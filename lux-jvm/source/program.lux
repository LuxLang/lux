(.module:
  [lux (#- Definition)
   [program (#+ program:)]
   ["@" target]
   ["." ffi (#+ import:)]
   [abstract
    [monad (#+ do)]]
   [control
    ["." io (#+ IO)]
    ["." try (#+ Try)]
    [concurrency
     ["." promise (#+ Promise)]]]
   [data
    ["." product]
    [text
     ["%" format (#+ format)]]
    [collection
     [array (#+ Array)]
     ["." dictionary]]]
   ["." world #_
    ["." file]
    ["#/." program]]
   [target
    [jvm
     [bytecode (#+ Bytecode)]]]
   [tool
    [compiler
     [default
      ["." platform (#+ Platform)]]
     [meta
      ["." packager #_
       ["#" jvm]]]
     [language
      [lux
       [analysis
        [macro (#+ Expander)]]
       [phase
        [extension (#+ Phase Bundle Operation Handler Extender)
         ["." analysis #_
          ["#" jvm]]
         ## ["." generation #_
         ##  ["#" jvm]]
         ## ["." directive #_
         ##  ["#" jvm]]
         ]
        [generation
         ["." jvm #_
          ["#/." runtime]
          ## ["#/." host]
          ]]]]]]]]
  [program
   ["/" compositor
    ["/." cli]
    ["/." static]]]
  [luxc
   [lang
    [host
     ["_" jvm]]
    ["." directive #_
     ["#" jvm]]
    [translation
     ["." jvm
      ["." runtime]
      ["." expression]
      ["#/." program]
      ["translation" extension]]]]])

(import: java/lang/reflect/Method
  ["#::."
   (invoke [java/lang/Object [java/lang/Object]] #try java/lang/Object)])

(import: (java/lang/Class c)
  ["#::."
   (getMethod [java/lang/String [(java/lang/Class java/lang/Object)]] #try java/lang/reflect/Method)])

(import: java/lang/Object
  ["#::."
   (getClass [] (java/lang/Class java/lang/Object))])

(def: _object_class
  (java/lang/Class java/lang/Object)
  (ffi.class_for java/lang/Object))

(def: _apply2_args
  (Array (java/lang/Class java/lang/Object))
  (|> (ffi.array (java/lang/Class java/lang/Object) 2)
      (ffi.array_write 0 _object_class)
      (ffi.array_write 1 _object_class)))

(def: _apply5_args
  (Array (java/lang/Class java/lang/Object))
  (|> (ffi.array (java/lang/Class java/lang/Object) 5)
      (ffi.array_write 0 _object_class)
      (ffi.array_write 1 _object_class)
      (ffi.array_write 2 _object_class)
      (ffi.array_write 3 _object_class)
      (ffi.array_write 4 _object_class)))

(def: #export (expander macro inputs lux)
  Expander
  (do try.monad
    [apply_method (|> macro
                      (:coerce java/lang/Object)
                      (java/lang/Object::getClass)
                      (java/lang/Class::getMethod "apply" _apply2_args))]
    (:coerce (Try (Try [Lux (List Code)]))
             (java/lang/reflect/Method::invoke
              (:coerce java/lang/Object macro)
              (|> (ffi.array java/lang/Object 2)
                  (ffi.array_write 0 (:coerce java/lang/Object inputs))
                  (ffi.array_write 1 (:coerce java/lang/Object lux)))
              apply_method))))

(def: #export platform
  ## (IO (Platform Anchor (Bytecode Any) Definition))
  (IO (Platform _.Anchor _.Inst _.Definition))
  (do io.monad
    [## host jvm/host.host
     host jvm.host]
    (wrap {#platform.&file_system (file.async file.default)
           #platform.host host
           ## #platform.phase jvm.generate
           #platform.phase expression.translate
           ## #platform.runtime runtime.generate
           #platform.runtime runtime.translate
           #platform.write product.right})))

(def: extender
  Extender
  ## TODO: Stop relying on coercions ASAP.
  (<| (:coerce Extender)
      (function (@self handler))
      (:coerce Handler)
      (function (@self name phase))
      (:coerce Phase)
      (function (@self archive parameters))
      (:coerce Operation)
      (function (@self state))
      (:coerce Try)
      try.assume
      (:coerce Try)
      (do try.monad
        [method (|> handler
                    (:coerce java/lang/Object)
                    (java/lang/Object::getClass)
                    (java/lang/Class::getMethod "apply" _apply5_args))]
        (java/lang/reflect/Method::invoke
         (:coerce java/lang/Object handler)
         (|> (ffi.array java/lang/Object 5)
             (ffi.array_write 0 (:coerce java/lang/Object name))
             (ffi.array_write 1 (:coerce java/lang/Object phase))
             (ffi.array_write 2 (:coerce java/lang/Object archive))
             (ffi.array_write 3 (:coerce java/lang/Object parameters))
             (ffi.array_write 4 (:coerce java/lang/Object state)))
         method))))

(def: (declare_success! _)
  (-> Any (Promise Any))
  (promise.future (\ world/program.default exit +0)))

(program: [{service /cli.service}]
  (let [static {#/static.host @.jvm
                #/static.host_module_extension ".jvm"
                #/static.target (/cli.target service)
                #/static.artifact_extension ".class"}]
    (exec (do promise.monad
            [_ (/.compiler {#/static.host @.jvm
                            #/static.host_module_extension ".jvm"
                            #/static.target (/cli.target service)
                            #/static.artifact_extension ".class"}
                           ..expander
                           analysis.bundle
                           ..platform
                           ## generation.bundle
                           translation.bundle
                           (directive.bundle ..extender)
                           (jvm/program.program jvm/runtime.class_name)
                           [_.Anchor _.Inst _.Definition]
                           ..extender
                           service
                           [(packager.package static)
                            (format (/cli.target service) (\ file.default separator) "program.jar")])]
            (..declare_success! []))
      (io.io []))))
