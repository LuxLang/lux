(.module:
  [library
   [lux "*"
    ... [abstract
    ...  [monad {"+" [do]}]]
    ... [control
    ...  ["[0]" try {"+" [Try]}]
    ...  ["ex" exception {"+" [exception:]}]
    ...  ["[0]" io]]
    ... [data
    ...  [binary {"+" [Binary]}]
    ...  ["[0]" text ("[1]/[0]" hash)
    ...   format]
    ...  [collection
    ...   ["[0]" dictionary {"+" [Dictionary]}]]]
    ... ["[0]" macro]
    ... [host {"+" [import:]}]
    ... [tool
    ...  [compiler
    ...   [reference {"+" [Register]}]
    ...   ["[0]" name]
    ...   ["[0]" phase]]]
    ]]
  ... [luxc
  ...  [lang
  ...   [host
  ...    ["[0]" jvm
  ...     [type]]]]]
  )

... (def: .public (with-artifacts action)
...   (All (_ a) (-> (Meta a) (Meta [Artifacts a])))
...   (function (_ state)
...     (case (action (revised@ #.host
...                             (|>> (:coerce Host)
...                                  (with@ #artifacts (dictionary.new text.hash))
...                                  (:coerce Nothing))
...                             state))
...       {#try.Success [state' output]}
...       {#try.Success [(revised@ #.host
...                                (|>> (:coerce Host)
...                                     (with@ #artifacts (|> (value@ #.host state) (:coerce Host) (value@ #artifacts)))
...                                     (:coerce Nothing))
...                                state')
...                      [(|> state' (value@ #.host) (:coerce Host) (value@ #artifacts))
...                       output]]}

...       {#try.Failure error}
...       {#try.Failure error})))

... (def: .public (load-definition state)
...   (-> Lux (-> Name Binary (Try Any)))
...   (function (_ (^@ def-name [def-module def-name]) def-bytecode)
...     (let [normal-name (format (name.normalize def-name) (%n (text/hash def-name)))
...           class-name (format (text.replace-all "/" "." def-module) "." normal-name)]
...       (<| (macro.result state)
...           (do macro.monad
...             [_ (..store-class class-name def-bytecode)
...              class (..load-class class-name)]
...             (case (do try.monad
...                     [field (Class::getField [..value-field] class)]
...                     (Field::get [#.None] field))
...               {#try.Success {#.Some def-value}}
...               (wrap def-value)

...               {#try.Success #.None}
...               (phase.throw invalid-definition-value (%name def-name))

...               {#try.Failure error}
...               (phase.throw cannot-load-definition
...                            (format "Definition: " (%name def-name) "\n"
...                                    "Error:\n"
...                                    error))))))))
