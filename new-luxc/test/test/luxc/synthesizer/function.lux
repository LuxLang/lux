(;module:
  lux
  (lux [io]
       (control monad
                pipe)
       (data [product]
             (coll [list]))
       ["r" math/random "r/" Monad<Random>]
       test)
  (luxc (lang ["la" analysis]
              ["ls" synthesis])
        (analyser [";A" structure])
        [synthesizer])
  (.. common))

(test: "Function application."
  [num-args (|> r;nat (:: @ map (|>. (n.% +10) (n.max +1))))
   funcA gen-primitive
   argsA (r;list num-args gen-primitive)]
  ($_ seq
      (assert "Can synthesize function application."
              (|> (synthesizer;synthesize (la;apply argsA funcA))
                  (case> (#ls;Call funcS argsS)
                         (and (corresponds? funcA funcS)
                              (list;every? (product;uncurry corresponds?)
                                           (list;zip2 argsA argsS)))
                         
                         _
                         false)))
      (assert "Function application on no arguments just synthesizes to the function itself."
              (|> (synthesizer;synthesize (la;apply (list) funcA))
                  (corresponds? funcA)))
      ))
