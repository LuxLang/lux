(;module:
  lux
  (lux [io]
       (control monad
                pipe)
       (data ["E" error]
             [product]
             (coll [list "L/" Functor<List>]))
       ["R" math/random "R/" Monad<Random>]
       [type "Type/" Eq<Type>]
       [macro #+ Monad<Lux>]
       test)
  (luxc ["&" base]
        (lang ["~" analysis])
        [analyser]
        (analyser ["@" struct]
                  ["@;" common]))
  (.. common))

(def: analyse
  &;Analyser
  (analyser;analyser (:!! [])))

(test: "Tuples"
  [size (|> R;nat (:: @ map (|>. (n.% +10) (n.max +2))))
   primitives (R;list size gen-simple-primitive)]
  ($_ seq
      (assert "Can analyse tuple."
              (|> (@common;with-unknown-type
                    (@;analyse-tuple analyse (L/map product;right primitives)))
                  (macro;run init-compiler)
                  (case> (#E;Success [_type (#~;Tuple elems)])
                         (and (Type/= (type;tuple (L/map product;left primitives))
                                      _type)
                              (n.= size (list;size elems)))

                         _
                         false))
              )))
