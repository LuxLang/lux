(.module:
  [lux #*
   [control
    [monad (#+ do)]
    pipe]
   [data
    ["e" error]
    [bit ("bit/." Equivalence<Bit>)]
    [number ("frac/." Number<Frac> Interval<Frac>)
     ["." i64]]
    ["." text ("text/." Equivalence<Text>)
     format]
    [collection
     ["." list]]]
   [math
    ["r" random]]
   [compiler
    [default
     ["." reference]
     [phase
      ["." synthesis]]]]
   test]
  [test
   [luxc
    ["." common (#+ Runner)]]])

(def: (bit-spec run)
  (-> Runner Test)
  (do r.Monad<Random>
    [param r.i64
     subject r.i64]
    (with-expansions [<binary> (do-template [<name> <reference> <param-expr>]
                                 [(test <name>
                                        (|> (run (#synthesis.Extension <name> (list (synthesis.i64 subject)
                                                                                    (synthesis.i64 param))))
                                            (case> (#e.Success valueT)
                                                   (n/= (<reference> param subject) (:coerce Nat valueT))

                                                   (#e.Error error)
                                                   (exec (log! error)
                                                     #0))
                                            (let [param <param-expr>])))]

                                 ["lux bit and"                 i64.and                 param]
                                 ["lux bit or"                  i64.or                  param]
                                 ["lux bit xor"                 i64.xor                 param]
                                 ["lux bit left-shift"          i64.left-shift          (n/% 64 param)]
                                 ["lux bit logical-right-shift" i64.logical-right-shift (n/% 64 param)]
                                 )]
      ($_ seq
          <binary>
          (test "lux bit arithmetic-right-shift"
                (|> (run (#synthesis.Extension "lux bit arithmetic-right-shift"
                                               (list (synthesis.i64 subject)
                                                     (synthesis.i64 param))))
                    (case> (#e.Success valueT)
                           ("lux i64 ="
                            (i64.arithmetic-right-shift param subject)
                            (:coerce I64 valueT))

                           (#e.Error error)
                           (exec (log! error)
                             #0))
                    (let [param (n/% 64 param)])))
          ))))

(def: (i64-spec run)
  (-> Runner Test)
  (do r.Monad<Random>
    [param (|> r.i64 (r.filter (|>> ("lux i64 =" 0) not)))
     subject r.i64]
    (`` ($_ seq
            (~~ (do-template [<name> <type> <prepare> <comp> <subject-expr>]
                  [(test <name>
                         (|> (run (#synthesis.Extension <name> (list (synthesis.i64 subject))))
                             (case> (#e.Success valueT)
                                    (<comp> (<prepare> subject) (:coerce <type> valueT))

                                    (#e.Error error)
                                    (exec (log! error)
                                      #0))
                             (let [subject <subject-expr>])))]

                  ["lux i64 to-frac" Frac int-to-frac f/= subject]
                  ["lux i64 char"    Text (|>> (:coerce Nat) text.from-code) text/= (|> subject
                                                                                        (:coerce Nat)
                                                                                        (n/% (i64.left-shift 8 1))
                                                                                        (:coerce Int))]
                  ))
            (~~ (do-template [<name> <reference> <outputT> <comp>]
                  [(test <name>
                         (exec (log! <name>)
                           (|> (run (#synthesis.Extension <name> (list (synthesis.i64 subject)
                                                                       (synthesis.i64 param))))
                               (case> (#e.Success valueT)
                                      (<comp> (<reference> param subject) (:coerce <outputT> valueT))

                                      (#e.Error error)
                                      (exec (log! error)
                                        #0)))))]

                  ["lux i64 +" i/+ Int  i/=]
                  ["lux i64 -" i/- Int  i/=]
                  ["lux i64 *" i/* Int  i/=]
                  ["lux i64 /" i// Int  i/=]
                  ["lux i64 %" i/% Int  i/=]
                  ["lux i64 =" i/= Bit bit/=]
                  ["lux i64 <" i/< Bit bit/=]
                  ))
            ))))

(def: (f64-spec/0 run)
  (-> Runner Test)
  (do r.Monad<Random>
    [param (|> r.frac (r.filter (|>> (f/= +0.0) not)))
     subject r.frac]
    (with-expansions [<binary> (do-template [<name> <reference> <outputT> <comp>]
                                 [(test <name>
                                        (|> (run (#synthesis.Extension <name> (list (synthesis.f64 subject)
                                                                                    (synthesis.f64 param))))
                                            (case> (#e.Success valueT)
                                                   (<comp> (<reference> param subject) (:coerce <outputT> valueT))

                                                   _
                                                   #0)))]

                                 ["lux f64 +" f/+ Frac f/=]
                                 ["lux f64 -" f/- Frac f/=]
                                 ["lux f64 *" f/* Frac f/=]
                                 ["lux f64 /" f// Frac f/=]
                                 ["lux f64 %" f/% Frac f/=]
                                 ["lux f64 =" f/= Bit bit/=]
                                 ["lux f64 <" f/< Bit bit/=]
                                 )]
      ($_ seq
          <binary>
          ))))

(def: (f64-spec/1 run)
  (-> Runner Test)
  (do r.Monad<Random>
    [subject r.frac]
    (`` ($_ seq
            (~~ (do-template [<name> <test>]
                  [(test <name>
                         (|> (run (#synthesis.Extension <name> (list)))
                             (case> (#e.Success valueT)
                                    (<test> (:coerce Frac valueT))

                                    _
                                    #0)))]

                  ["lux f64 min" (f/= frac/bottom)]
                  ["lux f64 max" (f/= frac/top)]
                  ["lux f64 smallest" (f/= ("lux frac smallest"))]
                  ))
            (~~ (do-template [<forward> <backward> <test>]
                  [(test <forward>
                         (|> (run (|> subject synthesis.f64
                                      (list) (#synthesis.Extension <forward>)
                                      (list) (#synthesis.Extension <backward>)))
                             (case> (#e.Success valueT)
                                    (|> valueT (:coerce Frac) (f/- subject) frac/abs <test>)

                                    (#e.Error error)
                                    (exec (log! error)
                                      #0))))]

                  ["lux f64 to-int" "lux i64 to-frac" (f/< +1.0)]))
            ))))

(def: (f64-spec run)
  (-> Runner Test)
  ($_ seq
      (f64-spec/0 run)
      (f64-spec/1 run)))

(def: (text-spec run)
  (-> Runner Test)
  (do r.Monad<Random>
    [sample-size (|> r.nat (:: @ map (|>> (n/% 10) (n/max 1))))
     sample0 (r.ascii/lower-alpha sample-size)
     sample1 (r.ascii/upper-alpha sample-size)
     sample2 (|> (r.ascii/alpha sample-size)
                 (r.filter (|>> (text/= sample1) not)))
     char-idx (|> r.nat (:: @ map (n/% sample-size)))
     #let [sample0S (synthesis.text sample0)
           sample1S (synthesis.text sample1)
           sample2S (synthesis.text sample2)
           concatenatedS (#synthesis.Extension "lux text concat" (list sample0S sample1S))
           pre-rep-once (format sample0 sample1)
           post-rep-once (format sample0 sample2)
           pre-rep-all (|> (list.repeat sample-size sample0) (text.join-with sample1))
           post-rep-all (|> (list.repeat sample-size sample0) (text.join-with sample2))]]
    ($_ seq
        (test "Can compare texts for equality."
              (and (|> (run (#synthesis.Extension "lux text =" (list sample0S sample0S)))
                       (case> (#e.Success valueV)
                              (:coerce Bit valueV)

                              _
                              #0))
                   (|> (run (#synthesis.Extension "lux text =" (list sample0S sample1S)))
                       (case> (#e.Success valueV)
                              (not (:coerce Bit valueV))

                              _
                              #0))))
        (test "Can compare texts for order."
              (|> (run (#synthesis.Extension "lux text <" (list sample1S sample0S)))
                  (case> (#e.Success valueV)
                         (:coerce Bit valueV)

                         _
                         #0)))
        (test "Can get length of text."
              (|> (run (#synthesis.Extension "lux text size" (list sample0S)))
                  (case> (#e.Success valueV)
                         (n/= sample-size (:coerce Nat valueV))

                         _
                         #0)))
        (test "Can concatenate text."
              (|> (run (#synthesis.Extension "lux text size" (list concatenatedS)))
                  (case> (#e.Success valueV)
                         (n/= (n/* 2 sample-size) (:coerce Nat valueV))

                         _
                         #0)))
        (test "Can find index of sub-text."
              (and (|> (run (#synthesis.Extension "lux text index"
                                                  (list concatenatedS sample0S
                                                        (synthesis.i64 0))))
                       (case> (^multi (#e.Success valueV)
                                      [(:coerce (Maybe Nat) valueV) (#.Some valueV)])
                              (n/= 0 valueV)

                              _
                              #0))
                   (|> (run (#synthesis.Extension "lux text index"
                                                  (list concatenatedS sample1S
                                                        (synthesis.i64 0))))
                       (case> (^multi (#e.Success valueV)
                                      [(:coerce (Maybe Nat) valueV) (#.Some valueV)])
                              (n/= sample-size valueV)

                              _
                              #0))))
        (let [test-clip (: (-> (I64 Any) (I64 Any) Text Bit)
                           (function (_ from to expected)
                             (|> (run (#synthesis.Extension "lux text clip"
                                                            (list concatenatedS
                                                                  (synthesis.i64 from)
                                                                  (synthesis.i64 to))))
                                 (case> (^multi (#e.Success valueV)
                                                [(:coerce (Maybe Text) valueV) (#.Some valueV)])
                                        (text/= expected valueV)

                                        _
                                        #0))))]
          (test "Can clip text to extract sub-text."
                (and (test-clip 0 sample-size sample0)
                     (test-clip sample-size (n/* 2 sample-size) sample1))))
        (test "Can extract individual characters from text."
              (|> (run (#synthesis.Extension "lux text char"
                                             (list sample0S
                                                   (synthesis.i64 char-idx))))
                  (case> (^multi (#e.Success valueV)
                                 [(:coerce (Maybe Int) valueV) (#.Some valueV)])
                         (text.contains? ("lux int char" valueV)
                                         sample0)

                         _
                         #0)))
        )))

(def: (array-spec run)
  (-> Runner Test)
  (do r.Monad<Random>
    [size (|> r.nat (:: @ map (|>> (n/% 10) (n/max 1))))
     idx (|> r.nat (:: @ map (n/% size)))
     value r.nat
     #let [array0S (#synthesis.Extension "lux array new"
                                         (list (synthesis.i64 size)))
           array1S (#synthesis.Extension "lux array put"
                                         (list array0S
                                               (synthesis.i64 idx)
                                               (synthesis.i64 value)))]]
    ($_ seq
        (test "Can get size of array."
              (|> (run (#synthesis.Extension "lux array size"
                                             (list array0S)))
                  (case> (#e.Success valueV)
                         (n/= size (:coerce Nat valueV))

                         (#e.Error error)
                         (exec (log! error)
                           #0))))
        (test "Can get element from array (if it exists)."
              (and (|> (run (#synthesis.Extension "lux array get"
                                                  (list array0S (synthesis.i64 idx))))
                       (case> (^multi (#e.Success valueV)
                                      [(:coerce (Maybe Nat) valueV) #.None])
                              #1

                              _
                              #0))
                   (|> (run (#synthesis.Extension "lux array get"
                                                  (list array1S (synthesis.i64 idx))))
                       (case> (^multi (#e.Success valueV)
                                      [(:coerce (Maybe Nat) valueV) (#.Some valueV)])
                              (n/= value valueV)

                              _
                              #0))))
        (test "Can remove element from array."
              (|> (run (#synthesis.Extension "lux array get"
                                             (list (#synthesis.Extension "lux array remove"
                                                                         (list array1S
                                                                               (synthesis.i64 idx)))
                                                   (synthesis.i64 idx))))
                  (case> (^multi (#e.Success valueV)
                                 [(:coerce (Maybe Nat) valueV) #.None])
                         #1

                         _
                         #0)))
        )))

(def: (io-spec run)
  (-> Runner Test)
  (do r.Monad<Random>
    [message (r.ascii/alpha 5)]
    ($_ seq
        (test "Can log messages."
              (|> (run (#synthesis.Extension "lux io log"
                                             (list (synthesis.text (format "LOG: " message)))))
                  (case> (#e.Success valueV)
                         #1

                         (#e.Error error)
                         (exec (log! error)
                           #0))))
        (test "Can throw runtime errors."
              (and (|> (run (#synthesis.Extension "lux try"
                                                  (list (synthesis.function/abstraction
                                                         {#synthesis.environment (list)
                                                          #synthesis.arity 1
                                                          #synthesis.body (#synthesis.Extension "lux io error"
                                                                                                (list (synthesis.text message)))}))))
                       (case> (^multi (#e.Success valueV)
                                      [(:coerce (e.Error Text) valueV) (#e.Error error)])
                              (text.contains? message error)

                              _
                              #0))
                   (|> (run (#synthesis.Extension "lux try"
                                                  (list (synthesis.function/abstraction
                                                         {#synthesis.environment (list)
                                                          #synthesis.arity 1
                                                          #synthesis.body (#synthesis.Extension "lux io error"
                                                                                                (list (synthesis.text message)))}))))
                       (case> (^multi (#e.Success valueV)
                                      [(:coerce (e.Error Text) valueV) (#e.Success valueV)])
                              (text/= message valueV)

                              _
                              #0))))
        (test "Can obtain current time in milli-seconds."
              (|> (run (synthesis.tuple (list (#synthesis.Extension "lux io current-time" (list))
                                              (#synthesis.Extension "lux io current-time" (list)))))
                  (case> (#e.Success valueV)
                         (let [[pre post] (:coerce [Nat Nat] valueV)]
                           (n/>= pre post))

                         (#e.Error error)
                         (exec (log! error)
                           #0))))
        )))

(def: (atom-spec run)
  (-> Runner Test)
  (do r.Monad<Random>
    [pre r.nat
     post (|> r.nat (r.filter (|>> (n/= pre) not)))
     #let [preS (synthesis.i64 pre)
           postS (synthesis.i64 post)
           atomS (#synthesis.Extension "lux atom new" (list preS))]]
    ($_ seq
        (test "Can read atoms."
              (|> (run (#synthesis.Extension "lux atom read" (list atomS)))
                  (case> (#e.Success valueV)
                         (n/= pre (:coerce Nat valueV))

                         (#e.Error error)
                         (exec (log! error)
                           #0))))
        (test "Can compare-and-swap atoms."
              (and (|> (run (synthesis.branch/let
                             [preS 0
                              (synthesis.branch/let
                               [(#synthesis.Extension "lux atom new"
                                                      (list (synthesis.variable/local 0)))
                                1
                                (synthesis.tuple
                                 (list (#synthesis.Extension "lux atom compare-and-swap"
                                                             (list (synthesis.variable/local 1)
                                                                   (synthesis.variable/local 0)
                                                                   postS))
                                       (#synthesis.Extension "lux atom read" (list (synthesis.variable/local 1)))))])]))
                       (case> (#e.Success valueV)
                              (let [[swapped? current-value] (:coerce [Bit Nat] valueV)]
                                (and swapped?
                                     (n/= post current-value)))

                              (#e.Error error)
                              (exec (log! error)
                                #0)))
                   (|> (run (synthesis.branch/let
                             [preS 0
                              (synthesis.branch/let
                               [(#synthesis.Extension "lux atom new"
                                                      (list (synthesis.variable/local 0)))
                                1
                                (synthesis.tuple
                                 (list (#synthesis.Extension "lux atom compare-and-swap"
                                                             (list (synthesis.variable/local 1)
                                                                   postS
                                                                   postS))
                                       (#synthesis.Extension "lux atom read" (list (synthesis.variable/local 1)))))])]))
                       (case> (#e.Success valueV)
                              (let [[swapped? current-value] (:coerce [Bit Nat] valueV)]
                                (and (not swapped?)
                                     (n/= pre current-value)))

                              (#e.Error error)
                              (exec (log! error)
                                #0)))))
        )))

(def: (box-spec run)
  (-> Runner Test)
  (do r.Monad<Random>
    [pre r.nat
     post (|> r.nat (r.filter (|>> (n/= pre) not)))
     #let [preS (synthesis.i64 pre)
           postS (synthesis.i64 post)
           boxS (#synthesis.Extension "lux box new"
                                      (list preS))]]
    ($_ seq
        (test "Can read boxes."
              (|> (run (#synthesis.Extension "lux box read" (list boxS)))
                  (case> (#e.Success valueV)
                         (n/= pre (:coerce Nat valueV))

                         (#e.Error error)
                         (exec (log! error)
                           #0))))
        (test "Can write boxes."
              (|> (run (synthesis.branch/let
                        [boxS
                         0
                         (synthesis.branch/let
                          [(#synthesis.Extension "lux box write"
                                                 (list postS (synthesis.variable/local 0)))
                           1
                           (#synthesis.Extension "lux box read"
                                                 (list (synthesis.variable/local 0)))])]))
                  (case> (#e.Success valueV)
                         (n/= post (:coerce Nat valueV))

                         (#e.Error error)
                         (exec (log! error)
                           #0))))
        )))

(def: (process-spec run)
  (-> Runner Test)
  ($_ seq
      (test "Can query the concurrency level of the machine."
            (|> (run (#synthesis.Extension "lux process parallelism-level" (list)))
                (case> (#e.Success valueV)
                       (n/>= 1 (:coerce Nat valueV))

                       (#e.Error error)
                       (exec (log! error)
                         #0))))
      (do r.Monad<Random>
        [delay (|> r.nat (:: @ map (n/% 10)))
         message (r.ascii/upper-alpha 5)]
        (test "Can schedule I/O operations for future execution."
              (|> (run (#synthesis.Extension "lux process schedule"
                                             (list (synthesis.i64 delay)
                                                   (synthesis.function/abstraction
                                                    {#synthesis.environment (list)
                                                     #synthesis.arity 1
                                                     #synthesis.body (#synthesis.Extension "lux io log"
                                                                                           (list (synthesis.text (format "SCHEDULE: " message))))}))))
                  (case> (#e.Success valueV)
                         #1

                         (#e.Error error)
                         (exec (log! error)
                           #0)))))
      ))

(def: (all-specs run)
  (-> Runner Test)
  ($_ seq
      (bit-spec run)
      (i64-spec run)
      (f64-spec run)
      (text-spec run)
      (array-spec run)
      (io-spec run)
      (atom-spec run)
      (box-spec run)
      (process-spec run)
      ))

(context: "[JVM] Common procedures."
  (<| (times 100)
      (all-specs common.run-jvm)))

## (context: "[JS] Common procedures."
##   (<| (times 100)
##       (all-specs common.run-js)))

## (context: "[Lua] Common procedures."
##   (<| (times 100)
##       (all-specs common.run-lua)))

## (context: "[Ruby] Common procedures."
##   (<| (times 100)
##       (all-specs common.run-ruby)))

## (context: "[Python] Common procedures."
##   (<| (times 100)
##       (all-specs common.run-python)))

## (context: "[R] Common procedures."
##   (<| (times 100)
##       (all-specs common.run-r)))

## (context: "[Scheme] Common procedures."
##   (<| (times 100)
##       (all-specs common.run-scheme)))

## (context: "[Common Lisp] Common procedures."
##   (<| (times 100)
##       (all-specs common.run-common-lisp)))

## (context: "[PHP] Common procedures."
##   (<| (times 100)
##       (all-specs common.run-php)))
