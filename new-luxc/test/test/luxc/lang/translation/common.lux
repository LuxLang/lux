(.module:
  lux
  (lux [io #+ IO]
       (control [monad #+ do]
                pipe)
       (data text/format
             [bit]
             ["e" error]
             [bool "bool/" Eq<Bool>]
             [text "text/" Eq<Text>]
             [number "nat/" Interval<Nat> "int/" Number<Int> Interval<Int> "frac/" Number<Frac> Interval<Frac> "deg/" Interval<Deg>]
             (coll ["a" array]
                   [list]))
       ["r" math/random]
       [macro]
       (macro [code])
       [host]
       test)
  (luxc [lang]
        (lang ["ls" synthesis]
              (translation (jvm [".T_jvm" eval]
                                [".T_jvm" expression]
                                [".T_jvm" runtime])
                           (js [".T_js" eval]
                               [".T_js" expression]
                               [".T_js" runtime]))))
  (test/luxc common))

(def: (bit-spec translate-expression eval translate-runtime init)
  (All [a]
    (-> (-> ls.Synthesis (Meta a)) (-> a (Meta Top)) (Meta Top) (IO Compiler)
        Test))
  (do r.Monad<Random>
    [param r.nat
     subject r.nat]
    (with-expansions [<binary> (do-template [<name> <reference> <param-expr>]
                                 [(test <name>
                                        (|> (do macro.Monad<Meta>
                                              [_ translate-runtime
                                               sampleJS (translate-expression (` (<name> (~ (code.nat subject))
                                                                                         (~ (code.nat param)))))]
                                              (eval sampleJS))
                                            (lang.with-current-module "")
                                            (macro.run (io.run init))
                                            (case> (#e.Success valueT)
                                                   (n/= (<reference> param subject) (:! Nat valueT))

                                                   (#e.Error error)
                                                   false)
                                            (let [param <param-expr>])))]

                                 ["lux bit and"                  bit.and param]
                                 ["lux bit or"                   bit.or param]
                                 ["lux bit xor"                  bit.xor param]
                                 ["lux bit shift-left"           bit.shift-left (n/% +64 param)]
                                 ["lux bit unsigned-shift-right" bit.shift-right (n/% +64 param)]
                                 )]
      ($_ seq
          (test "lux bit count"
                (|> (do macro.Monad<Meta>
                      [_ translate-runtime
                       sampleJS (translate-expression (` ("lux bit count" (~ (code.nat subject)))))]
                      (eval sampleJS))
                    (lang.with-current-module "")
                    (macro.run (io.run init))
                    (case> (#e.Success valueT)
                           (n/= (bit.count subject) (:! Nat valueT))

                           (#e.Error error)
                           false)))

          <binary>
          (test "lux bit shift-right"
                (|> (do macro.Monad<Meta>
                      [_ translate-runtime
                       sampleJS (translate-expression (` ("lux bit shift-right"
                                                          (~ (code.int (nat-to-int subject)))
                                                          (~ (code.nat param)))))]
                      (eval sampleJS))
                    (lang.with-current-module "")
                    (macro.run (io.run init))
                    (case> (#e.Success valueT)
                           (i/= (bit.signed-shift-right param (nat-to-int subject))
                                (:! Int valueT))

                           (#e.Error error)
                           false)
                    (let [param (n/% +64 param)])))
          ))))

(def: (nat-spec translate-expression eval translate-runtime init)
  (All [a]
    (-> (-> ls.Synthesis (Meta a)) (-> a (Meta Top)) (Meta Top) (IO Compiler)
        Test))
  (do r.Monad<Random>
    [param (|> r.nat (r.filter (|>> (n/= +0) not)))
     subject r.nat]
    (`` ($_ seq
            (~~ (do-template [<name> <reference>]
                  [(test <name>
                         (|> (do macro.Monad<Meta>
                               [_ translate-runtime
                                sampleJS (translate-expression (` (<name>)))]
                               (eval sampleJS))
                             (lang.with-current-module "")
                             (macro.run (io.run init))
                             (case> (#e.Success valueT)
                                    (n/= <reference> (:! Nat valueT))

                                    (#e.Error error)
                                    false)))]

                  ["lux nat min" nat/bottom]
                  ["lux nat max" nat/top]
                  ))
            (~~ (do-template [<name> <type> <prepare> <comp> <subject-expr>]
                  [(test <name>
                         (|> (do macro.Monad<Meta>
                               [_ translate-runtime
                                sampleJS (translate-expression (` (<name> (~ (code.nat subject)))))]
                               (eval sampleJS))
                             (lang.with-current-module "")
                             (macro.run (io.run init))
                             (case> (#e.Success valueT)
                                    (<comp> (<prepare> subject) (:! <type> valueT))

                                    (#e.Error error)
                                    false)
                             (let [subject <subject-expr>])))]

                  ["lux nat to-int" Int  nat-to-int     i/=    subject]
                  ["lux nat char"   Text text.from-code text/= (n/% (bit.shift-left +32 +1) subject)]
                  ))
            (~~ (do-template [<name> <reference> <outputT> <comp>]
                  [(test <name>
                         (|> (do macro.Monad<Meta>
                               [_ translate-runtime
                                sampleJS (translate-expression (` (<name> (~ (code.nat subject)) (~ (code.nat param)))))]
                               (eval sampleJS))
                             (lang.with-current-module "")
                             (macro.run (io.run init))
                             (case> (#e.Success valueT)
                                    (<comp> (<reference> param subject) (:! <outputT> valueT))

                                    _
                                    false)))]

                  ["lux nat +" n/+ Nat  n/=]
                  ["lux nat -" n/- Nat  n/=]
                  ["lux nat *" n/* Nat  n/=]
                  ["lux nat /" n// Nat  n/=]
                  ["lux nat %" n/% Nat  n/=]
                  ["lux nat =" n/= Bool bool/=]
                  ["lux nat <" n/< Bool bool/=]
                  ))
            ))))

(def: (int-spec translate-expression eval translate-runtime init)
  (All [a]
    (-> (-> ls.Synthesis (Meta a)) (-> a (Meta Top)) (Meta Top) (IO Compiler)
        Test))
  (do r.Monad<Random>
    [param (|> r.int (r.filter (|>> (i/= 0) not)))
     subject r.int]
    (with-expansions [<nullary> (do-template [<name> <reference>]
                                  [(test <name>
                                         (|> (do macro.Monad<Meta>
                                               [_ translate-runtime
                                                sampleJS (translate-expression (` (<name>)))]
                                               (eval sampleJS))
                                             (lang.with-current-module "")
                                             (macro.run (io.run init))
                                             (case> (#e.Success valueT)
                                                    (i/= <reference> (:! Int valueT))

                                                    (#e.Error error)
                                                    false)))]

                                  ["lux int min" int/bottom]
                                  ["lux int max" int/top]
                                  )
                      <unary> (do-template [<name> <type> <prepare> <comp>]
                                [(test <name>
                                       (|> (do macro.Monad<Meta>
                                             [_ translate-runtime
                                              sampleJS (translate-expression (` (<name> (~ (code.int subject)))))]
                                             (eval sampleJS))
                                           (lang.with-current-module "")
                                           (macro.run (io.run init))
                                           (case> (#e.Success valueT)
                                                  (<comp> (<prepare> subject) (:! <type> valueT))

                                                  (#e.Error error)
                                                  false)))]

                                ["lux int to-nat"  Nat  int-to-nat  n/=]
                                ["lux int to-frac" Frac int-to-frac f/=]
                                )
                      <binary> (do-template [<name> <reference> <outputT> <comp>]
                                 [(test <name>
                                        (|> (do macro.Monad<Meta>
                                              [_ translate-runtime
                                               sampleJS (translate-expression (` (<name> (~ (code.int subject)) (~ (code.int param)))))]
                                              (eval sampleJS))
                                            (lang.with-current-module "")
                                            (macro.run (io.run init))
                                            (case> (#e.Success valueT)
                                                   (<comp> (<reference> param subject) (:! <outputT> valueT))

                                                   _
                                                   false)))]

                                 ["lux int +" i/+ Int  i/=]
                                 ["lux int -" i/- Int  i/=]
                                 ["lux int *" i/* Int  i/=]
                                 ["lux int /" i// Int  i/=]
                                 ["lux int %" i/% Int  i/=]
                                 ["lux int =" i/= Bool bool/=]
                                 ["lux int <" i/< Bool bool/=]
                                 )]
      ($_ seq
          <nullary>
          <unary>
          <binary>
          ))))

(def: (frac-spec|0 translate-expression eval translate-runtime init)
  (All [a]
    (-> (-> ls.Synthesis (Meta a)) (-> a (Meta Top)) (Meta Top) (IO Compiler)
        Test))
  (do r.Monad<Random>
    [param (|> r.frac (r.filter (|>> (f/= 0.0) not)))
     subject r.frac]
    (with-expansions [<binary> (do-template [<name> <reference> <outputT> <comp>]
                                 [(test <name>
                                        (|> (do macro.Monad<Meta>
                                              [_ translate-runtime
                                               sampleJS (translate-expression (` (<name> (~ (code.frac subject)) (~ (code.frac param)))))]
                                              (eval sampleJS))
                                            (lang.with-current-module "")
                                            (macro.run (io.run init))
                                            (case> (#e.Success valueT)
                                                   (<comp> (<reference> param subject) (:! <outputT> valueT))

                                                   _
                                                   false)))]

                                 ["lux frac +" f/+ Frac f/=]
                                 ["lux frac -" f/- Frac f/=]
                                 ["lux frac *" f/* Frac f/=]
                                 ["lux frac /" f// Frac f/=]
                                 ["lux frac %" f/% Frac f/=]
                                 ["lux frac =" f/= Bool bool/=]
                                 ["lux frac <" f/< Bool bool/=]
                                 )]
      ($_ seq
          <binary>
          ))))

(def: (frac-spec|1 translate-expression eval translate-runtime init)
  (All [a]
    (-> (-> ls.Synthesis (Meta a)) (-> a (Meta Top)) (Meta Top) (IO Compiler)
        Test))
  (do r.Monad<Random>
    [param (|> r.frac (r.filter (|>> (f/= 0.0) not)))
     subject r.frac]
    (with-expansions [<nullary> (do-template [<name> <test>]
                                  [(test <name>
                                         (|> (do macro.Monad<Meta>
                                               [_ translate-runtime
                                                sampleJS (translate-expression (` (<name>)))]
                                               (eval sampleJS))
                                             (lang.with-current-module "")
                                             (macro.run (io.run init))
                                             (case> (#e.Success valueT)
                                                    (<test> (:! Frac valueT))

                                                    _
                                                    false)))]

                                  ["lux frac min" (f/= frac/bottom)]
                                  ["lux frac max" (f/= frac/top)]
                                  ["lux frac not-a-number" number.not-a-number?]
                                  ["lux frac positive-infinity" (f/= number.positive-infinity)]
                                  ["lux frac negative-infinity" (f/= number.negative-infinity)]
                                  ["lux frac smallest" (f/= ("lux frac smallest"))]
                                  )
                      <unary> (do-template [<forward> <backward> <test>]
                                [(test <forward>
                                       (|> (do macro.Monad<Meta>
                                             [_ translate-runtime
                                              sampleJS (translate-expression (` (<backward> (<forward> (~ (code.frac subject))))))]
                                             (eval sampleJS))
                                           (lang.with-current-module "")
                                           (macro.run (io.run init))
                                           (case> (#e.Success valueT)
                                                  (|> valueT (:! Frac) (f/- subject) frac/abs <test>)

                                                  (#e.Error error)
                                                  false)))]

                                ["lux frac to-int" "lux int to-frac" (f/< 1.0)]
                                ["lux frac to-deg" "lux deg to-frac" (f/<= 0.000000001)])]
      ($_ seq
          <nullary>
          <unary>
          (test "frac encode|decode"
                (|> (do macro.Monad<Meta>
                      [_ translate-runtime
                       sampleJS (translate-expression (` ("lux frac decode" ("lux frac encode" (~ (code.frac subject))))))]
                      (eval sampleJS))
                    (lang.with-current-module "")
                    (macro.run (io.run init))
                    (case> (^multi (#e.Success valueT)
                                   [(:! (Maybe Frac) valueT) (#.Some value)])
                           (f/= subject value)

                           _
                           false)))
          ))))

(def: (frac-spec translate-expression eval translate-runtime init)
  (All [a]
    (-> (-> ls.Synthesis (Meta a)) (-> a (Meta Top)) (Meta Top) (IO Compiler)
        Test))
  ($_ seq
      (frac-spec|0 translate-expression eval translate-runtime init)
      (frac-spec|1 translate-expression eval translate-runtime init)))

(def: deg-threshold
  {#.doc "1/(2^30)"}
  Deg
  .000000001)

(def: (above-threshold value)
  (-> Deg Deg)
  (if (d/< deg-threshold value)
    (d/+ deg-threshold value)
    value))

(def: (deg-difference reference sample)
  (-> Deg Deg Deg)
  (if (d/> reference sample)
    (d/- reference sample)
    (d/- sample reference)))

(def: (deg-spec translate-expression eval translate-runtime init)
  (All [a]
    (-> (-> ls.Synthesis (Meta a)) (-> a (Meta Top)) (Meta Top) (IO Compiler)
        Test))
  (do r.Monad<Random>
    [param (|> r.deg (:: @ map above-threshold))
     special r.nat
     subject (|> r.deg (:: @ map above-threshold))]
    (`` ($_ seq
            (~~ (do-template [<name> <reference>]
                  [(test <name>
                         (|> (do macro.Monad<Meta>
                               [_ translate-runtime
                                sampleJS (translate-expression (` (<name>)))]
                               (eval sampleJS))
                             (lang.with-current-module "")
                             (macro.run (io.run init))
                             (case> (#e.Success valueT)
                                    (d/= <reference> (:! Deg valueT))

                                    _
                                    false)))]

                  ["lux deg min" deg/bottom]
                  ["lux deg max" deg/top]
                  ))
            (~~ (do-template [<forward> <backward> <type>]
                  [(test <forward>
                         (|> (do macro.Monad<Meta>
                               [_ translate-runtime
                                sampleJS (translate-expression (` (<backward> (<forward> (~ (code.deg subject))))))]
                               (eval sampleJS))
                             (lang.with-current-module "")
                             (macro.run (io.run init))
                             (case> (#e.Success valueV)
                                    (d/<= deg-threshold (deg-difference subject (:! <type> valueV)))

                                    _
                                    false)))]

                  ["lux deg to-frac" "lux frac to-deg" Deg]
                  ))
            (~~ (do-template [<name> <reference> <outputT> <comp>]
                  [(test <name>
                         (|> (do macro.Monad<Meta>
                               [_ translate-runtime
                                sampleJS (translate-expression (` (<name> (~ (code.deg subject)) (~ (code.deg param)))))]
                               (eval sampleJS))
                             (lang.with-current-module "")
                             (macro.run (io.run init))
                             (case> (#e.Success valueT)
                                    (<comp> (<reference> param subject) (:! <outputT> valueT))

                                    _
                                    false)))]

                  ["lux deg +" d/+ Deg  d/=]
                  ["lux deg -" d/- Deg  d/=]
                  ["lux deg *" d/* Deg  d/=]
                  ["lux deg /" d// Deg  d/=]
                  ["lux deg %" d/% Deg  d/=]
                  ["lux deg =" d/= Bool bool/=]
                  ["lux deg <" d/< Bool bool/=]
                  ))
            (~~ (do-template [<name> <reference> <outputT> <comp>]
                  [(test <name>
                         (|> (do macro.Monad<Meta>
                               [_ translate-runtime
                                sampleJS (translate-expression (` (<name> (~ (code.deg subject)) (~ (code.nat special)))))]
                               (eval sampleJS))
                             (lang.with-current-module "")
                             (macro.run (io.run init))
                             (case> (#e.Success valueT)
                                    (<comp> (<reference> special subject) (:! <outputT> valueT))

                                    _
                                    false)))]

                  ["lux deg scale"      d/scale      Deg d/=]
                  ["lux deg reciprocal" d/reciprocal Deg d/=]
                  ))
            ))))

## Bit
(context: "[JVM] Bit procedures"
  (<| (times +100)
      (bit-spec expressionT_jvm.translate evalT_jvm.eval runtimeT_jvm.translate init-jvm)))

(context: "[JS] Bit procedures"
  (<| (times +100)
      (bit-spec expressionT_js.translate evalT_js.eval runtimeT_js.translate init-js)))

## Nat
(context: "[JVM] Nat procedures"
  (<| (times +100)
      (nat-spec expressionT_jvm.translate evalT_jvm.eval runtimeT_jvm.translate init-jvm)))

(context: "[JS] Nat procedures"
  (<| (times +100)
      (nat-spec expressionT_js.translate evalT_js.eval runtimeT_js.translate init-js)))

## Int
(context: "[JVM] Int procedures"
  (<| (times +100)
      (int-spec expressionT_jvm.translate evalT_jvm.eval runtimeT_jvm.translate init-jvm)))

(context: "[JS] Int procedures"
  (<| (times +100)
      (int-spec expressionT_js.translate evalT_js.eval runtimeT_js.translate init-js)))

## Frac
(context: "[JVM] Frac procedures"
  (<| (times +100)
      (frac-spec expressionT_jvm.translate evalT_jvm.eval runtimeT_jvm.translate init-jvm)))

(context: "[JS] Frac procedures"
  (<| (times +100)
      (frac-spec expressionT_js.translate evalT_js.eval runtimeT_js.translate init-js)))

## Deg
(context: "[JVM] Deg procedures"
  (<| (times +100)
      (deg-spec expressionT_jvm.translate evalT_jvm.eval runtimeT_jvm.translate init-jvm)))

(context: "[JS] Deg procedures"
  (<| (times +100)
      (deg-spec expressionT_js.translate evalT_js.eval runtimeT_js.translate init-js)))
