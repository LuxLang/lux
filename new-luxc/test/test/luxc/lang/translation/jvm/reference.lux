(.module:
  lux
  (lux [io]
       (control [monad #+ do]
                pipe)
       (data ["e" error]
             [text])
       ["r" math/random]
       [macro]
       (macro [code])
       test)
  (luxc [lang]
        (lang ["_." module]
              (host ["$" jvm]
                    (jvm ["$i" inst]))
              ["ls" synthesis]
              (translation (jvm [".T" statement]
                                [".T" eval]
                                [".T" expression]
                                [".T" case]
                                [".T" runtime]))))
  (test/luxc common))

(def: ident-part
  (r.Random Text)
  (|> (r.text +5)
      (r.filter (function [sample]
                  (not (or (text.contains? "/" sample)
                           (text.contains? "[" sample)
                           (text.contains? "]" sample)))))))

(context: "Definitions."
  (<| (times +100)
      (do @
        [module-name ident-part
         def-name ident-part
         def-value r.int
         #let [valueI (|>> ($i.long def-value) ($i.wrap #$.Long))]]
        ($_ seq
            (test "Can refer to definitions."
                  (|> (do macro.Monad<Meta>
                        [_ (_module.with-module +0 module-name
                             (statementT.translate-def def-name Int valueI (' {})))
                         sampleI (expressionT.translate (code.symbol [module-name def-name]))]
                        (evalT.eval sampleI))
                      (lang.with-current-module "")
                      (macro.run (init-compiler []))
                      (case> (#e.Success valueT)
                             (i/= def-value (:! Int valueT))

                             (#e.Error error)
                             false)))
            ))))

(context: "Variables."
  (<| (times +100)
      (do @
        [module-name (|> (r.text +5) (r.filter (|>> (text.contains? "/") not)))
         register (|> r.nat (:: @ map (n/% +100)))
         value r.int]
        ($_ seq
            (test "Can refer to local variables/registers."
                  (|> (do macro.Monad<Meta>
                        [sampleI (caseT.translate-let expressionT.translate
                                                      register
                                                      (code.int value)
                                                      (` ((~ (code.int (nat-to-int register))))))]
                        (evalT.eval sampleI))
                      (lang.with-current-module "")
                      (macro.run (init-compiler []))
                      (case> (#e.Success outputT)
                             (i/= value (:! Int outputT))

                             (#e.Error error)
                             false)))
            ))))
