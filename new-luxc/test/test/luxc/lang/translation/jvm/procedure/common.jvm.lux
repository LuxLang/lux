(.module:
  lux
  (lux [io]
       (control [monad #+ do]
                pipe)
       (data text/format
             [bit]
             ["e" error]
             [bool "bool/" Eq<Bool>]
             [text "text/" Eq<Text>]
             [number "nat/" Interval<Nat> "int/" Interval<Int> "real/" Interval<Frac> "deg/" Interval<Deg>]
             (coll ["a" array]
                   [list]))
       ["r" math/random]
       [macro]
       (macro [code])
       [host]
       test)
  (luxc [lang]
        (lang ["ls" synthesis]
              (translation (jvm [".T" expression]
                                ["@." eval]
                                ["@." runtime]
                                ["@." common]))))
  (test/luxc common))

(context: "Bit procedures"
  (<| (times +100)
      (do @
        [param r.nat
         subject r.nat]
        (with-expansions [<binary> (do-template [<name> <reference>]
                                     [(test <name>
                                            (|> (do macro.Monad<Meta>
                                                  [sampleI (expressionT.translate (` (<name> (~ (code.nat subject))
                                                                                             (~ (code.nat param)))))]
                                                  (@eval.eval sampleI))
                                                (lang.with-current-module "")
                                                (macro.run (init-compiler []))
                                                (case> (#e.Success valueT)
                                                       (n/= (<reference> param subject) (:! Nat valueT))

                                                       _
                                                       false)))]

                                     ["lux bit and"                  bit.and]
                                     ["lux bit or"                   bit.or]
                                     ["lux bit xor"                  bit.xor]
                                     ["lux bit shift-left"           bit.shift-left]
                                     ["lux bit unsigned-shift-right" bit.shift-right]
                                     )]
          ($_ seq
              (test "bit count"
                    (|> (do macro.Monad<Meta>
                          [sampleI (expressionT.translate (` ("lux bit count" (~ (code.nat subject)))))]
                          (@eval.eval sampleI))
                        (lang.with-current-module "")
                        (macro.run (init-compiler []))
                        (case> (#e.Success valueT)
                               (n/= (bit.count subject) (:! Nat valueT))

                               _
                               false)))

              <binary>
              (test "bit shift-right"
                    (|> (do macro.Monad<Meta>
                          [sampleI (expressionT.translate (` ("lux bit shift-right"
                                                              (~ (code.int (nat-to-int subject)))
                                                              (~ (code.nat param)))))]
                          (@eval.eval sampleI))
                        (lang.with-current-module "")
                        (macro.run (init-compiler []))
                        (case> (#e.Success valueT)
                               (i/= (bit.signed-shift-right param (nat-to-int subject))
                                    (:! Int valueT))

                               _
                               false)))
              )))))

(context: "Nat procedures"
  (<| (times +100)
      (do @
        [param (|> r.nat (r.filter (|>> (n/= +0) not)))
         subject r.nat]
        (`` ($_ seq
                (~~ (do-template [<name> <reference>]
                      [(test <name>
                             (|> (do macro.Monad<Meta>
                                   [sampleI (expressionT.translate (` (<name>)))]
                                   (@eval.eval sampleI))
                                 (lang.with-current-module "")
                                 (macro.run (init-compiler []))
                                 (case> (#e.Success valueT)
                                        (n/= <reference> (:! Nat valueT))

                                        _
                                        false)))]

                      ["lux nat min" nat/bottom]
                      ["lux nat max" nat/top]
                      ))
                (~~ (do-template [<name> <type> <prepare> <comp>]
                      [(test <name>
                             (|> (do macro.Monad<Meta>
                                   [sampleI (expressionT.translate (` (<name> (~ (code.nat subject)))))]
                                   (@eval.eval sampleI))
                                 (lang.with-current-module "")
                                 (macro.run (init-compiler []))
                                 (case> (#e.Success valueT)
                                        (<comp> (<prepare> subject) (:! <type> valueT))

                                        _
                                        false)))]

                      ["lux nat to-int" Int  nat-to-int     i/=]
                      ["lux nat char"   Text text.from-code text/=]
                      ))
                (~~ (do-template [<name> <reference> <outputT> <comp>]
                      [(test <name>
                             (|> (do macro.Monad<Meta>
                                   [runtime-bytecode @runtime.translate
                                    sampleI (expressionT.translate (` (<name> (~ (code.nat subject)) (~ (code.nat param)))))]
                                   (@eval.eval sampleI))
                                 (lang.with-current-module "")
                                 (macro.run (init-compiler []))
                                 (case> (#e.Success valueT)
                                        (<comp> (<reference> param subject) (:! <outputT> valueT))

                                        _
                                        false)))]

                      ["lux nat +" n/+ Nat  n/=]
                      ["lux nat -" n/- Nat  n/=]
                      ["lux nat *" n/* Nat  n/=]
                      ["lux nat /" n// Nat  n/=]
                      ["lux nat %" n/% Nat  n/=]
                      ["lux nat =" n/= Bool bool/=]
                      ["lux nat <" n/< Bool bool/=]
                      ))
                )))))

(context: "Int procedures"
  (<| (times +100)
      (do @
        [param (|> r.int (r.filter (|>> (i/= 0) not)))
         subject r.int]
        (with-expansions [<nullary> (do-template [<name> <reference>]
                                      [(test <name>
                                             (|> (do macro.Monad<Meta>
                                                   [sampleI (expressionT.translate (` (<name>)))]
                                                   (@eval.eval sampleI))
                                                 (lang.with-current-module "")
                                                 (macro.run (init-compiler []))
                                                 (case> (#e.Success valueT)
                                                        (i/= <reference> (:! Int valueT))

                                                        _
                                                        false)))]

                                      ["lux int min" int/bottom]
                                      ["lux int max" int/top]
                                      )
                          <unary> (do-template [<name> <type> <prepare> <comp>]
                                    [(test <name>
                                           (|> (do macro.Monad<Meta>
                                                 [sampleI (expressionT.translate (` (<name> (~ (code.int subject)))))]
                                                 (@eval.eval sampleI))
                                               (lang.with-current-module "")
                                               (macro.run (init-compiler []))
                                               (case> (#e.Success valueT)
                                                      (<comp> (<prepare> subject) (:! <type> valueT))

                                                      _
                                                      false)))]

                                    ["lux int to-nat"  Nat  int-to-nat  n/=]
                                    ["lux int to-frac" Frac int-to-frac f/=]
                                    )
                          <binary> (do-template [<name> <reference> <outputT> <comp>]
                                     [(test <name>
                                            (|> (do macro.Monad<Meta>
                                                  [runtime-bytecode @runtime.translate
                                                   sampleI (expressionT.translate (` (<name> (~ (code.int subject)) (~ (code.int param)))))]
                                                  (@eval.eval sampleI))
                                                (lang.with-current-module "")
                                                (macro.run (init-compiler []))
                                                (case> (#e.Success valueT)
                                                       (<comp> (<reference> param subject) (:! <outputT> valueT))

                                                       _
                                                       false)))]

                                     ["lux int +" i/+ Int  i/=]
                                     ["lux int -" i/- Int  i/=]
                                     ["lux int *" i/* Int  i/=]
                                     ["lux int /" i// Int  i/=]
                                     ["lux int %" i/% Int  i/=]
                                     ["lux int =" i/= Bool bool/=]
                                     ["lux int <" i/< Bool bool/=]
                                     )]
          ($_ seq
              <nullary>
              <unary>
              <binary>
              )))))

(context: "Frac procedures [Part 1]"
  (<| (times +100)
      (do @
        [param (|> r.frac (r.filter (|>> (f/= 0.0) not)))
         subject r.frac]
        (with-expansions [<binary> (do-template [<name> <reference> <outputT> <comp>]
                                     [(test <name>
                                            (|> (do macro.Monad<Meta>
                                                  [runtime-bytecode @runtime.translate
                                                   sampleI (expressionT.translate (` (<name> (~ (code.frac subject)) (~ (code.frac param)))))]
                                                  (@eval.eval sampleI))
                                                (lang.with-current-module "")
                                                (macro.run (init-compiler []))
                                                (case> (#e.Success valueT)
                                                       (<comp> (<reference> param subject) (:! <outputT> valueT))

                                                       _
                                                       false)))]

                                     ["lux frac +" f/+ Frac f/=]
                                     ["lux frac -" f/- Frac f/=]
                                     ["lux frac *" f/* Frac f/=]
                                     ["lux frac /" f// Frac f/=]
                                     ["lux frac %" f/% Frac f/=]
                                     ["lux frac =" f/= Bool bool/=]
                                     ["lux frac <" f/< Bool bool/=]
                                     )]
          ($_ seq
              <binary>
              )))))

(context: "Frac procedures [Part 2]"
  (<| (times +100)
      (do @
        [param (|> r.frac (r.filter (|>> (f/= 0.0) not)))
         subject r.frac]
        (with-expansions [<nullary> (do-template [<name> <test>]
                                      [(test <name>
                                             (|> (do macro.Monad<Meta>
                                                   [sampleI (expressionT.translate (` (<name>)))]
                                                   (@eval.eval sampleI))
                                                 (lang.with-current-module "")
                                                 (macro.run (init-compiler []))
                                                 (case> (#e.Success valueT)
                                                        (<test> (:! Frac valueT))

                                                        _
                                                        false)))]

                                      ["lux frac min" (f/= real/bottom)]
                                      ["lux frac max" (f/= real/top)]
                                      ["lux frac not-a-number" number.not-a-number?]
                                      ["lux frac positive-infinity" (f/= number.positive-infinity)]
                                      ["lux frac negative-infinity" (f/= number.negative-infinity)]
                                      ["lux frac smallest" (f/= ("lux frac smallest"))]
                                      )
                          <unary> (do-template [<name> <type> <prepare> <comp>]
                                    [(test <name>
                                           (|> (do macro.Monad<Meta>
                                                 [runtime-bytecode @runtime.translate
                                                  sampleI (expressionT.translate (` (<name> (~ (code.frac subject)))))]
                                                 (@eval.eval sampleI))
                                               (lang.with-current-module "")
                                               (macro.run (init-compiler []))
                                               (case> (#e.Success valueT)
                                                      (<comp> (<prepare> subject) (:! <type> valueT))

                                                      _
                                                      false)))]

                                    ["lux frac to-int" Int frac-to-int i/=]
                                    ["lux frac to-deg" Deg frac-to-deg d/=]
                                    )]
          ($_ seq
              <nullary>
              <unary>
              (test "frac encode|decode"
                    (|> (do macro.Monad<Meta>
                          [runtime-bytecode @runtime.translate
                           sampleI (expressionT.translate (` ("lux frac decode" ("lux frac encode" (~ (code.frac subject))))))]
                          (@eval.eval sampleI))
                        (lang.with-current-module "")
                        (macro.run (init-compiler []))
                        (case> (^multi (#e.Success valueT)
                                       [(:! (Maybe Frac) valueT) (#.Some value)])
                               (f/= subject value)

                               _
                               false)))
              )))))

(def: (above-threshold value)
  (-> Deg Deg)
  (let [threshold .000000001 #( 1/(2^30) )#]
    (if (d/< threshold value)
      (d/+ threshold value)
      value)))

(context: "Deg procedures"
  (<| (times +100)
      (do @
        [param (|> r.deg (:: @ map above-threshold))
         special r.nat
         subject (|> r.deg (:: @ map above-threshold))]
        (`` ($_ seq
                (~~ (do-template [<name> <reference>]
                      [(test <name>
                             (|> (do macro.Monad<Meta>
                                   [sampleI (expressionT.translate (` (<name>)))]
                                   (@eval.eval sampleI))
                                 (lang.with-current-module "")
                                 (macro.run (init-compiler []))
                                 (case> (#e.Success valueT)
                                        (d/= <reference> (:! Deg valueT))

                                        _
                                        false)))]

                      ["lux deg min" deg/bottom]
                      ["lux deg max" deg/top]
                      ))
                (~~ (do-template [<name> <type> <prepare> <comp>]
                      [(test <name>
                             (|> (do macro.Monad<Meta>
                                   [runtime-bytecode @runtime.translate
                                    sampleI (expressionT.translate (` (<name> (~ (code.deg subject)))))]
                                   (@eval.eval sampleI))
                                 (lang.with-current-module "")
                                 (macro.run (init-compiler []))
                                 (case> (#e.Success valueT)
                                        (<comp> (<prepare> subject) (:! <type> valueT))

                                        _
                                        false)))]

                      ["lux deg to-frac" Frac deg-to-frac f/=]
                      ))
                (~~ (do-template [<name> <reference> <outputT> <comp>]
                      [(test <name>
                             (|> (do macro.Monad<Meta>
                                   [runtime-bytecode @runtime.translate
                                    sampleI (expressionT.translate (` (<name> (~ (code.deg subject)) (~ (code.deg param)))))]
                                   (@eval.eval sampleI))
                                 (lang.with-current-module "")
                                 (macro.run (init-compiler []))
                                 (case> (#e.Success valueT)
                                        (<comp> (<reference> param subject) (:! <outputT> valueT))

                                        _
                                        false)))]

                      ["lux deg +" d/+ Deg  d/=]
                      ["lux deg -" d/- Deg  d/=]
                      ["lux deg *" d/* Deg  d/=]
                      ["lux deg /" d// Deg  d/=]
                      ["lux deg %" d/% Deg  d/=]
                      ["lux deg =" d/= Bool bool/=]
                      ["lux deg <" d/< Bool bool/=]
                      ))
                (~~ (do-template [<name> <reference> <outputT> <comp>]
                      [(test <name>
                             (|> (do macro.Monad<Meta>
                                   [runtime-bytecode @runtime.translate
                                    sampleI (expressionT.translate (` (<name> (~ (code.deg subject)) (~ (code.nat special)))))]
                                   (@eval.eval sampleI))
                                 (lang.with-current-module "")
                                 (macro.run (init-compiler []))
                                 (case> (#e.Success valueT)
                                        (<comp> (<reference> special subject) (:! <outputT> valueT))

                                        _
                                        false)))]

                      ["lux deg scale"      d/scale      Deg d/=]
                      ["lux deg reciprocal" d/reciprocal Deg d/=]
                      ))
                )))))
