(.module:
  lux
  (lux [io #+ IO]
       (control [monad #+ do]
                pipe)
       (data ["e" error]
             [maybe]
             [bool "bool/" Eq<Bool>]
             [text "text/" Eq<Text>]
             text/format
             (coll [array]
                   [list]))
       ["r" math/random "r/" Monad<Random>]
       [macro]
       (macro [code])
       [host]
       test)
  (luxc [lang]
        (lang [".L" host]
              [synthesis #+ Synthesis]))
  (test/luxc common))

(host.import java/lang/Integer)
(host.import java/lang/Long)

(def: upper-alpha
  (r.Random Nat)
  (|> r.nat (:: r.Functor<Random> map (|>> (n/% +91) (n/max +65)))))

(def: gen-primitive
  (r.Random Synthesis)
  (r.either (r.either (r.either (r/wrap (' []))
                                (r/map code.bool r.bool))
                      (r.either (r/map code.nat r.nat)
                                (r/map code.int r.int)))
            (r.either (r.either (r/map code.deg r.deg)
                                (r/map code.frac r.frac))
                      (r/map code.text (r.text' upper-alpha +5)))))

(def: (corresponds? [prediction sample])
  (-> [Synthesis Top] Bool)
  (case prediction
    [_ (#.Tuple #.Nil)]
    (text/= hostL.unit (:! Text sample))

    (^template [<tag> <type> <test>]
      [_ (<tag> prediction')]
      (case (host.try (<test> prediction' (:! <type> sample)))
        (#e.Success result)
        result

        (#e.Error error)
        false))
    ([#.Bool Bool bool/=]
     [#.Nat  Nat n/=]
     [#.Int  Int i/=]
     [#.Deg  Deg d/=]
     [#.Frac Frac f/=]
     [#.Text Text text/=])

    _
    false
    ))

(def: (tuples-spec run)
  (-> (-> Synthesis (e.Error Top)) Test)
  (do r.Monad<Random>
    [size (|> r.nat (:: @ map (|>> (n/% +10) (n/max +2))))
     members (r.list size gen-primitive)]
    (test "Can translate tuple."
          (|> (run (code.tuple members))
              (case> (#e.Success valueT)
                     (let [valueT (:! (Array Top) valueT)]
                       (and (n/= size (array.size valueT))
                            (list.every? corresponds? (list.zip2 members (array.to-list valueT)))))

                     (#e.Error error)
                     (exec (log! error)
                       false))))))

(def: (variants-spec run)
  (-> (-> Synthesis (e.Error Top)) Test)
  (do r.Monad<Random>
    [num-tags (|> r.nat (:: @ map (|>> (n/% +10) (n/max +2))))
     tag (|> r.nat (:: @ map (n/% num-tags)))
     #let [last? (n/= (n/dec num-tags) tag)]
     member gen-primitive]
    (test "Can translate variant."
          (|> (run (` ((~ (code.nat tag)) (~ (code.bool last?)) (~ member))))
              (case> (#e.Success valueT)
                     (let [valueT (:! (Array Top) valueT)]
                       (and (n/= +3 (array.size valueT))
                            (let [_tag (:! Integer (maybe.assume (array.read +0 valueT)))
                                  _last? (array.read +1 valueT)
                                  _value (:! Top (maybe.assume (array.read +2 valueT)))]
                              (and (n/= tag (|> _tag host.int-to-long (:! Nat)))
                                   (case _last?
                                     (#.Some _last?')
                                     (and last? (text/= "" (:! Text _last?')))

                                     #.None
                                     (not last?))
                                   (corresponds? [member _value])))))

                     (#e.Error error)
                     (exec (log! error)
                       false))))))

(def: (structure-spec run)
  (-> (-> Synthesis (e.Error Top)) Test)
  ($_ seq
      (tuples-spec run)
      (variants-spec run)))

(context: "[JVM] Structures."
  (<| (times +100)
      (structure-spec run-jvm)))

(context: "[JS] Structures."
  (<| (times +100)
      (structure-spec run-js)))

(context: "[Lua] Structures."
  (<| (times +100)
      (structure-spec run-lua)))

(context: "[Ruby] Structures."
  (<| (times +100)
      (structure-spec run-ruby)))
