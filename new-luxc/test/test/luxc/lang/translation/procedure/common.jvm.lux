(;module:
  lux
  (lux [io]
       (control [monad #+ do]
                pipe)
       (data text/format
             [bit]
             ["e" error]
             [bool "bool/" Eq<Bool>]
             [text "text/" Eq<Text>]
             [number "nat/" Interval<Nat> "int/" Interval<Int> "real/" Interval<Frac> "deg/" Interval<Deg>]
             (coll ["a" array]
                   [list]))
       ["r" math/random]
       [meta]
       (meta [code])
       [host]
       test)
  (luxc (lang ["ls" synthesis]
              (translation [";T" expression]
                           ["@;" eval]
                           ["@;" runtime]
                           ["@;" common])))
  (test/luxc common))

(context: "Bit procedures"
  (<| (times +100)
      (do @
        [param r;nat
         subject r;nat]
        (with-expansions [<binary> (do-template [<name> <reference>]
                                     [(test <name>
                                            (|> (do meta;Monad<Meta>
                                                  [sampleI (expressionT;generate (` (<name> (~ (code;nat subject))
                                                                                            (~ (code;nat param)))))]
                                                  (@eval;eval sampleI))
                                                (meta;run (init-compiler []))
                                                (case> (#e;Success valueT)
                                                       (n.= (<reference> param subject) (:! Nat valueT))

                                                       _
                                                       false)))]

                                     ["bit and"                  bit;and]
                                     ["bit or"                   bit;or]
                                     ["bit xor"                  bit;xor]
                                     ["bit shift-left"           bit;shift-left]
                                     ["bit unsigned-shift-right" bit;shift-right]
                                     )]
          ($_ seq
              (test "bit count"
                    (|> (do meta;Monad<Meta>
                          [sampleI (expressionT;generate (` ("bit count" (~ (code;nat subject)))))]
                          (@eval;eval sampleI))
                        (meta;run (init-compiler []))
                        (case> (#e;Success valueT)
                               (n.= (bit;count subject) (:! Nat valueT))

                               _
                               false)))

              <binary>
              (test "bit shift-right"
                    (|> (do meta;Monad<Meta>
                          [sampleI (expressionT;generate (` ("bit shift-right"
                                                             (~ (code;int (nat-to-int subject)))
                                                             (~ (code;nat param)))))]
                          (@eval;eval sampleI))
                        (meta;run (init-compiler []))
                        (case> (#e;Success valueT)
                               (i.= (bit;signed-shift-right param (nat-to-int subject))
                                    (:! Int valueT))

                               _
                               false)))
              )))))

(context: "Nat procedures"
  (<| (times +100)
      (do @
        [param (|> r;nat (r;filter (|>. (n.= +0) not)))
         subject r;nat]
        (`` ($_ seq
                (~~ (do-template [<name> <reference>]
                      [(test <name>
                             (|> (do meta;Monad<Meta>
                                   [sampleI (expressionT;generate (` (<name>)))]
                                   (@eval;eval sampleI))
                                 (meta;run (init-compiler []))
                                 (case> (#e;Success valueT)
                                        (n.= <reference> (:! Nat valueT))

                                        _
                                        false)))]

                      ["nat min" nat/bottom]
                      ["nat max" nat/top]
                      ))
                (~~ (do-template [<name> <type> <prepare> <comp>]
                      [(test <name>
                             (|> (do meta;Monad<Meta>
                                   [sampleI (expressionT;generate (` (<name> (~ (code;nat subject)))))]
                                   (@eval;eval sampleI))
                                 (meta;run (init-compiler []))
                                 (case> (#e;Success valueT)
                                        (<comp> (<prepare> subject) (:! <type> valueT))

                                        _
                                        false)))]

                      ["nat to-int"  Int  nat-to-int     i.=]
                      ["nat to-char" Text text;from-code text/=]
                      ))
                (~~ (do-template [<name> <reference> <outputT> <comp>]
                      [(test <name>
                             (|> (do meta;Monad<Meta>
                                   [runtime-bytecode @runtime;generate
                                    sampleI (expressionT;generate (` (<name> (~ (code;nat subject)) (~ (code;nat param)))))]
                                   (@eval;eval sampleI))
                                 (meta;run (init-compiler []))
                                 (case> (#e;Success valueT)
                                        (<comp> (<reference> param subject) (:! <outputT> valueT))

                                        _
                                        false)))]

                      ["nat +" n.+ Nat  n.=]
                      ["nat -" n.- Nat  n.=]
                      ["nat *" n.* Nat  n.=]
                      ["nat /" n./ Nat  n.=]
                      ["nat %" n.% Nat  n.=]
                      ["nat =" n.= Bool bool/=]
                      ["nat <" n.< Bool bool/=]
                      ))
                )))))

(context: "Int procedures"
  (<| (times +100)
      (do @
        [param (|> r;int (r;filter (|>. (i.= 0) not)))
         subject r;int]
        (with-expansions [<nullary> (do-template [<name> <reference>]
                                      [(test <name>
                                             (|> (do meta;Monad<Meta>
                                                   [sampleI (expressionT;generate (` (<name>)))]
                                                   (@eval;eval sampleI))
                                                 (meta;run (init-compiler []))
                                                 (case> (#e;Success valueT)
                                                        (i.= <reference> (:! Int valueT))

                                                        _
                                                        false)))]

                                      ["int min" int/bottom]
                                      ["int max" int/top]
                                      )
                          <unary> (do-template [<name> <type> <prepare> <comp>]
                                    [(test <name>
                                           (|> (do meta;Monad<Meta>
                                                 [sampleI (expressionT;generate (` (<name> (~ (code;int subject)))))]
                                                 (@eval;eval sampleI))
                                               (meta;run (init-compiler []))
                                               (case> (#e;Success valueT)
                                                      (<comp> (<prepare> subject) (:! <type> valueT))

                                                      _
                                                      false)))]

                                    ["int to-nat"  Nat  int-to-nat  n.=]
                                    ["int to-frac" Frac int-to-frac f.=]
                                    )
                          <binary> (do-template [<name> <reference> <outputT> <comp>]
                                     [(test <name>
                                            (|> (do meta;Monad<Meta>
                                                  [runtime-bytecode @runtime;generate
                                                   sampleI (expressionT;generate (` (<name> (~ (code;int subject)) (~ (code;int param)))))]
                                                  (@eval;eval sampleI))
                                                (meta;run (init-compiler []))
                                                (case> (#e;Success valueT)
                                                       (<comp> (<reference> param subject) (:! <outputT> valueT))

                                                       _
                                                       false)))]

                                     ["int +" i.+ Int  i.=]
                                     ["int -" i.- Int  i.=]
                                     ["int *" i.* Int  i.=]
                                     ["int /" i./ Int  i.=]
                                     ["int %" i.% Int  i.=]
                                     ["int =" i.= Bool bool/=]
                                     ["int <" i.< Bool bool/=]
                                     )]
          ($_ seq
              <nullary>
              <unary>
              <binary>
              )))))

(context: "Frac procedures [Part 1]"
  (<| (times +100)
      (do @
        [param (|> r;frac (r;filter (|>. (f.= 0.0) not)))
         subject r;frac]
        (with-expansions [<binary> (do-template [<name> <reference> <outputT> <comp>]
                                     [(test <name>
                                            (|> (do meta;Monad<Meta>
                                                  [runtime-bytecode @runtime;generate
                                                   sampleI (expressionT;generate (` (<name> (~ (code;frac subject)) (~ (code;frac param)))))]
                                                  (@eval;eval sampleI))
                                                (meta;run (init-compiler []))
                                                (case> (#e;Success valueT)
                                                       (<comp> (<reference> param subject) (:! <outputT> valueT))

                                                       _
                                                       false)))]

                                     ["frac +" f.+ Frac f.=]
                                     ["frac -" f.- Frac f.=]
                                     ["frac *" f.* Frac f.=]
                                     ["frac /" f./ Frac f.=]
                                     ["frac %" f.% Frac f.=]
                                     ["frac =" f.= Bool bool/=]
                                     ["frac <" f.< Bool bool/=]
                                     )]
          ($_ seq
              <binary>
              )))))

(context: "Frac procedures [Part 2]"
  (<| (times +100)
      (do @
        [param (|> r;frac (r;filter (|>. (f.= 0.0) not)))
         subject r;frac]
        (with-expansions [<nullary> (do-template [<name> <test>]
                                      [(test <name>
                                             (|> (do meta;Monad<Meta>
                                                   [sampleI (expressionT;generate (` (<name>)))]
                                                   (@eval;eval sampleI))
                                                 (meta;run (init-compiler []))
                                                 (case> (#e;Success valueT)
                                                        (<test> (:! Frac valueT))

                                                        _
                                                        false)))]

                                      ["frac min" (f.= real/bottom)]
                                      ["frac max" (f.= real/top)]
                                      ["frac not-a-number" number;not-a-number?]
                                      ["frac positive-infinity" (f.= number;positive-infinity)]
                                      ["frac negative-infinity" (f.= number;negative-infinity)]
                                      ["frac smallest" (f.= (_lux_proc [ "frac" "smallest-value"] []))]
                                      )
                          <unary> (do-template [<name> <type> <prepare> <comp>]
                                    [(test <name>
                                           (|> (do meta;Monad<Meta>
                                                 [runtime-bytecode @runtime;generate
                                                  sampleI (expressionT;generate (` (<name> (~ (code;frac subject)))))]
                                                 (@eval;eval sampleI))
                                               (meta;run (init-compiler []))
                                               (case> (#e;Success valueT)
                                                      (<comp> (<prepare> subject) (:! <type> valueT))

                                                      _
                                                      false)))]

                                    ["frac to-int" Int frac-to-int i.=]
                                    ["frac to-deg" Deg frac-to-deg d.=]
                                    )]
          ($_ seq
              <nullary>
              <unary>
              (test "frac encode|decode"
                    (|> (do meta;Monad<Meta>
                          [runtime-bytecode @runtime;generate
                           sampleI (expressionT;generate (` ("frac decode" ("frac encode" (~ (code;frac subject))))))]
                          (@eval;eval sampleI))
                        (meta;run (init-compiler []))
                        (case> (^multi (#e;Success valueT)
                                       [(:! (Maybe Frac) valueT) (#;Some value)])
                               (f.= subject value)

                               _
                               false)))
              )))))

(def: (above-threshold value)
  (-> Deg Deg)
  (let [threshold .000000001 #( 1/(2^30) )#]
    (if (d.< threshold value)
      (d.+ threshold value)
      value)))

(context: "Deg procedures"
  (<| (times +100)
      (do @
        [param (|> r;deg (:: @ map above-threshold))
         special r;nat
         subject (|> r;deg (:: @ map above-threshold))]
        (`` ($_ seq
                (~~ (do-template [<name> <reference>]
                      [(test <name>
                             (|> (do meta;Monad<Meta>
                                   [sampleI (expressionT;generate (` (<name>)))]
                                   (@eval;eval sampleI))
                                 (meta;run (init-compiler []))
                                 (case> (#e;Success valueT)
                                        (d.= <reference> (:! Deg valueT))

                                        _
                                        false)))]

                      ["deg min" deg/bottom]
                      ["deg max" deg/top]
                      ))
                (~~ (do-template [<name> <type> <prepare> <comp>]
                      [(test <name>
                             (|> (do meta;Monad<Meta>
                                   [runtime-bytecode @runtime;generate
                                    sampleI (expressionT;generate (` (<name> (~ (code;deg subject)))))]
                                   (@eval;eval sampleI))
                                 (meta;run (init-compiler []))
                                 (case> (#e;Success valueT)
                                        (<comp> (<prepare> subject) (:! <type> valueT))

                                        _
                                        false)))]

                      ["deg to-frac" Frac deg-to-frac f.=]
                      ))
                (~~ (do-template [<name> <reference> <outputT> <comp>]
                      [(test <name>
                             (|> (do meta;Monad<Meta>
                                   [runtime-bytecode @runtime;generate
                                    sampleI (expressionT;generate (` (<name> (~ (code;deg subject)) (~ (code;deg param)))))]
                                   (@eval;eval sampleI))
                                 (meta;run (init-compiler []))
                                 (case> (#e;Success valueT)
                                        (<comp> (<reference> param subject) (:! <outputT> valueT))

                                        _
                                        false)))]

                      ["deg +" d.+ Deg  d.=]
                      ["deg -" d.- Deg  d.=]
                      ["deg *" d.* Deg  d.=]
                      ["deg /" d./ Deg  d.=]
                      ["deg %" d.% Deg  d.=]
                      ["deg =" d.= Bool bool/=]
                      ["deg <" d.< Bool bool/=]
                      ))
                (~~ (do-template [<name> <reference> <outputT> <comp>]
                      [(test <name>
                             (|> (do meta;Monad<Meta>
                                   [runtime-bytecode @runtime;generate
                                    sampleI (expressionT;generate (` (<name> (~ (code;deg subject)) (~ (code;nat special)))))]
                                   (@eval;eval sampleI))
                                 (meta;run (init-compiler []))
                                 (case> (#e;Success valueT)
                                        (<comp> (<reference> special subject) (:! <outputT> valueT))

                                        _
                                        false)))]

                      ["deg scale"      d.scale      Deg d.=]
                      ["deg reciprocal" d.reciprocal Deg d.=]
                      ))
                )))))
