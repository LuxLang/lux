(.module:
  [lux #*
   [control
    [monad (#+ do)]
    pipe]
   [data
    ["." maybe]
    ["." error (#+ Error)]
    [collection
     ["." list ("list/." Functor<List>)]]]
   [math
    ["r" random ("r/." Monad<Random>)]]
   [compiler
    [default
     ["." reference]
     [phase
      [analysis (#+ Arity)]
      ["." synthesis (#+ Synthesis)]]]]
   test]
  [test
   [luxc
    ["." common (#+ Runner)]]])

(def: max-arity Nat 10)

(def: arity
  (r.Random Arity)
  (|> r.nat (r/map (|>> (n/% max-arity) (n/max 1)))))

(def: gen-function
  (r.Random [Arity Nat Synthesis])
  (do r.Monad<Random>
    [arity arity
     arg (|> r.nat (:: @ map (n/% arity)))]
    (wrap [arity arg
           (synthesis.function/abstraction
            {#synthesis.environment (list)
             #synthesis.arity arity
             #synthesis.body (synthesis.variable/local arg)})])))

(def: upper-alpha-ascii
  (r.Random Nat)
  (|> r.nat (:: r.Functor<Random> map (|>> (n/% 26) (n/+ 65)))))

(def: #export (check reference)
  (-> Frac (Error Any) Bit)
  (|>> (case> (#error.Success valueT)
              (|> valueT (:coerce Frac) (f/= reference))

              (#error.Error error)
              (exec (log! error)
                #0))))

(def: (function-spec run)
  (-> Runner Test)
  (do r.Monad<Random>
    [[arity arg functionS] gen-function
     cut-off (|> r.nat (:: @ map (n/% arity)))
     args (r.list arity r.frac)
     #let [arg-value (maybe.assume (list.nth arg args))
           argsS (list/map (|>> synthesis.f64) args)
           last-arg (dec arity)
           cut-off (|> cut-off (n/min (dec last-arg)))]]
    ($_ seq
        (test "Can read arguments."
              (|> (run (synthesis.function/apply [functionS argsS]))
                  (check arg-value)))
        (test "Can partially apply functions."
              (or (n/= 1 arity)
                  (let [partial-arity (inc cut-off)
                        preS (list.take partial-arity argsS)
                        postS (list.drop partial-arity argsS)]
                    (|> (run (synthesis.function/apply {#synthesis.function (synthesis.function/apply {#synthesis.function functionS
                                                                                                       #synthesis.arguments preS})
                                                        #synthesis.arguments postS}))
                        (check arg-value)))))
        (test "Can read environment."
              (or (n/= 1 arity)
                  (let [environment (|> (list.n/range 0 cut-off)
                                        (list/map (|>> #reference.Local)))
                        arity::super (inc cut-off)
                        argument (if (n/<= cut-off arg)
                                   (synthesis.variable/foreign arg)
                                   (synthesis.variable/local (n/- (dec arity::super) arg)))
                        arity::sub (|> arity (n/- arity::super))
                        functionS (synthesis.function/abstraction
                                   {#synthesis.environment (list)
                                    #synthesis.arity arity::super
                                    #synthesis.body (synthesis.function/abstraction
                                                     {#synthesis.environment environment
                                                      #synthesis.arity arity::sub
                                                      #synthesis.body argument})})]
                    (|> (run (synthesis.function/apply [functionS argsS]))
                        (check arg-value)))))
        )))

(context: "[JVM] Function."
  (<| (times 100)
      (function-spec common.run-jvm)))

## (context: "[JS] Function."
##   (<| (times 100)
##       (function-spec common.run-js)))

## (context: "[Lua] Function."
##   (<| (times 100)
##       (function-spec common.run-lua)))

## (context: "[Ruby] Function."
##   (<| (times 100)
##       (function-spec common.run-ruby)))

## (context: "[Python] Function."
##   (<| (times 100)
##       (function-spec common.run-python)))

## (context: "[R] Function."
##   (<| (times 100)
##       (function-spec common.run-r)))

## (context: "[Scheme] Function."
##   (<| (times 100)
##       (function-spec common.run-scheme)))

## (context: "[Common Lisp] Function."
##   (<| (times 100)
##       (function-spec common.run-common-lisp)))

## (context: "[PHP] Function."
##   (<| (times 100)
##       (function-spec common.run-php)))
