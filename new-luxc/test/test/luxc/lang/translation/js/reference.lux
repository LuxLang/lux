(.module:
  lux
  (lux [io]
       (control [monad #+ do]
                pipe)
       (data ["e" error]
             [text])
       ["r" math/random]
       [macro]
       (macro [code])
       test)
  (luxc [lang]
        (lang ["_." module]
              ["ls" synthesis]
              (translation (js [".T" statement]
                               [".T" eval]
                               [".T" expression]
                               [".T" case]
                               [".T" runtime]))))
  (test/luxc common))

(def: upper-alpha-ascii
  (r.Random Nat)
  (|> r.nat (:: r.Functor<Random> map (|>> (n/% +91) (n/max +65)))))

(def: ident-part
  (r.Random Text)
  (|> (r.text' upper-alpha-ascii +5)
      (r.filter (function [sample]
                  (not (or (text.contains? "/" sample)
                           (text.contains? "[" sample)
                           (text.contains? "]" sample)))))))

(context: "Definitions."
  (<| (times +100)
      (do @
        [module-name ident-part
         def-name ident-part
         def-value r.int]
        ($_ seq
            (test "Can refer to definitions."
                  (|> (do macro.Monad<Meta>
                        [_ runtimeT.translate
                         valueJS (expressionT.translate (code.int def-value))
                         _ (_module.with-module +0 module-name
                             (statementT.translate-def def-name Int valueJS (' {})))
                         sampleJS (expressionT.translate (code.symbol [module-name def-name]))]
                        (evalT.eval sampleJS))
                      (lang.with-current-module "")
                      (macro.run (init-js []))
                      (case> (#e.Success valueT)
                             (i/= def-value (:! Int valueT))

                             (#e.Error error)
                             (exec (log! error)
                               false))))
            ))))

(context: "Variables."
  (<| (times +100)
      (do @
        [module-name (|> (r.text +5) (r.filter (|>> (text.contains? "/") not)))
         register (|> r.nat (:: @ map (n/% +100)))
         value r.int]
        ($_ seq
            (test "Can refer to local variables/registers."
                  (|> (do macro.Monad<Meta>
                        [_ runtimeT.translate
                         sampleJS (caseT.translate-let expressionT.translate
                                                       register
                                                       (code.int value)
                                                       (` ((~ (code.int (nat-to-int register))))))]
                        (evalT.eval sampleJS))
                      (lang.with-current-module "")
                      (macro.run (init-js []))
                      (case> (#e.Success outputT)
                             (i/= value (:! Int outputT))

                             (#e.Error error)
                             (exec (log! error)
                               false))))
            ))))
