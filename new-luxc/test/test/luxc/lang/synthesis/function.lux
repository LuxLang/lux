(;module:
  lux
  (lux [io]
       (control [monad #+ do]
                pipe)
       (data [product]
             [maybe]
             [number]
             text/format
             (coll [list "list/" Functor<List> Fold<List>]
                   [dict #+ Dict]
                   [set]))
       (macro [code])
       ["r" math/random "r/" Monad<Random>]
       test)
  (luxc (lang ["la" analysis]
              ["ls" synthesis]
              (synthesis [";S" expression])
              [";L" variable #+ Variable]))
  (.. common))

(def: gen-function//constant
  (r;Random [Nat la;Analysis la;Analysis])
  (r;rec
   (function [gen-function//constant]
     (do r;Monad<Random>
       [function? r;bool]
       (if function?
         (do @
           [[num-args outputA subA] gen-function//constant]
           (wrap [(n.inc num-args)
                  outputA
                  (` ("lux function" [] (~ subA)))]))
         (do @
           [outputA gen-primitive]
           (wrap [+0 outputA outputA])))))))

(def: (pick scope-size)
  (-> Nat (r;Random Nat))
  (|> r;nat (:: r;Monad<Random> map (n.% scope-size))))

(def: gen-function//captured
  (r;Random [Nat Int la;Analysis])
  (do r;Monad<Random>
    [num-locals (|> r;nat (:: @ map (|>. (n.% +100) (n.max +10))))
     #let [indices (list;n.range +0 (n.dec num-locals))
           absolute-env (list/map variableL;local indices)
           relative-env (list/map variableL;captured indices)]
     [total-args prediction bodyA] (: (r;Random [Nat Int la;Analysis])
                                      (loop [num-args +1
                                             global-env relative-env]
                                        (let [env-size (list;size global-env)
                                              resolver (list/fold (function [[idx var] resolver]
                                                                    (dict;put idx var resolver))
                                                                  (: (Dict Nat Int)
                                                                     (dict;new number;Hash<Nat>))
                                                                  (list;zip2 (list;n.range +0 (n.dec env-size))
                                                                             global-env))]
                                          (do @
                                            [nest? r;bool]
                                            (if nest?
                                              (do @
                                                [num-picks (:: @ map (n.max +1) (pick (n.inc env-size)))
                                                 picks (|> (r;set number;Hash<Nat> num-picks (pick env-size))
                                                           (:: @ map set;to-list))
                                                 [total-args prediction bodyA] (recur (n.inc num-args)
                                                                                      (list/map (function [pick] (maybe;assume (list;nth pick global-env)))
                                                                                                picks))]
                                                (wrap [total-args prediction (` ("lux function" [(~@ (list/map (|>. variableL;captured code;int) picks))]
                                                                                 (~ bodyA)))]))
                                              (do @
                                                [chosen (pick (list;size global-env))]
                                                (wrap [num-args
                                                       (maybe;assume (dict;get chosen resolver))
                                                       (la;var (variableL;captured chosen))])))))))]
    (wrap [total-args prediction (` ("lux function"
                                     [(~@ (list/map code;int absolute-env))]
                                     (~ bodyA)))])
    ))

(def: gen-function//local
  (r;Random [Nat Int la;Analysis])
  (loop [num-args +0
         nest? true]
    (if nest?
      (do r;Monad<Random>
        [nest?' r;bool
         [total-args prediction bodyA] (recur (n.inc num-args) nest?')]
        (wrap [total-args prediction (` ("lux function" [] (~ bodyA)))]))
      (do r;Monad<Random>
        [chosen (|> r;nat (:: @ map (|>. (n.% +100) (n.max +2))))]
        (wrap [num-args
               (|> chosen (n.+ (n.dec num-args)) nat-to-int)
               (la;var (variableL;local chosen))])))))

(context: "Function definition."
  (<| (times +100)
      (do @
        [[args1 prediction1 function1] gen-function//constant
         [args2 prediction2 function2] gen-function//captured
         [args3 prediction3 function3] gen-function//local]
        ($_ seq
            (test "Nested functions will get folded together."
                  (|> (expressionS;synthesize function1)
                      (case> (^ [_ (#;Form (list [_ (#;Text "lux function")] [_ (#;Nat args)] [_ (#;Tuple captured)] output))])
                             (and (n.= args1 args)
                                  (corresponds? prediction1 output))
                             
                             _
                             (n.= +0 args1))))
            (test "Folded functions provide direct access to captured variables."
                  (|> (expressionS;synthesize function2)
                      (case> (^ [_ (#;Form (list [_ (#;Text "lux function")] [_ (#;Nat args)] [_ (#;Tuple captured)]
                                                 [_ (#;Form (list [_ (#;Int output)]))]))])
                             (and (n.= args2 args)
                                  (i.= prediction2 output))
                             
                             _
                             false)))
            (test "Folded functions properly offset local variables."
                  (|> (expressionS;synthesize function3)
                      (case> (^ [_ (#;Form (list [_ (#;Text "lux function")] [_ (#;Nat args)] [_ (#;Tuple captured)]
                                                 [_ (#;Form (list [_ (#;Int output)]))]))])
                             (and (n.= args3 args)
                                  (i.= prediction3 output))
                             
                             _
                             false)))
            ))))

(context: "Function application."
  (<| (times +100)
      (do @
        [num-args (|> r;nat (:: @ map (|>. (n.% +10) (n.max +1))))
         funcA gen-primitive
         argsA (r;list num-args gen-primitive)]
        ($_ seq
            (test "Can synthesize function application."
                  (|> (expressionS;synthesize (la;apply argsA funcA))
                      (case> (^ [_ (#;Form (list& [_ (#;Text "lux call")] funcS argsS))])
                             (and (corresponds? funcA funcS)
                                  (list;every? (product;uncurry corresponds?)
                                               (list;zip2 argsA argsS)))
                             
                             _
                             false)))
            (test "Function application on no arguments just synthesizes to the function itself."
                  (|> (expressionS;synthesize (la;apply (list) funcA))
                      (corresponds? funcA)))
            ))))
