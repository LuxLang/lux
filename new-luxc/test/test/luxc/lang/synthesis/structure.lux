(;module:
  lux
  (lux [io]
       (control [monad #+ do]
                pipe)
       (data [bool "B/" Eq<Bool>]
             [product]
             (coll [list]))
       ["r" math/random "r/" Monad<Random>]
       test)
  (luxc (lang ["la" analysis]
              ["ls" synthesis]
              (synthesis [";S" expression])))
  (.. common))

(context: "Variants"
  (<| (times +100)
      (do @
        [size (|> r;nat (:: @ map (|>. (n.% +10) (n.max +2))))
         tagA (|> r;nat (:: @ map (n.% size)))
         memberA gen-primitive]
        ($_ seq
            (test "Can synthesize variants."
                  (|> (expressionS;synthesize (la;sum tagA size +0 memberA))
                      (case> (^ [_ (#;Form (list [_ (#;Nat tagS)] [_ (#;Bool last?S)] memberS))])
                             (and (n.= tagA tagS)
                                  (B/= (n.= (n.dec size) tagA)
                                       last?S)
                                  (corresponds? memberA memberS))
                             
                             _
                             false)))
            ))))

(context: "Tuples"
  (<| (times +100)
      (do @
        [size (|> r;nat (:: @ map (|>. (n.% +10) (n.max +2))))
         membersA (r;list size gen-primitive)]
        ($_ seq
            (test "Can synthesize tuple."
                  (|> (expressionS;synthesize (la;product membersA))
                      (case> [_ (#;Tuple membersS)]
                             (and (n.= size (list;size membersS))
                                  (list;every? (product;uncurry corresponds?) (list;zip2 membersA membersS)))

                             _
                             false)))
            ))))
