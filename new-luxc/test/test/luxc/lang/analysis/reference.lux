(.module:
  lux
  (lux [io]
       (control [monad #+ do]
                pipe)
       (data ["e" error])
       ["r" math/random]
       [macro #+ Monad<Meta>]
       (lang [type "type/" Eq<Type>])
       test)
  (luxc (lang ["&." scope]
              ["&." module]
              ["~" analysis]
              (analysis [".A" expression]
                        ["@" reference]
                        ["@." common])))
  (// common)
  (test/luxc common))

(context: "References"
  (<| (times +100)
      (do @
        [[ref-type _] gen-primitive
         module-name (r.text +5)
         scope-name (r.text +5)
         var-name (r.text +5)]
        ($_ seq
            (test "Can analyse variable."
                  (|> (&scope.with-scope scope-name
                        (&scope.with-local [var-name ref-type]
                          (@common.with-unknown-type
                            (@.analyse-reference ["" var-name]))))
                      (macro.run (init-compiler []))
                      (case> (^ (#e.Success [_type (^code ((~ [_ (#.Int var)])))]))
                             (type/= ref-type _type)

                             _
                             false)))
            (test "Can analyse definition."
                  (|> (do Monad<Meta>
                        [_ (&module.create +0 module-name)
                         _ (&module.define [module-name var-name]
                                           [ref-type (' {}) (:! Void [])])]
                        (@common.with-unknown-type
                          (@.analyse-reference [module-name var-name])))
                      (macro.run (init-compiler []))
                      (case> (#e.Success [_type [_ (#.Symbol def-name)]])
                             (type/= ref-type _type)

                             _
                             false)))
            ))))
