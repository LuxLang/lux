(;module:
  lux
  (lux [io]
       (control [monad #+ do]
                pipe)
       (data [bool "bool/" Eq<Bool>]
             ["e" error]
             [product]
             [maybe]
             [text]
             text/format
             (coll [list "list/" Functor<List>]
                   ["S" set]))
       ["r" math/random "r/" Monad<Random>]
       [meta]
       (meta [code]
             [type "type/" Eq<Type>]
             (type ["tc" check]))
       test)
  (luxc ["&" base]
        (lang ["la" analysis]
              (analysis [";A" expression]
                        ["@" structure]
                        ["@;" common]))
        ["@;" module])
  (.. common)
  (test/luxc common))

(context: "Sums"
  (<| (times +100)
      (do @
        [size (|> r;nat (:: @ map (|>. (n.% +10) (n.max +2))))
         choice (|> r;nat (:: @ map (n.% size)))
         primitives (r;list size gen-primitive)
         +choice (|> r;nat (:: @ map (n.% (n.inc size))))
         [_ +valueC] gen-primitive
         #let [variantT (type;variant (list/map product;left primitives))
               [valueT valueC] (maybe;assume (list;nth choice primitives))
               +size (n.inc size)
               +primitives (list;concat (list (list;take choice primitives)
                                              (list [(#;Bound +1) +valueC])
                                              (list;drop choice primitives)))
               [+valueT +valueC] (maybe;assume (list;nth +choice +primitives))
               +variantT (type;variant (list/map product;left +primitives))]]
        ($_ seq
            (test "Can analyse sum."
                  (|> (&;with-scope
                        (&;with-expected-type variantT
                          (@;analyse-sum analyse choice valueC)))
                      (meta;run (init-compiler []))
                      (case> (^multi (#e;Success [_ sumA])
                                     [(la;unfold-variant sumA)
                                      (#;Some [tag last? valueA])])
                             (and (n.= tag choice)
                                  (bool/= last? (n.= (n.dec size) choice)))

                             _
                             false)))
            (test "Can analyse sum through bound type-vars."
                  (|> (&;with-scope
                        (@common;with-var
                          (function [[var-id varT]]
                            (do meta;Monad<Meta>
                              [_ (&;with-type-env
                                   (tc;check varT variantT))]
                              (&;with-expected-type varT
                                (@;analyse-sum analyse choice valueC))))))
                      (meta;run (init-compiler []))
                      (case> (^multi (#e;Success [_ sumA])
                                     [(la;unfold-variant sumA)
                                      (#;Some [tag last? valueA])])
                             (and (n.= tag choice)
                                  (bool/= last? (n.= (n.dec size) choice)))

                             _
                             false)))
            (test "Cannot analyse sum through unbound type-vars."
                  (|> (&;with-scope
                        (@common;with-var
                          (function [[var-id varT]]
                            (&;with-expected-type varT
                              (@;analyse-sum analyse choice valueC)))))
                      (meta;run (init-compiler []))
                      (case> (#e;Success _)
                             false

                             _
                             true)))
            (test "Can analyse sum through existential quantification."
                  (|> (&;with-scope
                        (&;with-expected-type (type;ex-q +1 +variantT)
                          (@;analyse-sum analyse +choice +valueC)))
                      (meta;run (init-compiler []))
                      (case> (#e;Success _)
                             true

                             (#e;Error error)
                             false)))
            (test "Can analyse sum through universal quantification."
                  (|> (&;with-scope
                        (&;with-expected-type (type;univ-q +1 +variantT)
                          (@;analyse-sum analyse +choice +valueC)))
                      (meta;run (init-compiler []))
                      (case> (#e;Success _)
                             (not (n.= choice +choice))

                             (#e;Error error)
                             (n.= choice +choice))))
            ))))

(context: "Products"
  (<| (times +100)
      (do @
        [size (|> r;nat (:: @ map (|>. (n.% +10) (n.max +2))))
         primitives (r;list size gen-primitive)
         choice (|> r;nat (:: @ map (n.% size)))
         [_ +valueC] gen-primitive
         #let [[singletonT singletonC] (|> primitives (list;nth choice) maybe;assume)
               +primitives (list;concat (list (list;take choice primitives)
                                              (list [(#;Bound +1) +valueC])
                                              (list;drop choice primitives)))
               +tupleT (type;tuple (list/map product;left +primitives))]]
        ($_ seq
            (test "Can analyse product."
                  (|> (&;with-expected-type (type;tuple (list/map product;left primitives))
                        (@;analyse-product analyse (list/map product;right primitives)))
                      (meta;run (init-compiler []))
                      (case> (#e;Success tupleA)
                             (n.= size (list;size (la;unfold-tuple tupleA)))

                             _
                             false)))
            (test "Can infer product."
                  (|> (@common;with-unknown-type
                        (@;analyse-product analyse (list/map product;right primitives)))
                      (meta;run (init-compiler []))
                      (case> (#e;Success [_type tupleA])
                             (and (type/= (type;tuple (list/map product;left primitives))
                                          _type)
                                  (n.= size (list;size (la;unfold-tuple tupleA))))

                             _
                             false)))
            (test "Can analyse pseudo-product (singleton tuple)"
                  (|> (&;with-expected-type singletonT
                        (analyse (` [(~ singletonC)])))
                      (meta;run (init-compiler []))
                      (case> (#e;Success singletonA)
                             true

                             (#e;Error error)
                             false)))
            (test "Can analyse product through bound type-vars."
                  (|> (&;with-scope
                        (@common;with-var
                          (function [[var-id varT]]
                            (do meta;Monad<Meta>
                              [_ (&;with-type-env
                                   (tc;check varT (type;tuple (list/map product;left primitives))))]
                              (&;with-expected-type varT
                                (@;analyse-product analyse (list/map product;right primitives)))))))
                      (meta;run (init-compiler []))
                      (case> (#e;Success [_ tupleA])
                             (n.= size (list;size (la;unfold-tuple tupleA)))

                             _
                             false)))
            (test "Can analyse product through existential quantification."
                  (|> (&;with-scope
                        (&;with-expected-type (type;ex-q +1 +tupleT)
                          (@;analyse-product analyse (list/map product;right +primitives))))
                      (meta;run (init-compiler []))
                      (case> (#e;Success _)
                             true

                             (#e;Error error)
                             false)))
            (test "Cannot analyse product through universal quantification."
                  (|> (&;with-scope
                        (&;with-expected-type (type;univ-q +1 +tupleT)
                          (@;analyse-product analyse (list/map product;right +primitives))))
                      (meta;run (init-compiler []))
                      (case> (#e;Success _)
                             false

                             (#e;Error error)
                             true)))
            ))))

(def: (check-variant-inference variantT choice size analysis)
  (-> Type Nat Nat (Meta [Module Scope Type la;Analysis]) Bool)
  (|> analysis
      (meta;run (init-compiler []))
      (case> (^multi (#e;Success [_ _ sumT sumA])
                     [(la;unfold-variant sumA)
                      (#;Some [tag last? valueA])])
             (and (type/= variantT sumT)
                  (n.= tag choice)
                  (bool/= last? (n.= (n.dec size) choice)))

             _
             false)))

(def: (check-record-inference tupleT size analysis)
  (-> Type Nat (Meta [Module Scope Type la;Analysis]) Bool)
  (|> analysis
      (meta;run (init-compiler []))
      (case> (^multi (#e;Success [_ _ productT productA])
                     [(la;unfold-tuple productA)
                      membersA])
             (and (type/= tupleT productT)
                  (n.= size (list;size membersA)))

             _
             false)))

(context: "Tagged Sums"
  (<| (times +100)
      (do @
        [size (|> r;nat (:: @ map (|>. (n.% +10) (n.max +2))))
         tags (|> (r;set text;Hash<Text> size (r;text +5)) (:: @ map S;to-list))
         choice (|> r;nat (:: @ map (n.% size)))
         other-choice (|> r;nat (:: @ map (n.% size)) (r;filter (|>. (n.= choice) not)))
         primitives (r;list size gen-primitive)
         module-name (r;text +5)
         type-name (r;text +5)
         #let [varT (#;Bound +1)
               primitivesT (list/map product;left primitives)
               [choiceT choiceC] (maybe;assume (list;nth choice primitives))
               [other-choiceT other-choiceC] (maybe;assume (list;nth other-choice primitives))
               variantT (type;variant primitivesT)
               namedT (#;Named [module-name type-name] variantT)
               polyT (|> (type;variant (list;concat (list (list;take choice primitivesT)
                                                          (list varT)
                                                          (list;drop (n.inc choice) primitivesT))))
                         (type;univ-q +1))
               named-polyT (#;Named [module-name type-name] polyT)
               choice-tag (maybe;assume (list;nth choice tags))
               other-choice-tag (maybe;assume (list;nth other-choice tags))]]
        ($_ seq
            (test "Can infer tagged sum."
                  (|> (@module;with-module +0 module-name
                        (do meta;Monad<Meta>
                          [_ (@module;declare-tags tags false namedT)]
                          (&;with-scope
                            (@common;with-unknown-type
                              (@;analyse-tagged-sum analyse [module-name choice-tag] choiceC)))))
                      (check-variant-inference variantT choice size)))
            (test "Tagged sums specialize when type-vars get bound."
                  (|> (@module;with-module +0 module-name
                        (do meta;Monad<Meta>
                          [_ (@module;declare-tags tags false named-polyT)]
                          (&;with-scope
                            (@common;with-unknown-type
                              (@;analyse-tagged-sum analyse [module-name choice-tag] choiceC)))))
                      (check-variant-inference variantT choice size)))
            (test "Tagged sum inference retains universal quantification when type-vars are not bound."
                  (|> (@module;with-module +0 module-name
                        (do meta;Monad<Meta>
                          [_ (@module;declare-tags tags false named-polyT)]
                          (&;with-scope
                            (@common;with-unknown-type
                              (@;analyse-tagged-sum analyse [module-name other-choice-tag] other-choiceC)))))
                      (check-variant-inference polyT other-choice size)))
            (test "Can specialize generic tagged sums."
                  (|> (@module;with-module +0 module-name
                        (do meta;Monad<Meta>
                          [_ (@module;declare-tags tags false named-polyT)]
                          (&;with-scope
                            (&;with-expected-type variantT
                              (@;analyse-tagged-sum analyse [module-name other-choice-tag] other-choiceC)))))
                      (meta;run (init-compiler []))
                      (case> (^multi (#e;Success [_ _ sumA])
                                     [(la;unfold-variant sumA)
                                      (#;Some [tag last? valueA])])
                             (and (n.= tag other-choice)
                                  (bool/= last? (n.= (n.dec size) other-choice)))

                             _
                             false)))
            ))))

(context: "Records"
  (<| (times +100)
      (do @
        [size (|> r;nat (:: @ map (|>. (n.% +10) (n.max +2))))
         tags (|> (r;set text;Hash<Text> size (r;text +5)) (:: @ map S;to-list))
         primitives (r;list size gen-primitive)
         module-name (r;text +5)
         type-name (r;text +5)
         choice (|> r;nat (:: @ map (n.% size)))
         #let [varT (#;Bound +1)
               tagsC (list/map (|>. [module-name] code;tag) tags)
               primitivesT (list/map product;left primitives)
               primitivesC (list/map product;right primitives)
               tupleT (type;tuple primitivesT)
               namedT (#;Named [module-name type-name] tupleT)
               recordC (list;zip2 tagsC primitivesC)
               polyT (|> (type;tuple (list;concat (list (list;take choice primitivesT)
                                                        (list varT)
                                                        (list;drop (n.inc choice) primitivesT))))
                         (type;univ-q +1))
               named-polyT (#;Named [module-name type-name] polyT)]]
        ($_ seq
            (test "Can infer record."
                  (|> (@module;with-module +0 module-name
                        (do meta;Monad<Meta>
                          [_ (@module;declare-tags tags false namedT)]
                          (&;with-scope
                            (@common;with-unknown-type
                              (@;analyse-record analyse recordC)))))
                      (check-record-inference tupleT size)))
            (test "Records specialize when type-vars get bound."
                  (|> (@module;with-module +0 module-name
                        (do meta;Monad<Meta>
                          [_ (@module;declare-tags tags false named-polyT)]
                          (&;with-scope
                            (@common;with-unknown-type
                              (@;analyse-record analyse recordC)))))
                      (check-record-inference tupleT size)))
            (test "Can specialize generic records."
                  (|> (@module;with-module +0 module-name
                        (do meta;Monad<Meta>
                          [_ (@module;declare-tags tags false named-polyT)]
                          (&;with-scope
                            (&;with-expected-type tupleT
                              (@;analyse-record analyse recordC)))))
                      (meta;run (init-compiler []))
                      (case> (^multi (#e;Success [_ _ productA])
                                     [(la;unfold-tuple productA)
                                      membersA])
                             (n.= size (list;size membersA))

                             _
                             false)))
            ))))
