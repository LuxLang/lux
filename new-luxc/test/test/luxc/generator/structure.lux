(;module:
  lux
  (lux [io]
       (control [monad #+ do]
                pipe)
       (data ["e" error]
             [maybe]
             [bool "bool/" Eq<Bool>]
             [text "text/" Eq<Text>]
             text/format
             (coll [array]
                   [list]))
       ["r" math/random "r/" Monad<Random>]
       [meta #+ Monad<Meta>]
       [host]
       test)
  (luxc (lang ["ls" synthesis])
        [analyser]
        [synthesizer]
        (generator ["@" expr]
                   ["@;" eval]
                   ["@;" runtime]
                   ["@;" common]))
  (test/luxc common))

(host;import java.lang.Integer)

(def: gen-primitive
  (r;Random ls;Synthesis)
  (r;either (r;either (r;either (r/wrap #ls;Unit)
                                (r/map (|>. #ls;Bool) r;bool))
                      (r;either (r/map (|>. #ls;Nat) r;nat)
                                (r/map (|>. #ls;Int) r;int)))
            (r;either (r;either (r/map (|>. #ls;Deg) r;deg)
                                (r/map (|>. #ls;Frac) r;frac))
                      (r/map (|>. #ls;Text) (r;text +5)))))

(def: (corresponds? [prediction sample])
  (-> [ls;Synthesis Top] Bool)
  (case prediction
    #ls;Unit
    (is @runtime;unit (:! Text sample))

    (^template [<tag> <type> <test>]
      (<tag> prediction')
      (case (host;try (<test> prediction' (:! <type> sample)))
        (#e;Success result)
        result

        (#e;Error error)
        false))
    ([#ls;Bool Bool bool/=]
     [#ls;Nat  Nat n.=]
     [#ls;Int  Int i.=]
     [#ls;Deg  Deg d.=]
     [#ls;Frac Frac f.=]
     [#ls;Text Text text/=])

    _
    false
    ))

(context: "Tuples."
  [size (|> r;nat (:: @ map (|>. (n.% +10) (n.max +2))))
   members (r;list size gen-primitive)]
  (test "Can generate tuple."
        (|> (do meta;Monad<Meta>
              [sampleI (@;generate (#ls;Tuple members))]
              (@eval;eval sampleI))
            (meta;run (init-compiler []))
            (case> (#e;Success valueG)
                   (let [valueG (:! (Array Top) valueG)]
                     (and (n.= size (array;size valueG))
                          (list;every? corresponds? (list;zip2 members (array;to-list valueG)))))

                   _
                   false))))

(context: "Variants."
  [num-tags (|> r;nat (:: @ map (|>. (n.% +10) (n.max +2))))
   tag (|> r;nat (:: @ map (n.% num-tags)))
   #let [last? (n.= (n.dec num-tags) tag)]
   member gen-primitive]
  (test "Can generate variant."
        (|> (do Monad<Meta>
              [runtime-bytecode @runtime;generate
               sampleI (@;generate (#ls;Variant tag last? member))]
              (@eval;eval sampleI))
            (meta;run (init-compiler []))
            (case> (#e;Success valueG)
                   (let [valueG (:! (Array Top) valueG)]
                     (and (n.= +3 (array;size valueG))
                          (let [_tag (:! Integer (maybe;assume (array;read +0 valueG)))
                                _last? (array;read +1 valueG)
                                _value (:! Top (maybe;assume (array;read +2 valueG)))]
                            (and (n.= tag (|> _tag host;i2l int-to-nat))
                                 (case _last?
                                   (#;Some _last?')
                                   (and last? (text/= "" (:! Text _last?')))

                                   #;None
                                   (not last?))
                                 (corresponds? [member _value])))))

                   _
                   false))))
