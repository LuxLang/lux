(;module:
  lux
  (lux [io]
       (control [monad #+ do]
                pipe)
       (data [product]
             [maybe]
             ["e" error]
             (coll ["a" array]
                   [list "list/" Functor<List>]))
       ["r" math/random "r/" Monad<Random>]
       [meta]
       (meta [code])
       [host]
       test)
  (luxc (lang ["ls" synthesis])
        [analyser]
        [synthesizer]
        (generator ["@;" expr]
                   ["@;" eval]
                   ["@;" runtime]
                   ["@;" common]))
  (test/luxc common))

(def: arity-limit Nat +10)

(def: arity
  (r;Random ls;Arity)
  (|> r;nat (r/map (|>. (n.% arity-limit) (n.max +1)))))

(def: gen-function
  (r;Random [ls;Arity Nat ls;Synthesis])
  (do r;Monad<Random>
    [arity arity
     arg (|> r;nat (:: @ map (n.% arity)))
     #let [functionS (#ls;Function arity (list) (#ls;Variable (nat-to-int (n.inc arg))))]]
    (wrap [arity arg functionS])))

(context: "Function."
  [[arity arg functionS] gen-function
   cut-off (|> r;nat (:: @ map (n.% arity)))
   args (r;list arity r;nat)
   #let [arg-value (maybe;assume (list;nth arg args))
         argsS (list/map (|>. #ls;Nat) args)
         last-arg (n.dec arity)
         cut-off (|> cut-off (n.min (n.dec last-arg)))]]
  ($_ seq
      (test "Can read arguments."
            (|> (do meta;Monad<Meta>
                  [runtime-bytecode @runtime;generate
                   sampleI (@expr;generate (#ls;Call argsS functionS))]
                  (@eval;eval sampleI))
                (meta;run (init-compiler []))
                (case> (#e;Success valueG)
                       (n.= arg-value (:! Nat valueG))

                       (#e;Error error)
                       false)))
      (test "Can partially apply functions."
            (or (n.= +1 arity)
                (|> (do meta;Monad<Meta>
                      [#let [partial-arity (n.inc cut-off)
                             preS (list;take partial-arity argsS)
                             postS (list;drop partial-arity argsS)]
                       runtime-bytecode @runtime;generate
                       sampleI (@expr;generate (|> functionS (#ls;Call preS) (#ls;Call postS)))]
                      (@eval;eval sampleI))
                    (meta;run (init-compiler []))
                    (case> (#e;Success valueG)
                           (n.= arg-value (:! Nat valueG))

                           (#e;Error error)
                           false))))
      (test "Can read environment."
            (or (n.= +1 arity)
                (|> (do meta;Monad<Meta>
                      [#let [env (|> (list;n.range +0 cut-off)
                                     (list/map (|>. n.inc nat-to-int)))
                             super-arity (n.inc cut-off)
                             arg-var (if (n.<= cut-off arg)
                                       (|> arg n.inc nat-to-int (i.* -1))
                                       (|> arg n.inc (n.- super-arity) nat-to-int))
                             sub-arity (|> arity (n.- super-arity))
                             functionS (<| (#ls;Function super-arity (list))
                                           (#ls;Function sub-arity env)
                                           (#ls;Variable arg-var))]
                       runtime-bytecode @runtime;generate
                       sampleI (@expr;generate (#ls;Call argsS functionS))]
                      (@eval;eval sampleI))
                    (meta;run (init-compiler []))
                    (case> (#e;Success valueG)
                           (n.= arg-value (:! Nat valueG))

                           (#e;Error error)
                           false))))
      ))
