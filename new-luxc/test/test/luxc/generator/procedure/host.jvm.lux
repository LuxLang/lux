(;module:
  lux
  (lux [io]
       (control [monad #+ do]
                pipe)
       (data [maybe]
             ["e" error]
             [bit]
             [bool "bool/" Eq<Bool>]
             [number "int/" Number<Int> Codec<Text,Int>]
             [text "text/" Eq<Text>]
             text/format
             (coll [list]))
       ["r" math/random "r/" Monad<Random>]
       [meta #+ Monad<Meta>]
       [host]
       test)
  (luxc [";L" host]
        (lang ["ls" synthesis])
        [analyser]
        [synthesizer]
        (generator ["@" expr]
                   ["@;" eval]
                   ["@;" runtime]
                   ["@;" common]))
  (test/luxc common))

(context: "Conversions [Part 1]"
  (<| (times +100)
      (do @
        [int-sample (|> r;int (:: @ map (i.% 128)))
         #let [frac-sample (int-to-frac int-sample)]]
        (with-expansions [<2step> (do-template [<step1> <step2> <tag> <sample> <cast> <test>]
                                    [(test (format <step1> " / " <step2>)
                                           (|> (do meta;Monad<Meta>
                                                 [sampleI (@;generate (|> (<tag> <sample>)
                                                                          (list) (#ls;Procedure <step1>)
                                                                          (list) (#ls;Procedure <step2>)))]
                                                 (@eval;eval sampleI))
                                               (meta;run (init-compiler []))
                                               (case> (#e;Success valueG)
                                                      (<test> <sample> (:! <cast> valueG))

                                                      (#e;Error error)
                                                      false)))]

                                    ["jvm convert double-to-float" "jvm convert float-to-double" #ls;Frac frac-sample Frac f.=]
                                    ["jvm convert double-to-int"   "jvm convert int-to-double" #ls;Frac frac-sample Frac f.=]
                                    ["jvm convert double-to-long"  "jvm convert long-to-double" #ls;Frac frac-sample Frac f.=]

                                    ["jvm convert long-to-float" "jvm convert float-to-long" #ls;Int int-sample Int i.=]
                                    ["jvm convert long-to-int" "jvm convert int-to-long" #ls;Int int-sample Int i.=]
                                    ["jvm convert long-to-short" "jvm convert short-to-long" #ls;Int int-sample Int i.=]
                                    ["jvm convert long-to-byte" "jvm convert byte-to-long" #ls;Int int-sample Int i.=]
                                    )]
          ($_ seq
              <2step>
              )))))

(context: "Conversions [Part 2]"
  (<| (times +100)
      (do @
        [int-sample (|> r;int (:: @ map (|>. (i.% 128) int/abs)))
         #let [frac-sample (int-to-frac int-sample)]]
        (with-expansions [<3step> (do-template [<step1> <step2> <step3> <tag> <sample> <cast> <test>]
                                    [(test (format <step1> " / " <step2> " / " <step3>)
                                           (|> (do meta;Monad<Meta>
                                                 [sampleI (@;generate (|> (<tag> <sample>)
                                                                          (list) (#ls;Procedure <step1>)
                                                                          (list) (#ls;Procedure <step2>)
                                                                          (list) (#ls;Procedure <step3>)))]
                                                 (@eval;eval sampleI))
                                               (meta;run (init-compiler []))
                                               (case> (#e;Success valueG)
                                                      (<test> <sample> (:! <cast> valueG))

                                                      (#e;Error error)
                                                      false)))]

                                    ["jvm convert long-to-int" "jvm convert int-to-char" "jvm convert char-to-long" #ls;Int int-sample Int i.=]
                                    ["jvm convert long-to-int" "jvm convert int-to-byte" "jvm convert byte-to-long" #ls;Int int-sample Int i.=]
                                    ["jvm convert long-to-int" "jvm convert int-to-short" "jvm convert short-to-long" #ls;Int int-sample Int i.=]
                                    ["jvm convert long-to-float" "jvm convert float-to-int" "jvm convert int-to-long" #ls;Int int-sample Int i.=]
                                    ["jvm convert long-to-int" "jvm convert int-to-float" "jvm convert float-to-long" #ls;Int int-sample Int i.=]
                                    )
                          <4step> (do-template [<step1> <step2> <step3> <step4> <tag> <sample> <cast> <test>]
                                    [(test (format <step1> " / " <step2> " / " <step3>)
                                           (|> (do meta;Monad<Meta>
                                                 [sampleI (@;generate (|> (<tag> <sample>)
                                                                          (list) (#ls;Procedure <step1>)
                                                                          (list) (#ls;Procedure <step2>)
                                                                          (list) (#ls;Procedure <step3>)
                                                                          (list) (#ls;Procedure <step4>)))]
                                                 (@eval;eval sampleI))
                                               (meta;run (init-compiler []))
                                               (case> (#e;Success valueG)
                                                      (<test> <sample> (:! <cast> valueG))

                                                      (#e;Error error)
                                                      false)))]

                                    ["jvm convert long-to-int" "jvm convert int-to-char" "jvm convert char-to-byte" "jvm convert byte-to-long" #ls;Int int-sample Int i.=]
                                    ["jvm convert long-to-int" "jvm convert int-to-char" "jvm convert char-to-short" "jvm convert short-to-long" #ls;Int int-sample Int i.=]
                                    ["jvm convert long-to-int" "jvm convert int-to-char" "jvm convert char-to-int" "jvm convert int-to-long" #ls;Int int-sample Int i.=]
                                    )
                          ]
          ($_ seq
              <3step>
              <4step>
              )))))

(def: gen-nat
  (r;Random Nat)
  (|> r;nat
      (r/map (n.% +128))
      (r;filter (|>. (n.= +0) not))))

(def: gen-int
  (r;Random Int)
  (|> gen-nat (r/map nat-to-int)))

(def: gen-frac
  (r;Random Frac)
  (|> gen-int (r/map int-to-frac)))

(do-template [<domain> <generator> <tag> <type> <test> <augmentation> <+> <-> <*> </> <%> <pre> <post>]
  [(context: (format "Arithmetic [" <domain> "]")
     (<| (times +100)
         (do @
           [param <generator>
            #let [subject (<augmentation> param)]]
           (with-expansions [<tests> (do-template [<procedure> <reference>]
                                       [(test <procedure>
                                              (|> (do meta;Monad<Meta>
                                                    [sampleI (@;generate (<post> (#ls;Procedure <procedure> (list (<pre> (<tag> subject))
                                                                                                                  (<pre> (<tag> param))))))]
                                                    (@eval;eval sampleI))
                                                  (meta;run (init-compiler []))
                                                  (case> (#e;Success valueG)
                                                         (<test> (<reference> param subject)
                                                                 (:! <type> valueG))

                                                         (#e;Error error)
                                                         false)))]

                                       [(format "jvm " <domain> " +") <+>]
                                       [(format "jvm " <domain> " -") <->]
                                       [(format "jvm " <domain> " *") <*>]
                                       [(format "jvm " <domain> " /") </>]
                                       [(format "jvm " <domain> " %") <%>]
                                       )]
             ($_ seq
                 <tests>
                 )))))]

  ["int" gen-int #ls;Int Int i.= (i.* 10) i.+ i.- i.* i./ i.% (|>. (list) (#ls;Procedure "jvm convert long-to-int")) (|>. (list) (#ls;Procedure "jvm convert int-to-long"))]
  ["long" gen-int #ls;Int Int i.= (i.* 10) i.+ i.- i.* i./ i.% id id]
  ["float" gen-frac #ls;Frac Frac f.= (f.* 10.0) f.+ f.- f.* f./ f.% (|>. (list) (#ls;Procedure "jvm convert double-to-float")) (|>. (list) (#ls;Procedure "jvm convert float-to-double"))]
  ["double" gen-frac #ls;Frac Frac f.= (f.* 10.0) f.+ f.- f.* f./ f.% id id]
  )

(do-template [<domain> <post> <convert>]
  [(context: (format "Bit-wise [" <domain> "]")
     (<| (times +100)
         (do @
           [param gen-nat
            subject gen-nat
            #let [shift (n.% +10 param)]]
           (with-expansions [<combiners> (do-template [<procedure> <reference>]
                                           [(test <procedure>
                                                  (|> (do meta;Monad<Meta>
                                                        [sampleI (@;generate (<post> (#ls;Procedure <procedure> (list (<convert> (#ls;Nat subject))
                                                                                                                      (<convert> (#ls;Nat param))))))]
                                                        (@eval;eval sampleI))
                                                      (meta;run (init-compiler []))
                                                      (case> (#e;Success valueG)
                                                             (n.= (<reference> param subject)
                                                                  (:! Nat valueG))

                                                             (#e;Error error)
                                                             false)))]

                                           [(format "jvm " <domain> " and") bit;and]
                                           [(format "jvm " <domain> " or") bit;or]
                                           [(format "jvm " <domain> " xor") bit;xor]
                                           )
                             <shifters> (do-template [<procedure> <reference> <type> <test> <pre-subject> <pre>]
                                          [(test <procedure>
                                                 (|> (do meta;Monad<Meta>
                                                       [sampleI (@;generate (<post> (#ls;Procedure <procedure> (list (<convert> (<pre> subject))
                                                                                                                     (|> (#ls;Nat shift)
                                                                                                                         (list)
                                                                                                                         (#ls;Procedure "jvm convert long-to-int"))))))]
                                                       (@eval;eval sampleI))
                                                     (meta;run (init-compiler []))
                                                     (case> (#e;Success valueG)
                                                            (<test> (<reference> shift (<pre-subject> subject))
                                                                    (:! <type> valueG))

                                                            (#e;Error error)
                                                            false)))]

                                          [(format "jvm " <domain> " shl") bit;shift-left Nat n.= id #ls;Nat]
                                          [(format "jvm " <domain> " shr") bit;signed-shift-right Int i.= nat-to-int (|>. nat-to-int #ls;Int)]
                                          [(format "jvm " <domain> " ushr") bit;shift-right Nat n.= id #ls;Nat]
                                          )]
             ($_ seq
                 <combiners>
                 <shifters>
                 )))))]

  ["int" (|>. (list) (#ls;Procedure "jvm convert int-to-long")) (|>. (list) (#ls;Procedure "jvm convert long-to-int"))]
  ["long" id id]
  )

(do-template [<domain> <generator> <tag> <=> <<> <pre>]
  [(context: (format "Order [" <domain> "]")
     (<| (times +100)
         (do @
           [param <generator>
            subject <generator>]
           (with-expansions [<tests> (do-template [<procedure> <reference>]
                                       [(test <procedure>
                                              (|> (do meta;Monad<Meta>
                                                    [sampleI (@;generate (#ls;Procedure <procedure> (list (<pre> (<tag> subject))
                                                                                                          (<pre> (<tag> param)))))]
                                                    (@eval;eval sampleI))
                                                  (meta;run (init-compiler []))
                                                  (case> (#e;Success valueG)
                                                         (bool/= (<reference> param subject)
                                                                 (:! Bool valueG))

                                                         (#e;Error error)
                                                         false)))]

                                       [(format "jvm " <domain> " =") <=>]
                                       [(format "jvm " <domain> " <") <<>]
                                       )]
             ($_ seq
                 <tests>
                 )))))]

  ["int" gen-int #ls;Int i.= i.< (|>. (list) (#ls;Procedure "jvm convert long-to-int"))]
  ["long" gen-int #ls;Int i.= i.< id]
  ["float" gen-frac #ls;Frac f.= f.< (|>. (list) (#ls;Procedure "jvm convert double-to-float"))]
  ["double" gen-frac #ls;Frac f.= f.< id]
  ["char" gen-int #ls;Int i.= i.< (|>. (list) (#ls;Procedure "jvm convert long-to-int")
                                       (list) (#ls;Procedure "jvm convert int-to-char"))]
  )

(context: "Array [Part 1]"
  (<| (times +100)
      (do @
        [size (|> r;nat (:: @ map (|>. (n.% +10) (n.max +1))))
         idx (|> r;nat (:: @ map (n.% size)))
         valueZ r;bool
         valueB gen-int
         valueS gen-int
         valueI gen-int
         valueL r;int
         valueF gen-frac
         valueD r;frac
         valueC gen-int]
        (with-expansions [<array> (do-template [<class> <type> <value> <test> <input> <post>]
                                    [(test <class>
                                           (|> (do meta;Monad<Meta>
                                                 [sampleI (@;generate (|> (#ls;Procedure "jvm array new" (list (#ls;Nat +0) (#ls;Text <class>) (#ls;Nat size)))
                                                                          (list (#ls;Text <class>) (#ls;Nat idx) <input>) (#ls;Procedure "jvm array write")
                                                                          (list (#ls;Text <class>) (#ls;Nat idx)) (#ls;Procedure "jvm array read")
                                                                          <post>))]
                                                 (@eval;eval sampleI))
                                               (meta;run (init-compiler []))
                                               (case> (#e;Success outputZ)
                                                      (<test> <value> (:! <type> outputZ))

                                                      (#e;Error error)
                                                      false)))]

                                    ["boolean" Bool valueZ bool/= (#ls;Bool valueZ) id]
                                    ["byte" Int valueB i.= (|> (#ls;Int valueB)
                                                               (list) (#ls;Procedure "jvm convert long-to-byte"))
                                     (<| (#ls;Procedure "jvm convert byte-to-long") (list))]
                                    ["short" Int valueS i.= (|> (#ls;Int valueS)
                                                                (list) (#ls;Procedure "jvm convert long-to-short"))
                                     (<| (#ls;Procedure "jvm convert short-to-long") (list))]
                                    ["int" Int valueI i.= (|> (#ls;Int valueI)
                                                              (list) (#ls;Procedure "jvm convert long-to-int"))
                                     (<| (#ls;Procedure "jvm convert int-to-long") (list))]
                                    ["long" Int valueL i.= (#ls;Int valueL) id]
                                    ["float" Frac valueF f.= (|> (#ls;Frac valueF)
                                                                 (list) (#ls;Procedure "jvm convert double-to-float"))
                                     (<| (#ls;Procedure "jvm convert float-to-double") (list))]
                                    ["double" Frac valueD f.= (#ls;Frac valueD) id]
                                    )]
          ($_ seq
              <array>
              )))))

(context: "Array [Part 2]"
  (<| (times +100)
      (do @
        [size (|> r;nat (:: @ map (|>. (n.% +10) (n.max +1))))
         idx (|> r;nat (:: @ map (n.% size)))
         valueZ r;bool
         valueB gen-int
         valueS gen-int
         valueI gen-int
         valueL r;int
         valueF gen-frac
         valueD r;frac
         valueC gen-int]
        (with-expansions [<array> (do-template [<class> <type> <value> <test> <input> <post>]
                                    [(test <class>
                                           (|> (do meta;Monad<Meta>
                                                 [sampleI (@;generate (|> (#ls;Procedure "jvm array new" (list (#ls;Nat +0) (#ls;Text <class>) (#ls;Nat size)))
                                                                          (list (#ls;Text <class>) (#ls;Nat idx) <input>) (#ls;Procedure "jvm array write")
                                                                          (list (#ls;Text <class>) (#ls;Nat idx)) (#ls;Procedure "jvm array read")
                                                                          <post>))]
                                                 (@eval;eval sampleI))
                                               (meta;run (init-compiler []))
                                               (case> (#e;Success outputG)
                                                      (<test> <value> (:! <type> outputG))

                                                      (#e;Error error)
                                                      false)))]

                                    ["char" Int valueC i.= (|> (#ls;Int valueC)
                                                               (list) (#ls;Procedure "jvm convert long-to-int")
                                                               (list) (#ls;Procedure "jvm convert int-to-char"))
                                     (<| (#ls;Procedure "jvm convert char-to-long") (list))]
                                    ["java.lang.Long" Int valueL i.= (#ls;Int valueL) id]
                                    )]
          ($_ seq
              <array>
              (test "java.lang.Double (level 1)"
                    (|> (do meta;Monad<Meta>
                          [#let [inner (|> (#ls;Procedure "jvm array new" (list (#ls;Nat +0) (#ls;Text "java.lang.Double") (#ls;Nat size)))
                                           (list (#ls;Text "java.lang.Double") (#ls;Nat idx) (#ls;Frac valueD)) (#ls;Procedure "jvm array write"))]
                           sampleI (@;generate (|> (#ls;Procedure "jvm array new" (list (#ls;Nat +1) (#ls;Text "java.lang.Double") (#ls;Nat size)))
                                                   (list (#ls;Text "#Array") (#ls;Nat idx) inner) (#ls;Procedure "jvm array write")
                                                   (list (#ls;Text "#Array") (#ls;Nat idx)) (#ls;Procedure "jvm array read")
                                                   (list (#ls;Text "java.lang.Double") (#ls;Nat idx)) (#ls;Procedure "jvm array read")))]
                          (@eval;eval sampleI))
                        (meta;run (init-compiler []))
                        (case> (#e;Success outputG)
                               (f.= valueD (:! Frac outputG))

                               (#e;Error error)
                               false)))
              (test "jvm array length"
                    (|> (do meta;Monad<Meta>
                          [sampleI (@;generate (|> (#ls;Procedure "jvm array new" (list (#ls;Nat +0) (#ls;Text "java.lang.Object") (#ls;Nat size)))
                                                   (list) (#ls;Procedure "jvm array length")))]
                          (@eval;eval sampleI))
                        (meta;run (init-compiler []))
                        (case> (#e;Success outputG)
                               (n.= size (:! Nat outputG))

                               (#e;Error error)
                               false)))
              )))))

(host;import java.lang.Class
  (getName [] String))

(def: classes
  (List Text)
  (list "java.lang.Object" "java.lang.Class"
        "java.lang.String" "java.lang.Number"))

(def: instances
  (List [Text (r;Random ls;Synthesis)])
  (let [gen-boolean (|> r;bool (:: r;Functor<Random> map (|>. #ls;Bool)))
        gen-integer (|> r;int (:: r;Functor<Random> map (|>. #ls;Int)))
        gen-double (|> r;frac (:: r;Functor<Random> map (|>. #ls;Frac)))
        gen-string (|> (r;text +5) (:: r;Functor<Random> map (|>. #ls;Text)))]
    (list ["java.lang.Boolean" gen-boolean]
          ["java.lang.Long" gen-integer]
          ["java.lang.Double" gen-double]
          ["java.lang.String" gen-string]
          ["java.lang.Object" (r;either (r;either gen-boolean
                                                  gen-integer)
                                        (r;either gen-double
                                                  gen-string))])))

(context: "Object."
  (<| (times +100)
      (do @
        [#let [num-classes (list;size classes)]
         #let [num-instances (list;size instances)]
         class-idx (|> r;nat (:: @ map (n.% num-classes)))
         instance-idx (|> r;nat (:: @ map (n.% num-instances)))
         exception-message (r;text +5)
         #let [class (maybe;assume (list;nth class-idx classes))
               [instance-class instance-gen] (maybe;assume (list;nth instance-idx instances))
               exception-message$ (|> (#ls;Text exception-message)
                                      (list (#ls;Text "java.lang.String")) #ls;Tuple)]
         sample r;int
         monitor r;int
         instance instance-gen]
        ($_ seq
            (test "jvm object null"
                  (|> (do meta;Monad<Meta>
                        [sampleI (@;generate (|> (#ls;Procedure "jvm object null" (list))
                                                 (list) (#ls;Procedure "jvm object null?")))]
                        (@eval;eval sampleI))
                      (meta;run (init-compiler []))
                      (case> (#e;Success outputG)
                             (:! Bool outputG)

                             (#e;Error error)
                             false)))
            (test "jvm object null?"
                  (|> (do meta;Monad<Meta>
                        [sampleI (@;generate (|> (#ls;Int sample)
                                                 (list) (#ls;Procedure "jvm object null?")))]
                        (@eval;eval sampleI))
                      (meta;run (init-compiler []))
                      (case> (#e;Success outputG)
                             (not (:! Bool outputG))

                             (#e;Error error)
                             false)))
            (test "jvm object synchronized"
                  (|> (do meta;Monad<Meta>
                        [sampleI (@;generate (#ls;Procedure "jvm object synchronized"
                                                            (list (#ls;Int monitor)
                                                                  (#ls;Int sample))))]
                        (@eval;eval sampleI))
                      (meta;run (init-compiler []))
                      (case> (#e;Success outputG)
                             (i.= sample (:! Int outputG))

                             (#e;Error error)
                             false)))
            (test "jvm object throw"
                  (|> (do meta;Monad<Meta>
                        [_ @runtime;generate
                         sampleI (@;generate (|> (#ls;Procedure "jvm member invoke constructor" (list (#ls;Text "java.lang.Throwable")
                                                                                                      exception-message$))
                                                 (list) (#ls;Procedure "jvm object throw")
                                                 (#ls;Function +1 (list))
                                                 (list) (#ls;Procedure "lux try")))]
                        (@eval;eval sampleI))
                      (meta;run (init-compiler []))
                      (case> (#e;Success outputG)
                             (case (:! (e;Error Top) outputG)
                               (#e;Error error)
                               (text;contains? exception-message error)

                               (#e;Success outputG)
                               false)

                             (#e;Error error)
                             false)))
            (test "jvm object class"
                  (|> (do meta;Monad<Meta>
                        [sampleI (@;generate (#ls;Procedure "jvm object class" (list (#ls;Text class))))]
                        (@eval;eval sampleI))
                      (meta;run (init-compiler []))
                      (case> (#e;Success outputG)
                             (|> outputG (:! Class) (Class.getName []) (text/= class))

                             (#e;Error error)
                             false)))
            (test "jvm object instance?"
                  (|> (do meta;Monad<Meta>
                        [sampleI (@;generate (#ls;Procedure "jvm object instance?" (list (#ls;Text instance-class)
                                                                                         instance)))]
                        (@eval;eval sampleI))
                      (meta;run (init-compiler []))
                      (case> (#e;Success outputG)
                             (:! Bool outputG)

                             (#e;Error error)
                             false)))
            ))))

(host;import java.util.GregorianCalendar
  (#static AD int))

(context: "Member [Field]"
  (<| (times +100)
      (do @
        [sample-short (|> r;int (:: @ map (|>. int/abs (i.% 100))))
         sample-string (r;text +5)
         other-sample-string (r;text +5)
         #let [shortS (|> (#ls;Int sample-short)
                          (list) (#ls;Procedure "jvm convert long-to-short")
                          (list (#ls;Text "short")) #ls;Tuple)
               stringS (|> (#ls;Text sample-string)
                           (list (#ls;Text "java.lang.String")) #ls;Tuple)
               type-codeS (|> (#ls;Procedure "jvm object null" (list))
                              (list (#ls;Text "org.omg.CORBA.TypeCode")) #ls;Tuple)
               idl-typeS (|> (#ls;Procedure "jvm object null" (list))
                             (list (#ls;Text "org.omg.CORBA.IDLType")) #ls;Tuple)
               value-member$ (#ls;Procedure "jvm member invoke constructor" (list (#ls;Text "org.omg.CORBA.ValueMember")
                                                                                  stringS
                                                                                  stringS
                                                                                  stringS
                                                                                  stringS
                                                                                  type-codeS
                                                                                  idl-typeS
                                                                                  shortS))]]
        ($_ seq
            (test "jvm member static get"
                  (|> (do meta;Monad<Meta>
                        [sampleI (@;generate (|> (#ls;Procedure "jvm member static get" (list (#ls;Text "java.util.GregorianCalendar") (#ls;Text "AD") (#ls;Text "int")))
                                                 (list) (#ls;Procedure "jvm convert int-to-long")))]
                        (@eval;eval sampleI))
                      (meta;run (init-compiler []))
                      (case> (#e;Success outputG)
                             (i.= GregorianCalendar.AD (:! Int outputG))

                             (#e;Error error)
                             false)))
            (test "jvm member static put"
                  (|> (do meta;Monad<Meta>
                        [sampleI (@;generate (#ls;Procedure "jvm member static put" (list (#ls;Text "java.awt.datatransfer.DataFlavor") (#ls;Text "allHtmlFlavor") (#ls;Text "java.awt.datatransfer.DataFlavor")
                                                                                          (#ls;Procedure "jvm member static get" (list (#ls;Text "java.awt.datatransfer.DataFlavor") (#ls;Text "allHtmlFlavor") (#ls;Text "java.awt.datatransfer.DataFlavor"))))))]
                        (@eval;eval sampleI))
                      (meta;run (init-compiler []))
                      (case> (#e;Success outputG)
                             (is hostL;unit (:! Text outputG))

                             (#e;Error error)
                             false)))
            (test "jvm member virtual get"
                  (|> (do meta;Monad<Meta>
                        [sampleI (@;generate (|> value-member$
                                                 (list (#ls;Text "org.omg.CORBA.ValueMember")
                                                       (#ls;Text "name")
                                                       (#ls;Text "java.lang.String"))
                                                 (#ls;Procedure "jvm member virtual get")))]
                        (@eval;eval sampleI))
                      (meta;run (init-compiler []))
                      (case> (#e;Success outputG)
                             (text/= sample-string (:! Text outputG))

                             (#e;Error error)
                             false)))
            (test "jvm member virtual put"
                  (|> (do meta;Monad<Meta>
                        [sampleI (@;generate (|> value-member$
                                                 (list (#ls;Text "org.omg.CORBA.ValueMember")
                                                       (#ls;Text "name")
                                                       (#ls;Text "java.lang.String")
                                                       (#ls;Text other-sample-string))
                                                 (#ls;Procedure "jvm member virtual put")
                                                 (list (#ls;Text "org.omg.CORBA.ValueMember")
                                                       (#ls;Text "name")
                                                       (#ls;Text "java.lang.String"))
                                                 (#ls;Procedure "jvm member virtual get")))]
                        (@eval;eval sampleI))
                      (meta;run (init-compiler []))
                      (case> (#e;Success outputG)
                             (text/= other-sample-string (:! Text outputG))

                             (#e;Error error)
                             false)))
            ))))

(host;import java.lang.Object)

(host;import (java.util.ArrayList a))

(context: "Member [Method]"
  (<| (times +100)
      (do @
        [sample (|> r;int (:: @ map (|>. int/abs (i.% 100))))
         #let [object-longS (|> (#ls;Int sample)
                                (list (#ls;Text "java.lang.Object")) #ls;Tuple)
               intS (|> (#ls;Int sample)
                        (list) (#ls;Procedure "jvm convert long-to-int")
                        (list (#ls;Text "int")) #ls;Tuple)
               coded-intS (|> (#ls;Text (int/encode sample))
                              (list (#ls;Text "java.lang.String")) #ls;Tuple)
               array-listS (#ls;Procedure "jvm member invoke constructor" (list (#ls;Text "java.util.ArrayList") intS))]]
        ($_ seq
            (test "jvm member invoke static"
                  (|> (do meta;Monad<Meta>
                        [sampleI (@;generate (#ls;Procedure "jvm member invoke static"
                                                            (list (#ls;Text "java.lang.Long")
                                                                  (#ls;Text "decode")
                                                                  (#ls;Text "java.lang.Long")
                                                                  coded-intS)))]
                        (@eval;eval sampleI))
                      (meta;run (init-compiler []))
                      (case> (#e;Success outputG)
                             (i.= sample (:! Int outputG))

                             (#e;Error error)
                             false)))
            (test "jvm member invoke virtual"
                  (|> (do meta;Monad<Meta>
                        [sampleI (@;generate (|> object-longS
                                                 (list (#ls;Text "java.lang.Object")
                                                       (#ls;Text "equals")
                                                       (#ls;Text "boolean")
                                                       (#ls;Int sample))
                                                 (#ls;Procedure "jvm member invoke virtual")))]
                        (@eval;eval sampleI))
                      (meta;run (init-compiler []))
                      (case> (#e;Success outputG)
                             (:! Bool outputG)

                             (#e;Error error)
                             false)))
            (test "jvm member invoke interface"
                  (|> (do meta;Monad<Meta>
                        [sampleI (@;generate (#ls;Procedure "jvm member invoke interface"
                                                            (list (#ls;Text "java.util.Collection")
                                                                  (#ls;Text "add")
                                                                  (#ls;Text "boolean")
                                                                  array-listS
                                                                  object-longS)))]
                        (@eval;eval sampleI))
                      (meta;run (init-compiler []))
                      (case> (#e;Success outputG)
                             (:! Bool outputG)

                             (#e;Error error)
                             false)))
            (test "jvm member invoke constructor"
                  (|> (do meta;Monad<Meta>
                        [sampleI (@;generate array-listS)]
                        (@eval;eval sampleI))
                      (meta;run (init-compiler []))
                      (case> (#e;Success outputG)
                             (host;instance? ArrayList (:! Object outputG))

                             (#e;Error error)
                             false)))
            ))))
