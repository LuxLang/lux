(;module:
  lux
  (lux [io]
       (control [monad #+ do]
                pipe)
       (data ["R" result]
             [number "int/" Number<Int>]
             text/format)
       ["r" math/random "r/" Monad<Random>]
       [macro #+ Monad<Lux>]
       [host]
       test)
  (luxc (lang ["ls" synthesis])
        [analyser]
        [synthesizer]
        (generator ["@" expr]
                   ["@;" eval]
                   ["@;" runtime]
                   ["@;" common]))
  (test/luxc common))

(context: "Conversions [Part 1]"
  [int-sample (|> r;int (:: @ map (i.% 128)))
   #let [frac-sample (int-to-frac int-sample)]]
  (with-expansions [<2step> (do-template [<step1> <step2> <tag> <sample> <cast> <test>]
                              [(test (format <step1> " / " <step2>)
                                     (|> (do macro;Monad<Lux>
                                           [sampleI (@;generate (|> (<tag> <sample>)
                                                                    (list) (#ls;Procedure <step1>)
                                                                    (list) (#ls;Procedure <step2>)))]
                                           (@eval;eval sampleI))
                                         (macro;run (init-compiler []))
                                         (case> (#R;Success valueG)
                                                (<test> <sample> (:! <cast> valueG))

                                                (#R;Error error)
                                                false)))]

                              ["jvm convert double-to-float" "jvm convert float-to-double" #ls;Frac frac-sample Frac f.=]
                              ["jvm convert double-to-int"   "jvm convert int-to-double" #ls;Frac frac-sample Frac f.=]
                              ["jvm convert double-to-long"  "jvm convert long-to-double" #ls;Frac frac-sample Frac f.=]

                              ["jvm convert long-to-float" "jvm convert float-to-long" #ls;Int int-sample Int i.=]
                              ["jvm convert long-to-int" "jvm convert int-to-long" #ls;Int int-sample Int i.=]
                              ["jvm convert long-to-short" "jvm convert short-to-long" #ls;Int int-sample Int i.=]
                              ["jvm convert long-to-byte" "jvm convert byte-to-long" #ls;Int int-sample Int i.=]
                              )]
    ($_ seq
        <2step>
        )))

(context: "Conversions [Part 2]"
  [int-sample (|> r;int (:: @ map (|>. (i.% 128) int/abs)))
   #let [frac-sample (int-to-frac int-sample)]]
  (with-expansions [<3step> (do-template [<step1> <step2> <step3> <tag> <sample> <cast> <test>]
                              [(test (format <step1> " / " <step2> " / " <step3>)
                                     (|> (do macro;Monad<Lux>
                                           [sampleI (@;generate (|> (<tag> <sample>)
                                                                    (list) (#ls;Procedure <step1>)
                                                                    (list) (#ls;Procedure <step2>)
                                                                    (list) (#ls;Procedure <step3>)))]
                                           (@eval;eval sampleI))
                                         (macro;run (init-compiler []))
                                         (case> (#R;Success valueG)
                                                (<test> <sample> (:! <cast> valueG))

                                                (#R;Error error)
                                                false)))]

                              ["jvm convert long-to-int" "jvm convert int-to-char" "jvm convert char-to-long" #ls;Int int-sample Int i.=]
                              ["jvm convert long-to-int" "jvm convert int-to-byte" "jvm convert byte-to-long" #ls;Int int-sample Int i.=]
                              ["jvm convert long-to-int" "jvm convert int-to-short" "jvm convert short-to-long" #ls;Int int-sample Int i.=]
                              ["jvm convert long-to-float" "jvm convert float-to-int" "jvm convert int-to-long" #ls;Int int-sample Int i.=]
                              ["jvm convert long-to-int" "jvm convert int-to-float" "jvm convert float-to-long" #ls;Int int-sample Int i.=]
                              )
                    <4step> (do-template [<step1> <step2> <step3> <step4> <tag> <sample> <cast> <test>]
                              [(test (format <step1> " / " <step2> " / " <step3>)
                                     (|> (do macro;Monad<Lux>
                                           [sampleI (@;generate (|> (<tag> <sample>)
                                                                    (list) (#ls;Procedure <step1>)
                                                                    (list) (#ls;Procedure <step2>)
                                                                    (list) (#ls;Procedure <step3>)
                                                                    (list) (#ls;Procedure <step4>)))]
                                           (@eval;eval sampleI))
                                         (macro;run (init-compiler []))
                                         (case> (#R;Success valueG)
                                                (<test> <sample> (:! <cast> valueG))

                                                (#R;Error error)
                                                false)))]

                              ["jvm convert long-to-int" "jvm convert int-to-char" "jvm convert char-to-byte" "jvm convert byte-to-long" #ls;Int int-sample Int i.=]
                              ["jvm convert long-to-int" "jvm convert int-to-char" "jvm convert char-to-short" "jvm convert short-to-long" #ls;Int int-sample Int i.=]
                              ["jvm convert long-to-int" "jvm convert int-to-char" "jvm convert char-to-int" "jvm convert int-to-long" #ls;Int int-sample Int i.=]
                              )
                    ]
    ($_ seq
        <3step>
        <4step>
        )))
