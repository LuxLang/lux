(;module:
  lux
  (lux [io]
       (control [monad #+ do]
                pipe)
       (data ["e" error])
       ["r" math/random]
       [meta]
       test)
  (luxc (lang ["ls" synthesis])
        ["_;" module]
        (generator [";G" statement]
                   [";G" eval]
                   [";G" expr]
                   [";G" case]
                   [";G" runtime]
                   (host ["$" jvm]
                         (jvm ["$i" inst]))))
  (test/luxc common))

(def: nilI $;Inst runtimeG;noneI)

(def: cursorI
  $;Inst
  (|>. ($i;int 3)
       ($i;array runtimeG;$Tuple)
       $i;DUP ($i;int 0) ($i;string "") $i;AASTORE
       $i;DUP ($i;int 1) ($i;long 0) ($i;wrap #$;Long) $i;AASTORE
       $i;DUP ($i;int 2) ($i;long 0) ($i;wrap #$;Long) $i;AASTORE))

(def: empty-metaI
  (|>. ($i;int 2)
       ($i;array runtimeG;$Tuple)
       $i;DUP ($i;int 0) cursorI $i;AASTORE
       $i;DUP ($i;int 1) nilI $i;AASTORE))

(context: "Definitions."
  (<| (times +100)
      (do @
        [module-name (r;text +5)
         def-name (r;text +5)
         def-value r;int
         #let [valueI (|>. ($i;long def-value) ($i;wrap #$;Long))]]
        ($_ seq
            (test "Can refer to definitions."
                  (|> (do meta;Monad<Meta>
                        [_ (_module;with-module +0 module-name
                             (statementG;generate-def def-name Int valueI empty-metaI (' {})))
                         sampleI (exprG;generate (#ls;Definition [module-name def-name]))]
                        (evalG;eval sampleI))
                      (meta;run (init-compiler []))
                      (case> (#e;Success valueG)
                             (i.= def-value (:! Int valueG))

                             (#e;Error error)
                             false)))
            ))))

(context: "Variables."
  (<| (times +100)
      (do @
        [register (|> r;nat (:: @ map (n.% +100)))
         value r;int]
        ($_ seq
            (test "Can refer to local variables/registers."
                  (|> (do meta;Monad<Meta>
                        [sampleI (caseG;generate-let exprG;generate
                                                     register
                                                     (#ls;Int value)
                                                     (#ls;Variable (nat-to-int register)))]
                        (evalG;eval sampleI))
                      (meta;run (init-compiler []))
                      (case> (#e;Success outputG)
                             (i.= value (:! Int outputG))

                             (#e;Error error)
                             false)))
            ))))
