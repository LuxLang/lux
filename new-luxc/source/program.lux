(.module:
  [lux #*
   [control
    [monad (#+ do)]
    ["p" parser]]
   [data
    ["." error]
    ["." text
     format]]
   ["." io (#+ IO Process io)]
   [time
    ["." instant]]
   [cli (#+ program:)]
   [world
    ["." file (#+ File)]
    ["." console]]
   [compiler
    ["." cli]
    ["." default (#+ Platform)]]
   ["." interpreter]]
  [luxc
   [lang
    ["." host/jvm]
    [translation
     ["." jvm
      ["." runtime]
      ["." expression]
      [procedure
       ["." common]]]]]])

(def: (or-crash! failure-description action)
  (All [a]
    (-> Text (Process a) (IO a)))
  (do io.Monad<IO>
    [?output action]
    (case ?output
      (#error.Error error)
      (exec (log! (format text.new-line
                          failure-description text.new-line
                          error text.new-line))
        (io.exit +1))

      (#error.Success output)
      (wrap output))))

(def: (timed action)
  (All [a]
    (-> (Process a) (Process a)))
  (do io.Monad<Process>
    [start (io.from-io instant.now)
     result action
     finish (io.from-io instant.now)
     #let [elapsed-time (instant.span start finish)
           _ (log! (format text.new-line "Elapsed time: " (%duration elapsed-time)))]]
    (wrap result)))

(def: jvm-platform
  (IO (Platform Process host/jvm.Anchor host/jvm.Inst host/jvm.Definition))
  (do io.Monad<IO>
    [host jvm.init]
    (wrap {#default.host host
           #default.phase expression.translate
           #default.runtime runtime.translate
           #default.file-system file.JVM@System})))

(program: [{service cli.service}]
  (do io.Monad<IO>
    [platform ..jvm-platform
     console (:: @ map error.assume console.open)]
    (case service
      (#cli.Compilation configuration)
      (<| (or-crash! "Compilation failed:")
          ..timed
          (default.compile platform configuration common.bundle))
      
      (#cli.Interpretation configuration)
      (<| (or-crash! "Interpretation failed:")
          (interpreter.run io.Monad<Process> console platform configuration)))))
