(;module:
  lux
  (lux (control monad
                ["p" parser])
       (concurrency ["P" promise]
                    ["T" task])
       (data ["e" error]
             text/format)
       [io #- run]
       [cli #+ program: CLI])
  (luxc (lang [";L" translation])))

## (type: Compilation
##   {#program &;Path
##    #target &;Path})

## (def: (marker tokens)
##   (-> (List Text) (CLI Unit))
##   (cli;after (cli;option tokens)
##              (:: Monad<CLI> wrap [])))

## (def: (tagged tags)
##   (-> (List Text) (CLI Text))
##   (cli;after (cli;option tags)
##              cli;any))

## (def: compilation^
##   (CLI Compilation)
##   ($_ cli;seq
##       (tagged (list "-p" "--program"))
##       (tagged (list "-t" "--target"))))

## (program: ([command (cli;opt compilation^)]
##            [sources (cli;some (tagged (list "-s" "--source")))])
##   (case command
##     #;None
##     (io (log! "No REPL for you!"))

##     (#;Some [program target])
##     (exec (&compiler;compile-program program target sources)
##       (io []))))

(def: (or-crash! action)
  (All [a] (-> (T;Task a) (P;Promise a)))
  (do P;Monad<Promise>
    [?output action]
    (case ?output
      (#e;Error error)
      (exec (log! (format "\n"
                          "Compilation failed:" "\n"
                          error "\n"))
        ("lux io exit" 1))

      (#e;Success output)
      (wrap output))))


