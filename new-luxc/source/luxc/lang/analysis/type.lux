(;module:
  lux
  (lux (control monad)
       [meta]
       (meta (type ["tc" check])))
  (luxc ["&" base]
        (lang ["la" analysis #+ Analysis])))

## These 2 analysers are somewhat special, since they require the
## means of evaluating Lux expressions at compile-time for the sake of
## computing Lux type values.
(def: #export (analyse-check analyse eval type value)
  (-> &;Analyser &;Eval Code Code (Meta Analysis))
  (do meta;Monad<Meta>
    [actualT (eval Type type)
     #let [actualT (:! Type actualT)]
     expectedT meta;expected-type
     _ (&;with-type-env
         (tc;check expectedT actualT))]
    (&;with-expected-type actualT
      (analyse value))))

(def: #export (analyse-coerce analyse eval type value)
  (-> &;Analyser &;Eval Code Code (Meta Analysis))
  (do meta;Monad<Meta>
    [actualT (eval Type type)
     expectedT meta;expected-type
     _ (&;with-type-env
         (tc;check expectedT (:! Type actualT)))]
    (&;with-expected-type Top
      (analyse value))))
