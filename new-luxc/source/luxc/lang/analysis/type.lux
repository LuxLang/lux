(.module:
  lux
  (lux (control monad)
       [macro]
       (lang (type ["tc" check])))
  (luxc ["&" lang]
        (lang ["la" analysis #+ Analysis])))

## These 2 analysers are somewhat special, since they require the
## means of evaluating Lux expressions at compile-time for the sake of
## computing Lux type values.
(def: #export (analyse-check analyse eval type value)
  (-> &.Analyser &.Eval Code Code (Meta Analysis))
  (do macro.Monad<Meta>
    [actualT (eval Type type)
     #let [actualT (:! Type actualT)]
     _ (&.infer actualT)]
    (&.with-type actualT
      (analyse value))))

(def: #export (analyse-coerce analyse eval type value)
  (-> &.Analyser &.Eval Code Code (Meta Analysis))
  (do macro.Monad<Meta>
    [actualT (eval Type type)
     _ (&.infer (:! Type actualT))]
    (&.with-type Top
      (analyse value))))
