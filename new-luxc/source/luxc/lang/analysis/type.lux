(;module:
  lux
  (lux (control monad)
       [meta #+ Monad<Meta>]
       (meta (type ["TC" check])))
  (luxc ["&" base]
        (lang ["la" analysis #+ Analysis])))

## These 2 analysers are somewhat special, since they require the
## means of evaluating Lux expressions at compile-time for the sake of
## computing Lux type values.
(def: #export (analyse-check analyse eval type value)
  (-> &;Analyser &;Eval Code Code (Meta Analysis))
  (do Monad<Meta>
    [actual (eval Type type)
     #let [actual (:! Type actual)]
     expected meta;expected-type
     _ (&;with-type-env
         (TC;check expected actual))]
    (&;with-expected-type actual
      (analyse value))))

(def: #export (analyse-coerce analyse eval type value)
  (-> &;Analyser &;Eval Code Code (Meta Analysis))
  (do Monad<Meta>
    [actual (eval Type type)
     expected meta;expected-type
     _ (&;with-type-env
         (TC;check expected (:! Type actual)))]
    (&;with-expected-type Top
      (analyse value))))
