(;module:
  lux
  (lux (control [monad #+ do])
       (data [text]
             text/format
             (coll [list "list/" Functor<List> Monoid<List>]))
       [meta])
  (luxc ["&" base]
        [";L" host]
        (host ["$" jvm]
              (jvm ["$t" type]
                   ["$d" def]
                   ["$i" inst]))
        (lang ["la" analysis]
              ["ls" synthesis]
              (translation [";T" common]
                           [";T" runtime]
                           [";T" reference])
              [";L" variable #+ Variable])))

(def: #export (translate-recur translate argsS)
  (-> (-> ls;Synthesis (Meta $;Inst))
      (List ls;Synthesis)
      (Meta $;Inst))
  (do meta;Monad<Meta>
    [[@begin offset] hostL;anchor
     argsI (monad;map @ (function [[register argS]]
                          (let [register' (n.+ offset register)]
                            (: (Meta $;Inst)
                               (case argS
                                 (^multi (^code ((~ [_ (#;Int var)])))
                                         (i.= (variableL;local register')
                                              var))
                                 (wrap id)

                                 _
                                 (do @
                                   [argI (translate argS)]
                                   (wrap (|>. argI
                                              ($i;ASTORE register'))))))))
                      (list;zip2 (list;n.range +0 (n.dec (list;size argsS)))
                                 argsS))]
    (wrap (|>. ($i;fuse argsI)
               ($i;GOTO @begin)))))

(def: #export (translate-loop translate offset initsS+ bodyS)
  (-> (-> ls;Synthesis (Meta $;Inst))
      Nat (List ls;Synthesis) ls;Synthesis
      (Meta $;Inst))
  (do meta;Monad<Meta>
    [@begin $i;make-label
     initsI+ (monad;map @ translate initsS+)
     bodyI (hostL;with-anchor [@begin offset]
             (translate bodyS))
     #let [initializationI (|> (list;enumerate initsI+)
                               (list/map (function [[register initI]]
                                           (|>. initI
                                                ($i;ASTORE (|> register n.inc (n.+ offset))))))
                               $i;fuse)]]
    (wrap (|>. initializationI
               ($i;label @begin)
               bodyI))))
