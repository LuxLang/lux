(.module:
  lux
  (lux (control [monad #+ do])
       [macro]
       (data text/format))
  (luxc (lang [".L" module]))
  [//]
  (// [".T" runtime]
      [".T" reference]
      [".T" eval]))

(def: #export (translate-def name expressionT expressionJS metaV)
  (-> Text Type //.Expression Code (Meta Unit))
  (do macro.Monad<Meta>
    [current-module macro.current-module-name
     #let [def-ident [current-module name]]]
    (case (macro.get-symbol-ann (ident-for #.alias) metaV)
      (#.Some real-def)
      (do @
        [[realT realA realV] (macro.find-def real-def)
         _ (moduleL.define def-ident [realT metaV realV])]
        (wrap []))

      _
      (do @
        [_ (//.save-definition def-ident expressionJS)
         expressionV (evalT.eval (referenceT.global def-ident))
         _ (moduleL.define def-ident [expressionT metaV expressionV])
         _ (if (macro.type? metaV)
             (case (macro.declared-tags metaV)
               #.Nil
               (wrap [])

               tags
               (moduleL.declare-tags tags (macro.export? metaV) (:! Type expressionV)))
             (wrap []))
         #let [_ (log! (format "DEF " (%ident def-ident)))]]
        (wrap []))
      )))

(def: #export (translate-program programJS)
  (-> //.Expression (Meta //.Statement))
  (macro.fail "translate-program NOT IMPLEMENTED YET")
  ## (hostT.save (format "var " (referenceT.variable +0) " = " runtimeT.lux//program-args "();"
  ##                     "(" programJS ")(null);"))
  )
