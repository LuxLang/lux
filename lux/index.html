<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Lux - Lux</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Lux";
    var mkdocs_page_input_path = "lux.md";
    var mkdocs_page_url = "/lux/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Lux</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Home</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">Lux</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#lux">lux</a></li>
    

    <li class="toctree-l2"><a href="#types">Types</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#ast">AST</a></li>
        
            <li><a class="toctree-l3" href="#ast_1">AST'</a></li>
        
            <li><a class="toctree-l3" href="#analysis">Analysis</a></li>
        
            <li><a class="toctree-l3" href="#ann-value">Ann-Value</a></li>
        
            <li><a class="toctree-l3" href="#anns">Anns</a></li>
        
            <li><a class="toctree-l3" href="#bindings">Bindings</a></li>
        
            <li><a class="toctree-l3" href="#bool">Bool</a></li>
        
            <li><a class="toctree-l3" href="#bottom">Bottom</a></li>
        
            <li><a class="toctree-l3" href="#char">Char</a></li>
        
            <li><a class="toctree-l3" href="#compiler">Compiler</a></li>
        
            <li><a class="toctree-l3" href="#compiler-info">Compiler-Info</a></li>
        
            <li><a class="toctree-l3" href="#compiler-mode">Compiler-Mode</a></li>
        
            <li><a class="toctree-l3" href="#cursor">Cursor</a></li>
        
            <li><a class="toctree-l3" href="#def">Def</a></li>
        
            <li><a class="toctree-l3" href="#either">Either</a></li>
        
            <li><a class="toctree-l3" href="#frac">Frac</a></li>
        
            <li><a class="toctree-l3" href="#ident">Ident</a></li>
        
            <li><a class="toctree-l3" href="#int">Int</a></li>
        
            <li><a class="toctree-l3" href="#list">List</a></li>
        
            <li><a class="toctree-l3" href="#lux_1">Lux</a></li>
        
            <li><a class="toctree-l3" href="#macro">Macro</a></li>
        
            <li><a class="toctree-l3" href="#maybe">Maybe</a></li>
        
            <li><a class="toctree-l3" href="#meta">Meta</a></li>
        
            <li><a class="toctree-l3" href="#module">Module</a></li>
        
            <li><a class="toctree-l3" href="#nat">Nat</a></li>
        
            <li><a class="toctree-l3" href="#real">Real</a></li>
        
            <li><a class="toctree-l3" href="#scope">Scope</a></li>
        
            <li><a class="toctree-l3" href="#source">Source</a></li>
        
            <li><a class="toctree-l3" href="#text">Text</a></li>
        
            <li><a class="toctree-l3" href="#top">Top</a></li>
        
            <li><a class="toctree-l3" href="#type">Type</a></li>
        
            <li><a class="toctree-l3" href="#unit">Unit</a></li>
        
            <li><a class="toctree-l3" href="#void">Void</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#macros">Macros</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#_1">$</a></li>
        
            <li><a class="toctree-l3" href="#_">$_</a></li>
        
            <li><a class="toctree-l3" href="#_2">&amp;</a></li>
        
            <li><a class="toctree-l3" href="#_3">'</a></li>
        
            <li><a class="toctree-l3" href="#-">-&gt;</a></li>
        
            <li><a class="toctree-l3" href="#_4">:</a></li>
        
            <li><a class="toctree-l3" href="#_5">:!</a></li>
        
            <li><a class="toctree-l3" href="#_6">:!!</a></li>
        
            <li><a class="toctree-l3" href="#_7">::</a></li>
        
            <li><a class="toctree-l3" href="#_8">&lt;|</a></li>
        
            <li><a class="toctree-l3" href="#post">@post</a></li>
        
            <li><a class="toctree-l3" href="#pre">@pre</a></li>
        
            <li><a class="toctree-l3" href="#all">All</a></li>
        
            <li><a class="toctree-l3" href="#ex">Ex</a></li>
        
            <li><a class="toctree-l3" href="#rec">Rec</a></li>
        
            <li><a class="toctree-l3" href="#_9">^</a></li>
        
            <li><a class="toctree-l3" href="#_10">^=&gt;</a></li>
        
            <li><a class="toctree-l3" href="#_11">^@</a></li>
        
            <li><a class="toctree-l3" href="#open">^open</a></li>
        
            <li><a class="toctree-l3" href="#or">^or</a></li>
        
            <li><a class="toctree-l3" href="#slots">^slots</a></li>
        
            <li><a class="toctree-l3" href="#template">^template</a></li>
        
            <li><a class="toctree-l3" href="#_12">^|&gt;</a></li>
        
            <li><a class="toctree-l3" href="#_13">^~</a></li>
        
            <li><a class="toctree-l3" href="#__1">_$</a></li>
        
            <li><a class="toctree-l3" href="#_14">`</a></li>
        
            <li><a class="toctree-l3" href="#_15">`'</a></li>
        
            <li><a class="toctree-l3" href="#and">and</a></li>
        
            <li><a class="toctree-l3" href="#case">case</a></li>
        
            <li><a class="toctree-l3" href="#comment">comment</a></li>
        
            <li><a class="toctree-l3" href="#cond">cond</a></li>
        
            <li><a class="toctree-l3" href="#def_1">def:</a></li>
        
            <li><a class="toctree-l3" href="#default">default</a></li>
        
            <li><a class="toctree-l3" href="#do-template">do-template</a></li>
        
            <li><a class="toctree-l3" href="#doc">doc</a></li>
        
            <li><a class="toctree-l3" href="#exec">exec</a></li>
        
            <li><a class="toctree-l3" href="#get">get@</a></li>
        
            <li><a class="toctree-l3" href="#host">host</a></li>
        
            <li><a class="toctree-l3" href="#ident-for">ident-for</a></li>
        
            <li><a class="toctree-l3" href="#if">if</a></li>
        
            <li><a class="toctree-l3" href="#lambda">lambda</a></li>
        
            <li><a class="toctree-l3" href="#let">let</a></li>
        
            <li><a class="toctree-l3" href="#let_1">let%</a></li>
        
            <li><a class="toctree-l3" href="#list_1">list</a></li>
        
            <li><a class="toctree-l3" href="#list_2">list&amp;</a></li>
        
            <li><a class="toctree-l3" href="#loop">loop</a></li>
        
            <li><a class="toctree-l3" href="#macro_1">macro:</a></li>
        
            <li><a class="toctree-l3" href="#module_1">module:</a></li>
        
            <li><a class="toctree-l3" href="#open_1">open</a></li>
        
            <li><a class="toctree-l3" href="#or_1">or</a></li>
        
            <li><a class="toctree-l3" href="#set">set@</a></li>
        
            <li><a class="toctree-l3" href="#sig">sig:</a></li>
        
            <li><a class="toctree-l3" href="#struct">struct</a></li>
        
            <li><a class="toctree-l3" href="#struct_1">struct:</a></li>
        
            <li><a class="toctree-l3" href="#template_1">template:</a></li>
        
            <li><a class="toctree-l3" href="#type_1">type</a></li>
        
            <li><a class="toctree-l3" href="#type-of">type-of</a></li>
        
            <li><a class="toctree-l3" href="#type_2">type:</a></li>
        
            <li><a class="toctree-l3" href="#undefined">undefined</a></li>
        
            <li><a class="toctree-l3" href="#update">update@</a></li>
        
            <li><a class="toctree-l3" href="#with-cursor">with-cursor</a></li>
        
            <li><a class="toctree-l3" href="#_16">|</a></li>
        
            <li><a class="toctree-l3" href="#_17">|&gt;</a></li>
        
            <li><a class="toctree-l3" href="#_18">|&gt;.</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#values">Values</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#_19">.</a></li>
        
            <li><a class="toctree-l3" href="#error-message">(error! message)</a></li>
        
            <li><a class="toctree-l3" href="#f">f.%</a></li>
        
            <li><a class="toctree-l3" href="#f_1">f.*</a></li>
        
            <li><a class="toctree-l3" href="#f_2">f.+</a></li>
        
            <li><a class="toctree-l3" href="#f-">f.-</a></li>
        
            <li><a class="toctree-l3" href="#f_3">f./</a></li>
        
            <li><a class="toctree-l3" href="#f_4">f.&lt;</a></li>
        
            <li><a class="toctree-l3" href="#f_5">f.&lt;=</a></li>
        
            <li><a class="toctree-l3" href="#f_6">f.=</a></li>
        
            <li><a class="toctree-l3" href="#f_7">f.&gt;</a></li>
        
            <li><a class="toctree-l3" href="#f_8">f.&gt;=</a></li>
        
            <li><a class="toctree-l3" href="#fmax">f.max</a></li>
        
            <li><a class="toctree-l3" href="#fmin">f.min</a></li>
        
            <li><a class="toctree-l3" href="#frac-to-real-input">(frac-to-real input)</a></li>
        
            <li><a class="toctree-l3" href="#i">i.%</a></li>
        
            <li><a class="toctree-l3" href="#i_1">i.*</a></li>
        
            <li><a class="toctree-l3" href="#i_2">i.+</a></li>
        
            <li><a class="toctree-l3" href="#i-">i.-</a></li>
        
            <li><a class="toctree-l3" href="#i_3">i./</a></li>
        
            <li><a class="toctree-l3" href="#i_4">i.&lt;</a></li>
        
            <li><a class="toctree-l3" href="#i_5">i.&lt;=</a></li>
        
            <li><a class="toctree-l3" href="#i_6">i.=</a></li>
        
            <li><a class="toctree-l3" href="#i_7">i.&gt;</a></li>
        
            <li><a class="toctree-l3" href="#i_8">i.&gt;=</a></li>
        
            <li><a class="toctree-l3" href="#idec-value">(i.dec value)</a></li>
        
            <li><a class="toctree-l3" href="#ieven-n">(i.even? n)</a></li>
        
            <li><a class="toctree-l3" href="#iinc-value">(i.inc value)</a></li>
        
            <li><a class="toctree-l3" href="#imax">i.max</a></li>
        
            <li><a class="toctree-l3" href="#imin">i.min</a></li>
        
            <li><a class="toctree-l3" href="#iodd-n">(i.odd? n)</a></li>
        
            <li><a class="toctree-l3" href="#id-x">(id x)</a></li>
        
            <li><a class="toctree-l3" href="#int-to-nat-input">(int-to-nat input)</a></li>
        
            <li><a class="toctree-l3" href="#int-to-real-n">(int-to-real n)</a></li>
        
            <li><a class="toctree-l3" href="#is-left-right">(is left right)</a></li>
        
            <li><a class="toctree-l3" href="#log">log!</a></li>
        
            <li><a class="toctree-l3" href="#n">n.%</a></li>
        
            <li><a class="toctree-l3" href="#n_1">n.*</a></li>
        
            <li><a class="toctree-l3" href="#n_2">n.+</a></li>
        
            <li><a class="toctree-l3" href="#n-">n.-</a></li>
        
            <li><a class="toctree-l3" href="#n_3">n./</a></li>
        
            <li><a class="toctree-l3" href="#n_4">n.&lt;</a></li>
        
            <li><a class="toctree-l3" href="#n_5">n.&lt;=</a></li>
        
            <li><a class="toctree-l3" href="#n_6">n.=</a></li>
        
            <li><a class="toctree-l3" href="#n_7">n.&gt;</a></li>
        
            <li><a class="toctree-l3" href="#n_8">n.&gt;=</a></li>
        
            <li><a class="toctree-l3" href="#ndec-value">(n.dec value)</a></li>
        
            <li><a class="toctree-l3" href="#neven-n">(n.even? n)</a></li>
        
            <li><a class="toctree-l3" href="#ninc-value">(n.inc value)</a></li>
        
            <li><a class="toctree-l3" href="#nmax">n.max</a></li>
        
            <li><a class="toctree-l3" href="#nmin">n.min</a></li>
        
            <li><a class="toctree-l3" href="#nodd-n">(n.odd? n)</a></li>
        
            <li><a class="toctree-l3" href="#nat-to-int-input">(nat-to-int input)</a></li>
        
            <li><a class="toctree-l3" href="#not">not</a></li>
        
            <li><a class="toctree-l3" href="#r">r.%</a></li>
        
            <li><a class="toctree-l3" href="#r_1">r.*</a></li>
        
            <li><a class="toctree-l3" href="#r_2">r.+</a></li>
        
            <li><a class="toctree-l3" href="#r-">r.-</a></li>
        
            <li><a class="toctree-l3" href="#r_3">r./</a></li>
        
            <li><a class="toctree-l3" href="#r_4">r.&lt;</a></li>
        
            <li><a class="toctree-l3" href="#r_5">r.&lt;=</a></li>
        
            <li><a class="toctree-l3" href="#r_6">r.=</a></li>
        
            <li><a class="toctree-l3" href="#r_7">r.&gt;</a></li>
        
            <li><a class="toctree-l3" href="#r_8">r.&gt;=</a></li>
        
            <li><a class="toctree-l3" href="#rmax">r.max</a></li>
        
            <li><a class="toctree-l3" href="#rmin">r.min</a></li>
        
            <li><a class="toctree-l3" href="#real-to-frac-input">(real-to-frac input)</a></li>
        
            <li><a class="toctree-l3" href="#real-to-int-n">(real-to-int n)</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_cli/">Lux cli</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_codata_cont/">Lux codata cont</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_codata_env/">Lux codata env</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_codata_function/">Lux codata function</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_codata_io/">Lux codata io</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_codata_state/">Lux codata state</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_codata_struct_stream/">Lux codata struct stream</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_compiler/">Lux compiler</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_concurrency_actor/">Lux concurrency actor</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_concurrency_atom/">Lux concurrency atom</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_concurrency_frp/">Lux concurrency frp</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_concurrency_promise/">Lux concurrency promise</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_concurrency_stm/">Lux concurrency stm</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_control_applicative/">Lux control applicative</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_control_bounded/">Lux control bounded</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_control_codec/">Lux control codec</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_control_comonad/">Lux control comonad</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_control_effect/">Lux control effect</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_control_enum/">Lux control enum</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_control_eq/">Lux control eq</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_control_fold/">Lux control fold</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_control_functor/">Lux control functor</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_control_hash/">Lux control hash</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_control_monad/">Lux control monad</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_control_monoid/">Lux control monoid</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_control_number/">Lux control number</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_control_ord/">Lux control ord</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_bit/">Lux data bit</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_bool/">Lux data bool</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_char/">Lux data char</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_error/">Lux data error</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_error_exception/">Lux data error exception</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_format_json/">Lux data format json</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_ident/">Lux data ident</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_identity/">Lux data identity</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_log/">Lux data log</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_maybe/">Lux data maybe</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_number/">Lux data number</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_product/">Lux data product</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_struct_array/">Lux data struct array</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_struct_dict/">Lux data struct dict</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_struct_list/">Lux data struct list</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_struct_queue/">Lux data struct queue</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_struct_set/">Lux data struct set</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_struct_stack/">Lux data struct stack</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_struct_tree/">Lux data struct tree</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_struct_vector/">Lux data struct vector</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_struct_zipper/">Lux data struct zipper</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_sum/">Lux data sum</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_text/">Lux data text</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_data_text_format/">Lux data text format</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_host/">Lux host</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_lexer/">Lux lexer</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_macro/">Lux macro</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_macro_ast/">Lux macro ast</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_macro_poly/">Lux macro poly</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_macro_poly_eq/">Lux macro poly eq</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_macro_poly_functor/">Lux macro poly functor</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_macro_poly_text-encoder/">Lux macro poly text encoder</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_macro_syntax/">Lux macro syntax</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_macro_syntax_common/">Lux macro syntax common</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_math/">Lux math</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_math_complex/">Lux math complex</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_math_ratio/">Lux math ratio</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_math_simple/">Lux math simple</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_pipe/">Lux pipe</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_random/">Lux random</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_regex/">Lux regex</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_test/">Lux test</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_type/">Lux type</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_type_auto/">Lux type auto</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lux_type_check/">Lux type check</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Lux</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Lux</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h2 id="lux">lux</h2>
<h2 id="types">Types</h2>
<h3 id="ast">AST</h3>
<p>The type of AST nodes for Lux syntax.</p>
<pre><code>(type: AST
  (Meta Cursor (AST' (Meta Cursor))))
</code></pre>

<h3 id="ast_1">AST'</h3>
<pre><code>(type: (AST' w)
  (#BoolS Bool)
  (#NatS Nat)
  (#IntS Int)
  (#FracS Frac)
  (#RealS Real)
  (#CharS Char)
  (#TextS Text)
  (#SymbolS Ident)
  (#TagS Ident)
  (#FormS (List (w (AST' w))))
  (#TupleS (List (w (AST' w))))
  (#RecordS (List [(w (AST' w)) (w (AST' w))])))
</code></pre>

<h3 id="analysis">Analysis</h3>
<pre><code>(type: Analysis
  (Meta [Type Cursor] Void))
</code></pre>

<h3 id="ann-value">Ann-Value</h3>
<p>The value of an individual annotation.</p>
<pre><code>(type: #rec Ann-Value
  (#BoolM Bool)
  (#NatM Nat)
  (#IntM Int)
  (#FracM Frac)
  (#RealM Real)
  (#CharM Char)
  (#TextM Text)
  (#IdentM Ident)
  (#ListM (List Ann-Value))
  (#DictM (List [Text Ann-Value])))
</code></pre>

<h3 id="anns">Anns</h3>
<p>A set of annotations associated with a definition.</p>
<pre><code>(type: Anns
  (List [Ident Ann-Value]))
</code></pre>

<h3 id="bindings">Bindings</h3>
<pre><code>(type: (Bindings k v)
  {#counter Nat
   #mappings (List [k v])})
</code></pre>

<h3 id="bool">Bool</h3>
<p>Your standard, run-of-the-mill boolean values.</p>
<pre><code>(type: Bool
  (host java.lang.Boolean))
</code></pre>

<h3 id="bottom">Bottom</h3>
<p>The type of things whose type is unknown or undefined.</p>
<p>Useful for expressions that cause errors or other "extraordinary" conditions.</p>
<pre><code>(type: Bottom
  (All [a] a))
</code></pre>

<h3 id="char">Char</h3>
<p>Your standard, run-of-the-mill character values.</p>
<pre><code>(type: Char
  (host java.lang.Character))
</code></pre>

<h3 id="compiler">Compiler</h3>
<p>Represents the state of the Lux compiler during a run.</p>
<p>It is provided to macros during their invocation, so they can access compiler data.</p>
<p>Caveat emptor: Avoid fiddling with it, unless you know what you're doing.</p>
<pre><code>(type: Compiler
  {#info Compiler-Info
   #source Source
   #cursor Cursor
   #modules (List [Text Module])
   #scopes (List Scope)
   #type-vars (Bindings Nat (Maybe Type))
   #expected (Maybe Type)
   #seed Nat
   #scope-type-vars (List Nat)
   #host Void})
</code></pre>

<h3 id="compiler-info">Compiler-Info</h3>
<p>Information about the current version and type of compiler that is running.</p>
<pre><code>(type: Compiler-Info
  {#compiler-name Text
   #compiler-version Text
   #compiler-mode Compiler-Mode})
</code></pre>

<h3 id="compiler-mode">Compiler-Mode</h3>
<p>A sign that shows the conditions under which the compiler is running.</p>
<pre><code>(type: Compiler-Mode
  #Release
  #Debug
  #Eval
  #REPL)
</code></pre>

<h3 id="cursor">Cursor</h3>
<p>Cursors are for specifying the location of AST nodes in Lux files during compilation.</p>
<pre><code>(type: Cursor
  {#module Text
   #line Int
   #column Int})
</code></pre>

<h3 id="def">Def</h3>
<p>Represents all the data associated with a definition: its type, its annotations, and its value.</p>
<pre><code>(type: Def
  [Type Anns Void])
</code></pre>

<h3 id="either">Either</h3>
<p>A choice between two values of different types.</p>
<pre><code>(type: (Either l r)
  (#Left l)
  (#Right r))
</code></pre>

<h3 id="frac">Frac</h3>
<p>Fractional numbers that live in the interval [0,1).</p>
<p>Useful for probability, and other domains that work within that interval.</p>
<pre><code>(type: Frac
  (host #Frac))
</code></pre>

<h3 id="ident">Ident</h3>
<p>An identifier.</p>
<p>It is used as part of Lux syntax to represent symbols and tags.</p>
<pre><code>(type: Ident
  [Text Text])
</code></pre>

<h3 id="int">Int</h3>
<p>Your standard, run-of-the-mill integer numbers.</p>
<pre><code>(type: Int
  (host java.lang.Long))
</code></pre>

<h3 id="list">List</h3>
<p>A potentially empty list of values.</p>
<pre><code>(type: (List a)
  #Nil
  (#Cons a (List a)))
</code></pre>

<h3 id="lux_1">Lux</h3>
<p>Computations that can have access to the state of the compiler.</p>
<p>These computations may fail, or modify the state of the compiler.</p>
<pre><code>(type: (Lux a)
  (-&gt; Compiler (Either Text [Compiler a])))
</code></pre>

<h3 id="macro">Macro</h3>
<p>Functions that run at compile-time and allow you to transform and extend the language in powerful ways.</p>
<pre><code>(type: Macro
  (-&gt; (List AST) (Lux (List AST))))
</code></pre>

<h3 id="maybe">Maybe</h3>
<p>A potentially missing value.</p>
<pre><code>(type: (Maybe a)
  #None
  (#Some a))
</code></pre>

<h3 id="meta">Meta</h3>
<p>The type of things that can have meta-data of arbitrary types.</p>
<pre><code>(type: (Meta m v)
  {#meta m
   #datum v})
</code></pre>

<h3 id="module">Module</h3>
<p>All the information contained within a Lux module.</p>
<pre><code>(type: Module
  {#module-hash Int
   #module-aliases (List [Text Text])
   #defs (List [Text Def])
   #imports (List Text)
   #tags (List [Text Nat (List Ident) Bool Type])
   #types (List [Text (List Ident) Bool Type])
   #module-anns Anns})
</code></pre>

<h3 id="nat">Nat</h3>
<p>Natural numbers (unsigned integers).</p>
<p>They start at zero (+0) and extend in the positive direction.</p>
<pre><code>(type: Nat
  (host #Nat))
</code></pre>

<h3 id="real">Real</h3>
<p>Your standard, run-of-the-mill floating-point numbers.</p>
<pre><code>(type: Real
  (host java.lang.Double))
</code></pre>

<h3 id="scope">Scope</h3>
<pre><code>(type: Scope
  {#name (List Text)
   #inner-closures Int
   #locals (Bindings Text Analysis)
   #closure (Bindings Text Analysis)})
</code></pre>

<h3 id="source">Source</h3>
<pre><code>(type: Source
  (List (Meta Cursor Text)))
</code></pre>

<h3 id="text">Text</h3>
<p>Your standard, run-of-the-mill string values.</p>
<pre><code>(type: Text
  (host java.lang.String))
</code></pre>

<h3 id="top">Top</h3>
<p>The type of things whose type doesn't matter.</p>
<p>It can be used to write functions or data-structures that can take, or return, anything.</p>
<pre><code>(type: Top
  (Ex [a] a))
</code></pre>

<h3 id="type">Type</h3>
<p>This type represents the data-structures that are used to specify types themselves.</p>
<pre><code>(type: #rec Type
  (#HostT Text (List Type))
  #VoidT
  #UnitT
  (#SumT Type Type)
  (#ProdT Type Type)
  (#LambdaT Type Type)
  (#BoundT Nat)
  (#VarT Nat)
  (#ExT Nat)
  (#UnivQ (List Type) Type)
  (#ExQ (List Type) Type)
  (#AppT Type Type)
  (#NamedT Ident Type))
</code></pre>

<h3 id="unit">Unit</h3>
<p>An unusual type that only possesses a single value: []</p>
<pre><code>(type: Unit
  Unit)
</code></pre>

<h3 id="void">Void</h3>
<p>An unusual type that possesses no value, and thus can't be instantiated.</p>
<pre><code>(type: Void
  Void)
</code></pre>

<h2 id="macros">Macros</h2>
<h3 id="_1">$</h3>
<pre><code>## Allows you to refer to the type-variables in a polymorphic function's type, by their index.
## In the example below, +0 corresponds to the 'a' variable.
(def: #export (from-list list)
  (All [a] (-&gt; (List a) (Vector a)))
  (List/fold add
             (: (Vector ($ +0))
                empty)
             list))
</code></pre>

<h3 id="_">$_</h3>
<pre><code>## Right-association for the application of binary functions over variadic arguments.
($_ Text/append &quot;Hello, &quot; name &quot;.\nHow are you?&quot;)

## =&gt;
(Text/append &quot;Hello, &quot; (Text/append name &quot;.\nHow are you?&quot;))
</code></pre>

<h3 id="_2">&amp;</h3>
<pre><code>## Tuple types:
(&amp; Text Int Bool)

## The empty tuple, a.k.a. Unit.
(&amp;)
</code></pre>

<h3 id="_3">'</h3>
<pre><code>## Quotation as a macro.
(' &quot;YOLO&quot;)
</code></pre>

<h3 id="-">-&gt;</h3>
<pre><code>## Function types:
(-&gt; Int Int Int)

## This is the type of a function that takes 2 Ints and returns an Int.
</code></pre>

<h3 id="_4">:</h3>
<pre><code>## The type-annotation macro.
(: (List Int) (list 1 2 3))
</code></pre>

<h3 id="_5">:!</h3>
<pre><code>## The type-coercion macro.
(:! Dinosaur (list 1 2 3))
</code></pre>

<h3 id="_6">:!!</h3>
<pre><code>## Coerces the given expression to the type of whatever is expected.
(: Dinosaur (:!! (list 1 2 3)))
</code></pre>

<h3 id="_7">::</h3>
<pre><code>## Allows accessing the value of a structure's member.
(:: Codec&lt;Text,Int&gt; encode)

## Also allows using that value as a function.
(:: Codec&lt;Text,Int&gt; encode 123)
</code></pre>

<h3 id="_8">&lt;|</h3>
<pre><code>## Reverse piping macro.
(&lt;| (fold Text/append &quot;&quot;) (interpose &quot; &quot;) (map -&gt;Text) elems)

## =&gt;
(fold Text/append &quot;&quot;
      (interpose &quot; &quot;
                 (map -&gt;Text elems)))
</code></pre>

<h3 id="post">@post</h3>
<pre><code>## Post-conditions.
## Given a predicate and an expression to run, evaluates the expression and then tests the output with the predicate.
## If the predicate returns true, returns the value of the expression.
## Otherwise, an error is raised.
(@post i.even?
       (i.+ 2 2))
</code></pre>

<h3 id="pre">@pre</h3>
<pre><code>## Pre-conditions.
## Given a test and an expression to run, only runs the expression if the test passes.
## Otherwise, an error is raised.
(@pre (i.= 4 (i.+ 2 2))
      (foo 123 456 789))
</code></pre>

<h3 id="all">All</h3>
<pre><code>## Universal quantification.
(All [a]
  (-&gt; a a))

## A name can be provided, to specify a recursive type.
(All List [a]
  (| Unit
     [a (List a)]))
</code></pre>

<h3 id="ex">Ex</h3>
<pre><code>## Existential quantification.
(Ex [a]
  [(Codec Text a)
   a])

## A name can be provided, to specify a recursive type.
(Ex Self [a]
  [(Codec Text a)
   a
   (List (Self a))])
</code></pre>

<h3 id="rec">Rec</h3>
<pre><code>## Parameter-less recursive types.
## A name has to be given to the whole type, to use it within it's body.
(Rec Self
  [Int (List Self)])
</code></pre>

<h3 id="_9">^</h3>
<pre><code>## Macro-expanding patterns.
## It's a special macro meant to be used with 'case'.
(case (: (List Int) (list 1 2 3))
  (^ (list x y z))
  (#Some ($_ i.* x y z))

  _
  #None)
</code></pre>

<h3 id="_10">^=&gt;</h3>
<pre><code>## Multi-level pattern matching.
## Useful in situations where the result of a branch depends on further refinements on the values being matched.
## For example:
(case (split (size static) uri)
  (^=&gt; (#lux;Some[chunk uri']) [(Text/= static chunk) true])
  (match-uri endpoint? parts' uri')

  _
  (#lux;Left(format &quot;Static part &quot; (%t static) &quot; doesn't match URI: &quot; uri)))

## Short-cuts can be taken when using boolean tests.
## The example above can be rewritten as...
(case (split (size static) uri)
  (^=&gt; (#lux;Some[chunk uri']) (Text/= static chunk))
  (match-uri endpoint? parts' uri')

  _
  (#lux;Left(format &quot;Static part &quot; (%t static) &quot; doesn't match URI: &quot; uri)))
</code></pre>

<h3 id="_11">^@</h3>
<pre><code>## Allows you to simultaneously bind and de-structure a value.
(def: (hash (^@ set [Hash&lt;a&gt; _]))
  (List/fold (lambda [elem acc] (n.+ (:: Hash&lt;a&gt; hash elem) acc))
             +0
             (to-list set)))
</code></pre>

<h3 id="open">^open</h3>
<pre><code>## Same as the &quot;open&quot; macro, but meant to be used as a pattern-matching macro for generating local bindings.
## Can optionally take a &quot;prefix&quot; text for the generated local bindings.
(def: #export (range (^open) from to)
  (All [a] (-&gt; (Enum a) a a (List a)))
  (range' &lt;= succ from to))
</code></pre>

<h3 id="or">^or</h3>
<pre><code>## Or-patterns.
## It's a special macro meant to be used with 'case'.
(type: Weekday
  #Monday
  #Tuesday
  #Wednesday
  #Thursday
  #Friday
  #Saturday
  #Sunday)

(def: (weekend? day)
  (-&gt; Weekday Bool)
  (case day
    (^or #Saturday #Sunday)
    true

    _
    false))
</code></pre>

<h3 id="slots">^slots</h3>
<pre><code>## Allows you to extract record members as local variables with the same names.
## For example:
(let [(^slots [#foo #bar #baz]) quux]
  (f foo bar baz))
</code></pre>

<h3 id="template">^template</h3>
<pre><code>## It's similar to do-template, but meant to be used during pattern-matching.
(def: (beta-reduce env type)
  (-&gt; (List Type) Type Type)
  (case type
    (#;HostT name params)
    (#;HostT name (List/map (beta-reduce env) params))

    (^template [&lt;tag&gt;]
      (&lt;tag&gt; left right)
      (&lt;tag&gt; (beta-reduce env left) (beta-reduce env right)))
    ([#;SumT] [#;ProdT])

    (^template [&lt;tag&gt;]
      (&lt;tag&gt; left right)
      (&lt;tag&gt; (beta-reduce env left) (beta-reduce env right)))
    ([#;LambdaT]
     [#;AppT])

    (^template [&lt;tag&gt;]
      (&lt;tag&gt; old-env def)
      (case old-env
        #;Nil
        (&lt;tag&gt; env def)

        _
        type))
    ([#;UnivQ]
     [#;ExQ])

    (#;BoundT idx)
    (default type (list;at idx env))

    _
    type
    ))
</code></pre>

<h3 id="_12">^|&gt;</h3>
<pre><code>## Pipes the value being pattern-matched against prior to binding it to a variable.
(case input
  (^|&gt; value [n.inc (n.% +10) (n.max +1)])
  (foo value))
</code></pre>

<h3 id="_13">^~</h3>
<pre><code>## Use global defs with simple values, such as text, int, real, bool and char, in place of literals in patterns.
## The definitions must be properly-qualified (though you may use one of the short-cuts Lux provides).
(def: (empty?' node)
  (All [K V] (-&gt; (Node K V) Bool))
  (case node
    (^~ (#Base lux;clean-bitmap_))
    true

    _
    false))
</code></pre>

<h3 id="__1">_$</h3>
<pre><code>## Left-association for the application of binary functions over variadic arguments.
(_$ Text/append &quot;Hello, &quot; name &quot;.\nHow are you?&quot;)

## =&gt;
(Text/append (Text/append &quot;Hello, &quot; name) &quot;.\nHow are you?&quot;)
</code></pre>

<h3 id="_14">`</h3>
<pre><code>## Hygienic quasi-quotation as a macro. Unquote (~) and unquote-splice (~@) must also be used as forms.
## All unprefixed macros will receive their parent module's prefix if imported; otherwise will receive the prefix of the module on which the quasi-quote is being used.
(` (def: (~ name)
     (lambda [(~@ args)]
       (~ body))))
</code></pre>

<h3 id="_15">`'</h3>
<pre><code>## Unhygienic quasi-quotation as a macro. Unquote (~) and unquote-splice (~@) must also be used as forms.
(`' (def: (~ name)
      (lambda [(~@ args)]
        (~ body))))
</code></pre>

<h3 id="and">and</h3>
<pre><code>Short-circuiting &quot;and&quot;.
(and true false true) ## =&gt; false
</code></pre>

<h3 id="case">case</h3>
<pre><code>## The pattern-matching macro.
## Allows the usage of macros within the patterns to provide custom syntax.
(case (: (List Int) (list 1 2 3))
  (#Cons x (#Cons y (#Cons z #Nil)))
  (#Some ($_ i.* x y z))

  _
  #None)
</code></pre>

<h3 id="comment">comment</h3>
<pre><code>## Throws away any code given to it.
## Great for commenting-out code, while retaining syntax high-lighting and formatting in your text editor.
(comment 1 2 3 4)
</code></pre>

<h3 id="cond">cond</h3>
<pre><code>## Branching structures with multiple test conditions.
(cond (n.even? num) &quot;even&quot;
      (n.odd? num) &quot;odd&quot;
      ## else-branch
      &quot;???&quot;)
</code></pre>

<h3 id="def_1">def:</h3>
<pre><code>## Defines global constants/functions.
(def: (rejoin-pair pair)
  (-&gt; [AST AST] (List AST))
  (let [[left right] pair]
    (list left right)))

(def: branching-exponent
  Int
  5)
</code></pre>

<h3 id="default">default</h3>
<pre><code>## Allows you to provide a default value that will be used
## if a (Maybe x) value turns out to be #;None.
(default 20 (#;Some 10)) =&gt; 10

(default 20 #;None) =&gt; 20
</code></pre>

<h3 id="do-template">do-template</h3>
<pre><code>## By specifying a pattern (with holes), and the input data to fill those holes, repeats the pattern as many times as necessary.
(do-template [&lt;name&gt; &lt;diff&gt;]
             [(def: #export &lt;name&gt;
                (-&gt; Int Int)
                (i.+ &lt;diff&gt;))]

             [i.inc  1]
             [i.dec -1])
</code></pre>

<h3 id="doc">doc</h3>
<pre><code>## Creates code documentation, embedding text as comments and properly formatting the forms it's being given.

## For Example:
(doc &quot;Allows arbitrary looping, using the \&quot;recur\&quot; form to re-start the loop.
      Can be used in monadic code to create monadic loops.&quot;
     (loop [count 0
            x init]
       (if (&lt; 10 count)
         (recur (i.inc count) (f x))
         x)))
</code></pre>

<h3 id="exec">exec</h3>
<pre><code>## Sequential execution of expressions (great for side-effects).
(exec
  (log! &quot;#1&quot;)
  (log! &quot;#2&quot;)
  (log! &quot;#3&quot;)
  &quot;YOLO&quot;)
</code></pre>

<h3 id="get">get@</h3>
<pre><code>## Accesses the value of a record at a given tag.
(get@ #field my-record)

## Can also work with multiple levels of nesting:
(get@ [#foo #bar #baz] my-record)

## And, if only the slot/path is given, generates an
## accessor function:
(let [getter (get@ [#foo #bar #baz])]
  (getter my-record))
</code></pre>

<h3 id="host">host</h3>
<pre><code>## Macro to treat host-types as Lux-types.
(host java.lang.Object)

(host java.util.List [java.lang.Long])
</code></pre>

<h3 id="ident-for">ident-for</h3>
<pre><code>## Given a symbol or a tag, gives back a 2 tuple with the prefix and name parts, both as Text.
(ident-for #lux;doc)

## =&gt;
[&quot;lux&quot; &quot;doc&quot;]
</code></pre>

<h3 id="if">if</h3>
<pre><code>Picks which expression to evaluate based on a boolean test value.

(if true
  &quot;Oh, yeah!&quot;
  &quot;Aw hell naw!&quot;)

== &quot;Oh, yeah!&quot;
</code></pre>

<h3 id="lambda">lambda</h3>
<pre><code>## Syntax for creating functions.
## Allows for giving the function itself a name, for the sake of recursion.
(: (All [a b] (-&gt; a b a))
   (lambda [x y] x))

(: (All [a b] (-&gt; a b a))
   (lambda const [x y] x))
</code></pre>

<h3 id="let">let</h3>
<pre><code>## Creates local bindings.
## Can (optionally) use pattern-matching macros when binding.
(let [x (foo bar)
      y (baz quux)]
  (op x y))
</code></pre>

<h3 id="let_1">let%</h3>
<pre><code>## Controlled macro-expansion.
## Bind an arbitraty number of ASTs resulting from macro-expansion to local bindings.
## Wherever a binding appears, the bound ASTs will be spliced in there.
(test: &quot;AST operations &amp; structures&quot;
  (let% [&lt;tests&gt; (do-template [&lt;expr&gt; &lt;text&gt; &lt;pattern&gt;]
                   [(compare &lt;pattern&gt; &lt;expr&gt;)
                    (compare &lt;text&gt; (:: AST/encode show &lt;expr&gt;))
                    (compare true (:: Eq&lt;AST&gt; = &lt;expr&gt; &lt;expr&gt;))]

                   [(bool true)                             &quot;true&quot;       [[&quot;&quot; -1 -1] (#lux;BoolStrue)]]
                   [(bool false)                            &quot;false&quot;      [_ (#lux;BoolSfalse)]]
                   [(int 123)                               &quot;123&quot;        [_ (#lux;IntS123)]]
                   [(real 123.0)                            &quot;123.0&quot;      [_ (#lux;RealS123.0)]]
                   [(char #&quot;\n&quot;)                            &quot;#\\&quot;\\n\\&quot;&quot; [_ (#lux;CharS#&quot;\n&quot;)]]
                   [(text &quot;\\n&quot;)                            &quot;\\&quot;\\n\\&quot;&quot;  [_ (#lux;TextS&quot;\\n&quot;)]]
                   [(tag [&quot;yolo&quot; &quot;lol&quot;])                    &quot;#yolo;lol&quot;  [_ (#lux;TagS[&quot;yolo&quot; &quot;lol&quot;])]]
                   [(symbol [&quot;yolo&quot; &quot;lol&quot;])                 &quot;yolo;lol&quot;   [_ (#lux;SymbolS[&quot;yolo&quot; &quot;lol&quot;])]]
                   [(form (list (bool true) (int 123)))     &quot;(true 123)&quot; (^ [_ (#lux;FormS(list [_ (#lux;BoolStrue)] [_ (#lux;IntS123)]))])]
                   [(tuple (list (bool true) (int 123)))    &quot;[true 123]&quot; (^ [_ (#lux;TupleS(list [_ (#lux;BoolStrue)] [_ (#lux;IntS123)]))])]
                   [(record (list [(bool true) (int 123)])) &quot;{true 123}&quot; (^ [_ (#lux;RecordS(list [[_ (#lux;BoolStrue)] [_ (#lux;IntS123)]]))])]
                   [(local-tag &quot;lol&quot;)                       &quot;#lol&quot;       [_ (#lux;TagS[&quot;&quot; &quot;lol&quot;])]]
                   [(local-symbol &quot;lol&quot;)                    &quot;lol&quot;        [_ (#lux;SymbolS[&quot;&quot; &quot;lol&quot;])]])]

    (test-all &lt;tests&gt;)))
</code></pre>

<h3 id="list_1">list</h3>
<pre><code>## List-construction macro.
(list 1 2 3)
</code></pre>

<h3 id="list_2">list&amp;</h3>
<pre><code>## List-construction macro, with the last element being a tail-list.
## In other words, this macro prepends elements to another list.
(list&amp; 1 2 3 (list 4 5 6))
</code></pre>

<h3 id="loop">loop</h3>
<pre><code>## Allows arbitrary looping, using the &quot;recur&quot; form to re-start the loop.
## Can be used in monadic code to create monadic loops.
(loop [count 0
       x init]
  (if (&lt; 10 count)
    (recur (i.inc count) (f x))
    x))
</code></pre>

<h3 id="macro_1">macro:</h3>
<pre><code>Macro-definition macro.

(macro: #export (ident-for tokens)
  (case tokens
    (^template [&lt;tag&gt;]
     (^ (list [_ (&lt;tag&gt; [prefix name])]))
     (return (list (` [(~ (text$ prefix)) (~ (text$ name))]))))
    ([#;SymbolS] [#;TagS])

    _
    (fail &quot;Wrong syntax for ident-for&quot;)))
</code></pre>

<h3 id="module_1">module:</h3>
<pre><code>Module-definition macro.

Can take optional annotations and allows the specification of modules to import.

## Examples
(;module: {#;doc &quot;Some documentation...&quot;}
  lux
  (lux (control (monad #as M #refer #all))
       (data (text #open (&quot;Text/&quot; Monoid&lt;Text&gt;))
             (struct (list #open (&quot;List/&quot; Monad&lt;List&gt;)))
             maybe
             (ident #open (&quot;Ident/&quot; Codec&lt;Text,Ident&gt;)))
       meta
       (macro ast))
  (.. (type #open (&quot;&quot; Eq&lt;Type&gt;))))

(;module: {#;doc &quot;Some documentation...&quot;}
  lux
  (lux (control [&quot;M&quot; monad #*])
       (data [text &quot;Text/&quot; Monoid&lt;Text&gt;]
             (struct [list &quot;List/&quot; Monad&lt;List&gt;])
             maybe
             [ident &quot;Ident/&quot; Codec&lt;Text,Ident&gt;])
       meta
       (macro ast))
  (.. [type &quot;&quot; Eq&lt;Type&gt;]))
</code></pre>

<h3 id="open_1">open</h3>
<pre><code>## Opens a structure and generates a definition for each of its members (including nested members).
## For example:
(open Number&lt;Int&gt; &quot;i:&quot;)
## Will generate:
(def: i:+ (:: Number&lt;Int&gt; +))
(def: i:- (:: Number&lt;Int&gt; -))
(def: i:* (:: Number&lt;Int&gt; *))
...
</code></pre>

<h3 id="or_1">or</h3>
<pre><code>Short-circuiting &quot;or&quot;.
(or true false true) ## =&gt; true
</code></pre>

<h3 id="set">set@</h3>
<pre><code>## Sets the value of a record at a given tag.
(set@ #name &quot;Lux&quot; lang)

## Can also work with multiple levels of nesting:
(set@ [#foo #bar #baz] value my-record)

## And, if only the slot/path and (optionally) the value are given, generates a
## mutator function:
(let [setter (set@ [#foo #bar #baz] value)]
  (setter my-record))

(let [setter (set@ [#foo #bar #baz])]
  (setter value my-record))
</code></pre>

<h3 id="sig">sig:</h3>
<pre><code>## Definition of signatures ala ML.
(sig: #export (Ord a)
  (: (Eq a)
     eq)
  (: (-&gt; a a Bool)
     &lt;)
  (: (-&gt; a a Bool)
     &lt;=)
  (: (-&gt; a a Bool)
     &gt;)
  (: (-&gt; a a Bool)
     &gt;=))
</code></pre>

<h3 id="struct">struct</h3>
<pre><code>Not meant to be used directly. Prefer &quot;struct:&quot;.
</code></pre>

<h3 id="struct_1">struct:</h3>
<pre><code>## Definition of structures ala ML.
(struct: #export Ord&lt;Int&gt; (Ord Int)
  (def: eq Eq&lt;Int&gt;)
  (def: (&lt; test subject)
    (lux;&lt; test subject))
  (def: (&lt;= test subject)
    (or (lux;&lt; test subject)
        (lux;= test subject)))
  (def: (lux;&gt; test subject)
    (lux;&gt; test subject))
  (def: (lux;&gt;= test subject)
    (or (lux;&gt; test subject)
        (lux;= test subject))))
</code></pre>

<h3 id="template_1">template:</h3>
<pre><code>## Define macros in the style of do-template and ^template.
## For simple macros that don't need any fancy features.
(template: (square x)
  (i.* x x))
</code></pre>

<h3 id="type_1">type</h3>
<pre><code>## Takes a type expression and returns it's representation as data-structure.
(type (All [a] (Maybe (List a))))
</code></pre>

<h3 id="type-of">type-of</h3>
<pre><code>## Generates the type corresponding to a given definition or variable.
(let [my-num (: Int 123)]
  (type-of my-num))

## ==
Int
</code></pre>

<h3 id="type_2">type:</h3>
<pre><code>## The type-definition macro.
(type: (List a)
  #Nil
  (#Cons a (List a)))
</code></pre>

<h3 id="undefined">undefined</h3>
<pre><code>## Meant to be used as a stand-in for functions with undefined implementations.
## Undefined expressions will type-check against everything, so they make good dummy implementations.
(def: (square x)
  (-&gt; Int Int)
  (undefined))

## If an undefined expression is ever evaluated, it will raise an error.
</code></pre>

<h3 id="update">update@</h3>
<pre><code>## Modifies the value of a record at a given tag, based on some function.
(update@ #age i.inc person)

## Can also work with multiple levels of nesting:
(update@ [#foo #bar #baz] func my-record)

## And, if only the slot/path and (optionally) the value are given, generates a
## mutator function:
(let [updater (update@ [#foo #bar #baz] func)]
  (updater my-record))

(let [updater (update@ [#foo #bar #baz])]
  (updater func my-record))
</code></pre>

<h3 id="with-cursor">with-cursor</h3>
<pre><code>## Given some text, appends to it a prefix for identifying where the text comes from.
## For example:
(with-cursor (format &quot;User: &quot; user-id))

## Would be the same as:
(format &quot;[the-module,the-line,the-column] &quot; (format &quot;User: &quot; user-id))
</code></pre>

<h3 id="_16">|</h3>
<pre><code>## Variant types:
(| Text Int Bool)

## The empty tuple, a.k.a. Void.
(|)
</code></pre>

<h3 id="_17">|&gt;</h3>
<pre><code>## Piping macro.
(|&gt; elems (map -&gt;Text) (interpose &quot; &quot;) (fold Text/append &quot;&quot;))

## =&gt;
(fold Text/append &quot;&quot;
      (interpose &quot; &quot;
                 (map -&gt;Text elems)))
</code></pre>

<h3 id="_18">|&gt;.</h3>
<pre><code>## Similar to the piping macro, but rather than taking an initial object to work on, creates a function for taking it.
(|&gt; (map -&gt;Text) (interpose &quot; &quot;) (fold Text/append &quot;&quot;))
## =&gt;
(lambda [&lt;something&gt;]
  (fold Text/append &quot;&quot;
         (interpose &quot; &quot;
                    (map -&gt;Text &lt;something&gt;))))
</code></pre>

<h2 id="values">Values</h2>
<h3 id="_19">.</h3>
<pre><code>Function composition.
</code></pre>

<p><code>(All [a b c] (-&gt; (-&gt; b c) (-&gt; a b) a c))</code></p>
<h3 id="error-message">(error! message)</h3>
<pre><code>## Causes an error, with the given error message.
(error! &quot;OH NO!&quot;)
</code></pre>

<p><code>(-&gt; Text Bottom)</code></p>
<h3 id="f">f.%</h3>
<pre><code>Frac(tional) remainder.
</code></pre>

<p><code>(-&gt; Frac Frac Frac)</code></p>
<h3 id="f_1">f.*</h3>
<pre><code>Frac(tional) multiplication.
</code></pre>

<p><code>(-&gt; Frac Frac Frac)</code></p>
<h3 id="f_2">f.+</h3>
<pre><code>Frac(tional) addition.
</code></pre>

<p><code>(-&gt; Frac Frac Frac)</code></p>
<h3 id="f-">f.-</h3>
<pre><code>Frac(tional) substraction.
</code></pre>

<p><code>(-&gt; Frac Frac Frac)</code></p>
<h3 id="f_3">f./</h3>
<pre><code>Frac(tional) division.
</code></pre>

<p><code>(-&gt; Frac Frac Frac)</code></p>
<h3 id="f_4">f.&lt;</h3>
<pre><code>Fractional less-than.
</code></pre>

<p><code>(-&gt; Frac Frac Bool)</code></p>
<h3 id="f_5">f.&lt;=</h3>
<pre><code>Fractional less-than-equal.
</code></pre>

<p><code>(-&gt; Frac Frac Bool)</code></p>
<h3 id="f_6">f.=</h3>
<pre><code>Fractional equality.
</code></pre>

<p><code>(-&gt; Frac Frac Bool)</code></p>
<h3 id="f_7">f.&gt;</h3>
<pre><code>Fractional greater-than.
</code></pre>

<p><code>(-&gt; Frac Frac Bool)</code></p>
<h3 id="f_8">f.&gt;=</h3>
<pre><code>Fractional greater-than-equal.
</code></pre>

<p><code>(-&gt; Frac Frac Bool)</code></p>
<h3 id="fmax">f.max</h3>
<pre><code>Frac(tional) maximum.
</code></pre>

<p><code>(-&gt; Frac Frac Frac)</code></p>
<h3 id="fmin">f.min</h3>
<pre><code>Frac(tional) minimum.
</code></pre>

<p><code>(-&gt; Frac Frac Frac)</code></p>
<h3 id="frac-to-real-input">(frac-to-real input)</h3>
<p><code>(-&gt; Frac Real)</code></p>
<h3 id="i">i.%</h3>
<pre><code>Int(eger) remainder.
</code></pre>

<p><code>(-&gt; Int Int Int)</code></p>
<h3 id="i_1">i.*</h3>
<pre><code>Int(eger) multiplication.
</code></pre>

<p><code>(-&gt; Int Int Int)</code></p>
<h3 id="i_2">i.+</h3>
<pre><code>Int(eger) addition.
</code></pre>

<p><code>(-&gt; Int Int Int)</code></p>
<h3 id="i-">i.-</h3>
<pre><code>Int(eger) substraction.
</code></pre>

<p><code>(-&gt; Int Int Int)</code></p>
<h3 id="i_3">i./</h3>
<pre><code>Int(eger) division.
</code></pre>

<p><code>(-&gt; Int Int Int)</code></p>
<h3 id="i_4">i.&lt;</h3>
<pre><code>Integer less-than.
</code></pre>

<p><code>(-&gt; Int Int Bool)</code></p>
<h3 id="i_5">i.&lt;=</h3>
<pre><code>Integer less-than-equal.
</code></pre>

<p><code>(-&gt; Int Int Bool)</code></p>
<h3 id="i_6">i.=</h3>
<pre><code>Integer equality.
</code></pre>

<p><code>(-&gt; Int Int Bool)</code></p>
<h3 id="i_7">i.&gt;</h3>
<pre><code>Integer greater-than.
</code></pre>

<p><code>(-&gt; Int Int Bool)</code></p>
<h3 id="i_8">i.&gt;=</h3>
<pre><code>Integer greater-than-equal.
</code></pre>

<p><code>(-&gt; Int Int Bool)</code></p>
<h3 id="idec-value">(i.dec value)</h3>
<pre><code>Decrement function.
</code></pre>

<p><code>(-&gt; Int Int)</code></p>
<h3 id="ieven-n">(i.even? n)</h3>
<p><code>(-&gt; Int Bool)</code></p>
<h3 id="iinc-value">(i.inc value)</h3>
<pre><code>Increment function.
</code></pre>

<p><code>(-&gt; Int Int)</code></p>
<h3 id="imax">i.max</h3>
<pre><code>Int(eger) maximum.
</code></pre>

<p><code>(-&gt; Int Int Int)</code></p>
<h3 id="imin">i.min</h3>
<pre><code>Int(eger) minimum.
</code></pre>

<p><code>(-&gt; Int Int Int)</code></p>
<h3 id="iodd-n">(i.odd? n)</h3>
<p><code>(-&gt; Int Bool)</code></p>
<h3 id="id-x">(id x)</h3>
<pre><code>Identity function.

Does nothing to it's argument and just returns it.
</code></pre>

<p><code>(All [a] (-&gt; a a))</code></p>
<h3 id="int-to-nat-input">(int-to-nat input)</h3>
<p><code>(-&gt; Int Nat)</code></p>
<h3 id="int-to-real-n">(int-to-real n)</h3>
<p><code>(-&gt; Int Real)</code></p>
<h3 id="is-left-right">(is left right)</h3>
<pre><code>## Tests whether the 2 values are identical (not just &quot;equal&quot;).
## This one should succeed:
(let [value 5]
  (is 5 5))

## This one should fail:
(is 5 (i.+ 2 3))
</code></pre>

<p><code>(All [a] (-&gt; a a Bool))</code></p>
<h3 id="log">log!</h3>
<pre><code>Logs message to standard output.

Useful for debugging.
</code></pre>

<p><code>(-&gt; Text Unit)</code></p>
<h3 id="n">n.%</h3>
<pre><code>Nat(ural) remainder.
</code></pre>

<p><code>(-&gt; Nat Nat Nat)</code></p>
<h3 id="n_1">n.*</h3>
<pre><code>Nat(ural) multiplication.
</code></pre>

<p><code>(-&gt; Nat Nat Nat)</code></p>
<h3 id="n_2">n.+</h3>
<pre><code>Nat(ural) addition.
</code></pre>

<p><code>(-&gt; Nat Nat Nat)</code></p>
<h3 id="n-">n.-</h3>
<pre><code>Nat(ural) substraction.
</code></pre>

<p><code>(-&gt; Nat Nat Nat)</code></p>
<h3 id="n_3">n./</h3>
<pre><code>Nat(ural) division.
</code></pre>

<p><code>(-&gt; Nat Nat Nat)</code></p>
<h3 id="n_4">n.&lt;</h3>
<pre><code>Natural less-than.
</code></pre>

<p><code>(-&gt; Nat Nat Bool)</code></p>
<h3 id="n_5">n.&lt;=</h3>
<pre><code>Natural less-than-equal.
</code></pre>

<p><code>(-&gt; Nat Nat Bool)</code></p>
<h3 id="n_6">n.=</h3>
<pre><code>Natural equality.
</code></pre>

<p><code>(-&gt; Nat Nat Bool)</code></p>
<h3 id="n_7">n.&gt;</h3>
<pre><code>Natural greater-than.
</code></pre>

<p><code>(-&gt; Nat Nat Bool)</code></p>
<h3 id="n_8">n.&gt;=</h3>
<pre><code>Natural greater-than-equal.
</code></pre>

<p><code>(-&gt; Nat Nat Bool)</code></p>
<h3 id="ndec-value">(n.dec value)</h3>
<pre><code>Decrement function.
</code></pre>

<p><code>(-&gt; Nat Nat)</code></p>
<h3 id="neven-n">(n.even? n)</h3>
<p><code>(-&gt; Nat Bool)</code></p>
<h3 id="ninc-value">(n.inc value)</h3>
<pre><code>Increment function.
</code></pre>

<p><code>(-&gt; Nat Nat)</code></p>
<h3 id="nmax">n.max</h3>
<pre><code>Nat(ural) maximum.
</code></pre>

<p><code>(-&gt; Nat Nat Nat)</code></p>
<h3 id="nmin">n.min</h3>
<pre><code>Nat(ural) minimum.
</code></pre>

<p><code>(-&gt; Nat Nat Nat)</code></p>
<h3 id="nodd-n">(n.odd? n)</h3>
<p><code>(-&gt; Nat Bool)</code></p>
<h3 id="nat-to-int-input">(nat-to-int input)</h3>
<p><code>(-&gt; Nat Int)</code></p>
<h3 id="not">not</h3>
<pre><code>## Boolean negation.

(not true) == false

(not false) == true
</code></pre>

<p><code>(-&gt; Bool Bool)</code></p>
<h3 id="r">r.%</h3>
<pre><code>Real remainder.
</code></pre>

<p><code>(-&gt; Real Real Real)</code></p>
<h3 id="r_1">r.*</h3>
<pre><code>Real multiplication.
</code></pre>

<p><code>(-&gt; Real Real Real)</code></p>
<h3 id="r_2">r.+</h3>
<pre><code>Real addition.
</code></pre>

<p><code>(-&gt; Real Real Real)</code></p>
<h3 id="r-">r.-</h3>
<pre><code>Real substraction.
</code></pre>

<p><code>(-&gt; Real Real Real)</code></p>
<h3 id="r_3">r./</h3>
<pre><code>Real division.
</code></pre>

<p><code>(-&gt; Real Real Real)</code></p>
<h3 id="r_4">r.&lt;</h3>
<pre><code>Real less-than.
</code></pre>

<p><code>(-&gt; Real Real Bool)</code></p>
<h3 id="r_5">r.&lt;=</h3>
<pre><code>Real less-than-equal.
</code></pre>

<p><code>(-&gt; Real Real Bool)</code></p>
<h3 id="r_6">r.=</h3>
<pre><code>Real equality.
</code></pre>

<p><code>(-&gt; Real Real Bool)</code></p>
<h3 id="r_7">r.&gt;</h3>
<pre><code>Real greater-than.
</code></pre>

<p><code>(-&gt; Real Real Bool)</code></p>
<h3 id="r_8">r.&gt;=</h3>
<pre><code>Real greater-than-equal.
</code></pre>

<p><code>(-&gt; Real Real Bool)</code></p>
<h3 id="rmax">r.max</h3>
<pre><code>Real minimum.
</code></pre>

<p><code>(-&gt; Real Real Real)</code></p>
<h3 id="rmin">r.min</h3>
<pre><code>Real minimum.
</code></pre>

<p><code>(-&gt; Real Real Real)</code></p>
<h3 id="real-to-frac-input">(real-to-frac input)</h3>
<p><code>(-&gt; Real Frac)</code></p>
<h3 id="real-to-int-n">(real-to-int n)</h3>
<p><code>(-&gt; Real Int)</code></p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../lux_cli/" class="btn btn-neutral float-right" title="Lux cli">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href=".." class="btn btn-neutral" title="Home"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href=".." style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../lux_cli/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script src="../js/theme.js"></script>

</body>
</html>
