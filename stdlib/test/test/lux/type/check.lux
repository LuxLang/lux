(;module:
  lux
  (lux [io]
       (control [monad #+ do Monad])
       (data [text "text/" Monoid<Text> Eq<Text>]
             text/format
             [number]
             maybe
             (coll [list]))
       ["r" math/random]
       [type]
       ["@" type/check])
  lux/test)

## [Utils]
(def: gen-name
  (r;Random Text)
  (do r;Monad<Random>
    [size (|> r;nat (:: @ map (n.% +10)))]
    (r;text size)))

(def: gen-ident
  (r;Random Ident)
  (r;seq gen-name gen-name))

(def: gen-type
  (r;Random Type)
  (let [(^open "r/") r;Monad<Random>]
    (r;rec (function [gen-type]
             ($_ r;alt
                 (r;seq gen-name (r/wrap (list)))
                 (r/wrap [])
                 (r/wrap [])
                 (r;seq gen-type gen-type)
                 (r;seq gen-type gen-type)
                 (r;seq gen-type gen-type)
                 r;nat
                 r;nat
                 r;nat
                 (r;seq (r/wrap (list)) gen-type)
                 (r;seq (r/wrap (list)) gen-type)
                 (r;seq gen-type gen-type)
                 (r;seq gen-ident gen-type)
                 )))))

(def: (valid-type? type)
  (-> Type Bool)
  (case type
    (#;Host name params)
    (list;every? valid-type? params)
    
    (^or #;Void #;Unit (#;Ex id))
    true

    (^template [<tag>]
      (<tag> left right)
      (and (valid-type? left) (valid-type? right)))
    ([#;Sum] [#;Product] [#;Function])

    (#;Named name type')
    (valid-type? type')

    _
    false))

(def: (type-checks? input)
  (-> (@;Check []) Bool)
  (case (@;run @;fresh-context input)
    (#;Right [])
    true

    (#;Left error)
    false))

## [Tests]
(context: "Top and Bottom"
  [sample (|> gen-type (r;filter valid-type?))]
  ($_ seq
      (test "Top is the super-type of everything."
            (@;checks? Top sample))

      (test "Bottom is the sub-type of everything."
            (@;checks? sample Bottom))
      ))

(context: "Simple type-checking."
  ($_ seq
      (test "Unit and Void match themselves."
            (and (@;checks? Void Void)
                 (@;checks? Unit Unit)))

      (test "Existential types only match with themselves."
            (and (type-checks? (do @;Monad<Check>
                                 [[id ex] @;existential]
                                 (@;check ex ex)))
                 (not (type-checks? (do @;Monad<Check>
                                      [[lid lex] @;existential
                                       [rid rex] @;existential]
                                      (@;check lex rex))))))

      (test "Names don't affect type-checking."
            (and (type-checks? (do @;Monad<Check>
                                 [[id ex] @;existential]
                                 (@;check (#;Named ["module" "name"] ex)
                                          ex)))
                 (type-checks? (do @;Monad<Check>
                                 [[id ex] @;existential]
                                 (@;check ex
                                          (#;Named ["module" "name"] ex))))
                 (type-checks? (do @;Monad<Check>
                                 [[id ex] @;existential]
                                 (@;check (#;Named ["module" "name"] ex)
                                          (#;Named ["module" "name"] ex))))))

      (test "Can type-check functions."
            (and (@;checks? (#;Function Bottom Top)
                            (#;Function Top Bottom))
                 (not (@;checks? (#;Function Top Bottom)
                                 (#;Function Bottom Top)))))
      ))

(context: "Type application"
  [meta gen-type
   data gen-type]
  (test "Can type-check type application."
        (and (@;checks? (#;Apply data (#;Apply meta Meta))
                        (type;tuple (list meta data)))
             (@;checks? (type;tuple (list meta data))
                        (#;Apply data (#;Apply meta Meta))))))

(context: "Host types"
  [nameL gen-name
   nameR (|> gen-name (r;filter (. not (text/= nameL))))
   paramL gen-type
   paramR (|> gen-type (r;filter (|>. (@;checks? paramL) not)))]
  ($_ seq
      (test "Host types match when they have the same name and the same parameters."
            (@;checks? (#;Host nameL (list paramL))
                       (#;Host nameL (list paramL))))

      (test "Names matter to host types."
            (not (@;checks? (#;Host nameL (list paramL))
                            (#;Host nameR (list paramL)))))

      (test "Parameters matter to host types."
            (not (@;checks? (#;Host nameL (list paramL))
                            (#;Host nameL (list paramR)))))
      ))

(context: "Type-vars"
  ($_ seq
      (test "Type-vars check against themselves."
            (type-checks? (@;with (function [[id var]] (@;check var var)))))

      (test "Can bind unbound type-vars by type-checking against them."
            (and (type-checks? (@;with (function [[id var]] (@;check var #;Unit))))
                 (type-checks? (@;with (function [[id var]] (@;check #;Unit var))))))

      (test "Can't rebind already bound type-vars."
            (not (type-checks? (@;with (function [[id var]]
                                         (do @;Monad<Check>
                                           [_ (@;check var #;Unit)]
                                           (@;check var #;Void)))))))

      (test "If the type bound to a var is a super-type to another, then the var is also a super-type."
            (type-checks? (@;with (function [[id var]]
                                    (do @;Monad<Check>
                                      [_ (@;check var Top)]
                                      (@;check var #;Unit))))))

      (test "If the type bound to a var is a sub-type of another, then the var is also a sub-type."
            (type-checks? (@;with (function [[id var]]
                                    (do @;Monad<Check>
                                      [_ (@;check var Bottom)]
                                      (@;check #;Unit var))))))
      ))
