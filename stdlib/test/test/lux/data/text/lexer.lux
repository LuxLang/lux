(;module:
  lux
  (lux (control monad
                pipe)
       [io]
       (data ["R" result]
             [text "T/" Eq<Text>]
             text/format
             ["&" text/lexer]
             (coll [list]))
       ["r" math/random])
  lux/test)

## [Utils]
(def: (should-fail input)
  (All [a] (-> (R;Result a) Bool))
  (case input
    (#;Left _) true
    _          false))

(def: (should-passT test input)
  (-> Text (R;Result Text) Bool)
  (case input
    (#;Right output)
    (T/= test output)
    
    _
    false))

(def: (should-passL test input)
  (-> (List Text) (R;Result (List Text)) Bool)
  (let [(^open "L/") (list;Eq<List> text;Eq<Text>)]
    (case input
      (#;Right output)
      (L/= test output)
      
      _
      false)))

(def: (should-passE test input)
  (-> (Either Text Text) (R;Result (Either Text Text)) Bool)
  (case input
    (#;Right output)
    (case [test output]
      [(#;Left test) (#;Left output)]
      (T/= test output)

      [(#;Right test) (#;Right output)]
      (T/= test output)

      _
      false)
    
    _
    false))

## [Tests]
(test: "End"
  ($_ seq
      (assert "Can detect the end of the input."
              (|> (&;run ""
                         &;end)
                  (case> (#;Right _) true _ false)))
      
      (assert "Won't mistake non-empty text for no more input."
              (|> (&;run "YOLO"
                         &;end)
                  (case> (#;Left _) true _ false)))
      ))

(test: "Literals"
  [size (|> r;nat (:: @ map (|>. (n.% +100) (n.max +10))))
   pre (r;text size)
   post (|> (r;text size)
            (r;filter (|>. (text;starts-with? pre) not)))]
  ($_ seq
      (assert "Can find literal text fragments."
              (and (|> (&;run (format pre post)
                              (&;this pre))
                       (case> (#;Right []) true _ false))
                   (|> (&;run post
                              (&;this pre))
                       (case> (#;Left _) true _ false))))
      ))

(test: "Char lexers"
  ($_ seq
      (assert "Can lex characters."
              (and (|> (&;run "YOLO"
                              (&;this "Y"))
                       (case> (#;Right []) true _ false))
                   (|> (&;run "MEME"
                              (&;this "Y"))
                       (case> (#;Left _) true _ false))))

      (assert "Can lex characters ranges."
              (and (should-passT "Y" (&;run "YOLO"
                                            (&;char-range #"X" #"Z")))
                   (should-fail (&;run "MEME"
                                       (&;char-range #"X" #"Z")))))
      ))

(test: "Custom lexers"
  ($_ seq
      (assert "Can lex anything"
              (and (should-passT "A" (&;run "A"
                                            &;any))
                   (should-fail (&;run ""
                                       &;any))))
      
      (assert "Can lex upper-case and &;lower-case letters."
              (and (should-passT "Y" (&;run "YOLO"
                                            &;upper))
                   (should-fail (&;run "meme"
                                       &;upper))
                   
                   (should-passT "y" (&;run "yolo"
                                            &;lower))
                   (should-fail (&;run "MEME"
                                       &;lower))))

      (assert "Can lex numbers."
              (and (should-passT "1" (&;run "1"
                                            &;digit))
                   (should-fail (&;run " "
                                       &;digit))

                   (should-passT "7" (&;run "7"
                                            &;oct-digit))
                   (should-fail (&;run "8"
                                       &;oct-digit))

                   (should-passT "1" (&;run "1"
                                            &;hex-digit))
                   (should-passT "a" (&;run "a"
                                            &;hex-digit))
                   (should-passT "A" (&;run "A"
                                            &;hex-digit))
                   (should-fail (&;run " "
                                       &;hex-digit))
                   ))

      (assert "Can lex alphabetic characters."
              (and (should-passT "A" (&;run "A"
                                            &;alpha))
                   (should-passT "a" (&;run "a"
                                            &;alpha))
                   (should-fail (&;run "1"
                                       &;alpha))))

      (assert "Can lex alphanumeric characters."
              (and (should-passT "A" (&;run "A"
                                            &;alpha-num))
                   (should-passT "a" (&;run "a"
                                            &;alpha-num))
                   (should-passT "1" (&;run "1"
                                            &;alpha-num))
                   (should-fail (&;run " "
                                       &;alpha-num))))

      (assert "Can lex white-space."
              (and (should-passT " " (&;run " "
                                            &;space))
                   (should-fail (&;run "8"
                                       &;space))))
      ))

(test: "Combinators"
  ($_ seq
      (assert "Can combine lexers sequentially."
              (and (|> (&;run "YOLO"
                              (&;seq &;any &;any))
                       (case> (#;Right ["Y" "O"]) true
                              _ false))
                   (should-fail (&;run "Y"
                                       (&;seq &;any &;any)))))
      
      (assert "Can combine lexers alternatively."
              (and (should-passE (#;Left "0") (&;run "0"
                                                     (&;alt &;digit &;upper)))
                   (should-passE (#;Right "A") (&;run "A"
                                                      (&;alt &;digit &;upper)))
                   (should-fail (&;run "a"
                                       (&;alt &;digit &;upper)))))

      (assert "Can create the opposite of a lexer."
              (and (should-passT "a" (&;run "a"
                                            (&;not (&;alt &;digit &;upper))))
                   (should-fail (&;run "A"
                                       (&;not (&;alt &;digit &;upper))))))
      
      (assert "Can use either lexer."
              (and (should-passT "0" (&;run "0"
                                            (&;either &;digit &;upper)))
                   (should-passT "A" (&;run "A"
                                            (&;either &;digit &;upper)))
                   (should-fail (&;run "a"
                                       (&;either &;digit &;upper)))))
      
      (assert "Can select from among a set of characters."
              (and (should-passT "C" (&;run "C"
                                            (&;one-of "ABC")))
                   (should-fail (&;run "D"
                                       (&;one-of "ABC")))))

      (assert "Can avoid a set of characters."
              (and (should-passT "D" (&;run "D"
                                            (&;none-of "ABC")))
                   (should-fail (&;run "C"
                                       (&;none-of "ABC")))))
      
      (assert "Can lex using arbitrary predicates."
              (and (should-passT "D" (&;run "D"
                                            (&;satisfies (function [c] true))))
                   (should-fail (&;run "C"
                                       (&;satisfies (function [c] false))))))
      
      (assert "Can apply a lexer multiple times."
              (and (should-passT "0123456789ABCDEF" (&;run "0123456789ABCDEF yolo"
                                                           (&;many' &;hex-digit)))
                   (should-fail (&;run "yolo"
                                       (&;many' &;hex-digit)))

                   (should-passT "" (&;run "yolo"
                                           (&;some' &;hex-digit)))))
      ))

(test: "Yet more combinators..."
  ($_ seq
      (assert "Can fail at will."
              (should-fail (&;run "yolo"
                                  (&;fail "Well, it really SHOULD fail..."))))
      
      (assert "Can make assertions."
              (and (should-fail (&;run "yolo"
                                       (&;assert "Well, it really SHOULD fail..." false)))
                   (|> (&;run "yolo"
                              (&;assert "GO, GO, GO!" true))
                       (case> (#;Right []) true
                              _ false))))

      (assert "Can apply a lexer multiple times."
              (and (should-passL (list "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F")
                                 (&;run "0123456789ABCDEF yolo"
                                        (&;many &;hex-digit)))
                   (should-fail (&;run "yolo"
                                       (&;many &;hex-digit)))

                   (should-passL (list)
                                 (&;run "yolo"
                                        (&;some &;hex-digit)))))
      
      (assert "Can lex exactly N elements."
              (and (should-passL (list "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F")
                                 (&;run "0123456789ABCDEF yolo"
                                        (&;exactly +16 &;hex-digit)))
                   (should-passL (list "0" "1" "2")
                                 (&;run "0123456789ABCDEF yolo"
                                        (&;exactly +3 &;hex-digit)))
                   (should-fail (&;run "0123456789ABCDEF yolo"
                                       (&;exactly +17 &;hex-digit)))))
      
      (assert "Can lex at-most N elements."
              (and (should-passL (list "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F")
                                 (&;run "0123456789ABCDEF yolo"
                                        (&;at-most +16 &;hex-digit)))
                   (should-passL (list "0" "1" "2")
                                 (&;run "0123456789ABCDEF yolo"
                                        (&;at-most +3 &;hex-digit)))
                   (should-passL (list "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F")
                                 (&;run "0123456789ABCDEF yolo"
                                        (&;at-most +17 &;hex-digit)))))
      
      (assert "Can lex tokens between lower and upper boundaries of quantity."
              (and (should-passL (list "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F")
                                 (&;run "0123456789ABCDEF yolo"
                                        (&;between +0 +16 &;hex-digit)))
                   (should-passL (list "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F")
                                 (&;run "0123456789ABCDEF yolo"
                                        (&;between +3 +16 &;hex-digit)))
                   (should-fail (&;run "0123456789ABCDEF yolo"
                                       (&;between +17 +100 &;hex-digit)))
                   (should-passL (list "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F")
                                 (&;run "0123456789ABCDEF yolo"
                                        (&;between +15 +20 &;hex-digit)))))

      (assert "Can optionally lex a token."
              (and (|> (&;run "123abc"
                              (&;opt &;hex-digit))
                       (case> (#;Right (#;Some "1")) true
                              _ false))
                   (|> (&;run "yolo"
                              (&;opt &;hex-digit))
                       (case> (#;Right #;None) true
                              _ false))))

      (assert "Can take into account separators during lexing."
              (should-passL (list "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "a" "b" "c" "d" "e" "f")
                            (&;run "0 1 2 3 4 5 6 7 8 9 a b c d e f YOLO"
                                   (&;sep-by &;space &;hex-digit))))
      
      (assert "Can obtain the whole of the remaining input."
              (should-passT "yolo" (&;run "yolo"
                                          &;get-input)))
      ))
