(.module:
  lux
  (lux [io]
       (control [monad #+ do Monad])
       (data (coll ["&" set #+ Set]
                   [list "" Fold<List>])
             [number])
       ["r" math/random])
  lux/test)

(def: gen-nat
  (r.Random Nat)
  (|> r.nat
      (:: r.Monad<Random> map (n/% +100))))

(context: "Sets"
  (<| (times +100)
      (do @
        [sizeL gen-nat
         sizeR gen-nat
         setL (r.set number.Hash<Nat> sizeL gen-nat)
         setR (r.set number.Hash<Nat> sizeR gen-nat)
         non-member (|> gen-nat
                        (r.filter (|>> (&.member? setL) not)))
         #let [(^open "&/") &.Equivalence<Set>]]
        ($_ seq
            (test "I can query the size of a set."
                  (and (n/= sizeL (&.size setL))
                       (n/= sizeR (&.size setR))))

            (test "Converting sets to/from lists can't change their values."
                  (|> setL
                      &.to-list (&.from-list number.Hash<Nat>)
                      (&/= setL)))

            (test "Every set is a sub-set of the union of itself with another."
                  (let [setLR (&.union setL setR)]
                    (and (&.sub? setLR setL)
                         (&.sub? setLR setR))))

            (test "Every set is a super-set of the intersection of itself with another."
                  (let [setLR (&.intersection setL setR)]
                    (and (&.super? setLR setL)
                         (&.super? setLR setR))))

            (test "Union with the empty set leaves a set unchanged."
                  (&/= setL
                       (&.union (&.new number.Hash<Nat>)
                                setL)))

            (test "Intersection with the empty set results in the empty set."
                  (let [empty-set (&.new number.Hash<Nat>)]
                    (&/= empty-set
                         (&.intersection empty-set setL))))

            (test "After substracting a set A from another B, no member of A can be a member of B."
                  (let [sub (&.difference setR setL)]
                    (not (list.any? (&.member? sub) (&.to-list setR)))))

            (test "Every member of a set must be identifiable."
                  (and (not (&.member? setL non-member))
                       (&.member? (&.add non-member setL) non-member)
                       (not (&.member? (&.remove non-member (&.add non-member setL)) non-member))))
            ))))
