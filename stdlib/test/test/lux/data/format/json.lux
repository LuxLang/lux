(;module:
  lux
  (lux [io]
       (control monad
                codec
                eq
                pipe)
       (data [text "Text/" Monoid<Text>]
             text/format
             [result]
             [bool]
             [maybe]
             [number "i/" Number<Int>]
             (format ["&" json])
             (coll [vector #+ vector]
                   ["d" dict]
                   [list]))
       [macro #+ with-gensyms]
       (macro [code]
              [syntax #+ syntax:]
              [poly #+ derived:])
       ["r" math/random]
       test)
  )

(def: gen-json
  (r;Random &;JSON)
  (r;rec (function [gen-json]
           (do r;Monad<Random>
             [size (:: @ map (n.% +2) r;nat)]
             ($_ r;alt
                 (:: @ wrap [])
                 r;bool
                 (|> r;real (:: @ map (r.* 1_000_000.0)))
                 (r;text size)
                 (r;vector size gen-json)
                 (r;dict text;Hash<Text> size (r;text size) gen-json)
                 )))))

(context: "JSON"
  [sample gen-json
   #let [(^open "&/") &;Eq<JSON>
         (^open "&/") &;Codec<Text,JSON>]]
  ($_ seq
      (test "Every JSON is equal to itself."
            (&/= sample sample))

      (test "Can encode/decode JSON."
            (|> sample &/encode &/decode
                (case> (#;Right result)
                       (&/= sample result)

                       (#;Left _)
                       false)))
      ))

(type: Variant
  (#Case0 Bool)
  (#Case1 Int)
  (#Case2 Real))

(type: Record
  {#unit Unit
   #bool Bool
   #int Int
   #real Real
   #text Text
   #maybe (Maybe Int)
   #list (List Int)
   #variant Variant
   #tuple [Int Real Text]
   #dict (d;Dict Text Int)})

(def: gen-record
  (r;Random Record)
  (do r;Monad<Random>
    [size (:: @ map (n.% +2) r;nat)
     #let [gen-int (|> r;int (:: @ map (|>. i/abs (i.% 1_000_000))))]]
    ($_ r;seq
        (:: @ wrap [])
        r;bool
        gen-int
        r;real
        (r;text size)
        (r;maybe gen-int)
        (r;list size gen-int)
        ($_ r;alt r;bool gen-int r;real)
        ($_ r;seq gen-int r;real (r;text size))
        (r;dict text;Hash<Text> size (r;text size) gen-int)
        )))

(derived: (&;Codec<JSON,?> Record))

(struct: _ (Eq Record)
  (def: (= recL recR)
    (let [variant/= (function [left right]
                      (case [left right]
                        [(#Case0 left') (#Case0 right')]
                        (:: bool;Eq<Bool> = left' right')
                        
                        [(#Case1 left') (#Case1 right')]
                        (i.= left' right')
                        
                        [(#Case2 left') (#Case2 right')]
                        (r.= left' right')

                        _
                        false))]
      (and (:: bool;Eq<Bool> = (get@ #bool recL) (get@ #bool recR))
           (i.= (get@ #int recL) (get@ #int recR))
           (r.= (get@ #real recL) (get@ #real recR))
           (:: text;Eq<Text> = (get@ #text recL) (get@ #text recR))
           (:: (maybe;Eq<Maybe> number;Eq<Int>) = (get@ #maybe recL) (get@ #maybe recR))
           (:: (list;Eq<List> number;Eq<Int>) = (get@ #list recL) (get@ #list recR))
           (variant/= (get@ #variant recL) (get@ #variant recR))
           (let [[tL0 tL1 tL2] (get@ #tuple recL)
                 [tR0 tR1 tR2] (get@ #tuple recR)]
             (and (i.= tL0 tR0)
                  (r.= tL1 tR1)
                  (:: text;Eq<Text> = tL2 tR2)))
           (:: (d;Eq<Dict> i.=) = (get@ #dict recL) (get@ #dict recR))
           ))))

(context: "Polytypism"
  [sample gen-record
   #let [(^open "&/") Eq<Record>
         (^open "&/") Codec<JSON,Record>]]
  (test "Can encode/decode arbitrary types."
        (|> sample &/encode &/decode
            (case> (#;Right result)
                   (&/= sample result)

                   (#;Left _)
                   false))))
