(;module:
  lux
  (lux [io]
       (control monad)
       (data number
             [text "Text/" Monoid<Text> Eq<Text>]
             text/format)
       ["R" random]
       pipe)
  lux/test)

(do-template [category rand-gen <Eq> <Ord>]
  [(test: (format "[" category "] " "Eq & Ord")
     [x rand-gen
      y rand-gen]
     (assert "" (and (:: <Eq> = x x)
                     (or (:: <Eq> = x y)
                         (:: <Ord> < y x)
                         (:: <Ord> > y x)))))]

  ["Nat"  R;nat  Eq<Nat>  Ord<Nat>]
  ["Int"  R;int  Eq<Int>  Ord<Int>]
  ["Real" R;real Eq<Real> Ord<Real>]
  ["Deg"  R;deg  Eq<Deg>  Ord<Deg>]
  )

(do-template [category rand-gen <Number> <Ord>]
  [(test: (format "[" category "] " "Number")
     [x rand-gen
      #let [(^open) <Number>
            (^open) <Ord>]]
     (assert "" (and (>= x (abs x))
                     ## abs(0.0) == 0.0 && negate(abs(0.0)) == -0.0
                     (or (Text/= "Real" category)
                         (not (= x (negate x))))
                     (= x (negate (negate x)))
                     ## There is loss of precision when multiplying
                     (or (Text/= "Deg" category)
                         (= x (* (signum x)
                                 (abs x)))))))]

  ## ["Nat"  R;nat  Number<Nat>]
  ["Int"  R;int  Number<Int>  Ord<Int>]
  ["Real" R;real Number<Real> Ord<Real>]
  ["Deg"  R;deg  Number<Deg>  Ord<Deg>]
  )

(do-template [category rand-gen <Enum> <Number> <Ord>]
  [(test: (format "[" category "] " "Enum")
     [x rand-gen]
     (assert "" (let [(^open) <Number>
                      (^open) <Ord>]
                  (and (> x
                          (:: <Enum> succ x))
                       (< x
                          (:: <Enum> pred x))
                       
                       (= x
                          (|> x (:: <Enum> pred) (:: <Enum> succ)))
                       (= x
                          (|> x (:: <Enum> succ) (:: <Enum> pred)))
                       ))))]

  ["Nat"  R;nat Enum<Nat> Number<Nat> Ord<Nat>]
  ["Int"  R;int Enum<Int> Number<Int> Ord<Int>]
  )

(do-template [category rand-gen <Number> <Ord> <Interval> <test>]
  [(test: (format "[" category "] " "Interval")
     [x (|> rand-gen (R;filter <test>))
      #let [(^open) <Number>
            (^open) <Ord>]]
     (assert "" (and (<= x (:: <Interval> bottom))
                     (>= x (:: <Interval> top)))))]

  ["Nat"  R;nat  Number<Nat>  Ord<Nat>  Interval<Nat>  (lambda [_] true)]
  ["Int"  R;int  Number<Int>  Ord<Int>  Interval<Int>  (lambda [_] true)]
  ## Both min and max values will be positive (thus, greater than zero)
  ["Real" R;real Number<Real> Ord<Real> Interval<Real> (r.> 0.0)]
  ["Deg"  R;deg  Number<Deg>  Ord<Deg>  Interval<Deg>  (lambda [_] true)]
  )

(do-template [category rand-gen <Number> <Ord> <Monoid> <cap> <test>]
  [(test: (format "[" category "] " "Monoid")
     [x (|> rand-gen (:: @ map (|>. (:: <Number> abs) <cap>)) (R;filter <test>))
      #let [(^open) <Number>
            (^open) <Ord>
            (^open) <Monoid>]]
     (assert "Appending to unit doesn't change the value."
             (and (= x (append unit x))
                  (= x (append x unit))
                  (= unit (append unit unit)))))]

  ["Nat/Add"  R;nat  Number<Nat>  Ord<Nat>  Add@Monoid<Nat>  (n.% +1000)  (lambda [_] true)]
  ["Nat/Mul"  R;nat  Number<Nat>  Ord<Nat>  Mul@Monoid<Nat>  (n.% +1000)  (lambda [_] true)]
  ["Nat/Min"  R;nat  Number<Nat>  Ord<Nat>  Min@Monoid<Nat>  (n.% +1000)  (lambda [_] true)]
  ["Nat/Max"  R;nat  Number<Nat>  Ord<Nat>  Max@Monoid<Nat>  (n.% +1000)  (lambda [_] true)]
  ["Int/Add"  R;int  Number<Int>  Ord<Int>  Add@Monoid<Int>  (i.% 1000)   (lambda [_] true)]
  ["Int/Mul"  R;int  Number<Int>  Ord<Int>  Mul@Monoid<Int>  (i.% 1000)   (lambda [_] true)]
  ["Int/Min"  R;int  Number<Int>  Ord<Int>  Min@Monoid<Int>  (i.% 1000)   (lambda [_] true)]
  ["Int/Max"  R;int  Number<Int>  Ord<Int>  Max@Monoid<Int>  (i.% 1000)   (lambda [_] true)]
  ["Real/Add" R;real Number<Real> Ord<Real> Add@Monoid<Real> (r.% 1000.0) (r.> 0.0)]
  ["Real/Mul" R;real Number<Real> Ord<Real> Mul@Monoid<Real> (r.% 1000.0) (r.> 0.0)]
  ["Real/Min" R;real Number<Real> Ord<Real> Min@Monoid<Real> (r.% 1000.0) (r.> 0.0)]
  ["Real/Max" R;real Number<Real> Ord<Real> Max@Monoid<Real> (r.% 1000.0) (r.> 0.0)]
  ["Deg/Add"  R;deg  Number<Deg>  Ord<Deg>  Add@Monoid<Deg>  (d.% .125)   (lambda [_] true)]
  ## ["Deg/Mul"  R;deg  Number<Deg>  Ord<Deg>  Mul@Monoid<Deg>  (d.% .125)   (lambda [_] true)]
  ["Deg/Min" R;deg Number<Deg> Ord<Deg> Min@Monoid<Deg> (d.% .125)   (lambda [_] true)]
  ["Deg/Max" R;deg Number<Deg> Ord<Deg> Max@Monoid<Deg> (d.% .125)   (lambda [_] true)]
  )

(do-template [<category> <rand-gen> <Eq> <Codec>]
  [(test: (format "[" <category> "] " "Codec")
     [x <rand-gen>]
     (assert "Can encode/decode values."
             (|> x
                 (:: <Codec> encode)
                 (:: <Codec> decode)
                 (case> (#;Right x')
                        (:: <Eq> = x x')

                        (#;Left _)
                        false))))]

  ["Nat"  R;nat  Eq<Nat>  Codec<Text,Nat>]
  ["Int"  R;int  Eq<Int>  Codec<Text,Int>]
  ["Real" R;real Eq<Real> Codec<Text,Real>]
  ["Deg"  R;deg  Eq<Deg>  Codec<Text,Deg>]
  )

(do-template [<category> <rand-gen> <Eq> <Codec>]
  [(test: (format "[" <category> "] " "Alternative formats")
     [x <rand-gen>]
     (assert "Can encode/decode values."
             (|> x
                 (:: <Codec> encode)
                 (:: <Codec> decode)
                 (case> (#;Right x')
                        (:: <Eq> = x x')

                        (#;Left _)
                        false))))]

  ["Nat/Binary" R;nat  Eq<Nat>  Binary@Codec<Text,Nat>]
  ["Nat/Octal"  R;nat  Eq<Nat>  Octal@Codec<Text,Nat>]
  ["Nat/Hex"    R;nat  Eq<Nat>  Hex@Codec<Text,Nat>]
  )
