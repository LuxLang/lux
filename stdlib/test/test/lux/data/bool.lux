(.module:
  lux
  (lux (control ["M" monad (#+ do Monad)])
       [io]
       (data bool)
       ["r" math/random])
  lux/test)

(context: "Boolean operations."
  (<| (times +100)
      (do @
        [value r.bool]
        (test "" (and (not (and value (not value)))
                      (or value (not value))

                      (not (:: Or@Monoid<Bool> identity))
                      (:: Or@Monoid<Bool> compose value (not value))
                      (:: And@Monoid<Bool> identity)
                      (not (:: And@Monoid<Bool> compose value (not value)))
                      
                      (:: Equivalence<Bool> = value (not (not value)))
                      (not (:: Equivalence<Bool> = value (not value)))

                      (not (:: Equivalence<Bool> = value ((complement id) value)))
                      (:: Equivalence<Bool> = value ((complement not) value))

                      (case (|> value
                                (:: Codec<Text,Bool> encode)
                                (:: Codec<Text,Bool> decode))
                        (#.Right dec-value)
                        (:: Equivalence<Bool> = value dec-value)

                        (#.Left _)
                        false)
                      )))))
