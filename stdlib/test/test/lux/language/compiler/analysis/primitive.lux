(.module:
  [lux (#- primitive)
   [io]
   [control
    [monad (#+ do)]
    pipe
    ["ex" exception (#+ exception:)]]
   [data
    ["e" error]
    [text format]]
   [math
    ["r" random ("random/" Monad<Random>)]]
   [macro
    [code]]
   ["." language
    [".L" type ("type/" Equivalence<Type>)]
    ["." compiler
     [init]
     [analysis (#+ Analysis Operation)
      [".A" type]
      [expression]]
     [extension
      [".E" analysis]]]]
   test])

(def: #export analyse (expression.analyser (:coerce language.Eval [])))

(def: unit
  (r.Random Code)
  (random/wrap (' [])))

(def: #export primitive
  (r.Random [Type Code])
  (`` ($_ r.either
          (~~ (do-template [<type> <code-wrapper> <value-gen>]
                [(r.seq (random/wrap <type>) (random/map <code-wrapper> <value-gen>))]

                [Any  code.tuple (r.list +0 ..unit)]
                [Bit code.bit  r.bit]
                [Nat  code.nat   r.nat]
                [Int  code.int   r.int]
                [Rev  code.rev   r.rev]
                [Frac code.frac  r.frac]
                [Text code.text  (r.unicode +5)]
                )))))

(exception: (wrong-inference {expected Type} {inferred Type})
  (ex.report ["Expected" (%type expected)]
             ["Inferred" (%type inferred)]))

(def: (infer-primitive expected-type analysis)
  (-> Type (Operation Analysis) (e.Error Analysis))
  (|> analysis
      typeA.with-inference
      (compiler.run [analysisE.bundle (init.compiler [])])
      (case> (#e.Success [inferred-type output])
             (if (is? expected-type inferred-type)
               (#e.Success output)
               (ex.throw wrong-inference [expected-type inferred-type]))

             (#e.Error error)
             (#e.Error error))))

(context: "Primitives"
  ($_ seq
      (test "Can analyse unit."
            (|> (infer-primitive Any (..analyse (' [])))
                (case> (^ (#e.Success (#analysis.Primitive (#analysis.Unit output))))
                       (is? [] output)

                       _
                       false)))
      (<| (times +100)
          (`` ($_ seq
                  (~~ (do-template [<desc> <type> <tag> <random> <constructor>]
                        [(do @
                           [sample <random>]
                           (test (format "Can analyse " <desc> ".")
                                 (|> (infer-primitive <type> (..analyse (<constructor> sample)))
                                     (case> (#e.Success (#analysis.Primitive (<tag> output)))
                                            (is? sample output)

                                            _
                                            false))))]

                        ["bit" Bit #analysis.Bit r.bit code.bit]
                        ["nat"  Nat  #analysis.Nat  r.nat  code.nat]
                        ["int"  Int  #analysis.Int  r.int  code.int]
                        ["rev"  Rev  #analysis.Rev  r.rev  code.rev]
                        ["frac" Frac #analysis.Frac r.frac code.frac]
                        ["text" Text #analysis.Text (r.unicode +5) code.text]
                        )))))))
