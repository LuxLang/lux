(.module:
  lux
  (lux [io]
       (control ["M" monad #+ do Monad]
                ["&" exception #+ exception:])
       (data ["E" error]
             [text]
             text/format
             [number])
       ["r" math/random])
  lux/test)

(exception: Some-Exception)

(exception: Another-Exception)

(exception: Unknown-Exception)

(context: "Exceptions"
  (<| (times +100)
      (do @
        [should-throw? r.bool
         which? r.bool
         should-catch? r.bool
         default-val r.nat
         some-val r.nat
         another-val r.nat
         otherwise-val r.nat
         #let [this-ex (if should-catch?
                         (if which?
                           Some-Exception
                           Another-Exception)
                         Unknown-Exception)
               expected (if should-throw?
                          (if should-catch?
                            (if which?
                              some-val
                              another-val)
                            otherwise-val)
                          default-val)
               actual (|> (: (E.Error Nat)
                             (if should-throw?
                               (&.throw this-ex [])
                               (&.return default-val)))
                          (&.catch Some-Exception (function (_ ex) some-val))
                          (&.catch Another-Exception (function (_ ex) another-val))
                          (&.otherwise (function (_ ex) otherwise-val)))]]
        (test "Catch and otherwhise handlers can properly handle the flow of exception-handling."
              (n/= expected actual)))))
