(.module:
  lux
  (lux [io #+ IO]
       (control ["M" monad #+ do Monad])
       (data [number]
             [maybe]
             (coll [list "" Functor<List> "List/" Fold<List>])
             text/format)
       (concurrency [atom #+ Atom atom]
                    ["&" stm]
                    [promise]
                    [frp #+ Channel])
       ["r" math/random])
  lux/test)

(def: (read! channel)
  (All [a] (-> (Channel a) (IO (Atom (List a)))))
  (do io.Monad<IO>
    [#let [output (atom (list))]
     _ (frp.listen (function [value]
                     (atom.update (|>> (#.Cons value)) output))
                   channel)]
    (wrap output)))

(def: iterations/processes Int 100)

(context: "STM"
  ($_ seq
      (wrap (do promise.Monad<Promise>
              [output (&.commit (&.read (&.var 0)))]
              (assert "Can read STM vars."
                      (i/= 0 output))))
      (wrap (do promise.Monad<Promise>
              [#let [_var (&.var 0)]
               output (&.commit (do &.Monad<STM>
                                  [_ (&.write 5 _var)]
                                  (&.read _var)))]
              (assert "Can write STM vars."
                      (i/= 5 output))))
      (wrap (do promise.Monad<Promise>
              [#let [_var (&.var 5)]
               output (&.commit (do &.Monad<STM>
                                  [_ (&.update (i/* 3) _var)]
                                  (&.read _var)))]
              (assert "Can update STM vars."
                      (i/= 15 output))))
      (wrap (do promise.Monad<Promise>
              [#let [_var (&.var 0)
                     changes (io.run (read! (io.run (&.follow _var))))]
               _ (&.commit (&.write 5 _var))
               _ (&.commit (&.update (i/* 3) _var))
               changes (promise.future (atom.read changes))]
              (assert "Can follow all the changes to STM vars."
                      (:: (list.Eq<List> number.Eq<Int>) =
                          (list 5 15)
                          (list.reverse changes)))))
      (wrap (let [_concurrency-var (&.var 0)]
              (do promise.Monad<Promise>
                [_ (M.seq @
                          (map (function [_]
                                 (M.map @ (function [_] (&.commit (&.update i/inc _concurrency-var)))
                                        (list.i/range 1 iterations/processes)))
                               (list.i/range 1 (nat-to-int promise.concurrency-level))))
                 last-val (&.commit (&.read _concurrency-var))]
                (assert "Can modify STM vars concurrently from multiple threads."
                        (i/= (i/* iterations/processes (nat-to-int promise.concurrency-level))
                             last-val)))))))
