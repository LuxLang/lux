(.module:
  [lux #*
   [control
    [monad (#+ do)]]
   [data
    ["." lazy (#+ Lazy)]]
   ["." io (#+ IO)]
   [concurrency
    ["." promise]
    ["$" session (#+ Session << >> ?? !! +<< -<< \/ /\ $rec)]]
   [data
    [text
     format]]
   [math
    ["r" random]]]
  lux/test)

(def: $transfer (<| << (!! Int) >>))

(def: transfer
  (Lazy (:~ $transfer))
  (<| $.send $.end))

(context: "Transfer."
  (do @
    [#let [[$me $you] (lazy.thaw ..transfer)]
     expectation r.int]
    ($_ seq
        (wrap (do promise.Monad<Promise>
                [$me ($me expectation)]
                (assert "Client [Transfer]"
                        true)))
        (wrap (do promise.Monad<Promise>
                [[actual $end] ($you [])]
                (assert "Server [Transfer]"
                        (i/= expectation actual))))
        )))

(def: $endless
  (<< ($rec (function (_ $recur)
              (<| (!! Int) $recur)))))

(def: endless
  (Lazy (:~ $endless))
  ($.rec (function (_ recur)
           (<| $.send recur))))

(context: "Endless."
  (do @
    [#let [[$me $you] (lazy.thaw ..endless)]
     expectation0 r.int
     expectation1 r.int
     expectation2 r.int]
    ($_ seq
        (wrap (do promise.Monad<Promise>
                [$me ($me expectation0)
                 $me ($me expectation1)
                 $me ($me expectation2)]
                (assert "Client [Endless]"
                        true)))
        (wrap (do promise.Monad<Promise>
                [[actual0 $you] ($you [])
                 [actual1 $you] ($you [])
                 [actual2 $you] ($you [])]
                (assert "Server [Endless]"
                        (and (i/= expectation0 actual0)
                             (i/= expectation1 actual1)
                             (i/= expectation2 actual2)))))
        )))

(def: $calculation
  Session
  ($rec
   (function (_ $recur)
     ($_ \/
         (<| (!! Int) (!! Int) (?? Int) $recur)
         (<| (!! Int) (?? Int) $recur)
         >>))))

(def: calculation
  (Lazy (:~ (<< $calculation)))
  ($.rec
   (function (_ recur)
     ($_ $.fork
         (<| $.send $.send $.receive recur)
         (<| $.send $.receive recur)
         $.end))))

(def: negate (i/* -1))

(context: "Complex session."
  (do @
    [#let [[$me $you] (lazy.thaw calculation)]
     param r.int
     subject r.int
     #let [expectation (i/+ param subject)]]
    ($_ seq
        (wrap (do promise.Monad<Promise>
                [## Add
                 $me ($me (#.Left id))
                 $me ($me param)
                 $me ($me subject)
                 [output $me] ($me [])
                 ## Negate
                 $me ($me (#.Right id))
                 $me ($me (#.Left id))
                 $me ($me output)
                 [-output $me] ($me [])
                 ## Quit
                 $me ($me (#.Right id))
                 $me ($me (#.Right id))]
                (assert "Client [Add & Negate & Quit]"
                        (and (i/= expectation output)
                             (i/= (..negate expectation) -output)))))
        (wrap (loop [$add|<negate|quit> $you]
                (do promise.Monad<Promise>
                  [add|<negate|quit> ($add|<negate|quit> [])]
                  (case add|<negate|quit>
                    (#.Left $add)
                    (do @
                      [[param-input $add] ($add [])
                       [subject-input $add] ($add [])
                       $recur ($add (i/+ param-input subject-input))]
                      (recur $recur))

                    (#.Right $negate|quit)
                    (do @
                      [negate|quit ($negate|quit [])]
                      (case negate|quit
                        (#.Left $negate)
                        (do @
                          [[subject $negate] ($negate [])
                           $recur ($negate (..negate subject))]
                          (recur $recur))

                        (#.Right $quit)
                        (assert "Server [Quit]"
                                true)))))))
        )))
