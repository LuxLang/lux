(.module:
  lux
  (lux [io]
       (control [monad #+ do]
                pipe)
       (data ["e" error]
             [ident "ident/" Equivalence<Ident>]
             [text "text/" Equivalence<Text>])
       ["r" math/random]
       [macro #+ Monad<Meta>]
       (macro [code])
       [lang]
       (lang [type "type/" Equivalence<Type>]
             [".L" scope]
             [".L" module]
             [".L" reference]
             (compiler [".L" init]
                       [".L" analysis]
                       (analysis [".A" type]
                                 [".A" expression])))
       test)
  (// ["_." primitive]))

(def: analyse (expressionA.analyser (:coerce lang.Eval [])))

(type: Check (-> (e.Error Any) Bool))

(do-template [<name> <on-success> <on-failure>]
  [(def: <name>
     Check
     (|>> (case> (#e.Success _)
                 <on-success>

                 (#e.Error _)
                 <on-failure>)))]

  [success? true false]
  [failure? false true]
  )

(def: (reach-test var-name [export? def-module] [import? dependent-module] check!)
  (-> Text [Bool Text] [Bool Text] Check Bool)
  (|> (do Monad<Meta>
        [_ (moduleL.with-module +0 def-module
             (moduleL.define var-name [Any
                                       (if export?
                                         (' {#.export? true})
                                         (' {}))
                                       []]))]
        (moduleL.with-module +0 dependent-module
          (do @
            [_ (if import?
                 (moduleL.import def-module)
                 (wrap []))]
            (typeA.with-inference
              (..analyse (code.symbol [def-module var-name]))))))
      (macro.run (initL.compiler []))
      check!))

(context: "References"
  (<| (times +100)
      (do @
        [[expectedT _] _primitive.primitive
         def-module (r.unicode +5)
         scope-name (r.unicode +5)
         var-name (r.unicode +5)
         dependent-module (|> (r.unicode +5)
                              (r.filter (|>> (text/= def-module) not)))]
        ($_ seq
            (test "Can analyse variable."
                  (|> (scopeL.with-scope scope-name
                        (scopeL.with-local [var-name expectedT]
                          (typeA.with-inference
                            (..analyse (code.local-symbol var-name)))))
                      (macro.run (initL.compiler []))
                      (case> (^ (#e.Success [inferredT (#analysisL.Reference (referenceL.local var))]))
                             (and (type/= expectedT inferredT)
                                  (n/= +0 var))

                             _
                             false)))
            (test "Can analyse definition (in the same module)."
                  (let [def-name [def-module var-name]]
                    (|> (do Monad<Meta>
                          [_ (moduleL.define var-name [expectedT (' {}) []])]
                          (typeA.with-inference
                            (..analyse (code.symbol def-name))))
                        (moduleL.with-module +0 def-module)
                        (macro.run (initL.compiler []))
                        (case> (^ (#e.Success [_ inferredT (#analysisL.Reference (referenceL.constant constant-name))]))
                               (and (type/= expectedT inferredT)
                                    (ident/= def-name constant-name))

                               _
                               false))))
            (test "Can analyse definition (if exported from imported module)."
                  (reach-test var-name [true def-module] [true dependent-module] success?))
            (test "Cannot analyse definition (if not exported from imported module)."
                  (reach-test var-name [false def-module] [true dependent-module] failure?))
            (test "Cannot analyse definition (if exported from non-imported module)."
                  (reach-test var-name [true def-module] [false dependent-module] failure?))
            ))))
