(.module:
  [lux #*
   [control
    ["M" monad (#+ do Monad)]
    pipe
    ["p" parser]]
   [data
    ["." error]
    ["." number]
    [text ("text/." Equivalence<Text>)
     format]
    [collection
     ["." list]]]
   [math
    ["r" random]]
   ["_" test (#+ Test)]]
  {[-1 ""]
   ["." /]})

(def: #export test
  Test
  (do r.Monad<Random>
    [num-args (|> r.nat (:: @ map (n/% 10)))
     #let [(^open "Nat/.") number.Codec<Text,Nat>
           gen-arg (:: @ map Nat/encode r.nat)]
     yes gen-arg
     #let [gen-ignore (r.filter (|>> (text/= yes) not)
                                (r.unicode 5))]
     no gen-ignore
     pre-ignore (r.list 5 gen-ignore)
     post-ignore (r.list 5 gen-ignore)]
    ($_ _.and
        (_.test "Can read any argument."
                (|> (/.run (list yes) /.any)
                    (case> (#error.Failure _)
                           #0
                           
                           (#error.Success arg)
                           (text/= arg yes))))
        (_.test "Can test tokens."
                (and (|> (/.run (list yes) (/.this yes))
                         (case> (#error.Failure _)
                                #0

                                (#error.Success _)
                                #1))
                     (|> (/.run (list no) (/.this yes))
                         (case> (#error.Failure _)
                                #1

                                (#error.Success _)
                                #0))))
        (_.test "Can use custom token parsers."
                (|> (/.run (list yes) (/.parse Nat/decode))
                    (case> (#error.Failure _)
                           #0
                           
                           (#error.Success parsed)
                           (text/= (Nat/encode parsed)
                                   yes))))
        (_.test "Can query if there are any more inputs."
                (and (|> (/.run (list) /.end)
                         (case> (#error.Success []) #1 _ #0))
                     (|> (/.run (list yes) (p.not /.end))
                         (case> (#error.Success []) #0 _ #1))))
        (_.test "Can parse CLI input anywhere."
                (|> (/.run (list.concat (list pre-ignore (list yes) post-ignore))
                           (|> (/.somewhere (/.this yes))
                               (p.before (p.some /.any))))
                    (case> (#error.Failure _)
                           #0

                           (#error.Success _)
                           #1)))
        )))
