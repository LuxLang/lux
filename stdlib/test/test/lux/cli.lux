(;module:
  lux
  (lux [io]
       (control monad
                pipe)
       (data text/format
             [text "Text/" Eq<Text>]
             [number]
             [product]
             [sum]
             (coll [list]))
       ["&" cli]
       ["R" math/random])
  lux/test)

(context: "CLI"
  [num-args (|> R;nat (:: @ map (n.% +10)))
   #let [(^open "Nat/") number;Codec<Text,Nat>
         gen-arg (:: @ map Nat/encode R;nat)]
   option-name (R;text +5)
   args (R;list num-args gen-arg)]
  ($_ seq
      (test "Can read any argument."
            (|> (&;run &;any args)
                (case> (#;Left _)
                       (n.= +0 num-args)
                       
                       (#;Right arg)
                       (and (not (n.= +0 num-args))
                            (Text/= arg (default (undefined)
                                          (list;head args)))))))

      (test "Can safely fail parsing an argument."
            (|> (&;run (&;opt &;any) args)
                (case> (#;Right (#;Some arg))
                       (and (not (n.= +0 num-args))
                            (Text/= arg (default (undefined)
                                          (list;head args))))

                       (#;Right #;None)
                       (n.= +0 num-args)

                       _
                       false)))
      
      (test "Can read multiple arguments."
            (and (|> (&;run (&;some &;any) args)
                     (case> (#;Left _)
                            false
                            
                            (#;Right args')
                            (n.= num-args (list;size args'))))
                 (|> (&;run (&;many &;any) args)
                     (case> (#;Left _)
                            (n.= +0 num-args)
                            
                            (#;Right args')
                            (n.= num-args (list;size args'))))))

      (test "Can use custom token parsers."
            (|> (&;run (&;parse Nat/decode) args)
                (case> (#;Left _)
                       (n.= +0 num-args)
                       
                       (#;Right parsed)
                       (Text/= (Nat/encode parsed)
                               (default (undefined)
                                 (list;head args))))))

      (test "Can obtain option values."
            (and (|> (&;run (&;option (list option-name)) (list& option-name args))
                     (case> (#;Left _)
                            (n.= +0 num-args)
                            
                            (#;Right value)
                            (Text/= value (default (undefined)
                                            (list;head args)))))
                 (|> (&;run (&;option (list option-name)) args)
                     (case> (#;Left _) true (#;Right _) false))))

      (test "Can check flags."
            (and (|> (&;run (&;flag (list option-name)) (list& option-name args))
                     (case> (#;Right true) true _ false))
                 (|> (&;run (&;flag (list option-name)) args)
                     (case> (#;Right false) true _ false))))

      (test "Can query if there are any more inputs."
            (and (|> (&;run &;end args)
                     (case> (#;Right []) (n.= +0 num-args)
                            _ (n.> +0 num-args)))
                 (|> (&;run (&;not &;end) args)
                     (case> (#;Right []) (n.> +0 num-args)
                            _ (n.= +0 num-args)))))
      ))
