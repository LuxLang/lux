(;module:
  lux
  (lux [io]
       (control [monad #+ do Monad]
                pipe)
       (data [text]
             text/format
             ["R" result]
             [number "Int/" Number<Int>])
       (math ["r" random])
       ["@" time])
  lux/test)

(def: (limited-int size)
  (-> Nat (r;Random Int))
  (do r;Monad<Random>
    [sample r;int]
    (wrap (|> sample
              Int/abs
              (i.% (nat-to-int size))
              (i.* (Int/signum sample))))))

(def: boundary Int 99_999_999_999_999)

(def: time (r;Random @;Time)
  (|> r;int (:: r;Monad<Random> map (i.% boundary))))

(context: "Equality"
  [sample time
   #let [(^open) @;Eq<Time>]]
  (test "Every time equals itself."
        (= sample sample)))

(context: "Arithmetic"
  [subject time
   param time]
  ($_ seq
      (test "Can add and subtract times."
            (and (|> subject (@;t.+ param) (@;t.- param) (@;t.= subject))
                 (|> subject (@;t.- param) (@;t.+ param) (@;t.= subject))))
      (test "Subtracting a time from itself results in the epoch."
            (@;t.= @;epoch
                   (@;t.- subject subject)))
      ))

(context: "Order"
  [reference time
   sample time
   #let [(^open) @;Order<Time>]]
  (test "Can compare times."
        (and (or (< reference sample)
                 (>= reference sample))
             (or (> reference sample)
                 (<= reference sample)))))

(context: "Codec"
  #seed +16366082068080165840
  [sample time
   #let [(^open "&/") @;Codec<Text,Time>]]
  (test "Can encode/decode times."
        (|> sample
            &/encode
            &/decode
            (case> (#R;Success decoded)
                   (@;t.= sample decoded)

                   (#R;Error error)
                   false))))
