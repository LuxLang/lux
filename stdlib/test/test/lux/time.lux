(;module:
  lux
  (lux [io]
       (control [monad #+ do Monad]
                pipe)
       (data [text]
             text/format
             ["R" result]
             [number "Int/" Number<Int>])
       (math ["r" random])
       ["@" time])
  lux/test)

(def: (limited-int size)
  (-> Nat (r;Random Int))
  (do r;Monad<Random>
    [sample r;int]
    (wrap (|> sample
              Int/abs
              (i.% (nat-to-int size))
              (i.* (Int/signum sample))))))

(def: (pow exp base)
  (-> Nat Int Int)
  (case exp
    +0 1
    _ (loop [exp exp
             result base]
        (case exp
          +1 result
          _ (recur (n.dec exp)
                   (i.* base result))))))
(def: boundary Int (|> 2 (pow +31) (i.* @;second)))

(def: time (r;Random @;Time)
  (|> r;int
      (r;filter (i.>= 0))
      ## (:: r;Monad<Random> map (i.% boundary))
      ))

(context: "Equality"
  [sample time
   #let [(^open) @;Eq<Time>]]
  (test "Every time equals itself."
        (= sample sample)))

(context: "Arithmetic"
  [subject time
   param time]
  ($_ seq
      (test "Can add and subtract times."
            (and (|> subject (@;t.+ param) (@;t.- param) (@;t.= subject))
                 (|> subject (@;t.- param) (@;t.+ param) (@;t.= subject))))
      (test "Subtracting a time from itself results in the epoch."
            (@;t.= @;epoch
                   (@;t.- subject subject)))
      ))

(context: "Order"
  [reference time
   sample time
   #let [(^open) @;Order<Time>]]
  (test "Can compare times."
        (and (or (< reference sample)
                 (>= reference sample))
             (or (> reference sample)
                 (<= reference sample))))
  )

(context: "Codec"
  ## #seed +1484609979608
  ## #seed +1484654273059
  [sample time
   ## #let [sample 1095292800_000]
   ## #let [_ (log! (format "sample = " (%i sample)))]
   #let [(^open "&/") @;Codec<Text,Time>]]
  (test "Can encode/decode times."
        (|> sample
            &/encode
            &/decode
            (case> (#R;Success decoded)
                   (@;t.= sample decoded)

                   (#R;Error error)
                   false)))
  )
