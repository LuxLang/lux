(.module:
  [lux #*
   [io]
   [control
    [monad (#+ do Monad)]]
   [data
    [number]
    [text ("text/" Equivalence<Text>)
     format]]
   [math ["r" random]]
   [macro ["&" code]]]
  lux/test)

(context: "Code"
  (with-expansions
    [<tests> (do-template [<expr> <text>]
               [(test (format "Can produce Code node: " <text>)
                      (and (text/= <text> (&.to-text <expr>))
                           (:: &.Equivalence<Code> = <expr> <expr>)))]

               [(&.bit true)                                 "true"]
               [(&.bit false)                                "false"]
               [(&.int 123)                                  "123"]
               [(&.frac 123.0)                               "123.0"]
               [(&.text "\n")                                "\"\\n\""]
               [(&.tag ["yolo" "lol"])                       "#yolo.lol"]
               [(&.symbol ["yolo" "lol"])                    "yolo.lol"]
               [(&.form (list (&.bit true) (&.int 123)))     "(true 123)"]
               [(&.tuple (list (&.bit true) (&.int 123)))    "[true 123]"]
               [(&.record (list [(&.bit true) (&.int 123)])) "{true 123}"]
               [(&.local-tag "lol")                          "#lol"]
               [(&.local-symbol "lol")                       "lol"]
               )]
    ($_ seq <tests>)))
