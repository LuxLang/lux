(;module:
  lux
  (lux [io]
       (control [monad #+ do Monad]
                [eq #+ Eq])
       (data text/format
             [bool]
             [number "i/" Number<Int>]
             [text]
             [maybe]
             (coll [list]))
       ["r" math/random]
       [meta]
       (meta [poly #+ derived:]
             ["&" poly/eq]))
  lux/test)

## [Utils]
(type: Variant
  (#Case0 Bool)
  (#Case1 Int)
  (#Case2 Frac))

(type: #rec Recursive
  (#Number Frac)
  (#Addition Frac Recursive))

(type: Record
  {#unit Unit
   #bool Bool
   #int Int
   #frac Frac
   #text Text
   #maybe (Maybe Int)
   #list (List Int)
   #variant Variant
   #tuple [Int Frac Text]
   #recursive Recursive})

(def: gen-recursive
  (r;Random Recursive)
  (r;rec (function [gen-recursive]
           (r;alt r;frac
                  (r;seq r;frac gen-recursive)))))

(def: gen-record
  (r;Random Record)
  (do r;Monad<Random>
    [size (:: @ map (n.% +2) r;nat)
     #let [gen-int (|> r;int (:: @ map (|>. i/abs (i.% 1_000_000))))]]
    ($_ r;seq
        (:: @ wrap [])
        r;bool
        gen-int
        r;frac
        (r;text size)
        (r;maybe gen-int)
        (r;list size gen-int)
        ($_ r;alt r;bool gen-int r;frac)
        ($_ r;seq gen-int r;frac (r;text size))
        gen-recursive)))

(derived: (&;Eq<?> Record))

## [Tests]
(context: "Eq polytypism"
  [sample gen-record
   #let [(^open "&/") Eq<Record>]]
  (test "Every instance equals itself."
        (&/= sample sample)))
