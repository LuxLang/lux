... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except Module)
   ["[0]" debug]
   [abstract
    [monad (.only Monad do)]]
   [concurrency
    ["[0]" future (.only Future) (.use "[1]#[0]" monad)]]
   [control
    ["[0]" io (.only IO
                     io)]
    ["[0]" maybe]]
   [error
    ["[0]" try (.only Try)]]
   [data
    [binary (.only Binary)]
    ["[0]" product]
    ["[0]" text (.only \n)
     ["%" \\injection]]
    [collection
     ["[0]" dictionary (.only Dictionary)]
     ["[0]" sequence (.use "[1]#[0]" monoid mix)]
     ["[0]" list (.use "[1]#[0]" mix)]
     ["[0]" stack (.use "[1]#[0]" mix)]]
    [format
     ["[0]" tar (.only Tar)]]]
   [type (.only sharing)]
   [macro
    ["[0]" expansion]
    ["[0]" template]]
   ["[0]" compiler
    [default
     ["[0]" platform (.only Platform)]]
    [language
     ["$" lux (.only)
      ["[1]/[0]" program (.only Program)]
      ["[0]" syntax]
      ["[0]" translation]
      ["[0]" declaration]
      ["[0]" analysis (.only)
       [macro (.only Expander)]]
      ["[0]" phase (.only)
       [extension (.only Extender)
        ["[0]E" analysis]
        ["[0]E" synthesis]]]]]
    [meta
     [packager (.only Packager)]
     ["[0]" context (.only Context)]
     ["[0]" cli (.only Service)]
     ["[0]" import]
     ["[0]" export]
     ["[0]" cache (.only)
      ["[1]/[0]" archive]]
     [archive (.only Archive)
      ["[0]" unit]
      [module
       [descriptor (.only Module)]]]
     [io
      ["ioW" archive]]]]
   [time
    ["[0]" instant]
    ["[0]" duration]]
   ["[0]" world
    ["[0]" console]
    ["[1]/[0]" environment]
    ["[0]" file (.only)
     ["[1]/[0]" extension]]]]])

(the (or_crash! failure_description action)
  (for_any (_ it)
    (-> Text (Future (Try it))
        (Future it)))
  (do [! future.monad]
    [?output action]
    (when ?output
      {try.#Failure error}
      (let [report (text \n failure_description
                         \n error
                         \n)]
        (do !
          [_ (expansion.let [<else> (in {try.#Success (debug.log! report)})]
               (for .js (is (Future (Try Any))
                            (when console.default
                              {.#None}
                              <else>

                              {.#Some console}
                              (console.write_line report console)))
                    (is (Future (Try Any))
                        <else>)))]
          (io.value (by world/environment.default exit +1))))

      {try.#Success output}
      (in output))))

(the (timed process)
  (for_any (_ it)
    (-> (Future (Try it))
        (Future (Try it))))
  (do future.monad
    [.let [start (io.value instant.now)]
     output process
     .let [_ (debug.log! (|> (io.value instant.now)
                             (instant.span start)
                             duration.as_text
                             (text "Duration: ")))]]
    (in output)))

(the (package! file_context fs host_dependencies [packager package] archive context)
  (-> Context (file.System Future) (Dictionary file.Path Binary) [Packager file.Path] Archive (Maybe unit.ID)
      (Future (Try Any)))
  (let [target_root (its context.#target file_context)
        package (file.rooted fs target_root package)]
    (when (packager host_dependencies archive context)
      {try.#Success content}
      (when content
        {.#Left content}
        (by fs write package content)
        
        {.#Right content}
        (do [! (try.with future.monad)]
          [_ (by fs make_directory package)
           _ (stack.each' ! (function (_ [name content])
                              (by fs write (file.rooted fs package name) content))
                          content)]
          (in [])))
      
      {try.#Failure error}
      (by future.monad in {try.#Failure error}))))

(the (load_host_dependencies fs host_dependencies)
  (-> (file.System Future) (Stack file.Path)
      (Future (Try (Dictionary file.Path Binary))))
  (do [! (try.with future.monad)]
    []
    (loop (again [pending host_dependencies
                  output (is (Dictionary file.Path Binary)
                             (dictionary.empty text.hash))])
      (when pending
        {.#Empty}
        (in output)

        {.#Top head tail}
        (do !
          [content (by fs read head)]
          (again tail
                 (dictionary.has head content output)))))))

(the (hybrid_fs cache host)
  (-> (file.System Future) (file.System Future)
      (file.System Future))
  (`` (implementation
       (the delimiter
         (by host delimiter))
       (,, (template.with [<name>]
             [(the (<name> path)
                (do future.monad
                  [?/0 (by cache <name> path)
                   ?/1 (by host <name> path)]
                  (in (or ?/0 ?/1))))]

             [file?]
             [directory?]
             ))
       (,, (template.with [<name>]
             [(the <name>
                (by cache <name>))]

             [make_directory]
             [directory_files]
             [sub_directories]
             
             [file_size]
             [last_modified]
             [can_execute?]
             [delete]
             ))
       (the (read path)
         (do future.monad
           [it (by cache read path)]
           (when it
             {try.#Failure _}
             (by host read path)
             
             _
             (in it))))
       (,, (template.with [<name>]
             [(the <name>
                (by cache <name>))]
             
             [modify]
             [write]
             [append]
             [move]
             ))
       )))

(the cache_mode
  tar.Mode
  (all tar.and
       tar.execute_by_other
       tar.write_by_other
       tar.read_by_other

       tar.execute_by_group
       tar.write_by_group
       tar.read_by_group

       tar.execute_by_owner
       tar.write_by_owner
       tar.read_by_owner

       tar.save_text
       tar.set_group_id_on_execution
       tar.set_user_id_on_execution
       ))

(every (Action it)
  (Future (Try it)))

(the monad
  (is (Monad Action)
      (as_expected (try.with future.monad))))

(the (cache_tar_entry fs path)
  (-> (file.System Future) file.Path
      (Action tar.Entry))
  (do future.monad
    [content (by fs read path)]
    (in (do try.monad
          [content content
           path (tar.path path)
           content (tar.content content)]
          (in {tar.#Normal [path instant.epoch ..cache_mode tar.no_ownership content]})))))

(the (cache_tar context fs)
  (-> Context (file.System Future)
      (Action Tar))
  (loop (again [root cache.path])
    (do [! ..monad]
      [files (by fs directory_files root)
       subs (by fs sub_directories root)
       files (list.each' ! (cache_tar_entry fs) files)
       subs (list.each' ! again subs)]
      (in (list#mix sequence#composite
                    (sequence.of_list files)
                    subs)))))

(the (cache_path fs context)
  (-> (file.System Future) Context
      file.Path)
  (text (its context.#target context)
        (by fs delimiter)
        (its context.#host context)
        file/extension.tape_archive))

(the (cached_file_path fs full_path)
  (-> (file.System Future) file.Path
      [file.Path file.Path])
  (<| maybe.trusted
      (do maybe.monad
        [.let [/ (by fs delimiter)]
         @ (text.last_index / full_path)
         [directory file] (text.split_at @ full_path)]
        (in [directory (text.replaced_once / "" file)]))))

(expansion.let [<parameters> (these anchor expression artifact)]
  (these (the (load_cache! host_fs cache_fs context)
           (-> (file.System Future) (file.System Future) Context
               (Future (Try Any)))
           (do [! future.monad]
             [tar (by host_fs read (cache_path host_fs context))]
             (when tar
               {try.#Failure _}
               (in {try.#Success []})

               {try.#Success tar}
               (do [! (try.with !)]
                 [tar (future#in (by tar.binary of tar))
                  _ (sequence#mix (function (_ entry then)
                                    (when entry
                                      {tar.#Normal [path instant mode ownership content]}
                                      (do !
                                        [_ then
                                         .let [path (tar.from_path path)
                                               directory (maybe.else path (file.parent cache_fs path))]
                                         _ (is (Future (Try Any))
                                               (file.make_directories future.monad cache_fs directory))]
                                        (by cache_fs write path (tar.data content)))

                                      _
                                      then))
                                  (in [])
                                  tar)]
                 (in [])))))

         (the (cache! original_fs context platform)
           (for_any (_ <parameters>)
             (-> (file.System Future) Context (Platform <parameters>)
                 (Future (Try Any))))
           (do (try.with future.monad)
             [cache (cache_tar context (its platform.#file_system platform))]
             (by original_fs write
                 (cache_path original_fs context)
                 (by tar.binary as cache))))

         (the (with_caching it)
           (for_any (_ <parameters>)
             (-> (Platform <parameters>)
                 [(file.System Future) (Platform <parameters>)]))
           (let [cache_fs (file.memory (by (its platform.#file_system it) delimiter))
                 it (revised platform.#file_system (hybrid_fs cache_fs) it)]
             [cache_fs it]))

         (the (enable_output! original_fs context)
           (-> (file.System Future) Context
               (Future (Try Any)))
           (let [target_root (its context.#target context)]
             (do [! future.monad]
               [? (by original_fs directory? target_root)]
               (if ?
                 (in {try.#Success []})
                 (file.make_directories ! original_fs target_root)))))
         
         (the .public (compiler lux_compiler file_context
                                expander host_analysis platform translation_bundle host_declaration_bundle program global extender
                                service
                                packager,package)
           (for_any (_ <parameters>)
             (-> (-> Any platform.Custom)
                 Context
                 Expander
                 analysis.Bundle
                 (IO (Platform <parameters>))
                 (translation.Bundle <parameters>)
                 (declaration.Bundle <parameters>)
                 (Program expression artifact) (-> Archive Name (translation.Operation <parameters> expression))
                 Extender
                 Service
                 [Packager file.Path]
                 (Future Any)))
           (do [! future.monad]
             [platform (future.soon platform)]
             (when service
               {cli.#Compilation compilation}
               (<| (or_crash! "Compilation failed:")
                   ..timed
                   (do [! (try.with !)]
                     [.let [original_fs (its platform.#file_system platform)
                            [cache_fs platform] (with_caching platform)]
                      _ (enable_output! original_fs file_context)
                      _ (load_cache! original_fs cache_fs file_context)
                      import (import.import (its platform.#file_system platform) (its cli.#libraries compilation))
                      .let [all_extensions [(analysisE.bundle host_analysis)
                                            synthesisE.bundle
                                            translation_bundle
                                            host_declaration_bundle]]
                      [state archive phase_wrapper] (sharing [<parameters>]
                                                      (is (Platform <parameters>)
                                                          platform)
                                                      (is (Future (Try [(declaration.State <parameters>)
                                                                        Archive
                                                                        phase.Wrapper]))
                                                          (as_expected (platform.initialize file_context
                                                                                            (its cli.#module compilation)
                                                                                            expander
                                                                                            platform
                                                                                            program
                                                                                            extender
                                                                                            import
                                                                                            (its cli.#sources compilation)
                                                                                            (its cli.#configuration compilation)
                                                                                            all_extensions))))
                      archive,state (do future.monad
                                      [archive,state (sharing [<parameters>]
                                                       (is (Platform <parameters>)
                                                           platform)
                                                       (is (Future (Try [Archive (declaration.State <parameters>)]))
                                                           (as_expected (platform.compile program
                                                                                          global
                                                                                          lux_compiler
                                                                                          phase_wrapper
                                                                                          import
                                                                                          file_context
                                                                                          extender
                                                                                          expander
                                                                                          platform
                                                                                          compilation
                                                                                          [archive state]
                                                                                          all_extensions))))]
                                      (in {try.#Success archive,state}))]
                     (when archive,state
                       {try.#Success [archive state]}
                       (do !
                         [_ (cache/archive.cache! (its platform.#file_system platform) (its cli.#configuration compilation) archive)
                          _ (cache! original_fs file_context platform)
                          host_dependencies (..load_host_dependencies (its platform.#file_system platform)
                                                                      (its cli.#host_dependencies compilation))

                          _ (..package! file_context
                                        original_fs
                                        host_dependencies
                                        packager,package
                                        archive
                                        (try.maybe ($/program.context archive)))]
                         (in (debug.log! "Compilation complete!")))

                       {try.#Failure error}
                       (do !
                         [_ (cache! original_fs file_context platform)]
                         (future#in {try.#Failure error})))))

               {cli.#Export export}
               (<| (or_crash! "Export failed:")
                   (do (try.with !)
                     [_ (export.export (its platform.#file_system platform)
                          export)]
                     (in (debug.log! "Export complete!"))))
               
               {cli.#Interpretation interpretation}
               ... TODO: Fix the interpreter...
               (undefined)
               ... (<| (or_crash! "Interpretation failed:")
               ...     (do !
               ...       [console (|> console.default
               ...                    future.soon
               ...                    (by ! each (|>> try.trusted console.future)))]
               ...       (interpreter.value (try.with future.monad) console platform interpretation translation_bundle)))
               )))
         ))
