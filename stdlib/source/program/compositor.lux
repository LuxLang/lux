(.module:
  [lux (#- Module)
   [type (#+ :share)]
   ["@" target (#+ Host)]
   [abstract
    [monad (#+ Monad do)]]
   [control
    ["." io (#+ IO io)]
    ["." try (#+ Try)]
    [parser
     [cli (#+ program:)]]
    [security
     ["!" capability]]
    [concurrency
     ["." promise (#+ Promise) ("#@." monad)]]]
   [data
    [binary (#+ Binary)]
    ["." product]
    ["." text
     ["%" format (#+ format)]]
    [collection
     ["." dictionary]
     ["." row (#+ Row)]
     ["." list ("#@." functor fold)]]]
   [time
    ["." instant (#+ Instant)]]
   [world
    ["." file (#+ File Path)]
    ["." console]]
   [tool
    [compiler
     ["." phase]
     [default
      ["." platform (#+ Platform)]]
     [language
      ["$" lux
       ["#/." program (#+ Program)]
       ["." syntax]
       ["." analysis
        [macro (#+ Expander)]]
       ["." generation (#+ Buffer Context)]
       ["." directive]
       [phase
        [extension (#+ Extender)]]]]
     [meta
      [packager (#+ Packager)]
      [archive (#+ Archive)
       [descriptor (#+ Module)]]
      [cache
       ["." dependency]]
      [io
       ["ioW" archive]]]]
    ## ["." interpreter]
    ]]
  ["." / #_
   ["#." cli (#+ Service)]
   ["#." static (#+ Static)]
   ["#." export]
   ["#." import]])

(def: (or-crash! failure-description action)
  (All [a]
    (-> Text (Promise (Try a)) (Promise a)))
  (do promise.monad
    [?output action]
    (case ?output
      (#try.Failure error)
      (exec (log! (format text.new-line
                          failure-description text.new-line
                          error text.new-line))
        (io.run (io.exit +1)))

      (#try.Success output)
      (wrap output))))

(def: (package! monad file-system [packager package] static archive context)
  (All [!] (-> (Monad !) (file.System !) [Packager Path] Static Archive Context (! (Try Any))))
  (do (try.with monad)
    [#let [packager (:share [!] {(Monad !) monad} {(Packager !) packager})]
     content (packager monad file-system static archive context)
     package (:share [!]
                     {(Monad !)
                      monad}
                     {(! (Try (File !)))
                      (:assume (file.get-file monad file-system package))})]
    (!.use (:: (:share [!]
                       {(Monad !)
                        monad}
                       {(File !)
                        (:assume package)})
               over-write)
           [content])))

(with-expansions [<parameters> (as-is anchor expression artifact)]
  (def: #export (compiler static
                          expander host-analysis platform generation-bundle host-directive-bundle program extender
                          service
                          packager,package)
    (All [<parameters>]
      (-> Static
          Expander
          analysis.Bundle
          (IO (Platform <parameters>))
          (generation.Bundle <parameters>)
          (directive.Bundle <parameters>)
          (Program expression artifact)
          Extender
          Service
          [Packager Path]
          (Promise Any)))
    (do {@ promise.monad}
      [platform (promise.future platform)
       console (|> console.system
                   promise.future
                   (:: @ map (|>> try.assume console.async)))]
      (case service
        (#/cli.Compilation compilation)
        (<| (or-crash! "Compilation failed:")
            (do (try.with promise.monad)
              [#let [[compilation-sources compilation-libraries compilation-target compilation-module] compilation]
               import (/import.import (get@ #platform.&file-system platform) compilation-libraries)
               [state archive] (:share [<parameters>]
                                       {(Platform <parameters>)
                                        platform}
                                       {(Promise (Try [(directive.State+ <parameters>)
                                                       Archive]))
                                        (:assume (platform.initialize static compilation-module expander host-analysis platform generation-bundle host-directive-bundle program extender
                                                                      import compilation-sources))})
               [archive state] (:share [<parameters>]
                                       {(Platform <parameters>)
                                        platform}
                                       {(Promise (Try [Archive (directive.State+ <parameters>)]))
                                        (:assume (platform.compile import static expander platform compilation [archive state]))})
               _ (ioW.freeze (get@ #platform.&file-system platform) static archive)
               program-context (promise@wrap ($/program.context archive))
               _ (promise.future (..package! io.monad file.system packager,package static archive program-context))]
              (wrap (log! "Compilation complete!"))))

        (#/cli.Export export)
        (<| (or-crash! "Export failed:")
            (do (try.with promise.monad)
              [_ (/export.export (get@ #platform.&file-system platform)
                                 (get@ #/static.host-module-extension static)
                                 export)]
              (wrap (log! "Export complete!"))))
        
        (#/cli.Interpretation interpretation)
        ## TODO: Fix the interpreter...
        (undefined)
        ## (<| (or-crash! "Interpretation failed:")
        ##     (interpreter.run (try.with promise.monad) console platform interpretation generation-bundle))
        ))))
