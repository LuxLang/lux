(.module:
  [library
   [lux (#- Module)
    [type (#+ :sharing)]
    ["@" target]
    ["." debug]
    [abstract
     [monad (#+ do)]]
    [control
     ["." io (#+ IO io)]
     ["." try (#+ Try)]
     [concurrency
      ["." async (#+ Async) ("#\." monad)]]]
    [data
     [binary (#+ Binary)]
     ["." product]
     ["." text
      ["%" format (#+ format)]]
     [collection
      ["." dictionary (#+ Dictionary)]
      ["." row (#+ Row)]]]
    [time
     ["." instant]]
    ["." world #_
     ["." file]
     ["#/." program]
     ## ["." console]
     ]
    [tool
     [compiler
      ["." phase]
      [default
       ["." platform (#+ Platform)]]
      [language
       ["$" lux
        ["#/." program (#+ Program)]
        ["." syntax]
        ["." analysis
         [macro (#+ Expander)]]
        ["." generation (#+ Buffer Context)]
        ["." directive]
        [phase
         [extension (#+ Extender)]]]]
      [meta
       [packager (#+ Packager)]
       [archive (#+ Archive)
        [descriptor (#+ Module)]]
       [cache
        ["." dependency]]
       [io
        ["ioW" archive]]]]
     ## ["." interpreter]
     ]]]
  ["." / #_
   ["#." cli (#+ Service)]
   ["#." static (#+ Static)]
   ["#." export]
   ["#." import]])

(def: (or_crash! failure_description action)
  (All [a]
    (-> Text (Async (Try a)) (Async a)))
  (do async.monad
    [?output action]
    (case ?output
      (#try.Failure error)
      (exec (debug.log! (format text.new_line
                                failure_description text.new_line
                                error text.new_line))
        (io.run (\ world/program.default exit +1)))

      (#try.Success output)
      (in output))))

(def: (timed process)
  (All [a]
    (-> (Async (Try a)) (Async (Try a))))
  (do async.monad
    [.let [start (io.run instant.now)]
     output process
     .let [_ ("lux io log" (|> (io.run instant.now)
                               (instant.span start)
                               %.duration
                               (format "Duration: ")))]]
    (in output)))

(def: (package! fs host_dependencies [packager package] static archive context)
  (-> (file.System Async) (Dictionary file.Path Binary) [Packager file.Path] Static Archive Context (Async (Try Any)))
  (case (packager host_dependencies archive context)
    (#try.Success content)
    (\ fs write content package)
    
    (#try.Failure error)
    (\ async.monad in (#try.Failure error))))

(def: (load_host_dependencies fs host_dependencies)
  (-> (file.System Async) (List file.Path) (Async (Try (Dictionary file.Path Binary))))
  (do {! (try.with async.monad)}
    []
    (loop [pending host_dependencies
           output (: (Dictionary file.Path Binary)
                     (dictionary.empty text.hash))]
      (case pending
        #.End
        (in output)

        (#.Item head tail)
        (do !
          [content (\ fs read head)]
          (recur tail
                 (dictionary.put head content output)))))))

(with_expansions [<parameters> (as_is anchor expression artifact)]
  (def: .public (compiler static
                          expander host_analysis platform generation_bundle host_directive_bundle program anchorT,expressionT,directiveT extender
                          service
                          packager,package)
    (All [<parameters>]
      (-> Static
          Expander
          analysis.Bundle
          (IO (Platform <parameters>))
          (generation.Bundle <parameters>)
          (-> platform.Phase_Wrapper (directive.Bundle <parameters>))
          (Program expression artifact)
          [Type Type Type]
          (-> platform.Phase_Wrapper Extender)
          Service
          [Packager file.Path]
          (Async Any)))
    (do {! async.monad}
      [platform (async.future platform)]
      (case service
        (#/cli.Compilation compilation)
        (<| (or_crash! "Compilation failed:")
            ..timed
            (do (try.with async.monad)
              [.let [[compilation_sources compilation_host_dependencies compilation_libraries compilation_target compilation_module] compilation]
               import (/import.import (get@ #platform.&file_system platform) compilation_libraries)
               [state archive] (:sharing [<parameters>]
                                         (Platform <parameters>)
                                         platform
                                         
                                         (Async (Try [(directive.State+ <parameters>)
                                                      Archive]))
                                         (:assume (platform.initialize static compilation_module expander host_analysis platform generation_bundle host_directive_bundle program anchorT,expressionT,directiveT extender
                                                                       import compilation_sources)))
               [archive state] (:sharing [<parameters>]
                                         (Platform <parameters>)
                                         platform
                                         
                                         (Async (Try [Archive (directive.State+ <parameters>)]))
                                         (:assume (platform.compile import static expander platform compilation [archive state])))
               _ (ioW.freeze (get@ #platform.&file_system platform) static archive)
               program_context (async\in ($/program.context archive))
               host_dependencies (..load_host_dependencies (get@ #platform.&file_system platform) compilation_host_dependencies)
               _ (..package! (for {@.old (file.async file.default)
                                   @.jvm (file.async file.default)
                                   @.js file.default})
                             host_dependencies
                             packager,package
                             static
                             archive
                             program_context)]
              (in (debug.log! "Compilation complete!"))))

        (#/cli.Export export)
        (<| (or_crash! "Export failed:")
            (do (try.with async.monad)
              [_ (/export.export (get@ #platform.&file_system platform)
                                 export)]
              (in (debug.log! "Export complete!"))))
        
        (#/cli.Interpretation interpretation)
        ## TODO: Fix the interpreter...
        (undefined)
        ## (<| (or_crash! "Interpretation failed:")
        ##     (do {! async.monad}
        ##       [console (|> console.default
        ##                    async.future
        ##                    (\ ! map (|>> try.assumed console.async)))]
        ##       (interpreter.run (try.with async.monad) console platform interpretation generation_bundle)))
        ))))
