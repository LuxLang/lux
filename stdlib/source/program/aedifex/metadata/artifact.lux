(.using
  [library
   [lux "*"
    [abstract
     [monad {"+" do}]
     [equivalence {"+" Equivalence}]]
    [control
     [pipe {"+" do>}]
     ["[0]" try {"+" Try}]
     ["<>" parser
      ["<[0]>" xml {"+" Parser}]
      ["<[0]>" text]]
     [concurrency
      ["[0]" async {"+" Async}]]]
    [data
     ["[0]" product]
     ["[0]" text
      ["%" format]
      [encoding
       ["[0]" utf8]]]
     [format
      ["[0]" xml {"+" XML}]]
     [collection
      ["[0]" list ("[1]#[0]" functor)]]]
    [math
     [number
      ["n" nat]]]
    ["[0]" time {"+" Time}
     ["[0]" instant {"+" Instant}]
     ["[0]" date {"+" Date}]
     ["[0]" year]
     ["[0]" month]]
    [world
     [net
      ["[0]" uri {"+" URI}]]]]]
  ["[0]" //
   ["/[1]" // "_"
    [repository {"+" Repository}]
    ["[1][0]" artifact {"+" Group Name Version Artifact}]]])

(type: .public Metadata
  (Record
   [#group Group
    #name Name
    #versions (List Version)
    #last_updated Instant]))

(def: (pad value)
  (-> Nat Text)
  (if (n.< 10 value)
    (%.format "0" (%.nat value))
    (%.nat value)))

(def: (date_format value)
  (%.Format Date)
  (%.format (|> value date.year year.value .nat %.nat)
            (|> value date.month month.number ..pad)
            (|> value date.day_of_month ..pad)))

(def: (time_format value)
  (%.Format Time)
  (let [(^open "[0]") (time.clock value)]
    (%.format (..pad #hour)
              (..pad #minute)
              (..pad #second))))

(def: (instant_format value)
  (%.Format Instant)
  (%.format (..date_format (instant.date value))
            (..time_format (instant.time value))))

(template [<definition> <tag>]
  [(def: <definition> xml.Tag ["" <tag>])]

  [<group> "groupId"]
  [<name> "artifactId"]
  [<version> "version"]
  [<versioning> "versioning"]
  [<versions> "versions"]
  [<last_updated> "lastUpdated"]
  [<metadata> "metadata"]
  )

(template [<name> <type> <tag> <pre>]
  [(def: <name>
     (-> <type> XML)
     (|>> <pre> {xml.#Text} list {xml.#Node <tag> xml.attributes}))]

  [group_format Group ..<group> (|>)]
  [name_format Name ..<name> (|>)]
  [version_format Version ..<version> (|>)]
  [last_updated_format Instant ..<last_updated> ..instant_format]
  )

(def: versions_format
  (-> (List Version) XML)
  (|>> (list#each ..version_format) {xml.#Node ..<versions> xml.attributes}))

(def: .public (format value)
  (-> Metadata XML)
  {xml.#Node ..<metadata>
             xml.attributes
             (list (..group_format (value@ #group value))
                   (..name_format (value@ #name value))
                   {xml.#Node ..<versioning>
                              xml.attributes
                              (list (..versions_format (value@ #versions value))
                                    (..last_updated_format (value@ #last_updated value)))})})

(def: (text tag)
  (-> xml.Tag (Parser Text))
  (<| (<xml>.node tag)
      <xml>.text))

(def: date_parser
  (<text>.Parser Date)
  (do <>.monad
    [year (<>.codec n.decimal (<text>.exactly 4 <text>.decimal))
     year (<>.lifted (year.year (.int year)))
     month (<>.codec n.decimal (<text>.exactly 2 <text>.decimal))
     month (<>.lifted (month.by_number month))
     day_of_month (<>.codec n.decimal (<text>.exactly 2 <text>.decimal))]
    (<>.lifted (date.date year month day_of_month))))

(def: time_parser
  (<text>.Parser Time)
  (do <>.monad
    [hour (<>.codec n.decimal (<text>.exactly 2 <text>.decimal))
     minute (<>.codec n.decimal (<text>.exactly 2 <text>.decimal))
     second (<>.codec n.decimal (<text>.exactly 2 <text>.decimal))]
    (<>.lifted (time.time
                [time.#hour hour
                 time.#minute minute
                 time.#second second
                 time.#milli_second 0]))))

(def: last_updated_parser
  (Parser Instant)
  (<text>.then (do <>.monad
                 [date ..date_parser
                  time ..time_parser]
                 (in (instant.of_date_time date time)))
               (..text ..<last_updated>)))

(def: .public parser
  (Parser Metadata)
  (<| (<xml>.node ..<metadata>)
      ($_ <>.and
          (<xml>.somewhere (..text ..<group>))
          (<xml>.somewhere (..text ..<name>))
          (<| (<xml>.node ..<versioning>)
              ($_ <>.and
                  (<| <xml>.somewhere
                      (<xml>.node ..<versions>)
                      (<>.many (..text ..<version>)))
                  (<xml>.somewhere ..last_updated_parser)
                  )))))

(def: .public equivalence
  (Equivalence Metadata)
  ($_ product.equivalence
      text.equivalence
      text.equivalence
      (list.equivalence text.equivalence)
      instant.equivalence
      ))

(def: .public uri
  (-> Artifact URI)
  //.remote_project_uri)

(def: epoch
  Instant
  (instant.of_millis +0))

(def: .public (read repository artifact)
  (-> (Repository Async) Artifact (Async (Try Metadata)))
  (do async.monad
    [project (# repository download (..uri artifact))]
    (case project
      {try.#Success project}
      (in (|> project
              (do> try.monad
                   [(# utf8.codec decoded)]
                   [(# xml.codec decoded)]
                   [list (<xml>.result ..parser)])))
      
      {try.#Failure error}
      (in {try.#Success
           (let [(^open "[0]") artifact]
             [..#group #group
              ..#name #name
              ..#versions (list)
              ..#last_updated ..epoch])}))))

(def: .public (write repository artifact metadata)
  (-> (Repository Async) Artifact Metadata (Async (Try Any)))
  (|> metadata
      ..format
      (# xml.codec encoded)
      (# utf8.codec encoded)
      (# repository upload (..uri artifact))))
