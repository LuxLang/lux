(.module:
  [library
   [lux "*"
    ["[0]" time]
    [abstract
     [equivalence {"+" [Equivalence]}]
     [monad {"+" [do]}]]
    [control
     ["[0]" try {"+" [Try]}]
     ["<>" parser
      ["<[0]>" text {"+" [Parser]}]]]
    [data
     ["[0]" product]
     [text
      ["%" format {"+" [Format]}]]]
    [time
     ["[0]" instant {"+" [Instant]}]]]]
  ["[0]" / "_"
   ["[1][0]" date]
   ["[1][0]" time]])

(type: .public Time
  [/date.Date /time.Time])

(def: .public epoch
  Time
  [/date.epoch time.midnight])

(def: .public (instant time)
  (-> Time Instant)
  (let [[date time] time]
    (instant.of_date_time (/date.value date)
                          time)))

(def: .public (of_instant instant)
  (-> Instant (Try Time))
  (do try.monad
    [date (/date.date (instant.date instant))]
    (in [date
         (instant.time instant)])))

(def: .public equivalence
  (Equivalence Time)
  (product.equivalence /date.equivalence
                       time.equivalence))

(def: .public (format [date time])
  (Format Time)
  (%.format (/date.format date)
            (/time.format time)))

(def: .public parser
  (Parser Time)
  (do <>.monad
    [date /date.parser
     time /time.parser]
    (in [date time])))
