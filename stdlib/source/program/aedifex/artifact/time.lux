(.require
 [library
  [lux (.except)
   [abstract
    [equivalence (.only Equivalence)]
    [monad (.only do)]]
   [control
    ["<>" parser (.only)]
    ["[0]" try (.only Try)]]
   [data
    ["[0]" product]
    ["[0]" text
     ["%" \\format (.only Format)]
     ["<[1]>" \\parser (.only Parser)]]]
   [world
    ["[0]" time (.only)
     ["[0]" instant (.only Instant)]]]]]
 ["[0]" /
  ["[1][0]" date]
  ["[1][0]" time]])

(type .public Time
  [/date.Date /time.Time])

(def .public epoch
  Time
  [/date.epoch time.midnight])

(def .public (instant time)
  (-> Time Instant)
  (let [[date time] time]
    (instant.of_date_time (/date.value date)
                          time)))

(def .public (of_instant instant)
  (-> Instant (Try Time))
  (do try.monad
    [date (/date.date (instant.date instant))]
    (in [date
         (instant.time instant)])))

(def .public equivalence
  (Equivalence Time)
  (product.equivalence /date.equivalence
                       time.equivalence))

(def .public (format [date time])
  (Format Time)
  (%.format (/date.format date)
            (/time.format time)))

(def .public parser
  (Parser Time)
  (do <>.monad
    [date /date.parser
     time /time.parser]
    (in [date time])))
