(.using
 [library
  [lux "*"
   [abstract
    ["[0]" monad {"+" Monad do}]
    ["[0]" mix]]
   [control
    ["[0]" pipe]
    ["[0]" try {"+" Try}]
    [parser
     ["<[0]>" code]]]
   [data
    [binary {"+" Binary}]
    ["[0]" text
     [encoding
      ["[0]" utf8]]]
    [collection
     ["[0]" list]]]
   [meta
    ["[0]" location]]
   [tool
    [compiler
     [language
      [lux
       ["[0]" syntax]]]]]
   [world
    ["[0]" file]]]]
 ["[0]" // "_"
  ["[1][0]" profile {"+" Name Profile}]
  ["[1][0]" project {"+" Project}]
  ["[1][0]" parser]])

(def: (lux_parser source_code)
  (-> Text (Try Code))
  (let [parse (syntax.parse ""
                            syntax.no_aliases
                            (text.size source_code))]
    (case (parse [location.dummy 0 source_code])
      {.#Left [_ error]}
      {try.#Failure error}
      
      {.#Right [_ lux_code]}
      {try.#Success lux_code})))

(def: project_parser
  (-> Binary (Try Project))
  (|>> (pipe.do try.monad
         [(# utf8.codec decoded)]
         [..lux_parser]
         [(list) (<code>.result //parser.project)])))

(def: .public (read monad fs profiles)
  (All (_ !) (-> (Monad !) (file.System !) (List Name) (! (Try Profile))))
  (|> //project.file
      (# fs read)
      (# monad each
         (function (_ it)
           (do [! try.monad]
             [it it
              it (..project_parser it)
              it (monad.each ! (//project.profile it) (list& //profile.default profiles))]
             (in (mix.with_monoid //profile.monoid list.mix it)))))))
