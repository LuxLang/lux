(.module:
  [library
   [lux (#- Type type)
    ["_" test (#+ Test)]
    [abstract
     ["." monad (#+ do)]]
    [control
     ["." try]
     [concurrency
      ["." async (#+ Async)]]
     [parser
      ["." environment]]]
    [data
     [binary (#+ Binary)]
     ["." text]
     [format
      [xml (#+ XML)]]
     [collection
      ["." set]
      ["." dictionary]]]
    [math
     ["." random (#+ Random) ("#\." monad)]
     [number
      ["n" nat]]]
    [world
     ["." file]
     ["." program]]]]
  [//
   ["@." profile]
   ["@." artifact]
   [//
    [lux
     [data
      ["_." binary]]]]]
  [\\program
   ["." /
    ["/#" // #_
     ["#" profile (#+ Profile)]
     ["#." package (#+ Package)]
     ["#." pom]
     ["#." dependency (#+ Dependency)
      ["#/." resolution (#+ Resolution)]]
     ["#." artifact (#+ Artifact)
      ["#/." type (#+ Type)]]
     ["#." repository #_
      ["#/." origin]]]]])

(def: type
  (Random Type)
  ($_ random.either
      (random\in //artifact/type.lux_library)
      (random\in //artifact/type.jvm_library)))

(def: profile
  (Random [Artifact Profile XML])
  (random.one (function (_ profile)
                (try.maybe
                 (do try.monad
                   [pom (//pom.write profile)
                    identity (try.of_maybe (value@ #//.identity profile))]
                   (in [identity profile pom]))))
              @profile.random))

(def: content
  (Random Binary)
  (do {! random.monad}
    [content_size (\ ! each (n.% 100) random.nat)]
    (_binary.random content_size)))

(def: package
  (Random [Dependency Package])
  (do {! random.monad}
    [[identity profile pom] ..profile
     type ..type
     content ..content]
    (in [[#//dependency.artifact identity
          #//dependency.type type]
         (with@ #//package.origin (#//repository/origin.Remote "") (//package.local pom content))])))

(def: resolution
  (Random Resolution)
  (do {! random.monad}
    [[main_dependency main_package] ..package
     dependencies (|> (//package.dependencies main_package)
                      (\ try.monad each set.list)
                      (try.else (list))
                      (monad.each ! (function (_ dependency)
                                      (do !
                                        [pom (random.one (function (_ [identity profile pom])
                                                           (|> profile
                                                               (with@ #//.dependencies (set.empty //dependency.hash))
                                                               (with@ #//.identity (#.Some (value@ #//dependency.artifact dependency)))
                                                               //pom.write
                                                               try.maybe))
                                                         ..profile)
                                         content ..content]
                                        (in [dependency
                                             (with@ #//package.origin (#//repository/origin.Remote "") (//package.local pom content))])))))]
    (in (dictionary.of_list //dependency.hash (list& [main_dependency main_package] dependencies)))))

(def: singular
  Test
  (do {! random.monad}
    [[dependency expected_package] ..package
     home (random.ascii/alpha 5)
     working_directory (random.ascii/alpha 5)
     .let [fs (: (file.System Async)
                 (file.mock (\ file.default separator)))
           program (program.async (program.mock environment.empty home working_directory))]]
    (in (do async.monad
          [wrote! (/.write_one program fs dependency expected_package)
           read! (/.read_one program fs dependency)]
          (_.cover' [/.write_one /.read_one]
                    (<| (try.else false)
                        (do try.monad
                          [_ wrote!
                           actual_package read!]
                          (in (\ //package.equivalence =
                                 (with@ #//package.origin (#//repository/origin.Local "") expected_package)
                                 actual_package)))))))))

(def: plural
  Test
  (do {! random.monad}
    [expected ..resolution
     home (random.ascii/alpha 5)
     working_directory (random.ascii/alpha 5)
     .let [fs (: (file.System Async)
                 (file.mock (\ file.default separator)))
           program (program.async (program.mock environment.empty home working_directory))]]
    (in (do async.monad
          [wrote! (/.write_all program fs expected)
           read! (/.read_all program fs (dictionary.keys expected) //dependency/resolution.empty)]
          (_.cover' [/.write_all /.read_all]
                    (<| (try.else false)
                        (do try.monad
                          [_ wrote!
                           actual read!]
                          (in (\ //dependency/resolution.equivalence =
                                 (\ dictionary.functor each
                                    (with@ #//package.origin (#//repository/origin.Local ""))
                                    expected)
                                 actual)))))))))

(def: .public test
  Test
  (<| (_.covering /._)
      ($_ _.and
          ..singular
          ..plural
          )))
