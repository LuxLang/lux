(.using
 [library
  [lux {"-" Type type}
   ["_" test {"+" Test}]
   [abstract
    ["[0]" monad {"+" do}]]
   [control
    ["[0]" try]
    [concurrency
     ["[0]" async {"+" Async}]]
    [parser
     ["[0]" environment]]]
   [data
    [binary {"+" Binary}]
    ["[0]" text]
    [format
     [xml {"+" XML}]]
    [collection
     ["[0]" set]
     ["[0]" dictionary]]]
   [math
    ["[0]" random {"+" Random} ("[1]#[0]" monad)]
    [number
     ["n" nat]]]
   [world
    ["[0]" file]
    ["[0]" program]]]]
 [//
  ["@[0]" profile]
  ["@[0]" artifact]
  [//
   [lux
    [data
     ["_[0]" binary]]]]]
 [\\program
  ["[0]" /
   ["/[1]" // "_"
    ["[1]" profile {"+" Profile}]
    ["[1][0]" package {"+" Package}]
    ["[1][0]" pom]
    ["[1][0]" dependency {"+" Dependency}
     ["[1]/[0]" resolution {"+" Resolution}]]
    ["[1][0]" artifact {"+" Artifact}
     ["[1]/[0]" type {"+" Type}]]
    ["[1][0]" repository "_"
     ["[1]/[0]" origin]]]]])

(def: type
  (Random Type)
  (all random.either
       (random#in //artifact/type.lux_library)
       (random#in //artifact/type.jvm_library)))

(def: profile
  (Random [Artifact Profile XML])
  (random.one (function (_ profile)
                (try.maybe
                 (do try.monad
                   [pom (//pom.write profile)
                    identity (try.of_maybe (the //.#identity profile))]
                   (in [identity profile pom]))))
              @profile.random))

(def: content
  (Random Binary)
  (do [! random.monad]
    [content_size (# ! each (n.% 100) random.nat)]
    (_binary.random content_size)))

(def: package
  (Random [Dependency Package])
  (do [! random.monad]
    [[identity profile pom] ..profile
     type ..type
     content ..content]
    (in [[//dependency.#artifact identity
          //dependency.#type type]
         (has //package.#origin {//repository/origin.#Remote ""} (//package.local pom content))])))

(def: resolution
  (Random Resolution)
  (do [! random.monad]
    [[main_dependency main_package] ..package
     dependencies (|> (//package.dependencies main_package)
                      (# try.monad each set.list)
                      (try.else (list))
                      (monad.each ! (function (_ dependency)
                                      (do !
                                        [pom (random.one (function (_ [identity profile pom])
                                                           (|> profile
                                                               (has //.#dependencies (set.empty //dependency.hash))
                                                               (has //.#identity {.#Some (the //dependency.#artifact dependency)})
                                                               //pom.write
                                                               try.maybe))
                                                         ..profile)
                                         content ..content]
                                        (in [dependency
                                             (has //package.#origin {//repository/origin.#Remote ""} (//package.local pom content))])))))]
    (in (dictionary.of_list //dependency.hash (partial_list [main_dependency main_package] dependencies)))))

(def: singular
  Test
  (do [! random.monad]
    [[dependency expected_package] ..package
     home (random.ascii/alpha 5)
     working_directory (random.ascii/alpha 5)
     .let [fs (is (file.System Async)
                  (file.mock (# file.default separator)))
           program (program.async (program.mock environment.empty home working_directory))]]
    (in (do async.monad
          [wrote! (/.write_one program fs dependency expected_package)
           read! (/.read_one program fs dependency)]
          (_.cover' [/.write_one /.read_one]
                    (<| (try.else false)
                        (do try.monad
                          [_ wrote!
                           actual_package read!]
                          (in (# //package.equivalence =
                                 (has //package.#origin {//repository/origin.#Local ""} expected_package)
                                 actual_package)))))))))

(def: plural
  Test
  (do [! random.monad]
    [expected ..resolution
     home (random.ascii/alpha 5)
     working_directory (random.ascii/alpha 5)
     .let [fs (is (file.System Async)
                  (file.mock (# file.default separator)))
           program (program.async (program.mock environment.empty home working_directory))]]
    (in (do async.monad
          [wrote! (/.write_all program fs expected)
           read! (/.read_all program fs (dictionary.keys expected) //dependency/resolution.empty)]
          (_.cover' [/.write_all /.read_all]
                    (<| (try.else false)
                        (do try.monad
                          [_ wrote!
                           actual read!]
                          (in (# //dependency/resolution.equivalence =
                                 (# dictionary.functor each
                                    (has //package.#origin {//repository/origin.#Local ""})
                                    expected)
                                 actual)))))))))

(def: .public test
  Test
  (<| (_.covering /._)
      (all _.and
           ..singular
           ..plural
           )))
