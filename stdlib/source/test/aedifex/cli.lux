(.using
 [library
  [lux (.full)
   ["_" test (.only Test)]
   [abstract
    [monad (.only do)]
    [\\specification
     ["$[0]" equivalence]]]
   [control
    ["[0]" pipe]
    ["[0]" try]
    [parser
     ["[0]" cli]]]
   [data
    ["[0]" text]
    [collection
     ["[0]" list]]]
   [math
    ["[0]" random (.only Random) ("[1]#[0]" monad)]]]]
 [\\program
  ["[0]" /
   ["/[1]" // "_"
    ["[1]" profile]]]])

(def: compilation
  (Random /.Compilation)
  (random.or (random#in [])
             (random#in [])))

(def: command
  (Random /.Command)
  (all random.or
       ... #Version
       (random#in [])
       ... #Clean
       (random#in [])
       ... #POM
       (random#in [])
       ... #Dependencies
       (random#in [])
       ... #Install
       (random#in [])
       ... #Deploy
       (all random.and
            (random.alphabetic 1)
            (random.alphabetic 1)
            (random.alphabetic 1))
       ... #Compilation
       ..compilation
       ... #Auto
       ..compilation))

(def: (compilation_format value)
  (-> /.Compilation (List Text))
  (case value
    {/.#Build} (list "build")
    {/.#Test} (list "test")))

(def: (format value)
  (-> /.Command (List Text))
  (case value
    {/.#Version} (list "version")
    {/.#Clean} (list "clean")
    {/.#POM} (list "pom")
    {/.#Dependencies} (list "deps")
    {/.#Install} (list "install")
    {/.#Deploy repository [user password]} (list "deploy" repository user password)
    {/.#Compilation compilation} (..compilation_format compilation)
    {/.#Auto compilation} (partial_list "auto" (..compilation_format compilation))))

(def: without_profile
  Test
  (do random.monad
    [expected ..command]
    (_.property "Without profile."
      (|> expected
          ..format
          (cli.result /.command)
          (pipe.case
            {try.#Success [names actual]}
            (and (# (list.equivalence text.equivalence) = (list //.default) names)
                 (# /.equivalence = expected actual))
            
            {try.#Failure error}
            false)))))

(def: with_profile
  Test
  (do random.monad
    [expected_profile (random.alphabetic 1)
     expected_command ..command]
    (_.property "With profile."
      (|> expected_command
          ..format
          (partial_list "with" expected_profile)
          (cli.result /.command)
          (pipe.case
            {try.#Success [actual_profile actual_command]}
            (and (# (list.equivalence text.equivalence) = (list expected_profile //.default) actual_profile)
                 (# /.equivalence = expected_command actual_command))
            
            {try.#Failure error}
            false)))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Compilation /.Command]
             (all _.and
                  (_.for [/.equivalence]
                         ($equivalence.spec /.equivalence ..command))

                  (_.for [/.command]
                         (all _.and
                              ..without_profile
                              ..with_profile
                              ))))))
