(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    [abstract
     [monad {"+" [do]}]]
    [control
     ["[0]" try]
     ["[0]" exception]
     [concurrency
      ["[0]" async]]
     [parser
      ["[0]" environment]]]
    [data
     ["[0]" text ("[1]\[0]" equivalence)]
     [collection
      ["[0]" dictionary]
      ["[0]" list]]]
    [math
     ["[0]" random]]
    [world
     ["[0]" file]
     ["[0]" shell]
     ["[0]" program]]]]
  ["[0]" // "_"
   ["@[0]" version]
   ["@[0]" build]
   ["$/[1]" // "_"
    ["[1][0]" package]]]
  [\\program
   ["[0]" /
    ["/[1]" // "_"
     ["[1][0]" build]
     ["/[1]" // "_"
      ["[1]" profile {"+" [Profile]}]
      ["[1][0]" action]
      ["[1][0]" artifact
       ["[1]/[0]" type]]
      ["[1][0]" dependency
       ["[1]/[0]" resolution]]]]]])

(def: .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [test (random.ascii/alpha 5)
         target (random.ascii/alpha 5)
         home (random.ascii/alpha 5)
         working_directory (random.ascii/alpha 5)
         .let [empty_profile (: Profile
                                (\ ///.monoid identity))
               with_target (: (-> Profile Profile)
                              (with@ #///.target target))
               with_test (: (-> Profile Profile)
                            (with@ #///.test {#.Some test}))
               
               profile (|> empty_profile
                           with_test
                           with_target)]
         [compiler resolution] @build.resolution]
        ($_ _.and
            (let [fs (file.mock (\ file.default separator))
                  console (@version.echo "")]
              (in (do async.monad
                    [verdict (do ///action.monad
                               [_ (/.do! console (program.async (program.mock environment.empty home working_directory))
                                         fs (shell.async (@build.good_shell [])) resolution
                                         (with@ #///.compiler compiler profile))
                                build_start (\ console read_line [])
                                build_end (\ console read_line [])
                                test_start (\ console read_line [])
                                test_end (\ console read_line [])]
                               (in (and (and (text\= //build.start build_start)
                                             (text\= //build.success build_end))
                                        (and (text\= /.start test_start)
                                             (text\= /.success test_end)))))]
                    (_.cover' [/.do!
                               /.start /.success]
                              (try.else false verdict)))))
            (let [fs (file.mock (\ file.default separator))
                  console (@version.echo "")]
              (in (do async.monad
                    [verdict (do ///action.monad
                               [.let [bad_shell (shell.mock
                                                 (function (_ [actual_environment actual_working_directory actual_command actual_arguments])
                                                   {#try.Success
                                                    (: (shell.Mock [])
                                                       (implementation
                                                        (def: (on_read state)
                                                          (exception.except shell.no_more_output []))
                                                        (def: (on_error state)
                                                          (exception.except shell.no_more_output []))
                                                        (def: (on_write input state)
                                                          {#try.Failure "on_write"})
                                                        (def: (on_destroy state)
                                                          {#try.Failure "on_destroy"})
                                                        (def: (on_await state)
                                                          {#try.Success [state (if (list.any? (text\= "build") actual_arguments)
                                                                                 shell.normal
                                                                                 shell.error)]})))})
                                                 [])]
                                _ (/.do! console (program.async (program.mock environment.empty home working_directory))
                                         fs (shell.async bad_shell) resolution
                                         (with@ #///.compiler compiler profile))
                                build_start (\ console read_line [])
                                build_end (\ console read_line [])
                                test_start (\ console read_line [])
                                test_end (\ console read_line [])]
                               (in (and (and (text\= //build.start build_start)
                                             (text\= //build.success build_end))
                                        (and (text\= /.start test_start)
                                             (text\= /.failure test_end)))))]
                    (_.cover' [/.failure]
                              (try.else false verdict)))))
            ))))
