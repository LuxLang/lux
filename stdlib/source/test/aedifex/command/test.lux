(.module:
  [lux #*
   ["_" test (#+ Test)]
   [abstract
    [monad (#+ do)]]
   [control
    ["." try]
    [concurrency
     ["." promise]]
    [parser
     ["." environment]]
    [security
     ["!" capability]]]
   [data
    ["." text ("#\." equivalence)]
    [collection
     ["." dictionary]]]
   [math
    ["." random]]
   [world
    ["." file]
    ["." shell]
    ["." program]]]
  ["." // #_
   ["@." version]
   ["@." build]
   ["$/#" // #_
    ["#." package]]]
  {#program
   ["." /
    ["/#" // #_
     ["#." build]
     ["/#" // #_
      ["#" profile (#+ Profile)]
      ["#." action]
      ["#." artifact
       ["#/." type]]
      ["#." dependency
       ["#/." resolution]]]]]})

(def: #export test
  Test
  (<| (_.covering /._)
      (do {! random.monad}
        [program (random.ascii/alpha 5)
         target (random.ascii/alpha 5)
         working-directory (random.ascii/alpha 5)
         #let [empty-profile (: Profile
                                (\ ///.monoid identity))
               with-target (: (-> Profile Profile)
                              (set@ #///.target (#.Some target)))
               with-program (: (-> Profile Profile)
                               (set@ #///.program (#.Some program)))
               
               profile (|> empty-profile
                           with-program
                           with-target)]
         resolution @build.resolution]
        ($_ _.and
            (let [fs (file.mock (\ file.default separator))
                  console (@version.echo "")]
              (wrap (do promise.monad
                      [verdict (do ///action.monad
                                 [_ (/.do! console (program.async (program.mock environment.empty working-directory)) fs (@build.good-shell []) resolution profile)
                                  build-start (!.use (\ console read-line) [])
                                  build-end (!.use (\ console read-line) [])
                                  test-start (!.use (\ console read-line) [])
                                  test-end (!.use (\ console read-line) [])]
                                 (wrap (and (and (text\= //build.start build-start)
                                                 (text\= //build.success build-end))
                                            (and (text\= /.start test-start)
                                                 (text\= /.success test-end)))))]
                      (_.cover' [/.do!
                                 /.start /.success]
                                (try.default false verdict)))))
            (let [fs (file.mock (\ file.default separator))
                  console (@version.echo "")]
              (wrap (do promise.monad
                      [verdict (do ///action.monad
                                 [#let [bad-shell (shell.mock
                                                   (function (_ [actual-environment actual-working-directory actual-command actual-arguments])
                                                     (#try.Success
                                                      (: (shell.Simulation [])
                                                         (structure
                                                          (def: (on-read state)
                                                            (#try.Failure "on-read"))
                                                          (def: (on-error state)
                                                            (#try.Failure "on-error"))
                                                          (def: (on-write input state)
                                                            (#try.Failure "on-write"))
                                                          (def: (on-destroy state)
                                                            (#try.Failure "on-destroy"))
                                                          (def: (on-await state)
                                                            (#try.Success [state (if (text.ends-with? " build" actual-command)
                                                                                   shell.normal
                                                                                   shell.error)]))))))
                                                   [])]
                                  _ (/.do! console (program.async (program.mock environment.empty working-directory)) fs bad-shell resolution profile)
                                  build-start (!.use (\ console read-line) [])
                                  build-end (!.use (\ console read-line) [])
                                  test-start (!.use (\ console read-line) [])
                                  test-end (!.use (\ console read-line) [])]
                                 (wrap (and (and (text\= //build.start build-start)
                                                 (text\= //build.success build-end))
                                            (and (text\= /.start test-start)
                                                 (text\= /.failure test-end)))))]
                      (_.cover' [/.failure]
                                (try.default false verdict)))))
            ))))
