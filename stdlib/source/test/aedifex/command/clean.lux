(.module:
  [library
   [lux #*
    ["_" test (#+ Test)]
    [abstract
     ["." monad (#+ do)]]
    [control
     ["." try (#+ Try)]
     [concurrency
      ["." async (#+ Async)]]]
    [data
     [binary (#+ Binary)]
     ["." product]
     ["." text ("#\." equivalence)
      ["%" format (#+ format)]]
     [collection
      ["." list ("#\." functor)]
      ["." set]]]
    [math
     ["." random (#+ Random)]
     [number
      ["n" nat]]]
    [world
     ["." file (#+ Path)]]]]
  [//
   ["@." version]
   [//
    ["@." profile]
    [//
     [lux
      [data
       ["$." binary]]]]]]
  [\\program
   ["." /
    ["//#" /// #_
     ["#" profile]
     ["#." action (#+ Action)]]]])

(def: node_name
  (Random Text)
  (random.ascii/alpha 10))

(def: (files prefix)
  (-> Path (Random (List [Path Binary])))
  (do {! random.monad}
    [count (\ ! map (n.% 10) random.nat)
     names (random.set text.hash count ..node_name)
     contents (random.list count ($binary.random 100))]
    (in (list.zipped/2 (list\map (|>> (format prefix)) (set.to_list names))
                       contents))))

(def: (create_file! fs [path content])
  (-> (file.System Async) [Path Binary] (Async (Try Any)))
  (\ fs write content path))

(def: (create_directory! fs path files)
  (-> (file.System Async) Path (List [Path Binary]) (Async (Try Any)))
  (do {! (try.with async.monad)}
    [_ (: (Async (Try Any))
          (file.make_directories async.monad fs path))
     _ (monad.map ! (..create_file! fs) files)]
    (in [])))

(def: (directory_exists? fs)
  (-> (file.System Async) Path (Async (Try Bit)))
  (|>> (\ fs directory?) (try.lifted async.monad)))

(def: (file_exists? fs)
  (-> (file.System Async) Path (Async (Try Bit)))
  (|>> (\ fs file?) (try.lifted async.monad)))

(def: (assets_exist? fs directory_path files)
  (-> (file.System Async) Path (List [Path Binary]) (Async (Try Bit)))
  (do {! (try.with async.monad)}
    [directory_exists? (..directory_exists? fs directory_path)
     files_exist? (: (Action (List Bit))
                     (|> files
                         (list\map product.left)
                         (monad.map ///action.monad (..file_exists? fs))))]
    (in (and directory_exists?
             (list.every? (|>>) files_exist?)))))

(def: #export test
  Test
  (<| (_.covering /._)
      (do {! random.monad}
        [context ..node_name
         target ..node_name
         sub ..node_name
         #let [fs (file.mock (\ file.default separator))
               / (\ fs separator)
               target_path (format context / target)
               sub_path (format target_path / sub)]
         direct_files (..files (format target_path /))
         sub_files (..files (format sub_path /))

         dummy @profile.random]
        (in (do async.monad
              [#let [console (@version.echo "")]
               verdict (do {! (try.with async.monad)}
                         [_ (..create_directory! fs target_path direct_files)
                          _ (..create_directory! fs sub_path sub_files)
                          context_exists!/pre (..directory_exists? fs context)
                          target_exists!/pre (..assets_exist? fs target_path direct_files)
                          sub_exists!/pre (..assets_exist? fs sub_path sub_files)
                          _ (/.do! console fs (set@ #///.target target_path dummy))
                          context_exists!/post (..directory_exists? fs context)
                          target_exists!/post (..assets_exist? fs target_path direct_files)
                          sub_exists!/post (..assets_exist? fs sub_path sub_files)
                          logging (\ console read_line [])]
                         (in (and (and context_exists!/pre
                                       context_exists!/post)
                                  (and target_exists!/pre
                                       (not target_exists!/post))
                                  (and sub_exists!/pre
                                       (not sub_exists!/post))
                                  (text\= (/.success target_path) logging))))]
              (_.cover' [/.do! /.success]
                        (try.default false verdict)))))))
