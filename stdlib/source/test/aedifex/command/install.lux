(.module:
  [library
   [lux #*
    ["_" test (#+ Test)]
    [abstract
     ["." monad (#+ do)]]
    [control
     ["." try (#+ Try) ("#\." functor)]
     ["." exception]
     [concurrency
      ["." async (#+ Async)]]
     [parser
      ["." environment]]]
    [data
     ["." binary]
     ["." text ("#\." equivalence)
      ["%" format (#+ format)]]
     [collection
      ["." set (#+ Set)]]]
    [math
     ["." random]]
    [world
     ["." file]
     ["." program (#+ Program)]]]]
  [//
   ["$." version]
   [//
    ["$." profile]
    ["$." artifact]]]
  [\\program
   ["." /
    ["/#" // #_
     ["/#" // #_
      ["#" profile]
      ["#." action (#+ Action)]
      ["#." local]
      ["#." artifact
       ["#/." extension]]
      ["#." repository #_
       ["#/." local]]]]]])

(def: .public (make_sources! fs sources)
  (-> (file.System Async) (Set file.Path) (Action (List Any)))
  (let [/ (\ fs separator)
        ! ///action.monad]
    (|> sources
        set.list
        (monad.map ! (function (_ head)
                       (do !
                         [_ (: (Async (Try Any))
                               (file.make_directories async.monad fs head))]
                         (: (Async (Try Any))
                            (file.make_file async.monad fs (binary.create 0) (format head / head ".lux")))))))))

(def: (execute! program fs sample)
  (-> (Program Async) (file.System Async) ///.Profile (Async (Try Text)))
  (do ///action.monad
    [.let [console ($version.echo "")]
     _ (..make_sources! fs (get@ #///.sources sample))
     _ (/.do! console fs (///repository/local.repository program fs) sample)]
    (\ console read_line [])))

(def: .public test
  Test
  (<| (_.covering /._)
      (do {! random.monad}
        [identity $artifact.random
         sample (\ ! map (set@ #///.identity (#.Some identity))
                   $profile.random)
         home (random.ascii/alpha 5)
         working_directory (random.ascii/alpha 5)
         .let [/ (\ file.default separator)]]
        ($_ _.and
            (in (do {! async.monad}
                  [.let [fs (file.mock /)
                         program (program.async (program.mock environment.empty home working_directory))

                         artifact_path (///local.uri (get@ #///artifact.version identity) identity)
                         library_path (format artifact_path ///artifact/extension.lux_library)
                         pom_path (format artifact_path ///artifact/extension.pom)]
                   verdict (do {! ///action.monad}
                             [succeeded! (\ ! map (text\= /.success)
                                            (..execute! program fs sample))
                              library_exists! (|> library_path
                                                  (format home /)
                                                  (\ fs file?)
                                                  (\ async.monad map exception.return))
                              pom_exists! (|> pom_path
                                              (format home /)
                                              (\ fs file?)
                                              (\ async.monad map exception.return))]
                             (in (and succeeded!
                                      library_exists!
                                      pom_exists!)))]
                  (_.cover' [/.do! /.success]
                            (try.else false verdict))))
            (in (do {! async.monad}
                  [.let [fs (file.mock /)
                         program (program.async (program.mock environment.empty home working_directory))]
                   logging (..execute! program fs (set@ #///.identity #.None sample))]
                  (_.cover' [/.failure]
                            (|> logging
                                (try\map (text\= /.failure))
                                (try.else false)))))
            ))))
