(.module:
  [lux #*
   ["_" test (#+ Test)]
   [abstract
    [monad (#+ do)]]
   [control
    ["." try]
    [parser
     ["." environment (#+ Environment)]]
    [concurrency
     ["." atom (#+ Atom)]
     ["." promise (#+ Promise)]]
    [security
     ["!" capability]]]
   [data
    ["." text
     ["%" format (#+ format)]
     [encoding
      ["." utf8]]]
    [collection
     ["." dictionary]
     ["." set]
     ["." list ("#\." functor)]]]
   [math
    ["." random (#+ Random)]
    [number
     ["n" nat]]]
   [world
    [console (#+ Console)]
    ["." shell (#+ Shell)]
    ["." program (#+ Program)]
    ["." file (#+ Path File)
     ["." watch]]]]
  ["." // #_
   ["@." version]
   ["@." build]
   ["$/#" // #_
    ["#." package]]]
  {#program
   ["." /
    ["/#" // #_
     ["#." build]
     ["/#" // #_
      [command (#+ Command)]
      ["#" profile (#+ Profile)]
      ["#." action]
      ["#." artifact
       ["#/." type]]
      ["#." dependency
       ["#/." resolution (#+ Resolution)]]]]]})

(def: (command expected_runs end_signal dummy_file)
  (-> Nat Text (File Promise)
      [(Atom Nat)
       (-> (Console Promise) (Program Promise) (file.System Promise) (Shell Promise) Resolution (Command Any))])
  (let [@runs (: (Atom Nat)
                 (atom.atom 0))]
    [@runs
     (function (_ console program fs shell resolution profile)
       (do {! promise.monad}
         [[_ actual_runs] (promise.future (atom.update inc @runs))]
         (if (n.= expected_runs actual_runs)
           (wrap (#try.Failure end_signal))
           (do (try.with !)
             [_ (!.use (\ dummy_file over_write) (\ utf8.codec encode (%.nat actual_runs)))]
             (do !
               [_ (promise.future (atom.write actual_runs @runs))]
               (wrap (#try.Success [])))))))]))

(def: #export test
  Test
  (<| (_.covering /._)
      (do {! random.monad}
        [#let [/ (\ file.default separator)
               [fs watcher] (watch.mock /)]
         end_signal (random.ascii/alpha 5)
         
         program (random.ascii/alpha 5)
         target (random.ascii/alpha 5)
         source (random.ascii/alpha 5)
         #let [empty_profile (: Profile
                                (\ ///.monoid identity))
               with_target (: (-> Profile Profile)
                              (set@ #///.target target))
               with_program (: (-> Profile Profile)
                               (set@ #///.program (#.Some program)))
               
               profile (|> empty_profile
                           with_program
                           with_target
                           (set@ #///.sources (set.from_list text.hash (list source))))]

         home (random.ascii/alpha 5)
         working_directory (random.ascii/alpha 5)
         
         expected_runs (\ ! map (|>> (n.% 10) (n.max 2)) random.nat)
         dummy_path (\ ! map (|>> (format source /)) (random.ascii/alpha 5))
         resolution @build.resolution]
        ($_ _.and
            (wrap (do promise.monad
                    [verdict (do ///action.monad
                               [_ (!.use (\ fs create_directory) [source])
                                dummy_file (!.use (\ fs create_file) [dummy_path])
                                #let [[@runs command] (..command expected_runs end_signal dummy_file)]
                                _ (\ watcher poll [])]
                               (do promise.monad
                                 [outcome ((/.do! 1 watcher command)
                                           (@version.echo "")
                                           (program.async (program.mock environment.empty home working_directory))
                                           fs
                                           (shell.async (@build.good_shell []))
                                           resolution
                                           profile)
                                  actual_runs (promise.future (atom.read @runs))]
                                 (wrap (#try.Success (and (n.= expected_runs actual_runs)
                                                          (case outcome
                                                            (#try.Failure error)
                                                            (is? end_signal error)

                                                            (#try.Success _)
                                                            false))))))]
                    (_.cover' [/.do!]
                              (try.default false verdict))))
            ))))
