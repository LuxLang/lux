(.module:
  [lux #*
   ["_" test (#+ Test)]
   [abstract
    [monad (#+ do)]]
   [control
    ["." try]
    ["." exception]
    [concurrency
     ["." promise (#+ Promise)]]
    [parser
     ["." environment]]
    [security
     ["!" capability]]]
   [data
    ["." text ("#\." equivalence)]
    [collection
     ["." dictionary]]]
   [math
    ["." random]]
   [world
    ["." file]
    ["." shell (#+ Shell)]
    ["." program]]]
  ["." // #_
   ["@." version]
   ["$/#" // #_
    ["#." package]]]
  {#program
   ["." /
    ["//#" /// #_
     ["#" profile (#+ Profile)]
     ["#." action]
     ["#." artifact
      ["#/." type]]
     ["#." dependency
      ["#/." resolution]]]]})

(def: #export good-shell
  (-> Any (Shell Promise))
  (shell.mock
   (function (_ [actual-environment actual-working-directory actual-command actual-arguments])
     (#try.Success
      (: (shell.Simulation [])
         (structure
          (def: (on-read state)
            (#try.Failure "on-read"))
          (def: (on-error state)
            (#try.Failure "on-error"))
          (def: (on-write input state)
            (#try.Failure "on-write"))
          (def: (on-destroy state)
            (#try.Failure "on-destroy"))
          (def: (on-await state)
            (#try.Success [state shell.normal]))))))))

(def: #export bad-shell
  (-> Any (Shell Promise))
  (shell.mock
   (function (_ [actual-environment actual-working-directory actual-command actual-arguments])
     (#try.Success
      (: (shell.Simulation [])
         (structure
          (def: (on-read state)
            (#try.Failure "on-read"))
          (def: (on-error state)
            (#try.Failure "on-error"))
          (def: (on-write input state)
            (#try.Failure "on-write"))
          (def: (on-destroy state)
            (#try.Failure "on-destroy"))
          (def: (on-await state)
            (#try.Success [state shell.error]))))))))

(def: compiler
  (do random.monad
    [lux-version (random.ascii/alpha 5)
     #let [jvm-compiler {#///dependency.artifact {#///artifact.group /.lux-group
                                                  #///artifact.name /.jvm-compiler-name
                                                  #///artifact.version lux-version}
                         #///dependency.type ///artifact/type.lux-library}
           js-compiler {#///dependency.artifact {#///artifact.group /.lux-group
                                                 #///artifact.name /.js-compiler-name
                                                 #///artifact.version lux-version}
                        #///dependency.type ///artifact/type.lux-library}]]
    (random.either (wrap jvm-compiler)
                   (wrap js-compiler))))

(def: #export resolution
  (do random.monad
    [dependency ..compiler
     [_ package] $///package.random]
    (wrap (|> ///dependency/resolution.empty
              (dictionary.put dependency package)))))

(def: #export test
  Test
  (<| (_.covering /._)
      (do {! random.monad}
        [#let [fs (file.mock (\ file.default separator))
               shell (..good-shell [])]
         program (random.ascii/alpha 5)
         target (random.ascii/alpha 5)
         home (random.ascii/alpha 5)
         working-directory (random.ascii/alpha 5)
         #let [empty-profile (: Profile
                                (\ ///.monoid identity))
               with-target (: (-> Profile Profile)
                              (set@ #///.target (#.Some target)))
               with-program (: (-> Profile Profile)
                               (set@ #///.program (#.Some program)))
               
               profile (|> empty-profile
                           with-program
                           with-target)]]
        ($_ _.and
            (wrap (do promise.monad
                    [outcome (/.do! (@version.echo "") (program.async (program.mock environment.empty home working-directory)) fs shell ///dependency/resolution.empty
                                    (with-target empty-profile))]
                    (_.cover' [/.no-specified-program]
                              (case outcome
                                (#try.Success _)
                                false

                                (#try.Failure error)
                                (exception.match? /.no-specified-program error)))))
            (wrap (do promise.monad
                    [outcome (/.do! (@version.echo "") (program.async (program.mock environment.empty home working-directory)) fs shell ///dependency/resolution.empty
                                    (with-program empty-profile))]
                    (_.cover' [/.no-specified-target]
                              (case outcome
                                (#try.Success _)
                                false

                                (#try.Failure error)
                                (exception.match? /.no-specified-target error)))))
            (wrap (do promise.monad
                    [outcome (/.do! (@version.echo "") (program.async (program.mock environment.empty home working-directory)) fs shell ///dependency/resolution.empty profile)]
                    (_.cover' [/.Compiler /.no-available-compiler]
                              (case outcome
                                (#try.Success _)
                                false

                                (#try.Failure error)
                                (exception.match? /.no-available-compiler error)))))
            (do !
              [#let [console (@version.echo "")]
               resolution ..resolution]
              (wrap (do promise.monad
                      [verdict (do ///action.monad
                                 [_ (/.do! console (program.async (program.mock environment.empty home working-directory)) fs shell resolution profile)
                                  start (!.use (\ console read-line) [])
                                  end (!.use (\ console read-line) [])]
                                 (wrap (and (text\= /.start start)
                                            (text\= /.success end))))]
                      (_.cover' [/.do!
                                 /.lux-group /.jvm-compiler-name /.js-compiler-name
                                 /.start /.success]
                                (try.default false verdict)))))
            (do !
              [#let [console (@version.echo "")]
               resolution ..resolution]
              (wrap (do promise.monad
                      [verdict (do ///action.monad
                                 [_ (/.do! console (program.async (program.mock environment.empty home working-directory)) fs (..bad-shell []) resolution profile)
                                  start (!.use (\ console read-line) [])
                                  end (!.use (\ console read-line) [])]
                                 (wrap (and (text\= /.start start)
                                            (text\= /.failure end))))]
                      (_.cover' [/.failure]
                                (try.default false verdict)))))
            ))))
