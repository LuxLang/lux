(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    [abstract
     [monad {"+" [do]}]
     ["[0]" predicate]]
    [control
     ["[0]" try]
     [concurrency
      ["[0]" async]]
     [parser
      ["[0]" environment]]]
    [data
     ["[0]" text ("[1]\[0]" equivalence)
      ["%" format {"+" [format]}]
      [encoding
       ["[0]" utf8]]]
     [collection
      ["[0]" dictionary]
      ["[0]" set]]
     [format
      ["[0]" xml]]]
    [math
     ["[0]" random {"+" [Random]}]]
    [world
     ["[0]" program]
     ["[0]" file]]]]
  ["[0]" // "_"
   ["@[0]" version]
   ["$/[1]" // "_"
    ["[1][0]" package]
    ["[1][0]" artifact]
    ["[1][0]" dependency "_"
     ["[1]/[0]" resolution]]]]
  [\\program
   ["[0]" /
    ["/[1]" // "_"
     ["[1][0]" clean]
     ["/[1]" // "_"
      ["[1]" profile]
      ["[1][0]" action]
      ["[1][0]" pom]
      ["[1][0]" package]
      ["[1][0]" artifact
       ["[1]/[0]" type]]
      ["[1][0]" dependency
       ["[1]/[0]" resolution]
       ["[1]/[0]" deployment]
       ["[1]/[0]" status]]
      ["[1][0]" repository
       ["[1]/[0]" origin]
       ["[1]/[0]" local]]]]]])

(def: .public test
  Test
  (<| (_.covering /._)
      (do random.monad
        [home (random.ascii/alpha 5)
         working_directory (random.ascii/alpha 5)

         dependee_artifact $///artifact.random
         depender_artifact (random.only (predicate.complement
                                         (\ ///artifact.equivalence = dependee_artifact))
                                        $///artifact.random)

         [_ dependee_package] $///package.random
         [_ depender_package] $///package.random

         .let [dependee [#///dependency.artifact dependee_artifact
                         #///dependency.type ///artifact/type.lux_library]
               depender [#///dependency.artifact depender_artifact
                         #///dependency.type ///artifact/type.lux_library]

               dependee_pom (|> (\ ///.monoid identity)
                                (with@ #///.identity (#.Some dependee_artifact))
                                ///pom.write
                                try.trusted)
               depender_pom (|> (\ ///.monoid identity)
                                (with@ #///.identity (#.Some depender_artifact))
                                (with@ #///.dependencies (set.of_list ///dependency.hash (list dependee)))
                                ///pom.write
                                try.trusted)
               
               dependee_package (|> dependee_package
                                    (with@ #///package.origin (#///repository/origin.Remote ""))
                                    (with@ #///package.pom [dependee_pom
                                                            (|> dependee_pom (\ xml.codec encoded) (\ utf8.codec encoded))
                                                            #///dependency/status.Unverified]))
               depender_package (|> depender_package
                                    (with@ #///package.origin (#///repository/origin.Remote ""))
                                    (with@ #///package.pom [depender_pom
                                                            (|> depender_pom (\ xml.codec encoded) (\ utf8.codec encoded))
                                                            #///dependency/status.Unverified]))

               fs (file.mock (\ file.default separator))
               program (program.async (program.mock environment.empty home working_directory))]]
        (in (do async.monad
              [verdict (do ///action.monad
                         [.let [console (@version.echo "")
                                local (///repository/local.repository program fs)]
                          pre (|> ///dependency/resolution.empty
                                  (dictionary.has dependee dependee_package)
                                  (///dependency/deployment.all local))
                          post (|> (\ ///.monoid identity)
                                   (with@ #///.dependencies (set.of_list ///dependency.hash (list dependee depender)))
                                   (/.do! console local
                                          (list (///repository.mock ($///dependency/resolution.single depender_artifact depender_package)
                                                                    []))
                                          (function (_ url)
                                            (///repository.mock $///dependency/resolution.nope []))))

                          .let [had_dependee_before!
                                (set.member? pre dependee_artifact)

                                lacked_depender_before!
                                (not (set.member? pre depender_artifact))

                                had_dependee_after!
                                (dictionary.key? post dependee)
                                
                                had_depender_after!
                                (dictionary.key? post depender)]]
                         (in (and had_dependee_before!
                                  lacked_depender_before!
                                  
                                  had_dependee_after!
                                  had_depender_after!)))]
              (_.cover' [/.do!]
                        (try.else false verdict)))))))
