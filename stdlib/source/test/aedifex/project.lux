(.using
 [library
  [lux "*"
   ["_" test (.only Test)]
   [abstract
    [monad (.only do)]
    [\\specification
     ["$[0]" equivalence]
     ["$[0]" monoid]]]
   [control
    ["[0]" try ("[1]#[0]" functor)]
    ["[0]" exception]]
   [data
    ["[0]" product]
    ["[0]" text ("[1]#[0]" equivalence)]]
   [math
    ["[0]" random (.only Random) ("[1]#[0]" monad)]
    [number
     ["n" nat]]]]]
 [//
  ["@[0]" profile]]
 [\\program
  ["[0]" /
   ["/[1]" // "_"
    ["[1]" profile]]]])

(def: profile
  (Random [//.Name //.Profile])
  (|> @profile.random
      (random#each (has //.#parents (list)))
      (random.and (random.alphabetic 1))))

(def: .public random
  (Random /.Project)
  (do random.monad
    [[name profile] ..profile]
    (in (/.project name profile))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Project /.project]
             (all _.and
                  (_.for [/.equivalence]
                         ($equivalence.spec /.equivalence ..random))
                  (_.for [/.monoid]
                         ($monoid.spec /.equivalence /.monoid ..random))

                  (_.coverage [/.file]
                    (|> /.file
                        (text#= "")
                        not))
                  (do random.monad
                    [[super_name super_profile] ..profile
                     [dummy_name dummy_profile] (random.only (|>> product.left (text#= super_name) not)
                                                             ..profile)
                     [sub_name sub_profile] (random.only (function (_ [name profile])
                                                           (and (not (text#= super_name name))
                                                                (not (text#= dummy_name name))))
                                                         ..profile)
                     fake_name (random.only (function (_ name)
                                              (and (not (text#= super_name name))
                                                   (not (text#= dummy_name name))
                                                   (not (text#= sub_name name))))
                                            (random.alphabetic 1))
                     .let [project (all (# /.monoid composite)
                                        (/.project super_name super_profile)
                                        (/.project dummy_name dummy_profile)
                                        (/.project sub_name (has //.#parents (list super_name) sub_profile)))
                           circular (all (# /.monoid composite)
                                         (/.project super_name (has //.#parents (list sub_name) super_profile))
                                         (/.project dummy_name dummy_profile)
                                         (/.project sub_name (has //.#parents (list super_name) sub_profile)))]]
                    (all _.and
                         (_.coverage [/.profile]
                           (and (|> (/.profile project super_name)
                                    (try#each (# //.equivalence = super_profile))
                                    (try.else false))
                                (|> (/.profile project dummy_name)
                                    (try#each (# //.equivalence = dummy_profile))
                                    (try.else false))
                                (|> (/.profile project sub_name)
                                    (try#each (# //.equivalence = (# //.monoid composite sub_profile super_profile)))
                                    (try.else false))))
                         (_.coverage [/.unknown_profile]
                           (case (/.profile project fake_name)
                             {try.#Success _}
                             false

                             {try.#Failure error}
                             (exception.match? /.unknown_profile error)))
                         (_.coverage [/.circular_dependency]
                           (case (/.profile circular sub_name)
                             {try.#Success _}
                             false

                             {try.#Failure error}
                             (exception.match? /.circular_dependency error)))
                         ))
                  ))))
