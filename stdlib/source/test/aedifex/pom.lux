(.using
 [library
  [lux (.except)
   ["_" test (.only Test)]
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" try]
    ["[0]" exception]
    ["<>" parser (.only)
     ["<[0]>" xml]]]
   [data
    ["[0]" text ("[1]#[0]" equivalence)]
    [format
     ["[0]" xml]]]
   [math
    ["[0]" random]]]]
 [//
  ["@[0]" profile]]
 [\\program
  ["[0]" / (.only)
   ["/[1]" //
    ["[1]" profile]]]])

(def: .public test
  Test
  (<| (_.covering /._)
      (all _.and
           (_.coverage [/.file]
             (|> /.file
                 (text#= "")
                 not))
           (do random.monad
             [expected @profile.random]
             (_.coverage [/.write /.parser]
               (case [(/.write expected)
                      (the //.#identity expected)]
                 [{try.#Success pom}
                  {.#Some _}]
                 (case (<xml>.result /.parser (list pom))
                   {try.#Success actual}
                   (# //.equivalence =
                      (|> (# //.monoid identity)
                          (has //.#dependencies (the //.#dependencies expected))
                          (has //.#repositories (the //.#repositories expected)))
                      actual)

                   {try.#Failure error}
                   false)

                 [{try.#Failure error}
                  {.#None}]
                 (exception.match? //.no_identity error)

                 _
                 false)))
           )))
