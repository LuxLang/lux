(.using
 [library
  [lux (.full)
   ["_" test (.only Test)]
   [abstract
    [monad (.only do)]
    [\\specification
     ["$[0]" equivalence]]]
   [control
    ["[0]" try ("[1]#[0]" functor)]
    [parser
     ["<[0]>" text]]]
   [data
    ["[0]" text ("[1]#[0]" equivalence)
     ["%" format (.only format)]]]
   [math
    ["[0]" random (.only Random) ("[1]#[0]" monad)]
    [number
     ["n" nat]
     ["i" int]]]
   [time
    ["[0]" instant]]]]
 ["$[0]" /// "_"
  ["[1][0]" stamp]]
 [\\program
  ["[0]" /
   ["//[1]" ///
    ["[1][0]" stamp]
    ["[1][0]" time]]]])

(def: .public random
  (Random /.Value)
  (all random.and
       (random.alphabetic 5)
       (random.or (random#in [])
                  $///stamp.random)
       ))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Value])
      (all _.and
           (_.for [/.equivalence]
                  ($equivalence.spec /.equivalence ..random))

           (do random.monad
             [sample random
              stamp $///stamp.random]
             (let [version (the /.#version sample)

                   local!
                   (text#= version
                           (/.format (has /.#snapshot {///.#Local} sample)))

                   remote_format (/.format [/.#version (format version /.snapshot)
                                            /.#snapshot {///.#Remote stamp}])
                   remote!
                   (and (text.starts_with? (format version (///time.format (the ///stamp.#time stamp)))
                                           remote_format)
                        (text.ends_with? (%.nat (the ///stamp.#build stamp))
                                         remote_format))]
               (_.coverage [/.snapshot /.format]
                 (and local!
                      remote!))))
           )))
