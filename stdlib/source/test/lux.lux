(.module:
  ["/" lux #*
   ["@" target]
   [abstract
    [monad (#+ do)]
    [predicate (#+ Predicate)]]
   [control
    ["." io (#+ io)]
    [parser
     [cli (#+ program:)]]]
   [data
    ["." name]
    [text
     ["%" format (#+ format)]]]
   ["." math]
   ["_" test (#+ Test)]
   [math
    ["." random (#+ Random) ("#\." functor)]
    [number
     ["." i64]
     ["n" nat]
     ["i" int]
     ["r" rev]
     ["f" frac]]]]
  ## TODO: Must have 100% coverage on tests.
  ["." / #_
   ["#." abstract]
   ["#." control]
   ["#." data]
   ["#." locale]
   ["#." macro]
   ["#." math]
   ["#." meta]
   ["#." time]
   ## ["#." tool]
   ["#." type]
   ["#." world]
   ["#." host]
   ["#." extension]
   ["#." target #_
    ["#/." jvm]]])

## TODO: Get rid of this ASAP
(template: (!bundle body)
  (: Test
     (do random.monad
       [_ (wrap [])]
       body)))

(def: identity
  Test
  (do {! random.monad}
    [self (random.unicode 1)]
    ($_ _.and
        (_.test "Every value is identical to itself."
                (is? self self))
        (do !
          [other (random.unicode 1)]
          (_.test "Values created separately can't be identical."
                  (not (is? self other))))
        )))

(def: increment_and_decrement
  Test
  (do random.monad
    [value random.i64]
    ($_ _.and
        (_.test "'inc' and 'dec' are opposites."
                (and (|> value inc dec (n.= value))
                     (|> value dec inc (n.= value))))
        (_.test "'inc' and 'dec' shift the number by 1."
                (and (|> (inc value) (n.- value) (n.= 1))
                     (|> value (n.- (dec value)) (n.= 1)))))))

(def: (check_neighbors has_property? value)
  (All [a] (-> (Predicate (I64 a)) (I64 a) Bit))
  (and (|> value inc has_property?)
       (|> value dec has_property?)))

(def: (even_or_odd rand_gen even? odd?)
  (All [a] (-> (Random (I64 a)) (Predicate (I64 a)) (Predicate (I64 a)) Test))
  (do random.monad
    [value rand_gen]
    ($_ _.and
        (_.test "Every number is either even or odd."
                (if (even? value)
                  (not (odd? value))
                  (odd? value)))
        (_.test "Every odd/even number is surrounded by two of the other kind."
                (if (even? value)
                  (check_neighbors odd? value)
                  (check_neighbors even? value))))))

(type: (Choice a)
  (-> a a a))

(type: (Order a)
  (-> a a Bit))

(type: (Equivalence a)
  (-> a a Bit))

(def: (choice rand_gen = [< choose])
  (All [a] (-> (Random a) (Equivalence a) [(Order a) (Choice a)] Test))
  (do random.monad
    [left rand_gen
     right rand_gen
     #let [choice (choose left right)]]
    ($_ _.and
        (_.test "The choice between 2 values is one of them."
                (or (= left choice)
                    (= right choice)))
        (_.test "The choice between 2 values implies an order relationship between them."
                (if (= left choice)
                  (< right choice)
                  (< left choice))))))

(def: (minimum_and_maximum rand_gen = min' max')
  (All [a] (-> (Random a) (Equivalence a) [(Order a) (Choice a)] [(Order a) (Choice a)] Test))
  ($_ _.and
      (<| (_.context "Minimum.")
          (choice rand_gen = min'))
      (<| (_.context "Maximum.")
          (choice rand_gen = max'))))

(def: (conversion rand_gen forward backward =)
  (All [a b] (-> (Random a) (-> a b) (-> b a) (Equivalence a) Test))
  (do random.monad
    [value rand_gen]
    (_.test "Can convert between types in a lossless way."
            (|> value forward backward (= value)))))

(def: frac_rev
  (Random Rev)
  (let [bits_to_ignore 11]
    (\ random.functor map (i64.left_shift bits_to_ignore) random.rev)))

(def: prelude_macros
  Test
  ($_ _.and
      (do random.monad
        [factor (random\map (|>> (n.% 10) (n.max 1)) random.nat)
         iterations (random\map (n.% 10) random.nat)
         #let [expected (n.* factor iterations)]]
        (_.test "Can write loops."
                (n.= expected
                     (loop [counter 0
                            value 0]
                       (if (n.< iterations counter)
                         (recur (inc counter) (n.+ factor value))
                         value)))))

      (do random.monad
        [first random.nat
         second random.nat
         third random.nat]
        (_.test "Can create lists easily through macros."
                (and (case (list first second third)
                       (#.Cons first' (#.Cons second' (#.Cons third' #.Nil)))
                       (and (n.= first first')
                            (n.= second second')
                            (n.= third third'))

                       _
                       false)
                     (case (list& first (list second third))
                       (#.Cons first' (#.Cons second' (#.Cons third' #.Nil)))
                       (and (n.= first first')
                            (n.= second second')
                            (n.= third third'))

                       _
                       false)
                     (case (list& first second (list third))
                       (#.Cons first' (#.Cons second' (#.Cons third' #.Nil)))
                       (and (n.= first first')
                            (n.= second second')
                            (n.= third third'))

                       _
                       false))))
      ))

(template: (quadrance cat0 cat1)
  (n.+ (n.* cat0 cat0) (n.* cat1 cat1)))

(def: templates
  Test
  (do random.monad
    [cat0 random.nat
     cat1 random.nat]
    (_.test "Template application is a stand-in for the templated code."
            (n.= (n.+ (n.* cat0 cat0) (n.* cat1 cat1))
                 (quadrance cat0 cat1)))))

(def: cross_platform_support
  Test
  (do random.monad
    [on_default random.nat
     on_fake_host random.nat
     on_valid_host random.nat]
    ($_ _.and
        (_.test "Can provide default in case there is no particular host/platform support."
                (n.= on_default
                     (for {"" on_fake_host}
                          on_default)))
        (_.test "Can pick code depending on the host/platform being targeted."
                (n.= on_valid_host
                     (for {@.old on_valid_host
                           @.jvm on_valid_host
                           @.js on_valid_host}
                          on_default))))))

(def: sub_tests
  Test
  (_.in_parallel (list& /abstract.test
                        /control.test
                        /data.test
                        /locale.test
                        /macro.test
                        /math.test
                        /meta.test
                        /time.test
                        ## /tool.test
                        /type.test
                        /world.test
                        /host.test
                        /target/jvm.test
                        (for {@.old (list)}
                             (list /extension.test))
                        )))

(def: test
  (<| (_.context (name.module (name_of /._)))
      ($_ _.and
          (<| (_.context "Identity.")
              ..identity)
          (<| (_.context "Increment & decrement.")
              ..increment_and_decrement)
          (<| (_.context "Even or odd.")
              ($_ _.and
                  (<| (_.context "Natural numbers.")
                      (..even_or_odd random.nat n.even? n.odd?))
                  (<| (_.context "Integers.")
                      (..even_or_odd random.int i.even? i.odd?))))
          (<| (_.context "Minimum and maximum.")
              (`` ($_ _.and
                      (~~ (template [<=> <lt> <min> <gt> <max> <gen> <context>]
                            [(<| (_.context <context>)
                                 (..minimum_and_maximum <gen> <=> [<lt> <min>] [<gt> <max>]))]

                            [i.= i.< i.min i.> i.max random.int       "Integers."]
                            [n.= n.< n.min n.> n.max random.nat       "Natural numbers."]
                            [r.= r.< r.min r.> r.max random.rev       "Revolutions."]
                            [f.= f.< f.min f.> f.max random.safe_frac "Fractions."]
                            )))))
          (<| (_.context "Conversion.")
              (`` ($_ _.and
                      (~~ (template [<=> <forward> <backward> <gen>]
                            [(<| (_.context (format (%.name (name_of <forward>))
                                                    " " (%.name (name_of <backward>))))
                                 (..conversion <gen> <forward> <backward> <=>))]

                            [i.= .nat   .int   (random\map (i.% +1,000,000) random.int)]
                            [n.= .int   .nat   (random\map (n.%  1,000,000) random.nat)]
                            [i.= i.frac f.int  (random\map (i.% +1,000,000) random.int)]
                            [f.= f.int  i.frac (random\map (|>> (i.% +1,000,000) i.frac) random.int)]
                            [r.= r.frac f.rev  frac_rev]
                            )))))
          (<| (_.context "Prelude macros.")
              ..prelude_macros)
          (<| (_.context "Templates.")
              ..templates)
          (<| (_.context "Cross-platform support.")
              ..cross_platform_support)

          ..sub_tests
          )))

(program: args
  (<| io
      _.run!
      (_.times 100)
      ..test))
