(.with_expansions [<target>' (.for ["{old}" (.as_is ["[1]/[0]" jvm])
                                    "JVM" (.as_is ["[1]/[0]" jvm])]
                                   (.as_is))
                   <target> <target>']
  (.module:
    [library
     ["/" lux "*"
      [program {"+" [program:]}]
      ["_" test {"+" [Test]}]
      ["@" target]
      [abstract
       [monad {"+" [do]}]]
      [control
       ["[0]" io]
       ["[0]" maybe ("[1]#[0]" functor)]
       [concurrency
        ["[0]" atom {"+" [Atom]}]]
       [parser
        ["<[0]>" code]]]
      [data
       ["[0]" product]
       ["[0]" bit ("[1]#[0]" equivalence)]
       ["[0]" text ("[1]#[0]" equivalence)
        ["%" format {"+" [format]}]]
       [collection
        ["[0]" list ("[1]#[0]" functor)]
        ["[0]" set {"+" [Set]} ("[1]#[0]" equivalence)]
        [dictionary
         ["[0]" plist]]]]
      ["[0]" macro
       [syntax {"+" [syntax:]}]
       ["[0]" code ("[1]#[0]" equivalence)]
       ["[0]" template]]
      ["[0]" math
       ["[0]" random ("[1]#[0]" functor)]
       [number
        [i8 {"+" []}]
        [i16 {"+" []}]
        ["n" nat]
        ["i" int]
        ["r" rev]
        ["f" frac]
        ["[0]" i64]]]
      ["[0]" meta
       ["[0]" location ("[1]#[0]" equivalence)]]]]
    ... TODO: Must have 100% coverage on tests.
    ["[0]" / "_"
     ["[1][0]" abstract]
     ["[1][0]" control]
     ["[1][0]" data]
     ["[1][0]" debug]
     ["[1][0]" documentation]
     ["[1][0]" locale]
     ["[1][0]" macro
      ["[1]/[0]" code]]
     ["[1][0]" math]
     ["[1][0]" meta]
     ["[1][0]" program]
     ["[1][0]" static]
     ["[1][0]" target]
     ["[1][0]" test]
     ["[1][0]" time]
     ... ["[1][0]" tool] ... TODO: Update & expand tests for this
     ["[1][0]" type]
     ["[1][0]" world]
     ["[1][0]" ffi]
     ["[1][0]" extension]
     ["[1][0]" target "_"
      <target>]]))

... TODO: Get rid of this ASAP
(template: (!bundle body)
  [(: Test
      (do random.monad
        [_ (in [])]
        body))])

(def: sub_tests
  Test
  (with_expansions [... TODO: Update & expand tests for this
                    <target> (for [@.jvm (~~ (as_is /target/jvm.test))
                                   @.old (~~ (as_is /target/jvm.test))]
                                  (~~ (as_is)))
                    <extension> (for [@.old (~~ (as_is))]
                                     (~~ (as_is /extension.test)))]
    (`` (_.in_parallel (list /abstract.test
                             /control.test
                             /data.test
                             /debug.test
                             /documentation.test
                             /locale.test
                             /macro.test
                             /math.test
                             /meta.test
                             /program.test
                             /static.test
                             /target.test
                             /test.test
                             /time.test
                             ... /tool.test
                             /type.test
                             /world.test
                             /ffi.test
                             <target>
                             <extension>
                             )))))

(def: for_bit
  Test
  (do random.monad
    [expected random.nat
     dummy random.nat]
    (_.for [/.Bit /.if]
           ($_ _.and
               (_.cover [/.false]
                        (n.= expected
                             (/.if /.false
                               dummy
                               expected)))
               (_.cover [/.true]
                        (n.= expected
                             (/.if /.true
                               expected
                               dummy)))
               (_.cover [/.or]
                        (and (not (/.or /.false /.false))
                             (/.or /.false /.true)
                             (/.or /.true /.false)
                             (/.or /.true /.true)))
               (_.cover [/.and]
                        (and (not (/.and /.false /.false))
                             (not (/.and /.false /.true))
                             (not (/.and /.true /.false))
                             (/.and /.true /.true)))
               (_.cover [/.not]
                        (and (bit#= /.true (/.not /.false))
                             (bit#= /.false (/.not /.true))))
               (_.cover [/.cond]
                        (and (n.= expected
                                  (/.cond /.true
                                          expected

                                          ... else
                                          dummy))
                             (n.= expected
                                  (/.cond /.false
                                          dummy

                                          ... else
                                          expected))
                             (n.= expected
                                  (/.cond /.true
                                          expected

                                          /.false
                                          dummy

                                          ... else
                                          dummy))
                             (n.= expected
                                  (/.cond /.false
                                          dummy

                                          /.true
                                          expected

                                          ... else
                                          dummy))))
               ))))

(def: for_try
  Test
  (do random.monad
    [expected_error (random.ascii/lower 5)
     expected random.nat]
    ($_ _.and
        (_.cover [/.try]
                 (case (/.try expected)
                   {.#Left _}
                   false
                   
                   {.#Right actual}
                   (n.= expected actual)))
        (_.cover [/.undefined]
                 (case (/.try (/.undefined))
                   {.#Left _}
                   true
                   
                   {.#Right _}
                   false))
        (_.cover [/.panic!]
                 (case (/.try (/.panic! expected_error))
                   {.#Left actual_error}
                   (text.contains? expected_error actual_error)
                   
                   {.#Right _}
                   false))
        )))

(def: for_list
  Test
  (do random.monad
    [e/0 random.nat
     e/1 random.nat
     e/2 random.nat
     e/3 random.nat]
    ($_ _.and
        (_.cover [/.list]
                 (case (/.list e/0 e/1)
                   (^ (/.list a/0 a/1))
                   (and (n.= e/0 a/0)
                        (n.= e/1 a/1))

                   _
                   false))
        (_.cover [/.list&]
                 (case (/.list& e/0 e/1 (/.list e/2 e/3))
                   (^ (/.list& a/0 a/1 (/.list a/2 a/3)))
                   (and (n.= e/0 a/0)
                        (n.= e/1 a/1)
                        (n.= e/2 a/2)
                        (n.= e/3 a/3))

                   _
                   false))
        )))

(type: (Returner a)
  (/.Interface
   (: (-> Any a)
      return)))

(/.implementation: (global_returner value)
  (All (_ a) (-> a (Returner a)))

  (def: (return _)
    value))

(def: static_return 123)

(/.open: "global#[0]" (..global_returner ..static_return))

(def: for_interface
  Test
  (do random.monad
    [expected random.nat
     .let [local_returner (: (Returner Nat)
                             (/.implementation
                              (def: (return _)
                                expected)))]]
    (_.for [/.Interface]
           ($_ _.and
               (_.cover [/.implementation:]
                        (n.= expected (# (global_returner expected) return [])))
               (_.cover [/.implementation]
                        (n.= expected (# local_returner return [])))
               (_.cover [/.open:]
                        (n.= static_return (global#return [])))
               (_.cover [/.^open]
                        (let [(/.^open "local#[0]") local_returner]
                          (n.= expected (local#return []))))
               (_.cover [/.#]
                        (n.= expected (/.# local_returner return [])))
               ))))

(def: for_module
  Test
  ($_ _.and
      (let [[module short] (/.name_of .example)]
        (_.cover [/.name_of /.prelude_module]
                 (and (text#= /.prelude_module module)
                      (text#= short "example"))))
      (let [[module short] (/.name_of ..example)]
        (_.cover [/.module_separator]
                 (and (text.contains? /.module_separator module)
                      (not (text.contains? /.module_separator short)))))
      ))

(def: for_pipe
  Test
  (do random.monad
    [start random.nat
     factor random.nat
     .let [expected (n.* factor (++ start))]]
    ($_ _.and
        (_.cover [/.|>]
                 (n.= expected
                      (/.|> start ++ (n.* factor))))
        (_.cover [/.|>>]
                 (n.= expected
                      ((/.|>> ++ (n.* factor)) start)))
        (_.cover [/.<|]
                 (n.= expected
                      (/.<| (n.* factor) ++ start)))
        (_.cover [/.<<|]
                 (n.= expected
                      ((/.<<| (n.* factor) ++) start)))
        )))

(def: example_identifier "YOLO")
(def: i8 8)

(def: current_module
  Text
  (let [[module _] (name_of .._)]
    module))

(def: for_code/'
  Test
  (do random.monad
    [example_nat random.nat]
    (_.cover [/.']
             (and (code#= (code.nat 0) (/.' 0))
                  (code#= (code.int -1) (/.' -1))
                  (code#= (code.rev .2) (/.' .2))
                  (code#= (code.frac +3.4) (/.' +3.4))
                  (code#= (code.text "5") (/.' "5"))
                  (code#= (code.identifier ["" "example_identifier"])
                          (/.' example_identifier))
                  (code#= (code.identifier [/.prelude_module "example_identifier"])
                          (/.' .example_identifier))
                  (code#= (code.identifier [..current_module "example_identifier"])
                          (/.' ..example_identifier))
                  (code#= (code.form (list (code.nat 6) (code.int +7) (code.rev .8)))
                          (/.' (6 +7 .8)))
                  (code#= (code.variant (list (code.frac +9.0)
                                              (code.text "9")
                                              (code.identifier ["" "i8"])))
                          (/.' {+9.0 "9" i8}))
                  (code#= (code.tuple (list (code.frac +9.0)
                                            (code.text "9")
                                            (code.identifier ["" "i8"])))
                          (/.' [+9.0 "9" i8]))
                  (not (code#= (code.nat example_nat)
                               (/.' (~ (code.nat example_nat)))))
                  ))))

(def: for_code/`
  Test
  (do random.monad
    [example_nat random.nat]
    (_.cover [/.`]
             (and (code#= (code.nat 0) (/.` 0))
                  (code#= (code.int -1) (/.` -1))
                  (code#= (code.rev .2) (/.` .2))
                  (code#= (code.frac +3.4) (/.` +3.4))
                  (code#= (code.text "5") (/.` "5"))
                  (code#= (code.identifier [..current_module "example_identifier"])
                          (/.` example_identifier))
                  (code#= (code.identifier [/.prelude_module "example_identifier"])
                          (/.` .example_identifier))
                  (code#= (code.identifier [..current_module "example_identifier"])
                          (/.` ..example_identifier))
                  (code#= (code.form (list (code.nat 6) (code.int +7) (code.rev .8)))
                          (/.` (6 +7 .8)))
                  (code#= (code.variant (list (code.frac +9.0)
                                              (code.text "9")
                                              (code.identifier [..current_module "i8"])))
                          (/.` {+9.0 "9" i8}))
                  (code#= (code.tuple (list (code.frac +9.0)
                                            (code.text "9")
                                            (code.identifier [..current_module "i8"])))
                          (/.` [+9.0 "9" i8]))
                  (code#= (code.nat example_nat)
                          (/.` (~ (code.nat example_nat))))))))

(def: for_code/`'
  Test
  (do random.monad
    [example_nat random.nat]
    (_.cover [/.`']
             (and (code#= (code.nat 0) (/.`' 0))
                  (code#= (code.int -1) (/.`' -1))
                  (code#= (code.rev .2) (/.`' .2))
                  (code#= (code.frac +3.4) (/.`' +3.4))
                  (code#= (code.text "5") (/.`' "5"))
                  (code#= (code.identifier ["" "example_identifier"])
                          (/.`' example_identifier))
                  (code#= (code.identifier [/.prelude_module "example_identifier"])
                          (/.`' .example_identifier))
                  (code#= (code.identifier [..current_module "example_identifier"])
                          (/.`' ..example_identifier))
                  (code#= (code.form (list (code.nat 6) (code.int +7) (code.rev .8)))
                          (/.`' (6 +7 .8)))
                  (code#= (code.variant (list (code.frac +9.0)
                                              (code.text "9")
                                              (code.identifier ["" "i8"])))
                          (/.`' {+9.0 "9" i8}))
                  (code#= (code.tuple (list (code.frac +9.0)
                                            (code.text "9")
                                            (code.identifier ["" "i8"])))
                          (/.`' [+9.0 "9" i8]))
                  (code#= (code.nat example_nat)
                          (/.`' (~ (code.nat example_nat))))))))

(def: for_code
  Test
  (do random.monad
    [example_nat random.nat
     example /macro/code.random]
    ($_ _.and
        (_.for [/.Code /.Code']
               ($_ _.and
                   ..for_code/'
                   ..for_code/`
                   ..for_code/`'
                   ))
        (_.cover [/.Ann]
                 (|> example
                     (value@ /.#meta)
                     (location#= location.dummy)))
        )))

(/.macro: (identity_macro tokens)
  (# meta.monad in tokens))

(def: crosshair
  "This is an arbitrary text whose only purpose is to be found, somewhere, in the source-code.")

(/.macro: (found_crosshair? tokens lux)
  (let [[_ _ source_code] (value@ .#source lux)]
    {.#Right [lux (list (code.bit (text.contains? ..crosshair source_code)))]}))

(def: for_macro
  Test
  (let [macro (: /.Macro'
                 (function (_ tokens lux)
                   {.#Right [lux (list)]}))]
    (do random.monad
      [expected random.nat]
      (with_expansions [<found_crosshair?> (for [@.old (~~ (as_is))]
                                                (_.cover [/.Source]
                                                         (..found_crosshair?)))]
        (`` ($_ _.and
                (_.cover [/.Macro']
                         (|> macro
                             (: /.Macro')
                             (same? macro)))
                (_.cover [/.Macro]
                         (|> macro
                             "lux macro"
                             (: /.Macro)
                             (: Any)
                             (same? (: Any macro))))
                (_.cover [/.macro:]
                         (same? expected (..identity_macro expected)))
                <found_crosshair?>
                ))))))

(/.type: for_type/variant
  (Variant
   {#Case/0}
   {#Case/1 Nat}
   {#Case/2 Int Text}))

(/.type: for_type/record
  (Record
   [#slot/0 Bit
    #slot/1 Rev]))

(/.type: (for_type/all parameter)
  [parameter parameter])

(def: for_type
  Test
  (do [! random.monad]
    [expected random.nat

     expected_left random.nat
     expected_right random.nat

     .let [existential_type (# ! each (|>> {.#Ex}) random.nat)]
     expected/0 existential_type
     expected/1 existential_type]
    (<| (_.for [/.Type])
        ($_ _.and
            (_.cover [/.:]
                     (|> expected
                         (/.: Any)
                         (same? (/.: Any expected))))
            (_.cover [/.:as]
                     (|> expected
                         (/.: Any)
                         (/.:as /.Nat)
                         (same? expected)))
            (_.cover [/.:expected]
                     (|> expected
                         (/.: Any)
                         /.:expected
                         (/.: /.Nat)
                         (same? expected)))
            (_.cover [/.:let]
                     (let [[actual_left actual_right]
                           (: (/.:let [side /.Nat]
                                [side side])
                              [expected_left expected_right])]
                       (and (same? expected_left actual_left)
                            (same? expected_right actual_right))))
            (_.cover [/.:of]
                     (same? /.Nat (/.:of expected)))
            (_.cover [/.primitive]
                     (case (/.primitive "foo" [expected/0 expected/1])
                       (^ {.#Primitive "foo" (list actual/0 actual/1)})
                       (and (same? expected/0 actual/0)
                            (same? expected/1 actual/1))

                       _
                       false))
            (_.cover [/.type]
                     (and (case (/.type [expected/0 expected/1])
                            {.#Product actual/0 actual/1}
                            (and (same? expected/0 actual/0)
                                 (same? expected/1 actual/1))

                            _
                            false)
                          (case (/.type (/.Or expected/0 expected/1))
                            {.#Sum actual/0 actual/1}
                            (and (same? expected/0 actual/0)
                                 (same? expected/1 actual/1))

                            _
                            false)
                          (case (/.type (-> expected/0 expected/1))
                            {.#Function actual/0 actual/1}
                            (and (same? expected/0 actual/0)
                                 (same? expected/1 actual/1))

                            _
                            false)
                          (case (/.type (expected/0 expected/1))
                            {.#Apply actual/1 actual/0}
                            (and (same? expected/0 actual/0)
                                 (same? expected/1 actual/1))

                            _
                            false)))
            (_.cover [/.type:]
                     (exec
                       (: /.Type ..for_type/variant)
                       (: /.Type ..for_type/record)
                       (: /.Type ..for_type/all)
                       true))
            (_.cover [/.Variant]
                     (exec
                       (: for_type/variant
                          {#Case/1 expected_left})
                       true))
            (_.cover [/.Record]
                     (exec
                       (: for_type/record
                          [#slot/0 (n.= expected_left expected_right)
                           #slot/1 (.rev expected_right)])
                       true))
            ))))

(def: for_i64
  Test
  (do random.monad
    [expected random.i64]
    ($_ _.and
        (_.cover [/.i64]
                 (same? (: Any expected)
                        (: Any (/.i64 expected))))
        (_.cover [/.nat]
                 (same? (: Any expected)
                        (: Any (/.nat expected))))
        (_.cover [/.int]
                 (same? (: Any expected)
                        (: Any (/.int expected))))
        (_.cover [/.rev]
                 (same? (: Any expected)
                        (: Any (/.rev expected))))
        (_.cover [/.++]
                 (n.= 1 (n.- expected
                             (/.++ expected))))
        (_.cover [/.--]
                 (n.= 1 (n.- (/.-- expected)
                             expected)))
        )))

(def: for_function
  Test
  (do random.monad
    [expected_left random.nat
     expected_right random.nat]
    (_.cover [/.-> /.function]
             (and (let [actual (: (/.-> Nat Nat Nat)
                                  (/.function (_ actual_left actual_right)
                                    (n.* (++ actual_left) (-- actual_right))))]
                    (n.= (n.* (++ expected_left) (-- expected_right))
                         (actual expected_left expected_right)))
                  (let [actual (: (/.-> [Nat Nat] Nat)
                                  (/.function (_ [actual_left actual_right])
                                    (n.* (++ actual_left) (-- actual_right))))]
                    (n.= (n.* (++ expected_left) (-- expected_right))
                         (actual [expected_left expected_right])))))))

(/.template: (!n/+ <left> <right>)
  [(n.+ <left> <right>)])

(def: for_template
  Test
  (`` ($_ _.and
          (_.cover [/.template]
                   (let [bits (list (~~ (/.template [_]
                                          [true]

                                          [0] [1] [2]
                                          )))]
                     (and (n.= 3 (list.size bits))
                          (list.every? (bit#= true) bits))))
          (do random.monad
            [left random.nat
             right random.nat]
            (_.cover [/.template:]
                     (n.= (n.+ left right)
                          (!n/+ left right))))
          (do [! random.monad]
            [sample (# ! each (n.% 5) random.nat)]
            (_.cover [/.^template]
                     (case sample
                       (/.^template [<case>]
                         [<case> true])
                       ([0] [1] [2] [3] [4])

                       _
                       false)))
          )))

(def: option/0 "0")
(def: option/1 "1")
(def: static_char "@")

(def: for_static
  Test
  (do random.monad
    [sample (random.either (in option/0)
                           (in option/1))]
    ($_ _.and
        (_.cover [/.static]
                 (case sample
                   (^ (/.static option/0)) true
                   (^ (/.static option/1)) true
                   _ false))
        (_.cover [/.char]
                 (|> (`` (/.char (~~ (/.static static_char))))
                     text.of_char
                     (text#= static_char)))
        )))

(type: Small
  (Record
   [#small_left Nat
    #small_right Text]))

(type: Big
  (Record
   [#big_left Nat
    #big_right Small]))

(def: for_slot
  Test
  (do random.monad
    [start/s random.nat
     start/b random.nat
     shift/s random.nat
     shift/b random.nat
     text (random.ascii/lower 1)
     .let [expected/s (n.+ shift/s start/s)
           expected/b (n.+ shift/b start/b)

           sample [#big_left start/b
                   #big_right [#small_left start/s
                               #small_right text]]]]
    ($_ _.and
        (_.cover [/.value@]
                 (and (and (|> sample
                               (/.value@ #big_left)
                               (same? start/b))
                           (|> sample
                               ((/.value@ #big_left))
                               (same? start/b)))
                      (and (|> sample
                               (/.value@ [#big_right #small_left])
                               (same? start/s))
                           (|> sample
                               ((/.value@ [#big_right #small_left]))
                               (same? start/s)))))
        (_.cover [/.with@]
                 (and (and (|> sample
                               (/.with@ #big_left shift/b)
                               (/.value@ #big_left)
                               (same? shift/b))
                           (|> sample
                               ((/.with@ #big_left shift/b))
                               (/.value@ #big_left)
                               (same? shift/b))
                           (|> sample
                               ((/.with@ #big_left) shift/b)
                               (/.value@ #big_left)
                               (same? shift/b)))
                      (and (|> sample
                               (/.with@ [#big_right #small_left] shift/s)
                               (/.value@ [#big_right #small_left])
                               (same? shift/s))
                           (|> sample
                               ((/.with@ [#big_right #small_left] shift/s))
                               (/.value@ [#big_right #small_left])
                               (same? shift/s))
                           (|> sample
                               ((/.with@ [#big_right #small_left]) shift/s)
                               (/.value@ [#big_right #small_left])
                               (same? shift/s)))))
        (_.cover [/.revised@]
                 (and (and (|> sample
                               (/.revised@ #big_left (n.+ shift/b))
                               (/.value@ #big_left)
                               (n.= expected/b))
                           (|> sample
                               ((/.revised@ #big_left (n.+ shift/b)))
                               (/.value@ #big_left)
                               (n.= expected/b))
                           (|> sample
                               ((: (-> (-> Nat Nat) (-> Big Big))
                                   (/.revised@ #big_left))
                                (n.+ shift/b))
                               (/.value@ #big_left)
                               (n.= expected/b)))
                      (and (|> sample
                               (/.revised@ [#big_right #small_left] (n.+ shift/s))
                               (/.value@ [#big_right #small_left])
                               (n.= expected/s))
                           (|> sample
                               ((/.revised@ [#big_right #small_left] (n.+ shift/s)))
                               (/.value@ [#big_right #small_left])
                               (n.= expected/s))
                           (|> sample
                               ((: (-> (-> Nat Nat) (-> Big Big))
                                   (/.revised@ [#big_right #small_left]))
                                (n.+ shift/s))
                               (/.value@ [#big_right #small_left])
                               (n.= expected/s)))))
        )))

(def: for_associative
  Test
  (do random.monad
    [left (random.ascii/lower 1)
     mid (random.ascii/lower 1)
     right (random.ascii/lower 1)
     .let [expected (text.interposed "" (list left mid right))]]
    (_.cover [/.$_ /._$]
             (with_expansions [<left_association> (/._$ format
                                                        left
                                                        mid
                                                        right)
                               <right_association> (/.$_ format
                                                         left
                                                         mid
                                                         right)]
               (and (text#= <left_association>
                            <right_association>)
                    (not (code#= (' <left_association>)
                                 (' <right_association>))))))))

(def: for_expansion
  Test
  (do random.monad
    [left random.nat
     right random.nat
     dummy random.nat
     .let [expected (n.+ left right)]]
    ($_ _.and
        (_.cover [/.as_is]
                 (`` (and (~~ (as_is true
                                     true
                                     true)))))
        (_.cover [/.with_expansions]
                 (/.with_expansions [<operands> (as_is left right)]
                   (n.= expected
                        (n.+ <operands>))))
        (_.cover [/.comment]
                 (/.with_expansions [<dummy> (/.comment dummy)
                                     <operands> (as_is left right)]
                   (n.= expected
                        ($_ n.+ <operands> <dummy>))))
        (_.cover [/.``]
                 (n.= expected
                      (/.`` ($_ n.+
                                (~~ (as_is left right))
                                (~~ (/.comment dummy))))))
        (_.cover [/.for]
                 (and (n.= expected
                           (/.for ["fake host" dummy]
                                  expected))
                      (n.= expected
                           (/.for [@.old expected
                                   @.jvm expected
                                   @.js expected
                                   @.python expected
                                   @.lua expected
                                   @.ruby expected
                                   @.php expected]
                                  dummy))))
        )))

(def: for_value
  Test
  (do random.monad
    [left random.nat
     right (random.ascii/lower 1)

     item/0 random.nat
     item/1 random.nat
     item/2 random.nat]
    ($_ _.and
        (_.cover [/.Either]
                 (and (exec
                        (: (/.Either Nat Text)
                           {.#Left left})
                        true)
                      (exec
                        (: (/.Either Nat Text)
                           {.#Right right})
                        true)))
        (_.cover [/.Any]
                 (and (exec
                        (: /.Any
                           left)
                        true)
                      (exec
                        (: /.Any
                           right)
                        true)))
        (_.cover [/.Nothing]
                 (and (exec
                        (: (-> /.Any /.Nothing)
                           (function (_ _)
                             (undefined)))
                        true)
                      (exec
                        (: (-> /.Any /.Int)
                           (function (_ _)
                             (: /.Int (undefined))))
                        true)))
        (_.for [/.__adjusted_quantified_type__]
               ($_ _.and
                   (_.cover [/.All]
                            (let [identity (: (/.All (_ a) (-> a a))
                                              (|>>))]
                              (and (exec
                                     (: Nat
                                        (identity left))
                                     true)
                                   (exec
                                     (: Text
                                        (identity right))
                                     true))))
                   (_.cover [/.Ex]
                            (let [hide (: (/.Ex (_ a) (-> Nat a))
                                          (|>>))]
                              (exec
                                (: /.Any
                                   (hide left))
                                true)))))
        (_.cover [/.same?]
                 (let [not_left (|> left ++ --)]
                   (and (/.same? left left)
                        (and (n.= not_left left)
                             (not (/.same? not_left left))))))
        (_.cover [/.Rec]
                 (let [list (: (/.Rec NList
                                 (Maybe [Nat NList]))
                               {.#Some [item/0
                                        {.#Some [item/1
                                                 {.#Some [item/2
                                                          {.#None}]}]}]})]
                   (case list
                     {.#Some [actual/0 {.#Some [actual/1 {.#Some [actual/2 {.#None}]}]}]}
                     (and (same? item/0 actual/0)
                          (same? item/1 actual/1)
                          (same? item/2 actual/2))

                     _
                     false)))
        )))

(type: (Pair l r)
  (Record
   [#left l
    #right r]))

(template: (!pair <left> <right>)
  [[#left <left>
    #right <right>]])

(def: for_case
  Test
  (do [! random.monad]
    [expected_nat (# ! each (n.% 1) random.nat)
     expected_int (# ! each (i.% +1) random.int)
     expected_rev (random.either (in .5)
                                 (in .25))
     expected_frac (random.either (in +0.5)
                                  (in +1.25))
     expected_text (random.either (in "+0.5")
                                  (in "+1.25"))]
    ($_ _.and
        (_.cover [/.case]
                 (and (/.case expected_nat
                        0 true
                        _ false)
                      (/.case expected_int
                        +0 true
                        _ false)
                      (/.case expected_rev
                        .5 true
                        .25 true
                        _ false)
                      (/.case expected_frac
                        +0.5 true
                        +1.25 true
                        _ false)
                      (/.case expected_text
                        "+0.5" true
                        "+1.25" true
                        _ false)
                      (/.case [expected_nat expected_int]
                        [0 +0] true
                        _ false)
                      (/.case [#left expected_nat #right expected_int]
                        [#left 0 #right +0] true
                        _ false)
                      (/.case (: (Either Nat Int) {.#Left expected_nat})
                        {.#Left 0} true
                        _ false)
                      (/.case (: (Either Nat Int) {.#Right expected_int})
                        {.#Right +0} true
                        _ false)
                      ))
        (_.cover [/.^or]
                 (and (/.case expected_rev
                        (/.^or .5 .25) true
                        _ false)
                      (/.case expected_frac
                        (/.^or +0.5 +1.25) true
                        _ false)
                      (/.case expected_text
                        (/.^or "+0.5" "+1.25") true
                        _ false)))
        (_.cover [/.^slots]
                 (/.case [#left expected_nat #right expected_int]
                   (/.^slots [#left #right])
                   (and (/.same? expected_nat #left)
                        (/.same? expected_int #right))))
        (_.cover [/.^]
                 (/.case [#left expected_nat #right expected_int]
                   (/.^ (!pair 0 +0)) true
                   _ false))
        (_.cover [/.^@]
                 (let [expected_pair (: (Pair Nat Int)
                                        [#left expected_nat #right expected_int])]
                   (/.case expected_pair
                     (/.^@ actual_pair (/.^ (!pair actual_left actual_right)))
                     (and (/.same? expected_pair actual_pair)
                          (/.same? expected_nat actual_left)
                          (/.same? expected_int actual_right)))))
        (_.cover [/.^multi]
                 (let [expected_pair (: (Pair Nat Int)
                                        [#left expected_nat #right expected_int])]
                   (and (/.case expected_pair
                          (/.^multi (/.^ (!pair 0 actual_right))
                                    [actual_right
                                     +0])
                          true

                          _
                          false)
                        (/.case expected_pair
                          (/.^multi (/.^ (!pair 0 actual_right))
                                    (i.= +0 actual_right))
                          true

                          _
                          false))))
        (_.cover [/.^|>]
                 (case expected_frac
                   (/.^|> actual_frac [(f.* +2.0) (f.* +2.0)])
                   (f.= (f.* +4.0 expected_frac)
                        actual_frac)))
        (_.cover [/.^code]
                 (case (code.text expected_text)
                   (/.^code "+0.5") true
                   (/.^code "+1.25") true
                   _ false))
        (_.cover [/.let]
                 (and (/.let [actual_nat expected_nat]
                        (/.same? expected_nat actual_nat))
                      (/.let [[actual_left actual_right] [#left expected_nat #right expected_int]]
                        (and (/.same? expected_nat actual_left)
                             (/.same? expected_int actual_right)))))
        )))

(def: for_control_flow
  Test
  ($_ _.and
      (do random.monad
        [factor (random#each (|>> (n.% 10) (n.max 1)) random.nat)
         iterations (random#each (n.% 10) random.nat)
         .let [expected (n.* factor iterations)]]
        (_.cover [/.loop]
                 (n.= expected
                      (/.loop [counter 0
                               value 0]
                        (if (n.< iterations counter)
                          (recur (++ counter) (n.+ factor value))
                          value)))))
      (do random.monad
        [pre random.nat
         post (random.only (|>> (n.= pre) not) random.nat)
         .let [box (atom.atom pre)]]
        (_.cover [/.exec]
                 (and (same? pre (io.run! (atom.read! box)))
                      (/.exec
                        (io.run! (atom.write! post box))
                        (same? post (io.run! (atom.read! box)))))))
      ))

(def: identity/constant
  (All (_ a) (-> a a))
  (function (_ value)
    value))

(def: (identity/function value)
  (All (_ a) (-> a a))
  value)

(def: for_def:
  Test
  (do random.monad
    [expected random.nat]
    (_.cover [/.def:]
             (and (same? expected (identity/constant expected))
                  (same? expected (identity/function expected))))))

(def: possible_targets
  (Set @.Target)
  (<| (set.of_list text.hash)
      (list @.old
            @.js
            @.jvm
            @.lua
            @.python
            @.ruby)))

(syntax: (for_meta|Info [])
  (function (_ lux)
    (let [info (value@ .#info lux)

          conforming_target!
          (set.member? ..possible_targets (value@ .#target info))

          compiling!
          (case (value@ .#mode info)
            {.#Build} true
            _ false)]
      {.#Right [lux (list (code.bit (and conforming_target!
                                         compiling!)))]})))

(syntax: (for_meta|Module_State [])
  (do meta.monad
    [prelude_module (meta.module .prelude_module)]
    (in (list (code.bit (case (value@ .#module_state prelude_module)
                          {.#Active} false
                          _ true))))))

(def: for_meta
  Test
  ($_ _.and
      (_.cover [/.Mode /.Info]
               (for_meta|Info))
      (_.cover [/.Module_State]
               (for_meta|Module_State))
      ))

(def: for_export
  Test
  ($_ _.and
      (_.cover [/.public /.private]
               (and /.public (not /.private)))
      (_.cover [/.global /.local]
               (and (bit#= /.public /.global)
                    (bit#= /.private /.local)))
      ))

(for [@.old (as_is)]
     (as_is (syntax: (for_bindings|test [fn/0 <code>.local_identifier
                                         var/0 <code>.local_identifier
                                         let/0 <code>.local_identifier

                                         fn/1 <code>.local_identifier
                                         var/1 <code>.local_identifier
                                         let/1 <code>.local_identifier

                                         fn/2 <code>.local_identifier
                                         var/2 <code>.local_identifier
                                         let/2 <code>.local_identifier

                                         let/3 <code>.local_identifier])
              (in (list (code.bit (case (value@ .#scopes *lux*)
                                    (^ (list& scope/2 _))
                                    (let [locals/2 (value@ .#locals scope/2)
                                          expected_locals/2 (set.of_list text.hash (list fn/2 var/2 let/2
                                                                                         let/3))
                                          actual_locals/2 (|> locals/2
                                                              (value@ .#mappings)
                                                              (list#each product.left)
                                                              (set.of_list text.hash))
                                          
                                          correct_locals!
                                          (and (n.= 4 (value@ .#counter locals/2))
                                               (set#= expected_locals/2
                                                      actual_locals/2))

                                          captured/2 (value@ .#captured scope/2)

                                          local? (: (-> Ref Bit)
                                                    (function (_ ref)
                                                      (case ref
                                                        {.#Local _} true
                                                        {.#Captured _} false)))
                                          captured? (: (-> Ref Bit)
                                                       (|>> local? not))
                                          binding? (: (-> (-> Ref Bit) Text Bit)
                                                      (function (_ is? name)
                                                        (|> captured/2
                                                            (value@ .#mappings)
                                                            (plist.value name)
                                                            (maybe#each (|>> product.right is?))
                                                            (maybe.else false))))

                                          correct_closure!
                                          (and (n.= 6 (value@ .#counter captured/2))
                                               (binding? local? fn/1)
                                               (binding? local? var/1)
                                               (binding? local? let/1)
                                               (binding? captured? fn/0)
                                               (binding? captured? var/0)
                                               (binding? captured? let/0))]
                                      (and correct_locals!
                                           correct_closure!))
                                    
                                    _
                                    false)))))

            (def: for_bindings
              Test
              ((<| (template.with_locals [fn/0 var/0 let/0
                                          fn/1 var/1 let/1
                                          fn/2 var/2 let/2
                                          let/3])
                   (function (fn/0 var/0)) (let [let/0 123])
                   (function (fn/1 var/1)) (let [let/1 456])
                   (function (fn/2 var/2)) (let [let/2 789])
                   (let [let/3 [fn/0 var/0 let/0
                                fn/1 var/1 let/1
                                fn/2 var/2 let/2]
                         verdict (for_bindings|test fn/0 var/0 let/0
                                                    fn/1 var/1 let/1
                                                    fn/2 var/2 let/2
                                                    let/3)]
                     (_.cover [/.Bindings /.Ref]
                              verdict)))
               0 1 2))))

(def: test
  Test
  (<| (_.covering /._)
      (with_expansions
        [<for_bindings> (for [@.old (~~ (as_is))]
                             (~~ (as_is ..for_bindings)))]
        (`` ($_ _.and
                ..for_bit
                ..for_try
                ..for_list
                ..for_interface
                ..for_module
                ..for_pipe
                ..for_code
                ..for_macro
                ..for_type
                ..for_i64
                ..for_function
                ..for_template
                ..for_static
                ..for_slot
                ..for_associative
                ..for_expansion
                ..for_value
                ..for_case
                ..for_control_flow
                ..for_def:
                ..for_meta
                ..for_export
                <for_bindings>
                
                ..sub_tests
                )))))

(program: args
  (let [times (for [@.old 100
                    @.jvm 100
                    @.js 10
                    @.python 1
                    @.lua 1
                    @.ruby 1]
                   100)]
    (<| io.io
        _.run!
        (_.times times)
        ..test)))
