(.with_expansions [<target>' (.for {"{old}" (.as_is ["#/." jvm])
                                    "JVM" (.as_is ["#/." jvm])}
                                   (.as_is))
                   <target> <target>']
  (.module:
    [library
     ["/" lux #*
      [program (#+ program:)]
      ["_" test (#+ Test)]
      ["@" target]
      ["." meta]
      [abstract
       [monad (#+ do)]]
      [control
       ["." io]
       [concurrency
        ["." atom (#+ Atom)]]]
      [data
       ["." bit ("#\." equivalence)]
       ["." text ("#\." equivalence)
        ["%" format (#+ format)]]
       [collection
        ["." list]
        ["." set (#+ Set)]]]
      ["." macro
       [syntax (#+ syntax:)]
       ["." code ("#\." equivalence)]]
      ["." math
       ["." random ("#\." functor)]
       [number
        [i8 (#+)]
        [i16 (#+)]
        ["n" nat]
        ["i" int]
        ["r" rev]
        ["f" frac]
        ["." i64]]]]]
    ## TODO: Must have 100% coverage on tests.
    ["." / #_
     ["#." abstract]
     ["#." control]
     ["#." data]
     ["#." debug]
     ["#." locale]
     ["#." macro]
     ["#." math]
     ["#." meta]
     ["#." program]
     ["#." target]
     ["#." test]
     ["#." time]
     ## ["#." tool] ## TODO: Update & expand tests for this
     ["#." type]
     ["#." world]
     ["#." ffi]
     ["#." extension]
     ["#." target #_
      <target>]]))

## TODO: Get rid of this ASAP
(template: (!bundle body)
  (: Test
     (do random.monad
       [_ (in [])]
       body)))

(def: sub_tests
  Test
  (with_expansions [## TODO: Update & expand tests for this
                    <target> (for {@.jvm (~~ (as_is /target/jvm.test))
                                   @.old (~~ (as_is /target/jvm.test))}
                                  (~~ (as_is)))
                    <extension> (for {@.old (~~ (as_is))}
                                     (~~ (as_is /extension.test)))]
    (`` (_.in_parallel (list /abstract.test
                             /control.test
                             /data.test
                             /debug.test
                             /locale.test
                             /macro.test
                             /math.test
                             
                             /meta.test
                             /program.test
                             /target.test
                             /test.test

                             /time.test
                             ## /tool.test
                             /type.test
                             /world.test
                             /ffi.test
                             <target>
                             <extension>
                             )))))

(def: for_bit
  Test
  (do random.monad
    [expected random.nat
     dummy random.nat]
    (_.for [/.Bit /.if]
           ($_ _.and
               (_.cover [/.false]
                        (n.= expected
                             (/.if /.false
                               dummy
                               expected)))
               (_.cover [/.true]
                        (n.= expected
                             (/.if /.true
                               expected
                               dummy)))
               (_.cover [/.or]
                        (and (not (/.or /.false /.false))
                             (/.or /.false /.true)
                             (/.or /.true /.false)
                             (/.or /.true /.true)))
               (_.cover [/.and]
                        (and (not (/.and /.false /.false))
                             (not (/.and /.false /.true))
                             (not (/.and /.true /.false))
                             (/.and /.true /.true)))
               (_.cover [/.not]
                        (and (bit\= /.true (/.not /.false))
                             (bit\= /.false (/.not /.true))))
               (_.cover [/.cond]
                        (and (n.= expected
                                  (/.cond /.true
                                          expected

                                          ## else
                                          dummy))
                             (n.= expected
                                  (/.cond /.false
                                          dummy

                                          ## else
                                          expected))
                             (n.= expected
                                  (/.cond /.true
                                          expected

                                          /.false
                                          dummy

                                          ## else
                                          dummy))
                             (n.= expected
                                  (/.cond /.false
                                          dummy

                                          /.true
                                          expected

                                          ## else
                                          dummy))))
               ))))

(def: for_try
  Test
  (do random.monad
    [expected_error (random.ascii/lower 5)
     expected random.nat]
    ($_ _.and
        (_.cover [/.try]
                 (case (/.try expected)
                   (#.Left _)
                   false
                   
                   (#.Right actual)
                   (n.= expected actual)))
        (_.cover [/.undefined]
                 (case (/.try (/.undefined))
                   (#.Left _)
                   true
                   
                   (#.Right _)
                   false))
        (_.cover [/.error!]
                 (case (/.try (/.error! expected_error))
                   (#.Left actual_error)
                   (text.contains? expected_error actual_error)
                   
                   (#.Right _)
                   false))
        )))

(def: for_list
  Test
  (do random.monad
    [e/0 random.nat
     e/1 random.nat
     e/2 random.nat
     e/3 random.nat]
    ($_ _.and
        (_.cover [/.list]
                 (case (/.list e/0 e/1)
                   (^ (/.list a/0 a/1))
                   (and (n.= e/0 a/0)
                        (n.= e/1 a/1))

                   _
                   false))
        (_.cover [/.list&]
                 (case (/.list& e/0 e/1 (/.list e/2 e/3))
                   (^ (/.list& a/0 a/1 (/.list a/2 a/3)))
                   (and (n.= e/0 a/0)
                        (n.= e/1 a/1)
                        (n.= e/2 a/2)
                        (n.= e/3 a/3))

                   _
                   false))
        )))

(/.interface: (Returner a)
  (: (-> Any a)
     return))

(/.implementation: (global_returner value)
  (All [a] (-> a (Returner a)))

  (def: (return _)
    value))

(def: static_return 123)

(/.open: "global\." (..global_returner ..static_return))

(def: for_interface
  Test
  (do random.monad
    [expected random.nat
     #let [local_returner (: (Returner Nat)
                             (/.implementation
                              (def: (return _)
                                expected)))]]
    (_.for [/.interface:]
           ($_ _.and
               (_.cover [/.implementation:]
                        (n.= expected (\ (global_returner expected) return [])))
               (_.cover [/.implementation]
                        (n.= expected (\ local_returner return [])))
               (_.cover [/.open:]
                        (n.= static_return (global\return [])))
               (_.cover [/.^open]
                        (let [(/.^open "local\.") local_returner]
                          (n.= expected (local\return []))))
               (_.cover [/.\]
                        (n.= expected (/.\ local_returner return [])))
               ))))

(def: for_module
  Test
  ($_ _.and
      (let [[module short] (/.name_of .example)]
        (_.cover [/.name_of /.prelude_module]
                 (and (text\= /.prelude_module module)
                      (text\= short "example"))))
      (let [[module short] (/.name_of ..example)]
        (_.cover [/.module_separator]
                 (and (text.contains? /.module_separator module)
                      (not (text.contains? /.module_separator short)))))
      ))

(def: for_pipe
  Test
  (do random.monad
    [start random.nat
     factor random.nat
     #let [expected (n.* factor (inc start))]]
    ($_ _.and
        (_.cover [/.|>]
                 (n.= expected
                      (/.|> start inc (n.* factor))))
        (_.cover [/.|>>]
                 (n.= expected
                      ((/.|>> inc (n.* factor)) start)))
        (_.cover [/.<|]
                 (n.= expected
                      (/.<| (n.* factor) inc start)))
        (_.cover [/.<<|]
                 (n.= expected
                      ((/.<<| (n.* factor) inc) start)))
        )))

(def: example "YOLO")
(def: i8 8)

(def: current_module
  Text
  (let [[module _] (name_of .._)]
    module))

(def: for_code/'
  Test
  (do random.monad
    [example_nat random.nat]
    (_.cover [/.']
             (and (code\= (code.nat 0) (/.' 0))
                  (code\= (code.int -1) (/.' -1))
                  (code\= (code.rev .2) (/.' .2))
                  (code\= (code.frac +3.4) (/.' +3.4))
                  (code\= (code.text "5") (/.' "5"))
                  (code\= (code.identifier ["" "example"])
                          (/.' example))
                  (code\= (code.identifier [/.prelude_module "example"])
                          (/.' .example))
                  (code\= (code.identifier [..current_module "example"])
                          (/.' ..example))
                  (code\= (code.tag ["" "example"])
                          (/.' #example))
                  (code\= (code.tag [/.prelude_module "example"])
                          (/.' #.example))
                  (code\= (code.tag [..current_module "example"])
                          (/.' #..example))
                  (code\= (code.form (list (code.nat 6) (code.int +7) (code.rev .8)))
                          (/.' (6 +7 .8)))
                  (code\= (code.tuple (list (code.frac +9.0)
                                            (code.text "9")
                                            (code.identifier ["" "i8"])))
                          (/.' [+9.0 "9" i8]))
                  (code\= (code.record (list [(code.identifier [/.prelude_module "i7"])
                                              (code.identifier [..current_module "i6"])]))
                          (/.' {.i7 ..i6}))
                  (not (code\= (code.nat example_nat)
                               (/.' (~ (code.nat example_nat)))))
                  ))))

(def: for_code/`
  Test
  (do random.monad
    [example_nat random.nat]
    (_.cover [/.`]
             (and (code\= (code.nat 0) (/.` 0))
                  (code\= (code.int -1) (/.` -1))
                  (code\= (code.rev .2) (/.` .2))
                  (code\= (code.frac +3.4) (/.` +3.4))
                  (code\= (code.text "5") (/.` "5"))
                  (code\= (code.identifier [..current_module "example"])
                          (/.` example))
                  (code\= (code.identifier [/.prelude_module "example"])
                          (/.` .example))
                  (code\= (code.identifier [..current_module "example"])
                          (/.` ..example))
                  (code\= (code.tag [..current_module "example"])
                          (/.` #example))
                  (code\= (code.tag [/.prelude_module "example"])
                          (/.` #.example))
                  (code\= (code.tag [..current_module "example"])
                          (/.` #..example))
                  (code\= (code.form (list (code.nat 6) (code.int +7) (code.rev .8)))
                          (/.` (6 +7 .8)))
                  (code\= (code.tuple (list (code.frac +9.0)
                                            (code.text "9")
                                            (code.identifier [..current_module "i8"])))
                          (/.` [+9.0 "9" i8]))
                  (code\= (code.record (list [(code.identifier [/.prelude_module "i7"])
                                              (code.identifier [..current_module "i6"])]))
                          (/.` {.i7 ..i6}))
                  (code\= (code.nat example_nat)
                          (/.` (~ (code.nat example_nat))))))))

(def: for_code/`'
  Test
  (do random.monad
    [example_nat random.nat]
    (_.cover [/.`']
             (and (code\= (code.nat 0) (/.`' 0))
                  (code\= (code.int -1) (/.`' -1))
                  (code\= (code.rev .2) (/.`' .2))
                  (code\= (code.frac +3.4) (/.`' +3.4))
                  (code\= (code.text "5") (/.`' "5"))
                  (code\= (code.identifier ["" "example"])
                          (/.`' example))
                  (code\= (code.identifier [/.prelude_module "example"])
                          (/.`' .example))
                  (code\= (code.identifier [..current_module "example"])
                          (/.`' ..example))
                  (code\= (code.tag ["" "example"])
                          (/.`' #example))
                  (code\= (code.tag [/.prelude_module "example"])
                          (/.`' #.example))
                  (code\= (code.tag [..current_module "example"])
                          (/.`' #..example))
                  (code\= (code.form (list (code.nat 6) (code.int +7) (code.rev .8)))
                          (/.`' (6 +7 .8)))
                  (code\= (code.tuple (list (code.frac +9.0)
                                            (code.text "9")
                                            (code.identifier ["" "i8"])))
                          (/.`' [+9.0 "9" i8]))
                  (code\= (code.record (list [(code.identifier [/.prelude_module "i7"])
                                              (code.identifier [..current_module "i6"])]))
                          (/.`' {.i7 ..i6}))
                  (code\= (code.nat example_nat)
                          (/.`' (~ (code.nat example_nat))))))))

(def: for_code
  Test
  (do random.monad
    [example_nat random.nat]
    (_.for [/.Code /.Code']
           ($_ _.and
               ..for_code/'
               ..for_code/`
               ..for_code/`'
               ))))

(/.macro: (identity_macro tokens)
  (\ meta.monad in tokens))

(def: crosshair
  "This is an arbitrary text whose only purpose is to be found, somewhere, in the source-code.")

(/.macro: (found_crosshair? tokens lux)
  (let [[_ _ source_code] (get@ #.source lux)]
    (#.Right [lux (list (code.bit (text.contains? ..crosshair source_code)))])))

(def: for_macro
  Test
  (let [macro (: /.Macro'
                 (function (_ tokens lux)
                   (#.Right [lux (list)])))]
    (do random.monad
      [expected random.nat]
      (with_expansions [<found_crosshair?> (for {@.old (~~ (as_is))}
                                                (_.cover [/.Source]
                                                         (..found_crosshair?)))]
        (`` ($_ _.and
                (_.cover [/.Macro']
                         (|> macro
                             (: /.Macro')
                             (is? macro)))
                (_.cover [/.Macro]
                         (|> macro
                             "lux macro"
                             (: /.Macro)
                             (: Any)
                             (is? (: Any macro))))
                (_.cover [/.macro:]
                         (is? expected (..identity_macro expected)))
                <found_crosshair?>
                ))))))

(/.type: for_type/variant
  #Case/0
  (#Case/1 Nat)
  (#Case/2 Int Text))

(/.type: for_type/record
  {#slot/0 Bit
   #slot/1 Rev})

(/.type: (for_type/all parameter)
  [parameter parameter])

(def: for_type
  Test
  (do {! random.monad}
    [expected random.nat

     expected_left random.nat
     expected_right random.nat

     #let [existential_type (\ ! map (|>> #.Ex) random.nat)]
     expected/0 existential_type
     expected/1 existential_type]
    (<| (_.for [/.Type])
        ($_ _.and
            (_.cover [/.:]
                     (|> expected
                         (/.: Any)
                         (is? (/.: Any expected))))
            (_.cover [/.:as]
                     (|> expected
                         (/.: Any)
                         (/.:as /.Nat)
                         (is? expected)))
            (_.cover [/.:assume]
                     (|> expected
                         (/.: Any)
                         /.:assume
                         (/.: /.Nat)
                         (is? expected)))
            (_.cover [/.:let]
                     (let [[actual_left actual_right]
                           (: (/.:let [side /.Nat]
                                [side side])
                              [expected_left expected_right])]
                       (and (is? expected_left actual_left)
                            (is? expected_right actual_right))))
            (_.cover [/.:of]
                     (is? /.Nat (/.:of expected)))
            (_.cover [/.primitive]
                     (case (/.primitive "foo" [expected/0 expected/1])
                       (^ (#.Primitive "foo" (list actual/0 actual/1)))
                       (and (is? expected/0 actual/0)
                            (is? expected/1 actual/1))

                       _
                       false))
            (_.cover [/.type]
                     (and (case (/.type [expected/0 expected/1])
                            (#.Product actual/0 actual/1)
                            (and (is? expected/0 actual/0)
                                 (is? expected/1 actual/1))

                            _
                            false)
                          (case (/.type (/.Or expected/0 expected/1))
                            (#.Sum actual/0 actual/1)
                            (and (is? expected/0 actual/0)
                                 (is? expected/1 actual/1))

                            _
                            false)
                          (case (/.type (-> expected/0 expected/1))
                            (#.Function actual/0 actual/1)
                            (and (is? expected/0 actual/0)
                                 (is? expected/1 actual/1))

                            _
                            false)
                          (case (/.type (expected/0 expected/1))
                            (#.Apply actual/1 actual/0)
                            (and (is? expected/0 actual/0)
                                 (is? expected/1 actual/1))

                            _
                            false)))
            (_.cover [/.type:]
                     (exec
                       (: /.Type ..for_type/variant)
                       (: /.Type ..for_type/record)
                       (: /.Type ..for_type/all)
                       true))
            ))))

(def: for_i64
  Test
  (do random.monad
    [expected random.i64]
    ($_ _.and
        (_.cover [/.i64]
                 (is? (: Any expected)
                      (: Any (/.i64 expected))))
        (_.cover [/.nat]
                 (is? (: Any expected)
                      (: Any (/.nat expected))))
        (_.cover [/.int]
                 (is? (: Any expected)
                      (: Any (/.int expected))))
        (_.cover [/.rev]
                 (is? (: Any expected)
                      (: Any (/.rev expected))))
        (_.cover [/.inc]
                 (n.= 1 (n.- expected
                             (/.inc expected))))
        (_.cover [/.dec]
                 (n.= 1 (n.- (/.dec expected)
                             expected)))
        )))

(def: for_function
  Test
  (do random.monad
    [expected_left random.nat
     expected_right random.nat]
    (_.cover [/.-> /.function]
             (and (let [actual (: (/.-> Nat Nat Nat)
                                  (/.function (_ actual_left actual_right)
                                    (n.* (inc actual_left) (dec actual_right))))]
                    (n.= (n.* (inc expected_left) (dec expected_right))
                         (actual expected_left expected_right)))
                  (let [actual (: (/.-> [Nat Nat] Nat)
                                  (/.function (_ [actual_left actual_right])
                                    (n.* (inc actual_left) (dec actual_right))))]
                    (n.= (n.* (inc expected_left) (dec expected_right))
                         (actual [expected_left expected_right])))))))

(/.template: (!n/+ <left> <right>)
  (n.+ <left> <right>))

(def: for_template
  Test
  (`` ($_ _.and
          (_.cover [/.template]
                   (let [bits (list (~~ (/.template [_]
                                          [true]

                                          [0] [1] [2]
                                          )))]
                     (and (n.= 3 (list.size bits))
                          (list.every? (bit\= true) bits))))
          (do random.monad
            [left random.nat
             right random.nat]
            (_.cover [/.template:]
                     (n.= (n.+ left right)
                          (!n/+ left right))))
          (do {! random.monad}
            [sample (\ ! map (n.% 5) random.nat)]
            (_.cover [/.^template]
                     (case sample
                       (/.^template [<case>]
                         [<case> true])
                       ([0] [1] [2] [3] [4])

                       _
                       false)))
          )))

(def: option/0 "0")
(def: option/1 "1")
(def: static_char "@")

(def: for_static
  Test
  (do random.monad
    [sample (random.either (in option/0)
                           (in option/1))]
    ($_ _.and
        (_.cover [/.static]
                 (case sample
                   (^ (/.static option/0)) true
                   (^ (/.static option/1)) true
                   _ false))
        (_.cover [/.char]
                 (|> (`` (/.char (~~ (/.static static_char))))
                     text.of_char
                     (text\= static_char)))
        )))

(type: Small
  {#small_left Nat
   #small_right Text})

(type: Big
  {#big_left Nat
   #big_right Small})

(def: for_slot
  Test
  (do random.monad
    [start/s random.nat
     start/b random.nat
     shift/s random.nat
     shift/b random.nat
     text (random.ascii/lower 1)
     #let [expected/s (n.+ shift/s start/s)
           expected/b (n.+ shift/b start/b)

           sample {#big_left start/b
                   #big_right {#small_left start/s
                               #small_right text}}]]
    ($_ _.and
        (_.cover [/.get@]
                 (and (and (|> sample
                               (/.get@ #big_left)
                               (is? start/b))
                           (|> sample
                               ((/.get@ #big_left))
                               (is? start/b)))
                      (and (|> sample
                               (/.get@ [#big_right #small_left])
                               (is? start/s))
                           (|> sample
                               ((/.get@ [#big_right #small_left]))
                               (is? start/s)))))
        (_.cover [/.set@]
                 (and (and (|> sample
                               (/.set@ #big_left shift/b)
                               (/.get@ #big_left)
                               (is? shift/b))
                           (|> sample
                               ((/.set@ #big_left shift/b))
                               (/.get@ #big_left)
                               (is? shift/b))
                           (|> sample
                               ((/.set@ #big_left) shift/b)
                               (/.get@ #big_left)
                               (is? shift/b)))
                      (and (|> sample
                               (/.set@ [#big_right #small_left] shift/s)
                               (/.get@ [#big_right #small_left])
                               (is? shift/s))
                           (|> sample
                               ((/.set@ [#big_right #small_left] shift/s))
                               (/.get@ [#big_right #small_left])
                               (is? shift/s))
                           (|> sample
                               ((/.set@ [#big_right #small_left]) shift/s)
                               (/.get@ [#big_right #small_left])
                               (is? shift/s)))))
        (_.cover [/.update@]
                 (and (and (|> sample
                               (/.update@ #big_left (n.+ shift/b))
                               (/.get@ #big_left)
                               (n.= expected/b))
                           (|> sample
                               ((/.update@ #big_left (n.+ shift/b)))
                               (/.get@ #big_left)
                               (n.= expected/b))
                           (|> sample
                               ((: (-> (-> Nat Nat) (-> Big Big))
                                   (/.update@ #big_left))
                                (n.+ shift/b))
                               (/.get@ #big_left)
                               (n.= expected/b)))
                      (and (|> sample
                               (/.update@ [#big_right #small_left] (n.+ shift/s))
                               (/.get@ [#big_right #small_left])
                               (n.= expected/s))
                           (|> sample
                               ((/.update@ [#big_right #small_left] (n.+ shift/s)))
                               (/.get@ [#big_right #small_left])
                               (n.= expected/s))
                           (|> sample
                               ((: (-> (-> Nat Nat) (-> Big Big))
                                   (/.update@ [#big_right #small_left]))
                                (n.+ shift/s))
                               (/.get@ [#big_right #small_left])
                               (n.= expected/s)))))
        )))

(def: for_associative
  Test
  (do random.monad
    [left (random.ascii/lower 1)
     mid (random.ascii/lower 1)
     right (random.ascii/lower 1)
     #let [expected (text.join_with "" (list left mid right))]]
    (_.cover [/.$_ /._$]
             (with_expansions [<left_association> (/._$ format
                                                        left
                                                        mid
                                                        right)
                               <right_association> (/.$_ format
                                                         left
                                                         mid
                                                         right)]
               (and (text\= <left_association>
                            <right_association>)
                    (not (code\= (' <left_association>)
                                 (' <right_association>))))))))

(def: for_expansion
  Test
  (do random.monad
    [left random.nat
     right random.nat
     dummy random.nat
     #let [expected (n.+ left right)]]
    ($_ _.and
        (_.cover [/.as_is]
                 (`` (and (~~ (as_is true
                                     true
                                     true)))))
        (_.cover [/.with_expansions]
                 (/.with_expansions [<operands> (as_is left right)]
                   (n.= expected
                        (n.+ <operands>))))
        (_.cover [/.comment]
                 (/.with_expansions [<dummy> (/.comment dummy)
                                     <operands> (as_is left right)]
                   (n.= expected
                        ($_ n.+ <operands> <dummy>))))
        (_.cover [/.``]
                 (n.= expected
                      (/.`` ($_ n.+
                                (~~ (as_is left right))
                                (~~ (/.comment dummy))))))
        (_.cover [/.for]
                 (and (n.= expected
                           (/.for {"fake host" dummy}
                                  expected))
                      (n.= expected
                           (/.for {@.old expected
                                   @.jvm expected
                                   @.js expected
                                   @.python expected
                                   @.lua expected
                                   @.ruby expected
                                   @.php expected}
                                  dummy))))
        )))

(def: for_value
  Test
  (do random.monad
    [left random.nat
     right (random.ascii/lower 1)

     item/0 random.nat
     item/1 random.nat
     item/2 random.nat]
    ($_ _.and
        (_.cover [/.Either]
                 (and (exec
                        (: (/.Either Nat Text)
                           (#.Left left))
                        true)
                      (exec
                        (: (/.Either Nat Text)
                           (#.Right right))
                        true)))
        (_.cover [/.Any]
                 (and (exec
                        (: /.Any
                           left)
                        true)
                      (exec
                        (: /.Any
                           right)
                        true)))
        (_.cover [/.Nothing]
                 (and (exec
                        (: (-> /.Any /.Nothing)
                           (function (_ _)
                             (undefined)))
                        true)
                      (exec
                        (: (-> /.Any /.Int)
                           (function (_ _)
                             (: /.Int (undefined))))
                        true)))
        (_.cover [/.All]
                 (let [identity (: (/.All [a] (-> a a))
                                   (|>>))]
                   (and (exec
                          (: Nat
                             (identity left))
                          true)
                        (exec
                          (: Text
                             (identity right))
                          true))))
        (_.cover [/.Ex]
                 (let [hide (: (/.Ex [a] (-> Nat a))
                               (|>>))]
                   (exec
                     (: /.Any
                        (hide left))
                     true)))
        (_.cover [/.is?]
                 (let [not_left (|> left inc dec)]
                   (and (/.is? left left)
                        (and (n.= not_left left)
                             (not (/.is? not_left left))))))
        (_.cover [/.Rec]
                 (let [list (: (/.Rec NList
                                 (Maybe [Nat NList]))
                               (#.Some [item/0
                                        (#.Some [item/1
                                                 (#.Some [item/2
                                                          #.None])])]))]
                   (case list
                     (#.Some [actual/0 (#.Some [actual/1 (#.Some [actual/2 #.None])])])
                     (and (is? item/0 actual/0)
                          (is? item/1 actual/1)
                          (is? item/2 actual/2))

                     _
                     false)))
        )))

(type: (Pair l r)
  {#left l
   #right r})

(template: (!pair <left> <right>)
  [{#left <left>
    #right <right>}])

(def: for_case
  Test
  (do {! random.monad}
    [expected_nat (\ ! map (n.% 1) random.nat)
     expected_int (\ ! map (i.% +1) random.int)
     expected_rev (random.either (in .5)
                                 (in .25))
     expected_frac (random.either (in +0.5)
                                  (in +1.25))
     expected_text (random.either (in "+0.5")
                                  (in "+1.25"))]
    ($_ _.and
        (_.cover [/.case]
                 (and (/.case expected_nat
                        0 true
                        _ false)
                      (/.case expected_int
                        +0 true
                        _ false)
                      (/.case expected_rev
                        .5 true
                        .25 true
                        _ false)
                      (/.case expected_frac
                        +0.5 true
                        +1.25 true
                        _ false)
                      (/.case expected_text
                        "+0.5" true
                        "+1.25" true
                        _ false)
                      (/.case [expected_nat expected_int]
                        [0 +0] true
                        _ false)
                      (/.case {#left expected_nat #right expected_int}
                        {#left 0 #right +0} true
                        _ false)
                      (/.case (: (Either Nat Int) (#.Left expected_nat))
                        (#.Left 0) true
                        _ false)
                      (/.case (: (Either Nat Int) (#.Right expected_int))
                        (#.Right +0) true
                        _ false)
                      ))
        (_.cover [/.^or]
                 (and (/.case expected_rev
                        (/.^or .5 .25) true
                        _ false)
                      (/.case expected_frac
                        (/.^or +0.5 +1.25) true
                        _ false)
                      (/.case expected_text
                        (/.^or "+0.5" "+1.25") true
                        _ false)))
        (_.cover [/.^slots]
                 (/.case {#left expected_nat #right expected_int}
                   (/.^slots [#left #right])
                   (and (/.is? expected_nat left)
                        (/.is? expected_int right))))
        (_.cover [/.^]
                 (/.case {#left expected_nat #right expected_int}
                   (/.^ (!pair 0 +0)) true
                   _ false))
        (_.cover [/.^@]
                 (let [expected_pair (: (Pair Nat Int)
                                        {#left expected_nat #right expected_int})]
                   (/.case expected_pair
                     (/.^@ actual_pair (/.^ (!pair actual_left actual_right)))
                     (and (/.is? expected_pair actual_pair)
                          (/.is? expected_nat actual_left)
                          (/.is? expected_int actual_right)))))
        (_.cover [/.^multi]
                 (let [expected_pair (: (Pair Nat Int)
                                        {#left expected_nat #right expected_int})]
                   (and (/.case expected_pair
                          (/.^multi (/.^ (!pair 0 actual_right))
                                    {actual_right +0})
                          true

                          _
                          false)
                        (/.case expected_pair
                          (/.^multi (/.^ (!pair 0 actual_right))
                                    (i.= +0 actual_right))
                          true

                          _
                          false))))
        (_.cover [/.^|>]
                 (case expected_frac
                   (/.^|> actual_frac [(f.* +2.0) (f.* +2.0)])
                   (f.= (f.* +4.0 expected_frac)
                        actual_frac)))
        (_.cover [/.^code]
                 (case (code.text expected_text)
                   (/.^code "+0.5") true
                   (/.^code "+1.25") true
                   _ false))
        (_.cover [/.let]
                 (and (/.let [actual_nat expected_nat]
                        (/.is? expected_nat actual_nat))
                      (/.let [[actual_left actual_right] {#left expected_nat #right expected_int}]
                        (and (/.is? expected_nat actual_left)
                             (/.is? expected_int actual_right)))))
        )))

(def: for_control_flow
  Test
  ($_ _.and
      (do random.monad
        [factor (random\map (|>> (n.% 10) (n.max 1)) random.nat)
         iterations (random\map (n.% 10) random.nat)
         #let [expected (n.* factor iterations)]]
        (_.cover [/.loop]
                 (n.= expected
                      (/.loop [counter 0
                               value 0]
                        (if (n.< iterations counter)
                          (recur (inc counter) (n.+ factor value))
                          value)))))
      (do random.monad
        [pre random.nat
         post (random.only (|>> (n.= pre) not) random.nat)
         #let [box (atom.atom pre)]]
        (_.cover [/.exec]
                 (and (is? pre (io.run (atom.read box)))
                      (/.exec
                        (io.run (atom.write post box))
                        (is? post (io.run (atom.read box)))))))
      ))

(def: identity/constant
  (All [a] (-> a a))
  (function (_ value)
    value))

(def: (identity/function value)
  (All [a] (-> a a))
  value)

(def: for_def:
  Test
  (do random.monad
    [expected random.nat]
    (_.cover [/.def:]
             (and (is? expected (identity/constant expected))
                  (is? expected (identity/function expected))))))

(.refer "library/lux/target" #*)
(.refer "library/lux/macro" #all)
(.refer "library/lux/math/number/nat" #_)
(.refer "library/lux/math/number/int" #nothing)
(.refer "library/lux/math/number/rev" (#+ /4096))
(.refer "library/lux/math/number/frac" (#only positive_infinity))
(.refer "library/lux/math/number/i8" (#- equivalence width i8 i64))
(.refer "library/lux/math/number/i16" (#exclude equivalence width i16 i64))

(def: for_import
  Test
  (let [can_access? (: (All [a] (-> a a Bit))
                       (function (_ global local)
                         (is? global local)))]
    ($_ _.and
        (_.cover [/.refer]
                 (and (can_access? library/lux/target.jvm
                                   jvm)
                      (can_access? library/lux/macro.single_expansion
                                   single_expansion)
                      (can_access? library/lux/math/number/rev./4096
                                   /4096)
                      (can_access? library/lux/math/number/frac.positive_infinity
                                   positive_infinity)
                      (can_access? library/lux/math/number/i8.I8
                                   I8)
                      (can_access? library/lux/math/number/i16.I16
                                   I16)))
        )))

(def: possible_targets
  (Set @.Target)
  (<| (set.of_list text.hash)
      (list @.old
            @.js
            @.jvm
            @.lua
            @.python
            @.ruby)))

(syntax: (for_meta|Info)
  (function (_ lux)
    (let [info (get@ #.info lux)

          conforming_target!
          (set.member? ..possible_targets (get@ #.target info))

          compiling!
          (case (get@ #.mode info)
            #.Build true
            _ false)]
      (#.Right [lux (list (code.bit (and conforming_target!
                                         compiling!)))]))))

(syntax: (for_meta|Module_State)
  (do meta.monad
    [prelude_module (meta.module .prelude_module)]
    (in (list (code.bit (case (get@ #.module_state prelude_module)
                          #.Active false
                          _ true))))))

(def: for_meta
  Test
  ($_ _.and
      (_.cover [/.Mode /.Info]
               (for_meta|Info))
      (_.cover [/.Module_State]
               (for_meta|Module_State))
      ))

(def: test
  Test
  (<| (_.covering /._)
      ($_ _.and
          ..for_bit
          ..for_try
          ..for_list
          ..for_interface
          ..for_module
          ..for_pipe
          ..for_code
          ..for_macro
          ..for_type
          ..for_i64
          ..for_function
          ..for_template
          ..for_static
          ..for_slot
          ..for_associative
          ..for_expansion
          ..for_value
          ..for_case
          ..for_control_flow
          ..for_def:
          ..for_import
          ..for_meta
          
          ..sub_tests
          )))

(program: args
  (let [times (for {@.old 100
                    @.jvm 100
                    @.js 10
                    @.python 1
                    @.lua 1
                    @.ruby 1}
                   100)]
    (<| io.io
        _.run!
        (_.times times)
        ..test)))
