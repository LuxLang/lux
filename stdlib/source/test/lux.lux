... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  ["/" lux (.except)
   [program (.only program)]
   [abstract
    [monad (.only do)]]
   [concurrency
    ["[0]" atom]]
   [control
    ["[0]" io]
    ["[0]" maybe (.use "[1]#[0]" functor)]]
   [data
    ["[0]" product]
    ["[0]" bit]
    ["[0]" text]
    [collection
     ["[0]" set (.only Set)]
     ["[0]" list (.use "[1]#[0]" functor)
      ["[0]" property]]]]
   [math
    ["[0]" random (.use "[1]#[0]" functor)]
    [number
     ["n" natural]
     ["i" integer]]]
   ["[0]" macro (.only)
    ["^" pattern]
    ["[0]" syntax]
    ["[0]" template]
    ["[0]" expansion]]
   ["[0]" meta (.only)
    ["[0]" module]
    ["[0]" static]
    ["[0]" provenance]
    ["[0]" code (.only)
     ["<[1]>" \\projection]]]
   [test
    ["_" property (.only Test)]]]]
 ... TODO: Must have 100% coverage on tests.
 ["[0]" /
  ["[1][0]" abstract]
  ["[1][0]" algorithm]
  ["[1][0]" control]
  ["[1][0]" function]
  ["[1][0]" concurrency
   ["[1]/[0]" actor]
   ["[1]/[0]" agent]
   ["[1]/[0]" atom]
   ["[1]/[0]" frp]
   ["[1]/[0]" thread]
   ["[1]/[0]" future]
   ["[1]/[0]" semaphore]
   ["[1]/[0]" stm]
   ["[1]/[0]" event]
   ["[1]/[0]" csp]
   ["[1]/[0]" incremental]
   ["[1]/[0]" structured]
   ["[1]/[0]" behavioral]]
  ["[1][0]" color
   ["[1]/[0]" rgb]
   ["[1]/[0]" cmyk]
   ["[1]/[0]" hsl]
   ["[1]/[0]" hsb]
   ["[1]/[0]" pigment]
   ["[1]/[0]" named]
   ["[1]/[0]" terminal]
   ["[1]/[0]" scheme]]
  ["[1][0]" data]
  ["[1][0]" debug]
  
  ["[1][0]" documentation]
  ["[1][0]" math]

  ["[1][0]" type]
  ["[1][0]" macro]
  ["[1][0]" meta]
  ["[1][0]" program]
  ["[1][0]" test]

  ["[1][0]" web/permission]
  ["[1][0]" web/html/tag]
  ["[1][0]" web/html/attribute]
  ["[1][0]" web/dom/event]
  ["[1][0]" time]
  ["[1][0]" world]

  ["[1][0]" ffi]

  ["[1][0]" music
   ["[1]/[0]" instrument]
   ["[1]/[0]" percussion]
   ["[1]/[0]" pitch]
   ["[1]/[0]" velocity]
   ["[1]/[0]" interval]
   ["[1]/[0]" scale]
   ["[1]/[0]" mode]
   ["[1]/[0]" chord]
   ["[1]/[0]" note]
   ["[1]/[0]" channel]
   ["[1]/[0]" tempo]
   ["[1]/[0]" balance]
   ["[1]/[0]" panning]
   ["[1]/[0]" accidental]]
  ["[1][0]" finance
   ["[1]/[0]" money]
   ["[1]/[0]" trade
    ["[1]/[0]" volume]
    ["[1]/[0]" session]]
   ["[1]/[0]" market
    ["[1]/[0]" price]
    ["[1]/[0]" ticker]]
   ["[1]/[0]" interest
    ["[1]/[0]" rate]]]
  ["[1][0]" security
   ["[1]/[0]" policy]
   ["[1]/[0]" capability]]])

(the for_bit
  Test
  (do random.monad
    [expected random.natural
     dummy random.natural]
    (_.for [/.Bit /.if]
           (all _.and
                (_.coverage [/.false]
                  (n.= expected
                       (/.if /.false
                         dummy
                         expected)))
                (_.coverage [/.true]
                  (n.= expected
                       (/.if /.true
                         expected
                         dummy)))
                (_.coverage [/.or]
                  (and (not (/.or))
                       (not (/.or /.false /.false))
                       (/.or /.false /.true)
                       (/.or /.true /.false)
                       (/.or /.true /.true)))
                (_.coverage [/.and]
                  (and (/.and)
                       (not (/.and /.false /.false))
                       (not (/.and /.false /.true))
                       (not (/.and /.true /.false))
                       (/.and /.true /.true)))
                (_.coverage [/.not]
                  (and (bit.= /.true (/.not /.false))
                       (bit.= /.false (/.not /.true))))
                ))))

(the for_try
  Test
  (do random.monad
    [expected_error (random.lower_cased 5)
     expected random.natural]
    (all _.and
         (_.coverage [/.try]
           (when (/.try expected)
             {.#Left _}
             false

             {.#Right actual}
             (n.= expected actual)))
         (_.coverage [/.undefined]
           (when (/.try (/.undefined))
             {.#Left _}
             true

             {.#Right _}
             false))
         (_.coverage [/.halt!]
           (when (/.try (/.halt! expected_error))
             {.#Left actual_error}
             (text.contains? expected_error actual_error)

             {.#Right _}
             false))
         )))

(the for_list
  Test
  (do random.monad
    [e/0 random.natural
     e/1 random.natural
     e/2 random.natural
     e/3 random.natural]
    (all _.and
         (_.coverage [/.list]
           (when (/.list e/0 e/1)
             (/.list a/0 a/1)
             (and (n.= e/0 a/0)
                  (n.= e/1 a/1))

             _
             false))
         )))

(every (Returner a)
  (/.Interface
   (is (-> Any a)
       return)))

(the (global_returner value)
  (for_any (_ a) (-> a (Returner a)))
  (/.implementation
   (the (return _)
     value)))

(the static_return 123)

(/.use "global#[0]" (..global_returner ..static_return))

(the for_interface
  Test
  (do random.monad
    [expected random.natural
     .let [local_returner (is (Returner Natural)
                              (/.implementation
                               (the (return _)
                                 expected)))]]
    (_.for [/.Interface]
           (all _.and
                (_.coverage [/.implementation]
                  (n.= expected (by local_returner return [])))
                (_.coverage [/.use]
                  (n.= static_return (global#return [])))
                (_.coverage [/.open]
                  (let [(/.open "local#[0]") local_returner]
                    (n.= expected (local#return []))))
                (_.coverage [/.by]
                  (n.= expected (/.by local_returner return [])))
                ))))

(the for_module
  Test
  (all _.and
       (let [[module proper] (/.name .example)]
         (_.coverage [/.name /.prelude]
           (and (text.= /.prelude module)
                (text.= proper "example"))))
       (let [[module proper] (/.name ..example)]
         (_.coverage [/.module_delimiter]
           (and (text.contains? /.module_delimiter module)
                (not (text.contains? /.module_delimiter proper)))))
       ))

(the for_pipe
  Test
  (do random.monad
    [start random.natural
     factor random.natural
     .let [expected (n.* factor (++ start))]]
    (all _.and
         (_.coverage [/.|>]
           (n.= expected
                (/.|> start ++ (n.* factor))))
         (_.coverage [/.|>>]
           (n.= expected
                ((/.|>> ++ (n.* factor)) start)))
         (_.coverage [/.<|]
           (n.= expected
                (/.<| (n.* factor) ++ start)))
         (_.coverage [/.<<|]
           (n.= expected
                ((/.<<| (n.* factor) ++) start)))
         )))

(the example_name "YOLO")
(the i08 8)

(the current_module
  Text
  (let [[module _] (name .._)]
    module))

(the for_code/'
  Test
  (do random.monad
    [example_natural random.natural]
    (_.coverage [/.' /.quote]
      (and (code.= (code.natural 0) (/.' 0))
           (code.= (code.integer -1) (/.' -1))
           (code.= (code.revolution .2) (/.' .2))
           (code.= (code.decimal +3.4) (/.' +3.4))
           (code.= (code.text "5") (/.' "5"))
           (code.= (code.name ["" "example_name"])
                   (/.' example_name))
           (code.= (code.name [/.prelude "example_name"])
                   (/.' .example_name))
           (code.= (code.name [..current_module "example_name"])
                   (/.' ..example_name))
           (code.= (code.form (list (code.natural 6) (code.integer +7) (code.revolution .8)))
                   (/.' (6 +7 .8)))
           (code.= (code.variant (list (code.decimal +9.0)
                                       (code.text "9")
                                       (code.name ["" "i08"])))
                   (/.' {+9.0 "9" i08}))
           (code.= (code.tuple (list (code.decimal +9.0)
                                     (code.text "9")
                                     (code.name ["" "i08"])))
                   (/.' [+9.0 "9" i08]))
           ))))

(the for_code/`
  Test
  (do random.monad
    [example_natural random.natural]
    (_.coverage [/.` /.complete_quote]
      (and (code.= (code.natural 0) (/.` 0))
           (code.= (code.integer -1) (/.` -1))
           (code.= (code.revolution .2) (/.` .2))
           (code.= (code.decimal +3.4) (/.` +3.4))
           (code.= (code.text "5") (/.` "5"))
           (code.= (code.name [..current_module "example_name"])
                   (/.` example_name))
           (code.= (code.name [/.prelude "example_name"])
                   (/.` .example_name))
           (code.= (code.name [..current_module "example_name"])
                   (/.` ..example_name))
           (code.= (code.form (list (code.natural 6) (code.integer +7) (code.revolution .8)))
                   (/.` (6 +7 .8)))
           (code.= (code.variant (list (code.decimal +9.0)
                                       (code.text "9")
                                       (code.name [..current_module "i08"])))
                   (/.` {+9.0 "9" i08}))
           (code.= (code.tuple (list (code.decimal +9.0)
                                     (code.text "9")
                                     (code.name [..current_module "i08"])))
                   (/.` [+9.0 "9" i08]))
           ))))

(the for_code/`'
  Test
  (do random.monad
    [example_natural random.natural]
    (_.coverage [/.`' /.incomplete_quote]
      (and (code.= (code.natural 0) (/.`' 0))
           (code.= (code.integer -1) (/.`' -1))
           (code.= (code.revolution .2) (/.`' .2))
           (code.= (code.decimal +3.4) (/.`' +3.4))
           (code.= (code.text "5") (/.`' "5"))
           (code.= (code.name ["" "example_name"])
                   (/.`' example_name))
           (code.= (code.name [/.prelude "example_name"])
                   (/.`' .example_name))
           (code.= (code.name [..current_module "example_name"])
                   (/.`' ..example_name))
           (code.= (code.form (list (code.natural 6) (code.integer +7) (code.revolution .8)))
                   (/.`' (6 +7 .8)))
           (code.= (code.variant (list (code.decimal +9.0)
                                       (code.text "9")
                                       (code.name ["" "i08"])))
                   (/.`' {+9.0 "9" i08}))
           (code.= (code.tuple (list (code.decimal +9.0)
                                     (code.text "9")
                                     (code.name ["" "i08"])))
                   (/.`' [+9.0 "9" i08]))
           ))))

(the for_code
  Test
  (do [! random.monad]
    [example (by ! each code.natural random.natural)
     example_bit random.bit
     example_natural random.natural
     example_integer random.integer]
    (all _.and
         (_.for [/.Code /.Code'
                 /.#Bit /.#Natural /.#Integer /.#Revolution /.#Decimal /.#Text /.#Name /.#Form /.#Variant /.#Tuple]
                (all _.and
                     ..for_code/'
                     ..for_code/`
                     ..for_code/`'
                     ))
         (_.coverage [/.Annotated
                      /.#meta /.#datum]
           (|> example
               (its /.#meta)
               (provenance.= provenance.dummy)))
         (_.for [/.UnQuote]
                (all _.and
                     (_.coverage [/.unquote_macro]
                       (exec
                         (is /.Macro'
                             (/.unquote_macro /.,))
                         (is /.Macro'
                             (/.unquote_macro /.,'))
                         true))
                     (_.coverage [/.unquote]
                       (exec
                         (is /.UnQuote
                             (/.unquote (macro.macro (/.unquote_macro /.,))))
                         (is /.UnQuote
                             (/.unquote (macro.macro (/.unquote_macro /.,'))))
                         true))
                     (_.coverage [/., /.but]
                       (expansion.let [<natural> (code.natural example_natural)]
                         (and (not (code.= <natural>
                                           (/.' (/., <natural>))))
                              (code.= <natural>
                                      (/.` (/., <natural>)))
                              (code.= <natural>
                                      (/.`' (/., <natural>))))))
                     (_.coverage [/.,* /.also]
                       (expansion.let [<bit> (code.bit example_bit)
                                       <natural> (code.natural example_natural)
                                       <integer> (code.integer example_integer)
                                       <expected> (code.tuple (list <bit> <natural> <integer>))
                                       <actual> [(/.,* (list <bit> <natural> <integer>))]]
                         (and (not (code.= <expected>
                                           (/.' <actual>)))
                              (code.= <expected>
                                      (/.` <actual>))
                              (code.= <expected>
                                      (/.`' <actual>)))))
                     (_.coverage [/.,' /.verbatim]
                       (expansion.let [<bit> (code.bit example_bit)
                                       <natural> (code.natural example_natural)
                                       <integer> (code.integer example_integer)
                                       <expected> (/.' [(list <bit> <natural> <integer>)])
                                       <actual> [(/.,' (list <bit> <natural> <integer>))]]
                         (and (not (code.= <expected>
                                           (/.' <actual>)))
                              (code.= <expected>
                                      (/.` <actual>))
                              (code.= <expected>
                                      (/.`' <actual>)))))
                     ))
         )))

(the identity_macro
  (/.macro (_ tokens)
    (by meta.monad in tokens)))

(the crosshair
  "This is an arbitrary text whose only purpose is to be found, somewhere, in the source-code.")

(the found_crosshair?
  (macro (_ tokens lux)
    (let [[_ _ source_code] (its .#source lux)]
      {.#Right [lux (list (code.bit (text.contains? ..crosshair source_code)))]})))

(the for_macro
  Test
  (let [macro (is /.Macro'
                  (function (_ tokens lux)
                    {.#Right [lux (list)]}))]
    (do random.monad
      [expected random.natural]
      (`` (`` (all _.and
                   (_.coverage [/.Macro']
                     (|> macro
                         (is /.Macro')
                         (same? macro)))
                   (_.coverage [/.Macro]
                     (|> macro
                         macro.macro
                         (is /.Macro)
                         (is Any)
                         (same? (is Any macro))))
                   (_.coverage [/.macro]
                     (same? expected (..identity_macro expected)))
                   (_.coverage [/.Source]
                     (..found_crosshair?))
                   ... (_.coverage [/.using]
                   ...   (`` (expansion.let [<referral> (.in_module# "library/lux" library/lux.refer)
                   ...                         <alias> (static.random code.text (random.lower_cased 1))
                   ...                         <definition> (static.random code.local (random.lower_cased 1))
                   ...                         <module/0> (static.random code.text (random.lower_cased 2))
                   ...                         <module/0>' (template.name [<module/0>])
                   ...                         <module/1> (static.random code.text (random.lower_cased 3))
                   ...                         <module/1>' (template.name [<module/1>])
                   ...                         <module/2> (static.random code.text (random.lower_cased 4))
                   ...                         <module/2>' (template.name [<module/2>])
                   ...                         <m0/1> (template.text [<module/0> "/" <module/1>])
                   ...                         <//> (template.text [// <module/2>'])
                   ...                         <//>' (template.name [<//>])
                   ...                         <\\> (template.text [\\ <module/2>'])
                   ...                         <\\>' (template.name [<\\>])
                   ...                         <m0/2> (template.text [<module/0> "/" <module/2>])
                   ...                         <m2/1> (template.text [<module/2> "/" <module/1>])
                   ...                         <m0/1/2> (template.text [<module/0> "/" <module/1> "/" <module/2>])
                   ...                         <open/0> (template.text [<module/0> "#[0]"])]
                   ...         (and (,, (template.with [<input> <module> <referrals>]
                   ...                    [(expansion.let [<input>' (macro.final <input>)]
                   ...                       (let [scenario (is (-> Any Bit)
                   ...                                          (function (_ _)
                   ...                                            ... TODO: Remove this hack once Jython is no longer being used as the Python interpreter.
                   ...                                            (`` (for .python (when (' [<input>'])
                   ...                                                                (^.` [<module>
                   ...                                                                      (.def# (, [_ {.#Name ["" _]}]) [] #0)
                   ...                                                                      (,, (template.spliced <referrals>))])
                   ...                                                                true

                   ...                                                                _
                   ...                                                                false)
                   ...                                                     (when (' [<input>'])
                   ...                                                       (^.` [<module> (,, (template.spliced <referrals>))])
                   ...                                                       true

                   ...                                                       _
                   ...                                                       false)))))]
                   ...                         (scenario [])))]

                   ...                    [(.using [<module/0>'])
                   ...                     (.module# [])
                   ...                     []]

                   ...                    [(.using [<alias> <module/0>' (.except)])
                   ...                     (.module# [[<module/0> <alias>]])
                   ...                     [(<referral> <module/0> (.except))]]

                   ...                    [(.using [<alias> <module/0>' (.only <definition>)])
                   ...                     (.module# [[<module/0> <alias>]])
                   ...                     [(<referral> <module/0> (.only <definition>))]]

                   ...                    [(.using [<alias> <module/0>' (.except <definition>)])
                   ...                     (.module# [[<module/0> <alias>]])
                   ...                     [(<referral> <module/0> (.except <definition>))]]

                   ...                    [(.using [<alias> <module/0>'])
                   ...                     (.module# [])
                   ...                     []]

                   ...                    [(.using [<module/0>'
                   ...                                [<alias> <module/1>']])
                   ...                     (.module# [[<m0/1> <alias>]])
                   ...                     [(<referral> <m0/1>)]]

                   ...                    [(.using ["[0]" <module/0>'
                   ...                                ["[0]" <module/1>']])
                   ...                     (.module# [[<module/0> <module/0>]
                   ...                                        [<m0/1> <module/1>]])
                   ...                     [(<referral> <module/0>)
                   ...                      (<referral> <m0/1>)]]

                   ...                    [(.using ["[0]" <module/0>'
                   ...                                ["[1]" <module/1>']])
                   ...                     (.module# [[<m0/1> <module/0>]])
                   ...                     [(<referral> <m0/1>)]]

                   ...                    [(.using ["[0]" <module/0>'
                   ...                                ["[1]" <module/1>'
                   ...                                 ["[2]" <module/2>']]])
                   ...                     (.module# [[<m0/1/2> <module/0>]])
                   ...                     [(<referral> <m0/1/2>)]]

                   ...                    [(.using [<module/0>'
                   ...                                ["[0]" <module/1>'
                   ...                                 ["[0]" <//>']]])
                   ...                     (.module# [[<m0/1> <module/1>]
                   ...                                        [<m0/2> <//>]])
                   ...                     [(<referral> <m0/1>)
                   ...                      (<referral> <m0/2>)]]

                   ...                    [(.using ["[0]" <module/0>'
                   ...                                [<module/1>'
                   ...                                 ["[0]" <\\>']]])
                   ...                     (.module# [[<module/0> <module/0>]
                   ...                                        [<m2/1> <\\>]])
                   ...                     [(<referral> <module/0>)
                   ...                      (<referral> <m2/1>)]]

                   ...                    [(.using ["[0]" <module/0>' (.use "[1]#[0]" <definition>)])
                   ...                     (.module# [[<module/0> <module/0>]])
                   ...                     [(<referral> <module/0> (<open/0> <definition>))]]
                   ...                    ))))))
                   ))))))

(/.every for_type/variant
  (Variant
   {#Case/0}
   {#Case/1 Natural}
   {#Case/2 Integer Text}))

(/.every for_type/record
  (Record
   [#slot/0 Bit
    #slot/1 Revolution]))

(/.every (for_type/all parameter)
  [parameter parameter])

(the for_type
  Test
  (do [! random.monad]
    [expected random.natural

     expected_left random.natural
     expected_right random.natural

     .let [existential_type (by ! each (|>> {.#Opaque}) random.natural)]
     expected/0 existential_type
     expected/1 existential_type]
    (<| (_.for [/.Type
                /.#Nominal /.#Sum /.#Product /.#Function /.#Parameter /.#Variable /.#Opaque /.#Universal /.#Existential /.#Reification /.#Named])
        (all _.and
             (_.coverage [/.is]
               (|> expected
                   (/.is Any)
                   (same? (/.is Any expected))))
             (_.coverage [/.as]
               (|> expected
                   (/.is Any)
                   (/.as /.Natural)
                   (same? expected)))
             (_.coverage [/.as_expected]
               (|> expected
                   (/.is Any)
                   /.as_expected
                   (/.is /.Natural)
                   (same? expected)))
             (_.coverage [/.type_of]
               (same? /.Natural (/.type_of expected)))
             (_.coverage [/.Nominal]
               (when (/.Nominal "foo" [expected/0 expected/1])
                 {.#Nominal "foo" (list actual/0 actual/1)}
                 (and (same? expected/0 actual/0)
                      (same? expected/1 actual/1))

                 _
                 false))
             (_.coverage [/.every]
               (exec
                 (is /.Type ..for_type/variant)
                 (is /.Type ..for_type/record)
                 (is /.Type ..for_type/all)
                 true))
             (_.coverage [/.Variant]
               (exec
                 (is for_type/variant
                     {#Case/1 expected_left})
                 true))
             (_.coverage [/.Record]
               (exec
                 (is for_type/record
                     [#slot/0 (n.= expected_left expected_right)
                      #slot/1 (.revolution expected_right)])
                 true))
             ))))

(the for_i64
  Test
  (do random.monad
    [expected random.i64]
    (all _.and
         (_.coverage [/.i64]
           (same? (is Any expected)
                  (is Any (/.i64 expected))))
         (_.coverage [/.natural]
           (same? (is Any expected)
                  (is Any (/.natural expected))))
         (_.coverage [/.integer]
           (same? (is Any expected)
                  (is Any (/.integer expected))))
         (_.coverage [/.revolution]
           (same? (is Any expected)
                  (is Any (/.revolution expected))))
         (_.coverage [/.++]
           (n.= 1 (n.- expected
                       (/.++ expected))))
         (_.coverage [/.--]
           (n.= 1 (n.- (/.-- expected)
                       expected)))
         )))

(the for_function
  Test
  (do random.monad
    [expected_left random.natural
     expected_right random.natural]
    (_.coverage [/.-> /.function]
      (and (let [actual (is (/.-> Natural Natural Natural)
                            (/.function (_ actual_left actual_right)
                              (n.* (++ actual_left) (-- actual_right))))]
             (n.= (n.* (++ expected_left) (-- expected_right))
                  (actual expected_left expected_right)))
           (let [actual (is (/.-> [Natural Natural] Natural)
                            (/.function (_ [actual_left actual_right])
                              (n.* (++ actual_left) (-- actual_right))))]
             (n.= (n.* (++ expected_left) (-- expected_right))
                  (actual [expected_left expected_right])))))))

(the option/0 "0")
(the option/1 "1")
(the static_character "@")

(the for_static
  Test
  (do random.monad
    [sample (random.either (in option/0)
                           (in option/1))]
    (all _.and
         (_.coverage [/.static]
           (when sample
             (/.static option/0) true
             (/.static option/1) true
             _ false))
         (_.coverage [/.character]
           (|> (`` (/.character (,, (/.static static_character))))
               text.of_character
               (text.= static_character)))
         )))

(every Small
  (Record
   [#small_left Natural
    #small_right Text]))

(every Big
  (Record
   [#big_left Natural
    #big_right Small]))

(the for_slot
  Test
  (do random.monad
    [start/s random.natural
     start/b random.natural
     shift/s random.natural
     shift/b random.natural
     text (random.lower_cased 1)
     .let [expected/s (n.+ shift/s start/s)
           expected/b (n.+ shift/b start/b)

           sample [#big_left start/b
                   #big_right [#small_left start/s
                               #small_right text]]]]
    (all _.and
         (_.coverage [/.its]
           (and (and (|> sample
                         (/.its #big_left)
                         (same? start/b))
                     (|> sample
                         ((/.its #big_left))
                         (same? start/b)))
                (and (|> sample
                         (/.its [#big_right #small_left])
                         (same? start/s))
                     (|> sample
                         ((/.its [#big_right #small_left]))
                         (same? start/s)))))
         (_.coverage [/.has]
           (and (and (|> sample
                         (/.has #big_left shift/b)
                         (/.its #big_left)
                         (same? shift/b))
                     (|> sample
                         ((/.has #big_left shift/b))
                         (/.its #big_left)
                         (same? shift/b))
                     (|> sample
                         ((/.has #big_left) shift/b)
                         (/.its #big_left)
                         (same? shift/b)))
                (and (|> sample
                         (/.has [#big_right #small_left] shift/s)
                         (/.its [#big_right #small_left])
                         (same? shift/s))
                     (|> sample
                         ((/.has [#big_right #small_left] shift/s))
                         (/.its [#big_right #small_left])
                         (same? shift/s))
                     (|> sample
                         ((/.has [#big_right #small_left]) shift/s)
                         (/.its [#big_right #small_left])
                         (same? shift/s)))))
         (_.coverage [/.revised]
           (and (and (|> sample
                         (/.revised #big_left (n.+ shift/b))
                         (/.its #big_left)
                         (n.= expected/b))
                     (|> sample
                         ((/.revised #big_left (n.+ shift/b)))
                         (/.its #big_left)
                         (n.= expected/b))
                     (|> sample
                         ((is (-> (-> Natural Natural) (-> Big Big))
                              (/.revised #big_left))
                          (n.+ shift/b))
                         (/.its #big_left)
                         (n.= expected/b)))
                (and (|> sample
                         (/.revised [#big_right #small_left] (n.+ shift/s))
                         (/.its [#big_right #small_left])
                         (n.= expected/s))
                     (|> sample
                         ((/.revised [#big_right #small_left] (n.+ shift/s)))
                         (/.its [#big_right #small_left])
                         (n.= expected/s))
                     (|> sample
                         ((is (-> (-> Natural Natural) (-> Big Big))
                              (/.revised [#big_right #small_left]))
                          (n.+ shift/s))
                         (/.its [#big_right #small_left])
                         (n.= expected/s)))))
         )))

(the for_associative
  Test
  (do random.monad
    [left (random.lower_cased 1)
     mid (random.lower_cased 1)
     right (random.lower_cased 1)
     .let [expected (text.interposed "" (list left mid right))]]
    (_.coverage [/.left_associative /.right_associative]
      (expansion.let [<left_association> (/.left_associative .text left mid right)
                      <right_association> (/.right_associative .text left mid right)]
        (and (text.= <left_association>
                     <right_association>)
             (not (code.= (' <left_association>)
                          (' <right_association>))))))))

(the for_expansion
  Test
  (do random.monad
    [left random.natural
     right random.natural
     dummy random.natural
     .let [expected (n.+ left right)]]
    (all _.and
         (_.coverage [/.these]
           (`` (and (,, (these true
                               true
                               true)))))
         (_.coverage [/.comment]
           (expansion.let [<dummy> (/.comment dummy)
                           <operands> (these left right)]
             (n.= expected
                  (all n.+ <operands> <dummy>))))
         (_.coverage [/.`` /.,,]
           (n.= expected
                (/.`` (all n.+
                           (/.,, (these left right))
                           (/.,, (/.comment dummy))))))
         (_.coverage [/.for]
           (and (n.= expected
                     (/.for "fake host" dummy
                            expected))
                (n.= expected
                     (/.for .jvm expected
                            .js expected
                            .python expected
                            .lua expected
                            .ruby expected
                            .php expected
                            dummy))))
         )))

(the for_value
  Test
  (do random.monad
    [left random.natural
     right (random.lower_cased 1)

     item/0 random.natural
     item/1 random.natural
     item/2 random.natural]
    (all _.and
         (_.coverage [/.Either
                      /.#Left /.#Right]
           (and (exec
                  (is (/.Either Natural Text)
                      {.#Left left})
                  true)
                (exec
                  (is (/.Either Natural Text)
                      {.#Right right})
                  true)))
         (_.coverage [/.Any
                      /.True /.Verum]
           (and (exec
                  (is /.Any
                      left)
                  true)
                (exec
                  (is /.Any
                      right)
                  true)
                (alias? /.Any /.True)
                (alias? /.Any /.Verum)))
         (_.coverage [/.Nothing
                      /.False /.Falsum]
           (and (exec
                  (is (-> /.Any /.Nothing)
                      (function (_ _)
                        (undefined)))
                  true)
                (exec
                  (is (-> /.Any /.Integer)
                      (function (_ _)
                        (is /.Integer (undefined))))
                  true)
                (alias? /.Nothing /.False)
                (alias? /.Nothing /.Falsum)))
         (_.for [/.Quantification
                 /.__adjusted_quantified_type__]
                (all _.and
                     (_.coverage [/.for_any /.for_all /.for_every]
                       (and (let [identity (is (/.for_any (_ a) (-> a a))
                                               (|>>))]
                              (and (exec
                                     (is Natural
                                         (identity left))
                                     true)
                                   (exec
                                     (is Text
                                         (identity right))
                                     true)))
                            (alias? /.for_any /.for_all)
                            (alias? /.for_any /.for_every)))
                     (_.coverage [/.for_some /.there_exists]
                       (and (let [hide (is (/.for_some (_ a) (-> Natural a))
                                           (|>>))]
                              (exec
                                (is /.Any
                                    (hide left))
                                true))
                            (alias? /.for_some /.there_exists)))))
         (_.coverage [/.same? /.alias? /.identical?]
           (and (let [not_left (atom.atom left)
                      left (atom.atom left)]
                  (and (/.same? left left)
                       (/.same? not_left not_left)
                       (not (/.same? left not_left))))
                (/.alias? /.same? /.alias?)
                (/.alias? /.same? /.identical?)))
         (_.coverage [/.Rec]
           (let [list (is (/.Rec NList
                            (Maybe [Natural NList]))
                          {.#Some [item/0
                                   {.#Some [item/1
                                            {.#Some [item/2
                                                     {.#None}]}]}]})]
             (when list
               {.#Some [actual/0 {.#Some [actual/1 {.#Some [actual/2 {.#None}]}]}]}
               (and (same? item/0 actual/0)
                    (same? item/1 actual/1)
                    (same? item/2 actual/2))

               _
               false)))
         )))

(every (Pair l r)
  (Record
   [#left l
    #right r]))

(the !pair
  (template.macro (_ <left> <right>)
    [[..#left <left>
      ..#right <right>]]))

(the for_when
  Test
  (do [! random.monad]
    [expected_natural (by ! each (n.% 1) random.natural)
     expected_integer (by ! each (i.% +1) random.integer)
     expected_revolution (random.either (in .5)
                                        (in .25))
     expected_decimal (random.either (in +0.5)
                                     (in +1.25))
     expected_text (random.either (in "+0.5")
                                  (in "+1.25"))]
    (all _.and
         (_.coverage [/.when]
           (and (/.when expected_natural
                  0 true
                  _ false)
                (/.when expected_integer
                  +0 true
                  _ false)
                (/.when expected_revolution
                  .5 true
                  .25 true
                  _ false)
                (/.when expected_decimal
                  +0.5 true
                  +1.25 true
                  _ false)
                (/.when expected_text
                  "+0.5" true
                  "+1.25" true
                  _ false)
                (/.when [expected_natural expected_integer]
                  [0 +0] true
                  _ false)
                (/.when [..#left expected_natural ..#right expected_integer]
                  [..#left 0 ..#right +0] true
                  _ false)
                (/.when (is (Either Natural Integer) {.#Left expected_natural})
                  {.#Left 0} true
                  _ false)
                (/.when (is (Either Natural Integer) {.#Right expected_integer})
                  {.#Right +0} true
                  _ false)
                ))
         ... (_.coverage [/.pattern]
         ...   (/.when [..#left expected_natural ..#right expected_integer]
         ...     (!pair 0 +0)
         ...     true

         ...     _
         ...     false))
         (_.coverage [/.let]
           (and (/.let [actual_natural expected_natural]
                  (/.same? expected_natural actual_natural))
                (/.let [[actual_left actual_right] [..#left expected_natural ..#right expected_integer]]
                  (and (/.same? expected_natural actual_left)
                       (/.same? expected_integer actual_right)))))
         )))

(the for_control_flow
  Test
  (all _.and
       (do random.monad
         [factor (random#each (|>> (n.% 10) (n.major 1)) random.natural)
          iterations (random#each (n.% 10) random.natural)
          .let [expected (n.* factor iterations)]]
         (_.coverage [/.loop]
           (n.= expected
                (/.loop (again [counter 0
                                value 0])
                  (if (n.< iterations counter)
                    (again (++ counter) (n.+ factor value))
                    value)))))
       (do random.monad
         [pre random.natural
          post (random.only (|>> (n.= pre) not) random.natural)
          .let [box (atom.atom pre)]]
         (_.coverage [/.exec]
           (and (same? pre (io.value (atom.read! box)))
                (/.exec
                  (io.value (atom.write! post box))
                  (same? post (io.value (atom.read! box)))))))
       ))

(the identity/constant
  (for_any (_ a)
    (-> a
        a))
  (function (_ value)
    value))

(the (identity/function value)
  (for_any (_ a)
    (-> a
        a))
  value)

(the for_def
  Test
  (do random.monad
    [expected random.natural]
    (_.coverage [/.the]
      (and (same? expected (identity/constant expected))
           (same? expected (identity/function expected))))))

(the possible_targets
  (Set Target)
  (<| (set.of_list text.hash)
      (list .js
            .jvm
            .lua
            .python
            .ruby)))

(the for_meta|Info
  (syntax.macro (_ [])
    (function (_ lux)
      (let [info (its .#info lux)

            conforming_target!
            (set.member? ..possible_targets (its .#target info))

            compiling!
            (when (its .#mode info)
              {.#Build} true
              _ false)]
        {.#Right [lux (list (code.bit (and conforming_target!
                                           compiling!)))]}))))

(the for_meta|Module_State
  (syntax.macro (_ [])
    (do meta.monad
      [prelude (module.by_name .prelude)]
      (in (list (code.bit (when (its .#module_state prelude)
                            {/.#Active} false
                            {/.#Compiled} true
                            {/.#Cached} true)))))))

(the for_meta
  Test
  (all _.and
       (_.coverage [/.Info
                    /.#target /.#version /.#mode /.#configuration

                    /.Mode
                    /.#Build /.#Eval /.#Interpreter]
         (for_meta|Info))
       (_.coverage [/.Module_State
                    /.#Active /.#Compiled /.#Cached]
         (for_meta|Module_State))
       ))

(the for_export
  Test
  (all _.and
       (_.coverage [/.public /.private]
         (and /.public (not /.private)))
       (_.coverage [/.global /.local]
         (and (bit.= /.public /.global)
              (bit.= /.private /.local)))
       ))

(the for_complex
  Test
  (do random.monad
    [expected random.natural
     expected_left random.natural
     expected_right random.natural
     expected_bit random.bit
     expected_revolution random.revolution]
    (all _.and
         (_.coverage [/.variant /.|]
           (and (when (is (Maybe Natural)
                          (/.variant .#None []))
                  (/.variant .#None _)
                  true

                  _
                  false)
                (when (is (Maybe Natural)
                          (/.variant .#Some expected))
                  (/.variant .#Some actual)
                  (same? expected actual)

                  _
                  false)
                (same? /.variant /.|)))
         (_.coverage [/.tuple /.&]
           (and (let [(/.tuple actual_left actual_right)
                      (is [Natural Natural]
                          (/.tuple expected_left expected_right))]
                  (and (same? expected_left actual_left)
                       (same? expected_right actual_right)))
                (same? /.tuple /.&)))
         (_.coverage [/.record]
           (let [(/.tuple actual_bit actual_revolution)
                 (is for_type/record
                     (/.record #slot/0 expected_bit
                               #slot/1 expected_revolution))]
             (and (same? expected_bit actual_bit)
                  (same? expected_revolution actual_revolution))))
         )))

(the for_extension
  Test
  (all _.and
       (_.coverage [/.Analysis]
         true)
       (_.coverage [/.Synthesis]
         true)
       (_.coverage [/.Translation]
         true)
       (_.coverage [/.Declaration]
         true)
       ))

(the for_bindings|test
  (syntax.macro (_ lux_state
                   [fn/0 <code>.local
                    var/0 <code>.local
                    let/0 <code>.local

                    fn/1 <code>.local
                    var/1 <code>.local
                    let/1 <code>.local

                    fn/2 <code>.local
                    var/2 <code>.local
                    let/2 <code>.local

                    let/3 <code>.local])
    (in (list (code.bit (when (its .#scopes lux_state)
                          (list.partial scope/2 _)
                          (let [locals/2 (its .#locals scope/2)
                                expected_locals/2 (set.of_list text.hash (list fn/2 var/2 let/2
                                                                               let/3))
                                actual_locals/2 (|> locals/2
                                                    (its .#mappings)
                                                    (list#each product.left)
                                                    (set.of_list text.hash))

                                correct_locals!
                                (and (n.= 4 (its .#counter locals/2))
                                     (set.= expected_locals/2
                                            actual_locals/2))

                                captured/2 (its .#captured scope/2)

                                local? (is (-> Ref Bit)
                                           (function (_ ref)
                                             (when ref
                                               {.#Local _} true
                                               {.#Captured _} false)))
                                captured? (is (-> Ref Bit)
                                              (|>> local? not))
                                binding? (is (-> (-> Ref Bit) Text Bit)
                                             (function (_ is? name)
                                               (|> captured/2
                                                   (its .#mappings)
                                                   (property.value name)
                                                   (maybe#each (|>> product.right is?))
                                                   (maybe.else false))))

                                correct_closure!
                                (and (n.= 6 (its .#counter captured/2))
                                     (binding? local? fn/1)
                                     (binding? local? var/1)
                                     (binding? local? let/1)
                                     (binding? captured? fn/0)
                                     (binding? captured? var/0)
                                     (binding? captured? let/0))]
                            (and correct_locals!
                                 correct_closure!))

                          _
                          false))))))

(the for_bindings
  Test
  ((<| (template.with_locals [fn/0 var/0 let/0
                              fn/1 var/1 let/1
                              fn/2 var/2 let/2
                              let/3])
       (function (fn/0 var/0)) (let [let/0 123])
       (function (fn/1 var/1)) (let [let/1 456])
       (function (fn/2 var/2)) (let [let/2 789])
       (let [let/3 [fn/0 var/0 let/0
                    fn/1 var/1 let/1
                    fn/2 var/2 let/2]
             verdict (for_bindings|test fn/0 var/0 let/0
                                        fn/1 var/1 let/1
                                        fn/2 var/2 let/2
                                        let/3)]
         (_.coverage [/.Ref
                      /.#Local /.#Captured
                      
                      /.Bindings
                      /.#counter /.#mappings]
           verdict)))
   0 1 2))

(the for_target
  Test
  (<| (_.for [/.Target])
      (all _.and
           (_.coverage [/.c++ /.common_lisp /.js
                        /.jvm /.lua /.php
                        /.python /.r /.ruby]
             (let [options (is (List /.Target)
                               (list /.c++ /.common_lisp /.js
                                     /.jvm /.lua /.php
                                     /.python /.r /.ruby))
                   uniques (set.of_list text.hash options)]
               (n.= (list.size options)
                    (set.size uniques))))
           )))

... https://en.wikipedia.org/wiki/Involution_(mathematics)
(every (Involution of)
  (-> of
      of))

(the for_can
  Test
  (<| (_.for [/.Can])
      (all _.and
           (do random.monad
             [expected random.bit]
             (_.coverage [/.can /.ability /.entity]
               (let [ability (is (Involution Bit)
                                 not)
                     it (is (Can Involution Bit)
                            (/.can ability expected))]
                 (and (same? ability (/.ability it))
                      (same? expected (/.entity it))
                      (bit.= (ability expected)
                             ((is (Involution Bit)
                                  (/.ability it))
                              (/.entity it)))))))
           )))

(the test|lux
  Test
  (`` (`` (all _.and
               ..for_bit
               ..for_try
               ..for_list
               ..for_interface
               ..for_module
               ..for_pipe
               ..for_code
               ..for_macro
               ..for_type
               ..for_i64
               ..for_function
               ..for_static
               ..for_slot
               ..for_associative
               ..for_expansion
               ..for_value
               ..for_when
               ..for_control_flow
               ..for_def
               ..for_meta
               ..for_export
               ..for_complex
               ..for_extension
               ..for_bindings
               ..for_target
               ..for_can
               ))))

(the for_concurrency
  Test
  (all _.and
       /concurrency/actor.test
       /concurrency/agent.test
       /concurrency/atom.test
       /concurrency/frp.test
       /concurrency/thread.test
       /concurrency/future.test
       /concurrency/semaphore.test
       /concurrency/stm.test
       /concurrency/event.test
       /concurrency/csp.test
       /concurrency/incremental.test
       /concurrency/structured.test
       /concurrency/behavioral.test
       ))

(the for_color
  Test
  (all _.and
       /color/rgb.test
       /color/cmyk.test
       /color/hsl.test
       /color/hsb.test
       /color/pigment.test
       /color/named.test
       /color/terminal.test
       /color/scheme.test
       ))

(the for_music
  Test
  (all _.and
       /music/instrument.test
       /music/percussion.test
       /music/pitch.test
       /music/velocity.test
       /music/interval.test
       /music/scale.test
       /music/mode.test
       /music/chord.test
       /music/note.test
       /music/channel.test
       /music/tempo.test
       /music/balance.test
       /music/panning.test
       /music/accidental.test
       ))

(the for_finance
  Test
  (all _.and
       /finance/money.test
       /finance/trade/volume.test
       /finance/trade/session.test
       /finance/market/price.test
       /finance/market/ticker.test
       /finance/interest/rate.test
       ))

(the for_security
  Test
  (all _.and
       /security/policy.test
       /security/capability.test
       ))

(the test
  Test
  (<| (_.covering /._)
      (_.in_parallel
       (list ..test|lux

             /abstract.test
             /algorithm.test
             /control.test
             /function.test
             ..for_concurrency
             ..for_color
             /data.test
             /debug.test

             /documentation.test
             /math.test

             /type.test
             /macro.test
             /meta.test
             /program.test
             /test.test

             /web/permission.test
             /web/html/tag.test
             /web/html/attribute.test
             /web/dom/event.test

             /time.test
             /world.test

             /ffi.test

             ..for_music
             ..for_finance
             ..for_security
             ))))

(the _
  (program args
    (let [times (for .jvm 100
                     .js 10
                     .python 1
                     .lua 1
                     .ruby 1
                     100)]
      (<| io.io
          _.value
          (_.times times _.announce_success)
          ..test
          ))))
