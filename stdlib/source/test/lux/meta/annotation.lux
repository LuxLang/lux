(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    [abstract
     [monad {"+" [do]}]]
    [control
     ["[0]" try {"+" [Try]}]]
    [data
     ["[0]" product]
     ["[0]" bit]
     ["[0]" name ("[1]\[0]" equivalence)]
     ["[0]" text]
     [collection
      ["[0]" list ("[1]\[0]" functor)]]]
    [macro
     ["[0]" code ("[1]\[0]" equivalence)]]
    [math
     ["[0]" random {"+" [Random]}]
     [number
      ["[0]" nat]
      ["[0]" int]
      ["[0]" rev]
      ["[0]" frac]]]]]
  [///
   [macro
    ["_[0]" code]]]
  [\\library
   ["[0]" /]])

(def: random_key
  (Random Name)
  (random.and (random.ascii/alpha 1)
              (random.ascii/alpha 1)))

(def: (random_sequence random)
  (All (_ a) (-> (Random a) (Random (List a))))
  (do [! random.monad]
    [size (|> random.nat (\ ! each (nat.% 3)))]
    (random.list size random)))

(def: (random_record random)
  (All (_ a) (-> (Random a) (Random (List [a a]))))
  (do [! random.monad]
    [size (|> random.nat (\ ! each (nat.% 3)))]
    (random.list size (random.and random random))))

(template: (!expect <pattern> <value>)
  [(case <value>
     <pattern> true
     _ false)])

(def: (annotation key value)
  (-> Name Code /.Annotation)
  (code.record (list [(code.tag key)
                      value])))

(def: typed_value
  Test
  (do [! random.monad]
    [key ..random_key]
    (`` ($_ _.and
            (~~ (template [<definition> <random> <constructor> <equivalence>]
                  [(do [! random.monad]
                     [expected <random>]
                     (_.cover [<definition>]
                              (|> expected <constructor>
                                  (..annotation key)
                                  (<definition> key)
                                  (!expect (^multi (#.Some actual)
                                                   (\ <equivalence> = expected actual))))))]

                  [/.bit random.bit code.bit bit.equivalence]
                  [/.nat random.nat code.nat nat.equivalence]
                  [/.int random.int code.int int.equivalence]
                  [/.rev random.rev code.rev rev.equivalence]
                  [/.frac random.safe_frac code.frac frac.equivalence]
                  [/.text (random.ascii/alpha 1) code.text text.equivalence]
                  [/.identifier ..random_key code.identifier name.equivalence]
                  [/.tag ..random_key code.tag name.equivalence]
                  [/.form (..random_sequence _code.random) code.form (list.equivalence code.equivalence)]
                  [/.tuple (..random_sequence _code.random) code.tuple (list.equivalence code.equivalence)]
                  [/.record (..random_record _code.random) code.record (list.equivalence (product.equivalence code.equivalence code.equivalence))]
                  ))
            ))))

(def: flag
  Test
  (do [! random.monad]
    [key ..random_key]
    (`` ($_ _.and
            (do !
              [dummy (random.only (|>> (name\= key) not)
                                  ..random_key)
               expected random.bit]
              (_.cover [/.flagged?]
                       (and (|> expected code.bit
                                (..annotation key)
                                (/.flagged? key)
                                (\ bit.equivalence = expected))
                            (not (|> expected code.bit
                                     (..annotation dummy)
                                     (/.flagged? key))))))
            (do !
              [expected random.bit]
              (_.cover [/.implementation?]
                       (and (|> expected code.bit
                                (..annotation (name_of #.implementation?))
                                /.implementation?
                                (\ bit.equivalence = expected))
                            (not (|> expected code.bit
                                     (..annotation key)
                                     /.implementation?)))))
            ))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Annotation])
      (do [! random.monad]
        [key ..random_key]
        ($_ _.and
            (do !
              [expected _code.random]
              (_.cover [/.value]
                       (|> expected
                           (..annotation key)
                           (/.value key)
                           (!expect (^multi (#.Some actual)
                                            (code\= expected actual))))))
            
            ..typed_value

            ..flag
            ))))
