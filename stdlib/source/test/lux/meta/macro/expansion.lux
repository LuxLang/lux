... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" try]
    ["[0]" exception]]
   [data
    ["[0]" text (.only)
     ["%" \\injection]]
    [collection
     ["[0]" list]]]
   [math
    [number
     ["n" natural]]
    ["[0]" random]]
   ["[0]" meta (.only)
    ["[0]" static]
    ["[0]" code (.only)
     ["<[1]>" \\projection]]
    [macro
     ["[0]" syntax]
     ["[0]" template]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" /]])

(use "code_list#[0]" (list.equivalence code.equivalence))

(the dup
  (syntax.macro (_ [times <code>.natural
                    what <code>.any])
    (when times
      0 (in (list what))
      _ (let [it (` (..dup (, (code.natural (-- times))) (, what)))]
          (in (list it it))))))

(the .public test
  Test
  (<| (_.covering /._)
      (`` (all _.and
               (,, (template.with [<expansion> <inner> <0> <1>]
                     [(_.coverage [<expansion>]
                        (and (<| static.expansion
                                 (do meta.monad
                                   [it (<expansion> (` (..dup 0 <inner>)))]
                                   (in (list (code.bit (code_list#= <0>
                                                                    it))))))
                             (<| static.expansion
                                 (do meta.monad
                                   [it (<expansion> (` (..dup 1 <inner>)))]
                                   (in (list (code.bit (code_list#= <1>
                                                                    it))))))))]

                     [/.single   []           (list (` [])) (list (` (..dup 0 [])) (` (..dup 0 [])))]
                     [/.complete []           (list (` [])) (list (` []) (` []))]
                     [/.total    (..dup 0 []) (list (` [])) (list (` []) (` []))]
                     ))
               (_.coverage [/.one]
                 (and (<| static.expansion
                          (do meta.monad
                            [it (/.one (` (..dup 0 [])))]
                            (in (list (code.bit (code.= (` [])
                                                        it))))))
                      (<| static.expansion
                          (do meta.monad
                            [it (meta.try (/.one (` (..dup 1 []))))]
                            (in (list (code.bit (when it
                                                  {try.#Failure _}
                                                  true
                                                  
                                                  {try.#Success _}
                                                  false))))))))
               (_.coverage [/.log_single!]
                 (exec
                   (,, (/.log_single! "omit" (..dup 0 [])))
                   (,, (/.log_single! (..dup 0 [])))
                   true))
               (_.coverage [/.log_complete!]
                 (exec
                   (,, (/.log_complete! "omit" (..dup 1 [])))
                   (,, (/.log_complete! (..dup 1 [])))
                   true))
               (_.coverage [/.log_total!]
                 (exec
                   (,, (/.log_total! "omit" (..dup 1 (..dup 0 []))))
                   (,, (/.log_total! (..dup 1 (..dup 0 []))))
                   true))
               (do random.monad
                 [left random.natural
                  right random.natural
                  .let [expected (n.+ left right)]]
                 (_.coverage [/.let]
                   (/.let [<operands> (these left right)]
                     (n.= expected
                          (n.+ <operands>)))))
               ))))
