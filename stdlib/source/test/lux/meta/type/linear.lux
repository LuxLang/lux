... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    ["[0]" monad (.only)
     [indexed (.only do)]]]
   [control
    ["[0]" pure (.only Pure)]
    ["[0]" io (.only IO)]
    ["[0]" try]
    ["[0]" exception (.only Exception)]
    [concurrency
     ["[0]" async (.only Async)]]]
   [data
    ["[0]" text (.only)
     ["%" \\injection]]]
   [math
    ["[0]" random]]
   ["[0]" meta (.only)
    ["[0]" binding]
    ["[0]" code (.only)
     ["<[1]>" \\projection]]
    [macro
     ["[0]" syntax]
     ["[0]" expansion]
     ["[0]" template]]]
   [test
    ["[0]" unit]
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" / (.only Res)]])

(the pure
  Test
  (monad.do [! random.monad]
    [pre (of ! each %.natural random.natural)
     post (of ! each %.natural random.natural)
     .let [! pure.monad]]
    (_.for [/.Linear /.value /.monad]
           (`` (all _.and
                    (,, (template.with [<coverage> <bindings>]
                          [(_.coverage <coverage>
                             (<| (text.= (%.message pre post))
                                 (is (Pure Text))
                                 (/.value !)
                                 (do (/.monad !)
                                   <bindings>
                                   (in (%.message left right)))))]
                          
                          [[/.Affine /.Key /.Res /.Ordered /.ordered
                            /.Relevant /.read]
                           [res|left (/.ordered ! pre)
                            res|right (/.ordered ! post)
                            right (/.read ! res|right)
                            left (/.read ! res|left)]]
                          [[/.Commutative /.commutative /.exchange]
                           [res|left (/.commutative ! pre)
                            res|right (/.commutative ! post)
                            _ ((/.exchange [1 0]) !)
                            left (/.read ! res|left)
                            right (/.read ! res|right)]]
                          [[/.group /.un_group]
                           [res|left (/.commutative ! pre)
                            res|right (/.commutative ! post)
                            _ ((/.group 2) !)
                            _ ((/.un_group 2) !)
                            right (/.read ! res|right)
                            left (/.read ! res|left)]]
                          [[/.lifted]
                           [left (/.lifted ! pre)
                            right (/.lifted ! post)]]
                          ))
                    )))))

(the sync
  Test
  (monad.do [! random.monad]
    [pre (of ! each %.natural random.natural)
     post (of ! each %.natural random.natural)
     .let [! io.monad]]
    (_.for [/.Linear /.value /.monad]
           (`` (all _.and
                    (,, (template.with [<coverage> <bindings>]
                          [(_.coverage <coverage>
                             (<| (text.= (%.message pre post))
                                 io.value
                                 (is (IO Text))
                                 (/.value !)
                                 (do (/.monad !)
                                   <bindings>
                                   (in (%.message left right)))))]

                          [[/.Affine /.Key /.Res /.Ordered /.ordered
                            /.Relevant /.read]
                           [res|left (/.ordered ! pre)
                            res|right (/.ordered ! post)
                            right (/.read ! res|right)
                            left (/.read ! res|left)]]
                          [[/.Commutative /.commutative /.exchange]
                           [res|left (/.commutative ! pre)
                            res|right (/.commutative ! post)
                            _ ((/.exchange [1 0]) !)
                            left (/.read ! res|left)
                            right (/.read ! res|right)]]
                          [[/.group /.un_group]
                           [res|left (/.commutative ! pre)
                            res|right (/.commutative ! post)
                            _ ((/.group 2) !)
                            _ ((/.un_group 2) !)
                            right (/.read ! res|right)
                            left (/.read ! res|left)]]
                          [[/.lifted]
                           [left (/.lifted ! (io.io pre))
                            right (/.lifted ! (io.io post))]]
                          ))
                    )))))

(the async
  Test
  (monad.do [! random.monad]
    [pre (of ! each %.natural random.natural)
     post (of ! each %.natural random.natural)
     .let [! async.monad]]
    (_.for [/.Linear /.value /.monad]
           (`` (all _.and
                    (,, (template.with [<coverage> <bindings>]
                          [(in (monad.do !
                                 [outcome (<| (is (Async Text))
                                              (/.value !)
                                              (do (/.monad !)
                                                <bindings>
                                                (in (%.message left right))))]
                                 (unit.coverage <coverage>
                                   (text.= (%.message pre post)
                                           outcome))))]

                          [[/.Affine /.Key /.Res /.Ordered /.ordered
                            /.Relevant /.read]
                           [res|left (/.ordered ! pre)
                            res|right (/.ordered ! post)
                            right (/.read ! res|right)
                            left (/.read ! res|left)]]
                          [[/.Commutative /.commutative /.exchange]
                           [res|left (/.commutative ! pre)
                            res|right (/.commutative ! post)
                            _ ((/.exchange [1 0]) !)
                            left (/.read ! res|left)
                            right (/.read ! res|right)]]
                          [[/.group /.un_group]
                           [res|left (/.commutative ! pre)
                            res|right (/.commutative ! post)
                            _ ((/.group 2) !)
                            _ ((/.un_group 2) !)
                            right (/.read ! res|right)
                            left (/.read ! res|left)]]
                          [[/.lifted]
                           [left (/.lifted ! (async.resolved pre))
                            right (/.lifted ! (async.resolved post))]]
                          ))
                    )))))

(the with_error
  (syntax.macro (_ [exception <code>.symbol
                    to_expand <code>.any])
    (monad.do meta.monad
      [[_ exception] (binding.export exception)]
      (function (_ compiler)
        {.#Right [compiler
                  (list (code.bit (when ((expansion.single to_expand) compiler)
                                    {try.#Success _}
                                    false
                                    
                                    {try.#Failure error}
                                    true)))]}))))

(the .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Procedure])
      (all _.and
           ..pure
           ..sync
           ..async

           (_.coverage [/.amount_cannot_be_zero]
             (`` (and (,, (template.with [<group|un_group>]
                            [(with_error /.amount_cannot_be_zero
                               (<group|un_group> 0))]

                            [/.group]
                            [/.un_group]
                            )))))
           (_.coverage [/.index_cannot_be_repeated]
             (with_error /.index_cannot_be_repeated
               (/.exchange [0 0])))
           )))
