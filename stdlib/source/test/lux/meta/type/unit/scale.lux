... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]
    [equivalence (.only Equivalence)]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" nat]
     ["i" int]
     ["[0]" frac]]]
   ["[0]" meta (.only)
    ["[0]" code]
    [macro
     ["[0]" syntax]
     ["[0]" expansion]
     ["[0]" template]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" / (.only)
   ["/[1]" //]]])

(the natural
  (syntax.macro (_ [])
    (of meta.monad each
        (|>> code.nat list)
        meta.seed)))

(expansion.let [<from> (..natural)
                <factor> (..natural)
                <to> (n.* <factor> <from>)]
  (these (the how (/.scale [frac.#denominator <from>
                            frac.#numerator <to>]))
         (the How (/.type how))

         (the how::from <from>)
         (the how::to <to>))
  )

(the .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Scale
              /.up /.down /.frac])
      (do [! random.monad]
        [small (|> random.int
                   (of ! each (i.% +1,000))
                   (of ! each (of //.meter in)))
         large (|> random.int
                   (of ! each (i.% +1,000))
                   (of ! each (i.* +1,000,000,000))
                   (of ! each (of //.meter in)))
         .let [(open "meter#[0]") (is (Equivalence (//.Measure Any //.Meter))
                                      //.equivalence)]
         unscaled (|> random.int
                      (of ! each (|>> (i.% +1,000)
                                      (i.* (.int how::to))
                                      (of //.meter in))))]
        (`` (all _.and
                 (,, (template.with [<type> <scale>]
                       [(_.coverage [<type> <scale>]
                          (|> small
                              (of <scale> up)
                              (is (//.Measure <type> //.Meter))
                              (of <scale> down)
                              (is (//.Measure Any //.Meter))
                              (meter#= small)))]

                       [/.Kilo /.kilo]
                       [/.Mega /.mega]
                       [/.Giga /.giga]
                       ))
                 (,, (template.with [<type> <scale>]
                       [(_.coverage [<type> <scale>]
                          (|> large
                              (of <scale> up)
                              (is (//.Measure <type> //.Meter))
                              (of <scale> down)
                              (is (//.Measure Any //.Meter))
                              (meter#= large)))]

                       [/.Milli /.milli]
                       [/.Micro /.micro]
                       [/.Nano /.nano]
                       ))
                 (_.coverage [/.re_scaled]
                   (|> large (is (//.Measure Any //.Meter))
                       (of /.kilo up) (is (//.Measure /.Kilo //.Meter))
                       (/.re_scaled /.kilo /.milli) (is (//.Measure /.Milli //.Meter))
                       (/.re_scaled /.milli /.kilo) (is (//.Measure /.Kilo //.Meter))
                       (of /.kilo down) (is (//.Measure Any //.Meter))
                       (meter#= large)))
                 (_.coverage [/.scale /.type]
                   (and (|> unscaled
                            (of ..how up)
                            (is (//.Measure How //.Meter))
                            (of ..how down)
                            (meter#= unscaled))
                        (frac.= [frac.#denominator ..how::from
                                 frac.#numerator ..how::to]
                                (of ..how frac))))
                 )))))
