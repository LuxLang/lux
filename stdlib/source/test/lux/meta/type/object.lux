... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" parser]
    ["[0]" try]
    ["[0]" exception]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" nat]
     ["f" frac]]
    [geometry
     ["[0]" circle]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" /]]
 ["[0]" \\parser])

(/.every (Shape [] _)
  [#perimeter (/.Method [] Frac)
   #area (/.Method [] Frac)])

(every Circle
  (Record
   [#radius Frac]))

(the circle
  (Shape Circle)
  [#perimeter (/.method
                (function (_ next again [this _])
                  (all f.* +2.0 circle.pi (its #radius (/.state this)))))
   #area (/.method
           (function (_ next again [this _])
             (let [radius (its #radius (/.state this))]
               (all f.* circle.pi radius radius))))])

(every Square
  (Record
   [#side Frac]))

(the square
  (Shape Square)
  [#perimeter (/.method
                (function (_ next again [this _])
                  (all f.* +4.0 (its #side (/.state this)))))
   #area (/.method
           (function (_ next again [this _])
             (let [side (its #side (/.state this))]
               (all f.* side side))))])

(the (scaled scalar)
  (-> Frac (Shape Frac)
      (Shape Frac))
  (|>> (/.override #perimeter
                   (function (_ next again [this input])
                     (all f.*
                          scalar
                          (next [this input]))))
       (/.override #area
                   (function (_ next again [this input])
                     (all f.*
                          scalar scalar
                          (next [this input]))))))

(the value
  (Random Frac)
  (of random.functor each
      (|>> (n.% 100) n.frac)
      random.nat))

(the \\parser
  Test
  (<| (_.covering \\parser._)
      (_.for [\\parser.Parser])
      (do [! random.monad]
        [radius ..value
         side ..value])
      (all _.and
           (_.coverage [\\parser.any \\parser.value]
             (when (\\parser.value (is (\\parser.Parser Shape Frac)
                                       (do parser.monad
                                         [it (\\parser.any ..circle)]
                                         (in (/.state it))))
                                   (list (/.object ..circle [#radius radius])))
               {try.#Success actual}
               (same? radius actual)

               {try.#Failure _}
               false))
           (_.coverage [\\parser.wrong_class]
             (when (\\parser.value (is (\\parser.Parser Shape Frac)
                                       (do parser.monad
                                         [it (\\parser.any ..circle)]
                                         (in (/.state it))))
                                   (list (/.object ..square [#side side])))
               {try.#Failure error}
               (exception.is? \\parser.wrong_class error)

               {try.#Success _}
               false))
           )))

(the .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [radius ..value
         side ..value
         scale ..value])
      (_.for [/.Instance /.Object])
      (all _.and
           (_.coverage [/.object /.class]
             (|> [#side side]
                 (/.object ..square)
                 (is (/.Object Shape Square))
                 /.class
                 (same? ..square)))
           (_.coverage [/.state]
             (and (|> [#side side]
                      (/.object ..square)
                      (is (/.Object Shape Square))
                      /.state
                      (same? side))
                  (|> [#radius radius]
                      (/.object ..circle)
                      (is (/.Object Shape Circle))
                      /.state
                      (same? radius))))
           (_.coverage [/.Method
                        /.#complete /.#partial
                        
                        /.method /.on]
             (let [it (is (/.Object Shape Circle)
                          (/.object circle [#radius radius]))]
               (not (f.= (/.on #perimeter [] it)
                         (/.on #area [] it)))))
           (_.coverage [/.override]
             (and (f.= (/.on #perimeter [] (/.object ..square [#radius (f.* scale radius)]))
                       (/.on #perimeter [] (/.object (..scaled scale ..square) [#radius radius])))
                  (f.= (/.on #area [] (/.object ..square [#radius (f.* scale radius)]))
                       (/.on #area [] (/.object (..scaled scale ..square) [#radius radius])))))

           ..\\parser
           )))
