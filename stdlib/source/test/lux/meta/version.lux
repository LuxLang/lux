(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   ["[0]" static]
   ["[0]" meta]
   [abstract
    [monad {"+" do}]]
   [control
    ["[0]" try]
    ["[0]" exception]
    [parser
     ["<[0]>" code]]]
   [data
    ["[0]" text]]
   ["[0]" macro
    [syntax {"+" syntax:}]
    ["[0]" code]]
   [math
    ["[0]" random]
    [number
     ["n" nat]]]]]
 [\\library
  ["[0]" /]])

(syntax: (failure [it <code>.any])
  (function (_ lux)
    (case (macro.expansion it lux)
      {try.#Failure error}
      {try.#Success [lux (list (code.text error))]}
      
      {try.#Success _}
      {try.#Failure ""})))

(def: .public test
  Test
  (<| (_.covering /._)
      (with_expansions [<current> (/.current)
                        <fake> (static.random code.text (random.lower_case 1))])
      (all _.and
           (_.coverage [/.latest]
             (n.> 0 /.latest))
           (_.coverage [/.current]
             (not (text.empty? (/.current))))
           (_.coverage [/.for]
             (and (/.for <current> true
                         false)
                  (/.for <fake> false
                         true)))
           (_.coverage [/.invalid]
             (and (text.contains? (the exception.#label /.invalid)
                                  (..failure (/.for)))
                  (text.contains? (the exception.#label /.invalid)
                                  (..failure (/.for <fake> false)))))
           )))
