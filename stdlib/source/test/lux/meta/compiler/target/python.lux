... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except)
   ["[0]" ffi]
   [abstract
    [monad (.only do)]
    ["[0]" hash
     ["[1]T" \\test]]
    ["[0]" equivalence
     ["[1]T" \\test]]]
   [control
    ["[0]" maybe (.use "[1]#[0]" functor)]
    ["[0]" try (.only Try) (.use "[1]#[0]" functor)]
    ["[0]" function (.only)
     ["[0]" predicate]]]
   [data
    ["[0]" bit]
    ["[0]" text (.only)
     ["%" \\injection]]
    [collection
     ["[0]" list (.use "[1]#[0]" functor)]]]
   [math
    ["[0]" random (.only Random) (.use "[1]#[0]" monad)]
    [number
     ["n" nat]
     ["i" int]
     ["d" dec]
     ["[0]" i64]]]
   [meta
    ["[0]" static]
    ["[0]" code]
    [macro
     ["[0]" template]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" / (.use "[1]#[0]" equivalence)]])

(ffi.import (eval [Text] "try" "?" Any))

(the (expression ??? it)
  (-> (-> Any Bit) /.Expression Bit)
  (|> it
      /.code
      ..eval
      (try#each (|>> (maybe#each ???)
                     (maybe.else false)))
      (try.else false)))

(the test|literal
  Test
  (do [! random.monad]
    [bool random.bit
     float random.dec
     int random.int
     string (random.upper_cased 1)]
    (all _.and
         (_.coverage [/.none]
           (|> /.none
               /.code
               ..eval
               (try#each (function (_ it)
                           (when it
                             {.#None} true
                             {.#Some _} false)))
               (try.else false)))
         (_.coverage [/.bool]
           (expression (|>> (as Bit) (bit.= bool))
                       (/.bool bool)))
         (_.coverage [/.int]
           (expression (|>> (as Int) (i.= int))
                       (/.int int)))
         ... (_.coverage [/.long]
         ...          (expression (|>> (as Int) (i.= int))
         ...                      (/.long int)))
         (_.coverage [/.float]
           (expression (|>> (as Dec) (d.= float))
                       (/.float float)))
         (_.coverage [/.string]
           (expression (|>> (as Text) (text.= string))
                       (/.string string)))
         (_.coverage [/.unicode]
           (expression (|>> (as Text) (text.= string))
                       (/.unicode string)))
         )))

(the test|bool
  Test
  (do [! random.monad]
    [left random.bit
     right random.bit]
    (`` (all _.and
             (,, (template.with [</> <lux>]
                   [(_.coverage [</>]
                      (let [expected (<lux> left right)]
                        (expression (|>> (as Bit) (bit.= expected))
                                    (</> (/.bool left) (/.bool right)))))]

                   [/.or .or]
                   [/.and .and]
                   ))
             (_.coverage [/.not]
               (expression (|>> (as Bit) (bit.= (not left)))
                           (/.not (/.bool left))))
             ))))

(the test|float
  Test
  (do [! random.monad]
    [parameter (random.only (|>> (d.= +0.0) not)
                            random.safe_dec)
     subject random.safe_dec]
    (`` (all _.and
             (,, (template.with [</> <lux> <pre>]
                   [(_.coverage [</>]
                      (let [expected (<lux> (<pre> parameter) (<pre> subject))]
                        (expression (|>> (as Dec) (d.= expected))
                                    (</> (/.float (<pre> parameter)) (/.float (<pre> subject))))))]

                   [/.+ d.+ |>]
                   [/.- d.- |>]
                   [/.* d.* |>]
                   [/./ d./ |>]
                   [/.% d.mod |>]
                   [/.** d.pow d.abs]
                   ))
             (,, (template.with [</> <lux>]
                   [(_.coverage [</>]
                      (let [expected (<lux> parameter subject)]
                        (expression (|>> (as Bit) (bit.= expected))
                                    (</> (/.float parameter) (/.float subject)))))]

                   [/.<  d.<]
                   [/.<= d.<=]
                   [/.>  d.>]
                   [/.>= d.>=]
                   [/.=  d.=]
                   ))
             (_.coverage [/.float/1]
               (expression (|>> (as Dec) (d.= subject))
                           (/.float/1 (/.string (%.dec subject)))))
             (_.coverage [/.repr/1]
               (expression (|>> (as Text) (text.= (text.replaced "+" "" (%.dec subject))))
                           (/.repr/1 (/.float subject))))
             ))))

(the python_3?
  /.Expression
  (|> (/.__import__/1 (/.unicode "sys"))
      (/.its "version_info")
      (/.its "major")
      (/.= (/.int +3))))

(the int_16
  (-> Int Int)
  (i64.and (-- (i64.left_shifted 15 1))))

(the test|int
  Test
  (do [! random.monad]
    [left random.int
     right random.int

     i16 (of ! each ..int_16 random.int)
     shift (of ! each (n.% 16) random.nat)]
    (`` (all _.and
             (,, (template.with [</> <lux>]
                   [(_.coverage [</>]
                      (let [expected (<lux> left right)]
                        (expression (|>> (as Dec) d.int (i.= expected))
                                    (</> (/.int left) (/.int right)))))]

                   [/.bit_or i64.or]
                   [/.bit_xor i64.xor]
                   [/.bit_and i64.and]
                   ))
             (,, (template.with [</> <lux>]
                   [(_.coverage [</>]
                      (let [left (.int shift)
                            right (i.* (.int shift) i16)
                            expected (<lux> left right)]
                        (expression (|>> (as Int) (i.= expected))
                                    (</> (/.int left) (/.int right)))))]

                   [/.// i./]
                   ))
             (_.coverage [/.opposite]
               (expression (|>> (as Int) (i.= (i.* -1 left)))
                           (/.opposite (/.int left))))
             (_.coverage [/.bit_shl]
               (let [expected (i64.left_shifted shift i16)]
                 (expression (|>> (as Dec) d.int (i.= expected))
                             (/.bit_shl (/.int (.int shift))
                                        (/.int i16)))))
             (_.coverage [/.bit_shr]
               (let [expected (i.right_shifted shift i16)]
                 (expression (|>> (as Dec) d.int (i.= expected))
                             (/.bit_shr (/.int (.int shift))
                                        (/.int i16)))))
             (_.coverage [/.int/1]
               (expression (|>> (as Int) (i.= left))
                           (/.int/1 (/.string (%.int left)))))
             (_.coverage [/.str/1]
               (expression (|>> (as Text) (text.= (text.replaced "+" "" (%.int left))))
                           (/.str/1 (/.int left))))
             (_.coverage [/.long]
               (or (expression (|>> (as Bit))
                               ..python_3?)
                   (expression (|>> (as Int) (i.= left))
                               (/.long left))))
             ))))

(the test|text
  Test
  (do [! random.monad]
    [expected_code (of ! each (n.% 128) random.nat)
     .let [expected_char (text.of_char expected_code)]]
    (all _.and
         (_.coverage [/.chr/1 /.ord/1
                      /.unichr/1 /.unicode/1]
           (and (expression (|>> (as Int) .nat (n.= expected_code))
                            (/.? python_3?
                                 (/.ord/1 (/.chr/1 (/.int (.int expected_code))))
                                 (/.unicode/1 (/.unichr/1 (/.int (.int expected_code))))))
                (expression (|>> (as Text) (text.= expected_char))
                            (/.? python_3?
                                 (/.chr/1 (/.ord/1 (/.string expected_char)))
                                 (/.unichr/1 (/.unicode/1 (/.string expected_char)))))))
         )))

(the test|array
  Test
  (do [! random.monad]
    [size (of ! each (|>> (n.% 10) ++) random.nat)
     index (of ! each (n.% size) random.nat)
     items (random.list size random.safe_dec)
     .let [expected (|> items
                        (list.item index)
                        (try.else d.not_a_number))]
     from (of ! each (n.% size) random.nat)
     plus (of ! each (n.% (n.- from size)) random.nat)
     .let [slice_from|size (n.- from size)
           to (/.int (.int (n.+ plus from)))
           from (/.int (.int from))]]
    (all _.and
         (_.for [/.item]
                (all _.and
                     (_.coverage [/.list]
                       (expression (|>> (as Dec) (d.= expected))
                                   (/.item (/.int (.int index))
                                           (/.list (list#each /.float items)))))
                     (_.coverage [/.tuple]
                       (expression (|>> (as Dec) (d.= expected))
                                   (/.item (/.int (.int index))
                                           (/.tuple (list#each /.float items)))))))
         (_.coverage [/.slice /.len/1]
           (expression (|>> (as Int) (i.= (.int plus)))
                       (|> (/.list (list#each /.float items))
                           (/.slice from to)
                           /.len/1)))
         (_.coverage [/.slice_from]
           (expression (|>> (as Int) (i.= (.int slice_from|size)))
                       (|> (/.list (list#each /.float items))
                           (/.slice_from from)
                           /.len/1)))
         )))

(the test|dict
  Test
  (do [! random.monad]
    [expected random.safe_dec
     field (random.upper_cased 5)
     dummy (random.only (|>> (text.= field) not)
                        (random.upper_cased 5))
     .let [field (/.string field)
           dummy (/.string dummy)]]
    (all _.and
         (_.coverage [/.dict]
           (expression (|>> (as Dec) (d.= expected))
                       (/.item field (/.dict (list [field (/.float expected)])))))
         (_.coverage [/.in?]
           (and (expression (|>> (as Bit) not)
                            (/.in? (/.dict (list)) field))
                (expression (|>> (as Bit))
                            (/.in? (/.dict (list [field (/.float expected)])) field))))
         )))

(the test|computation
  Test
  (do [! random.monad]
    [test random.bit
     then random.safe_dec
     else random.safe_dec

     bool random.bit
     float (random.only (|>> d.not_a_number? not) random.dec)
     string (random.upper_cased 5)

     comment (random.upper_cased 10)
     $arg/0 (of ! each /.var (random.lower_cased 10))
     $arg/1 (of ! each /.var (random.lower_cased 11))]
    (all _.and
         ..test|bool
         ..test|float
         ..test|int
         ..test|text
         ..test|array
         ..test|dict
         (_.coverage [/.?]
           (let [expected (if test then else)]
             (expression (|>> (as Dec) (d.= expected))
                         (/.? (/.bool test)
                              (/.float then)
                              (/.float else)))))
         (_.coverage [/.comment]
           (expression (|>> (as Dec) (d.= then))
                       (/.comment comment
                         (/.float then))))
         (_.coverage [/.__import__/1]
           (expression (function.constant true)
                       (/.__import__/1 (/.string "math"))))
         (_.coverage [/.do]
           (expression (|>> (as Dec) (d.= (d.ceil float)))
                       (|> (/.__import__/1 (/.string "math"))
                           (/.do "ceil" (list (/.float float))))))
         (_.coverage [/.is]
           (and (expression (|>> (as Bit))
                            (/.apply (list (/.string (%.message string string)))
                                     (/.lambda (list $arg/0)
                                               (/.is $arg/0 $arg/0))))
                (expression (|>> (as Bit) not)
                            (/.apply (list (/.string (%.message string string))
                                           (/.string string))
                                     (/.lambda (list $arg/0 $arg/1)
                                               (/.is $arg/0 (/.+ $arg/1 $arg/1)))))))
         )))

(the test|function
  Test
  (do [! random.monad]
    [float/0 random.safe_dec
     float/1 random.safe_dec
     float/2 random.safe_dec
     $arg/0 (of ! each /.var (random.lower_cased 10))
     $arg/1 (of ! each /.var (random.lower_cased 11))
     $arg/2 (of ! each /.var (random.lower_cased 12))]
    (all _.and
         (_.coverage [/.lambda]
           (expression (|>> (as Dec) (d.= float/0))
                       (/.apply (list)
                                (/.lambda (list)
                                          (/.float float/0)))))
         (_.coverage [/.apply]
           (expression (|>> (as Dec) (d.= (all d.+ float/0 float/1 float/2)))
                       (/.apply (list (/.float float/0) (/.float float/1) (/.float float/2))
                                (/.lambda (list $arg/0 $arg/1 $arg/2)
                                          (all /.+ $arg/0 $arg/1 $arg/2)))))
         )))

(the test|var
  Test
  (do [! random.monad]
    [expected/0 random.safe_dec
     expected/1 random.safe_dec
     poly_choice (of ! each (n.% 2) random.nat)
     .let [keyword (|>> %.nat (%.message "k") /.string)
           keyword/0 (keyword 0)
           keyword/1 (keyword 1)
           keyword_choice (keyword poly_choice)]
     .let [expected/? (when poly_choice
                        0 expected/0
                        _ expected/1)]
     $var (of ! each (|>> %.nat (%.message "v") /.var) random.nat)
     $choice (of ! each (|>> %.nat (%.message "c") /.var) random.nat)]
    (all _.and
         (_.coverage [/.SVar /.var]
           (expression (|>> (as Dec) (d.= expected/0))
                       (/.apply (list (/.float expected/0))
                                (/.lambda (list $var) $var))))
         (_.for [/.PVar]
                (all _.and
                     (_.coverage [/.poly]
                       (expression (|>> (as Dec) (d.= expected/?))
                                   (/.apply (list (/.int (.int poly_choice))
                                                  (/.float expected/0)
                                                  (/.float expected/1))
                                            (/.lambda (list $choice (/.poly $var))
                                                      (/.item $choice $var)))))
                     (_.coverage [/.splat_poly]
                       (expression (|>> (as Dec) (d.= expected/?))
                                   (/.apply (list (/.int (.int poly_choice))
                                                  (/.splat_poly
                                                   (/.list (list (/.float expected/0)
                                                                 (/.float expected/1)))))
                                            (/.lambda (list $choice (/.poly $var))
                                                      (/.item $choice $var)))))
                     ))
         (_.for [/.KVar]
                (all _.and
                     (_.coverage [/.keyword]
                       (expression (|>> (as Nat) (n.= 2))
                                   (/.apply (list keyword_choice
                                                  (/.splat_keyword
                                                   (/.dict (list [keyword/0 (/.float expected/0)]
                                                                 [keyword/1 (/.float expected/1)]))))
                                            (/.lambda (list $choice (/.keyword $var))
                                                      (/.len/1 $var)))))
                     (_.coverage [/.splat_keyword]
                       (expression (|>> (as Dec) (d.= expected/?))
                                   (/.apply (list keyword_choice
                                                  (/.splat_keyword
                                                   (/.dict (list [keyword/0 (/.float expected/0)]
                                                                 [keyword/1 (/.float expected/1)]))))
                                            (/.lambda (list $choice (/.keyword $var))
                                                      (/.item $choice $var)))))
                     ))
         )))

(the test|expression
  Test
  (do [! random.monad]
    [dummy random.safe_dec
     expected random.safe_dec]
    (`` (all _.and
             (_.for [/.Literal]
                    ..test|literal)
             (_.for [/.Computation]
                    ..test|computation)
             ..test|function
             (_.for [/.Var]
                    ..test|var)
             ))))

(ffi.import Dict
  "[1]::[0]"
  (get [ffi.String] Any))

(ffi.import (dict [] ..Dict))

(the (statement it)
  (-> (-> /.SVar /.Statement) Any)
  (let [$output (static.random (|>> %.nat (%.message "output_") code.text)
                               random.nat)
        environment (..dict [])]
    (exec
      (.python_exec# (/.code (it (/.var $output))) (as_expected environment))
      (Dict::get $output environment))))

(the test|access
  Test
  (do [! random.monad]
    [$var/0 (of ! each (|>> %.nat (%.message "v0_") /.var) random.nat)
     expected/0 random.safe_dec
     dummy/0 random.safe_dec
     field (of ! each /.string (random.upper_cased 1))]
    (all _.and
         (_.coverage [/.item]
           (`` (and (,, (template.with [<seq>]
                          [(expression (|>> (as Dec) (d.= expected/0))
                                       (/.item (/.int +0)
                                               (<seq> (list (/.float expected/0)))))]

                          [/.list]
                          [/.tuple]
                          ))
                    (|> (..statement
                         (function (_ $output)
                           (all /.then
                                (/.set (list $var/0) (/.list (list (/.float dummy/0))))
                                (/.set (list (/.item (/.int +0) $var/0)) (/.float expected/0))
                                (/.set (list $output) (/.item (/.int +0) $var/0)))))
                        (as Dec)
                        (d.= expected/0))

                    (expression (|>> (as Dec) (d.= expected/0))
                                (/.item field (/.dict (list [field (/.float expected/0)]))))
                    (|> (..statement
                         (function (_ $output)
                           (all /.then
                                (/.set (list $var/0) (/.dict (list [field (/.float dummy/0)])))
                                (/.set (list (/.item field $var/0)) (/.float expected/0))
                                (/.set (list $output) (/.item field $var/0)))))
                        (as Dec)
                        (d.= expected/0)))))
         )))

(the test|location
  Test
  (do [! random.monad]
    [$var/0 (of ! each (|>> %.nat (%.message "v0_") /.var) random.nat)
     $var/1 (of ! each (|>> %.nat (%.message "v1_") /.var) random.nat)
     $def (of ! each (|>> %.nat (%.message "def_") /.var) random.nat)
     expected/0 random.safe_dec
     expected/1 random.safe_dec
     dummy/0 random.safe_dec
     field/0 (of ! each /.string (random.upper_cased 1))]
    (all _.and
         (_.coverage [/.set]
           (|> (..statement
                (function (_ $output)
                  (all /.then
                       (/.set (list $var/0) (/.float expected/0))
                       (/.set (list $output) $var/0))))
               (as Dec)
               (d.= expected/0)))
         (_.coverage [/.multi]
           (`` (and (,, (template.with [<var> <value>]
                          [(|> (..statement
                                (function (_ $output)
                                  (all /.then
                                       (/.set (list $var/0 $var/1) (/.multi (list (/.float expected/0) (/.float expected/1))))
                                       (/.set (list $output) <var>))))
                               (as Dec)
                               (d.= <value>))]

                          [$var/0 expected/0]
                          [$var/1 expected/1]
                          )))))
         (_.coverage [/.delete]
           (and (|> (..statement
                     (function (_ $output)
                       (all /.then
                            (/.set (list $var/0) (/.list (list (/.float dummy/0) (/.float expected/0))))
                            (/.delete (/.item (/.int +0) $var/0))
                            (/.set (list $output) (/.item (/.int +0) $var/0)))))
                    (as Dec)
                    (d.= expected/0))
                (|> (..statement
                     (function (_ $output)
                       (all /.then
                            (/.set (list $var/0) (/.list (list (/.float dummy/0) (/.float expected/0))))
                            (/.delete (/.slice (/.int +0) (/.int +1) $var/0))
                            (/.set (list $output) (/.item (/.int +0) $var/0)))))
                    (as Dec)
                    (d.= expected/0))
                (|> (..statement
                     (function (_ $output)
                       (all /.then
                            (/.set (list $var/0) (/.list (list (/.float dummy/0) (/.float dummy/0))))
                            (/.delete (/.slice_from (/.int +0) $var/0))
                            (/.statement (/.do "append" (list (/.float expected/0)) $var/0))
                            (/.set (list $output) (/.item (/.int +0) $var/0)))))
                    (as Dec)
                    (d.= expected/0))
                (|> (..statement
                     (function (_ $output)
                       (all /.then
                            (/.set (list $var/0) (/.dict (list [field/0 (/.float dummy/0)])))
                            (/.delete (/.item field/0 $var/0))
                            (/.set (list $output) (/.in? $var/0 field/0)))))
                    (as Bit)
                    not)
                (|> (..statement
                     (function (_ $output)
                       (all /.then
                            (/.set (list $var/0) (/.float dummy/0))
                            (/.delete $var/0)
                            (/.set (list $output) (/.or (/.in? /.locals/0 (/.string (/.code $var/0)))
                                                        (/.in? /.globals/0 (/.string (/.code $var/0))))))))
                    (as Bit)
                    not)
                ))
         (_.coverage [/.globals/0]
           (|> (..statement
                (function (_ $output)
                  (all /.then
                       (/.def $def (list $var/0)
                              (/.return (/.in? /.globals/0 (/.string (/.code $var/0)))))
                       (/.set (list $output) (/.and (/.not (/.in? /.globals/0 (/.string (/.code $var/0))))
                                                    (/.not (/.apply (list (/.float dummy/0)) $def))))
                       (/.set (list $var/0) (/.float dummy/0))
                       (/.set (list $output) (/.and $output
                                                    (/.in? /.globals/0 (/.string (/.code $var/0))))))))
               (as Bit)))
         (_.coverage [/.locals/0]
           (|> (..statement
                (function (_ $output)
                  (all /.then
                       (/.def $def (list $var/0)
                              (/.return (/.in? /.locals/0 (/.string (/.code $var/0)))))
                       (/.set (list $output) (/.and (/.not (/.in? /.locals/0 (/.string (/.code $var/0))))
                                                    (/.apply (list (/.float dummy/0)) $def)))
                       (/.set (list $var/0) (/.float dummy/0))
                       (/.set (list $output) (/.and $output
                                                    (/.in? /.locals/0 (/.string (/.code $var/0))))))))
               (as Bit)))
         (_.coverage [/.import]
           (|> (..statement
                (function (_ $output)
                  (all /.then
                       (/.import "math")
                       (/.set (list $output) (/.in? /.globals/0 (/.string "math"))))))
               (as Bit)))
         (_.for [/.Access]
                ..test|access)
         )))

(the test|exception
  Test
  (do [! random.monad]
    [expected_error (random.upper_cased 10)
     expected random.safe_dec
     dummy (random.only (|>> (d.= expected) not)
                        random.safe_dec)
     $ex (of ! each (|>> %.nat (%.message "ex_") /.var) random.nat)]
    (all _.and
         (_.coverage [/.raise /.Exception/1]
           (when (try (..statement
                       (function (_ $output)
                         (all /.then
                              (/.raise (/.Exception/1 (/.string expected_error)))
                              (/.set (list $output) (/.float dummy))))))
             {try.#Failure actual_error}
             (text.= expected_error actual_error)
             
             {try.#Success _}
             false))
         (_.coverage [/.try /.Except]
           (and (|> (..statement
                     (function (_ $output)
                       (/.try (all /.then
                                   (/.raise (/.Exception/1 (/.string expected_error)))
                                   (/.set (list $output) (/.float dummy)))
                              (list [/.#classes (list "Exception")
                                     /.#exception $ex
                                     /.#handler (/.set (list $output) (/.float expected))]))))
                    (as Dec)
                    (d.= expected))
                (when (try (..statement
                            (function (_ $output)
                              (/.try (all /.then
                                          (/.raise (/.Exception/1 (/.string expected_error)))
                                          (/.set (list $output) (/.float dummy)))
                                     (list [/.#classes (list)
                                            /.#exception $ex
                                            /.#handler (/.set (list $output) (/.float expected))])))))
                  {try.#Failure actual_error}
                  (text.= expected_error actual_error)
                  
                  {try.#Success actual}
                  false)))
         )))

(the test|loop
  Test
  (do [! random.monad]
    [base (of ! each (n.% 100) random.nat)
     factor (of ! each (|>> (n.% 10) ++) random.nat)
     extra (of ! each (|>> (n.% 10) ++) random.nat)
     .let [expected (n.* factor base)]
     $iteration (of ! each (|>> %.nat (%.message "iteration_") /.var) random.nat)
     $temp (of ! each (|>> %.nat (%.message "temp_") /.var) random.nat)]
    (all _.and
         (_.coverage [/.while]
           (and (|> (..statement
                     (function (_ $output)
                       (all /.then
                            (/.set (list $output) (/.int +0))
                            (/.set (list $iteration) (/.int +0))
                            (/.while (/.< (/.int (.int factor)) $iteration)
                                     (all /.then
                                          (/.set (list $output) (/.+ (/.int (.int base))
                                                                     $output))
                                          (/.set (list $iteration) (/.+ (/.int +1)
                                                                        $iteration))
                                          )
                                     {.#None}))))
                    (as Nat)
                    (n.= expected))
                (|> (..statement
                     (function (_ $output)
                       (all /.then
                            (/.set (list $temp) (/.int +0))
                            (/.set (list $iteration) (/.int +0))
                            (/.while (/.< (/.int (.int factor)) $iteration)
                                     (all /.then
                                          (/.set (list $temp) (/.+ (/.int (.int base))
                                                                   $temp))
                                          (/.set (list $iteration) (/.+ (/.int +1)
                                                                        $iteration))
                                          )
                                     {.#Some (/.set (list $output) $temp)}))))
                    (as Nat)
                    (n.= expected))))
         (_.coverage [/.for_in]
           (|> (..statement
                (function (_ $output)
                  (all /.then
                       (/.set (list $output) (/.int +0))
                       (/.for_in $iteration
                                 (/.list (list.repeated factor (/.int (.int base))))
                                 (/.set (list $output) (/.+ $iteration
                                                            $output))))))
               (as Nat)
               (n.= expected)))
         (_.coverage [/.pass]
           (|> (..statement
                (function (_ $output)
                  (all /.then
                       (/.set (list $output) (/.int +0))
                       (/.set (list $iteration) (/.int +0))
                       (/.while (/.< (/.int (.int (n.+ extra factor))) $iteration)
                                (all /.then
                                     (/.set (list $iteration) (/.+ (/.int +1)
                                                                   $iteration))
                                     (/.if (/.> (/.int (.int extra)) $iteration)
                                       (/.set (list $output) (/.+ (/.int (.int base))
                                                                  $output))
                                       /.pass))
                                {.#None}))))
               (as Nat)
               (n.= expected)))
         (_.coverage [/.continue]
           (|> (..statement
                (function (_ $output)
                  (all /.then
                       (/.set (list $output) (/.int +0))
                       (/.set (list $iteration) (/.int +0))
                       (/.while (/.< (/.int (.int (n.+ extra factor))) $iteration)
                                (all /.then
                                     (/.set (list $iteration) (/.+ (/.int +1)
                                                                   $iteration))
                                     (/.if (/.> (/.int (.int extra)) $iteration)
                                       (/.set (list $output) (/.+ (/.int (.int base))
                                                                  $output))
                                       /.continue))
                                {.#None}))))
               (as Nat)
               (n.= expected)))
         (_.coverage [/.break]
           (|> (..statement
                (function (_ $output)
                  (all /.then
                       (/.set (list $output) (/.int +0))
                       (/.set (list $iteration) (/.int +0))
                       (/.while (/.< (/.int (.int (n.+ extra factor))) $iteration)
                                (all /.then
                                     (/.set (list $iteration) (/.+ (/.int +1)
                                                                   $iteration))
                                     (/.if (/.> (/.int (.int factor)) $iteration)
                                       /.break
                                       (/.set (list $output) (/.+ (/.int (.int base))
                                                                  $output))))
                                {.#None}))))
               (as Nat)
               (n.= expected)))
         )))

(the test|statement
  Test
  (do [! random.monad]
    [$def (of ! each (|>> %.nat (%.message "def_") /.var) random.nat)
     $input/0 (of ! each (|>> %.nat (%.message "input_") /.var) random.nat)
     expected/0 random.safe_dec
     test random.bit
     then random.safe_dec
     else random.safe_dec
     .let [expected/? (if test then else)]]
    (all _.and
         (_.coverage [/.def /.return]
           (|> (..statement
                (function (_ $output)
                  (all /.then
                       (/.def $def (list $input/0)
                              (/.return $input/0))
                       (/.set (list $output) (/.apply (list (/.float expected/0)) $def)))))
               (as Dec)
               (d.= expected/0)))
         (_.coverage [/.if]
           (|> (..statement
                (function (_ $output)
                  (all /.then
                       (/.def $def (list)
                              (/.if (/.bool test)
                                (/.return (/.float then))
                                (/.return (/.float else))))
                       (/.set (list $output) (/.apply (list) $def)))))
               (as Dec)
               (d.= expected/?)))
         (_.coverage [/.when /.then]
           (|> (..statement
                (function (_ $output)
                  (all /.then
                       (/.def $def (list)
                              (all /.then
                                   (/.when (/.bool test)
                                     (/.return (/.float then)))
                                   (/.return (/.float else))))
                       (/.set (list $output) (/.apply (list) $def)))))
               (as Dec)
               (d.= expected/?)))
         (_.coverage [/.statement]
           (|> (..statement
                (function (_ $output)
                  (all /.then
                       (/.def $def (list)
                              (all /.then
                                   (/.statement (/.+ (/.float expected/0) (/.float expected/0)))
                                   (/.return (/.float expected/0))))
                       (/.set (list $output) (/.apply (list) $def)))))
               (as Dec)
               (d.= expected/0)))
         (_.coverage [/.exec]
           (|> (..statement
                (function (_ $output)
                  (/.exec {.#Some /.globals/0}
                    (/.string (/.code (/.set (list $output) (/.float expected/0)))))))
               (as Dec)
               (d.= expected/0)))
         ..test|exception
         (_.for [/.Location]
                ..test|location)
         (_.for [/.Loop]
                ..test|loop)
         )))

(the random_expression
  (Random /.Literal)
  (all random.either
       (random#each /.bool random.bit)
       (random#each /.float random.dec)
       (random#each /.int random.int)
       (random#each /.string (random.lower_cased 1))
       ))

(the .public test
  Test
  (do [! random.monad]
    [expected ..random_expression]
    (<| (_.covering /._)
        (_.for [/.Code])
        (all _.and
             (_.for [/.equivalence]
                    (equivalenceT.spec /.equivalence ..random_expression))
             (_.for [/.hash]
                    (hashT.spec /.hash ..random_expression))
             
             (_.coverage [/.code /.manual]
               (|> (/.manual (/.code expected))
                   (is /.Expression)
                   (/#= expected)))
             (_.for [/.Expression]
                    ..test|expression)
             (_.for [/.Statement]
                    ..test|statement)
             ))))
