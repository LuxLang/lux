... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]
    ["[0]" equivalence
     ["[1]T" \\test]]
    ["[0]" hash
     ["[1]T" \\test]]]
   [data
    ["[0]" bit]
    ["[0]" binary (.only)
     ["![1]" \\injection]]
    [collection
     ["[0]" list]
     ["[0]" set]]]
   [math
    ["[0]" random (.only Random) (.use "[1]#[0]" monad)]
    [number
     ["n" natural]
     ["i" integer]]]
   [meta
    ["[0]" static]
    [macro
     ["[0]" expansion]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" / (.only)
   [///
    [encoding
     ["[0]" signed]]]]]
 [///
  [encoding
   ["[0]T" signed]]])

(expansion.let [,tags (these /.utf8
                             /.integer
                             /.float
                             /.long
                             /.double
                             /.class
                             /.string
                             /.field
                             /.method
                             /.interface_method
                             /.name_and_type
                             /.method_handle
                             /.method_type
                             /.invoke_dynamic)]
  (these (the .public random
           (Random /.Tag)
           (let [options (list ,tags)]
             (random.try
              (do [! random.monad]
                [choice (by ! each (n.% (list.size options))
                            random.natural)]
                (in (list.item choice options))))))

         (the .public test
           Test
           (<| (_.covering /._)
               (do [! random.monad]
                 [expected_0 ..random
                  expected_1 ..random])
               (_.for [/.Tag])
               (all _.and
                    (_.for [/.equivalence /.=]
                           (static.when (same? /.equivalence /.=)
                             (equivalenceT.spec /.equivalence ..random)))
                    (_.for [/.hash]
                           (hashT.spec /.hash ..random))

                    (_.coverage [,tags]
                      (let [options (list ,tags)
                            unique (set.of_list /.hash options)]
                        (n.= (list.size options)
                             (set.size unique))))
                    (_.coverage [/.injection]
                      (bit.= (/.= expected_0 expected_1)
                             (binary.= (!binary.value /.injection expected_0)
                                       (!binary.value /.injection expected_1))))
                    )))))
