... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]
    ["[0]" equivalence
     ["[1]T" \\test]]
    ["[0]" hash
     ["[1]T" \\test]]]
   [control
    [function
     ["?" predicate]]]
   [data
    ["[0]" text]
    [collection
     ["[0]" list (.use "[1]#[0]" functor)]
     ["[0]" set]]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" natural]]]
   [meta
    ["[0]" static]
    [macro
     ["[0]" expansion]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" / (.only)
   [//
    ["[0]" category]
    ["[0]" box]]]])

(<| (expansion.let [,*primitives (these /.boolean
                                        /.byte
                                        /.short
                                        /.int
                                        /.long
                                        /.float
                                        /.double
                                        /.char)
                    ,*simple (these /.void
                                    ,*primitives)
                    ,*objects (these /.var
                                     /.wildcard)
                    ,*boxes (these box.boolean
                                   box.byte
                                   box.short
                                   box.int
                                   box.long
                                   box.float
                                   box.double
                                   box.char)])
    (these (the .public random
             (Random (/.Reflection category.Value))
             (let [primitives (is (List (/.Reflection category.Primitive))
                                  (list ,*primitives))
                   primitives_amount (list.size primitives)

                   boxes (list ,*boxes)
                   boxes_amount (list.size boxes)]
               (all random.either
                    (do [! random.monad]
                      [choice (of ! each (n.% primitives_amount) random.natural)]
                      (random.try (in (list.item choice primitives))))
                    (do [! random.monad]
                      [choice (of ! each (n.% boxes_amount) random.natural)
                       choice (random.try (in (list.item choice boxes)))]
                      (in (/.class choice)))))))
    (the .public test
      Test
      (<| (_.covering /._)
          (do [! random.monad]
            [argument_0 ..random
             argument_1 ..random
             return (is (Random (/.Reflection category.Return))
                        (all random.either
                             (in /.void)
                             ..random))])
          (_.for [/.Reflection])
          (all _.and
               (_.for [/.equivalence /.=]
                      (static.when (same? /.equivalence /.=)
                        (equivalenceT.spec /.equivalence ..random)))
               (_.for [/.hash]
                      (hashT.spec /.hash ..random))

               (_.coverage [,*simple]
                 (let [options (is (List (/.Reflection category.Return))
                                   (list ,*simple))
                       uniques (set.of_list /.hash options)]
                   (n.= (list.size options)
                        (set.size uniques))))
               (_.coverage [,*objects]
                 (let [options (is (List (/.Reflection category.Return))
                                   (list ,*objects))
                       uniques (set.of_list /.hash options)]
                   (n.= 1
                        (set.size uniques))))
               (_.coverage [/.reflection]
                 (let [options (<| (list#each /.reflection)
                                   (is (List (/.Reflection category.Return)))
                                   (list ,*simple))
                       uniques (set.of_list text.hash options)]
                   (n.= (list.size options)
                        (set.size uniques))))
               
               (_.coverage [/.class]
                 (let [options (is (List (/.Reflection category.Class))
                                   (list#each /.class (list ,*boxes)))
                       uniques (set.of_list /.hash options)]
                   (n.= (list.size options)
                        (set.size uniques))))
               (_.coverage [/.declaration /.as_class]
                 (let [expected (is (List (/.Reflection category.Class))
                                    (list#each (|>> /.declaration /.as_class) (list ,*boxes)))
                       actual (is (List (/.Reflection category.Class))
                                  (list#each /.class (list ,*boxes)))]
                   (of (list.equivalence /.equivalence) =
                       expected
                       actual)))
               (_.coverage [/.lower]
                 (let [options (is (List (/.Reflection category.Parameter))
                                   (list#each (|>> /.class /.lower) (list ,*boxes)))
                       uniques (set.of_list /.hash options)]
                   (n.= 1
                        (set.size uniques))))
               (_.coverage [/.upper]
                 (let [options (is (List (/.Reflection category.Parameter))
                                   (list#each (|>> /.class /.upper) (list ,*boxes)))
                       uniques (set.of_list /.hash options)]
                   (n.= (list.size options)
                        (set.size uniques))))
               (_.coverage [/.array]
                 (and (let [options (is (List (/.Reflection category.Array))
                                        (list#each (|>> /.class /.array) (list ,*boxes)))
                            uniques (set.of_list /.hash options)]
                        (n.= (list.size options)
                             (set.size uniques)))
                      (let [single (list#each (|>> /.class /.array) (list ,*boxes))
                            double (list#each /.array single)]
                        (not (of (list.equivalence /.equivalence) =
                                 single
                                 double)))))
               ))))
