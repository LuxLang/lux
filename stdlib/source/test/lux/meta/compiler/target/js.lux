... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" pipe]
    ["[0]" maybe (.use "[1]#[0]" functor)]
    ["[0]" try (.only Try) (.use "[1]#[0]" functor)]
    ["[0]" function (.only)
     ["[0]" predicate]]]
   [data
    ["[0]" bit]
    ["[0]" text (.only \n)
     ["%" \\injection]]
    [collection
     ["[0]" list (.use "[1]#[0]" functor)]]]
   [math
    ["[0]" random (.only Random) (.use "[1]#[0]" monad)]
    [number
     ["n" natural]
     ["i" int]
     ["d" dec]
     ["[0]" i64]]]
   [meta
    ["[0]" static]
    [macro
     ["[0]" template]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" /]])

(the (eval code)
  (-> /.Expression (Try (Maybe Any)))
  ... Note: I have to call "eval" this way
  ... in order to avoid a quirk of calling eval in Node
  ... when the code is running under "use strict";.
  (try (let [return (.js_apply# (function.identity (.js_constant# "eval")) [(/.code code)])]
         (if (.js_object_null?# return)
           {.#None}
           {.#Some return}))))

(the (expression ??? it)
  (-> (-> Any Bit) /.Expression Bit)
  (|> it
      ..eval
      (try#each (|>> (maybe#each ???)
                     (try.else false)))
      (try.else false)))

(template.with [<range>]
  [(`` (the (,, (template.symbol ["as_int_" <range>]))
         (-> Int Int)
         (|>> (i64.and (static.natural (-- (i64.left_shifted <range> 1)))))))
   (`` (the (,, (template.symbol ["int_" <range>]))
         (Random Int)
         (do [! random.monad]
           [negative? random.bit
            mantissa (of ! each (|>> (i64.and (static.natural (-- (i64.left_shifted (-- <range>) 1))))
                                     .int)
                         random.natural)]
           (in (if negative?
                 (i.* -1 mantissa)
                 mantissa)))))]

  [16]
  [32]
  )

(the test|literal
  Test
  (do [! random.monad]
    [boolean random.bit
     number random.dec
     int ..int_32
     string (random.upper_cased 5)]
    (all _.and
         (_.coverage [/.null]
           (|> /.null
               ..eval
               (try#each (function (_ it)
                           (when it
                             {.#None} true
                             {.#Some _} false)))
               (try.else false)))
         (_.coverage [/.boolean]
           (expression (|>> (as Bit) (bit.= boolean))
                       (/.boolean boolean)))
         (_.coverage [/.number]
           (expression (|>> (as Dec) (d.= number))
                       (/.number number)))
         (_.coverage [/.int]
           (expression (|>> (as Dec) d.int (i.= int))
                       (/.int int)))
         (_.coverage [/.string]
           (expression (|>> (as Text) (text.= string))
                       (/.string string)))
         )))

(the test|boolean
  Test
  (do [! random.monad]
    [left random.bit
     right random.bit]
    (`` (all _.and
             (,, (template.with [<js> <lux>]
                   [(_.coverage [<js>]
                      (let [expected (<lux> left right)]
                        (expression (|>> (as Bit) (bit.= expected))
                                    (<js> (/.boolean left) (/.boolean right)))))]

                   [/.or .or]
                   [/.and .and]
                   ))
             (_.coverage [/.not]
               (expression (|>> (as Bit) (bit.= (not left)))
                           (/.not (/.boolean left))))
             ))))

(the test|number
  Test
  (do [! random.monad]
    [parameter (random.only (|>> (d.= +0.0) not)
                            random.safe_dec)
     subject random.safe_dec]
    (`` (all _.and
             (,, (template.with [<js> <lux>]
                   [(_.coverage [<js>]
                      (let [expected (<lux> parameter subject)]
                        (expression (|>> (as Dec) (d.= expected))
                                    (<js> (/.number parameter) (/.number subject)))))]

                   [/.+ d.+]
                   [/.- d.-]
                   [/.* d.*]
                   [/./ d./]
                   [/.% d.%]
                   ))
             (,, (template.with [<js> <lux>]
                   [(_.coverage [<js>]
                      (let [expected (<lux> parameter subject)]
                        (expression (|>> (as Bit) (bit.= expected))
                                    (<js> (/.number parameter) (/.number subject)))))]

                   [/.<  d.<]
                   [/.<= d.<=]
                   [/.>  d.>]
                   [/.>= d.>=]
                   [/.=  d.=]
                   ))
             ))))

(the test|i32
  Test
  (do [! random.monad]
    [left ..int_32
     right ..int_32

     i32 ..int_32
     i16 ..int_16
     shift (of ! each (n.% 16) random.natural)]
    (`` (all _.and
             (,, (template.with [<js> <lux>]
                   [(_.coverage [<js>]
                      (let [expected (<lux> left right)]
                        (expression (|>> (as Dec) d.int (i.= expected))
                                    (<js> (/.int left) (/.int right)))))]

                   [/.bit_or i64.or]
                   [/.bit_xor i64.xor]
                   [/.bit_and i64.and]
                   ))
             (_.coverage [/.opposite]
               (expression (|>> (as Dec) d.int (i.= (i.* -1 i32)))
                           (/.opposite (/.i32 i32))))

             (_.coverage [/.i32]
               (expression (|>> (as Dec) d.int (i.= i32))
                           (/.i32 i32)))
             (_.coverage [/.to_i32]
               (expression (|>> (as Dec) d.int (i.= i32))
                           (/.to_i32 (/.int i32))))
             (_.coverage [/.left_shift]
               (let [expected (i64.left_shifted shift i16)]
                 (expression (|>> (as Dec) d.int (i.= expected))
                             (/.left_shift (/.int (.int shift))
                                           (/.i32 i16)))))
             (_.coverage [/.logic_right_shift]
               (let [expected (i64.right_shifted shift (as_int_32 i16))]
                 (expression (|>> (as Dec) d.int (i.= expected))
                             (/.logic_right_shift (/.int (.int shift))
                                                  (/.i32 i16)))))
             (_.coverage [/.arithmetic_right_shift]
               (let [expected (i.right_shifted shift i16)]
                 (expression (|>> (as Dec) d.int (i.= expected))
                             (/.arithmetic_right_shift (/.int (.int shift))
                                                       (/.i32 i16)))))
             (_.coverage [/.bit_not]
               (let [expected (if (i.< +0 i32)
                                (as_int_32 (i64.not i32))
                                (i64.not (as_int_32 i32)))]
                 (expression (|>> (as Dec) d.int (i.= expected))
                             (/.bit_not (/.i32 i32)))))
             ))))

(the test|array
  Test
  (do [! random.monad]
    [size (of ! each (|>> (n.% 10) ++) random.natural)
     index (of ! each (n.% size) random.natural)
     items (random.list size random.safe_dec)
     .let [expected (|> items
                        (list.item index)
                        (try.else d.not_a_number))]]
    (all _.and
         (_.coverage [/.array /.at]
           (and (expression (|>> (as Dec) (d.= expected))
                            (/.at (/.int (.int index))
                                  (/.array (list#each /.number items))))
                (expression (|>> (as Bit))
                            (|> (/.array (list#each /.number items))
                                (/.at (/.int (.int size)))
                                (/.= /.undefined)))))
         )))

(the test|object
  Test
  (do [! random.monad]
    [expected random.safe_dec
     field (random.upper_cased 5)
     dummy (random.only (|>> (text.= field) not)
                        (random.upper_cased 5))

     size (of ! each (|>> (n.% 10) ++) random.natural)
     index (of ! each (n.% size) random.natural)
     items (random.list size random.safe_dec)]
    (all _.and
         (_.coverage [/.object /.its]
           (expression (|>> (as Dec) (d.= expected))
                       (/.its field (/.object (list [field (/.number expected)])))))
         (let [expected (|> items
                            (list.item index)
                            (try.else d.not_a_number))]
           (_.coverage [/.do]
             (expression (|>> (as Dec) d.int (i.= (.int index)))
                         (|> (/.array (list#each /.number items))
                             (/.do "lastIndexOf" (list (/.number expected)))))))
         (_.coverage [/.undefined]
           (expression (|>> (as Bit))
                       (|> (/.object (list [field (/.number expected)]))
                           (/.its dummy)
                           (/.= /.undefined))))
         )))

(the test|computation
  Test
  (do [! random.monad]
    [test random.bit
     then random.safe_dec
     else random.safe_dec

     boolean random.bit
     number random.dec
     string (random.upper_cased 5)

     comment (random.upper_cased 10)]
    (all _.and
         ..test|boolean
         ..test|number
         ..test|i32
         ..test|array
         ..test|object
         (_.coverage [/.?]
           (let [expected (if test then else)]
             (expression (|>> (as Dec) (d.= expected))
                         (/.? (/.boolean test)
                              (/.number then)
                              (/.number else)))))
         (_.coverage [/.not_a_number?]
           (and (expression (|>> (as Bit))
                            (/.not_a_number? (/.number d.not_a_number)))
                (expression (|>> (as Bit) not)
                            (/.not_a_number? (/.number then)))))
         (_.coverage [/.type_of]
           (and (expression (|>> (as Text) (text.= "boolean"))
                            (/.type_of (/.boolean boolean)))
                (expression (|>> (as Text) (text.= "number"))
                            (/.type_of (/.number number)))
                (expression (|>> (as Text) (text.= "string"))
                            (/.type_of (/.string string)))
                (expression (|>> (as Text) (text.= "object"))
                            (/.type_of /.null))
                (expression (|>> (as Text) (text.= "object"))
                            (/.type_of (/.object (list [string (/.number number)]))))
                (expression (|>> (as Text) (text.= "object"))
                            (/.type_of (/.array (list (/.boolean boolean)
                                                      (/.number number)
                                                      (/.string string)))))
                (expression (|>> (as Text) (text.= "undefined"))
                            (/.type_of /.undefined))))
         (_.coverage [/.comment]
           (expression (|>> (as Dec) (d.= then))
                       (/.comment comment
                         (/.number then))))
         )))

(the test|expression
  Test
  (do [! random.monad]
    [dummy random.safe_dec
     expected random.safe_dec]
    (`` (all _.and
             (_.for [/.Literal]
                    ..test|literal)
             (_.for [/.Computation]
                    ..test|computation)
             (_.coverage [/.,]
               (expression (|>> (as Dec) (d.= expected))
                           (/., (/.number dummy) (/.number expected))))
             ))))

(the test/var
  Test
  (do [! random.monad]
    [number/0 random.safe_dec
     number/1 random.safe_dec
     number/2 random.safe_dec
     foreign (random.lower_cased 10)
     local (random.only (|>> (text.= foreign) not)
                        (random.lower_cased 10))
     .let [$foreign (/.var foreign)
           $local (/.var local)]]
    (all _.and
         (_.coverage [/.var]
           (expression (|>> (as Dec) (d.= number/0))
                       (/.apply (/.closure (list $foreign) (/.return $foreign))
                                (list (/.number number/0)))))
         (_.coverage [/.define]
           (expression (|>> (as Dec) (d.= number/1))
                       (/.apply (/.closure (list $foreign)
                                           (all /.then
                                                (/.define $local (/.number number/1))
                                                (/.return $local)))
                                (list (/.number number/0)))))
         (_.coverage [/.declare]
           (expression (|>> (as Dec) (d.= number/1))
                       (/.apply (/.closure (list $foreign)
                                           (all /.then
                                                (/.declare $local)
                                                (/.statement (/.set $local (/.number number/1)))
                                                (/.return $local)))
                                (list (/.number number/0)))))
         )))

(the test/location
  Test
  (do [! random.monad]
    [number/0 random.safe_dec
     int/0 ..int_16
     $foreign (of ! each /.var (random.lower_cased 10))
     field (random.upper_cased 10)]
    (all _.and
         (_.coverage [/.set]
           (and (expression (|>> (as Dec) (d.= (d.+ number/0 number/0)))
                            (/.apply (/.closure (list $foreign)
                                                (all /.then
                                                     (/.statement (/.set $foreign (/.+ $foreign $foreign)))
                                                     (/.return $foreign)))
                                     (list (/.number number/0))))
                (expression (|>> (as Dec) (d.= (d.+ number/0 number/0)))
                            (let [@ (/.at (/.int +0) $foreign)]
                              (/.apply (/.closure (list $foreign)
                                                  (all /.then
                                                       (/.statement (/.set $foreign (/.array (list $foreign))))
                                                       (/.statement (/.set @ (/.+ @ @)))
                                                       (/.return @)))
                                       (list (/.number number/0)))))
                (expression (|>> (as Dec) (d.= (d.+ number/0 number/0)))
                            (let [@ (/.its field $foreign)]
                              (/.apply (/.closure (list $foreign)
                                                  (all /.then
                                                       (/.statement (/.set $foreign (/.object (list [field $foreign]))))
                                                       (/.statement (/.set @ (/.+ @ @)))
                                                       (/.return @)))
                                       (list (/.number number/0)))))))
         (_.coverage [/.delete]
           (and (and (expression (|>> (as Bit))
                                 (/.apply (/.closure (list)
                                                     (all /.then
                                                          (/.statement (/.set $foreign (/.number number/0)))
                                                          (/.return (/.delete $foreign))))
                                          (list)))
                     (expression (|>> (as Bit) not)
                                 (/.apply (/.closure (list $foreign)
                                                     (/.return (/.delete $foreign)))
                                          (list (/.number number/0)))))
                (expression (|>> (as Bit))
                            (let [@ (/.at (/.int +0) $foreign)]
                              (/.apply (/.closure (list $foreign)
                                                  (all /.then
                                                       (/.statement (/.set $foreign (/.array (list $foreign))))
                                                       (/.return (|> (/.= (/.boolean true) (/.delete @))
                                                                     (/.and (/.= /.undefined @))))))
                                       (list (/.number number/0)))))
                (expression (|>> (as Bit))
                            (let [@ (/.its field $foreign)]
                              (/.apply (/.closure (list $foreign)
                                                  (all /.then
                                                       (/.statement (/.set $foreign (/.object (list [field $foreign]))))
                                                       (/.return (|> (/.= (/.boolean true) (/.delete @))
                                                                     (/.and (/.= /.undefined @))))))
                                       (list (/.number number/0)))))
                ))
         (_.coverage [/.Access]
           (`` (and (,, (template.with [<js> <lux>]
                          [(expression (|>> (as Dec) d.int (i.= (<lux> int/0)))
                                       (/.apply (/.closure (list $foreign)
                                                           (all /.then
                                                                (/.statement (<js> $foreign))
                                                                (/.return $foreign)))
                                                (list (/.int int/0))))
                           (expression (|>> (as Dec) d.int (i.= (<lux> int/0)))
                                       (let [@ (/.at (/.int +0) $foreign)]
                                         (/.apply (/.closure (list $foreign)
                                                             (all /.then
                                                                  (/.statement (/.set $foreign (/.array (list $foreign))))
                                                                  (/.statement (<js> @))
                                                                  (/.return @)))
                                                  (list (/.int int/0)))))
                           (expression (|>> (as Dec) d.int (i.= (<lux> int/0)))
                                       (let [@ (/.its field $foreign)]
                                         (/.apply (/.closure (list $foreign)
                                                             (all /.then
                                                                  (/.statement (/.set $foreign (/.object (list [field $foreign]))))
                                                                  (/.statement (<js> @))
                                                                  (/.return @)))
                                                  (list (/.int int/0)))))]

                          [/.++ .++]
                          [/.-- .--]
                          )))))
         (_.for [/.Var]
                ..test/var)
         )))

(the test|label
  Test
  (do [! random.monad]
    [input ..int_16
     
     full_inner_iterations (of ! each (|>> (n.% 20) ++) random.natural)
     expected_inner_iterations (of ! each (n.% full_inner_iterations) random.natural)

     @outer (of ! each /.label (random.upper_cased 5))
     full_outer_iterations (of ! each (|>> (n.% 10) ++) random.natural)
     expected_outer_iterations (of ! each (n.% full_outer_iterations) random.natural)

     .let [$input (/.var "input")
           $output (/.var "output")
           $inner_index (/.var "inner_index")
           $outer_index (/.var "outer_index")]]
    (all _.and
         (_.coverage [/.break]
           (let [expected (i.* (.int expected_inner_iterations) input)]
             (expression (|>> (as Dec) d.int (i.= expected))
                         (/.apply (/.closure (list $input)
                                             (all /.then
                                                  (/.define $inner_index (/.int +0))
                                                  (/.define $output (/.int +0))
                                                  (/.while (/.< (/.int (.int full_inner_iterations)) $inner_index)
                                                           (all /.then
                                                                (/.when (/.= (/.int (.int expected_inner_iterations)) $inner_index)
                                                                  /.break)
                                                                (/.statement (/.set $output (/.+ $input $output)))
                                                                (/.statement (/.set $inner_index (/.+ (/.int +1) $inner_index)))
                                                                ))
                                                  (/.return $output)))
                                  (list (/.int input))))))
         (_.coverage [/.continue]
           (let [expected (i.* (.int (n.- expected_inner_iterations full_inner_iterations)) input)]
             (expression (|>> (as Dec) d.int (i.= expected))
                         (/.apply (/.closure (list $input)
                                             (all /.then
                                                  (/.define $inner_index (/.int +0))
                                                  (/.define $output (/.int +0))
                                                  (/.while (/.< (/.int (.int full_inner_iterations)) $inner_index)
                                                           (all /.then
                                                                (/.statement (/.set $inner_index (/.+ (/.int +1) $inner_index)))
                                                                (/.when (/.<= (/.int (.int expected_inner_iterations)) $inner_index)
                                                                  /.continue)
                                                                (/.statement (/.set $output (/.+ $input $output)))
                                                                ))
                                                  (/.return $output)))
                                  (list (/.int input))))))
         (_.for [/.label /.with_label]
                (all _.and
                     (_.coverage [/.break_at]
                       (let [expected (i.* (.int (n.* expected_outer_iterations
                                                      expected_inner_iterations))
                                           input)]
                         (expression (|>> (as Dec) d.int (i.= expected))
                                     (/.apply (/.closure (list $input)
                                                         (all /.then
                                                              (/.define $output (/.int +0))
                                                              (/.define $outer_index (/.int +0))
                                                              (/.with_label @outer
                                                                (/.while (/.< (/.int (.int full_outer_iterations)) $outer_index)
                                                                         (all /.then
                                                                              (/.define $inner_index (/.int +0))
                                                                              (/.while (/.< (/.int (.int full_inner_iterations)) $inner_index)
                                                                                       (all /.then
                                                                                            (/.when (/.= (/.int (.int expected_outer_iterations)) $outer_index)
                                                                                              (/.break_at @outer))
                                                                                            (/.when (/.= (/.int (.int expected_inner_iterations)) $inner_index)
                                                                                              /.break)
                                                                                            (/.statement (/.set $output (/.+ $input $output)))
                                                                                            (/.statement (/.set $inner_index (/.+ (/.int +1) $inner_index)))
                                                                                            ))
                                                                              (/.statement (/.set $outer_index (/.+ (/.int +1) $outer_index)))
                                                                              )))
                                                              (/.return $output)))
                                              (list (/.int input))))))
                     (_.coverage [/.continue_at]
                       (let [expected (i.* (.int (n.* (n.- expected_outer_iterations full_outer_iterations)
                                                      (n.- expected_inner_iterations full_inner_iterations)))
                                           input)]
                         (expression (|>> (as Dec) d.int (i.= expected))
                                     (/.apply (/.closure (list $input)
                                                         (all /.then
                                                              (/.define $output (/.int +0))
                                                              (/.define $outer_index (/.int +0))
                                                              (/.with_label @outer
                                                                (/.while (/.< (/.int (.int full_outer_iterations)) $outer_index)
                                                                         (all /.then
                                                                              (/.statement (/.set $outer_index (/.+ (/.int +1) $outer_index)))
                                                                              (/.define $inner_index (/.int +0))
                                                                              (/.while (/.< (/.int (.int full_inner_iterations)) $inner_index)
                                                                                       (all /.then
                                                                                            (/.statement (/.set $inner_index (/.+ (/.int +1) $inner_index)))
                                                                                            (/.when (/.<= (/.int (.int expected_outer_iterations)) $outer_index)
                                                                                              (/.continue_at @outer))
                                                                                            (/.when (/.<= (/.int (.int expected_inner_iterations)) $inner_index)
                                                                                              /.continue)
                                                                                            (/.statement (/.set $output (/.+ $input $output)))
                                                                                            ))
                                                                              )
                                                                         ))
                                                              (/.return $output)))
                                              (list (/.int input))))))
                     ))
         )))

(the test|loop
  Test
  (do [! random.monad]
    [input ..int_16
     iterations (of ! each (n.% 10) random.natural)
     .let [$input (/.var "input")
           $output (/.var "output")
           $index (/.var "index")
           expected|while (i.* (.int iterations) input)
           expected|do_while (i.* (.int (n.max 1 iterations)) input)]]
    (all _.and
         (_.coverage [/.while]
           (expression (|>> (as Dec) d.int (i.= expected|while))
                       (/.apply (/.closure (list $input)
                                           (all /.then
                                                (/.define $index (/.int +0))
                                                (/.define $output (/.int +0))
                                                (/.while (/.< (/.int (.int iterations)) $index)
                                                         (all /.then
                                                              (/.statement (/.set $output (/.+ $input $output)))
                                                              (/.statement (/.set $index (/.+ (/.int +1) $index)))
                                                              ))
                                                (/.return $output)))
                                (list (/.int input)))))
         (_.coverage [/.do_while]
           (expression (|>> (as Dec) d.int (i.= expected|do_while))
                       (/.apply (/.closure (list $input)
                                           (all /.then
                                                (/.define $index (/.int +0))
                                                (/.define $output (/.int +0))
                                                (/.do_while (/.< (/.int (.int iterations)) $index)
                                                            (all /.then
                                                                 (/.statement (/.set $output (/.+ $input $output)))
                                                                 (/.statement (/.set $index (/.+ (/.int +1) $index)))
                                                                 ))
                                                (/.return $output)))
                                (list (/.int input)))))
         (_.coverage [/.for]
           (expression (|>> (as Dec) d.int (i.= expected|while))
                       (/.apply (/.closure (list $input)
                                           (all /.then
                                                (/.define $output (/.int +0))
                                                (/.for $index (/.int +0)
                                                       (/.< (/.int (.int iterations)) $index)
                                                       (/.++ $index)
                                                       (/.statement (/.set $output (/.+ $input $output))))
                                                (/.return $output)))
                                (list (/.int input)))))
         (_.for [/.Label]
                ..test|label)
         )))

(the test|exception
  Test
  (do [! random.monad]
    [expected random.safe_dec
     dummy (random.only (|>> (d.= expected) not)
                        random.safe_dec)
     $ex (of ! each /.var (random.lower_cased 10))]
    (all _.and
         (_.coverage [/.try]
           (expression (|>> (as Dec) (d.= expected))
                       (/.apply (/.closure (list)
                                           (/.try (/.return (/.number expected))
                                                  [$ex (/.return (/.number dummy))]))
                                (list))))
         (_.coverage [/.throw]
           (expression (|>> (as Dec) (d.= expected))
                       (/.apply (/.closure (list)
                                           (/.try (all /.then
                                                       (/.throw (/.number expected))
                                                       (/.return (/.number dummy)))
                                                  [$ex (/.return $ex)]))
                                (list))))
         )))

(the test|apply
  Test
  (do [! random.monad]
    [number/0 random.safe_dec
     number/1 random.safe_dec
     number/2 random.safe_dec
     $arg/0 (of ! each /.var (random.lower_cased 10))
     $arg/1 (of ! each /.var (random.lower_cased 11))
     $arg/2 (of ! each /.var (random.lower_cased 12))]
    (`` (all _.and
             (_.coverage [/.apply_1]
               (expression (|>> (as Dec) (d.= number/0))
                           (/.apply_1 (/.closure (list $arg/0) (/.return $arg/0))
                                      (/.number number/0))))
             (_.coverage [/.apply_2]
               (expression (|>> (as Dec) (d.= (all d.+ number/0 number/1)))
                           (/.apply_2 (/.closure (list $arg/0 $arg/1) (/.return (all /.+ $arg/0 $arg/1)))
                                      (/.number number/0)
                                      (/.number number/1))))
             (_.coverage [/.apply_3]
               (expression (|>> (as Dec) (d.= (all d.+ number/0 number/1 number/2)))
                           (/.apply_3 (/.closure (list $arg/0 $arg/1 $arg/2) (/.return (all /.+ $arg/0 $arg/1 $arg/2)))
                                      (/.number number/0)
                                      (/.number number/1)
                                      (/.number number/2))))
             (_.coverage [/.apply]
               (expression (|>> (as Dec) (d.= (all d.+ number/0 number/1 number/2)))
                           (/.apply (/.closure (list $arg/0 $arg/1 $arg/2) (/.return (all /.+ $arg/0 $arg/1 $arg/2)))
                                    (list (/.number number/0)
                                          (/.number number/1)
                                          (/.number number/2)))))
             ))))

(the test|function
  Test
  (do [! random.monad]
    [number/0 random.safe_dec
     iterations (of ! each (n.% 10) random.natural)
     $self (of ! each /.var (random.lower_cased 1))
     $arg/0 (of ! each /.var (random.lower_cased 2))
     field (random.lower_cased 3)
     $class (of ! each /.var (random.upper_cased 4))]
    (all _.and
         (_.coverage [/.closure /.return]
           (expression (|>> (as Dec) (d.= number/0))
                       (/.apply (/.closure (list) (/.return (/.number number/0)))
                                (list))))
         (_.coverage [/.function]
           (expression (|>> (as Dec) d.natural (n.= iterations))
                       (/.apply_1 (/.function $self (list $arg/0)
                                    (/.return (/.? (/.< (/.int (.int iterations)) $arg/0)
                                                   (/.apply_1 $self (/.+ (/.int +1) $arg/0))
                                                   $arg/0)))
                                  (/.int +0))))
         (_.coverage [/.function_definition]
           (expression (|>> (as Dec) d.natural (n.= iterations))
                       (/.apply (/.closure (list)
                                           (all /.then
                                                (/.function_definition $self (list $arg/0)
                                                                       (/.return (/.? (/.< (/.int (.int iterations)) $arg/0)
                                                                                      (/.apply_1 $self (/.+ (/.int +1) $arg/0))
                                                                                      $arg/0)))
                                                (/.return (/.apply_1 $self (/.int +0)))))
                                (list))))
         (_.coverage [/.new]
           (let [$this (/.var "this")]
             (expression (|>> (as Dec) (d.= number/0))
                         (/.apply_1 (/.closure (list $arg/0)
                                               (all /.then
                                                    (/.function_definition $class (list)
                                                                           (/.statement (/.set (/.its field $this) $arg/0)))
                                                    (/.return (/.its field (/.new $class (list))))))
                                    (/.number number/0)))))
         ..test|apply
         )))

(the test|branching
  Test
  (do [! random.monad]
    [number/0 random.safe_dec
     number/1 random.safe_dec
     number/2 random.safe_dec
     arg/0 (random.lower_cased 10)
     arg/1 (random.only (|>> (text.= arg/0) not)
                        (random.lower_cased 10))
     arg/2 (random.only (predicate.and (|>> (text.= arg/0) not)
                                       (|>> (text.= arg/1) not))
                        (random.lower_cased 10))
     .let [$arg/0 (/.var arg/0)
           $arg/1 (/.var arg/1)
           $arg/2 (/.var arg/2)]
     ??? random.bit
     int ..int_16]
    (all _.and
         (_.coverage [/.if]
           (expression (|>> (as Dec) (d.= (if ??? number/0 number/1)))
                       (/.apply (/.closure (list)
                                           (/.if (/.boolean ???)
                                             (/.return (/.number number/0))
                                             (/.return (/.number number/1))))
                                (list))))
         (_.coverage [/.when]
           (expression (|>> (as Dec) (d.= (if ??? number/0 number/1)))
                       (/.apply (/.closure (list)
                                           (all /.then
                                                (/.when (/.boolean ???)
                                                  (/.return (/.number number/0)))
                                                (/.return (/.number number/1))))
                                (list))))
         (_.coverage [/.switch]
           (let [number/0' (%.dec number/0)
                 number/1' (%.dec number/1)
                 number/2' (%.dec number/2)]
             (and (expression (|>> (as Text) (text.= number/0'))
                              (/.apply (/.closure (list)
                                                  (/.switch (/.number number/0)
                                                            (list [(list (/.number number/0)) (/.return (/.string number/0'))]
                                                                  [(list (/.number number/1)) (/.return (/.string number/1'))])
                                                            {.#None}))
                                       (list)))
                  (expression (|>> (as Text) (text.= number/1'))
                              (/.apply (/.closure (list)
                                                  (/.switch (/.number number/1)
                                                            (list [(list (/.number number/0)) (/.return (/.string number/0'))]
                                                                  [(list (/.number number/1)) (/.return (/.string number/1'))])
                                                            {.#Some (/.return (/.string number/2'))}))
                                       (list)))
                  (expression (|>> (as Text) (text.= number/2'))
                              (/.apply (/.closure (list)
                                                  (/.switch (/.number number/2)
                                                            (list [(list (/.number number/0)) (/.return (/.string number/0'))]
                                                                  [(list (/.number number/1)) (/.return (/.string number/1'))])
                                                            {.#Some (/.return (/.string number/2'))}))
                                       (list)))
                  )))
         )))

(the test|statement
  Test
  (do [! random.monad]
    [number/0 random.safe_dec
     number/1 random.safe_dec
     number/2 random.safe_dec
     $arg/0 (of ! each /.var (random.lower_cased 10))
     $arg/1 (of ! each /.var (random.lower_cased 11))
     $arg/2 (of ! each /.var (random.lower_cased 12))
     ??? random.bit
     int ..int_16]
    (`` (all _.and
             (_.coverage [/.statement]
               (expression (|>> (as Dec) (d.= number/0))
                           (/.apply_1 (/.closure (list $arg/0)
                                                 (all /.then
                                                      (/.statement (/.+ $arg/0 $arg/0))
                                                      (/.return $arg/0)))
                                      (/.number number/0))))
             (,, (template.with [<js> <lux>]
                   [(_.coverage [<js>]
                      (expression (|>> (as Dec) d.int (i.= (<lux> int)))
                                  (/.apply_1 (/.closure (list $arg/0)
                                                        (/.return (/., (<js> $arg/0)
                                                                       $arg/0)))
                                             (/.int int))))]
                   
                   [/.++ .++]
                   [/.-- .--]
                   ))
             (_.coverage [/.then]
               (expression (|>> (as Dec) (d.= number/0))
                           (/.apply_2 (/.closure (list $arg/0 $arg/1)
                                                 (all /.then
                                                      (/.return $arg/0)
                                                      (/.return $arg/1)))
                                      (/.number number/0)
                                      (/.number number/1))))
             (_.coverage [/.use_strict]
               (and (expression (|>> (as Dec) (d.= number/0))
                                (/.apply (/.closure (list)
                                                    (all /.then
                                                         /.use_strict
                                                         (/.declare $arg/0)
                                                         (/.statement (/.set $arg/0 (/.number number/0)))
                                                         (/.return $arg/0)))
                                         (list)))
                    (|> (/.apply (/.closure (list)
                                            (all /.then
                                                 /.use_strict
                                                 ... (/.declare $arg/0)
                                                 (/.statement (/.set $arg/0 (/.number number/0)))
                                                 (/.return $arg/0)))
                                 (list))
                        ..eval
                        (pipe.when
                          {try.#Success it}
                          false
                          
                          {try.#Failure error}
                          true))))
             ..test|exception
             ..test|function
             ..test|branching
             (_.for [/.Location]
                    ..test/location)
             (_.for [/.Loop]
                    ..test|loop)
             ))))

(the .public test
  Test
  (do [! random.monad]
    []
    (<| (_.covering /._)
        (_.for [/.Code /.code])
        (`` (all _.and
                 (_.for [/.Expression]
                        ..test|expression)
                 (_.for [/.Statement]
                        ..test|statement)
                 )))))
