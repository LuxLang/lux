(.require
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" try]
    [concurrency
     ["[0]" async (.only Async) (.use "[1]#[0]" monad)]]]
   [data
    ["[0]" binary (.use "[1]#[0]" equivalence)
     ["$[1]" \\test]]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" nat]]]
   [world
    ["[0]" file]]
   [test
    ["[0]" unit]
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" / (.only)
   ["/[1]" //
    ["[1][0]" module]]]]
 ["$[0]" ///
  ["[1][0]" context]])

(def .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [context $///context.random
         .let [/ "/"
               fs (file.mock /)]
         @module random.nat
         @artifact random.nat
         expected ($binary.random 1)]
        (all _.and
             (in (do [! async.monad]
                   [pre (at fs file? (/.path fs context @module @artifact))
                    _ (//module.enable! ! fs context @module)
                    write! (/.cache! fs context @module @artifact expected)
                    post (at fs file? (/.path fs context @module @artifact))
                    read! (/.cache fs context @module @artifact)]
                   (unit.coverage [/.path /.cache! /.cache]
                     (and (not pre)
                          (when write!
                            {try.#Success _} true
                            {try.#Failure _} false)
                          post
                          (when read!
                            {try.#Success actual} (binary#= expected actual)
                            {try.#Failure _} false)))))
             ))))
