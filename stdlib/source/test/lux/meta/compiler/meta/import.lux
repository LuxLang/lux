... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" maybe (.use "[1]#[0]" functor)]
    ["[0]" try (.use "[1]#[0]" functor)]
    ["[0]" exception]
    [concurrency
     ["[0]" async]]]
   [data
    ["[0]" binary (.only Binary)
     ["[0]" \\injection]
     ["<[1]>" \\projection]]
    [format
     ["[0]" tar (.only Tar)]]
    ["[0]" text (.only)
     ["%" \\injection]
     [encoding
      ["[0]" utf8]]]
    [collection
     ["[0]" sequence]
     ["[0]" dictionary]]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" natural]]]
   [world
    ["[0]" file]
    [time
     ["[0]" instant]]]
   [test
    ["[0]" unit]
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" / (.only)
   [//
    ["[0]" export]
    ["[0]" io
     ["[1]" context]]]]])

(the .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Import])
      (do [! random.monad]
        [library/0 (random.lower_cased 1)
         library/1 (random.lower_cased 2)
         
         .let [/ .module_separator
               random_file (is (Random file.Path)
                               (of ! each (text.suffix io.lux_extension) (random.lower_cased 3)))]
         file/0 random_file
         
         dir/0 (random.lower_cased 4)
         file/1 (of ! each (|>> (%.message dir/0 /)) random_file)
         
         .let [random_content (is (Random Binary)
                                  (of ! each (|>> %.natural (of utf8.format injection)) random.natural))]
         now instant.random
         content/0 random_content
         content/1 random_content
         .let [library_content (|> (do try.monad
                                     [file/0 (tar.path file/0)
                                      file/1 (tar.path file/1)
                                      content/0 (tar.content content/0)
                                      content/1 (tar.content content/1)]
                                     (in (|> (sequence.sequence {tar.#Normal [file/0 now export.mode export.ownership content/0]}
                                                                {tar.#Normal [file/1 now export.mode export.ownership content/1]})
                                             (\\injection.value tar.injection))))
                                   (try.else (binary.empty 0)))
               library_content/0 (|> (do try.monad
                                       [file/0 (tar.path file/0)
                                        content/0 (tar.content content/0)]
                                       (in (|> (sequence.sequence {tar.#Normal [file/0 now export.mode export.ownership content/0]})
                                               (\\injection.value tar.injection))))
                                     (try.else (binary.empty 0)))
               library_content/1 (|> (do try.monad
                                       [file/1 (tar.path file/1)
                                        content/1 (tar.content content/1)]
                                       (in (|> (sequence.sequence {tar.#Normal [file/1 now export.mode export.ownership content/1]})
                                               (\\injection.value tar.injection))))
                                     (try.else (binary.empty 0)))
               library_content/-0 (|> (do try.monad
                                        [file/0 (tar.path file/0)
                                         content/0 (tar.content content/0)]
                                        (in (|> (sequence.sequence {tar.#Contiguous [file/0 now export.mode export.ownership content/0]})
                                                (\\injection.value tar.injection))))
                                      (try.else (binary.empty 0)))
               library_content/-1 (|> (do try.monad
                                        [file/0 (tar.path file/0)]
                                        (in (|> (sequence.sequence {tar.#Symbolic_Link file/0})
                                                (\\injection.value tar.injection))))
                                      (try.else (binary.empty 0)))
               library_content/-2 (|> (do try.monad
                                        [file/0 (tar.path file/0)]
                                        (in (|> (sequence.sequence {tar.#Directory file/0})
                                                (\\injection.value tar.injection))))
                                      (try.else (binary.empty 0)))
               imported? (is (-> /.Import Bit)
                             (function (_ it)
                               (and (n.= 2 (dictionary.size it))
                                    (|> it
                                        (dictionary.value file/0)
                                        (maybe#each (binary.= content/0))
                                        (maybe.else false))
                                    (|> it
                                        (dictionary.value file/1)
                                        (maybe#each (binary.= content/1))
                                        (maybe.else false)))))]]
        (all _.and
             (in (do [! async.monad]
                   [it/0 (do (try.with !)
                           [.let [fs (file.mock /)]
                            _ (of fs write library/0 library_content)]
                           (/.import fs (list library/0)))
                    it/1 (do (try.with !)
                           [.let [fs (file.mock /)]
                            _ (of fs write library/0 library_content/0)
                            _ (of fs write library/1 library_content/1)]
                           (/.import fs (list library/0 library/1)))]
                   (unit.coverage [/.import]
                     (and (|> it/0
                              (try#each imported?)
                              (try.else false))
                          (|> it/1
                              (try#each imported?)
                              (try.else false))))))
             (in (do [! async.monad]
                   [it (do (try.with !)
                         [.let [fs (file.mock /)]
                          _ (of fs write library/0 library_content)
                          _ (/.import fs (list library/0 library/0))]
                         (in false))]
                   (unit.coverage [/.duplicate]
                     (exception.else (exception.is? /.duplicate) it))))
             (in (do [! async.monad]
                   [it/0 (do (try.with !)
                           [.let [fs (file.mock /)]
                            _ (of fs write library/0 library_content/-0)
                            _ (/.import fs (list library/0))]
                           (in false))
                    it/1 (do (try.with !)
                           [.let [fs (file.mock /)]
                            _ (of fs write library/0 library_content/-1)
                            _ (/.import fs (list library/0))]
                           (in false))
                    it/2 (do (try.with !)
                           [.let [fs (file.mock /)]
                            _ (of fs write library/0 library_content/-2)
                            _ (/.import fs (list library/0))]
                           (in false))]
                   (unit.coverage [/.useless_tar_entry]
                     (and (exception.else (exception.is? /.useless_tar_entry) it/0)
                          (exception.else (exception.is? /.useless_tar_entry) it/1)
                          (exception.else (exception.is? /.useless_tar_entry) it/2)))))
             ))))
