... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" try]
    ["[0]" exception]]
   [data
    ["[0]" product]
    ["[0]" text]
    [collection
     ["[0]" list]]]
   [math
    ["[0]" random]
    [number
     ["n" natural]]]
   [meta
    ["[0]" code]
    ["[0]" macro (.only)
     ["[0]" template]]
    ["[0]" type (.only)
     ["[0]" check]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" / (.only)
   [//
    ["[0]" extension (.only)
     ["[1]/[0]" analysis
      ["[1]" lux]]]
    [//
     ["/[1]" analysis (.only Analysis Operation)
      [evaluation (.only Eval)]
      ["[1][0]" macro]
      ["[1][0]" scope]
      ["[1][0]" module]
      ["[1][0]" pattern]
      ["[1][0]" type (.only)
       ["$[1]" \\test]]]
     [///
      ["[0]" phase (.use "[1]#[0]" monad)]
      [meta
       ["[0]" archive]]]]]]]
 ["[0]" /
  ["[1][0]" simple]
  ["[1][0]" complex]
  ["[1][0]" reference]
  ["[1][0]" function]
  ["[1][0]" when]])

(the (eval archive type term)
  Eval
  (phase#in []))

(the (expander macro inputs state)
  //macro.Expander
  {try.#Success ((macro.function macro) inputs state)})

(the (can_analyse_unit! lux module/0)
  (-> Lux Text Bit)
  (let [state [extension.#bundle (extension/analysis.bundle ..eval)
               extension.#state lux]]
    (|> (do phase.monad
          [[:it: it] (|> (' [])
                         (/.phase ..expander archive.empty)
                         //type.inferring)]
          (in (and (type.= .Any :it:)
                   (when it
                     (//.unit)
                     true

                     _
                     false))))
        //scope.with
        (//module.with 0 module/0)
        (phase#each (|>> product.right product.right))
        (phase.value state)
        (try.else false))))

(the (can_analyse_simple_literal_or_singleton_tuple! lux module/0 [bit/0 natural/0 integer/0 revolution/0 decimal/0 text/0])
  (-> Lux Text [.Bit .Natural .Integer .Revolution .Decimal .Text] Bit)
  (let [state [extension.#bundle (extension/analysis.bundle ..eval)
               extension.#state lux]]
    (`` (and (,, (template.with [<expected> <code> <type> <analysis>]
                   [(|> (do phase.monad
                          [[:it: it] (|> <expected>
                                         <code>
                                         (/.phase ..expander archive.empty)
                                         //type.inferring)]
                          (in (and (type.= <type> :it:)
                                   (when it
                                     (<analysis> it)
                                     (same? <expected> it)

                                     _
                                     false))))
                        //scope.with
                        (//module.with 0 module/0)
                        (phase#each (|>> product.right product.right))
                        (phase.value state)
                        (try.else false))]
                   
                   [bit/0 code.bit .Bit //.bit]
                   [natural/0 code.natural .Natural //.natural]
                   [integer/0 code.integer .Integer //.integer]
                   [revolution/0 code.revolution .Revolution //.revolution]
                   [decimal/0 code.decimal .Decimal //.decimal]
                   [text/0 code.text .Text //.text]

                   ... Singleton tuple
                   [bit/0 (<| code.tuple list code.bit) .Bit //.bit]
                   [natural/0 (<| code.tuple list code.natural) .Natural //.natural]
                   [integer/0 (<| code.tuple list code.integer) .Integer //.integer]
                   [revolution/0 (<| code.tuple list code.revolution) .Revolution //.revolution]
                   [decimal/0 (<| code.tuple list code.decimal) .Decimal //.decimal]
                   [text/0 (<| code.tuple list code.text) .Text //.text]
                   ))
             ))))

(the (can_analyse_sum! lux module/0 [@any @bit @natural @integer @revolution @decimal @text] [bit/0 natural/0 integer/0 revolution/0 decimal/0 text/0] [@left @right])
  (-> Lux Text [.Text .Text .Text .Text .Text .Text .Text] [.Bit .Natural .Integer .Revolution .Decimal .Text] [.Text .Text] Bit)
  (let [state [extension.#bundle (extension/analysis.bundle ..eval)
               extension.#state lux]
        :record: (And .Any .Bit .Natural .Integer .Revolution .Decimal .Text)
        :variant: (Or .Any .Bit .Natural .Integer .Revolution .Decimal .Text)

        can_analyse_unary!
        (`` (and (|> (do phase.monad
                       [it (|> (code.variant (list (code.natural 0) (code.bit false) (` [])))
                               (/.phase ..expander archive.empty)
                               (//type.expecting :variant:))]
                       (in (when it
                             (//.variant [0 .false (//.unit)])
                             true

                             _
                             false)))
                     //scope.with
                     (//module.with 0 module/0)
                     (phase#each (|>> product.right product.right))
                     (phase.value state)
                     (try.else false))
                 (,, (template.with [<lefts> <right> <expected> <tag> <code> <analysis>]
                       [(|> (do phase.monad
                              [it (|> (code.variant (list (code.natural <lefts>) (code.bit <right>) (<code> <expected>)))
                                      (/.phase ..expander archive.empty)
                                      (//type.expecting :variant:))]
                              (in (when it
                                    (//.variant [<lefts> <right> (<analysis> actual)])
                                    (same? <expected> actual)

                                    _
                                    false)))
                            //scope.with
                            (//module.with 0 module/0)
                            (phase#each (|>> product.right product.right))
                            (phase.value state)
                            (try.else false))]

                       [1 #0 bit/0 @bit code.bit //.bit]
                       [2 #0 natural/0 @natural code.natural //.natural]
                       [3 #0 integer/0 @integer code.integer //.integer]
                       [4 #0 revolution/0 @revolution code.revolution //.revolution]
                       [5 #0 decimal/0 @decimal code.decimal //.decimal]
                       [5 #1 text/0 @text code.text //.text]
                       ))))

        can_analyse_nullary!
        (|> (do phase.monad
              [.let [:either: (Or .Any :record:)]
               it (|> (code.variant (list (code.natural 0) (code.bit false)))
                      (/.phase ..expander archive.empty)
                      (//type.expecting :either:))]
              (in (when it
                    (//.variant [0 .false (//.unit)])
                    true

                    _
                    false)))
            //scope.with
            (//module.with 0 module/0)
            (phase#each (|>> product.right product.right))
            (phase.value state)
            (try.else false))

        can_analyse_multiary!
        (|> (do phase.monad
              [.let [:either: (Or .Any :record:)]
               it (|> (code.variant (list (code.natural 0)
                                          (code.bit #1)
                                          (` [])
                                          (code.bit bit/0)
                                          (code.natural natural/0)
                                          (code.integer integer/0)
                                          (code.revolution revolution/0)
                                          (code.decimal decimal/0)
                                          (code.text text/0)))
                      (/.phase ..expander archive.empty)
                      (//type.expecting :either:))]
              (in (when it
                    (//.variant [0 #1 (//.tuple (list (//.unit)
                                                      (//.bit bit/?)
                                                      (//.natural natural/?)
                                                      (//.integer integer/?)
                                                      (//.revolution revolution/?)
                                                      (//.decimal decimal/?)
                                                      (//.text text/?)))])
                    (and (same? bit/0 bit/?)
                         (same? natural/0 natural/?)
                         (same? integer/0 integer/?)
                         (same? revolution/0 revolution/?)
                         (same? decimal/0 decimal/?)
                         (same? text/0 text/?))

                    _
                    false)))
            //scope.with
            (//module.with 0 module/0)
            (phase#each (|>> product.right product.right))
            (phase.value state)
            (try.else false))]
    (and can_analyse_unary!
         can_analyse_nullary!
         can_analyse_multiary!
         )))

(the (can_analyse_variant! lux module/0 [@any @bit @natural @integer @revolution @decimal @text] [bit/0 natural/0 integer/0 revolution/0 decimal/0 text/0] [@left @right])
  (-> Lux Text [.Text .Text .Text .Text .Text .Text .Text] [.Bit .Natural .Integer .Revolution .Decimal .Text] [.Text .Text] Bit)
  (let [state [extension.#bundle (extension/analysis.bundle ..eval)
               extension.#state lux]
        :record: {.#Named [module/0 @text]
                          (type [.Any .Bit .Natural .Integer .Revolution .Decimal .Text])}
        slots/* (list @any @bit @natural @integer @revolution @decimal @text)
        :variant: {.#Named [module/0 @text]
                           (type (Or .Any .Bit .Natural .Integer .Revolution .Decimal .Text))}
        tags/* (list @any @bit @natural @integer @revolution @decimal @text)

        can_analyse_unary!
        (`` (and (|> (do phase.monad
                       [_ (//module.decimallare_labels false tags/* false :variant:)
                        [:it: it] (|> (code.variant (list (code.local @any) (` [])))
                                      (/.phase ..expander archive.empty)
                                      //type.inferring)]
                       (in (and (type.= :variant:
                                        :it:)
                                (when it
                                  (//.variant [0 .false (//.unit)])
                                  true

                                  _
                                  false))))
                     //scope.with
                     (//module.with 0 module/0)
                     (phase#each (|>> product.right product.right))
                     (phase.value state)
                     (try.else false))
                 (,, (template.with [<lefts> <right> <expected> <tag> <code> <analysis>]
                       [(|> (do phase.monad
                              [_ (//module.declare_labels false tags/* false :variant:)
                               [:it: it] (|> (code.variant (list (code.local <tag>) (<code> <expected>)))
                                             (/.phase ..expander archive.empty)
                                             //type.inferring)]
                              (in (and (type.= :variant:
                                               :it:)
                                       (when it
                                         (//.variant [<lefts> <right> (<analysis> actual)])
                                         (same? <expected> actual)

                                         _
                                         false))))
                            //scope.with
                            (//module.with 0 module/0)
                            (phase#each (|>> product.right product.right))
                            (phase.value state)
                            (try.else false))]

                       [1 #0 bit/0 @bit code.bit //.bit]
                       [2 #0 natural/0 @natural code.natural //.natural]
                       [3 #0 integer/0 @integer code.integer //.integer]
                       [4 #0 revolution/0 @revolution code.revolution //.revolution]
                       [5 #0 decimal/0 @decimal code.decimal //.decimal]
                       [5 #1 text/0 @text code.text //.text]
                       ))))

        can_analyse_nullary!
        (|> (do phase.monad
              [_ (//module.declare_labels true slots/* false :record:)
               .let [:either: {.#Named [module/0 module/0]
                                       (type (Or .Any :record:))}]
               _ (//module.declare_labels false (list @left @right) false :either:)
               [:it: it] (|> (code.variant (list (code.local @left)))
                             (/.phase ..expander archive.empty)
                             //type.inferring)]
              (in (and (type.= :either:
                               :it:)
                       (when it
                         (//.variant [0 .false (//.unit)])
                         true

                         _
                         false))))
            //scope.with
            (//module.with 0 module/0)
            (phase#each (|>> product.right product.right))
            (phase.value state)
            (try.else false))

        can_analyse_multiary!
        (|> (do phase.monad
              [_ (//module.declare_labels true slots/* false :record:)
               .let [:either: {.#Named [module/0 module/0]
                                       (type (Or .Any :record:))}]
               _ (//module.declare_labels false (list @left @right) false :either:)
               [:it: it] (|> (code.variant (list (code.local @right)
                                                 (` [])
                                                 (code.bit bit/0)
                                                 (code.natural natural/0)
                                                 (code.integer integer/0)
                                                 (code.revolution revolution/0)
                                                 (code.decimal decimal/0)
                                                 (code.text text/0)))
                             (/.phase ..expander archive.empty)
                             //type.inferring)]
              (in (and (type.= :either:
                               :it:)
                       (when it
                         (//.variant [0 #1 (//.tuple (list (//.unit)
                                                           (//.bit bit/?)
                                                           (//.natural natural/?)
                                                           (//.integer integer/?)
                                                           (//.revolution revolution/?)
                                                           (//.decimal decimal/?)
                                                           (//.text text/?)))])
                         (and (same? bit/0 bit/?)
                              (same? natural/0 natural/?)
                              (same? integer/0 integer/?)
                              (same? revolution/0 revolution/?)
                              (same? decimal/0 decimal/?)
                              (same? text/0 text/?))

                         _
                         false))))
            //scope.with
            (//module.with 0 module/0)
            (phase#each (|>> product.right product.right))
            (phase.value state)
            (try.else false))]
    (and can_analyse_unary!
         can_analyse_nullary!
         can_analyse_multiary!)))

(the (can_analyse_tuple! lux module/0 [bit/0 natural/0 integer/0 revolution/0 decimal/0 text/0])
  (-> Lux Text [.Bit .Natural .Integer .Revolution .Decimal .Text] Bit)
  (let [state [extension.#bundle (extension/analysis.bundle ..eval)
               extension.#state lux]]
    (|> (do phase.monad
          [[:it: it] (|> (code.tuple (list (` [])
                                           (code.bit bit/0)
                                           (code.natural natural/0)
                                           (code.integer integer/0)
                                           (code.revolution revolution/0)
                                           (code.decimal decimal/0)
                                           (code.text text/0)))
                         (/.phase ..expander archive.empty)
                         //type.inferring)]
          (in (and (type.= (type [.Any .Bit .Natural .Integer .Revolution .Decimal .Text])
                           :it:)
                   (when it
                     (//.tuple (list (//.unit)
                                     (//.bit bit/?)
                                     (//.natural natural/?)
                                     (//.integer integer/?)
                                     (//.revolution revolution/?)
                                     (//.decimal decimal/?)
                                     (//.text text/?)))
                     (and (same? bit/0 bit/?)
                          (same? natural/0 natural/?)
                          (same? integer/0 integer/?)
                          (same? revolution/0 revolution/?)
                          (same? decimal/0 decimal/?)
                          (same? text/0 text/?))

                     _
                     false))))
        //scope.with
        (//module.with 0 module/0)
        (phase#each (|>> product.right product.right))
        (phase.value state)
        (try.else false))))

(the (can_analyse_record! lux module/0 [@any @bit @natural @integer @revolution @decimal @text] [bit/0 natural/0 integer/0 revolution/0 decimal/0 text/0])
  (-> Lux Text [.Text .Text .Text .Text .Text .Text .Text] [.Bit .Natural .Integer .Revolution .Decimal .Text] Bit)
  (let [state [extension.#bundle (extension/analysis.bundle ..eval)
               extension.#state lux]
        :record: {.#Named [module/0 @text]
                          (type [.Any .Bit .Natural .Integer .Revolution .Decimal .Text])}
        slots/* (list @any @bit @natural @integer @revolution @decimal @text)]
    (|> (do phase.monad
          [_ (//module.declare_labels true slots/* false :record:)
           [:it: it] (|> (code.tuple (list (code.local @text) (code.text text/0)
                                           (code.local @bit) (code.bit bit/0)
                                           (code.local @revolution) (code.revolution revolution/0)
                                           (code.local @integer) (code.integer integer/0)
                                           (code.local @natural) (code.natural natural/0)
                                           (code.local @decimal) (code.decimal decimal/0)
                                           (code.local @any) (` [])))
                         (/.phase ..expander archive.empty)
                         //type.inferring)]
          (in (and (type.= :record:
                           :it:)
                   (when it
                     (//.tuple (list (//.unit)
                                     (//.bit bit/?)
                                     (//.natural natural/?)
                                     (//.integer integer/?)
                                     (//.revolution revolution/?)
                                     (//.decimal decimal/?)
                                     (//.text text/?)))
                     (and (same? bit/0 bit/?)
                          (same? natural/0 natural/?)
                          (same? integer/0 integer/?)
                          (same? revolution/0 revolution/?)
                          (same? decimal/0 decimal/?)
                          (same? text/0 text/?))

                     _
                     false))))
        //scope.with
        (//module.with 0 module/0)
        (phase#each (|>> product.right product.right))
        (phase.value state)
        (try.else false))))

(the (can_analyse_function! lux module/0 natural/0 [$abstraction/0 $parameter/0 $abstraction/1 $parameter/1])
  (-> Lux Text Natural [Code Code Code Code] Bit)
  (let [state [extension.#bundle (extension/analysis.bundle ..eval)
               extension.#state lux]

        can_make_abstraction!
        (|> (do phase.monad
              [[:it: it] (|> (` ([(, $abstraction/0) (, $parameter/0)] (, (code.natural natural/0))))
                             (/.phase ..expander archive.empty)
                             //type.inferring)]
              (in (and (type.= (for_any (_ a) (-> a .Natural))
                               :it:)
                       (when it
                         {//.#Function (list) (//.natural natural/?)}
                         (same? natural/0 natural/?)

                         _
                         false))))
            //scope.with
            (//module.with 0 module/0)
            (phase#each (|>> product.right product.right))
            (phase.value state)
            (try.else false))

        can_nest_abstraction!
        (|> (do phase.monad
              [[:it: it] (|> (` ([(, $abstraction/0) (, $parameter/0)]
                                 ([(, $abstraction/1) (, $parameter/1)]
                                  (, (code.natural natural/0)))))
                             (/.phase ..expander archive.empty)
                             //type.inferring)]
              (in (and (type.= (for_any (_ a) (-> a (for_any (_ b) (-> b .Natural))))
                               :it:)
                       (when it
                         {//.#Function (list) {//.#Function (list) (//.natural natural/?)}}
                         (same? natural/0 natural/?)

                         _
                         false))))
            //scope.with
            (//module.with 0 module/0)
            (phase#each (|>> product.right product.right))
            (phase.value state)
            (try.else false))

        can_refer_to_parameter!
        (|> (do phase.monad
              [[:it: it] (|> (` ([(, $abstraction/0) (, $parameter/0)]
                                 ([(, $abstraction/1) (, $parameter/1)]
                                  (, $parameter/1))))
                             (/.phase ..expander archive.empty)
                             //type.inferring)]
              (in (and (type.= (for_any (_ a) (-> a (for_any (_ b) (-> b b))))
                               :it:)
                       (when it
                         {//.#Function (list) {//.#Function (list) (//.local 1)}}
                         true

                         _
                         false))))
            //scope.with
            (//module.with 0 module/0)
            (phase#each (|>> product.right product.right))
            (phase.value state)
            (try.else false))

        can_refer_to_closure!
        (|> (do phase.monad
              [[:it: it] (|> (` ([(, $abstraction/0) (, $parameter/0)]
                                 ([(, $abstraction/1) (, $parameter/1)]
                                  (, $parameter/0))))
                             (/.phase ..expander archive.empty)
                             //type.inferring)]
              (in (and (when it
                         {//.#Function (list) {//.#Function (list (//.local 1)) (//.foreign 0)}}
                         true

                         _
                         false)
                       ... TODO: Un-comment
                       ... (type.= (for_any (_ a) (-> a (for_any (_ b) (-> b a))))
                       ...         :it:)
                       )))
            //scope.with
            (//module.with 0 module/0)
            (phase#each (|>> product.right product.right))
            (phase.value state)
            (try.else false))]
    (and can_make_abstraction!
         can_nest_abstraction!
         can_refer_to_parameter!
         can_refer_to_closure!
         ... TODO: Un-comment
         ... (|> (do phase.monad
         ...       [[:it: it] (|> (` ([(, $abstraction/0) (, $parameter/0)]
         ...                          ([(, $abstraction/1) (, $parameter/1)]
         ...                           (, $abstraction/1))))
         ...                      (/.phase ..expander archive.empty)
         ...                      //type.inferring)]
         ...       (in (when it
         ...             {//.#Function (list) {//.#Function (list) (//.local 0)}}
         ...             true

         ...             _
         ...             false)))
         ...     //scope.with
         ...     (//module.with 0 module/0)
         ...     (phase#each (|>> product.right product.right))
         ...     (phase.value state)
         ...     (try.else false))
         ... TODO: Un-comment
         ... (|> (do phase.monad
         ...       [[:it: it] (|> (` ([(, $abstraction/0) (, $parameter/0)]
         ...                          ([(, $abstraction/1) (, $parameter/1)]
         ...                           (, $abstraction/0))))
         ...                      (/.phase ..expander archive.empty)
         ...                      //type.inferring)]
         ...       (in (when it
         ...             {//.#Function (list) {//.#Function (list (//.local 0)) (//.foreign 0)}}
         ...             true

         ...             _
         ...             false)))
         ...     //scope.with
         ...     (//module.with 0 module/0)
         ...     (phase#each (|>> product.right product.right))
         ...     (phase.value state)
         ...     (try.else false))
         )))

(the (can_analyse_apply! lux module/0 bit/0 natural/0 [$abstraction/0 $parameter/0 $abstraction/1 $parameter/1])
  (-> Lux Text Bit Natural [Code Code Code Code] Bit)
  (let [state [extension.#bundle (extension/analysis.bundle ..eval)
               extension.#state lux]

        constant!
        (|> (do phase.monad
              [[:it: it] (|> (` (([(, $abstraction/0) (, $parameter/0)] (, (code.bit bit/0)))
                                 (, (code.natural natural/0))))
                             (/.phase ..expander archive.empty)
                             //type.inferring)]
              (in (and (type.= .Bit :it:)
                       (when it
                         {//.#Apply (//.natural natural/?)
                                    {//.#Function (list) (//.bit bit/?)}}
                         (and (same? bit/0 bit/?)
                              (same? natural/0 natural/?))

                         _
                         false))))
            //scope.with
            (//module.with 0 module/0)
            (phase#each (|>> product.right product.right))
            (phase.value state)
            (try.else false))

        variable!
        (|> (do phase.monad
              [[:it: it] (|> (` (([(, $abstraction/0) (, $parameter/0)] (, $parameter/0))
                                 (, (code.natural natural/0))))
                             (/.phase ..expander archive.empty)
                             //type.inferring)]
              (in (and (type.= .Natural :it:)
                       (when it
                         {//.#Apply (//.natural natural/?)
                                    {//.#Function (list) (//.local 1)}}
                         (same? natural/0 natural/?)

                         _
                         false))))
            //scope.with
            (//module.with 0 module/0)
            (phase#each (|>> product.right product.right))
            (phase.value state)
            (try.else false))

        partial!
        (|> (do phase.monad
              [[:it: it] (|> (` (([(, $abstraction/0) (, $parameter/0)]
                                  ([(, $abstraction/1) (, $parameter/1)]
                                   (, (code.bit bit/0))))
                                 (, (code.natural natural/0))))
                             (/.phase ..expander archive.empty)
                             //type.inferring)]
              (in (and (check.subsumed? (for_any (_ a) (-> a Bit)) :it:)
                       (when it
                         {//.#Apply (//.natural natural/?)
                                    {//.#Function (list)
                                                  {//.#Function (list) (//.bit bit/?)}}}
                         (and (same? bit/0 bit/?)
                              (same? natural/0 natural/?))

                         _
                         false))))
            //scope.with
            (//module.with 0 module/0)
            (phase#each (|>> product.right product.right))
            (phase.value state)
            (try.else false))]
    (and constant!
         variable!
         partial!)))

(the (can_analyse_extension! lux module/0 text/0)
  (-> Lux Text Text Bit)
  (let [state [extension.#bundle (extension/analysis.bundle ..eval)
               extension.#state lux]]
    (|> (do phase.monad
          [[:it: it] (|> (` (.text_composite# (, (code.text text/0)) (, (code.text text/0))))
                         (/.phase ..expander archive.empty)
                         //type.inferring)]
          (in (and (type.= .Text :it:)
                   (when it
                     {//.#Extension (symbol .text_composite#) (list (//.text left) (//.text right))}
                     (and (same? text/0 left)
                          (same? text/0 right))

                     _
                     false))))
        //scope.with
        (//module.with 0 module/0)
        (phase#each (|>> product.right product.right))
        (phase.value state)
        (try.else false))))

(the (can_analyse_pattern_matching! lux module/0 [@any @bit @natural @integer @revolution @decimal @text] [bit/0 natural/0 integer/0 revolution/0 decimal/0 text/0] $parameter/0)
  (-> Lux Text [.Text .Text .Text .Text .Text .Text .Text] [.Bit .Natural .Integer .Revolution .Decimal .Text] Code Bit)
  (let [state [extension.#bundle (extension/analysis.bundle ..eval)
               extension.#state lux]
        
        :variant: {.#Named [module/0 module/0]
                           (type (Or .Any .Bit .Natural .Integer .Revolution .Decimal .Text))}
        tags/* (list @any @bit @natural @integer @revolution @decimal @text)

        :record: {.#Named [module/0 module/0]
                          (type (And .Any .Bit .Natural .Integer .Revolution .Decimal .Text))}
        slots/* (list @any @bit @natural @integer @revolution @decimal @text)

        simple!
        (`` (and (,, (template.with [<input> <code> <analysis> <pattern>]
                       [(|> (do phase.monad
                              [[:it: it] (|> (` ({(, $parameter/0) (, (code.decimal decimal/0))} (, (<code> <input>))))
                                             (/.phase ..expander archive.empty)
                                             //type.inferring)]
                              (in (and (type.= .Decimal :it:)
                                       (when it
                                         {//.#When (<analysis> input/?)
                                                   [[//.#when (//pattern.bind 0)
                                                     //.#then (//.decimal decimal/?)]
                                                    (list)]}
                                         (and (same? <input> input/?)
                                              (same? decimal/0 decimal/?))

                                         _
                                         false))))
                            //scope.with
                            (//module.with 0 module/0)
                            (phase#each (|>> product.right product.right))
                            (phase.value state)
                            (try.else false))
                        (|> (do phase.monad
                              [[:it: it] (|> (` ({(, (<code> <input>))
                                                  (, (code.decimal decimal/0))

                                                  (, $parameter/0)
                                                  (, (code.decimal decimal/0))}
                                                 (, (<code> <input>))))
                                             (/.phase ..expander archive.empty)
                                             //type.inferring)]
                              (in (and (type.= .Decimal :it:)
                                       (when it
                                         {//.#When (<analysis> input/?)
                                                   [[//.#when (<pattern> pattern/?)
                                                     //.#then (//.decimal decimal/?)]
                                                    (list [//.#when (//pattern.bind 0)
                                                           //.#then (//.decimal decimal/?)])]}
                                         (and (same? <input> input/?)
                                              (same? <input> pattern/?)
                                              (same? decimal/0 decimal/?))

                                         _
                                         false))))
                            //scope.with
                            (//module.with 0 module/0)
                            (phase#each (|>> product.right product.right))
                            (phase.value state)
                            (try.else false))]

                       [bit/0 code.bit //.bit //pattern.bit]
                       [natural/0 code.natural //.natural //pattern.natural]
                       [integer/0 code.integer //.integer //pattern.integer]
                       [revolution/0 code.revolution //.revolution //pattern.revolution]
                       [decimal/0 code.decimal //.decimal //pattern.decimal]
                       [text/0 code.text //.text //pattern.text]
                       ))))

        bit!
        (|> (do phase.monad
              [[:it: it] (|> (` ({#0
                                  (, (code.decimal decimal/0))

                                  #1
                                  (, (code.decimal decimal/0))}
                                 (, (code.bit bit/0))))
                             (/.phase ..expander archive.empty)
                             //type.inferring)]
              (in (and (type.= .Decimal :it:)
                       (when it
                         {//.#When (//.bit bit/?)
                                   [[//.#when (//pattern.bit .false)
                                     //.#then (//.decimal false/?)]
                                    (list [//.#when (//pattern.bit .true)
                                           //.#then (//.decimal true/?)])]}
                         (and (same? bit/0 bit/?)
                              (same? decimal/0 false/?)
                              (same? decimal/0 true/?))

                         _
                         false))))
            //scope.with
            (//module.with 0 module/0)
            (phase#each (|>> product.right product.right))
            (phase.value state)
            (try.else false))

        variant!
        (`` (and (,, (template.with [<lefts> <right?> <expected> <tag> <code> <analysis> <pattern>]
                       [(|> (do phase.monad
                              [_ (//module.declare_labels false tags/* false :variant:)
                               [:it: it] (|> (` ({{(, (code.local <tag>)) (, (<code> <expected>))}
                                                  (, (code.decimal decimal/0))

                                                  (, $parameter/0)
                                                  (, (code.decimal decimal/0))}
                                                 {(, (code.local <tag>)) (, (<code> <expected>))}))
                                             (/.phase ..expander archive.empty)
                                             //type.inferring)]
                              (in (and (type.= .Decimal :it:)
                                       (when it
                                         {//.#When (//.variant [<lefts> <right?> (<analysis> analysis/?)])
                                                   [[//.#when (//pattern.variant [<lefts> <right?> (<pattern> pattern/?)])
                                                     //.#then (//.decimal match/?)]
                                                    (list [//.#when (//pattern.bind 0)
                                                           //.#then (//.decimal mismatch/?)])]}
                                         (and (same? <expected> analysis/?)
                                              (same? <expected> pattern/?)
                                              (same? decimal/0 match/?)
                                              (same? decimal/0 mismatch/?))

                                         _
                                         false))))
                            //scope.with
                            (//module.with 0 module/0)
                            (phase#each (|>> product.right product.right))
                            (phase.value state)
                            (try.else false))]

                       [1 #0 bit/0 @bit code.bit //.bit //pattern.bit]
                       [2 #0 natural/0 @natural code.natural //.natural //pattern.natural]
                       [3 #0 integer/0 @integer code.integer //.integer //pattern.integer]
                       [4 #0 revolution/0 @revolution code.revolution //.revolution //pattern.revolution]
                       [5 #0 decimal/0 @decimal code.decimal //.decimal //pattern.decimal]
                       [5 #1 text/0 @text code.text //.text //pattern.text]
                       ))))

        tuple!
        (|> (do phase.monad
              [[:it: it] (|> (` ({[#0 (, $parameter/0)]
                                  (, (code.decimal decimal/0))

                                  [#1 (, $parameter/0)]
                                  (, (code.decimal decimal/0))}
                                 [(, (code.bit bit/0))
                                  (, (code.natural natural/0))]))
                             (/.phase ..expander archive.empty)
                             //type.inferring)]
              (in (and (type.= .Decimal :it:)
                       (when it
                         {//.#When (//.tuple (list (//.bit bit/?) (//.natural natural/?)))
                                   [[//.#when (//pattern.tuple (list (//pattern.bit .false) (//pattern.bind 0)))
                                     //.#then (//.decimal false/?)]
                                    (list [//.#when (//pattern.tuple (list (//pattern.bit .true) (//pattern.bind 0)))
                                           //.#then (//.decimal true/?)])]}
                         (and (same? bit/0 bit/?)
                              (same? natural/0 natural/?)
                              (same? decimal/0 false/?)
                              (same? decimal/0 true/?))

                         _
                         false))))
            //scope.with
            (//module.with 0 module/0)
            (phase#each (|>> product.right product.right))
            (phase.value state)
            (try.else false))

        record!
        (|> (do phase.monad
              [_ (//module.declare_labels true slots/* false :record:)
               [:it: it] (|> (` ({[(, (code.symbol [module/0 @any])) []
                                   (, (code.symbol [module/0 @bit])) (, (code.bit bit/0))
                                   (, (code.symbol [module/0 @natural])) (, (code.natural natural/0))
                                   (, (code.symbol [module/0 @integer])) (, (code.integer integer/0))
                                   (, (code.symbol [module/0 @revolution])) (, (code.revolution revolution/0))
                                   (, (code.symbol [module/0 @decimal])) (, (code.decimal decimal/0))
                                   (, (code.symbol [module/0 @text])) (, (code.text text/0))]
                                  (, (code.decimal decimal/0))

                                  (, $parameter/0)
                                  (, (code.decimal decimal/0))}
                                 [(, (code.local @any)) []
                                  (, (code.local @bit)) (, (code.bit bit/0))
                                  (, (code.local @natural)) (, (code.natural natural/0))
                                  (, (code.local @integer)) (, (code.integer integer/0))
                                  (, (code.local @revolution)) (, (code.revolution revolution/0))
                                  (, (code.local @decimal)) (, (code.decimal decimal/0))
                                  (, (code.local @text)) (, (code.text text/0))]))
                             (/.phase ..expander archive.empty)
                             //type.inferring)]
              (in (and (type.= .Decimal :it:)
                       (when it
                         {//.#When (//.tuple (list (//.unit)
                                                   (//.bit bit/?)
                                                   (//.natural natural/?)
                                                   (//.integer integer/?)
                                                   (//.revolution revolution/?)
                                                   (//.decimal decimal/?)
                                                   (//.text text/?)))
                                   [[//.#when (//pattern.tuple (list (//pattern.unit)
                                                                     (//pattern.bit bit/?')
                                                                     (//pattern.natural natural/?')
                                                                     (//pattern.integer integer/?')
                                                                     (//pattern.revolution revolution/?')
                                                                     (//pattern.decimal decimal/?')
                                                                     (//pattern.text text/?')))
                                     //.#then (//.decimal match/?)]
                                    (list [//.#when (//pattern.bind 0)
                                           //.#then (//.decimal mismatch/?)])]}
                         (and (same? bit/0 bit/?) (same? bit/0 bit/?')
                              (same? natural/0 natural/?) (same? natural/0 natural/?')
                              (same? integer/0 integer/?) (same? integer/0 integer/?')
                              (same? revolution/0 revolution/?) (same? revolution/0 revolution/?')
                              (same? decimal/0 decimal/?) (same? decimal/0 decimal/?')
                              (same? text/0 text/?) (same? text/0 text/?')
                              (same? decimal/0 match/?)
                              (same? decimal/0 mismatch/?))

                         _
                         false))))
            //scope.with
            (//module.with 0 module/0)
            (phase#each (|>> product.right product.right))
            (phase.value state)
            (try.else false))]
    (and simple!
         bit!
         variant!
         tuple!
         record!)))

(the .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [lux $//type.random_state
         .let [state [extension.#bundle (extension/analysis.bundle ..eval)
                      extension.#state lux]]

         .let [[module/0 _] (symbol ._)]
         
         bit/0 random.bit
         natural/0 random.natural
         integer/0 random.integer
         revolution/0 random.revolution
         decimal/0 random.decimal
         text/0 (random.lower_cased 1)

         @any (random.lower_cased 2)
         @bit (random.lower_cased 3)
         @natural (random.lower_cased 4)
         @integer (random.lower_cased 5)
         @revolution (random.lower_cased 6)
         @decimal (random.lower_cased 7)
         @text (random.lower_cased 8)

         @left (random.lower_cased 9)
         @right (random.lower_cased 10)

         $abstraction/0 (of ! each code.local (random.lower_cased 11))
         $parameter/0 (of ! each code.local (random.lower_cased 12))
         $abstraction/1 (of ! each code.local (random.lower_cased 13))
         $parameter/1 (of ! each code.local (random.lower_cased 14))])
      (all _.and
           (_.coverage [/.phase]
             (and (..can_analyse_unit! lux module/0)
                  (..can_analyse_simple_literal_or_singleton_tuple! lux module/0 [bit/0 natural/0 integer/0 revolution/0 decimal/0 text/0])
                  (..can_analyse_sum! lux module/0 [@any @bit @natural @integer @revolution @decimal @text] [bit/0 natural/0 integer/0 revolution/0 decimal/0 text/0] [@left @right])
                  (..can_analyse_variant! lux module/0 [@any @bit @natural @integer @revolution @decimal @text] [bit/0 natural/0 integer/0 revolution/0 decimal/0 text/0] [@left @right])
                  (..can_analyse_tuple! lux module/0 [bit/0 natural/0 integer/0 revolution/0 decimal/0 text/0])
                  (..can_analyse_record! lux module/0 [@any @bit @natural @integer @revolution @decimal @text] [bit/0 natural/0 integer/0 revolution/0 decimal/0 text/0])
                  (..can_analyse_function! lux module/0 natural/0 [$abstraction/0 $parameter/0 $abstraction/1 $parameter/1])
                  (..can_analyse_apply! lux module/0 bit/0 natural/0 [$abstraction/0 $parameter/0 $abstraction/1 $parameter/1])
                  (..can_analyse_extension! lux module/0 text/0)
                  (..can_analyse_pattern_matching! lux module/0 [@any @bit @natural @integer @revolution @decimal @text] [bit/0 natural/0 integer/0 revolution/0 decimal/0 text/0] $parameter/0)
                  ))
           (_.coverage [/.invalid]
             (`` (and (,, (template.with [<syntax>]
                            [(|> (do phase.monad
                                   [_ (|> <syntax>
                                          (/.phase ..expander archive.empty)
                                          (//type.expecting .Any))]
                                   (in false))
                                 //scope.with
                                 (//module.with 0 module/0)
                                 (phase#each (|>> product.right product.right))
                                 (phase.value state)
                                 (exception.else (text.contains? (its exception.#label /.invalid))))]

                            [(` ({#0} (, (code.bit bit/0))))]
                            [(` ({#0 [] #1} (, (code.bit bit/0))))]
                            [(` {(, (code.bit bit/0)) (, (code.natural natural/0)) (, (code.integer integer/0)) (, (code.revolution revolution/0)) (, (code.decimal decimal/0)) (, (code.text text/0))})]
                            [(` {(, (code.natural natural/0)) (, (code.integer integer/0)) (, (code.revolution revolution/0)) (, (code.decimal decimal/0)) (, (code.text text/0)) (, (code.bit bit/0))})]
                            [(` {(, (code.integer integer/0)) (, (code.revolution revolution/0)) (, (code.decimal decimal/0)) (, (code.text text/0)) (, (code.bit bit/0)) (, (code.natural natural/0))})]
                            [(` {(, (code.revolution revolution/0)) (, (code.decimal decimal/0)) (, (code.text text/0)) (, (code.bit bit/0)) (, (code.natural natural/0)) (, (code.integer integer/0))})]
                            [(` {(, (code.decimal decimal/0)) (, (code.text text/0)) (, (code.bit bit/0)) (, (code.natural natural/0)) (, (code.integer integer/0)) (, (code.revolution revolution/0))})]
                            [(` {(, (code.text text/0)) (, (code.bit bit/0)) (, (code.natural natural/0)) (, (code.integer integer/0)) (, (code.revolution revolution/0)) (, (code.decimal decimal/0))})]
                            ))
                      )))
           
           /simple.test
           /complex.test
           /reference.test
           /function.test
           /when.test
           )))
