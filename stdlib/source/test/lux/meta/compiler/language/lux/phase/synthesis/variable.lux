... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except)
   [abstract
    ["[0]" monad (.only do)]]
   [control
    ["[0]" try]]
   [data
    ["[0]" product]
    [number
     ["n" nat]]
    [collection
     ["[0]" list (.use "[1]#[0]" functor mix)]
     ["[0]" dictionary (.only Dictionary)]]]
   [math
    ["[0]" random (.only Random)]]
   [meta
    [macro
     ["^" pattern]
     ["[0]" template]]]
   [test
    ["_" property (.only Test)]]]]
 [\\
  ["[0]" /
   [////
    ["[0]" analysis]
    ["[0]" synthesis (.only Side Member Path Synthesis)]
    [///
     [reference
      ["[0]" variable]]]]]])

(the !expect
  (template.macro (_ <pattern> <value>)
    (when <value>
      <pattern>
      true
      
      _
      false)))

(every Context
  [#redundants Nat
   #necessary (Dictionary Nat Nat)])

(every (Scenario a)
  (-> Context (Random [a a])))

(template.with [<name> <synthesis> <random>]
  [(the (<name> context)
     (Scenario Synthesis)
     (do [! random.monad]
       [value <random>]
       (in [(<synthesis> value)
            (<synthesis> value)])))]

  [bit_scenario synthesis.bit random.bit]
  [i64_scenario synthesis.i64 (of ! each .i64 random.nat)]
  [f64_scenario synthesis.f64 random.dec]
  [text_scenario synthesis.text (random.unicode 1)]
  )

(the (primitive_scenario context)
  (Scenario Synthesis)
  (random.either (random.either (..bit_scenario context)
                                (..i64_scenario context))
                 (random.either (..f64_scenario context)
                                (..text_scenario context))))

(the (with_redundancy scenario context)
  (-> (Scenario Synthesis) (Scenario Synthesis))
  (do [! random.monad]
    [redundant? random.bit]
    (if redundant?
      (do !
        [let? random.bit
         [expected_input actual_input] (..primitive_scenario context)
         .let [fake_register (n.+ (its #redundants context)
                                  (dictionary.size (its #necessary context)))]
         [expected_output actual_output] (scenario (revised #redundants ++ context))]
        (in [(synthesis.when [expected_input
                              {synthesis.#Seq {synthesis.#Pop}
                                              {synthesis.#Then expected_output}}])
             (if let?
               (synthesis.let [actual_input fake_register actual_output])
               (synthesis.when [actual_input
                                {synthesis.#Seq {synthesis.#Bind fake_register}
                                                {synthesis.#Seq {synthesis.#Pop}
                                                                {synthesis.#Then actual_output}}}]))]))
      (scenario context))))

(the (variant_scenario scenario context)
  (-> (Scenario Synthesis) (Scenario Synthesis))
  (do [! random.monad]
    [lefts random.nat
     right? random.bit
     [expected input] (scenario context)]
    (in [(synthesis.variant [lefts right? expected])
         (synthesis.variant [lefts right? input])])))

(the (tuple_scenario context)
  (Scenario Synthesis)
  (let [registers (dictionary.entries (its #necessary context))]
    (of random.monad in
        [(synthesis.tuple (list#each (|>> product.left synthesis.local) registers))
         (synthesis.tuple (list#each (|>> product.right synthesis.local) registers))])))

(the (structure_scenario context)
  (Scenario Synthesis)
  (random.either (..variant_scenario (..with_redundancy ..tuple_scenario) context)
                 (..tuple_scenario context)))

(the (let_scenario scenario context)
  (-> (Scenario Synthesis) (Scenario Synthesis))
  (do random.monad
    [_ (in [])
     [expected_input actual_input] (scenario context)
     .let [real_register (dictionary.size (its #necessary context))
           fake_register (n.+ (its #redundants context)
                              (dictionary.size (its #necessary context)))]
     [expected_output actual_output] (scenario (revised #necessary (dictionary.has real_register fake_register) context))]
    (in [(synthesis.let [expected_input real_register expected_output])
         (synthesis.let [actual_input fake_register actual_output])])))

(the (if_scenario scenario context)
  (-> (Scenario Synthesis) (Scenario Synthesis))
  (do random.monad
    [_ (in [])
     [expected_test actual_test] (scenario context)
     [expected_then actual_then] (scenario context)
     [expected_else actual_else] (scenario context)]
    (in [(synthesis.if [expected_test
                        expected_then
                        expected_else])
         (synthesis.if [actual_test
                        actual_then
                        actual_else])])))

(the random_member
  (Random Member)
  (do random.monad
    [lefts random.nat
     right? random.bit]
    (in (if right?
          {.#Right lefts}
          {.#Left lefts}))))

(the (get_scenario scenario context)
  (-> (Scenario Synthesis) (Scenario Synthesis))
  (do [! random.monad]
    [length (of ! each (|>> (n.% 5) ++) random.nat)
     path (random.list length ..random_member)
     [expected_record actual_record] (scenario context)]
    (in [(synthesis.get [path expected_record])
         (synthesis.get [path actual_record])])))

(the random_side
  (Random Side)
  ..random_member)

(the (path_scenario scenario context)
  (-> (Scenario Synthesis) (Scenario Path))
  (`` (all random.either
           (all random.either
                (do [! random.monad]
                  [_ (in [])
                   [expected_then actual_then] (scenario context)]
                  (in [{synthesis.#Seq {synthesis.#Pop}
                                       {synthesis.#Then expected_then}}
                       {synthesis.#Seq {synthesis.#Pop}
                                       {synthesis.#Then actual_then}}]))
                (do [! random.monad]
                  [_ (in [])
                   .let [real_register (dictionary.size (its #necessary context))
                         fake_register (n.+ (its #redundants context)
                                            (dictionary.size (its #necessary context)))]
                   [expected_then actual_then] (scenario (revised #necessary (dictionary.has real_register fake_register) context))]
                  (in [{synthesis.#Seq {synthesis.#Bind real_register}
                                       {synthesis.#Seq {synthesis.#Pop}
                                                       {synthesis.#Then expected_then}}}
                       {synthesis.#Seq {synthesis.#Bind fake_register}
                                       {synthesis.#Seq {synthesis.#Pop}
                                                       {synthesis.#Then actual_then}}}])))
           (all random.either
                (,, (template.with [<tag> <random>]
                      [(do [! random.monad]
                         [test <random>
                          [expected_then actual_then] (scenario context)]
                         (in [{synthesis.#Seq {synthesis.#Test {<tag> test}}
                                              {synthesis.#Then expected_then}}
                              {synthesis.#Seq {synthesis.#Test {<tag> test}}
                                              {synthesis.#Then actual_then}}]))]

                      [synthesis.#Bit random.bit]
                      [synthesis.#I64 (of ! each .i64 random.nat)]
                      [synthesis.#F64 random.dec]
                      [synthesis.#Text (random.unicode 1)]
                      )))
           (all random.either
                (do [! random.monad]
                  [side ..random_side
                   [expected_next actual_next] (path_scenario scenario context)]
                  (in [{synthesis.#Seq {synthesis.#Access {synthesis.#Side side}}
                                       expected_next}
                       {synthesis.#Seq {synthesis.#Access {synthesis.#Side side}}
                                       actual_next}]))
                (do [! random.monad]
                  [member ..random_member
                   [expected_next actual_next] (path_scenario scenario context)]
                  (in [{synthesis.#Seq {synthesis.#Access {synthesis.#Member member}}
                                       expected_next}
                       {synthesis.#Seq {synthesis.#Access {synthesis.#Member member}}
                                       actual_next}])))
           (do [! random.monad]
             [_ (in [])
              [expected_left actual_left] (path_scenario scenario context)
              [expected_right actual_right] (path_scenario scenario context)]
             (in [{synthesis.#Alt expected_left expected_right}
                  {synthesis.#Alt actual_left actual_right}]))
           )))

(the (when_scenario scenario context)
  (-> (Scenario Synthesis) (Scenario Synthesis))
  (do [! random.monad]
    [_ (in [])
     [expected_input actual_input] (scenario context)
     [expected_path actual_path] (..path_scenario scenario context)]
    (in [(synthesis.when [expected_input expected_path])
         (synthesis.when [actual_input actual_path])])))

(the (branch_scenario scenario context)
  (-> (Scenario Synthesis) (Scenario Synthesis))
  (all random.either
       (..let_scenario scenario context)
       (..if_scenario scenario context)
       (..get_scenario scenario context)
       (..when_scenario scenario context)
       ))

(the scope_arity 5)

(the (scope_scenario scenario context)
  (-> (Scenario Synthesis) (Scenario Synthesis))
  (do [! random.monad]
    [_ (in [])
     .let [real_start (dictionary.size (its #necessary context))
           fake_start (n.+ (its #redundants context)
                           real_start)]
     inits (random.list ..scope_arity (scenario context))
     [expected_iteration actual_iteration] (scenario (revised #necessary
                                                              (function (_ necessary)
                                                                (list#mix (function (_ [idx _] context)
                                                                            (dictionary.has (n.+ real_start idx)
                                                                                            (n.+ fake_start idx)
                                                                                            context))
                                                                          necessary
                                                                          (list.enumeration inits)))
                                                              context))]
    (in [(synthesis.scope [real_start (list#each product.left inits) expected_iteration])
         (synthesis.scope [fake_start (list#each product.right inits) actual_iteration])])))

(the (again_scenario scenario context)
  (-> (Scenario Synthesis) (Scenario Synthesis))
  (do [! random.monad]
    [_ (in [])
     resets (random.list ..scope_arity (scenario context))]
    (in [(synthesis.again (list#each product.left resets))
         (synthesis.again (list#each product.right resets))])))

(the (loop_scenario scenario context)
  (-> (Scenario Synthesis) (Scenario Synthesis))
  (all random.either
       (..scope_scenario scenario context)
       (..again_scenario scenario context)
       ))

(the (abstraction_scenario scenario context)
  (-> (Scenario Synthesis) (Scenario Synthesis))
  (do [! random.monad]
    [_ (in [])
     .let [registers (dictionary.entries (its #necessary context))
           expected_environment (list#each (|>> product.left {variable.#Local}) registers)
           actual_environment (list#each (|>> product.right {variable.#Local}) registers)]
     [expected_body actual_body] (..primitive_scenario context)]
    (in [(synthesis.abstraction [expected_environment 1 expected_body])
         (synthesis.abstraction [actual_environment 1 actual_body])])))

(the (apply_scenario scenario context)
  (-> (Scenario Synthesis) (Scenario Synthesis))
  (do [! random.monad]
    [abstraction (of ! each (|>> synthesis.constant)
                     (random.and (random.unicode 1)
                                 (random.unicode 1)))
     inputs (random.list ..scope_arity (scenario context))]
    (in [(synthesis.apply [abstraction (list#each product.left inputs)])
         (synthesis.apply [abstraction (list#each product.right inputs)])])))

(the (function_scenario scenario context)
  (-> (Scenario Synthesis) (Scenario Synthesis))
  (all random.either
       (..abstraction_scenario scenario context)
       (..apply_scenario scenario context)
       ))

(the (control_scenario scenario context)
  (-> (Scenario Synthesis) (Scenario Synthesis))
  (all random.either
       (..branch_scenario scenario context)
       (..loop_scenario scenario context)
       (..function_scenario scenario context)
       ))

(the (scenario context)
  (Scenario Synthesis)
  (all random.either
       (..primitive_scenario context)
       (..structure_scenario context)
       (..control_scenario (..with_redundancy
                             (..control_scenario
                              (..with_redundancy
                                ..structure_scenario)))
                           context)
       ))

(the default
  Context
  [#redundants 0
   #necessary (dictionary.empty n.hash)])

(the .public test
  Test
  (<| (_.covering /._)
      (all _.and
           (do random.monad
             [[expected input] (..scenario ..default)]
             (_.coverage [/.optimization]
               (|> (/.optimization input)
                   (!expect (^.multi {try.#Success actual}
                                     (of synthesis.equivalence = expected actual))))))
           )))
