(.require
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" try]]
   [data
    [collection
     ["[0]" list]
     ["[0]" sequence]]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" nat]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" / (.only)
   [////
    [meta
     [archive
      ["[0]" registry]]]]]])

(def dummy_host
  (/.Host Any Any)
  (implementation
   (def (evaluate _ _)
     {try.#Failure ""})
   (def (execute _)
     {try.#Failure ""})
   (def (define _ _ _)
     {try.#Failure ""})

   (def (ingest _ _)
     [])
   (def (re_learn _ _ _)
     {try.#Failure ""})
   (def (re_load _ _ _)
     {try.#Failure ""})))

(def .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [expected_module (random.lower_cased 1)])
      (all _.and
           (_.coverage [/.Host]
             true)
           (_.coverage [/.Operation /.Phase]
             true)
           (_.for [/.State
                   /.#module /.#anchor /.#host /.#buffer
                   /.#registry /.#registry_shift
                   /.#counter /.#context /.#log /.#interim_artifacts]
                  (all _.and
                       (_.coverage [/.state]
                         (let [it (is (/.State Any Any Any)
                                      (/.state ..dummy_host expected_module))]
                           (and (same? expected_module (the /.#module it))
                                (when (the /.#anchor it) {.#None} true _ false)
                                (same? ..dummy_host (the /.#host it))
                                (when (the /.#buffer it) {.#None} true _ false)
                                (same? registry.empty (the /.#registry it))
                                (n.= 0 (the /.#registry_shift it))
                                (n.= 0 (the /.#counter it))
                                (when (the /.#context it) {.#None} true _ false)
                                (sequence.empty? (the /.#log it))
                                (list.empty? (the /.#interim_artifacts it)))))
                       ))
           (_.for [/.Buffer]
                  (all _.and
                       (_.coverage [/.empty_buffer]
                         (sequence.empty? /.empty_buffer))
                       ))
           )))
