(.module:
  [library
   [lux "*"
    ["[0]" debug]
    ["@" target
     ["[0]" jvm]
     ["[0]" js]
     ["[0]" python]
     ["[0]" lua]
     ["[0]" ruby]
     ["[0]" php]
     ["[0]" scheme]]
    [abstract
     ["[0]" monad {"+" [do]}]]
    [control
     ["[0]" try]
     ["<>" parser
      ["<[0]>" code]
      ["<[0]>" analysis]
      ["<[0]>" synthesis]]]
    [data
     ["[0]" product]
     ["[0]" text ("[1]\[0]" equivalence)
      ["%" format {"+" [format]}]]
     [collection
      ["[0]" row]
      ["[0]" list ("[1]\[0]" functor)]]]
    [math
     ["[0]" random]
     [number
      ["n" nat]]]
    [tool
     [compiler
      ["[0]" phase]
      [language
       [lux
        ["[0]" analysis]
        ["[0]" synthesis]
        ["[0]" directive]
        [phase
         [analysis
          ["[0]" type]]]]]]]
    ["_" test {"+" [Test]}]]]
  [\\library
   ["[0]" / {"+" [analysis: synthesis: generation: directive:]}]])

(def: my_analysis "my analysis")
(def: my_synthesis "my synthesis")
(def: my_generation "my generation")
(def: dummy_generation "dummy generation")
(def: my_directive "my directive")

... Generation
(for [@.old
      (as_is)]
     
     (as_is
      ... Analysis
      (analysis: (..my_analysis self phase archive [pass_through <code>.any])
        (phase archive pass_through))

      ... Synthesis
      (analysis: (..my_synthesis self phase archive [parameters (<>.some <code>.any)])
        (let [! phase.monad]
          (|> parameters
              (monad.each ! (phase archive))
              (\ ! each (|>> (#analysis.Extension self))))))

      (synthesis: (..my_synthesis self phase archive [pass_through <analysis>.any])
        (phase archive pass_through))

      ... Generation
      (analysis: (..my_generation self phase archive [parameters (<>.some <code>.any)])
        (let [! phase.monad]
          (|> parameters
              (monad.each ! (phase archive))
              (\ ! each (|>> (#analysis.Extension self))))))

      (synthesis: (..my_generation self phase archive [parameters (<>.some <analysis>.any)])
        (let [! phase.monad]
          (|> parameters
              (monad.each ! (phase archive))
              (\ ! each (|>> (#synthesis.Extension self))))))

      (generation: (..my_generation self phase archive [pass_through <synthesis>.any])
        (for [@.jvm
              (\ phase.monad each (|>> #jvm.Embedded row.row)
                 (phase archive pass_through))]
             (phase archive pass_through)))

      (analysis: (..dummy_generation self phase archive [])
        (\ phase.monad in (#analysis.Extension self (list))))

      (synthesis: (..dummy_generation self phase archive [])
        (\ phase.monad in (#synthesis.Extension self (list))))

      (generation: (..dummy_generation self phase archive [])
        (\ phase.monad in
           (for [@.jvm
                 (row.row (#jvm.Constant (#jvm.LDC (#jvm.String self))))

                 @.js (js.string self)
                 @.python (python.unicode self)
                 @.lua (lua.string self)
                 @.ruby (ruby.string self)
                 @.php (php.string self)
                 @.scheme (scheme.string self)])))

      ... Directive
      (directive: (..my_directive self phase archive [parameters (<>.some <code>.any)])
        (do phase.monad
          [.let [_ (debug.log! (format "Successfully installed directive " (%.text self) "!"))]]
          (in directive.no_requirements)))

      (`` ((~~ (static ..my_directive))))
      ))

(def: .public test
  Test
  (<| (_.covering /._)
      (do random.monad
        [expected random.nat]
        (`` ($_ _.and
                (~~ (template [<macro> <extension>]
                      [(_.cover [<macro>]
                                (for [@.old
                                      false]
                                     (n.= expected
                                          (`` ((~~ (static <extension>)) expected)))))]

                      [/.analysis: ..my_analysis]
                      [/.synthesis: ..my_synthesis]))
                (_.cover [/.generation:]
                         (for [@.old
                               false]
                              (and (n.= expected
                                        (`` ((~~ (static ..my_generation)) expected)))
                                   (text\= ..dummy_generation
                                           (`` ((~~ (static ..dummy_generation))))))))
                (_.cover [/.directive:]
                         true)
                )))))
