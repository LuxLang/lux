(.using
 [library
  [lux "*"
   ["[0]" debug]
   ["@" target
    ["[0]" jvm]
    ["[0]" js]
    ["[0]" python]
    ["[0]" lua]
    ["[0]" ruby]
    ["[0]" php]
    ["[0]" scheme]]
   [abstract
    ["[0]" monad {"+" do}]]
   [control
    ["[0]" try]
    ["<>" parser
     ["<[0]>" code]
     ["<[0]>" analysis]
     ["<[0]>" synthesis]]]
   [data
    ["[0]" product]
    ["[0]" text ("[1]#[0]" equivalence)
     ["%" format {"+" format}]]
    [collection
     ["[0]" sequence]
     ["[0]" list ("[1]#[0]" functor)]]]
   [macro
    ["[0]" template]]
   [math
    ["[0]" random]
    [number
     ["n" nat]]]
   [tool
    [compiler
     ["[0]" phase]
     [meta
      [archive
       ["[0]" artifact]]]
     [language
      [lux
       ["[0]" analysis]
       ["[0]" synthesis]
       ["[0]" generation]
       ["[0]" directive]
       [phase
        [analysis
         ["[0]" type]]]]]]]
   ["_" test {"+" Test}]]]
 [\\library
  ["[0]" / {"+" analysis: synthesis: generation: directive:}]])

(def: dummy_generation "dummy generation")

(template [<name>]
  [(def: <name>
     Text
     (`` (%.symbol (symbol (~~ (template.symbol [.._ <name>]))))))]

  [analysis]
  [synthesis]
  [generation]
  [directive]
  )

... Generation
(for [@.old
      (as_is)]
     
     (as_is
      (for [@.python
            ... TODO: Remove this hack once Jython is no longer being used as the Python interpreter.
            (analysis: ("dummy dum dum" self phase archive [])
              (undefined))]
           (as_is))
      
      ... Analysis
      (analysis: (..analysis self phase archive [pass_through <code>.any])
        (phase archive pass_through))

      ... Synthesis
      (analysis: (..synthesis self phase archive [parameters (<>.some <code>.any)])
        (let [! phase.monad]
          (|> parameters
              (monad.each ! (phase archive))
              (# ! each (|>> {analysis.#Extension self})))))

      (synthesis: (..synthesis self phase archive [pass_through <analysis>.any])
        (phase archive pass_through))

      ... Generation
      (analysis: (..generation self phase archive [parameters (<>.some <code>.any)])
        (let [! phase.monad]
          (|> parameters
              (monad.each ! (phase archive))
              (# ! each (|>> {analysis.#Extension self})))))

      (synthesis: (..generation self phase archive [parameters (<>.some <analysis>.any)])
        (let [! phase.monad]
          (|> parameters
              (monad.each ! (phase archive))
              (# ! each (|>> {synthesis.#Extension self})))))

      (generation: (..generation self phase archive [pass_through <synthesis>.any])
        (for [@.jvm
              (# phase.monad each (|>> {jvm.#Embedded} sequence.sequence)
                 (phase archive pass_through))]
             (phase archive pass_through)))

      (analysis: (..dummy_generation self phase archive [])
        (# phase.monad in {analysis.#Extension self (list)}))

      (synthesis: (..dummy_generation self phase archive [])
        (# phase.monad in {synthesis.#Extension self (list)}))

      (generation: (..dummy_generation self phase archive [])
        (# phase.monad in
           (for [@.jvm
                 (sequence.sequence {jvm.#Constant {jvm.#LDC {jvm.#String self}}})

                 @.js (js.string self)
                 @.python (python.unicode self)
                 @.lua (lua.string self)
                 @.ruby (ruby.string self)
                 @.php (php.string self)
                 @.scheme (scheme.string self)])))

      ... Directive
      (directive: (..directive self phase archive [expression <code>.any])
        (do [! phase.monad]
          [analysis_phase directive.analysis
           expressionA (directive.lifted_analysis
                        (type.with_type .Any
                          (analysis_phase archive expression)))

           synthesis_phase directive.synthesis
           expressionS (directive.lifted_synthesis
                        (synthesis_phase archive expressionA))

           generation_phase directive.generation
           expressionG (directive.lifted_generation
                        (generation_phase archive expressionS))
           
           _ (directive.lifted_generation
              (generation.with_new_context archive artifact.no_dependencies
                (do !
                  [[module_id artifact_id] (generation.context archive)
                   .let [commentary (format "Successfully installed directive " (%.text self) "!")]
                   _ (for [@.jvm (in [])
                           @.js (generation.save! artifact_id {.#None}
                                                  (js.comment commentary
                                                    (js.statement (js.string commentary))))
                           @.lua (generation.save! artifact_id {.#None}
                                                   (lua.comment commentary
                                                     (lua.statement (lua.string commentary))))
                           @.ruby (generation.save! artifact_id {.#None}
                                                    (ruby.comment commentary
                                                      (ruby.statement (ruby.string commentary))))])]
                  (generation.log! commentary))))]
          (in directive.no_requirements)))

      ... TODO: No longer skip testing Lua after Rembulan isn't being used anymore.
      (for [@.lua (as_is)]
           (`` ((~~ (static ..directive)) (n.* 2 3))))
      ))

(def: .public test
  Test
  (<| (_.covering /._)
      (do random.monad
        [expected random.nat]
        (`` ($_ _.and
                (~~ (template [<macro> <extension>]
                      [(_.cover [<macro>]
                                (for [@.old
                                      false]
                                     (n.= expected
                                          (`` ((~~ (static <extension>)) expected)))))]

                      [/.analysis: ..analysis]
                      [/.synthesis: ..synthesis]))
                (_.cover [/.generation:]
                         (for [@.old
                               false]
                              (and (n.= expected
                                        (`` ((~~ (static ..generation)) expected)))
                                   (text#= ..dummy_generation
                                           (`` ((~~ (static ..dummy_generation))))))))
                (_.cover [/.directive:]
                         true)
                )))))
