(.module:
  [library
   [lux #*
    [type (#+ :sharing)]
    ["_" test (#+ Test)]
    [abstract
     [equivalence (#+ Equivalence)]
     [functor (#+ Functor)]
     [apply (#+ Apply)]
     ["." monad (#+ Monad do)]
     ["." enum]
     [\\specification
      ["$." functor (#+ Injection Comparison)]
      ["$." apply]
      ["$." monad]]]
    [control
     ["." try (#+ Try)]]
    [data
     [collection
      ["." list]]]
    [math
     ["." random]
     [number
      ["n" nat]]]]]
  [\\library
   ["." / (#+ Region)
    [//
     ["." thread (#+ Thread)]
     ["." exception (#+ Exception exception:)]]]])

(exception: oops)

(def: (success? result)
  (All [a] (-> (Try a) Bit))
  (case result
    (#try.Success _)
    true
    
    (#try.Failure _)
    false))

(def: (throws? exception result)
  (All [e a] (-> (Exception e) (Try a) Bit))
  (case result
    (#try.Success _)
    false
    
    (#try.Failure error)
    (exception.match? exception error)))

(def: (injection value)
  (Injection (All [a] (All [! r] (Region r (Thread !) a))))
  (function (_ [region scope])
    (function (_ !)
      [scope
       (#try.Success value)])))

(def: comparison
  (Comparison (All [a] (All [! r] (Region r (Thread !) a))))
  (function (_ == left right)
    (case [(:sharing [a]
                     (Equivalence a)
                     ==
                     
                     (Try a)
                     (thread.run (:assume (/.run thread.monad left))))
           (:sharing [a]
                     (Equivalence a)
                     ==
                     
                     (Try a)
                     (thread.run (:assume (/.run thread.monad right))))]
      [(#try.Success left) (#try.Success right)]
      (== left right)

      _
      false)))

(def: #export test
  Test
  (<| (_.covering /._)
      (_.for [/.Region])
      (do {! random.monad}
        [expected_clean_ups (|> random.nat (\ ! map (|>> (n.% 100) (n.max 1))))]
        ($_ _.and
            (_.for [/.functor]
                   ($functor.spec ..injection ..comparison (: (All [! r]
                                                                (Functor (Region r (thread.Thread !))))
                                                              (/.functor thread.functor))))
            (_.for [/.apply]
                   ($apply.spec ..injection ..comparison (: (All [! r]
                                                              (Apply (Region r (thread.Thread !))))
                                                            (/.apply thread.monad))))
            (_.for [/.monad]
                   ($monad.spec ..injection ..comparison (: (All [! r]
                                                              (Monad (Region r (thread.Thread !))))
                                                            (/.monad thread.monad))))
            
            (_.cover [/.run]
                     (thread.run
                      (do {! thread.monad}
                        [clean_up_counter (thread.box 0)
                         #let [//@ !
                               count_clean_up (function (_ value)
                                                (do !
                                                  [_ (thread.update inc clean_up_counter)]
                                                  (in (#try.Success []))))]
                         outcome (/.run !
                                        (do {! (/.monad !)}
                                          [_ (monad.map ! (/.acquire //@ count_clean_up)
                                                        (enum.range n.enum 1 expected_clean_ups))]
                                          (in [])))
                         actual_clean_ups (thread.read clean_up_counter)]
                        (in (and (..success? outcome)
                                 (n.= expected_clean_ups
                                      actual_clean_ups))))))
            (_.cover [/.failure]
                     (thread.run
                      (do {! thread.monad}
                        [clean_up_counter (thread.box 0)
                         #let [//@ !
                               count_clean_up (function (_ value)
                                                (do !
                                                  [_ (thread.update inc clean_up_counter)]
                                                  (in (#try.Success []))))]
                         outcome (/.run !
                                        (do {! (/.monad !)}
                                          [_ (monad.map ! (/.acquire //@ count_clean_up)
                                                        (enum.range n.enum 1 expected_clean_ups))
                                           _ (/.failure //@ (exception.error ..oops []))]
                                          (in [])))
                         actual_clean_ups (thread.read clean_up_counter)]
                        (in (and (..throws? ..oops outcome)
                                 (n.= expected_clean_ups
                                      actual_clean_ups))))))
            (_.cover [/.except]
                     (thread.run
                      (do {! thread.monad}
                        [clean_up_counter (thread.box 0)
                         #let [//@ !
                               count_clean_up (function (_ value)
                                                (do !
                                                  [_ (thread.update inc clean_up_counter)]
                                                  (in (#try.Success []))))]
                         outcome (/.run !
                                        (do {! (/.monad !)}
                                          [_ (monad.map ! (/.acquire //@ count_clean_up)
                                                        (enum.range n.enum 1 expected_clean_ups))
                                           _ (/.except //@ ..oops [])]
                                          (in [])))
                         actual_clean_ups (thread.read clean_up_counter)]
                        (in (and (..throws? ..oops outcome)
                                 (n.= expected_clean_ups
                                      actual_clean_ups))))))
            (_.cover [/.acquire /.clean_up_error]
                     (thread.run
                      (do {! thread.monad}
                        [clean_up_counter (thread.box 0)
                         #let [//@ !
                               count_clean_up (function (_ value)
                                                (do !
                                                  [_ (thread.update inc clean_up_counter)]
                                                  (in (: (Try Any)
                                                         (exception.except ..oops [])))))]
                         outcome (/.run !
                                        (do {! (/.monad !)}
                                          [_ (monad.map ! (/.acquire //@ count_clean_up)
                                                        (enum.range n.enum 1 expected_clean_ups))]
                                          (in [])))
                         actual_clean_ups (thread.read clean_up_counter)]
                        (in (and (or (n.= 0 expected_clean_ups)
                                     (..throws? /.clean_up_error outcome))
                                 (n.= expected_clean_ups
                                      actual_clean_ups))))))
            (_.cover [/.lift]
                     (thread.run
                      (do {! thread.monad}
                        [clean_up_counter (thread.box 0)
                         #let [//@ !]
                         outcome (/.run !
                                        (do (/.monad !)
                                          [_ (/.lift //@ (thread.write expected_clean_ups clean_up_counter))]
                                          (in [])))
                         actual_clean_ups (thread.read clean_up_counter)]
                        (in (and (..success? outcome)
                                 (n.= expected_clean_ups
                                      actual_clean_ups))))))
            ))))
