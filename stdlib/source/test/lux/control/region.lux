(.using
 [library
  [lux "*"
   [type {"+" sharing}]
   ["_" test {"+" Test}]
   [abstract
    [equivalence {"+" Equivalence}]
    [functor {"+" Functor}]
    [apply {"+" Apply}]
    ["[0]" monad {"+" Monad do}]
    ["[0]" enum]
    [\\specification
     ["$[0]" functor {"+" Injection Comparison}]
     ["$[0]" apply]
     ["$[0]" monad]]]
   [control
    ["[0]" try {"+" Try}]]
   [data
    [collection
     ["[0]" list]]]
   [math
    ["[0]" random]
    [number
     ["n" nat]]]]]
 [\\library
  ["[0]" / {"+" Region}
   [//
    ["[0]" thread {"+" Thread}]
    ["[0]" exception {"+" Exception exception:}]]]])

(exception: oops)

(def: (success? result)
  (All (_ a) (-> (Try a) Bit))
  (case result
    {try.#Success _}
    true
    
    {try.#Failure _}
    false))

(def: (throws? exception result)
  (All (_ e a) (-> (Exception e) (Try a) Bit))
  (case result
    {try.#Success _}
    false
    
    {try.#Failure error}
    (exception.match? exception error)))

(def: (injection value)
  (Injection (All (_ a) (All (_ ! r) (Region r (Thread !) a))))
  (function (_ [region scope])
    (function (_ !)
      [scope
       {try.#Success value}])))

(def: comparison
  (Comparison (All (_ a) (All (_ ! r) (Region r (Thread !) a))))
  (function (_ == left right)
    (case [(sharing [a]
                    (Equivalence a)
                    ==
                    
                    (Try a)
                    (thread.result (as_expected (/.run! thread.monad left))))
           (sharing [a]
                    (Equivalence a)
                    ==
                    
                    (Try a)
                    (thread.result (as_expected (/.run! thread.monad right))))]
      [{try.#Success left} {try.#Success right}]
      (== left right)

      _
      false)))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Region])
      (do [! random.monad]
        [expected_clean_ups (|> random.nat (# ! each (|>> (n.% 100) (n.max 1))))]
        (all _.and
             (_.for [/.functor]
                    ($functor.spec ..injection ..comparison (is (All (_ ! r)
                                                                  (Functor (Region r (thread.Thread !))))
                                                                (/.functor thread.functor))))
             (_.for [/.apply]
                    ($apply.spec ..injection ..comparison (is (All (_ ! r)
                                                                (Apply (Region r (thread.Thread !))))
                                                              (/.apply thread.monad))))
             (_.for [/.monad]
                    ($monad.spec ..injection ..comparison (is (All (_ ! r)
                                                                (Monad (Region r (thread.Thread !))))
                                                              (/.monad thread.monad))))
             
             (_.coverage [/.run!]
               (thread.result
                (do [! thread.monad]
                  [clean_up_counter (thread.box 0)
                   .let [//@ !
                         count_clean_up (function (_ value)
                                          (do !
                                            [_ (thread.update! ++ clean_up_counter)]
                                            (in {try.#Success []})))]
                   outcome (/.run! !
                                   (do [! (/.monad !)]
                                     [_ (monad.each ! (/.acquire! //@ count_clean_up)
                                                    (enum.range n.enum 1 expected_clean_ups))]
                                     (in [])))
                   actual_clean_ups (thread.read! clean_up_counter)]
                  (in (and (..success? outcome)
                           (n.= expected_clean_ups
                                actual_clean_ups))))))
             (_.coverage [/.failure]
               (thread.result
                (do [! thread.monad]
                  [clean_up_counter (thread.box 0)
                   .let [//@ !
                         count_clean_up (function (_ value)
                                          (do !
                                            [_ (thread.update! ++ clean_up_counter)]
                                            (in {try.#Success []})))]
                   outcome (/.run! !
                                   (do [! (/.monad !)]
                                     [_ (monad.each ! (/.acquire! //@ count_clean_up)
                                                    (enum.range n.enum 1 expected_clean_ups))
                                      _ (/.failure //@ (exception.error ..oops []))]
                                     (in [])))
                   actual_clean_ups (thread.read! clean_up_counter)]
                  (in (and (..throws? ..oops outcome)
                           (n.= expected_clean_ups
                                actual_clean_ups))))))
             (_.coverage [/.except]
               (thread.result
                (do [! thread.monad]
                  [clean_up_counter (thread.box 0)
                   .let [//@ !
                         count_clean_up (function (_ value)
                                          (do !
                                            [_ (thread.update! ++ clean_up_counter)]
                                            (in {try.#Success []})))]
                   outcome (/.run! !
                                   (do [! (/.monad !)]
                                     [_ (monad.each ! (/.acquire! //@ count_clean_up)
                                                    (enum.range n.enum 1 expected_clean_ups))
                                      _ (/.except //@ ..oops [])]
                                     (in [])))
                   actual_clean_ups (thread.read! clean_up_counter)]
                  (in (and (..throws? ..oops outcome)
                           (n.= expected_clean_ups
                                actual_clean_ups))))))
             (_.coverage [/.acquire! /.clean_up_error]
               (thread.result
                (do [! thread.monad]
                  [clean_up_counter (thread.box 0)
                   .let [//@ !
                         count_clean_up (function (_ value)
                                          (do !
                                            [_ (thread.update! ++ clean_up_counter)]
                                            (in (is (Try Any)
                                                    (exception.except ..oops [])))))]
                   outcome (/.run! !
                                   (do [! (/.monad !)]
                                     [_ (monad.each ! (/.acquire! //@ count_clean_up)
                                                    (enum.range n.enum 1 expected_clean_ups))]
                                     (in [])))
                   actual_clean_ups (thread.read! clean_up_counter)]
                  (in (and (or (n.= 0 expected_clean_ups)
                               (..throws? /.clean_up_error outcome))
                           (n.= expected_clean_ups
                                actual_clean_ups))))))
             (_.coverage [/.lifted]
               (thread.result
                (do [! thread.monad]
                  [clean_up_counter (thread.box 0)
                   .let [//@ !]
                   outcome (/.run! !
                                   (do (/.monad !)
                                     [_ (/.lifted //@ (thread.write! expected_clean_ups clean_up_counter))]
                                     (in [])))
                   actual_clean_ups (thread.read! clean_up_counter)]
                  (in (and (..success? outcome)
                           (n.= expected_clean_ups
                                actual_clean_ups))))))
             ))))
