(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]
    [\\specification
     ["$[0]" equivalence]
     ["$[0]" hash]
     ["$[0]" monoid]
     ["$[0]" functor]
     ["$[0]" apply]
     ["$[0]" monad]]]
   [control
    ["[0]" io ("[1]#[0]" monad)]
    ["[0]" pipe]]
   [data
    ["[0]" text]
    [collection
     ["[0]" list]]]
   [math
    ["[0]" random {"+" Random}]
    [number
     ["n" nat]]]]]
 [\\library
  ["[0]" / ("[1]#[0]" monoid monad)]])

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [.Maybe])
      ($_ _.and
          (_.for [/.equivalence]
                 ($equivalence.spec (/.equivalence n.equivalence) (random.maybe random.nat)))
          (_.for [/.hash]
                 (|> random.nat
                     (# random.monad each (|>> {.#Some}))
                     ($hash.spec (/.hash n.hash))))
          (_.for [/.monoid]
                 ($monoid.spec (/.equivalence n.equivalence) /.monoid (random.maybe random.nat)))
          (_.for [/.functor]
                 ($functor.spec /#in /.equivalence /.functor))
          (_.for [/.apply]
                 ($apply.spec /#in /.equivalence /.apply))
          (_.for [/.monad]
                 ($monad.spec /#in /.equivalence /.monad))
          
          (do random.monad
            [left random.nat
             right random.nat
             .let [expected (n.+ left right)]]
            (let [lifted (/.lifted io.monad)]
              (_.cover [/.with /.lifted]
                       (|> (io.run! (do (/.with io.monad)
                                      [a (lifted (io#in left))
                                       b (in right)]
                                      (in (n.+ a b))))
                           (pipe.case
                             {.#Some actual}
                             (n.= expected actual)

                             _
                             false)))))
          (do random.monad
            [default random.nat
             value random.nat]
            (_.cover [/.else]
                     (and (same? default (/.else default
                                                 (: (Maybe Nat)
                                                    {.#None})))

                          (same? value (/.else default
                                               {.#Some value})))))
          (do random.monad
            [value random.nat]
            (_.cover [/.trusted]
                     (same? value (/.trusted {.#Some value}))))
          (do random.monad
            [value random.nat]
            (_.cover [/.list]
                     (# (list.equivalence n.equivalence) =
                        (list value)
                        (/.list {.#Some value}))))
          (do random.monad
            [expected random.nat
             .let [(open "/#[0]") (/.equivalence n.equivalence)]]
            (_.cover [/.when]
                     (and (/#= {.#Some expected} (/.when true {.#Some expected}))
                          (/#= {.#None} (/.when false {.#Some expected})))))
          )))
