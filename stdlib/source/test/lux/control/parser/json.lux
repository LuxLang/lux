(.using
 [library
  [lux "*"
   ["_" test (.only Test)]
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" pipe]
    ["[0]" maybe]
    ["[0]" try]
    ["[0]" exception]
    ["<>" parser]]
   [data
    ["[0]" bit]
    ["[0]" text]
    [collection
     ["[0]" list ("[1]#[0]" functor)]
     ["[0]" set]
     ["[0]" dictionary]
     ["[0]" sequence (.only sequence) ("[1]#[0]" functor)]]
    [format
     ["[0]" json]]]
   [macro
    ["^" pattern]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" nat]
     ["[0]" frac]]]]]
 [\\library
  ["[0]" /]])

(template: (!expect <pattern> <value>)
  [(case <value>
     <pattern>
     true
     
     _
     false)])

(def: safe_frac
  (Random Frac)
  (random.only (|>> frac.not_a_number? not) random.frac))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Parser])
      (`` (all _.and
               (do [! random.monad]
                 [expected (# ! each (|>> {json.#String}) (random.unicode 1))]
                 (_.coverage [/.result /.any]
                   (|> (/.result /.any expected)
                       (!expect (^.multi {try.#Success actual}
                                         (# json.equivalence = expected actual))))))
               (_.coverage [/.null]
                 (|> (/.result /.null {json.#Null})
                     (!expect {try.#Success _})))
               (~~ (template [<query> <test> <check> <random> <json> <equivalence>]
                     [(do [! random.monad]
                        [expected <random>
                         dummy (|> <random> (random.only (|>> (# <equivalence> = expected) not)))]
                        (all _.and
                             (_.coverage [<query>]
                               (|> (/.result <query> {<json> expected})
                                   (!expect (^.multi {try.#Success actual}
                                                     (# <equivalence> = expected actual)))))
                             (_.coverage [<test>]
                               (and (|> (/.result (<test> expected) {<json> expected})
                                        (!expect {try.#Success #1}))
                                    (|> (/.result (<test> expected) {<json> dummy})
                                        (!expect {try.#Success #0}))))
                             (_.coverage [<check>]
                               (and (|> (/.result (<check> expected) {<json> expected})
                                        (!expect {try.#Success _}))
                                    (|> (/.result (<check> expected) {<json> dummy})
                                        (!expect {try.#Failure _}))))))]

                     [/.boolean /.boolean? /.this_boolean random.bit json.#Boolean bit.equivalence]
                     [/.number /.number? /.this_number ..safe_frac json.#Number frac.equivalence]
                     [/.string /.string? /.this_string (random.unicode 1) json.#String text.equivalence]
                     ))
               (do [! random.monad]
                 [expected (random.unicode 1)
                  dummy random.bit]
                 (_.coverage [/.unexpected_value]
                   (|> (/.result /.string {json.#Boolean dummy})
                       (!expect (^.multi {try.#Failure error}
                                         (exception.match? /.unexpected_value error))))))
               (do [! random.monad]
                 [expected (random.unicode 1)
                  dummy (|> (random.unicode 1) (random.only (|>> (# text.equivalence = expected) not)))]
                 (_.coverage [/.value_mismatch]
                   (|> (/.result (/.this_string expected) {json.#String dummy})
                       (!expect (^.multi {try.#Failure error}
                                         (exception.match? /.value_mismatch error))))))
               (do [! random.monad]
                 [expected (random.unicode 1)]
                 (_.coverage [/.nullable]
                   (and (|> (/.result (/.nullable /.string) {json.#Null})
                            (!expect (^.multi {try.#Success actual}
                                              (# (maybe.equivalence text.equivalence) = {.#None} actual))))
                        (|> (/.result (/.nullable /.string) {json.#String expected})
                            (!expect (^.multi {try.#Success actual}
                                              (# (maybe.equivalence text.equivalence) = {.#Some expected} actual)))))))
               (do [! random.monad]
                 [size (# ! each (n.% 10) random.nat)
                  expected (|> (random.unicode 1)
                               (random.list size)
                               (# ! each sequence.of_list))]
                 (_.coverage [/.array]
                   (|> (/.result (/.array (<>.some /.string))
                                 {json.#Array (sequence#each (|>> {json.#String}) expected)})
                       (!expect (^.multi {try.#Success actual}
                                         (# (sequence.equivalence text.equivalence) = expected (sequence.of_list actual)))))))
               (do [! random.monad]
                 [expected (# ! each (|>> {json.#String}) (random.unicode 1))]
                 (_.coverage [/.unconsumed_input]
                   (|> (/.result (/.array /.any) {json.#Array (sequence expected expected)})
                       (!expect (^.multi {try.#Failure error}
                                         (exception.match? /.unconsumed_input error))))))
               (_.coverage [/.empty_input]
                 (|> (/.result (/.array /.any) {json.#Array (sequence)})
                     (!expect (^.multi {try.#Failure error}
                                       (exception.match? /.empty_input error)))))
               (do [! random.monad]
                 [expected_boolean random.bit
                  expected_number ..safe_frac
                  expected_string (random.unicode 1)
                  [boolean_field number_field string_field] (|> (random.set text.hash 3 (random.unicode 3))
                                                                (# ! each (|>> set.list
                                                                               (pipe.case
                                                                                 (pattern (list boolean_field number_field string_field))
                                                                                 [boolean_field number_field string_field]

                                                                                 _
                                                                                 (undefined)))))]
                 (_.coverage [/.object /.field]
                   (|> (/.result (/.object (all <>.and
                                                (/.field boolean_field /.boolean)
                                                (/.field number_field /.number)
                                                (/.field string_field /.string)))
                                 {json.#Object
                                  (dictionary.of_list text.hash
                                                      (list [boolean_field {json.#Boolean expected_boolean}]
                                                            [number_field {json.#Number expected_number}]
                                                            [string_field {json.#String expected_string}]))})
                       (!expect (^.multi {try.#Success [actual_boolean actual_number actual_string]}
                                         (and (# bit.equivalence = expected_boolean actual_boolean)
                                              (# frac.equivalence = expected_number actual_number)
                                              (# text.equivalence = expected_string actual_string)))))))
               (do [! random.monad]
                 [size (# ! each (n.% 10) random.nat)
                  keys (random.list size (random.unicode 1))
                  values (random.list size (random.unicode 1))
                  .let [expected (dictionary.of_list text.hash (list.zipped_2 keys values))]]
                 (_.coverage [/.dictionary]
                   (|> (/.result (/.dictionary /.string)
                                 {json.#Object
                                  (|> values
                                      (list#each (|>> {json.#String}))
                                      (list.zipped_2 keys)
                                      (dictionary.of_list text.hash))})
                       (!expect (^.multi {try.#Success actual}
                                         (# (dictionary.equivalence text.equivalence) = expected actual))))))
               ))))
