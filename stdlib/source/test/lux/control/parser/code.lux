(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]]
   [control
    ["[0]" function]
    ["[0]" try]
    ["<>" parser]]
   [data
    ["[0]" bit]
    ["[0]" text]
    [collection
     ["[0]" list]]]
   [macro
    ["[0]" code]]
   [math
    ["[0]" random {"+" Random} ("[1]#[0]" functor)]
    [number
     ["[0]" nat]
     ["[0]" int]
     ["[0]" rev]
     ["[0]" frac]]]
   [meta
    ["[0]" symbol]]]]
 [\\library
  ["[0]" /]])

(template: (!expect <pattern> <value>)
  [(case <value>
     <pattern>
     true
     
     _
     false)])

(def: local_symbol
  (Random Text)
  (random.ascii/lower 1))

(def: global_symbol
  (Random Symbol)
  ($_ random.and
      (random.ascii/lower 1)
      (random.ascii/lower 1)
      ))

(def: any_symbol
  (Random Symbol)
  ($_ random.either
      (random#each (|>> [""])
                   ..local_symbol)
      ..global_symbol
      ))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Parser])
      (`` ($_ _.and
              (do [! random.monad]
                [expected (# ! each code.bit random.bit)]
                (_.cover [/.result]
                         (and (|> (/.result /.any (list expected))
                                  (!expect {try.#Success _}))
                              (|> (/.result /.any (list))
                                  (!expect {try.#Failure _})))))
              (~~ (template [<query> <check> <random> <code> <equivalence>]
                    [(do [! random.monad]
                       [expected <random>
                        dummy (|> <random> (random.only (|>> (# <equivalence> = expected) not)))]
                       ($_ _.and
                           (_.cover [<query>]
                                    (|> (/.result <query> (list (<code> expected)))
                                        (!expect (^multi {try.#Success actual}
                                                         (# <equivalence> = expected actual)))))
                           (_.cover [<check>]
                                    (and (|> (/.result (<check> expected) (list (<code> expected)))
                                             (!expect {try.#Success []}))
                                         (|> (/.result (<check> expected) (list (<code> dummy)))
                                             (!expect {try.#Failure _}))))
                           ))]

                    [/.any /.this! (# ! each code.bit random.bit) function.identity code.equivalence]
                    [/.bit /.bit! random.bit code.bit bit.equivalence]
                    [/.nat /.nat! random.nat code.nat nat.equivalence]
                    [/.int /.int! random.int code.int int.equivalence]
                    [/.rev /.rev! random.rev code.rev rev.equivalence]
                    [/.frac /.frac! random.safe_frac code.frac frac.equivalence]
                    [/.text /.text! (random.unicode 1) code.text text.equivalence]
                    [/.local_symbol /.local_symbol! ..local_symbol code.local_symbol text.equivalence]
                    [/.global_symbol /.global_symbol! ..global_symbol code.symbol symbol.equivalence]
                    [/.symbol /.symbol! ..any_symbol code.symbol symbol.equivalence]
                    ))
              (~~ (template [<query> <code>]
                    [(do [! random.monad]
                       [expected_left random.nat
                        expected_right random.int]
                       (_.cover [<query>]
                                (|> (/.result (<query> (<>.and /.nat /.int))
                                              (list (<code> (list (code.nat expected_left)
                                                                  (code.int expected_right)))))
                                    (!expect (^multi {try.#Success [actual_left actual_right]}
                                                     (and (# nat.equivalence = expected_left actual_left)
                                                          (# int.equivalence = expected_right actual_right)))))))]

                    [/.form code.form]
                    [/.variant code.variant]
                    [/.tuple code.tuple]
                    ))
              (do [! random.monad]
                [expected_local random.nat
                 expected_global random.int]
                (_.cover [/.local]
                         (|> (/.result (<>.and (/.local (list (code.nat expected_local)) /.nat)
                                               /.int)
                                       (list (code.int expected_global)))
                             (!expect (^multi {try.#Success [actual_local actual_global]}
                                              (and (# nat.equivalence = expected_local actual_local)
                                                   (# int.equivalence = expected_global actual_global)))))))
              (do [! random.monad]
                [dummy (# ! each code.bit random.bit)]
                (_.cover [/.end?]
                         (|> (/.result (do <>.monad
                                         [pre /.end?
                                          _ /.any
                                          post /.end?]
                                         (in (and (not pre)
                                                  post)))
                                       (list dummy))
                             (!expect (^multi {try.#Success verdict}
                                              verdict)))))
              (do [! random.monad]
                [dummy (# ! each code.bit random.bit)]
                (_.cover [/.end!]
                         (and (|> (/.result /.end! (list))
                                  (!expect {try.#Success []}))
                              (|> (/.result /.end! (list dummy))
                                  (!expect {try.#Failure _})))))
              (do [! random.monad]
                [expected (# ! each code.bit random.bit)]
                (_.cover [/.next]
                         (|> (/.result (do <>.monad
                                         [pre /.next
                                          post /.any]
                                         (in (and (same? expected pre)
                                                  (same? pre post))))
                                       (list expected))
                             (!expect {try.#Success _}))))
              (do [! random.monad]
                [expected (# ! each code.bit random.bit)]
                (_.cover [/.not]
                         (and (|> (/.result (/.not /.nat) (list expected))
                                  (!expect (^multi {try.#Success actual}
                                                   (same? expected actual))))
                              (|> (/.result (/.not /.bit) (list expected))
                                  (!expect {try.#Failure _})))))
              ))))
