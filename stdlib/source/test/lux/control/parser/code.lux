(.using
 [library
  [lux {"-" local global}
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]]
   [control
    ["[0]" function]
    ["[0]" try]
    ["<>" parser]]
   [data
    ["[0]" bit]
    ["[0]" text]
    [collection
     ["[0]" list]]]
   [macro
    ["^" pattern]
    ["[0]" code]]
   [math
    ["[0]" random {"+" Random} ("[1]#[0]" functor)]
    [number
     ["[0]" nat]
     ["[0]" int]
     ["[0]" rev]
     ["[0]" frac]]]
   [meta
    ["[0]" symbol]]]]
 [\\library
  ["[0]" /]])

(template: (!expect <pattern> <value>)
  [(case <value>
     <pattern>
     true
     
     _
     false)])

(def: local
  (Random Text)
  (random.lower_case 1))

(def: global
  (Random Symbol)
  (all random.and
       (random.lower_case 1)
       (random.lower_case 1)
       ))

(def: any_symbol
  (Random Symbol)
  (all random.either
       (random#each (|>> [""])
                    ..local)
       ..global
       ))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Parser])
      (`` (all _.and
               (do [! random.monad]
                 [expected (# ! each code.bit random.bit)]
                 (_.cover [/.result]
                          (and (|> (/.result /.any (list expected))
                                   (!expect {try.#Success _}))
                               (|> (/.result /.any (list))
                                   (!expect {try.#Failure _})))))
               (~~ (template [<query> <check> <random> <code> <equivalence>]
                     [(do [! random.monad]
                        [expected <random>
                         dummy (|> <random> (random.only (|>> (# <equivalence> = expected) not)))]
                        (all _.and
                             (_.cover [<query>]
                                      (|> (/.result <query> (list (<code> expected)))
                                          (!expect (^.multi {try.#Success actual}
                                                            (# <equivalence> = expected actual)))))
                             (_.cover [<check>]
                                      (and (|> (/.result (<check> expected) (list (<code> expected)))
                                               (!expect {try.#Success []}))
                                           (|> (/.result (<check> expected) (list (<code> dummy)))
                                               (!expect {try.#Failure _}))))
                             ))]

                     [/.any /.this (# ! each code.bit random.bit) function.identity code.equivalence]
                     [/.bit /.this_bit random.bit code.bit bit.equivalence]
                     [/.nat /.this_nat random.nat code.nat nat.equivalence]
                     [/.int /.this_int random.int code.int int.equivalence]
                     [/.rev /.this_rev random.rev code.rev rev.equivalence]
                     [/.frac /.this_frac random.safe_frac code.frac frac.equivalence]
                     [/.text /.this_text (random.unicode 1) code.text text.equivalence]
                     [/.local /.this_local ..local code.local text.equivalence]
                     [/.global /.this_global ..global code.symbol symbol.equivalence]
                     [/.symbol /.this_symbol ..any_symbol code.symbol symbol.equivalence]
                     ))
               (~~ (template [<query> <code>]
                     [(do [! random.monad]
                        [expected_left random.nat
                         expected_right random.int]
                        (_.cover [<query>]
                                 (|> (/.result (<query> (<>.and /.nat /.int))
                                               (list (<code> (list (code.nat expected_left)
                                                                   (code.int expected_right)))))
                                     (!expect (^.multi {try.#Success [actual_left actual_right]}
                                                       (and (# nat.equivalence = expected_left actual_left)
                                                            (# int.equivalence = expected_right actual_right)))))))]

                     [/.form code.form]
                     [/.variant code.variant]
                     [/.tuple code.tuple]
                     ))
               (do [! random.monad]
                 [expected_local random.nat
                  expected_global random.int]
                 (_.cover [/.locally]
                          (|> (/.result (<>.and (/.locally (list (code.nat expected_local)) /.nat)
                                                /.int)
                                        (list (code.int expected_global)))
                              (!expect (^.multi {try.#Success [actual_local actual_global]}
                                                (and (# nat.equivalence = expected_local actual_local)
                                                     (# int.equivalence = expected_global actual_global)))))))
               (do [! random.monad]
                 [dummy (# ! each code.bit random.bit)]
                 (_.cover [/.end?]
                          (|> (/.result (do <>.monad
                                          [pre /.end?
                                           _ /.any
                                           post /.end?]
                                          (in (and (not pre)
                                                   post)))
                                        (list dummy))
                              (!expect (^.multi {try.#Success verdict}
                                                verdict)))))
               (do [! random.monad]
                 [dummy (# ! each code.bit random.bit)]
                 (_.cover [/.end]
                          (and (|> (/.result /.end (list))
                                   (!expect {try.#Success []}))
                               (|> (/.result /.end (list dummy))
                                   (!expect {try.#Failure _})))))
               (do [! random.monad]
                 [expected (# ! each code.bit random.bit)]
                 (_.cover [/.next]
                          (|> (/.result (do <>.monad
                                          [pre /.next
                                           post /.any]
                                          (in (and (same? expected pre)
                                                   (same? pre post))))
                                        (list expected))
                              (!expect {try.#Success _}))))
               (do [! random.monad]
                 [expected (# ! each code.bit random.bit)]
                 (_.cover [/.not]
                          (and (|> (/.result (/.not /.nat) (list expected))
                                   (!expect (^.multi {try.#Success actual}
                                                     (same? expected actual))))
                               (|> (/.result (/.not /.bit) (list expected))
                                   (!expect {try.#Failure _})))))
               ))))
