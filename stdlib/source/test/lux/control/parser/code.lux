(.using
 [library
  [lux (.except local global)
   ["_" test (.only Test)]
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" function]
    ["[0]" try]
    ["<>" parser]]
   [data
    ["[0]" bit]
    ["[0]" text]
    [collection
     ["[0]" list]]]
   [macro
    ["^" pattern]
    ["[0]" code]]
   [math
    ["[0]" random (.only Random) (.open: "[1]#[0]" functor)]
    [number
     ["[0]" nat]
     ["[0]" int]
     ["[0]" rev]
     ["[0]" frac]]]
   [meta
    ["[0]" symbol]]]]
 [\\library
  ["[0]" /]])

(def !expect
  (template (_ <pattern> <value>)
    [(case <value>
       <pattern>
       true
       
       _
       false)]))

(def local
  (Random Text)
  (random.lower_case 1))

(def global
  (Random Symbol)
  (all random.and
       (random.lower_case 1)
       (random.lower_case 1)
       ))

(def any_symbol
  (Random Symbol)
  (all random.either
       (random#each (|>> [""])
                    ..local)
       ..global
       ))

(def .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Parser])
      (`` (all _.and
               (do [! random.monad]
                 [expected (at ! each code.bit random.bit)]
                 (_.coverage [/.result]
                   (and (|> (/.result /.any (list expected))
                            (!expect {try.#Success _}))
                        (|> (/.result /.any (list))
                            (!expect {try.#Failure _})))))
               (~~ (with_template [<query> <check> <random> <code> <equivalence>]
                     [(do [! random.monad]
                        [expected <random>
                         dummy (|> <random> (random.only (|>> (at <equivalence> = expected) not)))]
                        (all _.and
                             (_.coverage [<query>]
                               (|> (/.result <query> (list (<code> expected)))
                                   (!expect (^.multi {try.#Success actual}
                                                     (at <equivalence> = expected actual)))))
                             (_.coverage [<check>]
                               (and (|> (/.result (<check> expected) (list (<code> expected)))
                                        (!expect {try.#Success []}))
                                    (|> (/.result (<check> expected) (list (<code> dummy)))
                                        (!expect {try.#Failure _}))))
                             ))]

                     [/.any /.this (at ! each code.bit random.bit) function.identity code.equivalence]
                     [/.bit /.this_bit random.bit code.bit bit.equivalence]
                     [/.nat /.this_nat random.nat code.nat nat.equivalence]
                     [/.int /.this_int random.int code.int int.equivalence]
                     [/.rev /.this_rev random.rev code.rev rev.equivalence]
                     [/.frac /.this_frac random.safe_frac code.frac frac.equivalence]
                     [/.text /.this_text (random.unicode 1) code.text text.equivalence]
                     [/.local /.this_local ..local code.local text.equivalence]
                     [/.global /.this_global ..global code.symbol symbol.equivalence]
                     [/.symbol /.this_symbol ..any_symbol code.symbol symbol.equivalence]
                     ))
               (~~ (with_template [<query> <code>]
                     [(do [! random.monad]
                        [expected_left random.nat
                         expected_right random.int]
                        (_.coverage [<query>]
                          (|> (/.result (<query> (<>.and /.nat /.int))
                                        (list (<code> (list (code.nat expected_left)
                                                            (code.int expected_right)))))
                              (!expect (^.multi {try.#Success [actual_left actual_right]}
                                                (and (at nat.equivalence = expected_left actual_left)
                                                     (at int.equivalence = expected_right actual_right)))))))]

                     [/.form code.form]
                     [/.variant code.variant]
                     [/.tuple code.tuple]
                     ))
               (do [! random.monad]
                 [expected_local random.nat
                  expected_global random.int]
                 (_.coverage [/.locally]
                   (|> (/.result (<>.and (/.locally (list (code.nat expected_local)) /.nat)
                                         /.int)
                                 (list (code.int expected_global)))
                       (!expect (^.multi {try.#Success [actual_local actual_global]}
                                         (and (at nat.equivalence = expected_local actual_local)
                                              (at int.equivalence = expected_global actual_global)))))))
               (do [! random.monad]
                 [dummy (at ! each code.bit random.bit)]
                 (_.coverage [/.end?]
                   (|> (/.result (do <>.monad
                                   [pre /.end?
                                    _ /.any
                                    post /.end?]
                                   (in (and (not pre)
                                            post)))
                                 (list dummy))
                       (!expect (^.multi {try.#Success verdict}
                                         verdict)))))
               (do [! random.monad]
                 [dummy (at ! each code.bit random.bit)]
                 (_.coverage [/.end]
                   (and (|> (/.result /.end (list))
                            (!expect {try.#Success []}))
                        (|> (/.result /.end (list dummy))
                            (!expect {try.#Failure _})))))
               (do [! random.monad]
                 [expected (at ! each code.bit random.bit)]
                 (_.coverage [/.next]
                   (|> (/.result (do <>.monad
                                   [pre /.next
                                    post /.any]
                                   (in (and (same? expected pre)
                                            (same? pre post))))
                                 (list expected))
                       (!expect {try.#Success _}))))
               (do [! random.monad]
                 [expected (at ! each code.bit random.bit)]
                 (_.coverage [/.not]
                   (and (|> (/.result (/.not /.nat) (list expected))
                            (!expect (^.multi {try.#Success actual}
                                              (same? expected actual))))
                        (|> (/.result (/.not /.bit) (list expected))
                            (!expect {try.#Failure _})))))
               ))))
