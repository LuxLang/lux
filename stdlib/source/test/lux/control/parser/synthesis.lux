(.using
 [library
  [lux (.except)
   ["_" test (.only Test)]
   [abstract
    ["[0]" monad (.only do)]]
   [control
    ["<>" parser]
    ["[0]" try]
    ["[0]" exception]]
   [data
    ["[0]" bit]
    ["[0]" text]
    [collection
     ["[0]" list (.open: "[1]#[0]" functor)]]]
   [macro
    ["^" pattern]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" nat]
     ["[0]" i64]
     ["[0]" frac]]]
   [meta
    ["[0]" symbol]]
   [tool
    [compiler
     [reference (.only)
      ["[0]" variable (.only Variable)]]
     [language
      [lux
       [analysis (.only Environment)]
       ["[0]" synthesis (.only Synthesis)]]]]]]]
 [\\library
  ["[0]" /]])

(template: (!expect <pattern> <value>)
  [(case <value>
     <pattern>
     true
     
     _
     false)])

(def: random_constant
  (Random Symbol)
  (random.and (random.unicode 1)
              (random.unicode 1)))

(def: random_variable
  (Random Variable)
  (random.or random.nat
             random.nat))

(def: random_environment
  (Random (Environment Synthesis))
  (do [! random.monad]
    [size (# ! each (n.% 5) random.nat)]
    (|> ..random_variable
        (# ! each (|>> synthesis.variable))
        (random.list size))))

(def: simple
  Test
  (`` (all _.and
           (~~ (template [<query> <check> <random> <synthesis> <equivalence>]
                 [(do [! random.monad]
                    [expected <random>
                     dummy (|> <random> (random.only (|>> (# <equivalence> = expected) not)))]
                    (all _.and
                         (_.coverage [<query>]
                           (|> (/.result <query> (list (<synthesis> expected)))
                               (!expect (^.multi {try.#Success actual}
                                                 (# <equivalence> = expected actual)))))
                         (_.coverage [<check>]
                           (and (|> (/.result (<check> expected) (list (<synthesis> expected)))
                                    (!expect {try.#Success _}))
                                (|> (/.result (<check> expected) (list (<synthesis> dummy)))
                                    (!expect (^.multi {try.#Failure error}
                                                      (exception.match? /.cannot_parse error))))))
                         ))]

                 [/.bit /.this_bit random.bit synthesis.bit bit.equivalence]
                 [/.i64 /.this_i64 random.i64 synthesis.i64 i64.equivalence]
                 [/.f64 /.this_f64 random.safe_frac synthesis.f64 frac.equivalence]
                 [/.text /.this_text (random.unicode 1) synthesis.text text.equivalence]
                 [/.local /.this_local random.nat synthesis.variable/local n.equivalence]
                 [/.foreign /.this_foreign random.nat synthesis.variable/foreign n.equivalence]
                 [/.constant /.this_constant ..random_constant synthesis.constant symbol.equivalence]
                 ))
           )))

(def: complex
  Test
  (all _.and
       (do [! random.monad]
         [expected_bit random.bit
          expected_i64 random.i64
          expected_f64 random.safe_frac
          expected_text (random.unicode 1)]
         (_.coverage [/.tuple]
           (and (|> (/.result (/.tuple (all <>.and /.bit /.i64 /.f64 /.text))
                              (list (synthesis.tuple (list (synthesis.bit expected_bit)
                                                           (synthesis.i64 expected_i64)
                                                           (synthesis.f64 expected_f64)
                                                           (synthesis.text expected_text)))))
                    (!expect (^.multi {try.#Success [actual_bit actual_i64 actual_f64 actual_text]}
                                      (and (# bit.equivalence = expected_bit actual_bit)
                                           (# i64.equivalence = expected_i64 actual_i64)
                                           (# frac.equivalence = expected_f64 actual_f64)
                                           (# text.equivalence = expected_text actual_text)))))
                (|> (/.result (/.tuple (all <>.and /.bit /.i64 /.f64 /.text))
                              (list (synthesis.text expected_text)))
                    (!expect (^.multi {try.#Failure error}
                                      (exception.match? /.cannot_parse error)))))))
       (do [! random.monad]
         [arity random.nat
          expected_environment ..random_environment
          expected_body (random.unicode 1)]
         (_.coverage [/.function]
           (and (|> (/.result (/.function arity /.text)
                              (list (synthesis.function/abstraction [expected_environment arity (synthesis.text expected_body)])))
                    (!expect (^.multi {try.#Success [actual_environment actual_body]}
                                      (and (# (list.equivalence synthesis.equivalence) =
                                              expected_environment
                                              actual_environment)
                                           (# text.equivalence = expected_body actual_body)))))
                (|> (/.result (/.function arity /.text)
                              (list (synthesis.text expected_body)))
                    (!expect (^.multi {try.#Failure error}
                                      (exception.match? /.cannot_parse error)))))))
       (do [! random.monad]
         [arity random.nat
          expected_environment ..random_environment
          expected_body (random.unicode 1)]
         (_.coverage [/.wrong_arity]
           (|> (/.result (/.function (++ arity) /.text)
                         (list (synthesis.function/abstraction [expected_environment arity (synthesis.text expected_body)])))
               (!expect (^.multi {try.#Failure error}
                                 (exception.match? /.wrong_arity error))))))
       (do [! random.monad]
         [arity (# ! each (|>> (n.% 10) ++) random.nat)
          expected_offset random.nat
          expected_inits (random.list arity random.bit)
          expected_body (random.unicode 1)]
         (_.coverage [/.loop]
           (and (|> (/.result (/.loop (<>.many /.bit) /.text)
                              (list (synthesis.loop/scope [expected_offset
                                                           (list#each (|>> synthesis.bit) expected_inits)
                                                           (synthesis.text expected_body)])))
                    (!expect (^.multi {try.#Success [actual_offset actual_inits actual_body]}
                                      (and (# n.equivalence = expected_offset actual_offset)
                                           (# (list.equivalence bit.equivalence) =
                                              expected_inits
                                              actual_inits)
                                           (# text.equivalence = expected_body actual_body)))))
                (|> (/.result (/.loop (<>.many /.bit) /.text)
                              (list (synthesis.text expected_body)))
                    (!expect (^.multi {try.#Failure error}
                                      (exception.match? /.cannot_parse error)))))))
       ))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Parser])
      (all _.and
           (do [! random.monad]
             [expected (# ! each (|>> synthesis.i64) random.i64)]
             (_.coverage [/.result /.any]
               (|> (/.result /.any (list expected))
                   (!expect (^.multi {try.#Success actual}
                                     (# synthesis.equivalence = expected actual))))))
           (_.coverage [/.empty_input]
             (|> (/.result /.any (list))
                 (!expect (^.multi {try.#Failure error}
                                   (exception.match? /.empty_input error)))))
           (do [! random.monad]
             [expected (# ! each (|>> synthesis.i64) random.i64)]
             (_.coverage [/.unconsumed_input]
               (|> (/.result /.any (list expected expected))
                   (!expect (^.multi {try.#Failure error}
                                     (exception.match? /.unconsumed_input error))))))
           (do [! random.monad]
             [dummy (# ! each (|>> synthesis.i64) random.i64)]
             (_.coverage [/.end /.expected_empty_input]
               (and (|> (/.result /.end (list))
                        (!expect {try.#Success _}))
                    (|> (/.result /.end (list dummy))
                        (!expect (^.multi {try.#Failure error}
                                          (exception.match? /.expected_empty_input error)))))))
           (do [! random.monad]
             [dummy (# ! each (|>> synthesis.i64) random.i64)]
             (_.coverage [/.end?]
               (and (|> (/.result /.end? (list))
                        (!expect {try.#Success #1}))
                    (|> (/.result (<>.before /.any /.end?) (list dummy))
                        (!expect {try.#Success #0})))))
           (_.for [/.cannot_parse]
                  (all _.and
                       ..simple
                       ..complex
                       ))
           )))
