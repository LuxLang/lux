(.module:
  [library
   [lux #*
    ["_" test (#+ Test)]
    [abstract
     [monad (#+ do)]]
    [control
     ["." maybe]
     ["." try (#+ Try)]
     ["." exception (#+ Exception)]
     ["." function]]
    [data
     ["." text ("#\." equivalence)
      ["%" format (#+ format)]
      ["." unicode #_
       ["#" set]
       ["#/." block]]]
     [collection
      ["." set]
      ["." list ("#\." functor)]
      [tree
       ["." finger]]]]
    [math
     ["." random]
     [number (#+ hex)
      ["n" nat]]]
    [macro
     ["." code]]]]
  [\\library
   ["." /
    ["<>" //
     ["<c>" code]]]])

(template: (!expect <pattern> <value>)
  [(case <value>
     <pattern>
     true
     
     _
     false)])

(def: (should_fail' sample parser exception)
  (All [a e] (-> Text (/.Parser a) (Exception e) Bit))
  (case (/.result parser sample)
    (#try.Failure error)
    (exception.match? exception error)
    
    _
    false))

(def: (should_fail sample parser)
  (All [a] (-> Text (/.Parser a) Bit))
  (case (/.result parser sample)
    (#try.Failure _)
    true
    
    _
    false))

(def: (should_pass expected parser)
  (-> Text (/.Parser Text) Bit)
  (|> expected
      (/.result parser)
      (\ try.functor map (text\= expected))
      (try.else false)))

(def: (should_pass! expected parser)
  (-> Text (/.Parser /.Slice) Bit)
  (..should_pass expected (/.slice parser)))

(def: character_classes
  Test
  ($_ _.and
      (do {! random.monad}
        [offset (\ ! map (n.% 50) random.nat)
         range (\ ! map (|>> (n.% 50) (n.+ 10)) random.nat)
         .let [limit (n.+ offset range)]
         expected (\ ! map (|>> (n.% range) (n.+ offset) text.of_char) random.nat)
         out_of_range (case offset
                        0 (\ ! map (|>> (n.% 10) ++ (n.+ limit) text.of_char) random.nat)
                        _ (\ ! map (|>> (n.% offset) text.of_char) random.nat))]
        (_.cover [/.range]
                 (and (..should_pass expected (/.range offset limit))
                      (..should_fail out_of_range (/.range offset limit)))))
      (do {! random.monad}
        [expected (random.char unicode.ascii/upper)
         invalid (random.only (|>> (unicode/block.within? unicode/block.basic_latin/upper) not)
                              (random.char unicode.character))]
        (_.cover [/.upper]
                 (and (..should_pass (text.of_char expected) /.upper)
                      (..should_fail (text.of_char invalid) /.upper))))
      (do {! random.monad}
        [expected (random.char unicode.ascii/lower)
         invalid (random.only (|>> (unicode/block.within? unicode/block.basic_latin/lower) not)
                              (random.char unicode.character))]
        (_.cover [/.lower]
                 (and (..should_pass (text.of_char expected) /.lower)
                      (..should_fail (text.of_char invalid) /.lower))))
      (do {! random.monad}
        [expected (\ ! map (n.% 10) random.nat)
         invalid (random.char (unicode.set [unicode/block.number_forms (list)]))]
        (_.cover [/.decimal]
                 (and (..should_pass (\ n.decimal encoded expected) /.decimal)
                      (..should_fail (text.of_char invalid) /.decimal))))
      (do {! random.monad}
        [expected (\ ! map (n.% 8) random.nat)
         invalid (random.char (unicode.set [unicode/block.number_forms (list)]))]
        (_.cover [/.octal]
                 (and (..should_pass (\ n.octal encoded expected) /.octal)
                      (..should_fail (text.of_char invalid) /.octal))))
      (do {! random.monad}
        [expected (\ ! map (n.% 16) random.nat)
         invalid (random.char (unicode.set [unicode/block.number_forms (list)]))]
        (_.cover [/.hexadecimal]
                 (and (..should_pass (\ n.hex encoded expected) /.hexadecimal)
                      (..should_fail (text.of_char invalid) /.hexadecimal))))
      (do {! random.monad}
        [expected (random.char unicode.ascii/alpha)
         invalid (random.only (function (_ char)
                                (not (or (unicode/block.within? unicode/block.basic_latin/upper char)
                                         (unicode/block.within? unicode/block.basic_latin/lower char))))
                              (random.char unicode.character))]
        (_.cover [/.alpha]
                 (and (..should_pass (text.of_char expected) /.alpha)
                      (..should_fail (text.of_char invalid) /.alpha))))
      (do {! random.monad}
        [expected (random.char unicode.ascii/alpha_num)
         invalid (random.only (function (_ char)
                                (not (or (unicode/block.within? unicode/block.basic_latin/upper char)
                                         (unicode/block.within? unicode/block.basic_latin/lower char)
                                         (unicode/block.within? unicode/block.basic_latin/decimal char))))
                              (random.char unicode.character))]
        (_.cover [/.alpha_num]
                 (and (..should_pass (text.of_char expected) /.alpha_num)
                      (..should_fail (text.of_char invalid) /.alpha_num))))
      (do {! random.monad}
        [expected ($_ random.either
                      (in text.tab)
                      (in text.vertical_tab)
                      (in text.space)
                      (in text.new_line)
                      (in text.carriage_return)
                      (in text.form_feed))
         invalid (|> (random.unicode 1) (random.only (function (_ char)
                                                       (not (or (text\= text.tab char)
                                                                (text\= text.vertical_tab char)
                                                                (text\= text.space char)
                                                                (text\= text.new_line char)
                                                                (text\= text.carriage_return char)
                                                                (text\= text.form_feed char))))))]
        (_.cover [/.space]
                 (and (..should_pass expected /.space)
                      (..should_fail invalid /.space))))
      (do {! random.monad}
        [.let [num_options 3]
         options (|> (random.char unicode.character)
                     (random.set n.hash num_options)
                     (\ ! map (|>> set.list
                                   (list\map text.of_char)
                                   text.together)))
         expected (\ ! map (function (_ value)
                             (|> options
                                 (text.char (n.% num_options value))
                                 maybe.trusted))
                     random.nat)
         invalid (random.only (function (_ char)
                                (not (text.contains? (text.of_char char) options)))
                              (random.char unicode.character))]
        (_.cover [/.one_of /.one_of! /.character_should_be]
                 (and (..should_pass (text.of_char expected) (/.one_of options))
                      (..should_fail (text.of_char invalid) (/.one_of options))
                      (..should_fail' (text.of_char invalid) (/.one_of options)
                                      /.character_should_be)

                      (..should_pass! (text.of_char expected) (/.one_of! options))
                      (..should_fail (text.of_char invalid) (/.one_of! options))
                      (..should_fail' (text.of_char invalid) (/.one_of! options)
                                      /.character_should_be)
                      )))
      (do {! random.monad}
        [.let [num_options 3]
         options (|> (random.char unicode.character)
                     (random.set n.hash num_options)
                     (\ ! map (|>> set.list
                                   (list\map text.of_char)
                                   text.together)))
         invalid (\ ! map (function (_ value)
                            (|> options
                                (text.char (n.% num_options value))
                                maybe.trusted))
                    random.nat)
         expected (random.only (function (_ char)
                                 (not (text.contains? (text.of_char char) options)))
                               (random.char unicode.character))]
        (_.cover [/.none_of /.none_of! /.character_should_not_be]
                 (and (..should_pass (text.of_char expected) (/.none_of options))
                      (..should_fail (text.of_char invalid) (/.none_of options))
                      (..should_fail' (text.of_char invalid) (/.none_of options)
                                      /.character_should_not_be)

                      (..should_pass! (text.of_char expected) (/.none_of! options))
                      (..should_fail (text.of_char invalid) (/.none_of! options))
                      (..should_fail' (text.of_char invalid) (/.none_of! options)
                                      /.character_should_not_be)
                      )))
      ))

(def: runs
  Test
  (let [octal! (/.one_of! "01234567")]
    ($_ _.and
        (do {! random.monad}
          [left (\ ! map (|>> (n.% 8) (\ n.octal encoded)) random.nat)
           right (\ ! map (|>> (n.% 8) (\ n.octal encoded)) random.nat)
           .let [expected (format left right)]
           invalid (|> random.nat
                       (\ ! map (n.% 16))
                       (random.only (n.>= 8))
                       (\ ! map (\ n.hex encoded)))]
          (_.cover [/.many /.many!]
                   (and (..should_pass expected (/.many /.octal))
                        (..should_fail invalid (/.many /.octal))

                        (..should_pass! expected (/.many! octal!)))))
        (do {! random.monad}
          [left (\ ! map (|>> (n.% 8) (\ n.octal encoded)) random.nat)
           right (\ ! map (|>> (n.% 8) (\ n.octal encoded)) random.nat)
           .let [expected (format left right)]
           invalid (|> random.nat
                       (\ ! map (n.% 16))
                       (random.only (n.>= 8))
                       (\ ! map (\ n.hex encoded)))]
          (_.cover [/.some /.some!]
                   (and (..should_pass expected (/.some /.octal))
                        (..should_pass "" (/.some /.octal))
                        (..should_fail invalid (/.some /.octal))

                        (..should_pass! expected (/.some! octal!))
                        (..should_pass! "" (/.some! octal!)))))
        (do {! random.monad}
          [.let [octal (\ ! map (|>> (n.% 8) (\ n.octal encoded)) random.nat)]
           first octal
           second octal
           third octal]
          (_.cover [/.exactly /.exactly!]
                   (and (..should_pass (format first second) (/.exactly 2 /.octal))
                        (..should_fail (format first second third) (/.exactly 2 /.octal))
                        (..should_fail (format first) (/.exactly 2 /.octal))

                        (..should_pass! (format first second) (/.exactly! 2 octal!))
                        (..should_fail (format first second third) (/.exactly! 2 octal!))
                        (..should_fail (format first) (/.exactly! 2 octal!)))))
        (do {! random.monad}
          [.let [octal (\ ! map (|>> (n.% 8) (\ n.octal encoded)) random.nat)]
           first octal
           second octal
           third octal]
          (_.cover [/.at_most /.at_most!]
                   (and (..should_pass (format first second) (/.at_most 2 /.octal))
                        (..should_pass (format first) (/.at_most 2 /.octal))
                        (..should_fail (format first second third) (/.at_most 2 /.octal))

                        (..should_pass! (format first second) (/.at_most! 2 octal!))
                        (..should_pass! (format first) (/.at_most! 2 octal!))
                        (..should_fail (format first second third) (/.at_most! 2 octal!)))))
        (do {! random.monad}
          [.let [octal (\ ! map (|>> (n.% 8) (\ n.octal encoded)) random.nat)]
           first octal
           second octal
           third octal]
          (_.cover [/.at_least /.at_least!]
                   (and (..should_pass (format first second) (/.at_least 2 /.octal))
                        (..should_pass (format first second third) (/.at_least 2 /.octal))
                        (..should_fail (format first) (/.at_least 2 /.octal))

                        (..should_pass! (format first second) (/.at_least! 2 octal!))
                        (..should_pass! (format first second third) (/.at_least! 2 octal!))
                        (..should_fail (format first) (/.at_least! 2 octal!)))))
        (do {! random.monad}
          [.let [octal (\ ! map (|>> (n.% 8) (\ n.octal encoded)) random.nat)]
           first octal
           second octal
           third octal]
          (_.cover [/.between /.between!]
                   (and (..should_pass (format first second) (/.between 2 1 /.octal))
                        (..should_pass (format first second third) (/.between 2 1 /.octal))
                        (..should_fail (format first) (/.between 2 1 /.octal))

                        (..should_pass! (format first second) (/.between! 2 1 octal!))
                        (..should_pass! (format first second third) (/.between! 2 1 octal!))
                        (..should_fail (format first) (/.between! 2 1 octal!)))))
        )))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Parser])
      ($_ _.and
          (do {! random.monad}
            [sample (random.unicode 1)]
            (_.cover [/.result /.end!]
                     (and (|> (/.result /.end!
                                        "")
                              (!expect (#try.Success _)))
                          (|> (/.result /.end!
                                        sample)
                              (!expect (#try.Failure _))))))
          (do {! random.monad}
            [.let [size 10]
             expected (random.unicode size)
             dummy (|> (random.unicode size)
                       (random.only (|>> (text\= expected) not)))]
            (_.cover [/.this /.cannot_match]
                     (and (|> (/.result (/.this expected)
                                        expected)
                              (!expect (#try.Success [])))
                          (|> (/.result (/.this expected)
                                        dummy)
                              (!expect (^multi (#try.Failure error)
                                               (exception.match? /.cannot_match error)))))))
          (_.cover [/.Slice /.slice /.cannot_slice]
                   (|> ""
                       (/.result (/.slice /.any!))
                       (!expect (^multi (#try.Failure error)
                                        (exception.match? /.cannot_slice error)))))
          (do {! random.monad}
            [expected (random.unicode 1)]
            (_.cover [/.any /.any!]
                     (and (..should_pass expected /.any)
                          (..should_fail "" /.any)

                          (..should_pass! expected /.any!)
                          (..should_fail "" /.any!))))
          (do {! random.monad}
            [expected (random.unicode 1)]
            (_.cover [/.next /.cannot_parse]
                     (and (..should_pass expected (<>.before /.any /.next))
                          (|> ""
                              (/.result (<>.before /.any /.next))
                              (!expect (^multi (#try.Failure error)
                                               (exception.match? /.cannot_parse error)))))))
          (do {! random.monad}
            [dummy (random.unicode 1)]
            (_.cover [/.unconsumed_input]
                     (|> (format dummy dummy)
                         (/.result /.any)
                         (!expect (^multi (#try.Failure error)
                                          (exception.match? /.unconsumed_input error))))))
          (do {! random.monad}
            [sample (random.unicode 1)]
            (_.cover [/.Offset /.offset]
                     (|> sample
                         (/.result (do <>.monad
                                     [pre /.offset
                                      _ /.any
                                      post /.offset]
                                     (in [pre post])))
                         (!expect (#try.Success [0 1])))))
          (do {! random.monad}
            [left (random.unicode 1)
             right (random.unicode 1)
             .let [input (format left right)]]
            (_.cover [/.remaining]
                     (|> input
                         (/.result (do <>.monad
                                     [pre /.remaining
                                      _ /.any
                                      post /.remaining
                                      _ /.any]
                                     (in (and (text\= input pre)
                                              (text\= right post)))))
                         (!expect (#try.Success #1)))))
          (do {! random.monad}
            [left (random.unicode 1)
             right (random.unicode 1)
             expected (random.only (|>> (text\= right) not)
                                   (random.unicode 1))]
            (_.cover [/.enclosed]
                     (|> (format left expected right)
                         (/.result (/.enclosed [left right] (/.this expected)))
                         (!expect (#try.Success _)))))
          (do {! random.monad}
            [input (random.unicode 1)
             output (random.unicode 1)]
            (_.cover [/.local]
                     (|> output
                         (/.result (do <>.monad
                                     [_ (/.local input (/.this input))]
                                     (/.this output)))
                         (!expect (#try.Success _)))))
          (do {! random.monad}
            [expected (\ ! map (|>> (n.% 8) (\ n.octal encoded)) random.nat)]
            (_.cover [/.then]
                     (|> (list (code.text expected))
                         (<c>.result (/.then /.octal <c>.text))
                         (!expect (^multi (#try.Success actual)
                                          (text\= expected actual))))))
          (do {! random.monad}
            [invalid (random.ascii/upper 1)
             expected (random.only (|>> (unicode/block.within? unicode/block.basic_latin/upper)
                                        not)
                                   (random.char unicode.character))
             .let [upper! (/.one_of! "ABCDEFGHIJKLMNOPQRSTUVWXYZ")]]
            (_.cover [/.not /.not! /.expected_to_fail]
                     (and (..should_pass (text.of_char expected) (/.not /.upper))
                          (|> invalid
                              (/.result (/.not /.upper))
                              (!expect (^multi (#try.Failure error)
                                               (exception.match? /.expected_to_fail error))))

                          (..should_pass! (text.of_char expected) (/.not! upper!))
                          (|> invalid
                              (/.result (/.not! upper!))
                              (!expect (^multi (#try.Failure error)
                                               (exception.match? /.expected_to_fail error)))))))
          (do {! random.monad}
            [upper (random.ascii/upper 1)
             lower (random.ascii/lower 1)
             invalid (random.only (function (_ char)
                                    (not (or (unicode/block.within? unicode/block.basic_latin/upper char)
                                             (unicode/block.within? unicode/block.basic_latin/lower char))))
                                  (random.char unicode.character))
             .let [upper! (/.one_of! "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
                   lower! (/.one_of! "abcdefghijklmnopqrstuvwxyz")]]
            (_.cover [/.and /.and!]
                     (and (..should_pass (format upper lower) (/.and /.upper /.lower))
                          (..should_fail (format (text.of_char invalid) lower) (/.and /.upper /.lower))
                          (..should_fail (format upper (text.of_char invalid)) (/.and /.upper /.lower))

                          (..should_pass! (format upper lower) (/.and! upper! lower!))
                          (..should_fail (format (text.of_char invalid) lower) (/.and! upper! lower!))
                          (..should_fail (format upper (text.of_char invalid)) (/.and! upper! lower!)))))
          (do {! random.monad}
            [expected (random.unicode 1)
             invalid (random.unicode 1)]
            (_.cover [/.satisfies /.character_does_not_satisfy_predicate]
                     (and (..should_pass expected (/.satisfies (function.constant true)))
                          (..should_fail' invalid (/.satisfies (function.constant false))
                                          /.character_does_not_satisfy_predicate))))
          ..character_classes
          ..runs
          )))
