(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    [abstract
     [monad {"+" [do]}]]
    [control
     [pipe {"+" [case>]}]
     ["[0]" try]
     ["[0]" exception]
     ["<>" parser]]
    [data
     ["[0]" name ("[1]\[0]" equivalence)]
     ["[0]" bit ("[1]\[0]" equivalence)]
     ["[0]" text ("[1]\[0]" equivalence)]
     [collection
      ["[0]" list]]]
    [math
     ["[0]" random {"+" [Random]}]
     [number
      ["n" nat]
      ["i" int]
      ["f" frac]
      ["r" rev]]]
    [tool
     [compiler
      [reference {"+" [Constant]}
       [variable {"+" []}]]
      [language
       [lux
        ["[0]" analysis]]]]]]]
  [\\library
   ["[0]" /]])

(template: (!expect <expectation> <computation>)
  [(case <computation>
     <expectation>
     true

     _
     false)])

(def: constant
  (Random Constant)
  (random.and (random.unicode 10)
              (random.unicode 10)))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Parser])
      (do [! random.monad]
        []
        (`` ($_ _.and
                (do [! random.monad]
                  [expected (\ ! each (|>> analysis.bit) random.bit)]
                  (_.cover [/.result /.any]
                           (|> (list expected)
                               (/.result /.any)
                               (case> {try.#Success actual}
                                      (\ analysis.equivalence = expected actual)

                                      {try.#Failure _}
                                      false))))
                (~~ (template [<query> <check> <random> <analysis> <=>]
                      [(do [! random.monad]
                         [expected <random>]
                         (_.cover [<query>]
                                  (|> (list (<analysis> expected))
                                      (/.result <query>)
                                      (case> {try.#Success actual}
                                             (<=> expected actual)

                                             {try.#Failure _}
                                             false))))
                       (do [! random.monad]
                         [expected <random>]
                         (_.cover [<check>]
                                  (|> (list (<analysis> expected))
                                      (/.result (<check> expected))
                                      (!expect {try.#Success _}))))]
                      
                      [/.bit /.bit! random.bit analysis.bit bit\=]
                      [/.nat /.nat! random.nat analysis.nat n.=]
                      [/.int /.int! random.int analysis.int i.=]
                      [/.frac /.frac! random.safe_frac analysis.frac f.=]
                      [/.rev /.rev! random.rev analysis.rev r.=]
                      [/.text /.text! (random.unicode 10) analysis.text text\=]
                      [/.local /.local! random.nat analysis.variable/local n.=]
                      [/.foreign /.foreign! random.nat analysis.variable/foreign n.=]
                      [/.constant /.constant! ..constant analysis.constant name\=]
                      ))
                (do [! random.monad]
                  [expected random.bit]
                  (_.cover [/.tuple]
                           (|> (list (analysis.tuple (list (analysis.bit expected))))
                               (/.result (/.tuple /.bit))
                               (case> {try.#Success actual}
                                      (bit\= expected actual)

                                      {try.#Failure _}
                                      false))))
                (do [! random.monad]
                  [dummy random.bit]
                  (_.cover [/.end?]
                           (and (|> (/.result /.end? (list))
                                    (!expect {try.#Success #1}))
                                (|> (/.result (do <>.monad
                                                [verdict /.end?
                                                 _ /.bit]
                                                (in verdict))
                                              (list (analysis.bit dummy)))
                                    (!expect {try.#Success #0})))))
                (do [! random.monad]
                  [dummy random.bit]
                  (_.cover [/.end!]
                           (and (|> (/.result /.end! (list))
                                    (!expect {try.#Success _}))
                                (|> (/.result /.end! (list (analysis.bit dummy)))
                                    (!expect {try.#Failure _})))))
                (do [! random.monad]
                  [expected random.bit]
                  (_.cover [/.cannot_parse]
                           (and (|> (list (analysis.bit expected))
                                    (/.result /.nat)
                                    (case> {try.#Success _}
                                           false

                                           {try.#Failure error}
                                           (exception.match? /.cannot_parse error)))
                                (|> (list)
                                    (/.result /.bit)
                                    (case> {try.#Success _}
                                           false

                                           {try.#Failure error}
                                           (exception.match? /.cannot_parse error))))))
                (do [! random.monad]
                  [expected random.bit]
                  (_.cover [/.unconsumed_input]
                           (|> (list (analysis.bit expected) (analysis.bit expected))
                               (/.result /.bit)
                               (case> {try.#Success _}
                                      false

                                      {try.#Failure error}
                                      (exception.match? /.unconsumed_input error)))))
                )))))
