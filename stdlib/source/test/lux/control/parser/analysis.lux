(.using
 [library
  [lux (.full)
   ["_" test (.only Test)]
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" pipe]
    ["[0]" try]
    ["[0]" exception]
    ["<>" parser]]
   [data
    ["[0]" bit ("[1]#[0]" equivalence)]
    ["[0]" text ("[1]#[0]" equivalence)]
    [collection
     ["[0]" list]]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" nat]
     ["i" int]
     ["f" frac]
     ["r" rev]]]
   [meta
    ["[0]" symbol ("[1]#[0]" equivalence)]]
   [tool
    [compiler
     [reference (.only Constant)
      [variable (.only)]]
     [language
      [lux
       ["[0]" analysis]]]]]]]
 [\\library
  ["[0]" /]])

(template: (!expect <expectation> <computation>)
  [(case <computation>
     <expectation>
     true

     _
     false)])

(def: constant
  (Random Constant)
  (random.and (random.unicode 10)
              (random.unicode 10)))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Parser])
      (do [! random.monad]
        []
        (`` (all _.and
                 (do [! random.monad]
                   [expected (# ! each (|>> analysis.bit) random.bit)]
                   (_.coverage [/.result /.any]
                     (|> (list expected)
                         (/.result /.any)
                         (pipe.case
                           {try.#Success actual}
                           (# analysis.equivalence = expected actual)

                           {try.#Failure _}
                           false))))
                 (~~ (template [<query> <check> <random> <analysis> <=>]
                       [(do [! random.monad]
                          [expected <random>]
                          (_.coverage [<query>]
                            (|> (list (<analysis> expected))
                                (/.result <query>)
                                (pipe.case
                                  {try.#Success actual}
                                  (<=> expected actual)

                                  {try.#Failure _}
                                  false))))
                        (do [! random.monad]
                          [expected <random>]
                          (_.coverage [<check>]
                            (|> (list (<analysis> expected))
                                (/.result (<check> expected))
                                (!expect {try.#Success _}))))]
                       
                       [/.bit /.this_bit random.bit analysis.bit bit#=]
                       [/.nat /.this_nat random.nat analysis.nat n.=]
                       [/.int /.this_int random.int analysis.int i.=]
                       [/.frac /.this_frac random.safe_frac analysis.frac f.=]
                       [/.rev /.this_rev random.rev analysis.rev r.=]
                       [/.text /.this_text (random.unicode 10) analysis.text text#=]
                       [/.local /.this_local random.nat analysis.local n.=]
                       [/.foreign /.this_foreign random.nat analysis.foreign n.=]
                       [/.constant /.this_constant ..constant analysis.constant symbol#=]
                       ))
                 (do [! random.monad]
                   [expected random.bit]
                   (_.coverage [/.tuple]
                     (|> (list (analysis.tuple (list (analysis.bit expected))))
                         (/.result (/.tuple /.bit))
                         (pipe.case
                           {try.#Success actual}
                           (bit#= expected actual)

                           {try.#Failure _}
                           false))))
                 (do [! random.monad]
                   [dummy random.bit]
                   (_.coverage [/.end?]
                     (and (|> (/.result /.end? (list))
                              (!expect {try.#Success #1}))
                          (|> (/.result (do <>.monad
                                          [verdict /.end?
                                           _ /.bit]
                                          (in verdict))
                                        (list (analysis.bit dummy)))
                              (!expect {try.#Success #0})))))
                 (do [! random.monad]
                   [dummy random.bit]
                   (_.coverage [/.end]
                     (and (|> (/.result /.end (list))
                              (!expect {try.#Success _}))
                          (|> (/.result /.end (list (analysis.bit dummy)))
                              (!expect {try.#Failure _})))))
                 (do [! random.monad]
                   [expected random.bit]
                   (_.coverage [/.cannot_parse]
                     (and (|> (list (analysis.bit expected))
                              (/.result /.nat)
                              (pipe.case
                                {try.#Success _}
                                false

                                {try.#Failure error}
                                (exception.match? /.cannot_parse error)))
                          (|> (list)
                              (/.result /.bit)
                              (pipe.case
                                {try.#Success _}
                                false

                                {try.#Failure error}
                                (exception.match? /.cannot_parse error))))))
                 (do [! random.monad]
                   [expected random.bit]
                   (_.coverage [/.unconsumed_input]
                     (|> (list (analysis.bit expected) (analysis.bit expected))
                         (/.result /.bit)
                         (pipe.case
                           {try.#Success _}
                           false

                           {try.#Failure error}
                           (exception.match? /.unconsumed_input error)))))
                 )))))
