(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   ["[0]" type ("[1]#[0]" equivalence)]
   [abstract
    [monad {"+" do}]]
   [control
    ["[0]" try]
    ["[0]" exception]]
   [data
    [text
     ["%" format {"+" format}]]
    [collection
     ["[0]" list]]]
   [macro
    ["^" pattern]]
   [math
    ["[0]" random {"+" Random}]
    [number
     ["n" nat]]]
   [meta
    ["[0]" symbol ("[1]#[0]" equivalence)]]]]
 [\\library
  ["[0]" /
   ["/[1]" //]]])

(template: (!expect <pattern> <value>)
  [(case <value>
     <pattern>
     true
     
     _
     false)])

(def: primitive
  (Random Type)
  (|> (random.alpha_numeric 1)
      (# random.monad each (function (_ name)
                             {.#Primitive name (list)}))))

(def: test|matches
  Test
  (<| (_.for [/.types_do_not_match])
      (do [! random.monad]
        [expected ..primitive
         dummy (random.only (|>> (type#= expected) not)
                            ..primitive)])
      (all _.and
           (_.cover [/.exactly]
                    (and (|> (/.result (/.exactly expected) expected)
                             (!expect {try.#Success []}))
                         (|> (/.result (/.exactly expected) dummy)
                             (!expect (^.multi {try.#Failure error}
                                               (exception.match? /.types_do_not_match error))))))
           (_.cover [/.sub]
                    (and (|> (/.result (/.sub expected) expected)
                             (!expect {try.#Success []}))
                         (|> (/.result (/.sub Any) expected)
                             (!expect {try.#Success []}))
                         (|> (/.result (/.sub expected) Nothing)
                             (!expect {try.#Success []}))
                         (|> (/.result (/.sub expected) dummy)
                             (!expect (^.multi {try.#Failure error}
                                               (exception.match? /.types_do_not_match error))))))
           (_.cover [/.super]
                    (and (|> (/.result (/.super expected) expected)
                             (!expect {try.#Success []}))
                         (|> (/.result (/.super expected) Any)
                             (!expect {try.#Success []}))
                         (|> (/.result (/.super Nothing) expected)
                             (!expect {try.#Success []}))
                         (|> (/.result (/.super expected) dummy)
                             (!expect (^.multi {try.#Failure error}
                                               (exception.match? /.types_do_not_match error))))))
           )))

(def: test|aggregate
  Test
  (do [! random.monad]
    [expected_left ..primitive
     expected_middle ..primitive
     expected_right ..primitive]
    (`` (all _.and
             (~~ (template [<parser> <exception> <good_constructor> <bad_constructor>]
                   [(_.cover [<parser> <exception>]
                             (and (|> (/.result (<parser> (all //.and /.any /.any /.any))
                                                (<good_constructor> (list expected_left expected_middle expected_right)))
                                      (!expect (^.multi {try.#Success [actual_left actual_middle actual_right]}
                                                        (and (type#= expected_left actual_left)
                                                             (type#= expected_middle actual_middle)
                                                             (type#= expected_right actual_right)))))
                                  (|> (/.result (<parser> (all //.and /.any /.any /.any))
                                                (<bad_constructor> (list expected_left expected_middle expected_right)))
                                      (!expect (^.multi {try.#Failure error}
                                                        (exception.match? <exception> error))))))]

                   [/.variant /.not_variant type.variant type.tuple]
                   [/.tuple /.not_tuple type.tuple type.variant]
                   ))

             (_.cover [/.function /.not_function]
                      (and (|> (/.result (/.function (all //.and /.any /.any) /.any)
                                         (type.function (list expected_left expected_middle) expected_right))
                               (!expect (^.multi {try.#Success [[actual_left actual_middle] actual_right]}
                                                 (and (type#= expected_left actual_left)
                                                      (type#= expected_middle actual_middle)
                                                      (type#= expected_right actual_right)))))
                           (|> (/.result (/.function (all //.and /.any /.any) /.any)
                                         (type.variant (list expected_left expected_middle expected_right)))
                               (!expect (^.multi {try.#Failure error}
                                                 (exception.match? /.not_function error))))))
             (_.cover [/.applied /.not_application]
                      (and (|> (/.result (/.applied (all //.and /.any /.any /.any))
                                         (type.application (list expected_middle expected_right) expected_left))
                               (!expect (^.multi {try.#Success [actual_left actual_middle actual_right]}
                                                 (and (type#= expected_left actual_left)
                                                      (type#= expected_middle actual_middle)
                                                      (type#= expected_right actual_right)))))
                           (|> (/.result (/.applied (all //.and /.any /.any /.any))
                                         (type.variant (list expected_left expected_middle expected_right)))
                               (!expect (^.multi {try.#Failure error}
                                                 (exception.match? /.not_application error))))))
             ))))

(def: test|parameter
  Test
  (do random.monad
    [quantification ..primitive
     argument ..primitive
     not_parameter ..primitive
     parameter random.nat]
    (all _.and
         (_.cover [/.not_parameter]
                  (|> (/.result /.parameter not_parameter)
                      (!expect (^.multi {try.#Failure error}
                                        (exception.match? /.not_parameter error)))))
         (_.cover [/.unknown_parameter]
                  (|> (/.result /.parameter {.#Parameter parameter})
                      (!expect (^.multi {try.#Failure error}
                                        (exception.match? /.unknown_parameter error)))))
         (_.cover [/.with_extension]
                  (|> (/.result (<| (/.with_extension quantification)
                                    (/.with_extension argument)
                                    /.any)
                                not_parameter)
                      (!expect (^.multi {try.#Success [quantification##binding argument##binding actual]}
                                        (same? not_parameter actual)))))
         (_.cover [/.parameter]
                  (|> (/.result (<| (/.with_extension quantification)
                                    (/.with_extension argument)
                                    /.parameter)
                                {.#Parameter 0})
                      (!expect {try.#Success [quantification##binding argument##binding _]})))
         (_.cover [/.argument]
                  (let [argument? (is (-> Nat Nat Bit)
                                      (function (_ @ expected)
                                        (|> (/.result (<| (/.with_extension quantification)
                                                          (/.with_extension argument)
                                                          (/.with_extension quantification)
                                                          (/.with_extension argument)
                                                          (do //.monad
                                                            [env /.env
                                                             _ /.any]
                                                            (in (/.argument env @))))
                                                      not_parameter)
                                            (!expect (^.multi {try.#Success [_ _ _ _ actual]}
                                                              (n.= expected actual))))))]
                    (and (argument? 0 2)
                         (argument? 1 3)
                         (argument? 2 0))))
         (_.cover [/.wrong_parameter]
                  (|> (/.result (<| (/.with_extension quantification)
                                    (/.with_extension argument)
                                    (/.this_parameter 1))
                                {.#Parameter 0})
                      (!expect (^.multi {try.#Failure error}
                                        (exception.match? /.wrong_parameter error)))))
         (_.cover [/.this_parameter]
                  (|> (/.result (<| (/.with_extension quantification)
                                    (/.with_extension argument)
                                    (/.this_parameter 0))
                                {.#Parameter 0})
                      (!expect {try.#Success [quantification##binding argument##binding _]})))
         )))

(def: test|polymorphic
  Test
  (do [! random.monad]
    [not_polymorphic ..primitive
     expected_inputs (# ! each (|>> (n.% 10) ++) random.nat)]
    (all _.and
         (_.cover [/.not_polymorphic]
                  (and (|> (/.result (/.polymorphic /.any)
                                     not_polymorphic)
                           (!expect (^.multi {try.#Failure error}
                                             (exception.match? /.not_polymorphic error))))
                       (|> (/.result (/.polymorphic /.any)
                                     (type.univ_q 0 not_polymorphic))
                           (!expect (^.multi {try.#Failure error}
                                             (exception.match? /.not_polymorphic error))))))
         (_.cover [/.polymorphic]
                  (|> (/.result (/.polymorphic /.any)
                                (type.univ_q expected_inputs not_polymorphic))
                      (!expect (^.multi {try.#Success [g!poly actual_inputs bodyT]}
                                        (and (n.= expected_inputs (list.size actual_inputs))
                                             (same? not_polymorphic bodyT))))))
         )))

(def: test|recursive
  Test
  (do random.monad
    [expected ..primitive]
    (all _.and
         (_.cover [/.recursive]
                  (|> (.type (Rec @ expected))
                      (/.result (/.recursive /.any))
                      (!expect (^.multi {try.#Success [@self actual]}
                                        (type#= expected actual)))))
         (_.cover [/.recursive_self]
                  (|> (.type (Rec @ @))
                      (/.result (/.recursive /.recursive_self))
                      (!expect (^.multi {try.#Success [@expected @actual]}
                                        (same? @expected @actual)))))
         (_.cover [/.recursive_call]
                  (|> (.type (All (self input) (self input)))
                      (/.result (/.polymorphic /.recursive_call))
                      (!expect {try.#Success [@self inputs ???]})))
         (_.cover [/.not_recursive]
                  (and (|> expected
                           (/.result (/.recursive /.any))
                           (!expect (^.multi {try.#Failure error}
                                             (exception.match? /.not_recursive error))))
                       (|> expected
                           (/.result /.recursive_self)
                           (!expect (^.multi {try.#Failure error}
                                             (exception.match? /.not_recursive error))))))
         )))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Parser])
      (all _.and
           (do [! random.monad]
             [expected ..primitive]
             (_.cover [/.result /.any]
                      (|> (/.result /.any expected)
                          (!expect (^.multi {try.#Success actual}
                                            (type#= expected actual))))))
           (do [! random.monad]
             [expected ..primitive]
             (_.cover [/.next /.unconsumed_input]
                      (and (|> (/.result (do //.monad
                                           [actual /.next
                                            _ /.any]
                                           (in actual))
                                         expected)
                               (!expect (^.multi {try.#Success actual}
                                                 (type#= expected actual))))
                           (|> (/.result /.next expected)
                               (!expect (^.multi {try.#Failure error}
                                                 (exception.match? /.unconsumed_input error)))))))
           (do [! random.monad]
             [expected ..primitive]
             (_.cover [/.empty_input]
                      (`` (and (~~ (template [<parser>]
                                     [(|> (/.result (do //.monad
                                                      [_ /.any]
                                                      <parser>)
                                                    expected)
                                          (!expect (^.multi {try.#Failure error}
                                                            (exception.match? /.empty_input error))))]

                                     [/.any]
                                     [/.next]
                                     ))))))
           (do [! random.monad]
             [expected ..primitive]
             (_.cover [/.Env /.env /.fresh]
                      (|> (/.result (do //.monad
                                      [env /.env
                                       _ /.any]
                                      (in env))
                                    expected)
                          (!expect (^.multi {try.#Success environment}
                                            (same? /.fresh environment))))))
           (do [! random.monad]
             [expected ..primitive
              dummy (random.only (|>> (type#= expected) not)
                                 ..primitive)]
             (_.cover [/.local]
                      (|> (/.result (do //.monad
                                      [_ /.any]
                                      (/.local (list expected)
                                               /.any))
                                    dummy)
                          (!expect (^.multi {try.#Success actual}
                                            (type#= expected actual))))))
           (do [! random.monad]
             [expected random.nat]
             (_.cover [/.existential /.not_existential]
                      (|> (/.result /.existential
                                    {.#Ex expected})
                          (!expect (^.multi {try.#Success actual}
                                            (n.= expected actual))))))
           (do [! random.monad]
             [expected_name (random.and (random.alpha_numeric 1)
                                        (random.alpha_numeric 1))
              expected_type ..primitive]
             (_.cover [/.named /.not_named]
                      (|> (/.result /.named
                                    {.#Named expected_name expected_type})
                          (!expect (^.multi {try.#Success [actual_name actual_type]}
                                            (and (symbol#= expected_name actual_name)
                                                 (type#= expected_type actual_type)))))))
           ..test|aggregate
           ..test|matches
           ..test|parameter
           ..test|polymorphic
           ..test|recursive
           )))
