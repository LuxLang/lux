(.module:
  [library
   [lux "*"
    ["_" test {"+" Test}]
    [abstract
     [monad {"+" do}]]
    [control
     ["[0]" try]
     ["[0]" exception]]
    [data
     [collection
      ["[0]" list]]]
    [math
     ["[0]" random {"+" Random}]
     [number
      ["n" nat]]]
    [meta
     ["[0]" symbol ("[1]#[0]" equivalence)]]
    ["[0]" type ("[1]#[0]" equivalence)]]]
  [\\library
   ["[0]" /
    ["/[1]" //]]])

(template: (!expect <pattern> <value>)
  [(case <value>
     <pattern>
     true
     
     _
     false)])

(def: primitive
  (Random Type)
  (|> (random.ascii/alpha_num 1)
      (# random.monad each (function (_ name)
                             {.#Primitive name (list)}))))

(def: matches
  Test
  (<| (_.for [/.types_do_not_match])
      (do [! random.monad]
        [expected ..primitive
         dummy (random.only (|>> (type#= expected) not)
                            ..primitive)])
      ($_ _.and
          (_.cover [/.exactly]
                   (and (|> (/.result (/.exactly expected) expected)
                            (!expect {try.#Success []}))
                        (|> (/.result (/.exactly expected) dummy)
                            (!expect (^multi {try.#Failure error}
                                             (exception.match? /.types_do_not_match error))))))
          (_.cover [/.sub]
                   (and (|> (/.result (/.sub expected) expected)
                            (!expect {try.#Success []}))
                        (|> (/.result (/.sub Any) expected)
                            (!expect {try.#Success []}))
                        (|> (/.result (/.sub expected) Nothing)
                            (!expect {try.#Success []}))
                        (|> (/.result (/.sub expected) dummy)
                            (!expect (^multi {try.#Failure error}
                                             (exception.match? /.types_do_not_match error))))))
          (_.cover [/.super]
                   (and (|> (/.result (/.super expected) expected)
                            (!expect {try.#Success []}))
                        (|> (/.result (/.super expected) Any)
                            (!expect {try.#Success []}))
                        (|> (/.result (/.super Nothing) expected)
                            (!expect {try.#Success []}))
                        (|> (/.result (/.super expected) dummy)
                            (!expect (^multi {try.#Failure error}
                                             (exception.match? /.types_do_not_match error))))))
          )))

(def: aggregate
  Test
  (do [! random.monad]
    [expected_left ..primitive
     expected_middle ..primitive
     expected_right ..primitive]
    (`` ($_ _.and
            (~~ (template [<parser> <exception> <good_constructor> <bad_constructor>]
                  [(_.cover [<parser> <exception>]
                            (and (|> (/.result (<parser> ($_ //.and /.any /.any /.any))
                                               (<good_constructor> (list expected_left expected_middle expected_right)))
                                     (!expect (^multi {try.#Success [actual_left actual_middle actual_right]}
                                                      (and (type#= expected_left actual_left)
                                                           (type#= expected_middle actual_middle)
                                                           (type#= expected_right actual_right)))))
                                 (|> (/.result (<parser> ($_ //.and /.any /.any /.any))
                                               (<bad_constructor> (list expected_left expected_middle expected_right)))
                                     (!expect (^multi {try.#Failure error}
                                                      (exception.match? <exception> error))))))]

                  [/.variant /.not_variant type.variant type.tuple]
                  [/.tuple /.not_tuple type.tuple type.variant]
                  ))

            (_.cover [/.function /.not_function]
                     (and (|> (/.result (/.function ($_ //.and /.any /.any) /.any)
                                        (type.function (list expected_left expected_middle) expected_right))
                              (!expect (^multi {try.#Success [[actual_left actual_middle] actual_right]}
                                               (and (type#= expected_left actual_left)
                                                    (type#= expected_middle actual_middle)
                                                    (type#= expected_right actual_right)))))
                          (|> (/.result (/.function ($_ //.and /.any /.any) /.any)
                                        (type.variant (list expected_left expected_middle expected_right)))
                              (!expect (^multi {try.#Failure error}
                                               (exception.match? /.not_function error))))))
            (_.cover [/.applied /.not_application]
                     (and (|> (/.result (/.applied ($_ //.and /.any /.any /.any))
                                        (type.application (list expected_middle expected_right) expected_left))
                              (!expect (^multi {try.#Success [actual_left actual_middle actual_right]}
                                               (and (type#= expected_left actual_left)
                                                    (type#= expected_middle actual_middle)
                                                    (type#= expected_right actual_right)))))
                          (|> (/.result (/.applied ($_ //.and /.any /.any /.any))
                                        (type.variant (list expected_left expected_middle expected_right)))
                              (!expect (^multi {try.#Failure error}
                                               (exception.match? /.not_application error))))))
            ))))

(def: parameter
  Test
  (do random.monad
    [quantification ..primitive
     argument ..primitive
     not_parameter ..primitive
     parameter random.nat]
    ($_ _.and
        (_.cover [/.not_parameter]
                 (|> (/.result /.parameter not_parameter)
                     (!expect (^multi {try.#Failure error}
                                      (exception.match? /.not_parameter error)))))
        (_.cover [/.unknown_parameter]
                 (|> (/.result /.parameter {.#Parameter parameter})
                     (!expect (^multi {try.#Failure error}
                                      (exception.match? /.unknown_parameter error)))))
        (_.cover [/.with_extension]
                 (|> (/.result (<| (/.with_extension quantification)
                                   (/.with_extension argument)
                                   /.any)
                               not_parameter)
                     (!expect (^multi {try.#Success [quantification##binding argument##binding actual]}
                                      (same? not_parameter actual)))))
        (_.cover [/.parameter]
                 (|> (/.result (<| (/.with_extension quantification)
                                   (/.with_extension argument)
                                   /.parameter)
                               {.#Parameter 0})
                     (!expect {try.#Success [quantification##binding argument##binding _]})))
        (_.cover [/.wrong_parameter]
                 (|> (/.result (<| (/.with_extension quantification)
                                   (/.with_extension argument)
                                   (/.parameter! 1))
                               {.#Parameter 0})
                     (!expect (^multi {try.#Failure error}
                                      (exception.match? /.wrong_parameter error)))))
        (_.cover [/.parameter!]
                 (|> (/.result (<| (/.with_extension quantification)
                                   (/.with_extension argument)
                                   (/.parameter! 0))
                               {.#Parameter 0})
                     (!expect {try.#Success [quantification##binding argument##binding _]})))
        )))

(def: polymorphic
  Test
  (do [! random.monad]
    [not_polymorphic ..primitive
     expected_inputs (# ! each (|>> (n.% 10) ++) random.nat)]
    ($_ _.and
        (_.cover [/.not_polymorphic]
                 (and (|> (/.result (/.polymorphic /.any)
                                    not_polymorphic)
                          (!expect (^multi {try.#Failure error}
                                           (exception.match? /.not_polymorphic error))))
                      (|> (/.result (/.polymorphic /.any)
                                    (type.univ_q 0 not_polymorphic))
                          (!expect (^multi {try.#Failure error}
                                           (exception.match? /.not_polymorphic error))))))
        (_.cover [/.polymorphic]
                 (|> (/.result (/.polymorphic /.any)
                               (type.univ_q expected_inputs not_polymorphic))
                     (!expect (^multi {try.#Success [g!poly actual_inputs bodyT]}
                                      (and (n.= expected_inputs (list.size actual_inputs))
                                           (same? not_polymorphic bodyT))))))
        )))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Parser])
      ($_ _.and
          (do [! random.monad]
            [expected ..primitive]
            (_.cover [/.result /.any]
                     (|> (/.result /.any expected)
                         (!expect (^multi {try.#Success actual}
                                          (type#= expected actual))))))
          (do [! random.monad]
            [expected ..primitive]
            (_.cover [/.next /.unconsumed_input]
                     (and (|> (/.result (do //.monad
                                          [actual /.next
                                           _ /.any]
                                          (in actual))
                                        expected)
                              (!expect (^multi {try.#Success actual}
                                               (type#= expected actual))))
                          (|> (/.result /.next expected)
                              (!expect (^multi {try.#Failure error}
                                               (exception.match? /.unconsumed_input error)))))))
          (do [! random.monad]
            [expected ..primitive]
            (_.cover [/.empty_input]
                     (`` (and (~~ (template [<parser>]
                                    [(|> (/.result (do //.monad
                                                     [_ /.any]
                                                     <parser>)
                                                   expected)
                                         (!expect (^multi {try.#Failure error}
                                                          (exception.match? /.empty_input error))))]

                                    [/.any]
                                    [/.next]
                                    ))))))
          (do [! random.monad]
            [expected ..primitive]
            (_.cover [/.Env /.env /.fresh]
                     (|> (/.result (do //.monad
                                     [env /.env
                                      _ /.any]
                                     (in env))
                                   expected)
                         (!expect (^multi {try.#Success environment}
                                          (same? /.fresh environment))))))
          (do [! random.monad]
            [expected ..primitive
             dummy (random.only (|>> (type#= expected) not)
                                ..primitive)]
            (_.cover [/.local]
                     (|> (/.result (do //.monad
                                     [_ /.any]
                                     (/.local (list expected)
                                              /.any))
                                   dummy)
                         (!expect (^multi {try.#Success actual}
                                          (type#= expected actual))))))
          (do [! random.monad]
            [expected random.nat]
            (_.cover [/.existential /.not_existential]
                     (|> (/.result /.existential
                                   {.#Ex expected})
                         (!expect (^multi {try.#Success actual}
                                          (n.= expected actual))))))
          (do [! random.monad]
            [expected_name (random.and (random.ascii/alpha_num 1)
                                       (random.ascii/alpha_num 1))
             expected_type ..primitive]
            (_.cover [/.named /.not_named]
                     (|> (/.result /.named
                                   {.#Named expected_name expected_type})
                         (!expect (^multi {try.#Success [actual_name actual_type]}
                                          (and (symbol#= expected_name actual_name)
                                               (type#= expected_type actual_type)))))))
          ..aggregate
          ..matches
          ..parameter
          ..polymorphic
          )))
