(.require
 [library
  [lux (.except)
   ["_" test (.only Test)]
   [abstract
    [equivalence (.only Equivalence)]
    [predicate (.only Predicate)]
    [monad (.only do)]
    [\\specification
     ["$[0]" monoid]]]
   [control
    ["[0]" state (.only State)]]
   [data
    ["[0]" product]
    [collection
     ["[0]" list (.use "[1]#[0]" functor mix)]]]
   [macro
    ["^" pattern]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" nat]]]]]
 [\\library
  ["[0]" /]])

(def .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [input (|> random.nat (at ! each (|>> (n.% 6) (n.+ 20))))
         dummy random.nat
         shift (|> random.nat (random.only (|>> (n.= dummy) not)))
         .let [equivalence (is (Equivalence (/.Mixin Nat Nat))
                               (implementation
                                (def (= left right)
                                  (n.= ((/.fixed left) input)
                                       ((/.fixed right) input)))))
               generator (is (Random (/.Mixin Nat Nat))
                             (do !
                               [output random.nat]
                               (in (function (_ delegate again input)
                                     output))))
               expected (|> (list.indices input)
                            (list#each ++)
                            (list#mix n.* 1))]])
      (all _.and
           (_.for [/.Mixin]
                  (all _.and
                       (_.for [/.monoid]
                              ($monoid.spec equivalence /.monoid generator))
                       
                       (_.coverage [/.fixed]
                         (let [factorial (/.fixed
                                          (function (_ delegate again input)
                                            (case input
                                              (^.or 0 1) 1
                                              _ (n.* input (again (-- input))))))]
                           (n.= expected
                                (factorial input))))
                       (_.coverage [/.mixed]
                         (let [bottom (is (/.Mixin Nat Nat)
                                          (function (_ delegate again input)
                                            (case input
                                              (^.or 0 1) 1
                                              _ (delegate input))))
                               multiplication (is (/.Mixin Nat Nat)
                                                  (function (_ delegate again input)
                                                    (n.* input (again (-- input)))))
                               factorial (/.fixed (/.mixed bottom multiplication))]
                           (n.= expected
                                (factorial input))))
                       (_.coverage [/.nothing]
                         (let [loop (is (/.Mixin Nat Nat)
                                        (function (_ delegate again input)
                                          (case input
                                            (^.or 0 1) 1
                                            _ (n.* input (delegate (-- input))))))
                               left (/.fixed (/.mixed /.nothing loop))
                               right (/.fixed (/.mixed loop /.nothing))]
                           (and (n.= expected
                                     (left input))
                                (n.= expected
                                     (right input)))))
                       (_.coverage [/.advice]
                         (let [bottom (is (/.Mixin Nat Nat)
                                          (function (_ delegate again input)
                                            1))
                               bottom? (is (Predicate Nat)
                                           (function (_ input)
                                             (case input
                                               (^.or 0 1) true
                                               _ false)))
                               multiplication (is (/.Mixin Nat Nat)
                                                  (function (_ delegate again input)
                                                    (n.* input (again (-- input)))))
                               factorial (/.fixed (/.mixed (/.advice bottom? bottom)
                                                           multiplication))]
                           (n.= expected
                                (factorial input))))
                       (_.coverage [/.before]
                         (let [implant (is (-> Nat (State Nat []))
                                           (function (_ input)
                                             (function (_ state)
                                               [shift []])))
                               meld (is (/.Mixin Nat (State Nat Nat))
                                        (function (_ delegate again input)
                                          (function (_ state)
                                            [state (n.+ state input)])))
                               function (/.fixed (/.mixed (/.before state.monad implant)
                                                          meld))]
                           (n.= (n.+ shift input)
                                (|> input function (state.result dummy) product.right))))
                       (_.coverage [/.after]
                         (let [implant (is (-> Nat Nat (State Nat []))
                                           (function (_ input output)
                                             (function (_ state)
                                               [shift []])))
                               meld (is (/.Mixin Nat (State Nat Nat))
                                        (function (_ delegate again input)
                                          (function (_ state)
                                            [state (n.+ state input)])))
                               function (/.fixed (/.mixed (/.after state.monad implant)
                                                          meld))]
                           (n.= (n.+ dummy input)
                                (|> input function (state.result dummy) product.right))))
                       ))
           (_.for [/.Recursive]
                  (_.coverage [/.of_recursive]
                    (let [factorial (/.fixed
                                     (/.of_recursive
                                      (function (_ again input)
                                        (case input
                                          (^.or 0 1) 1
                                          _ (n.* input (again (-- input)))))))]
                      (n.= expected
                           (factorial input)))))
           )))
