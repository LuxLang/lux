(.module:
  [library
   [lux #*
    ["_" test (#+ Test)]
    [abstract
     [monad (#+ do)]
     [\\specification
      ["$." functor (#+ Injection Comparison)]
      ["$." apply]
      ["$." monad]]]
    [data
     [collection
      ["." list]]]
    [math
     ["." random]
     [number
      ["n" nat]]]]]
  [\\library
   ["." /]])

(def: injection
  (All [o] (Injection (All [i] (/.Cont i o))))
  (|>> /.pending))

(def: comparison
  (Comparison /.Cont)
  (function (_ == left right)
    (== (/.result left) (/.result right))))

(def: .public test
  Test
  (<| (_.covering /._)
      (do random.monad
        [sample random.nat
         .let [(^open "_\.") /.apply
               (^open "_\.") /.monad]
         elems (random.list 3 random.nat)])
      (_.for [/.Cont])
      ($_ _.and
          (_.for [/.functor]
                 ($functor.spec ..injection ..comparison /.functor))
          (_.for [/.apply]
                 ($apply.spec ..injection ..comparison /.apply))
          (_.for [/.monad]
                 ($monad.spec ..injection ..comparison /.monad))

          (_.cover [/.result]
                   (n.= sample (/.result (_\in sample))))
          (_.cover [/.call/cc]
                   (n.= (n.* 2 sample)
                        (/.result (do {! /.monad}
                                    [value (/.call/cc
                                            (function (_ k)
                                              (do !
                                                [temp (k sample)]
                                                ... If this code where to run,
                                                ... the output would be
                                                ... (n.* 4 sample)
                                                (k temp))))]
                                    (in (n.* 2 value))))))
          (_.cover [/.portal]
                   (n.= (n.+ 100 sample)
                        (/.result (do /.monad
                                    [[restart [output idx]] (/.portal [sample 0])]
                                    (if (n.< 10 idx)
                                      (restart [(n.+ 10 output) (inc idx)])
                                      (in output))))))
          (_.cover [/.shift /.reset]
                   (let [(^open "_\.") /.monad
                         (^open "list\.") (list.equivalence n.equivalence)
                         visit (: (-> (List Nat)
                                      (/.Cont (List Nat) (List Nat)))
                                  (function (visit xs)
                                    (case xs
                                      #.End
                                      (_\in #.End)

                                      (#.Item x xs')
                                      (do {! /.monad}
                                        [output (/.shift (function (_ k)
                                                           (do !
                                                             [tail (k xs')]
                                                             (in (#.Item x tail)))))]
                                        (visit output)))))]
                     (list\= elems
                             (/.result (/.reset (visit elems))))))
          (_.cover [/.continue]
                   (/.continue (same? sample)
                               (: (/.Cont Nat Bit)
                                  (function (_ next)
                                    (next sample)))))
          (_.cover [/.pending]
                   (/.continue (same? sample)
                               (: (/.Cont Nat Bit)
                                  (/.pending sample))))
          )))
