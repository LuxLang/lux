(.module:
  [lux #*
   ["_" test (#+ Test)]
   [control
    [hash (#+ Hash)]
    [monad (#+ do)]
    [security
     ["!" capability]]
    {[0 #test]
     [/
      [".T" functor (#+ Injection Comparison)]
      [".T" apply]
      [".T" monad]]}]
   [data
    ["." text ("#;." equivalence)
     format]]
   [math
    ["r" random]]]
  {1
   ["." / (#+ Context Can-Conceal Can-Reveal Privilege Private with-privacy)]})

(def: (injection can-conceal)
  (All [label]
    (-> (Can-Conceal label) (Injection (All [value] (Private value label)))))
  (!.use can-conceal))

(def: (comparison can-reveal)
  (All [label]
    (-> (Can-Reveal label) (Comparison (All [value] (Private value label)))))
  (function (_ == left right)
    (== (!.use can-reveal left)
        (!.use can-reveal right))))

(type: Password (Private Text))

(signature: (Policy %)
  (: (Hash (Password %))
     &hash)

  (: (-> Text (Password %))
     password)

  (: (Privilege %)
     privilege))

(def: (policy _)
  (Ex [%] (-> Any (Policy %)))
  (with-privacy
    (: (Context Policy)
       (function (_ (^@ privilege (^open "%/.")))
         (structure
          (def: &hash
            (structure
             (def: &equivalence
               (structure (def: (= reference sample)
                            (text;= (!.use %/can-reveal reference)
                                    (!.use %/can-reveal sample)))))
             (def: hash
               (|>> (!.use %/can-reveal)
                    (:: text.hash hash)))))
          
          (def: password
            (!.use %/can-conceal))

          (def: privilege
            privilege))))))

(def: #export test
  Test
  (<| (_.context (%name (name-of /.Private)))
      (do r.monad
        [#let [policy-0 (policy [])]
         raw-password (r.ascii 10)
         #let [password (:: policy-0 password raw-password)]]
        ($_ _.and
            (_.test "Can work with private values under the same label."
                    (and (:: policy-0 = password password)
                         (n/= (:: text.hash hash raw-password)
                              (:: policy-0 hash password))))
            (let [policy-1 (policy [])
                  delegate (/.delegation (:: policy-0 can-reveal) (:: policy-1 can-conceal))]
              (_.test "Can use delegation to share private values between policies."
                      (:: policy-1 = (delegate password) (delegate password))))
            (functorT.laws (..injection (:: policy-0 can-conceal)) (..comparison (:: policy-0 can-reveal)) /.functor)
            (applyT.laws (..injection (:: policy-0 can-conceal)) (..comparison (:: policy-0 can-reveal)) /.apply)
            (monadT.laws (..injection (:: policy-0 can-conceal)) (..comparison (:: policy-0 can-reveal)) /.monad)
            ))))
