(.module:
  [lux #*
   ["_" test (#+ Test)]
   [control
    [hash (#+ Hash)]
    [monad (#+ do)]
    {[0 #test]
     [/
      [".T" functor (#+ Injection Comparison)]
      [".T" apply]
      [".T" monad]]}]
   [data
    ["." error]
    ["." text ("#/." equivalence)
     format]]
   [math
    ["r" random]]]
  {1
   ["." / (#+ Dirty)]})

(def: injection
  (Injection Dirty)
  /.taint)

(def: comparison
  (Comparison Dirty)
  (function (_ == left right)
    (== (/.trust left)
        (/.trust right))))

(def: #export test
  Test
  (<| (_.context (%name (name-of /.Dirty)))
      (do r.monad
        [raw (r.ascii 10)
         #let [dirty (/.taint raw)]]
        ($_ _.and
            (_.test "Can clean a dirty value by trusting it."
                    (text/= raw (/.trust dirty)))
            (_.test "Can validate a dirty value."
                    (case (/.validate (function (_ value)
                                        (if (|> value text.size (n/> 0))
                                          (#error.Success value)
                                          (#error.Failure "Empty text is invalid.")))
                                      dirty)
                      (#error.Success clean)
                      (text/= raw clean)

                      (#error.Failure error)
                      false))
            (functorT.laws ..injection ..comparison /.functor)
            (applyT.laws ..injection ..comparison /.apply)
            (monadT.laws ..injection ..comparison /.monad)
            ))))
