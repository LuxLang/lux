(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]
    [equivalence {"+" Equivalence}]
    [\\specification
     ["$[0]" functor {"+" Injection Comparison}]
     ["$[0]" apply]
     ["$[0]" monad]]]
   [control
    ["[0]" try {"+" Try}]
    [parser
     ["<[0]>" code]]]
   [data
    ["[0]" text ("[1]#[0]" equivalence)
     ["%" format {"+" format}]]
    [collection
     ["[0]" list ("[1]#[0]" functor)]]]
   [math
    ["[0]" random]
    [number
     ["n" nat]]]
   [macro
    [syntax {"+" syntax:}]
    ["[0]" code]]]]
 [\\library
  ["[0]" / {"+" Parser}]]
 ["[0]" / "_"
  ["[1][0]" analysis]
  ["[1][0]" binary]
  ["[1][0]" cli]
  ["[1][0]" code]
  ["[1][0]" environment]
  ["[1][0]" json]
  ["[1][0]" synthesis]
  ["[1][0]" text]
  ["[1][0]" tree]
  ["[1][0]" type]
  ["[1][0]" xml]])

(def: (should_fail expected input)
  (All (_ a) (-> Text (Try a) Bit))
  (case input
    {try.#Failure actual}
    (text#= expected actual)
    
    _
    #0))

(def: (enforced? parser input)
  (All (_ s) (-> (Parser s Any) s Bit))
  (case (/.result parser input)
    {try.#Success [_ []]}
    #1

    _
    #0))

(def: (found? parser input)
  (All (_ s) (-> (Parser s Bit) s Bit))
  (case (/.result parser input)
    {try.#Success [_ #1]}
    #1

    _
    #0))

(def: (fails? input)
  (All (_ a) (-> (Try a) Bit))
  (case input
    {try.#Failure _}
    #1

    _
    #0))

(syntax: (match [pattern <code>.any
                 then <code>.any
                 input <code>.any])
  (in (list (` (case (~ input)
                 (pattern {try.#Success [(~' _) (~ pattern)]})
                 (~ then)

                 (~' _)
                 #0)))))

(def: combinators_0
  Test
  (do [! random.monad]
    [expected0 random.nat
     variadic (# ! each (|>> (n.max 1) (n.min 20)) random.nat)
     expected+ (random.list variadic random.nat)
     even0 (random.only n.even? random.nat)
     odd0 (random.only n.odd? random.nat)
     not0 random.bit]
    ($_ _.and
        (_.cover [/.maybe]
                 (and (|> (list (code.nat expected0))
                          (/.result (/.maybe <code>.nat))
                          (match {.#Some actual}
                                 (n.= expected0 actual)))
                      (|> (list (code.int (.int expected0)))
                          (/.result (/.maybe <code>.nat))
                          (match {.#None}
                                 #1))))
        (_.cover [/.some]
                 (and (|> (list#each code.nat expected+)
                          (/.result (/.some <code>.nat))
                          (match actual
                                 (# (list.equivalence n.equivalence) = expected+ actual)))
                      (|> (list#each (|>> .int code.int) expected+)
                          (/.result (/.some <code>.nat))
                          (match {.#End}
                                 #1))))
        (_.cover [/.many]
                 (and (|> (list#each code.nat expected+)
                          (/.result (/.many <code>.nat))
                          (match actual
                                 (# (list.equivalence n.equivalence) = expected+ actual)))
                      (|> (list (code.nat expected0))
                          (/.result (/.many <code>.nat))
                          (match (list actual)
                                 (n.= expected0 actual)))
                      (|> (list#each (|>> .int code.int) expected+)
                          (/.result (/.many <code>.nat))
                          fails?)))
        (_.cover [/.only]
                 (and (|> (list (code.nat even0))
                          (/.result (/.only n.even? <code>.nat))
                          (match actual (n.= even0 actual)))
                      (|> (list (code.nat odd0))
                          (/.result (/.only n.even? <code>.nat))
                          fails?)))
        (_.cover [/.and]
                 (let [even (/.only n.even? <code>.nat)
                       odd (/.only n.odd? <code>.nat)]
                   (and (|> (list (code.nat even0) (code.nat odd0))
                            (/.result (/.and even odd))
                            (match [left right]
                                   (and (n.= even0 left)
                                        (n.= odd0 right))))
                        (|> (list (code.nat odd0) (code.nat even0))
                            (/.result (/.and even odd))
                            fails?))))
        (_.cover [/.or]
                 (let [even (/.only n.even? <code>.nat)
                       odd (/.only n.odd? <code>.nat)]
                   (and (|> (list (code.nat even0))
                            (/.result (/.or even odd))
                            (match {.#Left actual} (n.= even0 actual)))
                        (|> (list (code.nat odd0))
                            (/.result (/.or even odd))
                            (match {.#Right actual} (n.= odd0 actual)))
                        (|> (list (code.bit not0))
                            (/.result (/.or even odd))
                            fails?))))
        (_.cover [/.either]
                 (let [even (/.only n.even? <code>.nat)
                       odd (/.only n.odd? <code>.nat)]
                   (and (|> (list (code.nat even0))
                            (/.result (/.either even odd))
                            (match actual (n.= even0 actual)))
                        (|> (list (code.nat odd0))
                            (/.result (/.either even odd))
                            (match actual (n.= odd0 actual)))
                        (|> (list (code.bit not0))
                            (/.result (/.either even odd))
                            fails?))))
        (_.cover [/.not]
                 (and (|> (list (code.nat expected0))
                          (/.result (/.not <code>.nat))
                          fails?)
                      (|> (list (code.bit not0))
                          (/.result (/.not <code>.nat))
                          (match [] #1))))
        )))

(def: combinators_1
  Test
  (do [! random.monad]
    [variadic (# ! each (|>> (n.max 1) (n.min 20)) random.nat)
     times (# ! each (n.% variadic) random.nat)
     expected random.nat
     wrong (|> random.nat (random.only (|>> (n.= expected) not)))
     expected+ (random.list variadic random.nat)
     separator (random.ascii 1)]
    ($_ _.and
        (_.cover [/.exactly]
                 (and (|> (list#each code.nat expected+)
                          (/.result (/.exactly times <code>.nat))
                          (match actual
                                 (# (list.equivalence n.equivalence) =
                                    (list.first times expected+)
                                    actual)))
                      (|> (list#each code.nat expected+)
                          (/.result (/.exactly (++ variadic) <code>.nat))
                          fails?)))
        (_.cover [/.at_least]
                 (and (|> (list#each code.nat expected+)
                          (/.result (/.at_least times <code>.nat))
                          (match actual
                                 (# (list.equivalence n.equivalence) =
                                    expected+
                                    actual)))
                      (|> (list#each code.nat expected+)
                          (/.result (/.at_least (++ variadic) <code>.nat))
                          fails?)))
        (_.cover [/.at_most]
                 (and (|> (list#each code.nat expected+)
                          (/.result (/.at_most times <code>.nat))
                          (match actual
                                 (# (list.equivalence n.equivalence) =
                                    (list.first times expected+)
                                    actual)))
                      (|> (list#each code.nat expected+)
                          (/.result (/.at_most (++ variadic) <code>.nat))
                          (match actual
                                 (# (list.equivalence n.equivalence) =
                                    expected+
                                    actual)))))
        (_.cover [/.between]
                 (and (|> (list#each code.nat expected+)
                          (/.result (/.between times (n.- times variadic) <code>.nat))
                          (match actual
                                 (# (list.equivalence n.equivalence) =
                                    expected+
                                    actual)))
                      (|> (list#each code.nat (list.first times expected+))
                          (/.result (/.between times (n.- times variadic) <code>.nat))
                          (match actual
                                 (# (list.equivalence n.equivalence) =
                                    (list.first times expected+)
                                    actual)))))
        (_.cover [/.separated_by]
                 (|> (list.interposed (code.text separator) (list#each code.nat expected+))
                     (/.result (/.separated_by (<code>.this! (code.text separator)) <code>.nat))
                     (match actual
                            (# (list.equivalence n.equivalence) =
                               expected+
                               actual))))
        (_.cover [/.remaining]
                 (|> (list#each code.nat expected+)
                     (/.result /.remaining)
                     (match actual
                            (# (list.equivalence code.equivalence) =
                               (list#each code.nat expected+)
                               actual))))
        (_.cover [/.else]
                 (and (|> (/.result (/.else wrong (# /.monad in expected)) (list))
                          (match actual (n.= expected actual)))
                      (|> (/.result (/.else expected (/.failure "yolo"))
                                    (list))
                          (match actual (n.= expected actual)))
                      ))
        )))

(def: combinators_2
  Test
  (do random.monad
    [expected random.nat
     even (random.only n.even? random.nat)
     odd (random.only n.odd? random.nat)
     .let [nat^ <code>.nat
           even^ (/.only n.even? <code>.nat)
           odd^ (/.only n.odd? <code>.nat)]]
    ($_ _.and
        (_.cover [/.rec]
                 (let [parser (/.rec (function (_ self)
                                       (/.either <code>.nat
                                                 (<code>.tuple self))))
                       level_0 (code.nat expected)
                       level_up (is (-> Code Code)
                                    (|>> list code.tuple))]
                   (and (|> (list level_0)
                            (/.result parser)
                            (match actual (n.= expected actual)))
                        (|> (list (level_up level_0))
                            (/.result parser)
                            (match actual (n.= expected actual)))
                        (|> (list (level_up (level_up level_0)))
                            (/.result parser)
                            (match actual (n.= expected actual))))))
        (_.cover [/.after]
                 (and (|> (/.result (/.after even^ <code>.nat)
                                    (list (code.nat even) (code.nat expected)))
                          (match actual (n.= expected actual)))
                      (|> (/.result (/.after even^ <code>.nat)
                                    (list (code.nat odd) (code.nat expected)))
                          fails?)))
        (_.cover [/.before]
                 (and (|> (/.result (/.before even^ <code>.nat)
                                    (list (code.nat expected) (code.nat even)))
                          (match actual (n.= expected actual)))
                      (|> (/.result (/.before even^ <code>.nat)
                                    (list (code.nat expected) (code.nat odd)))
                          fails?)))
        (_.cover [/.parses?]
                 (and (|> (/.result (/.parses? even^)
                                    (list (code.nat even)))
                          (match verdict verdict))
                      (|> (/.result (/.parses? even^)
                                    (list (code.nat odd)))
                          (match verdict (not verdict)))))
        (_.cover [/.parses]
                 (and (|> (/.result (/.parses even^)
                                    (list (code.nat even)))
                          (match [] true))
                      (|> (/.result (/.parses even^)
                                    (list (code.nat odd)))
                          fails?)))
        (_.cover [/.speculative]
                 (let [happy_path!
                       (|> (/.result (/.and (/.speculative even^) nat^)
                                     (list (code.nat even)))
                           (match [speculation actual]
                                  (and (n.= speculation actual)
                                       (n.= even actual))))

                       sad_path!
                       (|> (/.result (/.and (/.speculative even^) nat^)
                                     (list (code.nat odd)))
                           fails?)]
                   (and happy_path!
                        sad_path!)))
        (_.cover [/.codec]
                 (|> (/.result (/.codec n.decimal <code>.text)
                               (list (code.text (%.nat expected))))
                     (match actual (n.= expected actual))))
        )))

(def: injection
  (Injection (All (_ a i) (Parser i a)))
  (# /.monad in))

(def: comparison
  (Comparison (All (_ a i) (Parser i a)))
  (function (_ == left right)
    (case [(/.result left []) (/.result right [])]
      [{try.#Success [_ left]} {try.#Success [_ right]}]
      (== left right)

      _
      false)))

(def: .public test
  Test
  (do random.monad
    [expected random.nat
     failure (random.ascii 1)
     assertion (random.ascii 1)]
    (<| (_.covering /._)
        (_.for [/.Parser])
        ($_ _.and
            (_.for [/.functor]
                   ($functor.spec ..injection ..comparison /.functor))
            (_.for [/.apply]
                   ($apply.spec ..injection ..comparison /.apply))
            (_.for [/.monad]
                   ($monad.spec ..injection ..comparison /.monad))

            (_.cover [/.result]
                     (|> (/.result (# /.monad in expected) (list))
                         (match actual (n.= expected actual))))
            (_.cover [/.failure]
                     (|> (list)
                         (/.result (/.failure failure))
                         (should_fail failure)))
            (_.cover [/.lifted]
                     (and (|> (list)
                              (/.result (/.lifted {try.#Success expected}))
                              (match actual (n.= expected actual)))
                          (|> (list)
                              (/.result (/.lifted {try.#Failure failure}))
                              (should_fail failure))))
            (_.cover [/.assertion]
                     (and (|> (list (code.bit #1) (code.int +123))
                              (/.result (/.assertion assertion #1))
                              (match [] true))
                          (|> (list (code.bit #1) (code.int +123))
                              (/.result (/.assertion assertion #0))
                              fails?)))
            ..combinators_0
            ..combinators_1
            ..combinators_2

            /analysis.test
            /binary.test
            /cli.test
            /code.test
            /environment.test
            /json.test
            /synthesis.test
            /text.test
            /tree.test
            /type.test
            /xml.test
            ))))
