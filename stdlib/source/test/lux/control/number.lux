(.module:
  [lux #*
   ["_" test (#+ Test)]
   [control
    [monad (#+ do)]]
   [data
    [text
     format]]
   [math
    ["r" random (#+ Random)]]]
  {1
   ["." / (#+ Number)
    [//
     [order (#+ Order)]]]})

(def: #export (spec (^open "_@.") (^open "_@.") gen-sample)
  (All [a] (-> (Order a) (Number a) (Random a) Test))
  (do r.monad
    [#let [non-zero (r.filter (function (_ sample)
                                (|> sample (_@+ sample) (_@= sample) not))
                              gen-sample)]
     parameter non-zero
     subject non-zero]
    (<| (_.context (%name (name-of /.Number)))
        ($_ _.and
            (_.test "Addition and subtraction are inverse functions."
                    (|> subject (_@+ parameter) (_@- parameter) (_@= subject)))
            (_.test "Multiplication and division are inverse functions."
                    (|> subject (_@* parameter) (_@/ parameter) (_@= subject)))
            (_.test "Modulus fills all the information division misses."
                    (let [modulus (_@% parameter subject)
                          multiple (_@- modulus subject)
                          times (_@/ modulus multiple)]
                      (|> parameter (_@* times) (_@+ modulus) (_@= subject))))
            (_.test "Negation flips the sign of a number and mimics subtraction."
                    (let [unsigned? (_@= (_@signum parameter)
                                         (_@signum (_@negate parameter)))]
                      (or unsigned?
                          (_@= (_@+ (_@negate parameter) subject)
                               (_@- parameter subject)))))
            (_.test "The absolute value is always positive."
                    (let [unsigned? (_@= (_@abs parameter)
                                         (_@abs (_@negate parameter)))]
                      (if unsigned?
                        (_@= subject (_@abs subject))
                        (_@>= subject (_@abs subject)))))
            ))))
