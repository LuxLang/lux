(.using
 [library
  [lux (.except)
   ["_" test (.only Test)]
   [abstract
    [monad (.only do)]
    [\\specification
     ["$[0]" functor (.only Injection Comparison)]
     ["$[0]" apply]
     ["$[0]" monad]
     ["$[0]" equivalence]]]
   [control
    ["[0]" pipe]
    ["[0]" io]]
   [data
    ["[0]" text (.open: "[1]#[0]" equivalence)]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" nat]]]]]
 [\\library
  ["[0]" / (.only Try)]])

(def injection
  (Injection Try)
  (|>> {/.#Success}))

(def comparison
  (Comparison Try)
  (function (_ ==)
    (at (/.equivalence ==) =)))

(def .public (attempt element)
  (All (_ a) (-> (Random a) (Random (Try a))))
  (all random.or
       (random.unicode 1)
       element))

(def .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Try])
      (do random.monad
        [expected random.nat
         alternative (|> random.nat (random.only (|>> (n.= expected) not)))
         error (random.unicode 1)
         .let [(open "io#[0]") io.monad]])
      (all _.and
           (_.for [/.equivalence]
                  ($equivalence.spec (/.equivalence n.equivalence) (..attempt random.nat)))
           (_.for [/.functor]
                  ($functor.spec ..injection ..comparison /.functor))
           (_.for [/.apply]
                  ($apply.spec ..injection ..comparison /.apply))
           (_.for [/.monad]
                  ($monad.spec ..injection ..comparison /.monad))

           (_.coverage [/.trusted]
             (n.= expected
                  (/.trusted {/.#Success expected})))
           (_.coverage [/.of_maybe]
             (case [(/.of_maybe {.#Some expected})
                    (/.of_maybe {.#None})]
               [{/.#Success actual} {/.#Failure _}]
               (n.= expected actual)

               _
               false))
           (_.coverage [/.maybe]
             (case [(/.maybe {/.#Success expected})
                    (/.maybe (is (/.Try Nat) {/.#Failure error}))]
               [{.#Some actual} {.#None}]
               (n.= expected actual)

               _
               false))
           (_.coverage [/.else]
             (and (n.= expected
                       (/.else alternative {/.#Success expected}))
                  (n.= alternative
                       (/.else alternative (is (Try Nat) {/.#Failure error})))))
           (_.coverage [/.with /.lifted]
             (let [lifted (/.lifted io.monad)]
               (|> (do (/.with io.monad)
                     [a (lifted (io#in expected))
                      b (in alternative)]
                     (in (n.+ a b)))
                   io.run!
                   (pipe.case
                     {/.#Success result}
                     (n.= (n.+ expected alternative)
                          result)

                     _
                     false))))
           )))
