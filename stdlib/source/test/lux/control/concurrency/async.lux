(.module:
  [library
   [lux #*
    ["_" test (#+ Test)]
    ["@" target]
    [abstract
     [monad (#+ do)]
     [\\specification
      ["$." functor (#+ Injection Comparison)]
      ["$." apply]
      ["$." monad]]]
    [control
     [pipe (#+ case>)]
     ["." io]]
    [time
     ["." instant]
     ["." duration]]
    [math
     ["." random]
     [number
      ["n" nat]
      ["i" int]
      ["." i64]]]]]
  [\\library
   ["." /
    [//
     ["." atom (#+ Atom)]]]])

(def: injection
  (Injection /.Async)
  /.resolved)

(def: comparison
  (Comparison /.Async)
  (function (_ == left right)
    (io.run
     (do io.monad
       [?left (/.poll left)
        ?right (/.poll right)]
       (in (case [?left ?right]
             [(#.Some left)
              (#.Some right)]
             (== left right)
             
             _
             false))))))

(def: delay
  (for {@.js
        (i64.left_shifted 4 1)}
       (i64.left_shifted 3 1)))

(def: #export test
  Test
  (<| (_.covering /._)
      (do {! random.monad}
        [to_wait (|> random.nat (\ ! map (|>> (n.% ..delay) (n.+ ..delay))))
         expected random.nat
         dummy random.nat
         #let [not_dummy (|> random.nat (random.only (|>> (n.= dummy) not)))]
         leftE not_dummy
         rightE not_dummy]
        ($_ _.and
            (_.for [/.functor]
                   ($functor.spec ..injection ..comparison /.functor))
            (_.for [/.apply]
                   ($apply.spec ..injection ..comparison /.apply))
            (_.for [/.monad]
                   ($monad.spec ..injection ..comparison /.monad))
            
            (in (do /.monad
                  [#let [[async resolver] (: [(/.Async Nat) (/.Resolver Nat)]
                                             (/.async []))]
                   resolved? (/.future (resolver expected))
                   actual async]
                  (_.cover' [/.Async /.Resolver /.async]
                            (and resolved?
                                 (n.= expected actual)))))
            (in (do /.monad
                  [actual (/.resolved expected)]
                  (_.cover' [/.resolved]
                            (n.= expected actual))))
            (in (do /.monad
                  [actual (/.future (io.io expected))]
                  (_.cover' [/.future]
                            (n.= expected actual))))
            (in (do /.monad
                  [pre (/.future instant.now)
                   actual (/.schedule to_wait (io.io expected))
                   post (/.future instant.now)]
                  (_.cover' [/.schedule]
                            (and (n.= expected actual)
                                 (i.>= (.int to_wait)
                                       (duration.to_millis (instant.span pre post)))))))
            (in (do /.monad
                  [pre (/.future instant.now)
                   _ (/.wait to_wait)
                   post (/.future instant.now)]
                  (_.cover' [/.wait]
                            (i.>= (.int to_wait)
                                  (duration.to_millis (instant.span pre post))))))
            (in (do /.monad
                  [[leftA rightA] (/.and (/.future (io.io leftE))
                                         (/.future (io.io rightE)))]
                  (_.cover' [/.and]
                            (n.= (n.+ leftE rightE)
                                 (n.+ leftA rightA)))))
            (in (do /.monad
                  [pre (/.future instant.now)
                   actual (/.delay to_wait expected)
                   post (/.future instant.now)]
                  (_.cover' [/.delay]
                            (and (n.= expected actual)
                                 (i.>= (.int to_wait)
                                       (duration.to_millis (instant.span pre post)))))))
            (in (do /.monad
                  [?left (/.or (in leftE)
                               (/.delay to_wait dummy))
                   ?right (/.or (/.delay to_wait dummy)
                                (in rightE))]
                  (_.cover' [/.or]
                            (case [?left ?right]
                              [(#.Left leftA) (#.Right rightA)]
                              (n.= (n.+ leftE rightE)
                                   (n.+ leftA rightA))

                              _
                              false))))
            (in (do /.monad
                  [leftA (/.either (in leftE)
                                   (/.delay to_wait dummy))
                   rightA (/.either (/.delay to_wait dummy)
                                    (in rightE))]
                  (_.cover' [/.either]
                            (n.= (n.+ leftE rightE)
                                 (n.+ leftA rightA)))))
            (in (do /.monad
                  [?actual (/.future (/.poll (/.resolved expected)))
                   #let [[async resolver] (: [(/.Async Nat) (/.Resolver Nat)]
                                             (/.async []))]
                   ?never (/.future (/.poll async))]
                  (_.cover' [/.poll]
                            (case [?actual ?never]
                              [(#.Some actual) #.None]
                              (n.= expected actual)

                              _
                              false))))
            (in (do /.monad
                  [yep (/.future (/.resolved? (/.resolved expected)))
                   #let [[async resolver] (: [(/.Async Nat) (/.Resolver Nat)]
                                             (/.async []))]
                   nope (/.future (/.resolved? async))]
                  (_.cover' [/.resolved?]
                            (and yep
                                 (not nope)))))
            (in (do /.monad
                  [?none (/.time_out 0 (/.delay to_wait dummy))
                   ?actual (/.time_out to_wait (in expected))]
                  (_.cover' [/.time_out]
                            (case [?none ?actual]
                              [#.None (#.Some actual)]
                              (n.= expected actual)

                              _
                              false))))
            (in (do /.monad
                  [#let [box (: (Atom Nat)
                                (atom.atom dummy))]
                   _ (/.future (/.await (function (_ value)
                                          (atom.write value box))
                                        (/.resolved expected)))
                   actual (/.future (atom.read box))]
                  (_.cover' [/.await]
                            (n.= expected actual))))
            ))))
