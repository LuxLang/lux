(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    [abstract
     [monad {"+" [do]}]]
    [control
     ["[0]" io]]
    [time
     ["[0]" instant {"+" [Instant]}]
     ["[0]" duration]]
    [math
     ["[0]" random]
     [number
      ["n" nat]
      ["i" int]]]]]
  [\\library
   ["[0]" /
    [//
     ["[0]" atom {"+" [Atom]}]
     ["[0]" async]]]])

(def: .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [dummy random.nat
         expected random.nat
         delay (\ ! each (|>> (n.% 5) (n.+ 5))
                  random.nat)]
        ($_ _.and
            (_.cover [/.parallelism]
                     (n.> 0 /.parallelism))
            (in (do async.monad
                  [reference_time (async.future instant.now)
                   .let [box (atom.atom [reference_time dummy])]
                   _ (async.future
                      (/.schedule! delay (do io.monad
                                           [execution_time instant.now]
                                           (atom.write! [execution_time expected] box))))
                   _ (async.delay (n.* 2 delay))
                   [execution_time actual] (async.future (atom.read! box))]
                  (_.cover' [/.schedule!]
                            (let [expected_delay!
                                  (i.>= (.int delay)
                                        (duration.millis (instant.span reference_time execution_time)))

                                  correct_value!
                                  (n.= expected actual)]
                              (and expected_delay!
                                   correct_value!)))))
            ))))
