(.using
 [library
  [lux (.except)
   ["_" test (.only Test)]
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" io]]
   [time
    ["[0]" instant (.only Instant)]
    ["[0]" duration]]
   [math
    ["[0]" random]
    [number
     ["n" nat]
     ["i" int]]]]]
 [\\library
  ["[0]" / (.only)
   [//
    ["[0]" atom (.only Atom)]
    ["[0]" async]]]])

(def: .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [dummy random.nat
         expected random.nat
         delay (at ! each (|>> (n.% 5) (n.+ 5))
                   random.nat)]
        (all _.and
             (_.coverage [/.parallelism]
               (n.> 0 /.parallelism))
             (in (do async.monad
                   [reference_time (async.future instant.now)
                    .let [box (atom.atom [reference_time dummy])]
                    _ (async.future
                       (/.schedule! delay (do io.monad
                                            [execution_time instant.now]
                                            (atom.write! [execution_time expected] box))))
                    _ (async.delay (n.* 2 delay))
                    [execution_time actual] (async.future (atom.read! box))]
                   (_.coverage' [/.schedule!]
                     (let [expected_delay!
                           (i.>= (.int delay)
                                 (duration.millis (instant.span reference_time execution_time)))

                           correct_value!
                           (n.= expected actual)]
                       (and expected_delay!
                            correct_value!)))))
             ))))
