(.module:
  [lux #*
   ["_" test (#+ Test)]
   [abstract
    [monad (#+ do)]]
   [control
    ["." io]]
   [data
    [number
     ["n" nat]
     ["i" int]]]
   [time
    ["." instant (#+ Instant)]
    ["." duration]]
   [math
    ["." random]]]
  {1
   ["." /
    [//
     ["." atom (#+ Atom)]
     ["." promise]]]})

(def: #export test
  Test
  (<| (_.covering /._)
      (do {! random.monad}
        [dummy random.nat
         expected random.nat
         delay (\ ! map (|>> (n.% 5) (n.+ 5))
                  random.nat)]
        ($_ _.and
            (_.cover [/.parallelism]
                     (n.> 0 /.parallelism))
            (wrap (do promise.monad
                    [reference-time (promise.future instant.now)
                     #let [box (atom.atom [reference-time dummy])]
                     _ (promise.future
                        (/.schedule delay (do io.monad
                                            [execution-time instant.now]
                                            (atom.write [execution-time expected] box))))
                     _ (promise.wait (n.* 2 delay))
                     [execution-time actual] (promise.future (atom.read box))]
                    (_.cover' [/.schedule]
                              (let [expected-delay!
                                    (i.>= (.int delay)
                                          (duration.to-millis (instant.span reference-time execution-time)))

                                    correct-value!
                                    (n.= expected actual)]
                                (and expected-delay!
                                     correct-value!)))))
            ))))
