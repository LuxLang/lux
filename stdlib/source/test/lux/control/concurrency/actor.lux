(.using
 [library
  [lux (.except)
   ["_" test (.only Test)]
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" try (.only Try)]
    ["[0]" exception (.only exception:)]
    ["[0]" io (.only IO io)]]
   [data
    [text
     ["%" format (.only format)]]
    [collection
     ["[0]" list]
     ["[0]" sequence (.only Sequence)]]]
   [math
    ["[0]" random]
    [number
     ["n" nat]]]]]
 [\\library
  ["[0]" / (.only actor: message)
   [//
    ["[0]" atom (.only Atom)]
    ["[0]" async (.only Async Resolver) (.open: "[1]#[0]" monad)]
    ["[0]" frp]]]])

(exception: got_wrecked)

(actor: counter
  Nat

  ((on_mail message state self)
   (message state self))

  (def: count!
    (message (_ [increment Nat] state self)
      Nat
      (let [state' (n.+ increment state)]
        (async#in {try.#Success [state' state']}))))
  )

(def: (mailed? outcome)
  (-> (Try Any) Bit)
  (case outcome
    {try.#Success _} true
    {try.#Failure _} false))

(def: .public test
  Test
  (do [! random.monad]
    [initial_state random.nat
     .let [as_mail (is (All (_ a) (-> (-> a a) (/.Mail a)))
                       (function (_ transform)
                         (function (_ state actor)
                           (|> state transform {try.#Success} async#in))))
           ++! (is (/.Mail Nat) (as_mail ++))
           --! (is (/.Mail Nat) (as_mail --))]]
    (<| (_.covering /._)
        (_.for [/.Actor])
        (all _.and
             (_.coverage [/.alive?]
               (io.run! (do io.monad
                          [actor (/.spawn! /.default 0)]
                          (/.alive? actor))))
             
             (_.coverage [/.poison!]
               (let [poisoned_actors_die!
                     (io.run! (do io.monad
                                [actor (/.spawn! /.default 0)
                                 poisoned? (/.poison! actor)
                                 alive? (/.alive? actor)]
                                (in (and (..mailed? poisoned?)
                                         (not alive?)))))

                     cannot_poison_more_than_once!
                     (io.run! (do io.monad
                                [actor (/.spawn! /.default 0)
                                 first_time? (/.poison! actor)
                                 second_time? (/.poison! actor)]
                                (in (and (..mailed? first_time?)
                                         (not (..mailed? second_time?))))))]
                 (and poisoned_actors_die!
                      cannot_poison_more_than_once!)))

             (let [[read write] (is [(Async Text) (Resolver Text)]
                                    (async.async []))]
               (in (do async.monad
                     [_ (async.future (do io.monad
                                        [actor (/.spawn! (is (/.Behavior Any Any)
                                                             [/.#on_init (|>>)
                                                              /.#on_mail (function (_ message state self)
                                                                           (do [! async.monad]
                                                                             [outcome (message state self)]
                                                                             (case outcome
                                                                               {try.#Failure cause}
                                                                               (do !
                                                                                 [_ (async.future (write cause))]
                                                                                 (in outcome))
                                                                               
                                                                               {try.#Success _}
                                                                               (in outcome))))])
                                                         [])]
                                        (/.poison! actor)))
                      _ (async.delay 100)
                      result (async.future (async.value read))]
                     (_.coverage' [/.poisoned]
                       (case result
                         {.#Some error}
                         (exception.match? /.poisoned error)

                         {.#None}
                         false)))))

             (in (do async.monad
                   [sent? (async.future (do io.monad
                                          [actor (/.spawn! /.default 0)
                                           sent? (/.mail! ++! actor)]
                                          (in (..mailed? sent?))))]
                   (_.coverage' [/.Behavior /.Mail
                                 /.default /.spawn! /.mail!]
                     sent?)))

             (in (do async.monad
                   [result (async.future (do io.monad
                                           [counter (/.spawn! /.default 0)
                                            _ (/.poison! counter)]
                                           (/.mail! ++! counter)))]
                   (_.coverage' [/.dead]
                     (case result
                       {try.#Success outcome}
                       false

                       {try.#Failure error}
                       (exception.match? /.dead error)))))

             (let [die! (is (/.Mail Nat)
                            (function (_ state actor)
                              (async#in (exception.except ..got_wrecked []))))]
               (in (do async.monad
                     [result (async.future (do io.monad
                                             [actor (/.spawn! /.default initial_state)
                                              sent? (/.mail! die! actor)
                                              alive? (/.alive? actor)
                                              obituary (/.obituary' actor)]
                                             (in {try.#Success [actor sent? alive? obituary]})))]
                     (_.coverage' [/.Obituary /.obituary']
                       (case result
                         (pattern {try.#Success [actor sent? alive? {.#Some [error state (list single_pending_message)]}]})
                         (and (..mailed? sent?)
                              (not alive?)
                              (exception.match? ..got_wrecked error)
                              (n.= initial_state state)
                              (same? die! single_pending_message))

                         _
                         false)))))

             (in (do async.monad
                   [counter (async.future (/.spawn! ..counter 0))
                    result (do (try.with async.monad)
                             [output_1 (/.tell! (count! 1) counter)
                              output_2 (/.tell! (count! 1) counter)
                              output_3 (/.tell! (count! 1) counter)]
                             (in (and (n.= 1 output_1)
                                      (n.= 2 output_2)
                                      (n.= 3 output_3))))]
                   (_.coverage' [/.Message /.message /.actor: /.tell!]
                     (case result
                       {try.#Success outcome}
                       outcome

                       {try.#Failure error}
                       false))))

             (in (do async.monad
                   [verdict (async.future
                             (do io.monad
                               [anonymous (/.actor [Nat
                                                    initial_state]
                                                   ((on_mail message state self)
                                                    (message (++ state) self)))
                                sent/++? (/.mail! ++! anonymous)
                                sent/--? (/.mail! --! anonymous)
                                poisoned? (/.poison! anonymous)
                                obituary (/.obituary' anonymous)]
                               (in (and (..mailed? sent/++?)
                                        (..mailed? sent/--?)
                                        (..mailed? poisoned?)
                                        (case obituary
                                          (pattern {.#Some [error final_state (list poison_pill)]})
                                          (and (exception.match? /.poisoned error)
                                               (n.= (++ (++ initial_state))
                                                    final_state))
                                          
                                          _
                                          false)))))]
                   (_.coverage' [/.actor]
                     verdict)))
             
             (do !
               [num_events (at ! each (|>> (n.% 10) ++) random.nat)
                events (random.list num_events random.nat)
                num_observations (at ! each (n.% num_events) random.nat)
                .let [expected (list.first num_observations events)
                      sink (is (Atom (Sequence Nat))
                               (atom.atom sequence.empty))]]
               (in (do async.monad
                     [agent (async.future
                             (do [! io.monad]
                               [agent (/.actor [Nat 0])
                                _ (/.observe! (function (_ event stop)
                                                (function (_ events_seen self)
                                                  (async.future
                                                   (if (n.< num_observations events_seen)
                                                     (do !
                                                       [_ (atom.update! (sequence.suffix event) sink)]
                                                       (in {try.#Success (++ events_seen)}))
                                                     (do !
                                                       [_ stop]
                                                       (in {try.#Failure "YOLO"}))))))
                                              (frp.sequential 0 events)
                                              agent)]
                               (in agent)))
                      _ (/.obituary agent)
                      actual (async.future (atom.read! sink))]
                     (_.coverage' [/.Stop /.observe! /.obituary]
                       (at (list.equivalence n.equivalence) = expected (sequence.list actual))))))
             ))))
