(.module:
  [lux #*
   ["_" test (#+ Test)]
   [abstract
    [monad (#+ do)]
    {[0 #spec]
     [/
      ["$." functor (#+ Injection Comparison)]
      ["$." apply]
      ["$." monad]]}]
   [control
    [pipe (#+ case>)]
    ["." io]]
   [data
    [number
     ["n" nat]
     ["i" int]]]
   [time
    ["." instant]
    ["." duration]]
   [math
    ["." random]]]
  {1
   ["." /
    [//
     ["." atom (#+ Atom)]]]})

(def: injection
  (Injection /.Promise)
  /.resolved)

(def: comparison
  (Comparison /.Promise)
  (function (_ == left right)
    (io.run
     (do io.monad
       [?left (/.poll left)
        ?right (/.poll right)]
       (wrap (case [?left ?right]
               [(#.Some left)
                (#.Some right)]
               (== left right)
               
               _
               false))))))

(def: #export test
  Test
  (<| (_.covering /._)
      (do {! random.monad}
        [to-wait (|> random.nat (\ ! map (|>> (n.% 100) (n.max 10))))
         expected random.nat
         dummy random.nat
         #let [not-dummy (|> random.nat (random.filter (|>> (n.= dummy) not)))]
         leftE not-dummy
         rightE not-dummy]
        ($_ _.and
            (_.for [/.functor]
                   ($functor.spec ..injection ..comparison /.functor))
            (_.for [/.apply]
                   ($apply.spec ..injection ..comparison /.apply))
            (_.for [/.monad]
                   ($monad.spec ..injection ..comparison /.monad))
            
            (wrap (do /.monad
                    [#let [[promise resolver] (: [(/.Promise Nat) (/.Resolver Nat)]
                                                 (/.promise []))]
                     resolved? (/.future (resolver expected))
                     actual promise]
                    (_.cover' [/.Promise /.Resolver /.promise]
                              (and resolved?
                                   (n.= expected actual)))))
            (wrap (do /.monad
                    [actual (/.resolved expected)]
                    (_.cover' [/.resolved]
                              (n.= expected actual))))
            (wrap (do /.monad
                    [actual (/.future (io.io expected))]
                    (_.cover' [/.future]
                              (n.= expected actual))))
            (wrap (do /.monad
                    [pre (/.future instant.now)
                     actual (/.schedule to-wait (io.io expected))
                     post (/.future instant.now)]
                    (_.cover' [/.schedule]
                              (and (n.= expected actual)
                                   (i.>= (.int to-wait)
                                         (duration.to-millis (instant.span pre post)))))))
            (wrap (do /.monad
                    [pre (/.future instant.now)
                     _ (/.wait to-wait)
                     post (/.future instant.now)]
                    (_.cover' [/.wait]
                              (i.>= (.int to-wait)
                                    (duration.to-millis (instant.span pre post))))))
            (wrap (do /.monad
                    [[leftA rightA] (/.and (/.future (io.io leftE))
                                           (/.future (io.io rightE)))]
                    (_.cover' [/.and]
                              (n.= (n.+ leftE rightE)
                                   (n.+ leftA rightA)))))
            (wrap (do /.monad
                    [pre (/.future instant.now)
                     actual (/.delay to-wait expected)
                     post (/.future instant.now)]
                    (_.cover' [/.delay]
                              (and (n.= expected actual)
                                   (i.>= (.int to-wait)
                                         (duration.to-millis (instant.span pre post)))))))
            (wrap (do /.monad
                    [?left (/.or (/.delay 100 leftE)
                                 (/.delay 200 dummy))
                     ?right (/.or (/.delay 200 dummy)
                                  (/.delay 100 rightE))]
                    (_.cover' [/.or]
                              (case [?left ?right]
                                [(#.Left leftA) (#.Right rightA)]
                                (n.= (n.+ leftE rightE)
                                     (n.+ leftA rightA))

                                _
                                false))))
            (wrap (do /.monad
                    [leftA (/.either (/.delay 100 leftE)
                                     (/.delay 200 dummy))
                     rightA (/.either (/.delay 200 dummy)
                                      (/.delay 100 rightE))]
                    (_.cover' [/.either]
                              (n.= (n.+ leftE rightE)
                                   (n.+ leftA rightA)))))
            (wrap (do /.monad
                    [?actual (/.future (/.poll (/.resolved expected)))
                     #let [[promise resolver] (: [(/.Promise Nat) (/.Resolver Nat)]
                                                 (/.promise []))]
                     ?never (/.future (/.poll promise))]
                    (_.cover' [/.poll]
                              (case [?actual ?never]
                                [(#.Some actual) #.None]
                                (n.= expected actual)

                                _
                                false))))
            (wrap (do /.monad
                    [yep (/.future (/.resolved? (/.resolved expected)))
                     #let [[promise resolver] (: [(/.Promise Nat) (/.Resolver Nat)]
                                                 (/.promise []))]
                     nope (/.future (/.resolved? promise))]
                    (_.cover' [/.resolved?]
                              (and yep
                                   (not nope)))))
            (wrap (do /.monad
                    [?none (/.time-out 0 (/.delay to-wait dummy))
                     ?actual (/.time-out to-wait (wrap expected))]
                    (_.cover' [/.time-out]
                              (case [?none ?actual]
                                [#.None (#.Some actual)]
                                (n.= expected actual)

                                _
                                false))))
            (wrap (do /.monad
                    [#let [box (: (Atom Nat)
                                  (atom.atom dummy))]
                     _ (/.future (/.await (function (_ value)
                                            (atom.write value box))
                                          (/.resolved expected)))
                     actual (/.future (atom.read box))]
                    (_.cover' [/.await]
                              (n.= expected actual))))
            ))))
