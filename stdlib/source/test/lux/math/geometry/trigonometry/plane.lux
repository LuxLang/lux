... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except)
   ["[0]" ffi]
   [abstract
    [monad (.only do)]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["f" frac]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" /]])

(the margin_of_error
  +0.0000001)

(the (symmetry forward backward angle)
  (-> (-> /.Angle Frac) (-> Frac /.Angle) /.Angle Bit)
  (let [normal (|> angle forward backward)]
    (|> normal forward backward (f.approximately? ..margin_of_error normal))))

(the .public test
  Test
  (<| (_.covering /._)
      (all _.and
           (do [! random.monad]
             [.let [~= (f.approximately? ..margin_of_error)]
              angle (|> random.safe_frac (of ! each (f.* /.tau)))]
             (all _.and
                  (_.coverage [/.sin /.asin]
                    (..symmetry /.sin /.asin angle))
                  (_.coverage [/.cos /.acos]
                    (..symmetry /.cos /.acos angle))
                  (_.coverage [/.tan /.atan]
                    (..symmetry /.tan /.atan angle))
                  (_.coverage [/.tau]
                    (and (and (~= +0.0 (/.sin /.tau))
                              (~= +1.0 (/.cos /.tau)))
                         (and (~= +0.0 (/.sin (f./ +2.0 /.tau)))
                              (~= -1.0 (/.cos (f./ +2.0 /.tau))))
                         (and (~= +1.0 (/.sin (f./ +4.0 /.tau)))
                              (~= +0.0 (/.cos (f./ +4.0 /.tau))))
                         (and (~= -1.0 (/.sin (f.* +3.0 (f./ +4.0 /.tau))))
                              (~= +0.0 (/.cos (f.* +3.0 (f./ +4.0 /.tau)))))
                         (let [x2+y2 (f.+ (f.pow +2.0 (/.sin angle))
                                          (f.pow +2.0 (/.cos angle)))]
                           (~= +1.0 x2+y2))))
                  (_.coverage [/.pi]
                    (~= (f./ +2.0 /.tau)
                        /.pi))
                  ))
           (do [! random.monad]
             [x (of ! each (|>> (f.* +10.0) f.abs) random.safe_frac)
              y (of ! each (|>> (f.* +10.0) f.abs) random.safe_frac)]
             (_.coverage [/.hypotenuse]
               (let [h (/.hypotenuse x y)]
                 (and (f.>= x h)
                      (f.>= y h)))))
           (do [! random.monad]
             [.let [~= (f.approximately? ..margin_of_error)
                    tau/4 (f./ +4.0 /.tau)]
              x (of ! each (f.* tau/4) random.safe_frac)
              y (of ! each (f.* tau/4) random.safe_frac)]
             (_.coverage [/.atan_2]
               (let [expected (/.atan_2 x y)
                     actual (if (f.> +0.0 x)
                              (/.atan (f./ x y))
                              (if (f.< +0.0 y)
                                (f.- /.pi (/.atan (f./ x y)))
                                (f.+ /.pi (/.atan (f./ x y)))))]
                 (and (~= expected actual)
                      (~= tau/4 (/.atan_2 +0.0 (f.abs y)))
                      (~= (f.opposite tau/4) (/.atan_2 +0.0 (f.opposite (f.abs y))))
                      (f.not_a_number? (/.atan_2 +0.0 +0.0))))))
           )))
