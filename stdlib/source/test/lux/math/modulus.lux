(.using
  [library
   [lux "*"
    ["_" test {"+" Test}]
    ["[0]" meta]
    [abstract
     [monad {"+" do}]]
    [control
     ["[0]" try]
     ["[0]" exception]]
    [math
     ["[0]" random {"+" Random}]
     [number
      ["i" int]]]
    [macro
     [syntax {"+" syntax:}]
     ["[0]" code]]]]
  [\\library
   ["[0]" /]])

(syntax: (|divisor| [])
  (do meta.monad
    [divisor meta.seed]
    (in (list (code.int (case divisor
                          0 +1
                          _ (.int divisor)))))))

(def: .public (random range)
  (Ex (_ %) (-> Int (Random (/.Modulus %))))
  (|> random.int
      (# random.monad each (i.% range))
      (random.one (|>> /.modulus try.maybe))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Modulus])
      (do random.monad
        [divisor random.int
         modulus (..random +1,000,000)
         dividend random.int]
        ($_ _.and
            (_.cover [/.modulus /.divisor]
                     (case (/.modulus divisor)
                       {try.#Success modulus}
                       (i.= divisor (/.divisor modulus))
                       
                       {try.#Failure error}
                       (i.= +0 divisor)))
            (_.cover [/.zero_cannot_be_a_modulus]
                     (case (/.modulus +0)
                       {try.#Failure error}
                       (exception.match? /.zero_cannot_be_a_modulus error)

                       {try.#Success modulus}
                       false))
            (_.cover [/.literal]
                     (with_expansions [<divisor> (|divisor|)]
                       (i.= <divisor> (/.divisor (/.literal <divisor>)))))
            (_.cover [/.=]
                     (with_expansions [<divisor> (|divisor|)]
                       (/.= (/.literal <divisor>)
                            (/.literal <divisor>))))
            (_.cover [/.congruent?]
                     (and (/.congruent? modulus dividend dividend)
                          (or (not (/.congruent? modulus dividend (++ dividend)))
                              (i.= +1 (/.divisor modulus)))))
            ))))
