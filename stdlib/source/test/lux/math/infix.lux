(.using
  [library
   [lux "*"
    ["_" test {"+" Test}]
    [abstract
     [monad {"+" do}]]
    [data
     ["[0]" bit ("[1]#[0]" equivalence)]]
    [math
     ["[0]" random]
     [number
      ["n" nat]
      ["f" frac]]]]]
  [\\library
   ["[0]" /
    ["[0]" //]]])

(def: .public test
  Test
  (<| (_.covering /._)
      (do random.monad
        [subject random.nat
         parameter random.nat
         extra random.nat
         angle random.safe_frac
         factor random.nat]
        (_.cover [/.infix]
                 (let [constant_values!
                       (n.= subject
                            (/.infix subject))

                       unary_functions!
                       (f.= (//.sin angle)
                            (/.infix [//.sin angle]))

                       binary_functions!
                       (n.= (n.gcd parameter subject)
                            (/.infix [subject n.gcd parameter]))

                       multiple_binary_functions!
                       (n.= (n.* factor (n.gcd parameter subject))
                            (/.infix [subject n.gcd parameter n.* factor]))

                       function_call!
                       (n.= (n.gcd extra (n.* parameter subject))
                            (/.infix [(n.* parameter subject) n.gcd extra]))

                       non_numeric!
                       (bit#= (and (n.< parameter subject) (n.< extra parameter))
                              (/.infix [[subject n.< parameter] and [parameter n.< extra]]))]
                   (and constant_values!
                        unary_functions!
                        binary_functions!
                        multiple_binary_functions!
                        function_call!
                        non_numeric!
                        ))))))
