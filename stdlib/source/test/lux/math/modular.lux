(.module:
  [library
   [lux "*"
    ["_" test {"+" Test}]
    ["[0]" type ("[1]#[0]" equivalence)]
    [abstract
     [monad {"+" do}]
     ["[0]" predicate]
     [\\specification
      ["$[0]" equivalence]
      ["$[0]" order]
      ["$[0]" monoid]
      ["$[0]" codec]]]
    [control
     ["[0]" try]
     ["[0]" exception]]
    [data
     ["[0]" product]
     ["[0]" bit ("[1]#[0]" equivalence)]]
    [math
     ["[0]" random {"+" Random}]
     [number
      ["i" int]]]]]
  ["$[0]" // "_"
   ["[1]" modulus]]
  [\\library
   ["[0]" /
    ["/[1]" // "_"
     ["[1]" modulus]]]])

(def: .public (random modulus)
  (All (_ %) (-> (//.Modulus %) (Random (/.Mod %))))
  (# random.monad each
     (/.modular modulus)
     random.int))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Mod])
      (do random.monad
        [param##% ($//.random +1,000,000)
         param (..random param##%)

         subject##% (random.only (predicate.and (|>> //.divisor (i.> +2))
                                                (|>> (//.= param##%) not))
                                 ($//.random +1,000,000))
         subject (..random subject##%)
         another (..random subject##%)]
        (`` ($_ _.and
                (_.for [/.equivalence /.=]
                       ($equivalence.spec /.equivalence (..random subject##%)))
                (_.for [/.order /.<]
                       ($order.spec /.order (..random subject##%)))
                (~~ (template [<composite> <monoid>]
                      [(_.for [<monoid> <composite>]
                              ($monoid.spec /.equivalence (<monoid> subject##%) (..random subject##%)))]
                      
                      [/.+ /.addition]
                      [/.* /.multiplication]
                      ))
                (_.for [/.codec]
                       ($codec.spec /.equivalence (/.codec subject##%) (..random subject##%)))

                (_.cover [/.incorrect_modulus]
                         (case (|> param
                                   (# (/.codec param##%) encoded)
                                   (# (/.codec subject##%) decoded))
                           {try.#Failure error}
                           (exception.match? /.incorrect_modulus error)
                           
                           {try.#Success _}
                           false))
                (_.cover [/.modulus]
                         (and (type#= (:of (/.modulus subject))
                                      (:of (/.modulus subject)))
                              (not (type#= (:of (/.modulus subject))
                                           (:of (/.modulus param))))))
                (_.cover [/.modular /.value]
                         (/.= subject
                              (/.modular (/.modulus subject) (/.value subject))))
                (_.cover [/.>]
                         (bit#= (/.> another subject)
                                (/.< subject another)))
                (_.cover [/.<= /.>=]
                         (bit#= (/.<= another subject)
                                (/.>= subject another)))
                (_.cover [/.-]
                         (let [zero (/.modular (/.modulus subject) +0)]
                           (and (/.= zero
                                     (/.- subject subject))
                                (/.= subject
                                     (/.- zero subject)))))
                (_.cover [/.inverse]
                         (let [one (/.modular (/.modulus subject) +1)
                               co_prime? (i.co_prime? (//.divisor (/.modulus subject))
                                                      (/.value subject))]
                           (case (/.inverse subject)
                             {.#Some subject^-1}
                             (and co_prime?
                                  (|> subject
                                      (/.* subject^-1)
                                      (/.= one)))
                             
                             {.#None}
                             (not co_prime?))))
                (_.cover [/.adapter]
                         (<| (try.else false)
                             (do try.monad
                               [copy##% (//.modulus (//.divisor subject##%))
                                adapt (/.adapter subject##% copy##%)]
                               (in (|> subject
                                       /.value
                                       (/.modular copy##%)
                                       adapt
                                       (/.= subject))))))
                (_.cover [/.moduli_are_not_equal]
                         (case (/.adapter subject##% param##%)
                           {try.#Failure error}
                           (exception.match? /.moduli_are_not_equal error)
                           
                           {try.#Success _}
                           false))
                )))))
