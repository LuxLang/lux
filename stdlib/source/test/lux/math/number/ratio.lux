(.using
 [library
  [lux (.except)
   ["_" test (.only Test)]
   [abstract
    [monad (.only do)]
    [\\specification
     ["$[0]" equivalence]
     ["$[0]" order]
     ["$[0]" monoid]
     ["$[0]" codec]]]
   [control
    ["[0]" maybe (.open: "[1]#[0]" functor)]]
   [data
    ["[0]" bit (.open: "[1]#[0]" equivalence)]]
   [math
    ["[0]" random (.only Random)]]]]
 [\\library
  ["[0]" / (.only)
   [//
    ["n" nat (.open: "[1]#[0]" equivalence)]]]])

(def: part
  (Random Nat)
  (at random.monad each
      (|>> (n.% 1,000,000) (n.max 1))
      random.nat))

(def: .public random
  (Random /.Ratio)
  (do random.monad
    [numerator ..part
     denominator (random.only (|>> (n.= 0) not)
                              ..part)]
    (in (/.ratio numerator denominator))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Ratio])
      (`` (all _.and
               (_.for [/.equivalence /.=]
                      ($equivalence.spec /.equivalence ..random))
               (_.for [/.order /.<]
                      ($order.spec /.order ..random))
               (~~ (template [<composite> <monoid>]
                     [(_.for [<monoid> <composite>]
                             ($monoid.spec /.equivalence <monoid> ..random))]

                     [/.+ /.addition]
                     [/.* /.multiplication]
                     ))
               (_.for [/.codec]
                      ($codec.spec /.equivalence /.codec ..random))

               (do random.monad
                 [.let [(open "#[0]") /.equivalence]
                  denom/0 ..part
                  denom/1 ..part]
                 (_.coverage [/.ratio]
                   (#= (/.ratio 0 denom/0)
                       (/.ratio 0 denom/1))))
               (do random.monad
                 [numerator ..part
                  denominator (random.only (|>> (n#= 1) not)
                                           ..part)]
                 (_.coverage [/.nat]
                   (let [only_numerator!
                         (|> (/.ratio numerator)
                             /.nat
                             (maybe#each (n#= numerator))
                             (maybe.else false))

                         denominator_1!
                         (|> (/.ratio numerator 1)
                             /.nat
                             (maybe#each (n#= numerator))
                             (maybe.else false))

                         with_denominator!
                         (case (/.nat (/.ratio numerator denominator))
                           {.#Some factor}
                           (and (n.= 0 (n.% denominator numerator))
                                (n.= numerator (n.* factor denominator)))
                           
                           {.#None}
                           (not (n.= 0 (n.% denominator numerator))))]
                     (and only_numerator!
                          denominator_1!
                          with_denominator!))))
               (do random.monad
                 [sample ..random]
                 (all _.and
                      (_.coverage [/.-]
                        (and (/.= (/.ratio 0) (/.- sample sample))
                             (/.= sample (/.- (/.ratio 0) sample))))
                      (_.coverage [/./]
                        (and (/.= (/.ratio 1) (/./ sample sample))
                             (/.= sample (/./ (/.ratio 1) sample))))
                      (_.coverage [/.reciprocal]
                        (/.= (/.ratio 1)
                             (/.* sample (/.reciprocal sample))))
                      ))
               (do random.monad
                 [left (random.only (|>> (/.= (/.ratio 0)) not)
                                    ..random)
                  right ..random]
                 (_.coverage [/.%]
                   (let [rem (/.% left right)
                         div (|> right (/.- rem) (/./ left))]
                     (and (/.= right
                               (|> div (/.* left) (/.+ rem)))
                          (case (/.nat div)
                            {.#Some _} true
                            {.#None}   false)))))
               (do random.monad
                 [left ..random
                  right ..random]
                 (all _.and
                      (_.coverage [/.>]
                        (bit#= (/.> left right)
                               (/.< right left)))
                      (_.coverage [/.<= /.>=]
                        (bit#= (/.<= left right)
                               (/.>= right left)))
                      ))
               ))))
