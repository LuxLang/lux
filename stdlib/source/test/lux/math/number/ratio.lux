(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]
    [\\specification
     ["$[0]" equivalence]
     ["$[0]" order]
     ["$[0]" monoid]
     ["$[0]" codec]]]
   [control
    ["[0]" maybe ("[1]#[0]" functor)]]
   [data
    ["[0]" bit ("[1]#[0]" equivalence)]]
   [math
    ["[0]" random {"+" Random}]]]]
 [\\library
  ["[0]" /
   [//
    ["n" nat ("[1]#[0]" equivalence)]]]])

(def: part
  (Random Nat)
  (# random.monad each
     (|>> (n.% 1,000,000) (n.max 1))
     random.nat))

(def: .public random
  (Random /.Ratio)
  (do random.monad
    [numerator ..part
     denominator (random.only (|>> (n.= 0) not)
                              ..part)]
    (in (/.ratio numerator denominator))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Ratio])
      (`` (all _.and
               (_.for [/.equivalence /.=]
                      ($equivalence.spec /.equivalence ..random))
               (_.for [/.order /.<]
                      ($order.spec /.order ..random))
               (~~ (template [<composite> <monoid>]
                     [(_.for [<monoid> <composite>]
                             ($monoid.spec /.equivalence <monoid> ..random))]

                     [/.+ /.addition]
                     [/.* /.multiplication]
                     ))
               (_.for [/.codec]
                      ($codec.spec /.equivalence /.codec ..random))

               (do random.monad
                 [.let [(open "#[0]") /.equivalence]
                  denom/0 ..part
                  denom/1 ..part]
                 (_.cover [/.ratio]
                          (#= (/.ratio 0 denom/0)
                              (/.ratio 0 denom/1))))
               (do random.monad
                 [numerator ..part
                  denominator (random.only (|>> (n#= 1) not)
                                           ..part)]
                 (_.cover [/.nat]
                          (let [only_numerator!
                                (|> (/.ratio numerator)
                                    /.nat
                                    (maybe#each (n#= numerator))
                                    (maybe.else false))

                                denominator_1!
                                (|> (/.ratio numerator 1)
                                    /.nat
                                    (maybe#each (n#= numerator))
                                    (maybe.else false))

                                with_denominator!
                                (case (/.nat (/.ratio numerator denominator))
                                  {.#Some factor}
                                  (and (n.= 0 (n.% denominator numerator))
                                       (n.= numerator (n.* factor denominator)))
                                  
                                  {.#None}
                                  (not (n.= 0 (n.% denominator numerator))))]
                            (and only_numerator!
                                 denominator_1!
                                 with_denominator!))))
               (do random.monad
                 [sample ..random]
                 (all _.and
                      (_.cover [/.-]
                               (and (/.= (/.ratio 0) (/.- sample sample))
                                    (/.= sample (/.- (/.ratio 0) sample))))
                      (_.cover [/./]
                               (and (/.= (/.ratio 1) (/./ sample sample))
                                    (/.= sample (/./ (/.ratio 1) sample))))
                      (_.cover [/.reciprocal]
                               (/.= (/.ratio 1)
                                    (/.* sample (/.reciprocal sample))))
                      ))
               (do random.monad
                 [left (random.only (|>> (/.= (/.ratio 0)) not)
                                    ..random)
                  right ..random]
                 (_.cover [/.%]
                          (let [rem (/.% left right)
                                div (|> right (/.- rem) (/./ left))]
                            (and (/.= right
                                      (|> div (/.* left) (/.+ rem)))
                                 (case (/.nat div)
                                   {.#Some _} true
                                   {.#None}   false)))))
               (do random.monad
                 [left ..random
                  right ..random]
                 (all _.and
                      (_.cover [/.>]
                               (bit#= (/.> left right)
                                      (/.< right left)))
                      (_.cover [/.<= /.>=]
                               (bit#= (/.<= left right)
                                      (/.>= right left)))
                      ))
               ))))
