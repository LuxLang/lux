... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]]
   [data
    ["[0]" bit]
    ["[0]" text]
    [collection
     ["[0]" list]]]
   [function
    [predicate (.only Predicate)]]
   [math
    ["[0]" random]
    [number
     ["[0]" natural]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" /]])

(the number_as_text
  (-> /.Number
      Text)
  (|>> list.reversed
       (list.as_text (by natural.base_10 as))))

(the (subtraction_as_text it)
  (-> /.Subtraction
      Text)
  (text (number_as_text (its /.#value it))
        "-"
        (number_as_text (its /.#offset it))))

(the .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [bit_0 random.bit
         bit_1 random.bit
         bit_2 random.bit
         .let [[random_0 random_1 random_2] (if bit_0
                                                (if bit_1
                                                    (if bit_2
                                                        [(/.random 1) (/.random 2) (/.random 3)]
                                                        [(/.random 1) (/.random 3) (/.random 2)])
                                                    (if bit_2
                                                        [(/.random 2) (/.random 1) (/.random 3)]
                                                        [(/.random 2) (/.random 3) (/.random 1)]))
                                                (if bit_1
                                                    [(/.random 3) (/.random 1) (/.random 2)]
                                                    [(/.random 3) (/.random 2) (/.random 1)]))]
         origin random_0
         other random_1
         it random_2

         it_0 (/.random 3)
         it_1 (/.random 3)
         it_2 (/.random 3)

         exponent_0 (by ! each (natural.% 200) random.natural)
         exponent_1 (by ! each (natural.% 200) random.natural)])
      (_.for [/.Number
              /.random])
      (all _.and
           (_.coverage [/.Natural]
             (same? /.Number /.Natural))
           (_.coverage [/.=]
             (let [reflection!
                   (/.= it it)

                   symmetry!
                   (bit.= (/.= origin it)
                          (/.= it origin))

                   transitivity!
                   (bit.= (and (/.= it_0 it_1)
                               (/.= it_1 it_2))
                          (/.= it_0 it_2))]
               (and reflection!
                    symmetry!
                    transitivity!)))
           (_.coverage [/.<]
             (let [anti_reflection!
                   (not (/.< it it))

                   anti_symmetry!
                   (or (/.= it origin)
                       (bit.= (not (/.< origin it))
                              (/.< it origin)))

                   ++ (all /.major origin other it)
                   -- (all /.minor origin other it)
                   not_extreme (is (Change /.Number)
                                   (function (_ it)
                                     (if (/.< ++ it)
                                         (if (/.> -- it)
                                             it
                                             /.zero)
                                         /.zero)))
                   +- (all /.+
                           (not_extreme origin)
                           (not_extreme other)
                           (not_extreme it))

                   transitivity!
                   (bit.= (and (/.< ++ +-)
                               (/.< +- --))
                          (/.< ++ --))]
               (and anti_reflection!
                    anti_symmetry!
                    transitivity!)))
           (_.coverage [/.>]
             (bit.= (/.< it origin)
                    (/.> origin it)))
           (_.coverage [/.<=]
             (bit.= (or (/.< origin it)
                        (/.<= origin it))
                    (/.<= origin it)))
           (_.coverage [/.>=]
             (bit.= (or (/.> origin it)
                        (/.>= origin it))
                    (/.>= origin it)))
           (_.coverage [/.major /.minor]
             (let [idempotency!
                   (and (/.= it (/.minor it it))
                        (/.= it (/.major it it)))

                   absorption!
                   (/.= /.zero (/.minor /.zero it))

                   identity!
                   (/.= it (/.major /.zero it))

                   commutativity!
                   (and (/.= (/.minor origin it)
                             (/.minor it origin))
                        (/.= (/.major origin it)
                             (/.major it origin)))

                   relationship!
                   (and (/.< (/.major origin it)
                             (/.minor origin it))
                        (/.> (/.minor origin it)
                             (/.major origin it)))]
               (and idempotency!
                    
                    absorption!
                    identity!

                    commutativity!
                    
                    relationship!)))
           (_.coverage [/.+]
             (and (/.= (/.+ origin it)
                       (/.+ it origin))
                  (bit.= (/.= it (/.+ it it))
                         (/.= /.zero it))
                  (/.= (/.+ origin (/.+ other it))
                       (/.+ (/.+ origin other) it))))
           (_.coverage [/.*]
             (let [commutativity!
                   (/.= (/.* origin it)
                        (/.* it origin))

                   identity!
                   (bit.= (/.= it (/.* it it))
                          (/.= /.one it))

                   associativity!
                   (/.= (/.* origin (/.* other it))
                        (/.* (/.* origin other) it))]
               (and commutativity!
                    identity!
                    associativity!)))
           (_.coverage [/.zero]
             (and (/.= it
                       (/.+ /.zero it))
                  (/.= /.zero
                       (/.* /.zero it))))
           (_.coverage [/.one]
             (/.= it
                  (/.* /.one it)))
           (_.coverage [/.Subtraction
                        /.#offset /.#value
                        
                        /.-]
             (let [balance!
                   (let [sub (/.- origin origin)]
                     (|> (/.- it it)
                         (its /.#offset)
                         (/.= /.zero)))

                   reconstitution!
                   (let [positive!
                         (let [major (/.major origin it)
                               minor (/.minor origin it)
                               sub (/.- minor major)]
                           (and (/.= /.zero (its /.#offset sub))
                                (/.= major (/.+ minor (its /.#value sub)))))

                         negative!
                         (let [major (/.major origin it)
                               minor (/.minor origin it)
                               sub (/.- major minor)]
                           (and (/.= /.zero (its /.#value sub))
                                (/.= major (/.+ minor (its /.#offset sub)))))]
                     (and positive!
                          negative!))]
               (and balance!
                    reconstitution!)))
           (_.coverage [/.exponential_2]
             (let [double (is (Change /.Number)
                              (function (_ it)
                                (/.+ it it)))]
               (and (/.= (|> it)
                         (/.* it (/.exponential_2 0)))
                    (/.= (|> it double)
                         (/.* it (/.exponential_2 1)))
                    (/.= (double (/.* it (/.exponential_2 exponent_0)))
                         (/.* it (/.exponential_2 (++ exponent_0))))
                    (let [e2^x (/.exponential_2 exponent_0)]
                      (and (|> e2^x
                               (/.* it)
                               (/./ it)
                               (/.= e2^x))
                           (|> it
                               (/.* e2^x)
                               (/./ e2^x)
                               (/.= it))))
                    (/.= (/.exponential_2 (natural.+ exponent_0 exponent_1))
                         (/.* (/.exponential_2 exponent_0)
                              (/.exponential_2 exponent_1))))))
           (_.coverage [/.logarithm_2]
             (and (|> (/.logarithm_2 /.zero)
                      (natural.= 0))
                  (|> (/.logarithm_2 /.one)
                      (natural.= 0))
                  (|> (/.logarithm_2 (/.+ /.one /.one))
                      (natural.= 1))
                  (natural.= (/.logarithm_2 (/.+ it it))
                             (++ (/.logarithm_2 it)))
                  (|> exponent_0
                      /.exponential_2
                      /.logarithm_2
                      (natural.= exponent_0))))
           (_.coverage [/./]
             (let [itself!
                   (/.= /.one (/./ it it))

                   one!
                   (/.= it (/./ /.one it))

                   of_zero!
                   (/.= /.zero (/./ it /.zero))

                   small!
                   (bit.= (/.< other it)
                          (/.= /.zero (/./ other it)))

                   large!
                   (bit.= (/.> other it)
                          (/.>= /.one (/./ other it)))

                   factor!
                   (and (|> it
                            (/.* other)
                            (/./ other)
                            (/.= it))
                        (|> other
                            (/.* it)
                            (/./ it)
                            (/.= other)))

                   exponential!
                   (let [e (/.exponential_2 exponent_0)]
                     (and (/.= e (/./ it (/.* e it)))
                          (/.= it (/./ e (/.* e it)))))

                   logarithm!
                   (let [e (/.exponential_2 exponent_0)]
                     (natural.= (natural.+ (/.logarithm_2 e)
                                           (/.logarithm_2 it))
                                (/.logarithm_2 (/.* e it))))]
               (and itself!
                    one!
                    of_zero!
                    small!
                    large!
                    factor!
                    exponential!
                    logarithm!)))
           (_.coverage [/.division_by_zero]
             (when (try (/./ /.zero it))
               {.#Left error}
               (text.contains? /.division_by_zero error)

               else
               false))
           (_.coverage [/.%]
             (let [itself!
                   (/.= /.zero (/.% it it))

                   no_room!
                   (/.= /.zero (/.% /.one it))

                   factor!
                   (and (/.= /.zero (/.% it (/.* other it)))
                        (/.= /.zero (/.% other (/.* other it))))

                   reconstitution!
                   (|> it
                       (/./ other)
                       (/.* other)
                       (/.+ (/.% other it))
                       (/.= it))]
               (and itself!
                    no_room!
                    factor!
                    reconstitution!)))
           )))
