... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]
    ["[0]" format
     ["[1]T" \\test]]
    ["[0]" equivalence
     ["[1]T" \\test]]
    ["[0]" order
     ["[1]T" \\test]]
    ["[0]" monoid
     ["[1]T" \\test]]]
   [control
    ["[0]" maybe (.use "[1]#[0]" functor)]]
   [error
    ["[0]" try (.use "[1]#[0]" functor)]]
   [data
    ["[0]" sum]
    ["[0]" text]
    [collection
     ["[0]" list (.use "[1]#[0]" mix)]]]
   [logic
    ["[0]" bit]]
   [math
    ["[0]" random (.only Random) (.use "[1]#[0]" functor)]]
   [macro
    ["[0]" template]]
   [meta
    ["[0]" static]]
   [test
    ["_" property (.only Test)]]
   [aspect
    ["[0]" case]]
   ["[0]" function]]]
 [\\library
  ["[0]" / (.only)
   [//
    ["n" natural]
    [//
     ["[0]" /64
      ["n[1]" natural]
      ["i" integer]
      ["d" decimal]]
     [//
      ["[0]" unit]]]]]])

(the unit
  Test
  (`` (all _.and
           (,, (template.with [,format <as> <of> ,unit]
                 [(let [threshold (|> (its unit.#factor ,unit)
                                      n.small
                                      (case.some /.natural)
                                      /.reciprocal)]
                    (all _.and
                         (_.for [,format]
                                (formatT.spec (/.approximately? threshold) ,format
                                              (/.random 2)))
                         (do [! random.monad]
                           [expected (/.random 2)
                            .let [change_of_scale!
                                  (|> expected
                                      <as>
                                      (by /.equivalence = expected)
                                      not)

                                  iso_morphism!
                                  (|> expected
                                      <as>
                                      <of>
                                      (by /.equivalence = expected))]]
                           (_.coverage [<as> <of>]
                             (and change_of_scale!
                                  iso_morphism!)))
                         ))]

                 [[/.degree /.as_degree /.of_degree unit.degree]
                  [/.gradian /.as_gradian /.of_gradian unit.gradian]
                  [/.per_cent /.as_per_cent /.of_per_cent unit.per_cent]
                  [/.per_mille /.as_per_mille /.of_per_mille unit.per_mille]
                  [/.per_myriad /.as_per_myriad /.of_per_myriad unit.per_myriad]]))
           )))

(the .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Fraction
              /.random])
      (do random.monad
        [expected (/.random 2)

         it_0 (/.random 2)
         it_1 (/.random 2)])
      (`` (all _.and
               (_.for [/.equivalence /.=]
                      (static.when (same? /.equivalence /.=)
                        (equivalenceT.spec /.equivalence (/.random 2))))
               (_.for [/.order /.<]
                      (static.when (same? (by /.order <) /.<)
                        (orderT.spec /.order (/.random 2))))
               (,, (template.with [<composite> <monoid>]
                     [(_.for [<monoid> <composite>]
                             (static.when (same? <composite> (by <monoid> composite))
                               (monoidT.spec /.equivalence <monoid> (/.random 2))))]

                     [[/.+ /.addition]
                      [/.x /.multiplication]

                      [/.minor /.minimum]
                      [/.major /.maximum]]))
               (_.for [/.text /.as_text]
                      (static.when (same? /.as_text
                                          (by /.text as))
                        (formatT.spec /.equivalence /.text (/.random 2))))

               (_.coverage [/.Number /.Q+]
                 (and (alias? /.Fraction /.Number)
                      (alias? /.Fraction /.Q+)))
               (_.coverage [/.approximately?]
                 (and (bit.= (/.approximately? /.zero it_0 it_1)
                             (/.= it_0 it_1))
                      (/.approximately? (/.major it_0 it_1) it_0 it_1)
                      (or (not (/.approximately? (/.minor it_0 it_1) it_0 it_1))
                          (/.= it_0 it_1))))
               (_.coverage [/.zero]
                 (and (/.= expected (/.+ /.zero expected))
                      (/.= expected (/.- /.zero expected))
                      
                      (/.= /.zero (/.x /.zero expected))
                      (/.= /.infinity (/./ /.zero expected))))
               (_.coverage [/.one]
                 (and (not (/.= expected (/.+ /.one expected)))
                      (/.= expected (/.x /.one expected))
                      (/.= expected (/./ /.one expected))))
               (_.coverage [/.infinity]
                 (and (/.= /.infinity (/./ /.zero /.one))

                      (/.= /.infinity (/.+ /.infinity expected))
                      (/.= /.infinity (/.- expected /.infinity))
                      (/.= /.zero (/.- /.infinity expected))
                      
                      (/.= /.infinity (/.x /.infinity expected))
                      (/.= /.zero (/./ /.infinity expected))))
               (_.coverage [/.indeterminate]
                 (and (/.= /.indeterminate expected)

                      (/.= (/.+ /.indeterminate expected)
                           (/.- /.indeterminate expected))
                      
                      (/.= (/.x /.indeterminate expected)
                           (/./ /.indeterminate expected))))
               (_.coverage [/.finite?]
                 (and (/.finite? expected)
                      (not (/.finite? /.infinity))))
               (_.coverage [/.determinate?]
                 (and (/.determinate? expected)
                      (not (/.determinate? /.indeterminate))))
               (_.coverage [/.whole /.partial]
                 (/.= expected
                      (/.+ (/.whole expected)
                           (/.partial expected))))
               (_.coverage [/.natural]
                 (|> (/.whole expected)
                     (case.if /.natural)
                     (sum.either (function.constant false)
                                 (|>> (case.some /.natural)
                                      (/.+ (/.partial expected))
                                      (/.= expected)))))
               (do random.monad
                 [_0 (n.random 2)
                  _1 (n.random 2)]
                 (_.coverage [/.new]
                   (and (/.= (/.new _0 n.zero)
                             (/.new _1 n.zero))
                        (/.= (/.new n.zero _0)
                             (/.new n.zero _1)))))
               (do [! random.monad]
                 [sample (/.random 2)
                  power (by ! each (i.% +10)
                            random.integer)]
                 (all _.and
                      (_.coverage [/.-]
                        (and (/.= /.zero
                                  (/.- sample sample))
                             (/.= sample
                                  (/.- /.zero sample))))
                      (_.coverage [/./]
                        (and (/.= /.one (/./ sample sample))
                             (/.= sample (/./ /.one sample))))
                      (_.coverage [/.reciprocal]
                        (/.= /.one
                             (/.x sample (/.reciprocal sample))))
                      (_.coverage [/.Exponent /.^]
                        (and (/.= /.one (/.^ +0 sample))
                             (/.= sample (/.^ +1 sample))
                             (/.= (/.reciprocal sample)
                                  (/.^ -1 sample))
                             (/.= (/.reciprocal (/.^ power sample))
                                  (/.^ (i.opposite power) sample))
                             (if (i.< +0 power)
                                 (/.= (list#mix /.x /.one (list.repeated (.natural (i.opposite power)) sample))
                                      (/.reciprocal (/.^ power sample)))
                                 (/.= (list#mix /.x /.one (list.repeated (.natural power) sample))
                                      (/.^ power sample)))))
                      ))
               (do random.monad
                 [left (random.only (|>> (/.= /.zero) not)
                                    (/.random 2))
                  right (/.random 2)]
                 (_.coverage [/.%]
                   (let [rem (/.% left right)
                         div (|> right
                                 (/.- rem)
                                 (/./ left))]
                     (and (/.= right
                               (|> div (/.x left) (/.+ rem)))
                          (when (case.if /.natural div)
                            {.#Right _}
                            true
                            
                            else
                            false)))))
               (do random.monad
                 [left (/.random 2)
                  right (/.random 2)]
                 (all _.and
                      (_.coverage [/.>]
                        (bit.= (/.> left right)
                               (/.< right left)))
                      (_.coverage [/.<= /.>=]
                        (bit.= (/.<= left right)
                               (/.>= right left)))
                      ))
               (do random.monad
                 [expected (/.random 2)
                  origin (/.random 2)]
                 (_.coverage [/.inversion]
                   (let [reciprocal_is!
                         (/.= (/.reciprocal expected)
                              (/.inversion /.one expected))

                         with_respect_to_self!
                         (/.= expected
                              (/.inversion expected expected))

                         is_involution!
                         (|> expected
                             (/.inversion origin)
                             (/.inversion origin)
                             (/.= expected))

                         double!
                         (/.= (/.x expected expected)
                              (/.inversion expected /.one))]
                     (and reciprocal_is!
                          with_respect_to_self!
                          is_involution!
                          double!))))

               ..unit
               ))))
