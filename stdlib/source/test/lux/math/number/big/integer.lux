... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]
    ["[0]" hash
     ["[1]T" \\test]]
    ["[0]" enum
     ["[1]T" \\test]]
    ["[0]" format
     ["[1]T" \\test]]
    ["[0]" equivalence
     ["[1]T" \\test]]
    ["[0]" order
     ["[1]T" \\test]]
    ["[0]" monoid
     ["[1]T" \\test]]]
   [data
    ["[0]" bit]
    [collection
     ["[0]" list (.use "[1]#[0]" mix)]]]
   [math
    ["[0]" random (.only Random)]
    ["[0]" arithmetic
     ["[1]T" \\test]]]
   [macro
    ["[0]" template]]
   [meta
    ["[0]" static]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" / (.only)
   [///
    [/64
     ["n" natural]]]]])

(the signature
  Test
  (`` (all _.and
           (_.for [/.equivalence /.=]
                  (static.when (same? /.equivalence /.=)
                    (equivalenceT.spec /.equivalence (/.random 2))))
           (_.for [/.hash]
                  (hashT.spec /.hash (/.random 2)))
           (_.for [/.order /.<]
                  (orderT.spec /.order (/.random 2)))
           (_.for [/.enum]
                  (enumT.spec /.enum (/.random 2)))
           (,, (template.with [<composite> <monoid>]
                 [(_.for [<monoid> <composite>]
                         (static.when (same? <composite> (by <monoid> composite))
                           (monoidT.spec /.equivalence <monoid> (/.random 2))))]
                 
                 [[/.+ /.addition]
                  [/.x /.multiplication]]))
           (,, (template.with [<format>]
                 [(_.for [<format>]
                         (formatT.spec /.equivalence <format> (/.random 2)))]

                 [[/.base_02]
                  [/.base_08]
                  [/.base_10]
                  [/.base_16]]))
           (_.for [/.arithmetic]
                  (arithmeticT.spec /.equivalence /.arithmetic (/.random 2)))
           )))

(the predicate
  Test
  (do [! random.monad]
    [sample (/.random 2)]
    (all _.and
         (_.coverage [/.negative?]
           (bit.= (/.negative? sample)
                  (/.< /.zero sample)))
         (_.coverage [/.positive?]
           (bit.= (/.positive? sample)
                  (/.> /.zero sample)))
         (_.coverage [/.zero?]
           (bit.= (/.zero? sample)
                  (/.= /.zero sample)))
         (_.coverage [/.even? /.odd?]
           (bit.= (/.even? sample)
                  (not (/.odd? sample))))
         )))

(the .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Number
              /.random])
      (all _.and
           (_.coverage [/.Integer /.Z]
             (and (alias? /.Integer /.Number)
                  (alias? /.Z /.Number)))
           (do [! random.monad]
             [sample (/.random 2)
              left (/.random 2)
              right (/.random 2)
              power (by ! each (n.% 10)
                        random.natural)]
             (all _.and
                  (_.coverage [/.-]
                    (and (/.= /.zero (/.- sample sample))
                         (/.= sample (/.- /.zero sample))
                         (/.= (/.opposite sample)
                              (/.- sample /.zero))))
                  (_.coverage [/./]
                    (and (/.= /.positive_one (/./ sample sample))
                         (/.= sample (/./ /.positive_one sample))))
                  (_.coverage [/.absolute]
                    (bit.= (/.> sample (/.absolute sample))
                           (/.negative? sample)))
                  (_.coverage [/.signum]
                    (/.= (/.absolute sample)
                         (/.x (/.signum sample) sample)))
                  (_.coverage [/.^]
                    (and (/.= /.positive_one (/.^ 0 sample))
                         (/.= sample (/.^ 1 sample))
                         (/.= (list#mix /.x /.positive_one (list.repeated power sample))
                              (/.^ power sample))))
                  ))
           (do random.monad
             [left (/.random 2)
              right (/.random 2)]
             (all _.and
                  (_.coverage [/.>]
                    (bit.= (/.> left right)
                           (/.< right left)))
                  (_.coverage [/.<= /.>=]
                    (bit.= (/.<= left right)
                           (/.>= right left)))
                  ))
           (do random.monad
             [left (random.only (|>> (/.= /.zero) not)
                                (/.random 2))
              right (/.random 2)]
             (all _.and
                  (_.coverage [/.%]
                    (let [rem (/.% left right)
                          div (|> right (/.- rem) (/./ left))]
                      (/.= right
                           (|> div (/.x left) (/.+ rem)))))
                  (_.coverage [/./%]
                    (let [[div rem] (/./% left right)]
                      (and (/.= div (/./ left right))
                           (/.= rem (/.% left right)))))
                  (_.coverage [/.mod]
                    (and (/.= (/.signum left)
                              (/.signum (/.mod left right)))
                         (/.= (/.signum right)
                              (/.signum (/.% left right)))
                         (if (/.= (/.signum left) (/.signum right))
                             (/.= (/.% left right)
                                  (/.mod left right))
                             (or (and (/.= /.zero (/.% left right))
                                      (/.= /.zero (/.mod left right)))
                                 (/.= (/.+ left (/.% left right))
                                      (/.mod left right))))))
                  ))
           (do [! random.monad]
             [.let [random (|> (/.random 2)
                               (by ! each (|>> (/.% (/.small +1,000))
                                               /.absolute))
                               (random.only (/.> /.zero)))]
              left random
              right random]
             (all _.and
                  (_.coverage [/.least_common_multiple /.lcm]
                    (and (let [least_common_multiple (/.least_common_multiple left right)]
                           (and (/.= /.zero (/.% left least_common_multiple))
                                (/.= /.zero (/.% right least_common_multiple))))
                         (alias? /.lcm
                                 /.least_common_multiple)))
                  (_.coverage [/.greatest_common_divisor /.gcd]
                    (and (let [greatest_common_divisor (/.greatest_common_divisor left right)]
                           (and (/.= /.zero (/.% greatest_common_divisor left))
                                (/.= /.zero (/.% greatest_common_divisor right))))
                         (alias? /.greatest_common_divisor
                                 /.gcd)))
                  (_.coverage [/.extended_greatest_common_divisor /.extended_gcd]
                    (let [[[left_k right_k] greatest_common_divisor] (/.extended_greatest_common_divisor left right)

                          same_greatest_common_divisor!
                          (/.= greatest_common_divisor
                               (/.greatest_common_divisor left right))
                          
                          bezout_identity!
                          (/.= greatest_common_divisor
                               (/.+ (/.x left_k left)
                                    (/.x right_k right)))]
                      (and same_greatest_common_divisor!
                           bezout_identity!
                           (alias? /.extended_greatest_common_divisor
                                   /.extended_gcd))))
                  (_.coverage [/.co_prime?]
                    (bit.= (/.= /.positive_one (/.greatest_common_divisor left right))
                           (/.co_prime? left right)))
                  (_.coverage [/.multiple?]
                    (and (/.multiple? left
                                      (/.least_common_multiple left right))
                         (/.multiple? right
                                      (/.least_common_multiple left right))))
                  (_.coverage [/.divisor?]
                    (and (/.divisor? left
                                     (/.greatest_common_divisor left right))
                         (/.divisor? right
                                     (/.greatest_common_divisor left right))))
                  ))
           (do random.monad
             [expected (/.random 2)]
             (_.coverage [/.opposite]
               (let [subtraction!
                     (/.= /.zero (/.+ (/.opposite expected) expected))

                     inverse!
                     (|> expected /.opposite /.opposite (/.= expected))]
                 (and subtraction!
                      inverse!))))

           ..predicate
           ..signature
           )))
