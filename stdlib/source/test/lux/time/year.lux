(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    [abstract
     [monad {"+" [do]}]
     [\\specification
      ["$[0]" equivalence]
      ["$[0]" order]
      ["$[0]" codec]]]
    [control
     ["[0]" try]
     ["[0]" exception]]
    [data
     ["[0]" bit ("[1]#[0]" equivalence)]
     [text
      ["%" format {"+" [format]}]]]
    [math
     ["[0]" random {"+" [Random]}]
     [number
      ["n" nat]
      ["i" int]]]]]
  [\\library
   ["[0]" /
    ["/[1]" //
     ["[1][0]" duration]
     ["[1][0]" instant]
     ["[1][0]" date]]]])

(def: .public random
  (Random /.Year)
  (random.one (|>> /.year try.maybe) random.int))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Year])
      ($_ _.and
          (_.for [/.equivalence]
                 ($equivalence.spec /.equivalence ..random))
          (_.for [/.order]
                 ($order.spec /.order ..random))
          (_.for [/.codec /.parser]
                 ($codec.spec /.equivalence /.codec ..random))
          
          (do random.monad
            [expected random.int]
            ($_ _.and
                (_.cover [/.year]
                         (bit#= (i.= +0 expected)
                                (case (/.year expected)
                                  {try.#Success _}
                                  false

                                  {try.#Failure _}
                                  true)))
                (_.cover [/.value]
                         (case (/.year expected)
                           {try.#Success year}
                           (i.= expected (/.value year))

                           {try.#Failure _}
                           (i.= +0 expected)))
                ))
          (_.cover [/.there_is_no_year_0]
                   (case (/.year +0)
                     {try.#Success _}
                     false

                     {try.#Failure error}
                     (exception.match? /.there_is_no_year_0 error)))
          (_.cover [/.days]
                   (n.= (.nat (//duration.ticks //duration.day //duration.normal_year))
                        /.days))
          (_.cover [/.epoch]
                   (# /.equivalence =
                      (//date.year (//instant.date //instant.epoch))
                      /.epoch))
          (_.for [/.Period]
                 (_.cover [/.leap /.century /.era]
                          (n.= /.leap (n./ /.century /.era))))
          (let [leap (try.trusted (/.year (.int /.leap)))
                century (try.trusted (/.year (.int /.century)))
                era (try.trusted (/.year (.int /.era)))]
            ($_ _.and
                (_.cover [/.leap?]
                         (and (/.leap? leap)
                              (not (/.leap? century))
                              (/.leap? era)))
                (_.cover [/.leaps]
                         (and (i.= +1 (/.leaps leap))
                              (i.= (.int (n./ /.leap /.century))
                                   (/.leaps century))
                              (i.= (++ (i.* +4 (-- (/.leaps century))))
                                   (/.leaps era))))
                ))
          )))
