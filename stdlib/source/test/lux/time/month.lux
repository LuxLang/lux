(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    [abstract
     [monad {"+" [do]}]
     ["[0]" predicate]
     [\\specification
      ["$[0]" equivalence]
      ["$[0]" hash]
      ["$[0]" order]
      ["$[0]" enum]
      ["$[0]" codec]]]
    [control
     ["[0]" try ("[1]#[0]" functor)]
     ["[0]" exception]]
    [data
     [collection
      ["[0]" set]
      ["[0]" list ("[1]#[0]" functor mix)]]]
    [math
     ["[0]" random {"+" [Random]}]
     [number
      ["n" nat]]]]]
  [\\library
   ["[0]" /
    [//
     ["[0]" duration]]]])

(def: .public random
  (Random /.Month)
  (let [december (/.number {/.#December})]
    (|> random.nat
        (# random.monad each (|>> (n.% december) ++))
        (random.one (|>> /.by_number try.maybe)))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Month])
      ($_ _.and
          (_.for [/.equivalence]
                 ($equivalence.spec /.equivalence ..random))
          (_.for [/.hash]
                 ($hash.spec /.hash ..random))
          (_.for [/.order]
                 ($order.spec /.order ..random))
          (_.for [/.enum]
                 ($enum.spec /.enum ..random))
          (_.for [/.codec]
                 ($codec.spec /.equivalence /.codec ..random))

          (do random.monad
            [expected ..random
             invalid (random.only (predicate.or (n.< (/.number {/.#January}))
                                                (n.> (/.number {/.#December})))
                                  random.nat)]
            ($_ _.and
                (_.cover [/.number /.by_number]
                         (|> expected
                             /.number
                             /.by_number
                             (try#each (# /.equivalence = expected))
                             (try.else false)))
                (_.cover [/.invalid_month]
                         (case (/.by_number invalid)
                           {try.#Failure error}
                           (exception.match? /.invalid_month error)
                           
                           {try.#Success _}
                           false))
                (_.cover [/.year]
                         (let [all (list.size /.year)
                               uniques (set.size (set.of_list /.hash /.year))]
                           (and (n.= (/.number {/.#December})
                                     all)
                                (n.= all
                                     uniques))))
                (_.cover [/.days]
                         (let [expected (.nat (duration.ticks duration.day duration.normal_year))]
                           (|> /.year
                               (list#each /.days)
                               (list#mix n.+ 0)
                               (n.= expected))))
                (_.cover [/.leap_year_days]
                         (let [expected (.nat (duration.ticks duration.day duration.leap_year))]
                           (|> /.year
                               (list#each /.leap_year_days)
                               (list#mix n.+ 0)
                               (n.= expected))))
                (do random.monad
                  [not_a_month (random.ascii/upper 1)]
                  (_.cover [/.not_a_month_of_the_year]
                           (case (# /.codec decoded not_a_month)
                             {try.#Failure error}
                             (exception.match? /.not_a_month_of_the_year error)
                             
                             {try.#Success _}
                             false)))
                )))))
