... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    [equality (.only Equality)]
    ["[0]" monad]]
   [control
    ["[0]" state]]
   [error
    ["[0]" try]]
   [logic
    ["[0]" bit]]
   [math
    ["[0]" random]]
   [macro
    ["[0]" template]]
   [test
    ["_" property (.only Test)]]
   [data
    ["[0]" product]
    ["[0]" binary (.only)
     ["[1]I" \\injection]]]]]
 [\\library
  ["[0]" / (.only)
   [//
    ["[0]" integer]
    ["[0]" float]
    ["[0]" long]
    ["[0]" double]
    ["[0]" utf8]
    [//
     [type
      ["[0]" box]
      ["[0]" descriptor (.only)
       ["[1]T" \\test]]]
     [encoding
      [name
       ["[0]" internal]]]]]]])

(the (= =)
  (for_any (_ it)
    (-> (Equality it)
        (Equality [it /.Pool])))
  (function (_ [reference_value reference_pool]
               [the_value the_pool])
    (let [equality_of_each_pool (/.= reference_pool
                                     the_pool)]
      (and (bit.= (= reference_value
                     the_value)
                  equality_of_each_pool)
           (bit.= equality_of_each_pool
                  (binary.= (binaryI.value /.as_binary reference_pool)
                            (binaryI.value /.as_binary the_pool)))))))

(the .public test
  Test
  (<| (_.covering /._)
      (monad.let [! random.monad]
        [])
      (all _.and
           (<| (_.for [/.Pool
                       /.equality /.= /.empty /.as_binary

                       /.Resource
                       /.functor /.monad])
               (`` (all _.and
                        (,, (template.with [,resource ,= ,random]
                              [(monad.let !
                                 [left_value ,random
                                  right_value ,random]
                                 (_.coverage [,resource]
                                   (when [((,resource left_value) /.empty)
                                          ((,resource right_value) /.empty)]
                                     [{try.:Success [left_pool _]}
                                      {try.:Success [right_pool _]}]
                                     (= ,= [left_value left_pool] [right_value right_pool])
                                     
                                     _
                                     false)))]

                              [[/.integer integer.= integer.random]
                               [/.float float.= float.random]
                               [/.long long.= long.random]
                               [/.double double.= double.random]
                               [/.utf8 utf8.= utf8.random]]))
                        (monad.let !
                          [left_value utf8.random
                           right_value utf8.random]
                          (_.coverage [/.string]
                            (when [((/.string left_value) /.empty)
                                   ((/.string right_value) /.empty)]
                              [{try.:Success [left_pool _]}
                               {try.:Success [right_pool _]}]
                              (= utf8.= [left_value left_pool] [right_value right_pool])
                              
                              _
                              false)))
                        (monad.let !
                          [left_value (by ! each internal.name box.random)
                           right_value (by ! each internal.name box.random)]
                          (_.coverage [/.class]
                            (when [((/.class left_value) /.empty)
                                   ((/.class right_value) /.empty)]
                              [{try.:Success [left_pool _]}
                               {try.:Success [right_pool _]}]
                              (= internal.= [left_value left_pool] [right_value right_pool])
                              
                              _
                              false)))
                        (monad.let !
                          [left_value descriptorT.random
                           right_value descriptorT.random]
                          (_.coverage [/.descriptor]
                            (when [((/.descriptor left_value) /.empty)
                                   ((/.descriptor right_value) /.empty)]
                              [{try.:Success [left_pool _]}
                               {try.:Success [right_pool _]}]
                              (= descriptor.= [left_value left_pool] [right_value right_pool])
                              
                              _
                              false)))
                        (<| (_.for [/.Member
                                    /.:name /.:descriptor])
                            (all _.and
                                 (monad.let !
                                   [left_name utf8.random
                                    right_name utf8.random

                                    left_descriptor descriptorT.random
                                    right_descriptor descriptorT.random]
                                   (_.coverage [/.name_and_type]
                                     (when [((/.name_and_type [left_name left_descriptor]) /.empty)
                                            ((/.name_and_type [right_name right_descriptor]) /.empty)]
                                       [{try.:Success [left_pool _]}
                                        {try.:Success [right_pool _]}]
                                       (= (product.equality utf8.= descriptor.=)
                                          [[left_name left_descriptor] left_pool]
                                          [[right_name right_descriptor] right_pool])
                                       
                                       _
                                       false)))
                                 (monad.let !
                                   [class box.random

                                    left_name utf8.random
                                    right_name utf8.random

                                    left_descriptor descriptorT.random
                                    right_descriptor descriptorT.random]
                                   (_.coverage [/.field]
                                     (when [((/.field class [left_name left_descriptor]) /.empty)
                                            ((/.field class [right_name right_descriptor]) /.empty)]
                                       [{try.:Success [left_pool _]}
                                        {try.:Success [right_pool _]}]
                                       (= (product.equality utf8.= descriptor.=)
                                          [[left_name left_descriptor] left_pool]
                                          [[right_name right_descriptor] right_pool])
                                       
                                       _
                                       false)))
                                 (,, (template.with [,resource]
                                       [(monad.let !
                                          [class box.random

                                           left_name utf8.random
                                           right_name utf8.random

                                           left_descriptor descriptorT.random
                                           right_descriptor descriptorT.random
                                           .let [left_descriptor (descriptor.method [(list) left_descriptor])
                                                 right_descriptor (descriptor.method [(list) right_descriptor])]]
                                          (_.coverage [,resource]
                                            (when [((,resource class [left_name left_descriptor]) /.empty)
                                                   ((,resource class [right_name right_descriptor]) /.empty)]
                                              [{try.:Success [left_pool _]}
                                               {try.:Success [right_pool _]}]
                                              (= (product.equality utf8.= descriptor.=)
                                                 [[left_name left_descriptor] left_pool]
                                                 [[right_name right_descriptor] right_pool])
                                              
                                              _
                                              false)))]

                                       [[/.method]
                                        [/.interface_method]]))
                                 ))
                        )))
           )))
