... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]
    ["[0]" equivalence
     ["[1]T" \\test]]
    ["[0]" order
     ["[1]T" \\test]]
    ["[0]" hash
     ["[1]T" \\test]]]
   [error
    ["[0]" try (.use "[1]#[0]" functor)]
    ["[0]" exception]]
   [data
    ["[0]" binary (.only)
     ["![1]" \\injection]]]
   [math
    ["[0]" random (.only Random) (.use "[1]#[0]" functor)]
    [number
     ["n" natural]]]
   [macro
    ["[0]" template]]
   [meta
    ["[0]" static]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" /]])

(template.with [,name ,type ,constructor ,maximum]
  [(the .public ,name
     (Random ,type)
     (|> random.natural
         (random#each (n.% (++ (/.value ,maximum))))
         (random.one ,constructor)))]

  [random_u1 /.U1 /.u1 /.maximum/1]
  )

(the .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Unsigned])
      (do [! random.monad]
        [expected_u1 ..random_u1])
      (all _.and
           (_.for [/.equivalence /.=]
                  (static.when (same? /.equivalence /.=)
                    (equivalenceT.spec /.equivalence ..random_u1)))
           (_.for [/.hash]
                  (hashT.spec /.hash ..random_u1))
           (_.for [/.order
                   /.< /.<= /.> /.>=
                   /.minor /.major]
                  (orderT.spec /.order ..random_u1))
           
           (<| (_.for [/.U1])
               (all _.and
                    (_.coverage [/.maximum/1]
                      (or (by /.order < /.maximum/1 expected_u1)
                          (/.= /.maximum/1 expected_u1)))
                    (_.coverage [/.u1 /.value]
                      (|> expected_u1
                          /.value
                          /.u1
                          (try#each (/.= expected_u1))
                          (try.else false)))
                    (_.coverage [/.-/1]
                      (let [zero (/.-/1 expected_u1 expected_u1)]
                        (|> zero
                            (try#each (|>> /.value
                                           (n.= 0)))
                            (try.else false))))
                    (_.coverage [/.+/1]
                      (<| (try.else false)
                          (do try.monad
                            [zero (/.-/1 expected_u1 expected_u1)
                             left (/.+/1 expected_u1 zero)
                             right (/.+/1 zero expected_u1)]
                            (in (/.= left right)))))
                    (_.coverage [/.major/1]
                      (and (/.= /.maximum/1 (/.major/1 /.maximum/1 expected_u1))
                           (/.= /.maximum/1 (/.major/1 expected_u1 /.maximum/1))
                           (/.= expected_u1 (/.major/1 expected_u1 expected_u1))))
                    ))

           (_.coverage [/.value_exceeds_the_maximum]
             (exception.failure? /.value_exceeds_the_maximum (/.+/1 /.maximum/1 /.maximum/1)))
           (_.coverage [/.subtraction_cannot_yield_negative_value]
             (or (exception.failure? /.subtraction_cannot_yield_negative_value (/.-/1 /.maximum/1 expected_u1))
                 (/.= /.maximum/1 expected_u1)))

           (_.coverage [/.bytes/1 /.as_binary/1]
             (n.= /.bytes/1 (binary.size (!binary.value /.as_binary/1 expected_u1))))
           )))
