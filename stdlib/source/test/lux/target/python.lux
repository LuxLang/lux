(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   ["[0]" ffi]
   ["[0]" static]
   [abstract
    [monad {"+" do}]
    ["[0]" predicate]
    [\\specification
     ["$[0]" equivalence]
     ["$[0]" hash]]]
   [control
    ["[0]" function]
    ["[0]" maybe ("[1]#[0]" functor)]
    ["[0]" try {"+" Try} ("[1]#[0]" functor)]]
   [data
    ["[0]" bit ("[1]#[0]" equivalence)]
    ["[0]" text ("[1]#[0]" equivalence)
     ["%" format {"+" format}]]
    [collection
     ["[0]" list ("[1]#[0]" functor)]]]
   [macro
    ["[0]" code]]
   [math
    ["[0]" random {"+" Random} ("[1]#[0]" monad)]
    [number
     ["n" nat]
     ["i" int]
     ["f" frac]
     ["[0]" i64]]]]]
 [\\library
  ["[0]" / ("[1]#[0]" equivalence)]])

(ffi.import: (eval [Text] "try" "?" Any))

(def: (expression ??? it)
  (-> (-> Any Bit) (/.Expression Any) Bit)
  (|> it
      /.code
      ..eval
      (try#each (|>> (maybe#each ???)
                     (maybe.else false)))
      (try.else false)))

(def: test|literal
  Test
  (do [! random.monad]
    [bool random.bit
     float random.frac
     int random.int
     string (random.ascii/upper 1)]
    ($_ _.and
        (_.cover [/.none]
                 (|> /.none
                     /.code
                     ..eval
                     (try#each (function (_ it)
                                 (case it
                                   {.#None} true
                                   {.#Some _} false)))
                     (try.else false)))
        (_.cover [/.bool]
                 (expression (|>> (as Bit) (bit#= bool))
                             (/.bool bool)))
        (_.cover [/.int]
                 (expression (|>> (as Int) (i.= int))
                             (/.int int)))
        ... (_.cover [/.long]
        ...          (expression (|>> (as Int) (i.= int))
        ...                      (/.long int)))
        (_.cover [/.float]
                 (expression (|>> (as Frac) (f.= float))
                             (/.float float)))
        (_.cover [/.string]
                 (expression (|>> (as Text) (text#= string))
                             (/.string string)))
        (_.cover [/.unicode]
                 (expression (|>> (as Text) (text#= string))
                             (/.unicode string)))
        )))

(def: test|bool
  Test
  (do [! random.monad]
    [left random.bit
     right random.bit]
    (`` ($_ _.and
            (~~ (template [</> <lux>]
                  [(_.cover [</>]
                            (let [expected (<lux> left right)]
                              (expression (|>> (as Bit) (bit#= expected))
                                          (</> (/.bool left) (/.bool right)))))]

                  [/.or .or]
                  [/.and .and]
                  ))
            (_.cover [/.not]
                     (expression (|>> (as Bit) (bit#= (not left)))
                                 (/.not (/.bool left))))
            ))))

(def: test|float
  Test
  (do [! random.monad]
    [parameter (random.only (|>> (f.= +0.0) not)
                            random.safe_frac)
     subject random.safe_frac]
    (`` ($_ _.and
            (~~ (template [</> <lux> <pre>]
                  [(_.cover [</>]
                            (let [expected (<lux> (<pre> parameter) (<pre> subject))]
                              (expression (|>> (as Frac) (f.= expected))
                                          (</> (/.float (<pre> parameter)) (/.float (<pre> subject))))))]

                  [/.+ f.+ |>]
                  [/.- f.- |>]
                  [/.* f.* |>]
                  [/./ f./ |>]
                  [/.% f.mod |>]
                  [/.** f.pow f.abs]
                  ))
            (~~ (template [</> <lux>]
                  [(_.cover [</>]
                            (let [expected (<lux> parameter subject)]
                              (expression (|>> (as Bit) (bit#= expected))
                                          (</> (/.float parameter) (/.float subject)))))]

                  [/.<  f.<]
                  [/.<= f.<=]
                  [/.>  f.>]
                  [/.>= f.>=]
                  [/.=  f.=]
                  ))
            (_.cover [/.float/1]
                     (expression (|>> (as Frac) (f.= subject))
                                 (/.float/1 (/.string (%.frac subject)))))
            (_.cover [/.repr/1]
                     (expression (|>> (as Text) (text#= (text.replaced "+" "" (%.frac subject))))
                                 (/.repr/1 (/.float subject))))
            ))))

(def: python_3?
  (/.Expression Any)
  (|> (/.__import__/1 (/.unicode "sys"))
      (/.the "version_info")
      (/.the "major")
      (/.= (/.int +3))))

(def: int_16
  (-> Int Int)
  (i64.and (-- (i64.left_shifted 15 1))))

(def: test|int
  Test
  (do [! random.monad]
    [left random.int
     right random.int

     i16 (# ! each ..int_16 random.int)
     shift (# ! each (n.% 16) random.nat)]
    (`` ($_ _.and
            (~~ (template [</> <lux>]
                  [(_.cover [</>]
                            (let [expected (<lux> left right)]
                              (expression (|>> (as Frac) f.int (i.= expected))
                                          (</> (/.int left) (/.int right)))))]

                  [/.bit_or i64.or]
                  [/.bit_xor i64.xor]
                  [/.bit_and i64.and]
                  ))
            (~~ (template [</> <lux>]
                  [(_.cover [</>]
                            (let [left (.int shift)
                                  right (i.* (.int shift) i16)
                                  expected (<lux> left right)]
                              (expression (|>> (as Int) (i.= expected))
                                          (</> (/.int left) (/.int right)))))]

                  [/.// i./]
                  ))
            (_.cover [/.opposite]
                     (expression (|>> (as Int) (i.= (i.* -1 left)))
                                 (/.opposite (/.int left))))
            (_.cover [/.bit_shl]
                     (let [expected (i64.left_shifted shift i16)]
                       (expression (|>> (as Frac) f.int (i.= expected))
                                   (/.bit_shl (/.int (.int shift))
                                              (/.int i16)))))
            (_.cover [/.bit_shr]
                     (let [expected (i.right_shifted shift i16)]
                       (expression (|>> (as Frac) f.int (i.= expected))
                                   (/.bit_shr (/.int (.int shift))
                                              (/.int i16)))))
            (_.cover [/.int/1]
                     (expression (|>> (as Int) (i.= left))
                                 (/.int/1 (/.string (%.int left)))))
            (_.cover [/.str/1]
                     (expression (|>> (as Text) (text#= (text.replaced "+" "" (%.int left))))
                                 (/.str/1 (/.int left))))
            (_.cover [/.long]
                     (or (expression (|>> (as Bit))
                                     ..python_3?)
                         (expression (|>> (as Int) (i.= left))
                                     (/.long left))))
            ))))

(def: test|text
  Test
  (do [! random.monad]
    [expected_code (# ! each (n.% 128) random.nat)
     .let [expected_char (text.of_char expected_code)]]
    ($_ _.and
        (_.cover [/.chr/1 /.ord/1
                  /.unichr/1 /.unicode/1]
                 (and (expression (|>> (as Int) .nat (n.= expected_code))
                                  (/.? python_3?
                                       (/.ord/1 (/.chr/1 (/.int (.int expected_code))))
                                       (/.unicode/1 (/.unichr/1 (/.int (.int expected_code))))))
                      (expression (|>> (as Text) (text#= expected_char))
                                  (/.? python_3?
                                       (/.chr/1 (/.ord/1 (/.string expected_char)))
                                       (/.unichr/1 (/.unicode/1 (/.string expected_char)))))))
        )))

(def: test|array
  Test
  (do [! random.monad]
    [size (# ! each (|>> (n.% 10) ++) random.nat)
     index (# ! each (n.% size) random.nat)
     items (random.list size random.safe_frac)
     .let [expected (|> items
                        (list.item index)
                        (maybe.else f.not_a_number))]
     from (# ! each (n.% size) random.nat)
     plus (# ! each (n.% (n.- from size)) random.nat)
     .let [slice_from|size (n.- from size)
           to (/.int (.int (n.+ plus from)))
           from (/.int (.int from))]]
    ($_ _.and
        (_.for [/.item]
               ($_ _.and
                   (_.cover [/.list]
                            (expression (|>> (as Frac) (f.= expected))
                                        (/.item (/.int (.int index))
                                                (/.list (list#each /.float items)))))
                   (_.cover [/.tuple]
                            (expression (|>> (as Frac) (f.= expected))
                                        (/.item (/.int (.int index))
                                                (/.tuple (list#each /.float items)))))))
        (_.cover [/.slice /.len/1]
                 (expression (|>> (as Int) (i.= (.int plus)))
                             (|> (/.list (list#each /.float items))
                                 (/.slice from to)
                                 /.len/1)))
        (_.cover [/.slice_from]
                 (expression (|>> (as Int) (i.= (.int slice_from|size)))
                             (|> (/.list (list#each /.float items))
                                 (/.slice_from from)
                                 /.len/1)))
        )))

(def: test|dict
  Test
  (do [! random.monad]
    [expected random.safe_frac
     field (random.ascii/upper 5)
     dummy (random.only (|>> (text#= field) not)
                        (random.ascii/upper 5))
     .let [field (/.string field)
           dummy (/.string dummy)]]
    ($_ _.and
        (_.cover [/.dict]
                 (expression (|>> (as Frac) (f.= expected))
                             (/.item field (/.dict (list [field (/.float expected)])))))
        (_.cover [/.in?]
                 (and (expression (|>> (as Bit) not)
                                  (/.in? (/.dict (list)) field))
                      (expression (|>> (as Bit))
                                  (/.in? (/.dict (list [field (/.float expected)])) field))))
        )))

(def: test|computation
  Test
  (do [! random.monad]
    [test random.bit
     then random.safe_frac
     else random.safe_frac

     bool random.bit
     float (random.only (|>> f.not_a_number? not) random.frac)
     string (random.ascii/upper 5)

     comment (random.ascii/upper 10)
     $arg/0 (# ! each /.var (random.ascii/lower 10))
     $arg/1 (# ! each /.var (random.ascii/lower 11))]
    ($_ _.and
        ..test|bool
        ..test|float
        ..test|int
        ..test|text
        ..test|array
        ..test|dict
        (_.cover [/.?]
                 (let [expected (if test then else)]
                   (expression (|>> (as Frac) (f.= expected))
                               (/.? (/.bool test)
                                    (/.float then)
                                    (/.float else)))))
        (_.cover [/.comment]
                 (expression (|>> (as Frac) (f.= then))
                             (/.comment comment
                               (/.float then))))
        (_.cover [/.__import__/1]
                 (expression (function.constant true)
                             (/.__import__/1 (/.string "math"))))
        (_.cover [/.do]
                 (expression (|>> (as Frac) (f.= (f.ceil float)))
                             (|> (/.__import__/1 (/.string "math"))
                                 (/.do "ceil" (list (/.float float))))))
        (_.cover [/.is]
                 (and (expression (|>> (as Bit))
                                  (/.apply/* (list (/.string (format string string)))
                                             (/.lambda (list $arg/0)
                                                       (/.is $arg/0 $arg/0))))
                      (expression (|>> (as Bit) not)
                                  (/.apply/* (list (/.string (format string string))
                                                   (/.string string))
                                             (/.lambda (list $arg/0 $arg/1)
                                                       (/.is $arg/0 (/.+ $arg/1 $arg/1)))))))
        )))

(def: test|function
  Test
  (do [! random.monad]
    [float/0 random.safe_frac
     float/1 random.safe_frac
     float/2 random.safe_frac
     $arg/0 (# ! each /.var (random.ascii/lower 10))
     $arg/1 (# ! each /.var (random.ascii/lower 11))
     $arg/2 (# ! each /.var (random.ascii/lower 12))]
    ($_ _.and
        (_.cover [/.lambda]
                 (expression (|>> (as Frac) (f.= float/0))
                             (/.apply/* (list)
                                        (/.lambda (list)
                                                  (/.float float/0)))))
        (_.cover [/.apply/*]
                 (expression (|>> (as Frac) (f.= ($_ f.+ float/0 float/1 float/2)))
                             (/.apply/* (list (/.float float/0) (/.float float/1) (/.float float/2))
                                        (/.lambda (list $arg/0 $arg/1 $arg/2)
                                                  ($_ /.+ $arg/0 $arg/1 $arg/2)))))
        )))

(def: test|var
  Test
  (do [! random.monad]
    [expected/0 random.safe_frac
     expected/1 random.safe_frac
     poly_choice (# ! each (n.% 2) random.nat)
     .let [keyword (|>> %.nat (format "k") /.string)
           keyword/0 (keyword 0)
           keyword/1 (keyword 1)
           keyword_choice (keyword poly_choice)]
     .let [expected/? (case poly_choice
                        0 expected/0
                        _ expected/1)]
     $var (# ! each (|>> %.nat (format "v") /.var) random.nat)
     $choice (# ! each (|>> %.nat (format "c") /.var) random.nat)]
    ($_ _.and
        (_.cover [/.Single /.SVar /.var]
                 (expression (|>> (as Frac) (f.= expected/0))
                             (/.apply/* (list (/.float expected/0))
                                        (/.lambda (list $var) $var))))
        (_.for [/.Poly /.PVar]
               ($_ _.and
                   (_.cover [/.poly]
                            (expression (|>> (as Frac) (f.= expected/?))
                                        (/.apply/* (list (/.int (.int poly_choice))
                                                         (/.float expected/0)
                                                         (/.float expected/1))
                                                   (/.lambda (list $choice (/.poly $var))
                                                             (/.item $choice $var)))))
                   (_.cover [/.splat_poly]
                            (expression (|>> (as Frac) (f.= expected/?))
                                        (/.apply/* (list (/.int (.int poly_choice))
                                                         (/.splat_poly
                                                          (/.list (list (/.float expected/0)
                                                                        (/.float expected/1)))))
                                                   (/.lambda (list $choice (/.poly $var))
                                                             (/.item $choice $var)))))
                   ))
        (_.for [/.Keyword /.KVar]
               ($_ _.and
                   (_.cover [/.keyword]
                            (expression (|>> (as Nat) (n.= 2))
                                        (/.apply/* (list keyword_choice
                                                         (/.splat_keyword
                                                          (/.dict (list [keyword/0 (/.float expected/0)]
                                                                        [keyword/1 (/.float expected/1)]))))
                                                   (/.lambda (list $choice (/.keyword $var))
                                                             (/.len/1 $var)))))
                   (_.cover [/.splat_keyword]
                            (expression (|>> (as Frac) (f.= expected/?))
                                        (/.apply/* (list keyword_choice
                                                         (/.splat_keyword
                                                          (/.dict (list [keyword/0 (/.float expected/0)]
                                                                        [keyword/1 (/.float expected/1)]))))
                                                   (/.lambda (list $choice (/.keyword $var))
                                                             (/.item $choice $var)))))
                   ))
        )))

(def: test|expression
  Test
  (do [! random.monad]
    [dummy random.safe_frac
     expected random.safe_frac]
    (`` ($_ _.and
            (_.for [/.Literal]
                   ..test|literal)
            (_.for [/.Computation]
                   ..test|computation)
            ..test|function
            (_.for [/.Var]
                   ..test|var)
            ))))

(ffi.import: Dict
  "[1]::[0]"
  (get [ffi.String] Any))

(ffi.import: (dict [] ..Dict))

(def: (statement it)
  (-> (-> /.SVar (/.Statement Any)) Any)
  (let [$output (static.random (|>> %.nat (format "output_") code.text)
                               random.nat)
        environment (..dict [])]
    (exec
      ("python exec" (/.code (it (/.var $output))) (as_expected environment))
      (Dict::get $output environment))))

(def: test|access
  Test
  (do [! random.monad]
    [$var/0 (# ! each (|>> %.nat (format "v0_") /.var) random.nat)
     expected/0 random.safe_frac
     dummy/0 random.safe_frac
     field (# ! each /.string (random.ascii/upper 1))]
    ($_ _.and
        (_.cover [/.item]
                 (`` (and (~~ (template [<seq>]
                                [(expression (|>> (as Frac) (f.= expected/0))
                                             (/.item (/.int +0)
                                                     (<seq> (list (/.float expected/0)))))]

                                [/.list]
                                [/.tuple]
                                ))
                          (|> (..statement
                               (function (_ $output)
                                 ($_ /.then
                                     (/.set (list $var/0) (/.list (list (/.float dummy/0))))
                                     (/.set (list (/.item (/.int +0) $var/0)) (/.float expected/0))
                                     (/.set (list $output) (/.item (/.int +0) $var/0)))))
                              (as Frac)
                              (f.= expected/0))

                          (expression (|>> (as Frac) (f.= expected/0))
                                      (/.item field (/.dict (list [field (/.float expected/0)]))))
                          (|> (..statement
                               (function (_ $output)
                                 ($_ /.then
                                     (/.set (list $var/0) (/.dict (list [field (/.float dummy/0)])))
                                     (/.set (list (/.item field $var/0)) (/.float expected/0))
                                     (/.set (list $output) (/.item field $var/0)))))
                              (as Frac)
                              (f.= expected/0)))))
        )))

(def: test|location
  Test
  (do [! random.monad]
    [$var/0 (# ! each (|>> %.nat (format "v0_") /.var) random.nat)
     $var/1 (# ! each (|>> %.nat (format "v1_") /.var) random.nat)
     $def (# ! each (|>> %.nat (format "def_") /.var) random.nat)
     expected/0 random.safe_frac
     expected/1 random.safe_frac
     dummy/0 random.safe_frac
     field/0 (# ! each /.string (random.ascii/upper 1))]
    ($_ _.and
        (_.cover [/.set]
                 (|> (..statement
                      (function (_ $output)
                        ($_ /.then
                            (/.set (list $var/0) (/.float expected/0))
                            (/.set (list $output) $var/0))))
                     (as Frac)
                     (f.= expected/0)))
        (_.cover [/.multi]
                 (`` (and (~~ (template [<var> <value>]
                                [(|> (..statement
                                      (function (_ $output)
                                        ($_ /.then
                                            (/.set (list $var/0 $var/1) (/.multi (list (/.float expected/0) (/.float expected/1))))
                                            (/.set (list $output) <var>))))
                                     (as Frac)
                                     (f.= <value>))]

                                [$var/0 expected/0]
                                [$var/1 expected/1]
                                )))))
        (_.cover [/.delete]
                 (and (|> (..statement
                           (function (_ $output)
                             ($_ /.then
                                 (/.set (list $var/0) (/.list (list (/.float dummy/0) (/.float expected/0))))
                                 (/.delete (/.item (/.int +0) $var/0))
                                 (/.set (list $output) (/.item (/.int +0) $var/0)))))
                          (as Frac)
                          (f.= expected/0))
                      (|> (..statement
                           (function (_ $output)
                             ($_ /.then
                                 (/.set (list $var/0) (/.list (list (/.float dummy/0) (/.float expected/0))))
                                 (/.delete (/.slice (/.int +0) (/.int +1) $var/0))
                                 (/.set (list $output) (/.item (/.int +0) $var/0)))))
                          (as Frac)
                          (f.= expected/0))
                      (|> (..statement
                           (function (_ $output)
                             ($_ /.then
                                 (/.set (list $var/0) (/.list (list (/.float dummy/0) (/.float dummy/0))))
                                 (/.delete (/.slice_from (/.int +0) $var/0))
                                 (/.statement (/.do "append" (list (/.float expected/0)) $var/0))
                                 (/.set (list $output) (/.item (/.int +0) $var/0)))))
                          (as Frac)
                          (f.= expected/0))
                      (|> (..statement
                           (function (_ $output)
                             ($_ /.then
                                 (/.set (list $var/0) (/.dict (list [field/0 (/.float dummy/0)])))
                                 (/.delete (/.item field/0 $var/0))
                                 (/.set (list $output) (/.in? $var/0 field/0)))))
                          (as Bit)
                          not)
                      (|> (..statement
                           (function (_ $output)
                             ($_ /.then
                                 (/.set (list $var/0) (/.float dummy/0))
                                 (/.delete $var/0)
                                 (/.set (list $output) (/.or (/.in? /.locals/0 (/.string (/.code $var/0)))
                                                             (/.in? /.globals/0 (/.string (/.code $var/0))))))))
                          (as Bit)
                          not)
                      ))
        (_.cover [/.globals/0]
                 (|> (..statement
                      (function (_ $output)
                        ($_ /.then
                            (/.def $def (list $var/0)
                                   (/.return (/.in? /.globals/0 (/.string (/.code $var/0)))))
                            (/.set (list $output) (/.and (/.not (/.in? /.globals/0 (/.string (/.code $var/0))))
                                                         (/.not (/.apply/* (list (/.float dummy/0)) $def))))
                            (/.set (list $var/0) (/.float dummy/0))
                            (/.set (list $output) (/.and $output
                                                         (/.in? /.globals/0 (/.string (/.code $var/0))))))))
                     (as Bit)))
        (_.cover [/.locals/0]
                 (|> (..statement
                      (function (_ $output)
                        ($_ /.then
                            (/.def $def (list $var/0)
                                   (/.return (/.in? /.locals/0 (/.string (/.code $var/0)))))
                            (/.set (list $output) (/.and (/.not (/.in? /.locals/0 (/.string (/.code $var/0))))
                                                         (/.apply/* (list (/.float dummy/0)) $def)))
                            (/.set (list $var/0) (/.float dummy/0))
                            (/.set (list $output) (/.and $output
                                                         (/.in? /.locals/0 (/.string (/.code $var/0))))))))
                     (as Bit)))
        (_.cover [/.import]
                 (|> (..statement
                      (function (_ $output)
                        ($_ /.then
                            (/.import "math")
                            (/.set (list $output) (/.in? /.globals/0 (/.string "math"))))))
                     (as Bit)))
        (_.for [/.Access]
               ..test|access)
        )))

(def: test|exception
  Test
  (do [! random.monad]
    [expected_error (random.ascii/upper 10)
     expected random.safe_frac
     dummy (random.only (|>> (f.= expected) not)
                        random.safe_frac)
     $ex (# ! each (|>> %.nat (format "ex_") /.var) random.nat)]
    ($_ _.and
        (_.cover [/.raise /.Exception/1]
                 (case (try (..statement
                             (function (_ $output)
                               ($_ /.then
                                   (/.raise (/.Exception/1 (/.string expected_error)))
                                   (/.set (list $output) (/.float dummy))))))
                   {try.#Failure actual_error}
                   (text#= expected_error actual_error)
                   
                   {try.#Success _}
                   false))
        (_.cover [/.try /.Except]
                 (and (|> (..statement
                           (function (_ $output)
                             (/.try ($_ /.then
                                        (/.raise (/.Exception/1 (/.string expected_error)))
                                        (/.set (list $output) (/.float dummy)))
                                    (list [/.#classes (list "Exception")
                                           /.#exception $ex
                                           /.#handler (/.set (list $output) (/.float expected))]))))
                          (as Frac)
                          (f.= expected))
                      (case (try (..statement
                                  (function (_ $output)
                                    (/.try ($_ /.then
                                               (/.raise (/.Exception/1 (/.string expected_error)))
                                               (/.set (list $output) (/.float dummy)))
                                           (list [/.#classes (list)
                                                  /.#exception $ex
                                                  /.#handler (/.set (list $output) (/.float expected))])))))
                        {try.#Failure actual_error}
                        (text#= expected_error actual_error)
                        
                        {try.#Success actual}
                        false)))
        )))

(def: test|loop
  Test
  (do [! random.monad]
    [base (# ! each (n.% 100) random.nat)
     factor (# ! each (|>> (n.% 10) ++) random.nat)
     extra (# ! each (|>> (n.% 10) ++) random.nat)
     .let [expected (n.* factor base)]
     $iteration (# ! each (|>> %.nat (format "iteration_") /.var) random.nat)
     $temp (# ! each (|>> %.nat (format "temp_") /.var) random.nat)]
    ($_ _.and
        (_.cover [/.while]
                 (and (|> (..statement
                           (function (_ $output)
                             ($_ /.then
                                 (/.set (list $output) (/.int +0))
                                 (/.set (list $iteration) (/.int +0))
                                 (/.while (/.< (/.int (.int factor)) $iteration)
                                          ($_ /.then
                                              (/.set (list $output) (/.+ (/.int (.int base))
                                                                         $output))
                                              (/.set (list $iteration) (/.+ (/.int +1)
                                                                            $iteration))
                                              )
                                          {.#None}))))
                          (as Nat)
                          (n.= expected))
                      (|> (..statement
                           (function (_ $output)
                             ($_ /.then
                                 (/.set (list $temp) (/.int +0))
                                 (/.set (list $iteration) (/.int +0))
                                 (/.while (/.< (/.int (.int factor)) $iteration)
                                          ($_ /.then
                                              (/.set (list $temp) (/.+ (/.int (.int base))
                                                                       $temp))
                                              (/.set (list $iteration) (/.+ (/.int +1)
                                                                            $iteration))
                                              )
                                          {.#Some (/.set (list $output) $temp)}))))
                          (as Nat)
                          (n.= expected))))
        (_.cover [/.for_in]
                 (|> (..statement
                      (function (_ $output)
                        ($_ /.then
                            (/.set (list $output) (/.int +0))
                            (/.for_in $iteration
                                      (/.list (list.repeated factor (/.int (.int base))))
                                      (/.set (list $output) (/.+ $iteration
                                                                 $output))))))
                     (as Nat)
                     (n.= expected)))
        (_.cover [/.pass]
                 (|> (..statement
                      (function (_ $output)
                        ($_ /.then
                            (/.set (list $output) (/.int +0))
                            (/.set (list $iteration) (/.int +0))
                            (/.while (/.< (/.int (.int (n.+ extra factor))) $iteration)
                                     ($_ /.then
                                         (/.set (list $iteration) (/.+ (/.int +1)
                                                                       $iteration))
                                         (/.if (/.> (/.int (.int extra)) $iteration)
                                           (/.set (list $output) (/.+ (/.int (.int base))
                                                                      $output))
                                           /.pass))
                                     {.#None}))))
                     (as Nat)
                     (n.= expected)))
        (_.cover [/.continue]
                 (|> (..statement
                      (function (_ $output)
                        ($_ /.then
                            (/.set (list $output) (/.int +0))
                            (/.set (list $iteration) (/.int +0))
                            (/.while (/.< (/.int (.int (n.+ extra factor))) $iteration)
                                     ($_ /.then
                                         (/.set (list $iteration) (/.+ (/.int +1)
                                                                       $iteration))
                                         (/.if (/.> (/.int (.int extra)) $iteration)
                                           (/.set (list $output) (/.+ (/.int (.int base))
                                                                      $output))
                                           /.continue))
                                     {.#None}))))
                     (as Nat)
                     (n.= expected)))
        (_.cover [/.break]
                 (|> (..statement
                      (function (_ $output)
                        ($_ /.then
                            (/.set (list $output) (/.int +0))
                            (/.set (list $iteration) (/.int +0))
                            (/.while (/.< (/.int (.int (n.+ extra factor))) $iteration)
                                     ($_ /.then
                                         (/.set (list $iteration) (/.+ (/.int +1)
                                                                       $iteration))
                                         (/.if (/.> (/.int (.int factor)) $iteration)
                                           /.break
                                           (/.set (list $output) (/.+ (/.int (.int base))
                                                                      $output))))
                                     {.#None}))))
                     (as Nat)
                     (n.= expected)))
        )))

(def: test|statement
  Test
  (do [! random.monad]
    [$def (# ! each (|>> %.nat (format "def_") /.var) random.nat)
     $input/0 (# ! each (|>> %.nat (format "input_") /.var) random.nat)
     expected/0 random.safe_frac
     test random.bit
     then random.safe_frac
     else random.safe_frac
     .let [expected/? (if test then else)]]
    ($_ _.and
        (_.cover [/.def /.return]
                 (|> (..statement
                      (function (_ $output)
                        ($_ /.then
                            (/.def $def (list $input/0)
                                   (/.return $input/0))
                            (/.set (list $output) (/.apply/* (list (/.float expected/0)) $def)))))
                     (as Frac)
                     (f.= expected/0)))
        (_.cover [/.if]
                 (|> (..statement
                      (function (_ $output)
                        ($_ /.then
                            (/.def $def (list)
                                   (/.if (/.bool test)
                                     (/.return (/.float then))
                                     (/.return (/.float else))))
                            (/.set (list $output) (/.apply/* (list) $def)))))
                     (as Frac)
                     (f.= expected/?)))
        (_.cover [/.when /.then]
                 (|> (..statement
                      (function (_ $output)
                        ($_ /.then
                            (/.def $def (list)
                                   ($_ /.then
                                       (/.when (/.bool test)
                                               (/.return (/.float then)))
                                       (/.return (/.float else))))
                            (/.set (list $output) (/.apply/* (list) $def)))))
                     (as Frac)
                     (f.= expected/?)))
        (_.cover [/.statement]
                 (|> (..statement
                      (function (_ $output)
                        ($_ /.then
                            (/.def $def (list)
                                   ($_ /.then
                                       (/.statement (/.+ (/.float expected/0) (/.float expected/0)))
                                       (/.return (/.float expected/0))))
                            (/.set (list $output) (/.apply/* (list) $def)))))
                     (as Frac)
                     (f.= expected/0)))
        (_.cover [/.exec]
                 (|> (..statement
                      (function (_ $output)
                        (/.exec {.#Some /.globals/0}
                          (/.string (/.code (/.set (list $output) (/.float expected/0)))))))
                     (as Frac)
                     (f.= expected/0)))
        ..test|exception
        (_.for [/.Location]
               ..test|location)
        (_.for [/.Loop]
               ..test|loop)
        )))

(def: random_expression
  (Random /.Literal)
  ($_ random.either
      (random#each /.bool random.bit)
      (random#each /.float random.frac)
      (random#each /.int random.int)
      (random#each /.string (random.ascii/lower 1))
      ))

(def: .public test
  Test
  (do [! random.monad]
    [expected ..random_expression]
    (<| (_.covering /._)
        (_.for [/.Code])
        ($_ _.and
            (_.for [/.equivalence]
                   ($equivalence.spec /.equivalence ..random_expression))
            (_.for [/.hash]
                   ($hash.spec /.hash ..random_expression))
            
            (_.cover [/.code /.manual]
                     (|> (/.manual (/.code expected))
                         (is /.Expression)
                         (/#= expected)))
            (_.for [/.Expression]
                   ..test|expression)
            (_.for [/.Statement]
                   ..test|statement)
            ))))
