... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   ["[0]" ffi]
   [abstract
    [monad (.only do)]
    ["[0]" hash
     ["[1]T" \\test]]
    ["[0]" equivalence
     ["[1]T" \\test]]]
   [control
    ["[0]" pipe]
    ["[0]" maybe (.use "[1]#[0]" functor)]]
   [error
    ["[0]" try (.only Try) (.use "[1]#[0]" functor)]]
   ["[0]" function]
   [data
    ["[0]" bit]
    ["[0]" text (.only \n)
     ["%" \\injection]]
    [collection
     ["[0]" stack (.use "[1]#[0]" functor)]]]
   [math
    ["[0]" random (.only Random) (.use "[1]#[0]" monad)]
    [number
     ["n" natural]
     ["i" integer]
     ["d" decimal]
     ["[0]" i64]]]
   [macro
    ["[0]" template]]
   [meta
    ["[0]" static]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" /]])

... http://www.lua.org/manual/5.3/manual.html#pdf-load
(ffi.import (load [Text] "?" (-> Any Any)))

(the (expression ??? it)
  (-> (-> Any Bit) /.Expression Bit)
  (|> it
      /.code
      (text "return ")
      ..load
      (maybe#each (|>> (function.on []) ???))
      (maybe.else false)))

(the test|literal
  Test
  (do [! random.monad]
    [boolean random.bit
     int random.integer
     float random.decimal
     string (random.upper_cased 5)]
    (all _.and
         (_.coverage [/.nil]
           (|> /.nil
               /.code
               ..load
               (pipe.when
                 {.#None} true
                 {.#Some _} false)))
         (_.coverage [/.boolean]
           (expression (|>> (as Bit) (bit.= boolean))
                       (/.boolean boolean)))
         (_.coverage [/.int]
           (expression (|>> (as Integer) (i.= int))
                       (/.int int)))
         (_.coverage [/.float]
           (expression (|>> (as Decimal) (d.= float))
                       (/.float float)))
         (_.coverage [/.string]
           (expression (|>> (as Text) (text.= string))
                       (/.string string)))
         )))

(the test|boolean
  Test
  (do [! random.monad]
    [left random.bit
     right random.bit]
    (`` (all _.and
             (,, (template.with [</> <lux>]
                   [(_.coverage [</>]
                      (let [expected (<lux> left right)]
                        (expression (|>> (as Bit) (bit.= expected))
                                    (</> (/.boolean left) (/.boolean right)))))]

                   [/.or .or]
                   [/.and .and]
                   ))
             (_.coverage [/.not]
               (expression (|>> (as Bit) (bit.= (not left)))
                           (/.not (/.boolean left))))
             ))))

(template.with [<bits>]
  [(`` (the (,, (template.name [int_ <bits>]))
         (Random Integer)
         (let [mask (|> 1 (i64.left_shifted (-- <bits>)) --)]
           (random#each (|>> (i64.and mask) .integer) random.natural))))]

  [16]
  [32]
  )

(the test|int
  Test
  (do [! random.monad]
    [left random.integer
     right random.integer
     shift (by ! each (n.% 65) random.natural)

     parameter (random.only (|>> (i.= +0) not)
                            random.integer)
     subject random.integer]
    (`` (all _.and
             (,, (template.with [</> <lux>]
                   [(_.coverage [</>]
                      (let [expected (<lux> left right)]
                        (expression (|>> (as Integer) (i.= expected))
                                    (</> (/.int left) (/.int right)))))]

                   [/.bit_or i64.or]
                   [/.bit_xor i64.xor]
                   [/.bit_and i64.and]
                   ))
             (_.coverage [/.opposite]
               (expression (|>> (as Integer) (i.= (i.- left +0)))
                           (/.opposite (/.int left))))
             (_.coverage [/.bit_shl]
               (let [expected (i64.left_shifted shift left)]
                 (expression (|>> (as Integer) (i.= expected))
                             (/.bit_shl (/.int (.integer shift))
                                        (/.int left)))))
             (_.coverage [/.bit_shr]
               (let [expected (i64.right_shifted shift left)]
                 (expression (|>> (as Integer) (i.= expected))
                             (/.bit_shr (/.int (.integer shift))
                                        (/.int left)))))
             (_.coverage [/.//]
               (let [expected (if (or (i.= (i.signum parameter) (i.signum subject))
                                      (i.= +0 (i.% parameter subject)))
                                (i./ parameter subject)
                                (-- (i./ parameter subject)))]
                 (expression (|>> (as Integer) (i.= expected))
                             (/.// (/.int parameter) (/.int subject)))))
             ))))

(the test|float
  Test
  (do [! random.monad]
    [parameter (random.only (|>> (d.= +0.0) not)
                            random.unit_decimal)
     subject random.unit_decimal]
    (`` (all _.and
             (,, (template.with [</> <lux> <pre>]
                   [(_.coverage [</>]
                      (let [expected (<lux> (<pre> parameter) (<pre> subject))]
                        (expression (|>> (as Decimal) (d.= expected))
                                    (</> (/.float (<pre> parameter)) (/.float (<pre> subject))))))]

                   [/.+ d.+ |>]
                   [/.- d.- |>]
                   [/.* d.* |>]
                   [/./ d./ |>]
                   [/.% d.mod |>]
                   [/.^ d.pow d.abs]
                   ))
             (,, (template.with [</> <lux>]
                   [(_.coverage [</>]
                      (let [expected (<lux> parameter subject)]
                        (expression (|>> (as Bit) (bit.= expected))
                                    (</> (/.float parameter) (/.float subject)))))]

                   [/.<  d.<]
                   [/.<= d.<=]
                   [/.>  d.>]
                   [/.>= d.>=]
                   [/.=  d.=]
                   ))
             ))))

(the test|string
  Test
  (do random.monad
    [left (random.lower_cased 8)
     right (random.lower_cased 8)
     .let [expected (text left right)]]
    (all _.and
         (_.coverage [/.concat]
           (expression (|>> (as Text) (text.= expected))
                       (|> (/.string left)
                           (/.concat (/.string right)))))
         )))

(the test|array
  Test
  (do [! random.monad]
    [size (by ! each (|>> (n.% 10) ++) random.natural)
     index (by ! each (n.% size) random.natural)
     items (random.stack size random.unit_decimal)
     .let [expected (|> items
                        (stack.item index)
                        maybe.trusted)]]
    (all _.and
         (_.coverage [/.array /.item]
           (and (expression (|>> (as Decimal) (d.= expected))
                            (/.item (/.int (.integer (++ index)))
                                    (/.array (stack#each /.float items))))
                (expression (|>> (as Bit))
                            (|> (/.array (stack#each /.float items))
                                (/.item (/.int (.integer (++ size))))
                                (/.= /.nil)))))
         (_.coverage [/.length]
           (expression (|>> (as Integer) (i.= (.integer size)))
                       (/.length (/.array (stack#each /.float items)))))
         )))

(the test|table
  Test
  (do [! random.monad]
    [expected random.unit_decimal
     dummy (random.only (|>> (d.= expected) not)
                        random.unit_decimal)

     size (by ! each (|>> (n.% 10) ++) random.natural)
     index (by ! each (n.% size) random.natural)
     items (random.stack size random.unit_decimal)

     $self (by ! each /.var (random.lower_cased 10))
     $table (by ! each /.var (random.lower_cased 11))
     $arg (by ! each /.var (random.lower_cased 12))
     field (random.upper_cased 5)
     non_field (random.only (|>> (text.= field) not)
                            (random.upper_cased 5))
     method (random.upper_cased 6)]
    (all _.and
         (_.coverage [/.table /.its]
           (and (expression (|>> (as Decimal) (d.= expected))
                            (/.its field (/.table (stack [field (/.float expected)]))))
                (expression (|>> (as Bit))
                            (|> (/.table (stack [field (/.float expected)]))
                                (/.its non_field)
                                (/.= /.nil)))))
         (_.coverage [/.do /.function]
           (expression (|>> (as Decimal) (d.= expected))
                       (|> (all /.then
                                (/.local/1 $table (/.table (stack [field (/.float expected)])))
                                (/.function (/.its method $table) (stack $self $arg)
                                  (/.if (/.= (/.float dummy) $arg)
                                    (/.return (/.its field $self))
                                    (/.return $arg)))
                                (/.return (/.do method (stack (/.float dummy)) $table)))
                           (/.closure (stack))
                           (/.apply (stack)))))
         )))

(the test|computation
  Test
  (do [! random.monad]
    [test random.bit
     then random.unit_decimal
     else random.unit_decimal

     boolean random.bit
     int random.integer
     float random.decimal
     string (random.upper_cased 5)

     comment (random.upper_cased 10)]
    (all _.and
         ..test|boolean
         ..test|int
         ..test|float
         ..test|string
         ..test|array
         ..test|table
         (_.coverage [/.type/1]
           (and (expression (|>> (as Text) (text.= "boolean"))
                            (/.type/1 (/.boolean boolean)))
                (expression (|>> (as Text) (text.= "number"))
                            (/.type/1 (/.int int)))
                (expression (|>> (as Text) (text.= "number"))
                            (/.type/1 (/.float float)))
                (expression (|>> (as Text) (text.= "string"))
                            (/.type/1 (/.string string)))
                (expression (|>> (as Text) (text.= "nil"))
                            (/.type/1 /.nil))
                (expression (|>> (as Text) (text.= "table"))
                            (/.type/1 (/.table (stack [string (/.float float)]))))
                (expression (|>> (as Text) (text.= "table"))
                            (/.type/1 (/.array (stack (/.boolean boolean)
                                                      (/.float float)
                                                      (/.string string)))))
                ))
         (_.coverage [/.require/1]
           (expression (|>> (as Integer) (i.= (i.abs int)))
                       (|> (/.require/1 (/.string "math"))
                           (/.its "abs")
                           (/.apply (stack (/.int int))))))
         (_.coverage [/.comment]
           (expression (|>> (as Decimal) (d.= then))
                       (/.comment comment
                         (/.float then))))
         )))

(the test|expression
  Test
  (`` (all _.and
           (_.for [/.Literal]
                  ..test|literal)
           (_.for [/.Computation]
                  ..test|computation)
           )))

(the test/var
  Test
  (do [! random.monad]
    [float/0 random.unit_decimal
     float/1 random.unit_decimal
     float/2 random.unit_decimal
     foreign (random.lower_cased 10)
     local (random.only (|>> (text.= foreign) not)
                        (random.lower_cased 10))
     .let [$foreign (/.var foreign)
           $local (/.var local)]]
    (all _.and
         (_.coverage [/.var]
           (expression (|>> (as Decimal) (d.= float/0))
                       (|> (/.return $foreign)
                           (/.closure (stack $foreign))
                           (/.apply (stack (/.float float/0))))))
         (_.coverage [/.let]
           (expression (|>> (as Decimal) (d.= float/1))
                       (|> (all /.then
                                (/.let (stack $local) (/.float float/1))
                                (/.return $local))
                           (/.closure (stack $foreign))
                           (/.apply (stack (/.float float/0))))))
         (_.coverage [/.local/1]
           (expression (|>> (as Decimal) (d.= float/1))
                       (|> (all /.then
                                (/.local/1 $local (/.float float/1))
                                (/.return $local))
                           (/.closure (stack $foreign))
                           (/.apply (stack (/.float float/0))))))
         (_.coverage [/.local]
           (expression (|>> (as Decimal) (d.= float/1))
                       (|> (all /.then
                                (/.local (stack $local))
                                (/.set (stack $local) (/.float float/1))
                                (/.return $local))
                           (/.closure (stack $foreign))
                           (/.apply (stack (/.float float/0))))))
         )))

(the test/location
  Test
  (do [! random.monad]
    [float/0 random.unit_decimal
     float/1 random.unit_decimal
     int/0 ..int_16
     $foreign (by ! each /.var (random.lower_cased 10))
     $arg/0 (by ! each /.var (random.lower_cased 11))
     $arg/1 (by ! each /.var (random.lower_cased 12))
     field (random.upper_cased 10)]
    (all _.and
         (_.coverage [/.set]
           (expression (|>> (as Decimal) (d.= (d.+ float/0 float/0)))
                       (|> (all /.then
                                (/.set (stack $foreign) (/.+ $foreign $foreign))
                                (/.return $foreign))
                           (/.closure (stack $foreign))
                           (/.apply (stack (/.float float/0))))))
         (_.coverage [/.multi]
           (and (expression (|>> (as Decimal) (d.= float/0))
                            (|> (all /.then
                                     (/.set (stack $arg/0 $arg/1) (/.multi (stack (/.float float/0) (/.float float/1))))
                                     (/.return $arg/0))
                                (/.closure (stack))
                                (/.apply (stack))))
                (expression (|>> (as Decimal) (d.= float/1))
                            (|> (all /.then
                                     (/.set (stack $arg/0 $arg/1) (/.multi (stack (/.float float/0) (/.float float/1))))
                                     (/.return $arg/1))
                                (/.closure (stack))
                                (/.apply (stack))))))
         (_.coverage [/.Access]
           (and (expression (|>> (as Decimal) (d.= (d.+ float/0 float/0)))
                            (let [@ (/.item (/.int +1) $foreign)]
                              (|> (all /.then
                                       (/.set (stack $foreign) (/.array (stack $foreign)))
                                       (/.set (stack @) (/.+ @ @))
                                       (/.return @))
                                  (/.closure (stack $foreign))
                                  (/.apply (stack (/.float float/0))))))
                (expression (|>> (as Decimal) (d.= (d.+ float/0 float/0)))
                            (let [@ (/.its field $foreign)]
                              (|> (all /.then
                                       (/.set (stack $foreign) (/.table (stack [field $foreign])))
                                       (/.set (stack @) (/.+ @ @))
                                       (/.return @))
                                  (/.closure (stack $foreign))
                                  (/.apply (stack (/.float float/0))))))))
         (_.for [/.Var]
                ..test/var)
         )))

(the test|label
  Test
  (do [! random.monad]
    [input ..int_16

     full_iterations (by ! each (|>> (n.% 20) ++) random.natural)
     expected_iterations (by ! each (|>> (n.% full_iterations) .integer) random.natural)

     $input (by ! each /.var (random.lower_cased 10))
     $output (by ! each /.var (random.lower_cased 11))
     $index (by ! each /.var (random.lower_cased 12))

     @loop (by ! each /.label (random.lower_cased 13))
     
     .let [expected (i.* expected_iterations input)
           expected_iterations (/.int expected_iterations)]]
    (all _.and
         (_.coverage [/.break]
           (let [=for_in (expression (|>> (as Integer) (i.= expected))
                                     (|> (all /.then
                                              (/.local/1 $output (/.int +0))
                                              (/.for_in (stack $index $input) (/.ipairs/1 (/.array (stack.repeated full_iterations $input)))
                                                        (all /.then
                                                             (/.when (/.> expected_iterations $index)
                                                               /.break)
                                                             (/.set (stack $output) (/.+ $input $output))))
                                              (/.return $output))
                                         (/.closure (stack $input))
                                         (/.apply (stack (/.int input)))))
                 
                 full_iterations (/.int (.integer full_iterations))
                 =while (expression (|>> (as Integer) (i.= expected))
                                    (|> (all /.then
                                             (/.local/1 $index (/.int +0))
                                             (/.local/1 $output (/.int +0))
                                             (/.while (/.< full_iterations $index)
                                                      (all /.then
                                                           (/.when (/.= expected_iterations $index)
                                                             /.break)
                                                           (/.set (stack $output) (/.+ $input $output))
                                                           (/.set (stack $index) (/.+ (/.int +1) $index))
                                                           ))
                                             (/.return $output))
                                        (/.closure (stack $input))
                                        (/.apply (stack (/.int input)))))
                 =repeat (expression (|>> (as Integer) (i.= expected))
                                     (|> (all /.then
                                              (/.local/1 $index (/.int +0))
                                              (/.local/1 $output (/.int +0))
                                              (/.repeat (/.= full_iterations $index)
                                                        (all /.then
                                                             (/.when (/.= expected_iterations $index)
                                                               /.break)
                                                             (/.set (stack $output) (/.+ $input $output))
                                                             (/.set (stack $index) (/.+ (/.int +1) $index))
                                                             ))
                                              (/.return $output))
                                         (/.closure (stack $input))
                                         (/.apply (stack (/.int input)))))
                 =for_step (expression (|>> (as Integer) (i.= expected))
                                       (|> (all /.then
                                                (/.local/1 $output (/.int +0))
                                                (/.for_step $index (/.int +0) full_iterations (/.int +1)
                                                            (all /.then
                                                                 (/.when (/.= expected_iterations $index)
                                                                   /.break)
                                                                 (/.set (stack $output) (/.+ $input $output))))
                                                (/.return $output))
                                           (/.closure (stack $input))
                                           (/.apply (stack (/.int input)))))]
             (and =while
                  =repeat
                  =for_step
                  =for_in)))
         (_.coverage [/.label /.set_label /.go_to]
           (expression (|>> (as Integer) (i.= expected))
                       (|> (all /.then
                                (/.local/1 $index (/.int +0))
                                (/.local/1 $output (/.int +0))
                                (/.set_label @loop)
                                (/.if (/.< expected_iterations $index)
                                  (all /.then
                                       (/.set (stack $output) (/.+ $input $output))
                                       (/.set (stack $index) (/.+ (/.int +1) $index))
                                       (/.go_to @loop))
                                  (/.return $output)))
                           (/.closure (stack $input))
                           (/.apply (stack (/.int input))))))
         )))

(the test|loop
  Test
  (do [! random.monad]
    [input ..int_16
     iterations (by ! each (n.% 10) random.natural)
     .let [$input (/.var "input")
           $output (/.var "output")
           $index (/.var "index")
           expected (i.* (.integer iterations) input)]]
    (all _.and
         (_.coverage [/.while]
           (expression (|>> (as Integer) (i.= expected))
                       (|> (all /.then
                                (/.local/1 $index (/.int +0))
                                (/.local/1 $output (/.int +0))
                                (/.while (/.< (/.int (.integer iterations)) $index)
                                         (all /.then
                                              (/.set (stack $output) (/.+ $input $output))
                                              (/.set (stack $index) (/.+ (/.int +1) $index))
                                              ))
                                (/.return $output))
                           (/.closure (stack $input))
                           (/.apply (stack (/.int input))))))
         (_.coverage [/.repeat]
           (expression (|>> (as Integer) (i.= expected))
                       (|> (all /.then
                                (/.local/1 $index (/.int +0))
                                (/.local/1 $output (/.int +0))
                                (/.repeat (/.= (/.int (.integer iterations)) $index)
                                          (all /.then
                                               (/.set (stack $output) (/.+ $input $output))
                                               (/.set (stack $index) (/.+ (/.int +1) $index))
                                               ))
                                (/.return $output))
                           (/.closure (stack $input))
                           (/.apply (stack (/.int input))))))
         (_.coverage [/.for_step]
           (expression (|>> (as Integer) (i.= expected))
                       (|> (all /.then
                                (/.local/1 $output (/.int +0))
                                (/.for_step $index (/.int +0) (/.int (.integer (-- iterations))) (/.int +1)
                                            (/.set (stack $output) (/.+ $input $output)))
                                (/.return $output))
                           (/.closure (stack $input))
                           (/.apply (stack (/.int input))))))
         (_.coverage [/.for_in /.ipairs/1]
           (expression (|>> (as Integer) (i.= expected))
                       (|> (all /.then
                                (/.local/1 $output (/.int +0))
                                (/.for_in (stack $index $input) (/.ipairs/1 (/.array (stack.repeated iterations $input)))
                                          (/.set (stack $output) (/.+ $input $output)))
                                (/.return $output))
                           (/.closure (stack $input))
                           (/.apply (stack (/.int input))))))
         (_.for [/.Label]
                ..test|label)
         )))

(the test|exception
  Test
  (do [! random.monad]
    [expected random.unit_decimal
     dummy (random.only (|>> (d.= expected) not)
                        random.unit_decimal)
     $verdict (by ! each /.var (random.lower_cased 10))
     $outcome (by ! each /.var (random.lower_cased 11))]
    (all _.and
         (_.coverage [/.pcall/1]
           (expression (|>> (as Decimal) (d.= expected))
                       (|> (all /.then
                                (/.let (stack $verdict $outcome) (/.pcall/1 (/.closure (stack)
                                                                                       (/.return (/.float expected)))))
                                (/.if $verdict
                                  (/.return $outcome)
                                  (/.return (/.float dummy))))
                           (/.closure (stack))
                           (/.apply (stack)))))
         (_.coverage [/.error/1]
           (expression (|>> (as Decimal) (d.= expected))
                       (|> (all /.then
                                (/.let (stack $verdict $outcome) (/.pcall/1 (/.closure (stack)
                                                                                       (all /.then
                                                                                            (/.; (/.error/1 (/.float expected)))
                                                                                            (/.return (/.float dummy))))))
                                (/.if $verdict
                                  (/.return (/.float dummy))
                                  (/.return $outcome)))
                           (/.closure (stack))
                           (/.apply (stack)))))
         (_.coverage [/.error/2]
           (expression (|>> (as Decimal) (d.= expected))
                       (|> (all /.then
                                (/.let (stack $verdict $outcome) (/.pcall/1 (/.closure (stack)
                                                                                       (all /.then
                                                                                            (/.; (/.error/2 (/.float expected) (/.int +2)))
                                                                                            (/.return (/.float dummy))))))
                                (/.if $verdict
                                  (/.return (/.float dummy))
                                  (/.return $outcome)))
                           (/.closure (stack))
                           (/.apply (stack)))))
         )))

(the test|function
  Test
  (do [! random.monad]
    [float/0 random.unit_decimal
     iterations (by ! each (n.% 10) random.natural)
     $self (by ! each /.var (random.lower_cased 1))
     $arg/0 (by ! each /.var (random.lower_cased 2))
     field (random.lower_cased 3)
     $class (by ! each /.var (random.upper_cased 4))]
    (all _.and
         (_.coverage [/.closure /.return]
           (expression (|>> (as Decimal) (d.= float/0))
                       (/.apply (stack)
                                (/.closure (stack) (/.return (/.float float/0))))))
         (_.coverage [/.local_function]
           (expression (|>> (as Integer) .natural (n.= iterations))
                       (|> (all /.then
                                (/.local_function $self (stack $arg/0)
                                                  (/.if (/.< (/.int (.integer iterations)) $arg/0)
                                                    (/.return (/.apply (stack (/.+ (/.int +1) $arg/0)) $self))
                                                    (/.return $arg/0)))
                                (/.return (/.apply (stack (/.int +0)) $self)))
                           (/.closure (stack))
                           (/.apply (stack)))))
         (do [! random.monad]
           [float/0 random.unit_decimal
            float/1 random.unit_decimal
            float/2 random.unit_decimal
            $arg/0 (by ! each /.var (random.lower_cased 10))
            $arg/1 (by ! each /.var (random.lower_cased 11))
            $arg/2 (by ! each /.var (random.lower_cased 12))]
           (`` (all _.and
                    (_.coverage [/.apply]
                      (expression (|>> (as Decimal) (d.= (all d.+ float/0 float/1 float/2)))
                                  (/.apply (stack (/.float float/0)
                                                  (/.float float/1)
                                                  (/.float float/2))
                                           (/.closure (stack $arg/0 $arg/1 $arg/2) (/.return (all /.+ $arg/0 $arg/1 $arg/2))))))
                    )))
         )))

(the test|branching
  Test
  (do [! random.monad]
    [float/0 random.unit_decimal
     float/1 random.unit_decimal
     ??? random.bit]
    (all _.and
         (_.coverage [/.if]
           (expression (|>> (as Decimal) (d.= (if ??? float/0 float/1)))
                       (|> (/.if (/.boolean ???)
                             (/.return (/.float float/0))
                             (/.return (/.float float/1)))
                           (/.closure (stack))
                           (/.apply (stack)))))
         (_.coverage [/.when]
           (expression (|>> (as Decimal) (d.= (if ??? float/0 float/1)))
                       (|> (all /.then
                                (/.when (/.boolean ???)
                                  (/.return (/.float float/0)))
                                (/.return (/.float float/1)))
                           (/.closure (stack))
                           (/.apply (stack)))))
         )))

(the test|binding
  Test
  (all _.and
       ..test|function
       (_.for [/.Location]
              ..test/location)
       ))

(the test|control
  Test
  (all _.and
       ..test|branching
       ..test|loop
       ..test|exception
       ))

(the test|statement
  Test
  (do [! random.monad]
    [float/0 random.unit_decimal
     float/1 random.unit_decimal
     $arg/0 (by ! each /.var (random.lower_cased 10))
     $arg/1 (by ! each /.var (random.lower_cased 11))]
    (`` (all _.and
             (_.coverage [/.; /.then /.print/1]
               (expression (|>> (as Decimal) (d.= float/0))
                           (|> (all /.then
                                    (/.; (/.print/1 $arg/0))
                                    (/.return $arg/0))
                               (/.closure (stack $arg/0))
                               (/.apply (stack (/.float float/0))))))
             ..test|binding
             ..test|control
             ))))

(the .public test
  Test
  (do [! random.monad]
    [.let [random (is (Random (/.Code Any))
                      (by ! each /.int random.integer))]
     expected random.integer]
    (<| (_.covering /._)
        (_.for [/.Code /.code])
        (`` (all _.and
                 (_.for [/.equivalence]
                        (equivalenceT.spec /.equivalence random))
                 (_.for [/.hash]
                        (hashT.spec /.hash random))
                 
                 (_.coverage [/.manual]
                   (expression (|>> (as Integer) (i.= expected))
                               (/.manual (/.code (/.int expected)))))
                 (_.for [/.Expression]
                        ..test|expression)
                 (_.for [/.Statement]
                        ..test|statement)
                 )))))
