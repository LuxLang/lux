(.module:
  [lux (#- Type type primitive int)
   ["." host (#+ import:)]
   ["@" target]
   [abstract
    ["." monad (#+ do)]]
   [control
    ["." function]
    ["." io]
    ["." try]
    [concurrency
     ["." atom]]]
   [data
    ["." maybe]
    ["." bit ("#\." equivalence)]
    [number
     ["." i32 (#+ I32)]
     ["." i64]
     ["n" nat]
     ["i" int]
     ["f" frac]]
    ["." text ("#\." equivalence)
     ["%" format (#+ format)]]
    ["." format #_
     ["#" binary]]
    [collection
     ["." array]
     ["." dictionary]
     ["." row]
     ["." set]
     ["." list ("#\." functor)]]]
   [math
    ["." random (#+ Random) ("#\." monad)]]
   ["_" test (#+ Test)]]
  {1
   ["." / #_
    ["#." loader (#+ Library)]
    ["#." version]
    ["#." modifier ("#\." monoid)]
    ["#." field]
    ["#." method (#+ Method)]
    ["#." class]
    ["#." attribute
     ["#/." code]]
    ["#." constant
     ["#/." pool (#+ Resource)]]
    [encoding
     ["#." name]
     ["#." signed]
     ["#." unsigned]]
    ["#" bytecode (#+ Label Bytecode)
     ["#." instruction]]
    ["#." type (#+ Type)
     ["." category (#+ Value Object Class)]]]})

(def: method-modifier
  ($_ /modifier\compose
      /method.public
      /method.static))

(import: java/lang/Boolean)
(import: java/lang/Byte)
(import: java/lang/Short)
(import: java/lang/Integer)
(import: java/lang/Long)
(import: java/lang/Float)
(import: java/lang/Double
  ["#::."
   (#static compare [double double] int)])
(import: java/lang/Character)
(import: java/lang/String)

(import: java/lang/reflect/Method
  ["#::."
   (invoke [java/lang/Object [java/lang/Object]] #try java/lang/Object)])

(import: (java/lang/Class c)
  ["#::."
   (getDeclaredMethod [java/lang/String [(java/lang/Class [? < java/lang/Object])]] java/lang/reflect/Method)])

(import: java/lang/Object
  ["#::."
   (getClass [] (java/lang/Class java/lang/Object))
   (toString [] java/lang/String)])

(def: class-name
  (Random Text)
  (do random.monad
    [super-package (random.ascii/lower-alpha 10)
     package (random.ascii/lower-alpha 10)
     name (random.ascii/upper-alpha 10)]
    (wrap (format super-package
                  /name.external-separator package
                  /name.external-separator name))))

(def: (get-method name class)
  (-> Text (java/lang/Class java/lang/Object) java/lang/reflect/Method)
  (java/lang/Class::getDeclaredMethod name
                                      (host.array (java/lang/Class java/lang/Object) 0)
                                      class))

(def: $Object (/type.class "java.lang.Object" (list)))

(def: (bytecode test bytecode)
  (-> (-> Any Bit) (Bytecode Any) (Random Bit))
  (do random.monad
    [class-name ..class-name
     method-name (random.ascii/upper-alpha 10)]
    (wrap (case (do try.monad
                  [class (/class.class /version.v6_0 /class.public
                                       (/name.internal class-name)
                                       (/name.internal "java.lang.Object")
                                       (list)
                                       (list)
                                       (list (/method.method ..method-modifier
                                                             method-name
                                                             (/type.method [(list) ..$Object (list)])
                                                             (list)
                                                             (#.Some (do /.monad
                                                                       [_ bytecode]
                                                                       /.areturn))))
                                       (row.row))
                   #let [bytecode (format.run /class.writer class)
                         loader (/loader.memory (/loader.new-library []))]
                   _ (/loader.define class-name bytecode loader)
                   class (io.run (/loader.load class-name loader))
                   method (host.try (get-method method-name class))]
                  (java/lang/reflect/Method::invoke (host.null) (host.array java/lang/Object 0) method))
            (#try.Success actual)
            (test actual)
            
            (#try.Failure error)
            false))))

(type: (Primitive a)
  {#unboxed (Type category.Return)
   #boxed (Type category.Class)
   #wrap (Bytecode Any)
   #random (Random a)
   #literal (-> a (Bytecode Any))})

(def: $Boolean
  (/type.class "java.lang.Boolean" (list)))
(def: $Boolean::wrap
  (/.invokestatic ..$Boolean "valueOf" (/type.method [(list /type.boolean) ..$Boolean (list)])))
(def: $Boolean::random (:coerce (Random java/lang/Boolean) random.bit))
(def: !false (|> 0 .i64 i32.i32 /.int))
(def: !true (|> 1 .i64 i32.i32 /.int))
(def: ($Boolean::literal value)
  (-> java/lang/Boolean (Bytecode Any))
  (if (:coerce Bit value)
    ..!true
    ..!false))
(def: $Boolean::primitive
  (Primitive java/lang/Boolean)
  {#unboxed /type.boolean
   #boxed ..$Boolean
   #wrap ..$Boolean::wrap
   #random ..$Boolean::random
   #literal ..$Boolean::literal})

(def: $Byte
  (/type.class "java.lang.Byte" (list)))
(def: $Byte::wrap
  (/.invokestatic ..$Byte "valueOf" (/type.method [(list /type.byte) ..$Byte (list)])))
(def: $Byte::random
  (Random java/lang/Byte)
  (\ random.monad map (|>> (:coerce java/lang/Long) host.long-to-byte) random.int))
(def: $Byte::literal
  (-> java/lang/Byte (Bytecode Any))
  (|>> host.byte-to-long (:coerce I64) i32.i32 /.int))
(def: $Byte::primitive
  (Primitive java/lang/Byte)
  {#unboxed /type.byte
   #boxed ..$Byte
   #wrap ..$Byte::wrap
   #random ..$Byte::random
   #literal ..$Byte::literal})

(def: $Short
  (/type.class "java.lang.Short" (list)))
(def: $Short::wrap
  (/.invokestatic ..$Short "valueOf" (/type.method [(list /type.short) ..$Short (list)])))
(def: $Short::random
  (Random java/lang/Short)
  (\ random.monad map (|>> (:coerce java/lang/Long) host.long-to-short) random.int))
(def: $Short::literal
  (-> java/lang/Short (Bytecode Any))
  (|>> host.short-to-long (:coerce I64) i32.i32 /.int))
(def: $Short::primitive
  (Primitive java/lang/Short)
  {#unboxed /type.short
   #boxed ..$Short
   #wrap ..$Short::wrap
   #random ..$Short::random
   #literal ..$Short::literal})

(def: $Integer
  (/type.class "java.lang.Integer" (list)))
(def: $Integer::wrap
  (/.invokestatic ..$Integer "valueOf" (/type.method [(list /type.int) ..$Integer (list)])))
(def: $Integer::random
  (Random java/lang/Integer)
  (\ random.monad map (|>> (:coerce java/lang/Long) host.long-to-int) random.int))
(def: $Integer::literal
  (-> java/lang/Integer (Bytecode Any))
  (|>> host.int-to-long (:coerce I64) i32.i32 /.int))
(def: $Integer::primitive
  (Primitive java/lang/Integer)
  {#unboxed /type.int
   #boxed ..$Integer
   #wrap ..$Integer::wrap
   #random ..$Integer::random
   #literal ..$Integer::literal})

(def: $Long (/type.class "java.lang.Long" (list)))
(def: $Long::wrap (/.invokestatic ..$Long "valueOf" (/type.method [(list /type.long) ..$Long (list)])))
(def: $Long::random (:coerce (Random java/lang/Long) random.int))
(def: $Long::literal (-> java/lang/Long (Bytecode Any)) (|>> (:coerce Int) /.long))
(def: $Long::primitive
  (Primitive java/lang/Long)
  {#unboxed /type.long
   #boxed ..$Long
   #wrap ..$Long::wrap
   #random ..$Long::random
   #literal ..$Long::literal})

(def: $Float (/type.class "java.lang.Float" (list)))
(def: $Float::wrap (/.invokestatic ..$Float "valueOf" (/type.method [(list /type.float) ..$Float (list)])))
(def: $Float::random
  (Random java/lang/Float)
  (\ random.monad map
     (|>> (:coerce java/lang/Double) host.double-to-float)
     random.frac))
(def: $Float::literal /.float)
(def: valid-float
  (Random java/lang/Float)
  (random.filter (|>> host.float-to-double (:coerce Frac) f.not-a-number? not)
                 ..$Float::random))
(def: $Float::primitive
  (Primitive java/lang/Float)
  {#unboxed /type.float
   #boxed ..$Float
   #wrap ..$Float::wrap
   #random ..valid-float
   #literal ..$Float::literal})

(def: $Double (/type.class "java.lang.Double" (list)))
(def: $Double::wrap (/.invokestatic ..$Double "valueOf" (/type.method [(list /type.double) ..$Double (list)])))
(def: $Double::random (:coerce (Random java/lang/Double) random.frac))
(def: $Double::literal
  (-> java/lang/Double (Bytecode Any))
  (|>> (:coerce Frac) /.double))
(def: valid-double
  (Random java/lang/Double)
  (random.filter (|>> (:coerce Frac) f.not-a-number? not)
                 ..$Double::random))
(def: $Double::primitive
  (Primitive java/lang/Double)
  {#unboxed /type.double
   #boxed ..$Double
   #wrap ..$Double::wrap
   #random ..valid-double
   #literal ..$Double::literal})

(def: $Character
  (/type.class "java.lang.Character" (list)))
(def: $Character::wrap
  (/.invokestatic ..$Character "valueOf" (/type.method [(list /type.char) ..$Character (list)])))
(def: $Character::random
  (Random java/lang/Character)
  (\ random.monad map (|>> (:coerce java/lang/Long) host.long-to-int host.int-to-char) random.int))
(def: $Character::literal
  (-> java/lang/Character (Bytecode Any))
  (|>> host.char-to-long (:coerce I64) i32.i32 /.int))
(def: $Character::primitive
  (Primitive java/lang/Character)
  {#unboxed /type.char
   #boxed ..$Character
   #wrap ..$Character::wrap
   #random ..$Character::random
   #literal ..$Character::literal})

(def: $String
  (/type.class "java.lang.String" (list)))

(def: $String::random
  (:coerce (Random java/lang/String)
           (random.ascii/alpha 10)))

(def: $String::literal
  (-> java/lang/String (Bytecode Any))
  (|>> (:coerce Text) /.string))

(def: $String::primitive
  (Primitive java/lang/String)
  {#unboxed ..$String
   #boxed ..$String
   #wrap /.nop
   #random ..$String::random
   #literal ..$String::literal})

(template [<name> <bits> <type> <push> <wrap> <message> <to-long> <signed>]
  [(def: <name>
     Test
     (do {! random.monad}
       [expected (\ ! map (i64.and (i64.mask <bits>)) random.nat)]
       (<| (_.lift <message>)
           (..bytecode (for {@.old
                             (|>> (:coerce <type>) <to-long> ("jvm leq" expected))
                             @.jvm
                             (|>> (:coerce <type>) <to-long> "jvm object cast" ("jvm long =" ("jvm object cast" (:coerce java/lang/Long expected))))}))
           (do /.monad
             [_ (<push> (|> expected .int <signed> try.assume))]
             <wrap>))))]

  [byte 7 java/lang/Byte /.bipush ..$Byte::wrap "BIPUSH" host.byte-to-long /signed.s1]
  [short 15 java/lang/Short /.sipush ..$Short::wrap "SIPUSH" host.short-to-long /signed.s2]
  )

(template [<name> <type>]
  [(template: (<name> <old-extension> <new-extension>)
     (: (-> <type> <type> <type>)
        (function (_ parameter subject)
          (for {@.old
                (<old-extension> subject parameter)
                
                @.jvm
                ("jvm object cast"
                 (<new-extension> ("jvm object cast" parameter)
                                  ("jvm object cast" subject)))}))))]

  [int/2 java/lang/Integer]
  [long/2 java/lang/Long]
  [float/2 java/lang/Float]
  [double/2 java/lang/Double]
  )

(template: (int+long/2 <old-extension> <new-extension>)
  (: (-> java/lang/Integer java/lang/Long java/lang/Long)
     (function (_ parameter subject)
       (for {@.old
             (<old-extension> subject parameter)
             
             @.jvm
             ("jvm object cast"
              (<new-extension> ("jvm object cast" parameter)
                               ("jvm object cast" subject)))}))))

(def: int
  Test
  (let [int (: (-> java/lang/Integer (Bytecode Any) (Random Bit))
               (function (_ expected bytecode)
                 (<| (..bytecode (for {@.old
                                       (|>> (:coerce java/lang/Integer) ("jvm ieq" expected))
                                       
                                       @.jvm
                                       (|>> (:coerce java/lang/Integer) "jvm object cast" ("jvm int =" ("jvm object cast" expected)))}))
                     (do /.monad
                       [_ bytecode]
                       ..$Integer::wrap))))
        unary (: (-> (-> java/lang/Integer java/lang/Integer) (Bytecode Any) (Random Bit))
                 (function (_ reference instruction)
                   (do random.monad
                     [subject ..$Integer::random]
                     (int (reference subject)
                          (do /.monad
                            [_ (..$Integer::literal subject)]
                            instruction)))))
        binary (: (-> (-> java/lang/Integer java/lang/Integer java/lang/Integer)
                      (Bytecode Any)
                      (Random Bit))
                  (function (_ reference instruction)
                    (do random.monad
                      [parameter ..$Integer::random
                       subject ..$Integer::random]
                      (int (reference parameter subject)
                           (do /.monad
                             [_ (..$Integer::literal subject)
                              _ (..$Integer::literal parameter)]
                             instruction)))))
        shift (: (-> (-> java/lang/Integer java/lang/Integer java/lang/Integer) (Bytecode Any) (Random Bit))
                 (function (_ reference instruction)
                   (do {! random.monad}
                     [parameter (\ ! map (|>> (n.% 32) .int (:coerce java/lang/Long) host.long-to-int) random.nat)
                      subject ..$Integer::random]
                     (int (reference parameter subject)
                          (do /.monad
                            [_ (..$Integer::literal subject)
                             _ (..$Integer::literal parameter)]
                            instruction)))))
        literal ($_ _.and
                    (_.lift "ICONST_M1" (int (host.long-to-int (:coerce java/lang/Long -1)) /.iconst-m1))
                    (_.lift "ICONST_0" (int (host.long-to-int (:coerce java/lang/Long +0)) /.iconst-0))
                    (_.lift "ICONST_1" (int (host.long-to-int (:coerce java/lang/Long +1)) /.iconst-1))
                    (_.lift "ICONST_2" (int (host.long-to-int (:coerce java/lang/Long +2)) /.iconst-2))
                    (_.lift "ICONST_3" (int (host.long-to-int (:coerce java/lang/Long +3)) /.iconst-3))
                    (_.lift "ICONST_4" (int (host.long-to-int (:coerce java/lang/Long +4)) /.iconst-4))
                    (_.lift "ICONST_5" (int (host.long-to-int (:coerce java/lang/Long +5)) /.iconst-5))
                    (_.lift "LDC_W/INTEGER"
                            (do random.monad
                              [expected ..$Integer::random]
                              (int expected (..$Integer::literal expected)))))
        arithmetic ($_ _.and
                       (_.lift "IADD" (binary (int/2 "jvm iadd" "jvm int +") /.iadd))
                       (_.lift "ISUB" (binary (int/2 "jvm isub" "jvm int -") /.isub))
                       (_.lift "IMUL" (binary (int/2 "jvm imul" "jvm int *") /.imul))
                       (_.lift "IDIV" (binary (int/2 "jvm idiv" "jvm int /") /.idiv))
                       (_.lift "IREM" (binary (int/2 "jvm irem" "jvm int %") /.irem))
                       (_.lift "INEG" (unary (function (_ value)
                                               ((int/2 "jvm isub" "jvm int -")
                                                value
                                                (host.long-to-int (:coerce java/lang/Long +0))))
                                             /.ineg)))
        bitwise ($_ _.and
                    (_.lift "IAND" (binary (int/2 "jvm iand" "jvm int and") /.iand))
                    (_.lift "IOR" (binary (int/2 "jvm ior" "jvm int or") /.ior))
                    (_.lift "IXOR" (binary (int/2 "jvm ixor" "jvm int xor") /.ixor))
                    (_.lift "ISHL" (shift (int/2 "jvm ishl" "jvm int shl") /.ishl))
                    (_.lift "ISHR" (shift (int/2 "jvm ishr" "jvm int shr") /.ishr))
                    (_.lift "IUSHR" (shift (int/2 "jvm iushr" "jvm int ushr") /.iushr)))]
    ($_ _.and
        (<| (_.context "literal")
            literal)
        (<| (_.context "arithmetic")
            arithmetic)
        (<| (_.context "bitwise")
            bitwise)
        )))

(def: long
  Test
  (let [long (: (-> java/lang/Long (Bytecode Any) (Random Bit))
                (function (_ expected bytecode)
                  (<| (..bytecode (for {@.old
                                        (|>> (:coerce Int) (i.= expected))
                                        
                                        @.jvm
                                        (|>> (:coerce java/lang/Long) "jvm object cast" ("jvm long =" ("jvm object cast" expected)))}))
                      (do /.monad
                        [_ bytecode]
                        ..$Long::wrap))))
        unary (: (-> (-> java/lang/Long java/lang/Long) (Bytecode Any) (Random Bit))
                 (function (_ reference instruction)
                   (do random.monad
                     [subject ..$Long::random]
                     (long (reference subject)
                           (do /.monad
                             [_ (..$Long::literal subject)]
                             instruction)))))
        binary (: (-> (-> java/lang/Long java/lang/Long java/lang/Long) (Bytecode Any) (Random Bit))
                  (function (_ reference instruction)
                    (do random.monad
                      [parameter ..$Long::random
                       subject ..$Long::random]
                      (long (reference parameter subject)
                            (do /.monad
                              [_ (..$Long::literal subject)
                               _ (..$Long::literal parameter)]
                              instruction)))))
        shift (: (-> (-> java/lang/Integer java/lang/Long java/lang/Long) (Bytecode Any) (Random Bit))
                 (function (_ reference instruction)
                   (do {! random.monad}
                     [parameter (\ ! map (|>> (n.% 64) (:coerce java/lang/Long)) random.nat)
                      subject ..$Long::random]
                     (long (reference (host.long-to-int parameter) subject)
                           (do /.monad
                             [_ (..$Long::literal subject)
                              _ (..$Integer::literal (host.long-to-int parameter))]
                             instruction)))))
        literal ($_ _.and
                    (_.lift "LCONST_0" (long (:coerce java/lang/Long +0) /.lconst-0))
                    (_.lift "LCONST_1" (long (:coerce java/lang/Long +1) /.lconst-1))
                    (_.lift "LDC2_W/LONG"
                            (do random.monad
                              [expected ..$Long::random]
                              (long expected (..$Long::literal expected)))))
        arithmetic ($_ _.and
                       (_.lift "LADD" (binary (long/2 "jvm ladd" "jvm long +") /.ladd))
                       (_.lift "LSUB" (binary (long/2 "jvm lsub" "jvm long -") /.lsub))
                       (_.lift "LMUL" (binary (long/2 "jvm lmul" "jvm long *") /.lmul))
                       (_.lift "LDIV" (binary (long/2 "jvm ldiv" "jvm long /") /.ldiv))
                       (_.lift "LREM" (binary (long/2 "jvm lrem" "jvm long %") /.lrem))
                       (_.lift "LNEG" (unary (function (_ value)
                                               ((long/2 "jvm lsub" "jvm long -")
                                                value
                                                (:coerce java/lang/Long +0)))
                                             /.lneg)))
        bitwise ($_ _.and
                    (_.lift "LAND" (binary (long/2 "jvm land" "jvm long and") /.land))
                    (_.lift "LOR" (binary (long/2 "jvm lor" "jvm long or") /.lor))
                    (_.lift "LXOR" (binary (long/2 "jvm lxor" "jvm long xor") /.lxor))
                    (_.lift "LSHL" (shift (int+long/2 "jvm lshl" "jvm long shl") /.lshl))
                    (_.lift "LSHR" (shift (int+long/2 "jvm lshr" "jvm long shr") /.lshr))
                    (_.lift "LUSHR" (shift (int+long/2 "jvm lushr" "jvm long ushr") /.lushr)))
        comparison (_.lift "LCMP"
                           (do random.monad
                             [reference ..$Long::random
                              subject ..$Long::random
                              #let [expected (cond (i.= (:coerce Int reference) (:coerce Int subject))
                                                   (:coerce java/lang/Long +0)

                                                   (i.> (:coerce Int reference) (:coerce Int subject))
                                                   (:coerce java/lang/Long +1)

                                                   ## (i.< (:coerce Int reference) (:coerce Int subject))
                                                   (:coerce java/lang/Long -1))]]
                             (<| (..bytecode (for {@.old
                                                   (|>> (:coerce Int) (i.= expected))
                                                   
                                                   @.jvm
                                                   (|>> (:coerce java/lang/Long) "jvm object cast" ("jvm long =" ("jvm object cast" expected)))}))
                                 (do /.monad
                                   [_ (..$Long::literal subject)
                                    _ (..$Long::literal reference)
                                    _ /.lcmp
                                    _ /.i2l]
                                   ..$Long::wrap))))]
    ($_ _.and
        (<| (_.context "literal")
            literal)
        (<| (_.context "arithmetic")
            arithmetic)
        (<| (_.context "bitwise")
            bitwise)
        (<| (_.context "comparison")
            comparison)
        )))

(def: float
  Test
  (let [float (: (-> java/lang/Float (Bytecode Any) (Random Bit))
                 (function (_ expected bytecode)
                   (<| (..bytecode (for {@.old
                                         (function (_ actual)
                                           (or (|> actual (:coerce java/lang/Float) ("jvm feq" expected))
                                               (and (f.not-a-number? (:coerce Frac (host.float-to-double expected)))
                                                    (f.not-a-number? (:coerce Frac (host.float-to-double (:coerce java/lang/Float actual)))))))
                                         
                                         @.jvm
                                         (function (_ actual)
                                           (or (|> actual (:coerce java/lang/Float) "jvm object cast" ("jvm float =" ("jvm object cast" expected)))
                                               (and (f.not-a-number? (:coerce Frac (host.float-to-double expected)))
                                                    (f.not-a-number? (:coerce Frac (host.float-to-double (:coerce java/lang/Float actual)))))))}))
                       (do /.monad
                         [_ bytecode]
                         ..$Float::wrap))))
        unary (: (-> (-> java/lang/Float java/lang/Float)
                     (Bytecode Any)
                     (Random Bit))
                 (function (_ reference instruction)
                   (do random.monad
                     [subject ..$Float::random]
                     (float (reference subject)
                            (do /.monad
                              [_ (..$Float::literal subject)]
                              instruction)))))
        binary (: (-> (-> java/lang/Float java/lang/Float java/lang/Float)
                      (Bytecode Any)
                      (Random Bit))
                  (function (_ reference instruction)
                    (do random.monad
                      [parameter ..$Float::random
                       subject ..$Float::random]
                      (float (reference parameter subject)
                             (do /.monad
                               [_ (..$Float::literal subject)
                                _ (..$Float::literal parameter)]
                               instruction)))))
        literal ($_ _.and
                    (_.lift "FCONST_0" (float (host.double-to-float (:coerce java/lang/Double +0.0)) /.fconst-0))
                    (_.lift "FCONST_1" (float (host.double-to-float (:coerce java/lang/Double +1.0)) /.fconst-1))
                    (_.lift "FCONST_2" (float (host.double-to-float (:coerce java/lang/Double +2.0)) /.fconst-2))
                    (_.lift "LDC_W/FLOAT"
                            (do random.monad
                              [expected ..$Float::random]
                              (float expected (..$Float::literal expected)))))
        arithmetic ($_ _.and
                       (_.lift "FADD" (binary (float/2 "jvm fadd" "jvm float +") /.fadd))
                       (_.lift "FSUB" (binary (float/2 "jvm fsub" "jvm float -") /.fsub))
                       (_.lift "FMUL" (binary (float/2 "jvm fmul" "jvm float *") /.fmul))
                       (_.lift "FDIV" (binary (float/2 "jvm fdiv" "jvm float /") /.fdiv))
                       (_.lift "FREM" (binary (float/2 "jvm frem" "jvm float %") /.frem))
                       (_.lift "FNEG" (unary (function (_ value)
                                               ((float/2 "jvm fsub" "jvm float -")
                                                value
                                                (host.double-to-float (:coerce java/lang/Double +0.0))))
                                             /.fneg)))
        comparison (: (-> (Bytecode Any) (-> java/lang/Float java/lang/Float Bit) (Random Bit))
                      (function (_ instruction standard)
                        (do random.monad
                          [#let [valid-float (random.filter (|>> host.float-to-double (:coerce Frac) f.not-a-number? not)
                                                            ..$Float::random)]
                           reference valid-float
                           subject valid-float
                           #let [expected (if (for {@.old
                                                    ("jvm feq" reference subject)
                                                    
                                                    @.jvm
                                                    ("jvm float =" ("jvm object cast" reference) ("jvm object cast" subject))})
                                            +0
                                            (if (standard reference subject)
                                              +1
                                              -1))]]
                          (<| (..bytecode (|>> (:coerce Int) (i.= expected)))
                              (do /.monad
                                [_ (..$Float::literal subject)
                                 _ (..$Float::literal reference)
                                 _ instruction
                                 _ /.i2l]
                                ..$Long::wrap)))))
        comparison-standard (: (-> java/lang/Float java/lang/Float Bit)
                               (function (_ reference subject)
                                 (for {@.old
                                       ("jvm fgt" subject reference)
                                       
                                       @.jvm
                                       ("jvm float <" ("jvm object cast" subject) ("jvm object cast" reference))})))
        comparison ($_ _.and
                       (_.lift "FCMPL" (comparison /.fcmpl comparison-standard))
                       (_.lift "FCMPG" (comparison /.fcmpg comparison-standard)))]
    ($_ _.and
        (<| (_.context "literal")
            literal)
        (<| (_.context "arithmetic")
            arithmetic)
        (<| (_.context "comparison")
            comparison)
        )))

(def: double
  Test
  (let [double (: (-> java/lang/Double (Bytecode Any) (Random Bit))
                  (function (_ expected bytecode)
                    (<| (..bytecode (for {@.old
                                          (function (_ actual)
                                            (or (|> actual (:coerce java/lang/Double) ("jvm deq" expected))
                                                (and (f.not-a-number? (:coerce Frac expected))
                                                     (f.not-a-number? (:coerce Frac actual)))))
                                          
                                          @.jvm
                                          (function (_ actual)
                                            (or (|> actual (:coerce java/lang/Double) "jvm object cast" ("jvm double =" ("jvm object cast" expected)))
                                                (and (f.not-a-number? (:coerce Frac expected))
                                                     (f.not-a-number? (:coerce Frac actual)))))}))
                        (do /.monad
                          [_ bytecode]
                          ..$Double::wrap))))
        unary (: (-> (-> java/lang/Double java/lang/Double) (Bytecode Any) (Random Bit))
                 (function (_ reference instruction)
                   (do random.monad
                     [subject ..$Double::random]
                     (double (reference subject)
                             (do /.monad
                               [_ (..$Double::literal subject)]
                               instruction)))))
        binary (: (-> (-> java/lang/Double java/lang/Double java/lang/Double) (Bytecode Any) (Random Bit))
                  (function (_ reference instruction)
                    (do random.monad
                      [parameter ..$Double::random
                       subject ..$Double::random]
                      (double (reference parameter subject)
                              (do /.monad
                                [_ (..$Double::literal subject)
                                 _ (..$Double::literal parameter)]
                                instruction)))))
        literal ($_ _.and
                    (_.lift "DCONST_0" (double (:coerce java/lang/Double +0.0) /.dconst-0))
                    (_.lift "DCONST_1" (double (:coerce java/lang/Double +1.0) /.dconst-1))
                    (_.lift "LDC2_W/DOUBLE"
                            (do random.monad
                              [expected ..$Double::random]
                              (double expected (..$Double::literal expected)))))
        arithmetic ($_ _.and
                       (_.lift "DADD" (binary (double/2 "jvm dadd" "jvm double +") /.dadd))
                       (_.lift "DSUB" (binary (double/2 "jvm dsub" "jvm double -") /.dsub))
                       (_.lift "DMUL" (binary (double/2 "jvm dmul" "jvm double *") /.dmul))
                       (_.lift "DDIV" (binary (double/2 "jvm ddiv" "jvm double /") /.ddiv))
                       (_.lift "DREM" (binary (double/2 "jvm drem" "jvm double %") /.drem))
                       (_.lift "DNEG" (unary (function (_ value)
                                               ((double/2 "jvm dsub" "jvm double -")
                                                value
                                                (:coerce java/lang/Double +0.0)))
                                             /.dneg)))
        comparison (: (-> (Bytecode Any) (-> java/lang/Double java/lang/Double Bit) (Random Bit))
                      (function (_ instruction standard)
                        (do random.monad
                          [reference ..valid-double
                           subject ..valid-double
                           #let [expected (if (for {@.old
                                                    ("jvm deq" reference subject)
                                                    
                                                    @.jvm
                                                    ("jvm double =" ("jvm object cast" reference) ("jvm object cast" subject))})
                                            +0
                                            (if (standard reference subject)
                                              +1
                                              -1))]]
                          (<| (..bytecode (|>> (:coerce Int) (i.= expected)))
                              (do /.monad
                                [_ (..$Double::literal subject)
                                 _ (..$Double::literal reference)
                                 _ instruction
                                 _ /.i2l]
                                ..$Long::wrap)))))
        ## https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.dcmp_op
        comparison-standard (: (-> java/lang/Double java/lang/Double Bit)
                               (function (_ reference subject)
                                 (for {@.old
                                       ("jvm dgt" subject reference)
                                       
                                       @.jvm
                                       ("jvm double <" ("jvm object cast" subject) ("jvm object cast" reference))})))
        comparison ($_ _.and
                       (_.lift "DCMPL" (comparison /.dcmpl comparison-standard))
                       (_.lift "DCMPG" (comparison /.dcmpg comparison-standard)))]
    ($_ _.and
        (<| (_.context "literal")
            literal)
        (<| (_.context "arithmetic")
            arithmetic)
        (<| (_.context "comparison")
            comparison)
        )))

(def: primitive
  Test
  ($_ _.and
      (<| (_.context "byte")
          ..byte)
      (<| (_.context "short")
          ..short)
      (<| (_.context "int")
          ..int)
      (<| (_.context "long")
          ..long)
      (<| (_.context "float")
          ..float)
      (<| (_.context "double")
          ..double)
      ))

(def: object
  Test
  (let [!object (: (Bytecode Any)
                   (do /.monad
                     [_ (/.new ..$Object)
                      _ /.dup]
                     (/.invokespecial ..$Object "<init>" (/type.method [(list) /type.void (list)]))))]
    ($_ _.and
        (<| (_.lift "ACONST_NULL")
            (..bytecode (|>> (:coerce Bit) not))
            (do /.monad
              [_ /.aconst-null
               _ (/.instanceof ..$String)]
              ..$Boolean::wrap))
        (<| (_.lift "INSTANCEOF")
            (do random.monad
              [value ..$String::random])
            (..bytecode (|>> (:coerce Bit)))
            (do /.monad
              [_ (/.string (:coerce Text value))
               _ (/.instanceof ..$String)]
              ..$Boolean::wrap))
        (<| (_.lift "NEW & CHECKCAST")
            (..bytecode (|>> (:coerce Bit)))
            (do /.monad
              [_ !object
               _ (/.checkcast ..$Object)
               _ (/.instanceof ..$Object)]
              ..$Boolean::wrap))
        (<| (_.lift "MONITORENTER & MONITOREXIT")
            (do random.monad
              [value ..$String::random])
            (..bytecode (|>> (:coerce Bit)))
            (do /.monad
              [_ (/.string (:coerce Text value))
               _ /.dup _ /.monitorenter
               _ /.dup _ /.monitorexit
               _ (/.instanceof ..$String)]
              ..$Boolean::wrap))
        )))

(def: method
  Test
  ($_ _.and
      (<| (_.lift "INVOKESTATIC")
          (do random.monad
            [expected (random.filter (|>> (:coerce Frac) f.not-a-number? not)
                                     ..$Double::random)])
          (..bytecode (for {@.old
                            (|>> (:coerce java/lang/Double) ("jvm deq" expected))
                            
                            @.jvm
                            (|>> (:coerce java/lang/Double) "jvm object cast" ("jvm double =" ("jvm object cast" expected)))}))
          (do /.monad
            [_ (/.double (:coerce Frac expected))]
            (/.invokestatic ..$Double "valueOf" (/type.method [(list /type.double) ..$Double (list)]))))
      (<| (_.lift "INVOKEVIRTUAL")
          (do random.monad
            [expected ..$Double::random])
          (..bytecode (|>> (:coerce Bit) (bit\= (f.not-a-number? (:coerce Frac expected)))))
          (do /.monad
            [_ (/.double (:coerce Frac expected))
             _ ..$Double::wrap
             _ (/.invokevirtual ..$Double "isNaN" (/type.method [(list) /type.boolean (list)]))]
            ..$Boolean::wrap))
      (<| (_.lift "INVOKESPECIAL")
          (do random.monad
            [expected (random.filter (|>> (:coerce Frac) f.not-a-number? not)
                                     ..$Double::random)])
          (..bytecode (for {@.old
                            (|>> (:coerce java/lang/Double) ("jvm deq" expected))
                            
                            @.jvm
                            (|>> (:coerce java/lang/Double) "jvm object cast" ("jvm double =" ("jvm object cast" expected)))}))
          (do /.monad
            [_ (/.new ..$Double)
             _ /.dup
             _ (/.double (:coerce Frac expected))]
            (/.invokespecial ..$Double "<init>" (/type.method [(list /type.double) /type.void (list)]))))
      (<| (_.lift "INVOKEINTERFACE")
          (do random.monad
            [subject ..$String::random])
          (..bytecode (|>> (:coerce Nat) (n.= (text.size (:coerce Text subject)))))
          (do /.monad
            [_ (/.string (:coerce Text subject))
             _ (/.invokeinterface (/type.class "java.lang.CharSequence" (list)) "length" (/type.method [(list) /type.int (list)]))
             _ /.i2l]
            ..$Long::wrap))
      ))

(def: field
  Test
  (do random.monad
    [class-name ..class-name
     part0 ..$Long::random
     part1 ..$Long::random
     #let [expected (: java/lang/Long
                       (for {@.old
                             ("jvm ladd" part0 part1)
                             
                             @.jvm
                             ("jvm object cast"
                              ("jvm long +" ("jvm object cast" part0) ("jvm object cast" part1)))}))
           $Self (/type.class class-name (list))
           class-field "class_field"
           object-field "object_field"
           constructor "<init>"
           constructor::type (/type.method [(list /type.long) /type.void (list)])
           static-method "static_method"
           bytecode (|> (/class.class /version.v6_0 /class.public
                                      (/name.internal class-name)
                                      (/name.internal "java.lang.Object")
                                      (list)
                                      (list (/field.field /field.static class-field /type.long (row.row))
                                            (/field.field /field.public object-field /type.long (row.row)))
                                      (list (/method.method /method.private
                                                            constructor
                                                            constructor::type
                                                            (list)
                                                            (#.Some (do /.monad
                                                                      [_ /.aload-0
                                                                       _ (/.invokespecial ..$Object constructor (/type.method [(list) /type.void (list)]))
                                                                       _ (..$Long::literal part0)
                                                                       _ (/.putstatic $Self class-field /type.long)
                                                                       _ /.aload-0
                                                                       _ /.lload-1
                                                                       _ (/.putfield $Self object-field /type.long)]
                                                                      /.return)))
                                            (/method.method ($_ /modifier\compose
                                                                /method.public
                                                                /method.static)
                                                            static-method
                                                            (/type.method [(list) ..$Long (list)])
                                                            (list)
                                                            (#.Some (do /.monad
                                                                      [_ (/.new $Self)
                                                                       _ /.dup
                                                                       _ (..$Long::literal part1)
                                                                       _ (/.invokespecial $Self constructor constructor::type)
                                                                       _ (/.getfield $Self object-field /type.long)
                                                                       _ (/.getstatic $Self class-field /type.long)
                                                                       _ /.ladd
                                                                       _ ..$Long::wrap]
                                                                      /.areturn))))
                                      (row.row))
                        try.assume
                        (format.run /class.writer))
           loader (/loader.memory (/loader.new-library []))]]
    (_.test "PUTSTATIC & PUTFIELD & GETFIELD & GETSTATIC"
            (case (do try.monad
                    [_ (/loader.define class-name bytecode loader)
                     class (io.run (/loader.load class-name loader))
                     method (host.try (get-method static-method class))
                     output (java/lang/reflect/Method::invoke (host.null) (host.array java/lang/Object 0) method)]
                    (wrap (:coerce Int output)))
              (#try.Success actual)
              (i.= (:coerce Int expected) (:coerce Int actual))

              (#try.Failure error)
              false))))

(def: array
  Test
  (let [!length (: (-> Nat (Bytecode Any))
                   (function (_ size)
                     (do /.monad
                       [_ ($Long::literal (:coerce java/lang/Long size))]
                       /.l2i)))
        ?length (: (Bytecode Any)
                   (do /.monad
                     [_ /.arraylength]
                     /.i2l))
        length (: (-> Nat (Bytecode Any) (Random Bit))
                  (function (_ size constructor)
                    (<| (..bytecode (|>> (:coerce Nat) (n.= size)))
                        (do /.monad
                          [_ (!length size)
                           _ constructor
                           _ ?length]
                          $Long::wrap))))
        write-and-read (: (All [a]
                            (-> Nat (Bytecode Any)
                                a (-> a (Bytecode Any))
                                [(Bytecode Any) (Bytecode Any) (Bytecode Any)]
                                (-> a Any Bit)
                                (Random Bit)))
                          (function (_ size constructor value literal [*store *load *wrap] test)
                            (let [!index ($Integer::literal (host.long-to-int (:coerce java/lang/Long +0)))]
                              (<| (..bytecode (test value))
                                  (do /.monad
                                    [_ (!length size)
                                     _ constructor
                                     _ /.dup _ !index _ (literal value) _ *store
                                     _ /.dup _ !index _ *load]
                                    *wrap)))))
        array (: (All [a]
                   (-> (Bytecode Any) (Random a) (-> a (Bytecode Any))
                       [(Bytecode Any) (Bytecode Any) (Bytecode Any)]
                       (-> a Any Bit)
                       Test))
                 (function (_ constructor random literal [*store *load *wrap] test)
                   (do {! random.monad}
                     [size (\ ! map (|>> (n.% 1024) (n.max 1)) random.nat)
                      value random]
                     ($_ _.and
                         (<| (_.lift "length")
                             (length size constructor))
                         (<| (_.lift "write and read")
                             (write-and-read size constructor value literal [*store *load *wrap] test))))))]
    ($_ _.and
        (_.context "boolean"
                   (array (/.newarray /instruction.t-boolean) $Boolean::random $Boolean::literal [/.bastore /.baload $Boolean::wrap]
                          (function (_ expected) (|>> (:coerce Bit) (bit\= (:coerce Bit expected))))))
        (_.context "byte"
                   (array (/.newarray /instruction.t-byte) $Byte::random $Byte::literal [/.bastore /.baload $Byte::wrap]
                          (function (_ expected)
                            (for {@.old
                                  (|>> (:coerce java/lang/Byte) host.byte-to-long ("jvm leq" (host.byte-to-long expected)))
                                  
                                  @.jvm
                                  (|>> (:coerce java/lang/Byte) host.byte-to-long "jvm object cast" ("jvm long =" ("jvm object cast" (host.byte-to-long (:coerce java/lang/Byte expected)))))}))))
        (_.context "short"
                   (array (/.newarray /instruction.t-short) $Short::random $Short::literal [/.sastore /.saload $Short::wrap]
                          (function (_ expected)
                            (for {@.old
                                  (|>> (:coerce java/lang/Short) host.short-to-long ("jvm leq" (host.short-to-long expected)))
                                  
                                  @.jvm
                                  (|>> (:coerce java/lang/Short) host.short-to-long "jvm object cast" ("jvm long =" ("jvm object cast" (host.short-to-long (:coerce java/lang/Short expected)))))}))))
        (_.context "int"
                   (array (/.newarray /instruction.t-int) $Integer::random $Integer::literal [/.iastore /.iaload $Integer::wrap]
                          (function (_ expected)
                            (for {@.old
                                  (|>> (:coerce java/lang/Integer) ("jvm ieq" (:coerce java/lang/Integer expected)))
                                  
                                  @.jvm
                                  (|>> (:coerce java/lang/Integer) "jvm object cast" ("jvm int =" ("jvm object cast" (:coerce java/lang/Integer expected))))}))))
        (_.context "long"
                   (array (/.newarray /instruction.t-long) $Long::random $Long::literal [/.lastore /.laload $Long::wrap]
                          (function (_ expected)
                            (for {@.old
                                  (|>> (:coerce java/lang/Long) ("jvm leq" expected))
                                  
                                  @.jvm
                                  (|>> (:coerce java/lang/Long) "jvm object cast" ("jvm long =" ("jvm object cast" (:coerce java/lang/Long expected))))}))))
        (_.context "float"
                   (array (/.newarray /instruction.t-float) ..valid-float $Float::literal [/.fastore /.faload $Float::wrap]
                          (function (_ expected)
                            (for {@.old
                                  (|>> (:coerce java/lang/Float) ("jvm feq" expected))
                                  
                                  @.jvm
                                  (|>> (:coerce java/lang/Float) "jvm object cast" ("jvm float =" ("jvm object cast" (:coerce java/lang/Float expected))))}))))
        (_.context "double"
                   (array (/.newarray /instruction.t-double) ..valid-double $Double::literal [/.dastore /.daload $Double::wrap]
                          (function (_ expected)
                            (for {@.old
                                  (|>> (:coerce java/lang/Double) ("jvm deq" expected))
                                  
                                  @.jvm
                                  (|>> (:coerce java/lang/Double) "jvm object cast" ("jvm double =" ("jvm object cast" (:coerce java/lang/Double expected))))}))))
        (_.context "char"
                   (array (/.newarray /instruction.t-char) $Character::random $Character::literal [/.castore /.caload $Character::wrap]
                          (function (_ expected)
                            (for {@.old
                                  (|>> (:coerce java/lang/Character) ("jvm ceq" expected))
                                  
                                  @.jvm
                                  (|>> (:coerce java/lang/Character) "jvm object cast" ("jvm char =" ("jvm object cast" (:coerce java/lang/Character expected))))}))))
        (_.context "object"
                   (array (/.anewarray ..$String) $String::random $String::literal [/.aastore /.aaload /.nop]
                          (function (_ expected) (|>> (:coerce Text) (text\= (:coerce Text expected))))))
        (<| (_.context "multi")
            (do {! random.monad}
              [#let [size (\ ! map (|>> (n.% 5) (n.+ 1))
                             random.nat)]
               dimensions size
               sizesH size
               sizesT (random.list (dec dimensions) size)
               #let [type (loop [dimensions dimensions
                                 type (: (Type Object)
                                         ..$Object)]
                            (case dimensions
                              0 type
                              _ (recur (dec dimensions) (/type.array type))))]]
              (<| (_.lift "MULTIANEWARRAY")
                  (..bytecode (|>> (:coerce Nat) (n.= sizesH)))
                  (do {! /.monad}
                    [_ (monad.map ! (|>> (:coerce java/lang/Long) host.long-to-int ..$Integer::literal)
                                  (#.Cons sizesH sizesT))
                     _ (/.multianewarray type (|> dimensions /unsigned.u1 try.assume))
                     _ ?length]
                    $Long::wrap))))
        )))

(template: (!::= <type> <old> <new>)
  (: (-> <type> Any Bit)
     (function (_ expected)
       (for {@.old
             (|>> (:coerce <type>) (<old> expected))
             
             @.jvm
             (|>> (:coerce <type>) "jvm object cast" (<new> ("jvm object cast" (:coerce <type> expected))))}))))

(def: conversion
  Test
  (let [conversion (: (All [a z]
                        (-> (Primitive a) (Primitive z) (Bytecode Any) (-> a z) (-> z Any Bit) (Random Bit)))
                      (function (_ from to instruction convert test)
                        (do random.monad
                          [input (get@ #random from)
                           #let [expected (convert input)]]
                          (..bytecode (test expected)
                                      (do /.monad
                                        [_ ((get@ #literal from) input)
                                         _ instruction]
                                        (get@ #wrap to))))))
        int::= (!::= java/lang/Integer "jvm ieq" "jvm int =")
        long::= (!::= java/lang/Long "jvm leq" "jvm long =")
        float::= (!::= java/lang/Float "jvm feq" "jvm float =")
        double::= (!::= java/lang/Double "jvm deq" "jvm double =")]
    ($_ _.and
        (<| (_.context "int")
            ($_ _.and
                (_.lift "I2L" (conversion ..$Integer::primitive ..$Long::primitive /.i2l (|>> host.int-to-long) long::=))
                (_.lift "I2F" (conversion ..$Integer::primitive ..$Float::primitive /.i2f (|>> host.int-to-float) float::=))
                (_.lift "I2D" (conversion ..$Integer::primitive ..$Double::primitive /.i2d (|>> host.int-to-double) double::=))
                (_.lift "I2B" (conversion ..$Integer::primitive ..$Byte::primitive /.i2b (|>> host.int-to-byte)
                                          (function (_ expected)
                                            (for {@.old
                                                  (|>> (:coerce java/lang/Byte) host.byte-to-long ("jvm leq" (host.byte-to-long expected)))
                                                  
                                                  @.jvm
                                                  (|>> (:coerce java/lang/Byte) host.byte-to-long "jvm object cast" ("jvm long =" ("jvm object cast" (host.byte-to-long (:coerce java/lang/Byte expected)))))}))))
                (_.lift "I2C" (conversion ..$Integer::primitive ..$Character::primitive /.i2c (|>> host.int-to-char)
                                          (!::= java/lang/Character "jvm ceq" "jvm char =")))
                (_.lift "I2S" (conversion ..$Integer::primitive ..$Short::primitive /.i2s (|>> host.int-to-short)
                                          (function (_ expected)
                                            (for {@.old
                                                  (|>> (:coerce java/lang/Short) host.short-to-long ("jvm leq" (host.short-to-long expected)))
                                                  
                                                  @.jvm
                                                  (|>> (:coerce java/lang/Short) host.short-to-long "jvm object cast" ("jvm long =" ("jvm object cast" (host.short-to-long (:coerce java/lang/Short expected)))))}))))))
        (<| (_.context "long")
            ($_ _.and
                (_.lift "L2I" (conversion ..$Long::primitive ..$Integer::primitive /.l2i (|>> host.long-to-int) int::=))
                (_.lift "L2F" (conversion ..$Long::primitive ..$Float::primitive /.l2f (|>> host.long-to-float) float::=))
                (_.lift "L2D" (conversion ..$Long::primitive ..$Double::primitive /.l2d (|>> host.long-to-double) double::=))))
        (<| (_.context "float")
            ($_ _.and
                (_.lift "F2I" (conversion ..$Float::primitive ..$Integer::primitive /.f2i (|>> host.float-to-int) int::=))
                (_.lift "F2L" (conversion ..$Float::primitive ..$Long::primitive /.f2l (|>> host.float-to-long) long::=))
                (_.lift "F2D" (conversion ..$Float::primitive ..$Double::primitive /.f2d (|>> host.float-to-double) double::=))))
        (<| (_.context "double")
            ($_ _.and
                (_.lift "D2I" (conversion ..$Double::primitive ..$Integer::primitive /.d2i (|>> host.double-to-int) int::=))
                (_.lift "D2L" (conversion ..$Double::primitive ..$Long::primitive /.d2l (|>> host.double-to-long) long::=))
                (_.lift "D2F" (conversion ..$Double::primitive ..$Float::primitive /.d2f (|>> host.double-to-float) float::=))))
        )))

(def: value
  Test
  ($_ _.and
      (<| (_.context "primitive")
          ..primitive)
      (<| (_.context "object")
          ..object)
      (<| (_.context "method")
          ..method)
      (<| (_.context "field")
          ..field)
      (<| (_.context "array")
          ..array)
      (<| (_.context "conversion")
          ..conversion)
      ))

(def: registry
  Test
  (let [store-and-load (: (All [a]
                            (-> (Random a) (-> a (Bytecode Any)) (Bytecode Any)
                                [(-> Nat (Bytecode Any)) (-> Nat (Bytecode Any))]
                                (-> a (-> Any Bit))
                                (Random Bit)))
                          (function (_ random-value literal *wrap [store load] test)
                            (do {! random.monad}
                              [expected random-value
                               register (\ ! map (n.% 128) random.nat)]
                              (<| (..bytecode (test expected))
                                  (do /.monad
                                    [_ (literal expected)
                                     _ (store register)
                                     _ (load register)]
                                    *wrap)))))]
    ($_ _.and
        (<| (_.context "int")
            (let [test (!::= java/lang/Integer "jvm ieq" "jvm int =")]
              ($_ _.and
                  (_.lift "ISTORE_0/ILOAD_0"
                          (store-and-load ..$Integer::random ..$Integer::literal ..$Integer::wrap [(function.constant /.istore-0) (function.constant /.iload-0)] test))
                  (_.lift "ISTORE_1/ILOAD_1"
                          (store-and-load ..$Integer::random ..$Integer::literal ..$Integer::wrap [(function.constant /.istore-1) (function.constant /.iload-1)] test))
                  (_.lift "ISTORE_2/ILOAD_2"
                          (store-and-load ..$Integer::random ..$Integer::literal ..$Integer::wrap [(function.constant /.istore-2) (function.constant /.iload-2)] test))
                  (_.lift "ISTORE_3/ILOAD_3"
                          (store-and-load ..$Integer::random ..$Integer::literal ..$Integer::wrap [(function.constant /.istore-3) (function.constant /.iload-3)] test))
                  (_.lift "ISTORE/ILOAD"
                          (store-and-load ..$Integer::random ..$Integer::literal ..$Integer::wrap [/.istore /.iload] test))
                  (_.lift "IINC"
                          (do {! random.monad}
                            [base ..$Byte::random
                             increment (\ ! map (|>> (n.% 100) /unsigned.u1 try.assume)
                                          random.nat)
                             #let [expected (: java/lang/Long
                                               (for {@.old
                                                     ("jvm ladd"
                                                      (host.byte-to-long base)
                                                      (.int (/unsigned.value increment)))
                                                     
                                                     @.jvm
                                                     ("jvm object cast"
                                                      ("jvm long +"
                                                       ("jvm object cast" (host.byte-to-long base))
                                                       ("jvm object cast" (:coerce java/lang/Long (/unsigned.value increment)))))}))]]
                            (..bytecode (|>> (:coerce Int) (i.= (:coerce Int expected)))
                                        (do /.monad
                                          [_ (..$Byte::literal base)
                                           _ /.istore-0
                                           _ (/.iinc 0 increment)
                                           _ /.iload-0
                                           _ /.i2l]
                                          ..$Long::wrap)))))))
        (<| (_.context "long")
            (let [test (!::= java/lang/Long "jvm leq" "jvm long =")]
              ($_ _.and
                  (_.lift "LSTORE_0/LLOAD_0"
                          (store-and-load ..$Long::random ..$Long::literal ..$Long::wrap [(function.constant /.lstore-0) (function.constant /.lload-0)] test))
                  (_.lift "LSTORE_1/LLOAD_1"
                          (store-and-load ..$Long::random ..$Long::literal ..$Long::wrap [(function.constant /.lstore-1) (function.constant /.lload-1)] test))
                  (_.lift "LSTORE_2/LLOAD_2"
                          (store-and-load ..$Long::random ..$Long::literal ..$Long::wrap [(function.constant /.lstore-2) (function.constant /.lload-2)] test))
                  (_.lift "LSTORE_3/LLOAD_3"
                          (store-and-load ..$Long::random ..$Long::literal ..$Long::wrap [(function.constant /.lstore-3) (function.constant /.lload-3)] test))
                  (_.lift "LSTORE/LLOAD"
                          (store-and-load ..$Long::random ..$Long::literal ..$Long::wrap [/.lstore /.lload] test)))))
        (<| (_.context "float")
            (let [test (!::= java/lang/Float "jvm feq" "jvm float =")]
              ($_ _.and
                  (_.lift "FSTORE_0/FLOAD_0"
                          (store-and-load ..valid-float ..$Float::literal ..$Float::wrap [(function.constant /.fstore-0) (function.constant /.fload-0)] test))
                  (_.lift "FSTORE_1/FLOAD_1"
                          (store-and-load ..valid-float ..$Float::literal ..$Float::wrap [(function.constant /.fstore-1) (function.constant /.fload-1)] test))
                  (_.lift "FSTORE_2/FLOAD_2"
                          (store-and-load ..valid-float ..$Float::literal ..$Float::wrap [(function.constant /.fstore-2) (function.constant /.fload-2)] test))
                  (_.lift "FSTORE_3/FLOAD_3"
                          (store-and-load ..valid-float ..$Float::literal ..$Float::wrap [(function.constant /.fstore-3) (function.constant /.fload-3)] test))
                  (_.lift "FSTORE/FLOAD"
                          (store-and-load ..valid-float ..$Float::literal ..$Float::wrap [/.fstore /.fload] test)))))
        (<| (_.context "double")
            (let [test (!::= java/lang/Double "jvm deq" "jvm double =")]
              ($_ _.and
                  (_.lift "DSTORE_0/DLOAD_0"
                          (store-and-load ..valid-double ..$Double::literal ..$Double::wrap [(function.constant /.dstore-0) (function.constant /.dload-0)] test))
                  (_.lift "DSTORE_1/DLOAD_1"
                          (store-and-load ..valid-double ..$Double::literal ..$Double::wrap [(function.constant /.dstore-1) (function.constant /.dload-1)] test))
                  (_.lift "DSTORE_2/DLOAD_2"
                          (store-and-load ..valid-double ..$Double::literal ..$Double::wrap [(function.constant /.dstore-2) (function.constant /.dload-2)] test))
                  (_.lift "DSTORE_3/DLOAD_3"
                          (store-and-load ..valid-double ..$Double::literal ..$Double::wrap [(function.constant /.dstore-3) (function.constant /.dload-3)] test))
                  (_.lift "DSTORE/DLOAD"
                          (store-and-load ..valid-double ..$Double::literal ..$Double::wrap [/.dstore /.dload] test)))))
        (<| (_.context "object")
            (let [test (: (-> java/lang/String Any Bit)
                          (function (_ expected actual)
                            (|> actual (:coerce Text) (text\= (:coerce Text expected)))))]
              ($_ _.and
                  (_.lift "ASTORE_0/ALOAD_0"
                          (store-and-load ..$String::random ..$String::literal /.nop [(function.constant /.astore-0) (function.constant /.aload-0)] test))
                  (_.lift "ASTORE_1/ALOAD_1"
                          (store-and-load ..$String::random ..$String::literal /.nop [(function.constant /.astore-1) (function.constant /.aload-1)] test))
                  (_.lift "ASTORE_2/ALOAD_2"
                          (store-and-load ..$String::random ..$String::literal /.nop [(function.constant /.astore-2) (function.constant /.aload-2)] test))
                  (_.lift "ASTORE_3/ALOAD_3"
                          (store-and-load ..$String::random ..$String::literal /.nop [(function.constant /.astore-3) (function.constant /.aload-3)] test))
                  (_.lift "ASTORE/ALOAD"
                          (store-and-load ..$String::random ..$String::literal /.nop [/.astore /.aload] test)))))
        )))

(def: stack
  Test
  (do random.monad
    [expected/1 $String::random
     #let [object-test (: (-> Any Bit)
                          (|>> (:coerce Text) (text\= (:coerce Text expected/1))))]
     dummy/1 $String::random
     #let [single ($_ _.and
                      (<| (_.lift "DUP & POP")
                          (..bytecode object-test)
                          (do /.monad
                            [_ ($String::literal expected/1)
                             _ /.dup]
                            /.pop))
                      (<| (_.lift "DUP_X1 & POP2")
                          (..bytecode object-test)
                          (do /.monad
                            [_ ($String::literal dummy/1)
                             _ ($String::literal expected/1)
                             _ /.dup-x1]
                            /.pop2))
                      (<| (_.lift "DUP_X2")
                          (..bytecode object-test)
                          (do /.monad
                            [_ ($String::literal dummy/1)
                             _ ($String::literal dummy/1)
                             _ ($String::literal expected/1)
                             _ /.dup-x2
                             _ /.pop2]
                            /.pop))
                      (<| (_.lift "SWAP")
                          (..bytecode object-test)
                          (do /.monad
                            [_ ($String::literal dummy/1)
                             _ ($String::literal expected/1)
                             _ /.swap]
                            /.pop))
                      )]
     expected/2 $Long::random
     #let [long-test (: (-> Any Bit)
                        (|>> (:coerce Int) (i.= (:coerce Int expected/2))))]
     dummy/2 $Long::random
     #let [double ($_ _.and
                      (<| (_.lift "DUP2")
                          (..bytecode long-test)
                          (do /.monad
                            [_ ($Long::literal expected/2)
                             _ /.dup2
                             _ /.pop2]
                            ..$Long::wrap))
                      (<| (_.lift "DUP2_X1")
                          (..bytecode long-test)
                          (do /.monad
                            [_ ($String::literal dummy/1)
                             _ ($Long::literal expected/2)
                             _ /.dup2-x1
                             _ /.pop2
                             _ /.pop]
                            ..$Long::wrap))
                      (<| (_.lift "DUP2_X2")
                          (..bytecode long-test)
                          (do /.monad
                            [_ ($Long::literal dummy/2)
                             _ ($Long::literal expected/2)
                             _ /.dup2-x2
                             _ /.pop2
                             _ /.pop2]
                            ..$Long::wrap))
                      )]]
    ($_ _.and
        (<| (_.context "single")
            single)
        (<| (_.context "double")
            double)
        )))

(def: resource
  Test
  ($_ _.and
      (<| (_.context "registry")
          ..registry)
      (<| (_.context "stack")
          ..stack)
      ))

(def: return
  Test
  (let [primitive-return (: (All [a] (-> (Primitive a) (Bytecode Any) (Maybe (-> a (Bytecode Any))) (-> a Any Bit) (Random Bit)))
                            (function (_ primitive return substitute test)
                              (do random.monad
                                [class-name ..class-name
                                 primitive-method-name (random.ascii/upper-alpha 10)
                                 #let [primitive-method-type (/type.method [(list) (get@ #unboxed primitive) (list)])]
                                 object-method-name (|> (random.ascii/upper-alpha 10)
                                                        (random.filter (|>> (text\= primitive-method-name) not)))
                                 expected (get@ #random primitive)
                                 #let [$Self (/type.class class-name (list))]]
                                (wrap (case (do try.monad
                                              [class (/class.class /version.v6_0 /class.public
                                                                   (/name.internal class-name)
                                                                   (/name.internal "java.lang.Object")
                                                                   (list)
                                                                   (list)
                                                                   (list (/method.method ..method-modifier
                                                                                         primitive-method-name
                                                                                         primitive-method-type
                                                                                         (list)
                                                                                         (#.Some (do /.monad
                                                                                                   [_ ((get@ #literal primitive) expected)]
                                                                                                   return)))
                                                                         (/method.method ..method-modifier
                                                                                         object-method-name
                                                                                         (/type.method [(list) (get@ #boxed primitive) (list)])
                                                                                         (list)
                                                                                         (#.Some (do /.monad
                                                                                                   [_ (/.invokestatic $Self primitive-method-name primitive-method-type)
                                                                                                    _ (case substitute
                                                                                                        #.None
                                                                                                        (wrap [])

                                                                                                        (#.Some substitute)
                                                                                                        (substitute expected))
                                                                                                    _ (get@ #wrap primitive)]
                                                                                                   /.areturn))))
                                                                   (row.row))
                                               #let [bytecode (format.run /class.writer class)
                                                     loader (/loader.memory (/loader.new-library []))]
                                               _ (/loader.define class-name bytecode loader)
                                               class (io.run (/loader.load class-name loader))
                                               method (host.try (get-method object-method-name class))]
                                              (java/lang/reflect/Method::invoke (host.null) (host.array java/lang/Object 0) method))
                                        (#try.Success actual)
                                        (test expected actual)

                                        (#try.Failure error)
                                        false)
                                      ))))]
    ($_ _.and
        (_.lift "IRETURN" (primitive-return ..$Integer::primitive /.ireturn #.None (!::= java/lang/Integer "jvm ieq" "jvm int =")))
        (_.lift "LRETURN" (primitive-return ..$Long::primitive /.lreturn #.None (!::= java/lang/Long "jvm leq" "jvm long =")))
        (_.lift "FRETURN" (primitive-return ..$Float::primitive /.freturn #.None (!::= java/lang/Float "jvm feq" "jvm float =")))
        (_.lift "DRETURN" (primitive-return ..$Double::primitive /.dreturn #.None (!::= java/lang/Double "jvm deq" "jvm double =")))
        (_.lift "ARETURN" (primitive-return ..$String::primitive /.areturn #.None (function (_ expected actual) (text\= (:coerce Text expected) (:coerce Text actual)))))
        (_.lift "RETURN" (primitive-return (: (Primitive java/lang/String)
                                              {#unboxed /type.void
                                               #boxed ..$String
                                               #wrap /.nop
                                               #random ..$String::random
                                               #literal (function.constant /.nop)})
                                           /.return
                                           (#.Some ..$String::literal)
                                           (function (_ expected actual) (text\= (:coerce Text expected) (:coerce Text actual)))))
        )))

(def: branching
  Test
  (do random.monad
    [expected ..$Long::random
     dummy ..$Long::random
     #let [if! (: (-> (-> Label (Bytecode Any)) (Bytecode Any) (Random Bit))
                  (function (_ instruction prelude)
                    (<| (..bytecode ((!::= java/lang/Long "jvm leq" "jvm long =") expected))
                        (do /.monad
                          [@then /.new-label
                           @end /.new-label
                           _ prelude
                           _ (instruction @then)
                           _ (..$Long::literal dummy)
                           _ (/.goto @end)
                           _ (/.set-label @then)
                           _ (..$Long::literal expected)
                           _ (/.set-label @end)]
                          ..$Long::wrap))))
           comparison-against-zero ($_ _.and
                                       (_.lift "IFEQ" (if! /.ifeq /.iconst-0))
                                       (_.lift "IFNE" (if! /.ifne /.iconst-1))
                                       (_.lift "IFLT" (if! /.iflt /.iconst-m1))
                                       (_.lift "IFLE" (if! /.ifle /.iconst-0))
                                       (_.lift "IFGT" (if! /.ifgt /.iconst-1))
                                       (_.lift "IFGE" (if! /.ifge /.iconst-0)))
           null-test ($_ _.and
                         (_.lift "IFNULL" (if! /.ifnull /.aconst-null))
                         (_.lift "IFNONNULL" (if! /.ifnonnull (/.string ""))))]
     reference ..$Integer::random
     subject (|> ..$Integer::random
                 (random.filter (|>> ((!::= java/lang/Integer "jvm ieq" "jvm int =") reference) not)))
     #let [[lesser greater] (if (for {@.old
                                      ("jvm ilt" reference subject)
                                      
                                      @.jvm
                                      ("jvm int <" ("jvm object cast" subject) ("jvm object cast" reference))})
                              [reference subject]
                              [subject reference])
           int-comparison ($_ _.and
                              (_.lift "IF_ICMPEQ" (if! /.if-icmpeq (do /.monad [_ (..$Integer::literal reference)] /.dup)))
                              (_.lift "IF_ICMPNE" (if! /.if-icmpne (do /.monad [_ (..$Integer::literal reference)] (..$Integer::literal subject))))
                              (_.lift "IF_ICMPLT" (if! /.if-icmplt (do /.monad [_ (..$Integer::literal lesser)] (..$Integer::literal greater))))
                              (_.lift "IF_ICMPLE" (if! /.if-icmple (do /.monad [_ (..$Integer::literal lesser)] (..$Integer::literal greater))))
                              (_.lift "IF_ICMPGT" (if! /.if-icmpgt (do /.monad [_ (..$Integer::literal greater)] (..$Integer::literal lesser))))
                              (_.lift "IF_ICMPGE" (if! /.if-icmpge (do /.monad [_ (..$Integer::literal greater)] (..$Integer::literal lesser)))))
           new-object (: (Bytecode Any)
                         (do /.monad
                           [_ (/.new ..$Object)
                            _ /.dup]
                           (/.invokespecial ..$Object "<init>" (/type.method [(list) /type.void (list)]))))
           reference-comparison ($_ _.and
                                    (_.lift "IF_ACMPEQ" (if! /.if-acmpeq (do /.monad [_ new-object] /.dup)))
                                    (_.lift "IF_ACMPNE" (if! /.if-acmpne (do /.monad [_ new-object] new-object)))
                                    )]]
    ($_ _.and
        comparison-against-zero
        null-test
        int-comparison
        reference-comparison
        )))

(def: jump
  Test
  (do random.monad
    [expected ..$Long::random
     dummy ..$Long::random
     #let [jump (: (-> (-> Label (Bytecode Any)) (Random Bit))
                   (function (_ goto)
                     (<| (..bytecode ((!::= java/lang/Long "jvm leq" "jvm long =") expected))
                         (do /.monad
                           [@skipped /.new-label
                            @value /.new-label
                            @end /.new-label
                            _ (goto @value)
                            _ (/.set-label @skipped)
                            _ (..$Long::literal dummy)
                            _ (goto @end)
                            _ (/.set-label @value)
                            _ (..$Long::literal expected)
                            _ (/.set-label @end)]
                           ..$Long::wrap))))]]
    ($_ _.and
        (_.lift "GOTO" (jump /.goto))
        (_.lift "GOTO_W" (jump /.goto-w)))))

(def: switch
  Test
  ($_ _.and
      (<| (_.lift "TABLESWITCH")
          (do {! random.monad}
            [expected ..$Long::random
             dummy ..$Long::random
             minimum (\ ! map (|>> (n.% 100) .int /signed.s4 try.assume)
                        random.nat)
             afterwards (\ ! map (n.% 10) random.nat)])
          (..bytecode ((!::= java/lang/Long "jvm leq" "jvm long =") expected))
          (do /.monad
            [@right /.new-label
             @wrong /.new-label
             @return /.new-label
             _ (/.bipush (|> minimum /signed.value .int /signed.s1 try.assume))
             _ (/.tableswitch minimum @wrong [@right (list.repeat afterwards @wrong)])
             _ (/.set-label @wrong)
             _ (..$Long::literal dummy)
             _ (/.goto @return)
             _ (/.set-label @right)
             _ (..$Long::literal expected)
             _ (/.set-label @return)]
            ..$Long::wrap))
      (<| (_.lift "LOOKUPSWITCH")
          (do {! random.monad}
            [options (\ ! map (|>> (n.% 10) (n.+ 1))
                        random.nat)
             choice (\ ! map (n.% options) random.nat)
             options (|> random.int
                         (\ ! map (|>> (:coerce java/lang/Long) host.long-to-int host.int-to-long (:coerce Int)))
                         (random.set i.hash options)
                         (\ ! map set.to-list))
             #let [choice (maybe.assume (list.nth choice options))]
             expected ..$Long::random
             dummy ..$Long::random])
          (..bytecode ((!::= java/lang/Long "jvm leq" "jvm long =") expected))
          (do /.monad
            [@right /.new-label
             @wrong /.new-label
             @return /.new-label
             _ (..$Integer::literal (host.long-to-int (:coerce java/lang/Long choice)))
             _ (/.lookupswitch @wrong (list\map (function (_ option)
                                                  [(|> option /signed.s4 try.assume)
                                                   (if (i.= choice option) @right @wrong)])
                                                options))
             _ (/.set-label @wrong)
             _ (..$Long::literal dummy)
             _ (/.goto @return)
             _ (/.set-label @right)
             _ (..$Long::literal expected)
             _ (/.set-label @return)]
            ..$Long::wrap))
      ))

(def: exception
  Test
  (do random.monad
    [expected ..$Long::random
     dummy ..$Long::random
     exception ..$String::random]
    (<| (_.lift "ATHROW")
        (..bytecode ((!::= java/lang/Long "jvm leq" "jvm long =") expected))
        (do /.monad
          [#let [$Exception (/type.class "java.lang.Exception" (list))]
           @skipped /.new-label
           @try /.new-label
           @handler /.new-label
           @return /.new-label
           _ (/.try @try @handler @handler $Exception)
           _ (/.set-label @try)
           _ (/.new $Exception)
           _ /.dup
           _ (..$String::literal exception)
           _ (/.invokespecial $Exception "<init>" (/type.method [(list ..$String) /type.void (list)]))
           _ /.athrow
           _ (/.set-label @skipped)
           _ (..$Long::literal dummy)
           _ (/.goto @return)
           _ (/.set-label @handler)
           _ /.pop
           _ (..$Long::literal expected)
           _ (/.set-label @return)]
          ..$Long::wrap))))

(def: code
  Test
  ($_ _.and
      (<| (_.context "return")
          ..return)
      (<| (_.context "branching")
          ..branching)
      (<| (_.context "jump")
          ..jump)
      (<| (_.context "switch")
          ..switch)
      (<| (_.context "exception")
          ..exception)
      ))

(def: instruction
  Test
  ($_ _.and
      (<| (_.context "value")
          ..value)
      (<| (_.context "resource")
          ..resource)
      (<| (_.context "code")
          ..code)
      ))

(def: inheritance
  Test
  (do random.monad
    [abstract-class ..class-name
     interface-class (|> ..class-name
                         (random.filter (|>> (text\= abstract-class) not)))
     concrete-class (|> ..class-name
                        (random.filter (function (_ class)
                                         (not (or (text\= abstract-class class)
                                                  (text\= interface-class class))))))
     part0 ..$Long::random
     part1 ..$Long::random
     part2 ..$Long::random
     fake-part2 ..$Long::random
     part3 ..$Long::random
     part4 ..$Long::random
     #let [expected ($_ i.+
                        (:coerce Int part0)
                        (:coerce Int part1)
                        (:coerce Int part2)
                        (:coerce Int part3)
                        (:coerce Int part4))
           $Concrete (/type.class concrete-class (list))
           $Abstract (/type.class abstract-class (list))
           $Interface (/type.class interface-class (list))

           constructor::type (/type.method [(list) /type.void (list)])
           method::type (/type.method [(list) /type.long (list)])

           inherited-method "inherited_method"
           overriden-method "overriden_method"
           abstract-method "abstract_method"
           interface-method "interface_method"
           virtual-method "virtual_method"
           static-method "static_method"

           method (: (-> Text java/lang/Long (Resource Method))
                     (function (_ name value)
                       (/method.method /method.public
                                       name
                                       method::type
                                       (list)
                                       (#.Some (do /.monad
                                                 [_ (..$Long::literal value)]
                                                 /.lreturn)))))

           interface-bytecode (|> (/class.class /version.v6_0 ($_ /modifier\compose /class.public /class.abstract /class.interface)
                                                (/name.internal interface-class)
                                                (/name.internal "java.lang.Object")
                                                (list)
                                                (list)
                                                (list (/method.method ($_ /modifier\compose /method.public /method.abstract)
                                                                      interface-method method::type (list) #.None))
                                                (row.row))
                                  try.assume
                                  (format.run /class.writer))
           abstract-bytecode (|> (/class.class /version.v6_0 ($_ /modifier\compose /class.public /class.abstract)
                                               (/name.internal abstract-class)
                                               (/name.internal "java.lang.Object")
                                               (list)
                                               (list)
                                               (list (/method.method /method.public
                                                                     "<init>"
                                                                     constructor::type
                                                                     (list)
                                                                     (#.Some (do /.monad
                                                                               [_ /.aload-0
                                                                                _ (/.invokespecial ..$Object "<init>" constructor::type)]
                                                                               /.return)))
                                                     (method inherited-method part0)
                                                     (method overriden-method fake-part2)
                                                     (/method.method ($_ /modifier\compose /method.public /method.abstract)
                                                                     abstract-method method::type (list) #.None))
                                               (row.row))
                                 try.assume
                                 (format.run /class.writer))
           invoke (: (-> (Type Class) Text (Bytecode Any))
                     (function (_ class method)
                       (do /.monad
                         [_ /.aload-0]
                         (/.invokevirtual class method method::type))))
           concrete-bytecode (|> (/class.class /version.v6_0 /class.public
                                               (/name.internal concrete-class)
                                               (/name.internal abstract-class)
                                               (list (/name.internal interface-class))
                                               (list)
                                               (list (/method.method /method.public
                                                                     "<init>"
                                                                     constructor::type
                                                                     (list)
                                                                     (#.Some (do /.monad
                                                                               [_ /.aload-0
                                                                                _ (/.invokespecial $Abstract "<init>" constructor::type)]
                                                                               /.return)))
                                                     (method virtual-method part1)
                                                     (method overriden-method part2)
                                                     (method abstract-method part3)
                                                     (method interface-method part4)
                                                     (/method.method ($_ /modifier\compose
                                                                         /method.public
                                                                         /method.static)
                                                                     static-method
                                                                     (/type.method [(list) ..$Long (list)])
                                                                     (list)
                                                                     (#.Some (do /.monad
                                                                               [_ (/.new $Concrete)
                                                                                _ /.dup
                                                                                _ (/.invokespecial $Concrete "<init>" constructor::type)
                                                                                _ /.astore-0
                                                                                _ (invoke $Abstract inherited-method)
                                                                                _ (invoke $Concrete virtual-method)
                                                                                _ /.ladd
                                                                                _ (invoke $Abstract overriden-method)
                                                                                _ /.ladd
                                                                                _ /.aload-0 _ (/.invokeinterface $Interface interface-method method::type)
                                                                                _ /.ladd
                                                                                _ (invoke $Abstract abstract-method)
                                                                                _ /.ladd
                                                                                _ ..$Long::wrap]
                                                                               /.areturn))))
                                               (row.row))
                                 try.assume
                                 (format.run /class.writer))
           loader (/loader.memory (/loader.new-library []))]]
    (_.test "Class & interface inheritance"
            (case (do try.monad
                    [_ (/loader.define abstract-class abstract-bytecode loader)
                     _ (/loader.define interface-class interface-bytecode loader)
                     _ (/loader.define concrete-class concrete-bytecode loader)
                     class (io.run (/loader.load concrete-class loader))
                     method (host.try (get-method static-method class))
                     output (java/lang/reflect/Method::invoke (host.null) (host.array java/lang/Object 0) method)]
                    (wrap (:coerce Int output)))
              (#try.Success actual)
              (i.= (:coerce Int expected) (:coerce Int actual))

              (#try.Failure error)
              false))))

(def: #export test
  Test
  (<| (_.context (%.name (name-of .._)))
      ($_ _.and
          (<| (_.context "instruction")
              ..instruction)
          (<| (_.context "inheritance")
              ..inheritance)
          )))
