(.module:
  [library
   [lux (#- Type type primitive int)
    ["." ffi (#+ import:)]
    ["@" target]
    [abstract
     ["." monad (#+ do)]]
    [control
     ["." function]
     ["." io]
     ["." try]
     [concurrency
      ["." atom]]]
    [data
     ["." maybe]
     ["." bit ("#\." equivalence)]
     ["." text ("#\." equivalence)
      ["%" format (#+ format)]]
     ["." format #_
      ["#" binary]]
     [collection
      ["." array]
      ["." dictionary]
      ["." row]
      ["." set]
      ["." list ("#\." functor)]]]
    [math
     ["." random (#+ Random) ("#\." monad)]
     [number
      ["n" nat]
      ["i" int]
      ["f" frac]
      ["." i32 (#+ I32)]
      ["." i64]]]
    ["_" test (#+ Test)]]]
  [\\library
   ["." / #_
    ["#." loader (#+ Library)]
    ["#." version]
    ["#." modifier ("#\." monoid)]
    ["#." field]
    ["#." method (#+ Method)]
    ["#." class]
    ["#." attribute
     ["#/." code]]
    ["#." constant
     ["#/." pool (#+ Resource)]]
    [encoding
     ["#." name]
     ["#." signed]
     ["#." unsigned]]
    ["#" bytecode (#+ Label Bytecode)
     ["#." instruction]]
    ["#." type (#+ Type)
     ["." category (#+ Value Object Class)]]]])

(def: method_modifier
  ($_ /modifier\compose
      /method.public
      /method.static))

(import: java/lang/Boolean)
(import: java/lang/Byte)
(import: java/lang/Short)
(import: java/lang/Integer)
(import: java/lang/Long)
(import: java/lang/Float)
(import: java/lang/Double
  ["#::."
   (#static compare [double double] int)])
(import: java/lang/Character)
(import: java/lang/String)

(import: java/lang/reflect/Method
  ["#::."
   (invoke [java/lang/Object [java/lang/Object]] #try java/lang/Object)])

(import: (java/lang/Class c)
  ["#::."
   (getDeclaredMethod [java/lang/String [(java/lang/Class [? < java/lang/Object])]] java/lang/reflect/Method)])

(import: java/lang/Object
  ["#::."
   (getClass [] (java/lang/Class java/lang/Object))
   (toString [] java/lang/String)])

(def: class_name
  (Random Text)
  (do random.monad
    [super_package (random.ascii/lower 10)
     package (random.ascii/lower 10)
     name (random.ascii/upper 10)]
    (wrap (format super_package
                  /name.external_separator package
                  /name.external_separator name))))

(def: (get_method name class)
  (-> Text (java/lang/Class java/lang/Object) java/lang/reflect/Method)
  (java/lang/Class::getDeclaredMethod name
                                      (ffi.array (java/lang/Class java/lang/Object) 0)
                                      class))

(def: $Object (/type.class "java.lang.Object" (list)))

(def: (bytecode test bytecode)
  (-> (-> Any Bit) (Bytecode Any) (Random Bit))
  (do random.monad
    [class_name ..class_name
     method_name (random.ascii/upper 10)]
    (wrap (case (do try.monad
                  [class (/class.class /version.v6_0 /class.public
                                       (/name.internal class_name)
                                       (/name.internal "java.lang.Object")
                                       (list)
                                       (list)
                                       (list (/method.method ..method_modifier
                                                             method_name
                                                             (/type.method [(list) ..$Object (list)])
                                                             (list)
                                                             (#.Some (do /.monad
                                                                       [_ bytecode]
                                                                       /.areturn))))
                                       (row.row))
                   #let [bytecode (format.run /class.writer class)
                         loader (/loader.memory (/loader.new_library []))]
                   _ (/loader.define class_name bytecode loader)
                   class (io.run (/loader.load class_name loader))
                   method (try (get_method method_name class))]
                  (java/lang/reflect/Method::invoke (ffi.null) (ffi.array java/lang/Object 0) method))
            (#try.Success actual)
            (test actual)
            
            (#try.Failure error)
            false))))

(type: (Primitive a)
  {#unboxed (Type category.Return)
   #boxed (Type category.Class)
   #wrap (Bytecode Any)
   #random (Random a)
   #literal (-> a (Bytecode Any))})

(def: $Boolean
  (/type.class "java.lang.Boolean" (list)))
(def: $Boolean::wrap
  (/.invokestatic ..$Boolean "valueOf" (/type.method [(list /type.boolean) ..$Boolean (list)])))
(def: $Boolean::random (:as (Random java/lang/Boolean) random.bit))
(def: !false (|> 0 .i64 i32.i32 /.int))
(def: !true (|> 1 .i64 i32.i32 /.int))
(def: ($Boolean::literal value)
  (-> java/lang/Boolean (Bytecode Any))
  (if (:as Bit value)
    ..!true
    ..!false))
(def: $Boolean::primitive
  (Primitive java/lang/Boolean)
  {#unboxed /type.boolean
   #boxed ..$Boolean
   #wrap ..$Boolean::wrap
   #random ..$Boolean::random
   #literal ..$Boolean::literal})

(def: $Byte
  (/type.class "java.lang.Byte" (list)))
(def: $Byte::wrap
  (/.invokestatic ..$Byte "valueOf" (/type.method [(list /type.byte) ..$Byte (list)])))
(def: $Byte::random
  (Random java/lang/Byte)
  (\ random.monad map (|>> (:as java/lang/Long) ffi.long_to_byte) random.int))
(def: $Byte::literal
  (-> java/lang/Byte (Bytecode Any))
  (|>> ffi.byte_to_long (:as I64) i32.i32 /.int))
(def: $Byte::primitive
  (Primitive java/lang/Byte)
  {#unboxed /type.byte
   #boxed ..$Byte
   #wrap ..$Byte::wrap
   #random ..$Byte::random
   #literal ..$Byte::literal})

(def: $Short
  (/type.class "java.lang.Short" (list)))
(def: $Short::wrap
  (/.invokestatic ..$Short "valueOf" (/type.method [(list /type.short) ..$Short (list)])))
(def: $Short::random
  (Random java/lang/Short)
  (\ random.monad map (|>> (:as java/lang/Long) ffi.long_to_short) random.int))
(def: $Short::literal
  (-> java/lang/Short (Bytecode Any))
  (|>> ffi.short_to_long (:as I64) i32.i32 /.int))
(def: $Short::primitive
  (Primitive java/lang/Short)
  {#unboxed /type.short
   #boxed ..$Short
   #wrap ..$Short::wrap
   #random ..$Short::random
   #literal ..$Short::literal})

(def: $Integer
  (/type.class "java.lang.Integer" (list)))
(def: $Integer::wrap
  (/.invokestatic ..$Integer "valueOf" (/type.method [(list /type.int) ..$Integer (list)])))
(def: $Integer::random
  (Random java/lang/Integer)
  (\ random.monad map (|>> (:as java/lang/Long) ffi.long_to_int) random.int))
(def: $Integer::literal
  (-> java/lang/Integer (Bytecode Any))
  (|>> ffi.int_to_long (:as I64) i32.i32 /.int))
(def: $Integer::primitive
  (Primitive java/lang/Integer)
  {#unboxed /type.int
   #boxed ..$Integer
   #wrap ..$Integer::wrap
   #random ..$Integer::random
   #literal ..$Integer::literal})

(def: $Long (/type.class "java.lang.Long" (list)))
(def: $Long::wrap (/.invokestatic ..$Long "valueOf" (/type.method [(list /type.long) ..$Long (list)])))
(def: $Long::random (:as (Random java/lang/Long) random.int))
(def: $Long::literal (-> java/lang/Long (Bytecode Any)) (|>> (:as Int) /.long))
(def: $Long::primitive
  (Primitive java/lang/Long)
  {#unboxed /type.long
   #boxed ..$Long
   #wrap ..$Long::wrap
   #random ..$Long::random
   #literal ..$Long::literal})

(def: $Float (/type.class "java.lang.Float" (list)))
(def: $Float::wrap (/.invokestatic ..$Float "valueOf" (/type.method [(list /type.float) ..$Float (list)])))
(def: $Float::random
  (Random java/lang/Float)
  (\ random.monad map
     (|>> (:as java/lang/Double) ffi.double_to_float)
     random.frac))
(def: $Float::literal /.float)
(def: valid_float
  (Random java/lang/Float)
  (random.filter (|>> ffi.float_to_double (:as Frac) f.not_a_number? not)
                 ..$Float::random))
(def: $Float::primitive
  (Primitive java/lang/Float)
  {#unboxed /type.float
   #boxed ..$Float
   #wrap ..$Float::wrap
   #random ..valid_float
   #literal ..$Float::literal})

(def: $Double (/type.class "java.lang.Double" (list)))
(def: $Double::wrap (/.invokestatic ..$Double "valueOf" (/type.method [(list /type.double) ..$Double (list)])))
(def: $Double::random (:as (Random java/lang/Double) random.frac))
(def: $Double::literal
  (-> java/lang/Double (Bytecode Any))
  /.double)
(def: valid_double
  (Random java/lang/Double)
  (random.filter (|>> (:as Frac) f.not_a_number? not)
                 ..$Double::random))
(def: $Double::primitive
  (Primitive java/lang/Double)
  {#unboxed /type.double
   #boxed ..$Double
   #wrap ..$Double::wrap
   #random ..valid_double
   #literal ..$Double::literal})

(def: $Character
  (/type.class "java.lang.Character" (list)))
(def: $Character::wrap
  (/.invokestatic ..$Character "valueOf" (/type.method [(list /type.char) ..$Character (list)])))
(def: $Character::random
  (Random java/lang/Character)
  (\ random.monad map (|>> (:as java/lang/Long) ffi.long_to_int ffi.int_to_char) random.int))
(def: $Character::literal
  (-> java/lang/Character (Bytecode Any))
  (|>> ffi.char_to_long (:as I64) i32.i32 /.int))
(def: $Character::primitive
  (Primitive java/lang/Character)
  {#unboxed /type.char
   #boxed ..$Character
   #wrap ..$Character::wrap
   #random ..$Character::random
   #literal ..$Character::literal})

(def: $String
  (/type.class "java.lang.String" (list)))

(def: $String::random
  (:as (Random java/lang/String)
       (random.ascii/alpha 10)))

(def: $String::literal
  (-> java/lang/String (Bytecode Any))
  (|>> (:as Text) /.string))

(def: $String::primitive
  (Primitive java/lang/String)
  {#unboxed ..$String
   #boxed ..$String
   #wrap /.nop
   #random ..$String::random
   #literal ..$String::literal})

(template [<name> <bits> <type> <push> <wrap> <message> <to_long> <signed>]
  [(def: <name>
     Test
     (do {! random.monad}
       [expected (\ ! map (i64.and (i64.mask <bits>)) random.nat)]
       (<| (_.lift <message>)
           (..bytecode (for {@.old
                             (|>> (:as <type>) <to_long> ("jvm leq" expected))
                             @.jvm
                             (|>> (:as <type>) <to_long> "jvm object cast" ("jvm long =" ("jvm object cast" (:as java/lang/Long expected))))}))
           (do /.monad
             [_ (<push> (|> expected .int <signed> try.assume))]
             <wrap>))))]

  [byte 7 java/lang/Byte /.bipush ..$Byte::wrap "BIPUSH" ffi.byte_to_long /signed.s1]
  [short 15 java/lang/Short /.sipush ..$Short::wrap "SIPUSH" ffi.short_to_long /signed.s2]
  )

(template [<name> <type>]
  [(template: (<name> <old_extension> <new_extension>)
     (: (-> <type> <type> <type>)
        (function (_ parameter subject)
          (for {@.old
                (<old_extension> subject parameter)
                
                @.jvm
                ("jvm object cast"
                 (<new_extension> ("jvm object cast" parameter)
                                  ("jvm object cast" subject)))}))))]

  [int/2 java/lang/Integer]
  [long/2 java/lang/Long]
  [float/2 java/lang/Float]
  [double/2 java/lang/Double]
  )

(template: (int+long/2 <old_extension> <new_extension>)
  (: (-> java/lang/Integer java/lang/Long java/lang/Long)
     (function (_ parameter subject)
       (for {@.old
             (<old_extension> subject parameter)
             
             @.jvm
             ("jvm object cast"
              (<new_extension> ("jvm object cast" parameter)
                               ("jvm object cast" subject)))}))))

(def: int
  Test
  (let [int (: (-> java/lang/Integer (Bytecode Any) (Random Bit))
               (function (_ expected bytecode)
                 (<| (..bytecode (for {@.old
                                       (|>> (:as java/lang/Integer) ("jvm ieq" expected))
                                       
                                       @.jvm
                                       (|>> (:as java/lang/Integer) "jvm object cast" ("jvm int =" ("jvm object cast" expected)))}))
                     (do /.monad
                       [_ bytecode]
                       ..$Integer::wrap))))
        unary (: (-> (-> java/lang/Integer java/lang/Integer) (Bytecode Any) (Random Bit))
                 (function (_ reference instruction)
                   (do random.monad
                     [subject ..$Integer::random]
                     (int (reference subject)
                          (do /.monad
                            [_ (..$Integer::literal subject)]
                            instruction)))))
        binary (: (-> (-> java/lang/Integer java/lang/Integer java/lang/Integer)
                      (Bytecode Any)
                      (Random Bit))
                  (function (_ reference instruction)
                    (do random.monad
                      [parameter ..$Integer::random
                       subject ..$Integer::random]
                      (int (reference parameter subject)
                           (do /.monad
                             [_ (..$Integer::literal subject)
                              _ (..$Integer::literal parameter)]
                             instruction)))))
        shift (: (-> (-> java/lang/Integer java/lang/Integer java/lang/Integer) (Bytecode Any) (Random Bit))
                 (function (_ reference instruction)
                   (do {! random.monad}
                     [parameter (\ ! map (|>> (n.% 32) .int (:as java/lang/Long) ffi.long_to_int) random.nat)
                      subject ..$Integer::random]
                     (int (reference parameter subject)
                          (do /.monad
                            [_ (..$Integer::literal subject)
                             _ (..$Integer::literal parameter)]
                            instruction)))))
        literal ($_ _.and
                    (_.lift "ICONST_M1" (int (ffi.long_to_int (:as java/lang/Long -1)) /.iconst_m1))
                    (_.lift "ICONST_0" (int (ffi.long_to_int (:as java/lang/Long +0)) /.iconst_0))
                    (_.lift "ICONST_1" (int (ffi.long_to_int (:as java/lang/Long +1)) /.iconst_1))
                    (_.lift "ICONST_2" (int (ffi.long_to_int (:as java/lang/Long +2)) /.iconst_2))
                    (_.lift "ICONST_3" (int (ffi.long_to_int (:as java/lang/Long +3)) /.iconst_3))
                    (_.lift "ICONST_4" (int (ffi.long_to_int (:as java/lang/Long +4)) /.iconst_4))
                    (_.lift "ICONST_5" (int (ffi.long_to_int (:as java/lang/Long +5)) /.iconst_5))
                    (_.lift "LDC_W/INTEGER"
                            (do random.monad
                              [expected ..$Integer::random]
                              (int expected (..$Integer::literal expected)))))
        arithmetic ($_ _.and
                       (_.lift "IADD" (binary (int/2 "jvm iadd" "jvm int +") /.iadd))
                       (_.lift "ISUB" (binary (int/2 "jvm isub" "jvm int -") /.isub))
                       (_.lift "IMUL" (binary (int/2 "jvm imul" "jvm int *") /.imul))
                       (_.lift "IDIV" (binary (int/2 "jvm idiv" "jvm int /") /.idiv))
                       (_.lift "IREM" (binary (int/2 "jvm irem" "jvm int %") /.irem))
                       (_.lift "INEG" (unary (function (_ value)
                                               ((int/2 "jvm isub" "jvm int -")
                                                value
                                                (ffi.long_to_int (:as java/lang/Long +0))))
                                             /.ineg)))
        bitwise ($_ _.and
                    (_.lift "IAND" (binary (int/2 "jvm iand" "jvm int and") /.iand))
                    (_.lift "IOR" (binary (int/2 "jvm ior" "jvm int or") /.ior))
                    (_.lift "IXOR" (binary (int/2 "jvm ixor" "jvm int xor") /.ixor))
                    (_.lift "ISHL" (shift (int/2 "jvm ishl" "jvm int shl") /.ishl))
                    (_.lift "ISHR" (shift (int/2 "jvm ishr" "jvm int shr") /.ishr))
                    (_.lift "IUSHR" (shift (int/2 "jvm iushr" "jvm int ushr") /.iushr)))]
    ($_ _.and
        (<| (_.context "literal")
            literal)
        (<| (_.context "arithmetic")
            arithmetic)
        (<| (_.context "bitwise")
            bitwise)
        )))

(def: long
  Test
  (let [long (: (-> java/lang/Long (Bytecode Any) (Random Bit))
                (function (_ expected bytecode)
                  (<| (..bytecode (for {@.old
                                        (|>> (:as Int) (i.= expected))
                                        
                                        @.jvm
                                        (|>> (:as java/lang/Long) "jvm object cast" ("jvm long =" ("jvm object cast" expected)))}))
                      (do /.monad
                        [_ bytecode]
                        ..$Long::wrap))))
        unary (: (-> (-> java/lang/Long java/lang/Long) (Bytecode Any) (Random Bit))
                 (function (_ reference instruction)
                   (do random.monad
                     [subject ..$Long::random]
                     (long (reference subject)
                           (do /.monad
                             [_ (..$Long::literal subject)]
                             instruction)))))
        binary (: (-> (-> java/lang/Long java/lang/Long java/lang/Long) (Bytecode Any) (Random Bit))
                  (function (_ reference instruction)
                    (do random.monad
                      [parameter ..$Long::random
                       subject ..$Long::random]
                      (long (reference parameter subject)
                            (do /.monad
                              [_ (..$Long::literal subject)
                               _ (..$Long::literal parameter)]
                              instruction)))))
        shift (: (-> (-> java/lang/Integer java/lang/Long java/lang/Long) (Bytecode Any) (Random Bit))
                 (function (_ reference instruction)
                   (do {! random.monad}
                     [parameter (\ ! map (|>> (n.% 64) (:as java/lang/Long)) random.nat)
                      subject ..$Long::random]
                     (long (reference (ffi.long_to_int parameter) subject)
                           (do /.monad
                             [_ (..$Long::literal subject)
                              _ (..$Integer::literal (ffi.long_to_int parameter))]
                             instruction)))))
        literal ($_ _.and
                    (_.lift "LCONST_0" (long (:as java/lang/Long +0) /.lconst_0))
                    (_.lift "LCONST_1" (long (:as java/lang/Long +1) /.lconst_1))
                    (_.lift "LDC2_W/LONG"
                            (do random.monad
                              [expected ..$Long::random]
                              (long expected (..$Long::literal expected)))))
        arithmetic ($_ _.and
                       (_.lift "LADD" (binary (long/2 "jvm ladd" "jvm long +") /.ladd))
                       (_.lift "LSUB" (binary (long/2 "jvm lsub" "jvm long -") /.lsub))
                       (_.lift "LMUL" (binary (long/2 "jvm lmul" "jvm long *") /.lmul))
                       (_.lift "LDIV" (binary (long/2 "jvm ldiv" "jvm long /") /.ldiv))
                       (_.lift "LREM" (binary (long/2 "jvm lrem" "jvm long %") /.lrem))
                       (_.lift "LNEG" (unary (function (_ value)
                                               ((long/2 "jvm lsub" "jvm long -")
                                                value
                                                (:as java/lang/Long +0)))
                                             /.lneg)))
        bitwise ($_ _.and
                    (_.lift "LAND" (binary (long/2 "jvm land" "jvm long and") /.land))
                    (_.lift "LOR" (binary (long/2 "jvm lor" "jvm long or") /.lor))
                    (_.lift "LXOR" (binary (long/2 "jvm lxor" "jvm long xor") /.lxor))
                    (_.lift "LSHL" (shift (int+long/2 "jvm lshl" "jvm long shl") /.lshl))
                    (_.lift "LSHR" (shift (int+long/2 "jvm lshr" "jvm long shr") /.lshr))
                    (_.lift "LUSHR" (shift (int+long/2 "jvm lushr" "jvm long ushr") /.lushr)))
        comparison (_.lift "LCMP"
                           (do random.monad
                             [reference ..$Long::random
                              subject ..$Long::random
                              #let [expected (cond (i.= (:as Int reference) (:as Int subject))
                                                   (:as java/lang/Long +0)

                                                   (i.> (:as Int reference) (:as Int subject))
                                                   (:as java/lang/Long +1)

                                                   ## (i.< (:as Int reference) (:as Int subject))
                                                   (:as java/lang/Long -1))]]
                             (<| (..bytecode (for {@.old
                                                   (|>> (:as Int) (i.= expected))
                                                   
                                                   @.jvm
                                                   (|>> (:as java/lang/Long) "jvm object cast" ("jvm long =" ("jvm object cast" expected)))}))
                                 (do /.monad
                                   [_ (..$Long::literal subject)
                                    _ (..$Long::literal reference)
                                    _ /.lcmp
                                    _ /.i2l]
                                   ..$Long::wrap))))]
    ($_ _.and
        (<| (_.context "literal")
            literal)
        (<| (_.context "arithmetic")
            arithmetic)
        (<| (_.context "bitwise")
            bitwise)
        (<| (_.context "comparison")
            comparison)
        )))

(def: float
  Test
  (let [float (: (-> java/lang/Float (Bytecode Any) (Random Bit))
                 (function (_ expected bytecode)
                   (<| (..bytecode (for {@.old
                                         (function (_ actual)
                                           (or (|> actual (:as java/lang/Float) ("jvm feq" expected))
                                               (and (f.not_a_number? (:as Frac (ffi.float_to_double expected)))
                                                    (f.not_a_number? (:as Frac (ffi.float_to_double (:as java/lang/Float actual)))))))
                                         
                                         @.jvm
                                         (function (_ actual)
                                           (or (|> actual (:as java/lang/Float) "jvm object cast" ("jvm float =" ("jvm object cast" expected)))
                                               (and (f.not_a_number? (:as Frac (ffi.float_to_double expected)))
                                                    (f.not_a_number? (:as Frac (ffi.float_to_double (:as java/lang/Float actual)))))))}))
                       (do /.monad
                         [_ bytecode]
                         ..$Float::wrap))))
        unary (: (-> (-> java/lang/Float java/lang/Float)
                     (Bytecode Any)
                     (Random Bit))
                 (function (_ reference instruction)
                   (do random.monad
                     [subject ..$Float::random]
                     (float (reference subject)
                            (do /.monad
                              [_ (..$Float::literal subject)]
                              instruction)))))
        binary (: (-> (-> java/lang/Float java/lang/Float java/lang/Float)
                      (Bytecode Any)
                      (Random Bit))
                  (function (_ reference instruction)
                    (do random.monad
                      [parameter ..$Float::random
                       subject ..$Float::random]
                      (float (reference parameter subject)
                             (do /.monad
                               [_ (..$Float::literal subject)
                                _ (..$Float::literal parameter)]
                               instruction)))))
        literal ($_ _.and
                    (_.lift "FCONST_0" (float (ffi.double_to_float (:as java/lang/Double +0.0)) /.fconst_0))
                    (_.lift "FCONST_1" (float (ffi.double_to_float (:as java/lang/Double +1.0)) /.fconst_1))
                    (_.lift "FCONST_2" (float (ffi.double_to_float (:as java/lang/Double +2.0)) /.fconst_2))
                    (_.lift "LDC_W/FLOAT"
                            (do random.monad
                              [expected ..$Float::random]
                              (float expected (..$Float::literal expected)))))
        arithmetic ($_ _.and
                       (_.lift "FADD" (binary (float/2 "jvm fadd" "jvm float +") /.fadd))
                       (_.lift "FSUB" (binary (float/2 "jvm fsub" "jvm float -") /.fsub))
                       (_.lift "FMUL" (binary (float/2 "jvm fmul" "jvm float *") /.fmul))
                       (_.lift "FDIV" (binary (float/2 "jvm fdiv" "jvm float /") /.fdiv))
                       (_.lift "FREM" (binary (float/2 "jvm frem" "jvm float %") /.frem))
                       (_.lift "FNEG" (unary (function (_ value)
                                               ((float/2 "jvm fsub" "jvm float -")
                                                value
                                                (ffi.double_to_float (:as java/lang/Double +0.0))))
                                             /.fneg)))
        comparison (: (-> (Bytecode Any) (-> java/lang/Float java/lang/Float Bit) (Random Bit))
                      (function (_ instruction standard)
                        (do random.monad
                          [#let [valid_float (random.filter (|>> ffi.float_to_double (:as Frac) f.not_a_number? not)
                                                            ..$Float::random)]
                           reference valid_float
                           subject valid_float
                           #let [expected (if (for {@.old
                                                    ("jvm feq" reference subject)
                                                    
                                                    @.jvm
                                                    ("jvm float =" ("jvm object cast" reference) ("jvm object cast" subject))})
                                            +0
                                            (if (standard reference subject)
                                              +1
                                              -1))]]
                          (<| (..bytecode (|>> (:as Int) (i.= expected)))
                              (do /.monad
                                [_ (..$Float::literal subject)
                                 _ (..$Float::literal reference)
                                 _ instruction
                                 _ /.i2l]
                                ..$Long::wrap)))))
        comparison_standard (: (-> java/lang/Float java/lang/Float Bit)
                               (function (_ reference subject)
                                 (for {@.old
                                       ("jvm fgt" subject reference)
                                       
                                       @.jvm
                                       ("jvm float <" ("jvm object cast" subject) ("jvm object cast" reference))})))
        comparison ($_ _.and
                       (_.lift "FCMPL" (comparison /.fcmpl comparison_standard))
                       (_.lift "FCMPG" (comparison /.fcmpg comparison_standard)))]
    ($_ _.and
        (<| (_.context "literal")
            literal)
        (<| (_.context "arithmetic")
            arithmetic)
        (<| (_.context "comparison")
            comparison)
        )))

(def: double
  Test
  (let [double (: (-> java/lang/Double (Bytecode Any) (Random Bit))
                  (function (_ expected bytecode)
                    (<| (..bytecode (for {@.old
                                          (function (_ actual)
                                            (or (|> actual (:as java/lang/Double) ("jvm deq" expected))
                                                (and (f.not_a_number? (:as Frac expected))
                                                     (f.not_a_number? (:as Frac actual)))))
                                          
                                          @.jvm
                                          (function (_ actual)
                                            (or (|> actual (:as java/lang/Double) "jvm object cast" ("jvm double =" ("jvm object cast" expected)))
                                                (and (f.not_a_number? (:as Frac expected))
                                                     (f.not_a_number? (:as Frac actual)))))}))
                        (do /.monad
                          [_ bytecode]
                          ..$Double::wrap))))
        unary (: (-> (-> java/lang/Double java/lang/Double) (Bytecode Any) (Random Bit))
                 (function (_ reference instruction)
                   (do random.monad
                     [subject ..$Double::random]
                     (double (reference subject)
                             (do /.monad
                               [_ (..$Double::literal subject)]
                               instruction)))))
        binary (: (-> (-> java/lang/Double java/lang/Double java/lang/Double) (Bytecode Any) (Random Bit))
                  (function (_ reference instruction)
                    (do random.monad
                      [parameter ..$Double::random
                       subject ..$Double::random]
                      (double (reference parameter subject)
                              (do /.monad
                                [_ (..$Double::literal subject)
                                 _ (..$Double::literal parameter)]
                                instruction)))))
        literal ($_ _.and
                    (_.lift "DCONST_0" (double (:as java/lang/Double +0.0) /.dconst_0))
                    (_.lift "DCONST_1" (double (:as java/lang/Double +1.0) /.dconst_1))
                    (_.lift "LDC2_W/DOUBLE"
                            (do random.monad
                              [expected ..$Double::random]
                              (double expected (..$Double::literal expected)))))
        arithmetic ($_ _.and
                       (_.lift "DADD" (binary (double/2 "jvm dadd" "jvm double +") /.dadd))
                       (_.lift "DSUB" (binary (double/2 "jvm dsub" "jvm double -") /.dsub))
                       (_.lift "DMUL" (binary (double/2 "jvm dmul" "jvm double *") /.dmul))
                       (_.lift "DDIV" (binary (double/2 "jvm ddiv" "jvm double /") /.ddiv))
                       (_.lift "DREM" (binary (double/2 "jvm drem" "jvm double %") /.drem))
                       (_.lift "DNEG" (unary (function (_ value)
                                               ((double/2 "jvm dsub" "jvm double -")
                                                value
                                                (:as java/lang/Double +0.0)))
                                             /.dneg)))
        comparison (: (-> (Bytecode Any) (-> java/lang/Double java/lang/Double Bit) (Random Bit))
                      (function (_ instruction standard)
                        (do random.monad
                          [reference ..valid_double
                           subject ..valid_double
                           #let [expected (if (for {@.old
                                                    ("jvm deq" reference subject)
                                                    
                                                    @.jvm
                                                    ("jvm double =" ("jvm object cast" reference) ("jvm object cast" subject))})
                                            +0
                                            (if (standard reference subject)
                                              +1
                                              -1))]]
                          (<| (..bytecode (|>> (:as Int) (i.= expected)))
                              (do /.monad
                                [_ (..$Double::literal subject)
                                 _ (..$Double::literal reference)
                                 _ instruction
                                 _ /.i2l]
                                ..$Long::wrap)))))
        ## https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.dcmp_op
        comparison_standard (: (-> java/lang/Double java/lang/Double Bit)
                               (function (_ reference subject)
                                 (for {@.old
                                       ("jvm dgt" subject reference)
                                       
                                       @.jvm
                                       ("jvm double <" ("jvm object cast" subject) ("jvm object cast" reference))})))
        comparison ($_ _.and
                       (_.lift "DCMPL" (comparison /.dcmpl comparison_standard))
                       (_.lift "DCMPG" (comparison /.dcmpg comparison_standard)))]
    ($_ _.and
        (<| (_.context "literal")
            literal)
        (<| (_.context "arithmetic")
            arithmetic)
        (<| (_.context "comparison")
            comparison)
        )))

(def: primitive
  Test
  ($_ _.and
      (<| (_.context "byte")
          ..byte)
      (<| (_.context "short")
          ..short)
      (<| (_.context "int")
          ..int)
      (<| (_.context "long")
          ..long)
      (<| (_.context "float")
          ..float)
      (<| (_.context "double")
          ..double)
      ))

(def: object
  Test
  (let [!object (: (Bytecode Any)
                   (do /.monad
                     [_ (/.new ..$Object)
                      _ /.dup]
                     (/.invokespecial ..$Object "<init>" (/type.method [(list) /type.void (list)]))))]
    ($_ _.and
        (<| (_.lift "ACONST_NULL")
            (..bytecode (|>> (:as Bit) not))
            (do /.monad
              [_ /.aconst_null
               _ (/.instanceof ..$String)]
              ..$Boolean::wrap))
        (<| (_.lift "INSTANCEOF")
            (do random.monad
              [value ..$String::random])
            (..bytecode (|>> (:as Bit)))
            (do /.monad
              [_ (/.string (:as Text value))
               _ (/.instanceof ..$String)]
              ..$Boolean::wrap))
        (<| (_.lift "NEW & CHECKCAST")
            (..bytecode (|>> (:as Bit)))
            (do /.monad
              [_ !object
               _ (/.checkcast ..$Object)
               _ (/.instanceof ..$Object)]
              ..$Boolean::wrap))
        (<| (_.lift "MONITORENTER & MONITOREXIT")
            (do random.monad
              [value ..$String::random])
            (..bytecode (|>> (:as Bit)))
            (do /.monad
              [_ (/.string (:as Text value))
               _ /.dup _ /.monitorenter
               _ /.dup _ /.monitorexit
               _ (/.instanceof ..$String)]
              ..$Boolean::wrap))
        )))

(def: method
  Test
  ($_ _.and
      (<| (_.lift "INVOKESTATIC")
          (do random.monad
            [expected (random.filter (|>> (:as Frac) f.not_a_number? not)
                                     ..$Double::random)])
          (..bytecode (for {@.old
                            (|>> (:as java/lang/Double) ("jvm deq" expected))
                            
                            @.jvm
                            (|>> (:as java/lang/Double) "jvm object cast" ("jvm double =" ("jvm object cast" expected)))}))
          (do /.monad
            [_ (/.double expected)]
            (/.invokestatic ..$Double "valueOf" (/type.method [(list /type.double) ..$Double (list)]))))
      (<| (_.lift "INVOKEVIRTUAL")
          (do random.monad
            [expected ..$Double::random])
          (..bytecode (|>> (:as Bit) (bit\= (f.not_a_number? (:as Frac expected)))))
          (do /.monad
            [_ (/.double expected)
             _ ..$Double::wrap
             _ (/.invokevirtual ..$Double "isNaN" (/type.method [(list) /type.boolean (list)]))]
            ..$Boolean::wrap))
      (<| (_.lift "INVOKESPECIAL")
          (do random.monad
            [expected (random.filter (|>> (:as Frac) f.not_a_number? not)
                                     ..$Double::random)])
          (..bytecode (for {@.old
                            (|>> (:as java/lang/Double) ("jvm deq" expected))
                            
                            @.jvm
                            (|>> (:as java/lang/Double) "jvm object cast" ("jvm double =" ("jvm object cast" expected)))}))
          (do /.monad
            [_ (/.new ..$Double)
             _ /.dup
             _ (/.double expected)]
            (/.invokespecial ..$Double "<init>" (/type.method [(list /type.double) /type.void (list)]))))
      (<| (_.lift "INVOKEINTERFACE")
          (do random.monad
            [subject ..$String::random])
          (..bytecode (|>> (:as Nat) (n.= (text.size (:as Text subject)))))
          (do /.monad
            [_ (/.string (:as Text subject))
             _ (/.invokeinterface (/type.class "java.lang.CharSequence" (list)) "length" (/type.method [(list) /type.int (list)]))
             _ /.i2l]
            ..$Long::wrap))
      ))

(def: field
  Test
  (do random.monad
    [class_name ..class_name
     part0 ..$Long::random
     part1 ..$Long::random
     #let [expected (: java/lang/Long
                       (for {@.old
                             ("jvm ladd" part0 part1)
                             
                             @.jvm
                             ("jvm object cast"
                              ("jvm long +" ("jvm object cast" part0) ("jvm object cast" part1)))}))
           $Self (/type.class class_name (list))
           class_field "class_field"
           object_field "object_field"
           constructor "<init>"
           constructor::type (/type.method [(list /type.long) /type.void (list)])
           static_method "static_method"
           bytecode (|> (/class.class /version.v6_0 /class.public
                                      (/name.internal class_name)
                                      (/name.internal "java.lang.Object")
                                      (list)
                                      (list (/field.field /field.static class_field /type.long (row.row))
                                            (/field.field /field.public object_field /type.long (row.row)))
                                      (list (/method.method /method.private
                                                            constructor
                                                            constructor::type
                                                            (list)
                                                            (#.Some (do /.monad
                                                                      [_ /.aload_0
                                                                       _ (/.invokespecial ..$Object constructor (/type.method [(list) /type.void (list)]))
                                                                       _ (..$Long::literal part0)
                                                                       _ (/.putstatic $Self class_field /type.long)
                                                                       _ /.aload_0
                                                                       _ /.lload_1
                                                                       _ (/.putfield $Self object_field /type.long)]
                                                                      /.return)))
                                            (/method.method ($_ /modifier\compose
                                                                /method.public
                                                                /method.static)
                                                            static_method
                                                            (/type.method [(list) ..$Long (list)])
                                                            (list)
                                                            (#.Some (do /.monad
                                                                      [_ (/.new $Self)
                                                                       _ /.dup
                                                                       _ (..$Long::literal part1)
                                                                       _ (/.invokespecial $Self constructor constructor::type)
                                                                       _ (/.getfield $Self object_field /type.long)
                                                                       _ (/.getstatic $Self class_field /type.long)
                                                                       _ /.ladd
                                                                       _ ..$Long::wrap]
                                                                      /.areturn))))
                                      (row.row))
                        try.assume
                        (format.run /class.writer))
           loader (/loader.memory (/loader.new_library []))]]
    (_.test "PUTSTATIC & PUTFIELD & GETFIELD & GETSTATIC"
            (case (do try.monad
                    [_ (/loader.define class_name bytecode loader)
                     class (io.run (/loader.load class_name loader))
                     method (try (get_method static_method class))
                     output (java/lang/reflect/Method::invoke (ffi.null) (ffi.array java/lang/Object 0) method)]
                    (wrap (:as Int output)))
              (#try.Success actual)
              (i.= (:as Int expected) (:as Int actual))

              (#try.Failure error)
              false))))

(def: array
  Test
  (let [!length (: (-> Nat (Bytecode Any))
                   (function (_ size)
                     (do /.monad
                       [_ ($Long::literal (:as java/lang/Long size))]
                       /.l2i)))
        ?length (: (Bytecode Any)
                   (do /.monad
                     [_ /.arraylength]
                     /.i2l))
        length (: (-> Nat (Bytecode Any) (Random Bit))
                  (function (_ size constructor)
                    (<| (..bytecode (|>> (:as Nat) (n.= size)))
                        (do /.monad
                          [_ (!length size)
                           _ constructor
                           _ ?length]
                          $Long::wrap))))
        write_and_read (: (All [a]
                            (-> Nat (Bytecode Any)
                                a (-> a (Bytecode Any))
                                [(Bytecode Any) (Bytecode Any) (Bytecode Any)]
                                (-> a Any Bit)
                                (Random Bit)))
                          (function (_ size constructor value literal [*store *load *wrap] test)
                            (let [!index ($Integer::literal (ffi.long_to_int (:as java/lang/Long +0)))]
                              (<| (..bytecode (test value))
                                  (do /.monad
                                    [_ (!length size)
                                     _ constructor
                                     _ /.dup _ !index _ (literal value) _ *store
                                     _ /.dup _ !index _ *load]
                                    *wrap)))))
        array (: (All [a]
                   (-> (Bytecode Any) (Random a) (-> a (Bytecode Any))
                       [(Bytecode Any) (Bytecode Any) (Bytecode Any)]
                       (-> a Any Bit)
                       Test))
                 (function (_ constructor random literal [*store *load *wrap] test)
                   (do {! random.monad}
                     [size (\ ! map (|>> (n.% 1024) (n.max 1)) random.nat)
                      value random]
                     ($_ _.and
                         (<| (_.lift "length")
                             (length size constructor))
                         (<| (_.lift "write and read")
                             (write_and_read size constructor value literal [*store *load *wrap] test))))))]
    ($_ _.and
        (_.context "boolean"
                   (array (/.newarray /instruction.t_boolean) $Boolean::random $Boolean::literal [/.bastore /.baload $Boolean::wrap]
                          (function (_ expected) (|>> (:as Bit) (bit\= (:as Bit expected))))))
        (_.context "byte"
                   (array (/.newarray /instruction.t_byte) $Byte::random $Byte::literal [/.bastore /.baload $Byte::wrap]
                          (function (_ expected)
                            (for {@.old
                                  (|>> (:as java/lang/Byte) ffi.byte_to_long ("jvm leq" (ffi.byte_to_long expected)))
                                  
                                  @.jvm
                                  (|>> (:as java/lang/Byte) ffi.byte_to_long "jvm object cast" ("jvm long =" ("jvm object cast" (ffi.byte_to_long (:as java/lang/Byte expected)))))}))))
        (_.context "short"
                   (array (/.newarray /instruction.t_short) $Short::random $Short::literal [/.sastore /.saload $Short::wrap]
                          (function (_ expected)
                            (for {@.old
                                  (|>> (:as java/lang/Short) ffi.short_to_long ("jvm leq" (ffi.short_to_long expected)))
                                  
                                  @.jvm
                                  (|>> (:as java/lang/Short) ffi.short_to_long "jvm object cast" ("jvm long =" ("jvm object cast" (ffi.short_to_long (:as java/lang/Short expected)))))}))))
        (_.context "int"
                   (array (/.newarray /instruction.t_int) $Integer::random $Integer::literal [/.iastore /.iaload $Integer::wrap]
                          (function (_ expected)
                            (for {@.old
                                  (|>> (:as java/lang/Integer) ("jvm ieq" (:as java/lang/Integer expected)))
                                  
                                  @.jvm
                                  (|>> (:as java/lang/Integer) "jvm object cast" ("jvm int =" ("jvm object cast" (:as java/lang/Integer expected))))}))))
        (_.context "long"
                   (array (/.newarray /instruction.t_long) $Long::random $Long::literal [/.lastore /.laload $Long::wrap]
                          (function (_ expected)
                            (for {@.old
                                  (|>> (:as java/lang/Long) ("jvm leq" expected))
                                  
                                  @.jvm
                                  (|>> (:as java/lang/Long) "jvm object cast" ("jvm long =" ("jvm object cast" (:as java/lang/Long expected))))}))))
        (_.context "float"
                   (array (/.newarray /instruction.t_float) ..valid_float $Float::literal [/.fastore /.faload $Float::wrap]
                          (function (_ expected)
                            (for {@.old
                                  (|>> (:as java/lang/Float) ("jvm feq" expected))
                                  
                                  @.jvm
                                  (|>> (:as java/lang/Float) "jvm object cast" ("jvm float =" ("jvm object cast" (:as java/lang/Float expected))))}))))
        (_.context "double"
                   (array (/.newarray /instruction.t_double) ..valid_double $Double::literal [/.dastore /.daload $Double::wrap]
                          (function (_ expected)
                            (for {@.old
                                  (|>> (:as java/lang/Double) ("jvm deq" expected))
                                  
                                  @.jvm
                                  (|>> (:as java/lang/Double) "jvm object cast" ("jvm double =" ("jvm object cast" (:as java/lang/Double expected))))}))))
        (_.context "char"
                   (array (/.newarray /instruction.t_char) $Character::random $Character::literal [/.castore /.caload $Character::wrap]
                          (function (_ expected)
                            (for {@.old
                                  (|>> (:as java/lang/Character) ("jvm ceq" expected))
                                  
                                  @.jvm
                                  (|>> (:as java/lang/Character) "jvm object cast" ("jvm char =" ("jvm object cast" (:as java/lang/Character expected))))}))))
        (_.context "object"
                   (array (/.anewarray ..$String) $String::random $String::literal [/.aastore /.aaload /.nop]
                          (function (_ expected) (|>> (:as Text) (text\= (:as Text expected))))))
        (<| (_.context "multi")
            (do {! random.monad}
              [#let [size (\ ! map (|>> (n.% 5) (n.+ 1))
                             random.nat)]
               dimensions size
               sizesH size
               sizesT (random.list (dec dimensions) size)
               #let [type (loop [dimensions dimensions
                                 type (: (Type Object)
                                         ..$Object)]
                            (case dimensions
                              0 type
                              _ (recur (dec dimensions) (/type.array type))))]]
              (<| (_.lift "MULTIANEWARRAY")
                  (..bytecode (|>> (:as Nat) (n.= sizesH)))
                  (do {! /.monad}
                    [_ (monad.map ! (|>> (:as java/lang/Long) ffi.long_to_int ..$Integer::literal)
                                  (#.Cons sizesH sizesT))
                     _ (/.multianewarray type (|> dimensions /unsigned.u1 try.assume))
                     _ ?length]
                    $Long::wrap))))
        )))

(template: (!::= <type> <old> <new>)
  (: (-> <type> Any Bit)
     (function (_ expected)
       (for {@.old
             (|>> (:as <type>) (<old> expected))
             
             @.jvm
             (|>> (:as <type>) "jvm object cast" (<new> ("jvm object cast" (:as <type> expected))))}))))

(def: conversion
  Test
  (let [conversion (: (All [a z]
                        (-> (Primitive a) (Primitive z) (Bytecode Any) (-> a z) (-> z Any Bit) (Random Bit)))
                      (function (_ from to instruction convert test)
                        (do random.monad
                          [input (get@ #random from)
                           #let [expected (convert input)]]
                          (..bytecode (test expected)
                                      (do /.monad
                                        [_ ((get@ #literal from) input)
                                         _ instruction]
                                        (get@ #wrap to))))))
        int::= (!::= java/lang/Integer "jvm ieq" "jvm int =")
        long::= (!::= java/lang/Long "jvm leq" "jvm long =")
        float::= (!::= java/lang/Float "jvm feq" "jvm float =")
        double::= (!::= java/lang/Double "jvm deq" "jvm double =")]
    ($_ _.and
        (<| (_.context "int")
            ($_ _.and
                (_.lift "I2L" (conversion ..$Integer::primitive ..$Long::primitive /.i2l (|>> ffi.int_to_long) long::=))
                (_.lift "I2F" (conversion ..$Integer::primitive ..$Float::primitive /.i2f (|>> ffi.int_to_float) float::=))
                (_.lift "I2D" (conversion ..$Integer::primitive ..$Double::primitive /.i2d (|>> ffi.int_to_double) double::=))
                (_.lift "I2B" (conversion ..$Integer::primitive ..$Byte::primitive /.i2b (|>> ffi.int_to_byte)
                                          (function (_ expected)
                                            (for {@.old
                                                  (|>> (:as java/lang/Byte) ffi.byte_to_long ("jvm leq" (ffi.byte_to_long expected)))
                                                  
                                                  @.jvm
                                                  (|>> (:as java/lang/Byte) ffi.byte_to_long "jvm object cast" ("jvm long =" ("jvm object cast" (ffi.byte_to_long (:as java/lang/Byte expected)))))}))))
                (_.lift "I2C" (conversion ..$Integer::primitive ..$Character::primitive /.i2c (|>> ffi.int_to_char)
                                          (!::= java/lang/Character "jvm ceq" "jvm char =")))
                (_.lift "I2S" (conversion ..$Integer::primitive ..$Short::primitive /.i2s (|>> ffi.int_to_short)
                                          (function (_ expected)
                                            (for {@.old
                                                  (|>> (:as java/lang/Short) ffi.short_to_long ("jvm leq" (ffi.short_to_long expected)))
                                                  
                                                  @.jvm
                                                  (|>> (:as java/lang/Short) ffi.short_to_long "jvm object cast" ("jvm long =" ("jvm object cast" (ffi.short_to_long (:as java/lang/Short expected)))))}))))))
        (<| (_.context "long")
            ($_ _.and
                (_.lift "L2I" (conversion ..$Long::primitive ..$Integer::primitive /.l2i (|>> ffi.long_to_int) int::=))
                (_.lift "L2F" (conversion ..$Long::primitive ..$Float::primitive /.l2f (|>> ffi.long_to_float) float::=))
                (_.lift "L2D" (conversion ..$Long::primitive ..$Double::primitive /.l2d (|>> ffi.long_to_double) double::=))))
        (<| (_.context "float")
            ($_ _.and
                (_.lift "F2I" (conversion ..$Float::primitive ..$Integer::primitive /.f2i (|>> ffi.float_to_int) int::=))
                (_.lift "F2L" (conversion ..$Float::primitive ..$Long::primitive /.f2l (|>> ffi.float_to_long) long::=))
                (_.lift "F2D" (conversion ..$Float::primitive ..$Double::primitive /.f2d (|>> ffi.float_to_double) double::=))))
        (<| (_.context "double")
            ($_ _.and
                (_.lift "D2I" (conversion ..$Double::primitive ..$Integer::primitive /.d2i (|>> ffi.double_to_int) int::=))
                (_.lift "D2L" (conversion ..$Double::primitive ..$Long::primitive /.d2l (|>> ffi.double_to_long) long::=))
                (_.lift "D2F" (conversion ..$Double::primitive ..$Float::primitive /.d2f (|>> ffi.double_to_float) float::=))))
        )))

(def: value
  Test
  ($_ _.and
      (<| (_.context "primitive")
          ..primitive)
      (<| (_.context "object")
          ..object)
      (<| (_.context "method")
          ..method)
      (<| (_.context "field")
          ..field)
      (<| (_.context "array")
          ..array)
      (<| (_.context "conversion")
          ..conversion)
      ))

(def: registry
  Test
  (let [store_and_load (: (All [a]
                            (-> (Random a) (-> a (Bytecode Any)) (Bytecode Any)
                                [(-> Nat (Bytecode Any)) (-> Nat (Bytecode Any))]
                                (-> a (-> Any Bit))
                                (Random Bit)))
                          (function (_ random_value literal *wrap [store load] test)
                            (do {! random.monad}
                              [expected random_value
                               register (\ ! map (n.% 128) random.nat)]
                              (<| (..bytecode (test expected))
                                  (do /.monad
                                    [_ (literal expected)
                                     _ (store register)
                                     _ (load register)]
                                    *wrap)))))]
    ($_ _.and
        (<| (_.context "int")
            (let [test (!::= java/lang/Integer "jvm ieq" "jvm int =")]
              ($_ _.and
                  (_.lift "ISTORE_0/ILOAD_0"
                          (store_and_load ..$Integer::random ..$Integer::literal ..$Integer::wrap [(function.constant /.istore_0) (function.constant /.iload_0)] test))
                  (_.lift "ISTORE_1/ILOAD_1"
                          (store_and_load ..$Integer::random ..$Integer::literal ..$Integer::wrap [(function.constant /.istore_1) (function.constant /.iload_1)] test))
                  (_.lift "ISTORE_2/ILOAD_2"
                          (store_and_load ..$Integer::random ..$Integer::literal ..$Integer::wrap [(function.constant /.istore_2) (function.constant /.iload_2)] test))
                  (_.lift "ISTORE_3/ILOAD_3"
                          (store_and_load ..$Integer::random ..$Integer::literal ..$Integer::wrap [(function.constant /.istore_3) (function.constant /.iload_3)] test))
                  (_.lift "ISTORE/ILOAD"
                          (store_and_load ..$Integer::random ..$Integer::literal ..$Integer::wrap [/.istore /.iload] test))
                  (_.lift "IINC"
                          (do {! random.monad}
                            [base ..$Byte::random
                             increment (\ ! map (|>> (n.% 100) /unsigned.u1 try.assume)
                                          random.nat)
                             #let [expected (: java/lang/Long
                                               (for {@.old
                                                     ("jvm ladd"
                                                      (ffi.byte_to_long base)
                                                      (.int (/unsigned.value increment)))
                                                     
                                                     @.jvm
                                                     ("jvm object cast"
                                                      ("jvm long +"
                                                       ("jvm object cast" (ffi.byte_to_long base))
                                                       ("jvm object cast" (:as java/lang/Long (/unsigned.value increment)))))}))]]
                            (..bytecode (|>> (:as Int) (i.= (:as Int expected)))
                                        (do /.monad
                                          [_ (..$Byte::literal base)
                                           _ /.istore_0
                                           _ (/.iinc 0 increment)
                                           _ /.iload_0
                                           _ /.i2l]
                                          ..$Long::wrap)))))))
        (<| (_.context "long")
            (let [test (!::= java/lang/Long "jvm leq" "jvm long =")]
              ($_ _.and
                  (_.lift "LSTORE_0/LLOAD_0"
                          (store_and_load ..$Long::random ..$Long::literal ..$Long::wrap [(function.constant /.lstore_0) (function.constant /.lload_0)] test))
                  (_.lift "LSTORE_1/LLOAD_1"
                          (store_and_load ..$Long::random ..$Long::literal ..$Long::wrap [(function.constant /.lstore_1) (function.constant /.lload_1)] test))
                  (_.lift "LSTORE_2/LLOAD_2"
                          (store_and_load ..$Long::random ..$Long::literal ..$Long::wrap [(function.constant /.lstore_2) (function.constant /.lload_2)] test))
                  (_.lift "LSTORE_3/LLOAD_3"
                          (store_and_load ..$Long::random ..$Long::literal ..$Long::wrap [(function.constant /.lstore_3) (function.constant /.lload_3)] test))
                  (_.lift "LSTORE/LLOAD"
                          (store_and_load ..$Long::random ..$Long::literal ..$Long::wrap [/.lstore /.lload] test)))))
        (<| (_.context "float")
            (let [test (!::= java/lang/Float "jvm feq" "jvm float =")]
              ($_ _.and
                  (_.lift "FSTORE_0/FLOAD_0"
                          (store_and_load ..valid_float ..$Float::literal ..$Float::wrap [(function.constant /.fstore_0) (function.constant /.fload_0)] test))
                  (_.lift "FSTORE_1/FLOAD_1"
                          (store_and_load ..valid_float ..$Float::literal ..$Float::wrap [(function.constant /.fstore_1) (function.constant /.fload_1)] test))
                  (_.lift "FSTORE_2/FLOAD_2"
                          (store_and_load ..valid_float ..$Float::literal ..$Float::wrap [(function.constant /.fstore_2) (function.constant /.fload_2)] test))
                  (_.lift "FSTORE_3/FLOAD_3"
                          (store_and_load ..valid_float ..$Float::literal ..$Float::wrap [(function.constant /.fstore_3) (function.constant /.fload_3)] test))
                  (_.lift "FSTORE/FLOAD"
                          (store_and_load ..valid_float ..$Float::literal ..$Float::wrap [/.fstore /.fload] test)))))
        (<| (_.context "double")
            (let [test (!::= java/lang/Double "jvm deq" "jvm double =")]
              ($_ _.and
                  (_.lift "DSTORE_0/DLOAD_0"
                          (store_and_load ..valid_double ..$Double::literal ..$Double::wrap [(function.constant /.dstore_0) (function.constant /.dload_0)] test))
                  (_.lift "DSTORE_1/DLOAD_1"
                          (store_and_load ..valid_double ..$Double::literal ..$Double::wrap [(function.constant /.dstore_1) (function.constant /.dload_1)] test))
                  (_.lift "DSTORE_2/DLOAD_2"
                          (store_and_load ..valid_double ..$Double::literal ..$Double::wrap [(function.constant /.dstore_2) (function.constant /.dload_2)] test))
                  (_.lift "DSTORE_3/DLOAD_3"
                          (store_and_load ..valid_double ..$Double::literal ..$Double::wrap [(function.constant /.dstore_3) (function.constant /.dload_3)] test))
                  (_.lift "DSTORE/DLOAD"
                          (store_and_load ..valid_double ..$Double::literal ..$Double::wrap [/.dstore /.dload] test)))))
        (<| (_.context "object")
            (let [test (: (-> java/lang/String Any Bit)
                          (function (_ expected actual)
                            (|> actual (:as Text) (text\= (:as Text expected)))))]
              ($_ _.and
                  (_.lift "ASTORE_0/ALOAD_0"
                          (store_and_load ..$String::random ..$String::literal /.nop [(function.constant /.astore_0) (function.constant /.aload_0)] test))
                  (_.lift "ASTORE_1/ALOAD_1"
                          (store_and_load ..$String::random ..$String::literal /.nop [(function.constant /.astore_1) (function.constant /.aload_1)] test))
                  (_.lift "ASTORE_2/ALOAD_2"
                          (store_and_load ..$String::random ..$String::literal /.nop [(function.constant /.astore_2) (function.constant /.aload_2)] test))
                  (_.lift "ASTORE_3/ALOAD_3"
                          (store_and_load ..$String::random ..$String::literal /.nop [(function.constant /.astore_3) (function.constant /.aload_3)] test))
                  (_.lift "ASTORE/ALOAD"
                          (store_and_load ..$String::random ..$String::literal /.nop [/.astore /.aload] test)))))
        )))

(def: stack
  Test
  (do random.monad
    [expected/1 $String::random
     #let [object_test (: (-> Any Bit)
                          (|>> (:as Text) (text\= (:as Text expected/1))))]
     dummy/1 $String::random
     #let [single ($_ _.and
                      (<| (_.lift "DUP & POP")
                          (..bytecode object_test)
                          (do /.monad
                            [_ ($String::literal expected/1)
                             _ /.dup]
                            /.pop))
                      (<| (_.lift "DUP_X1 & POP2")
                          (..bytecode object_test)
                          (do /.monad
                            [_ ($String::literal dummy/1)
                             _ ($String::literal expected/1)
                             _ /.dup_x1]
                            /.pop2))
                      (<| (_.lift "DUP_X2")
                          (..bytecode object_test)
                          (do /.monad
                            [_ ($String::literal dummy/1)
                             _ ($String::literal dummy/1)
                             _ ($String::literal expected/1)
                             _ /.dup_x2
                             _ /.pop2]
                            /.pop))
                      (<| (_.lift "SWAP")
                          (..bytecode object_test)
                          (do /.monad
                            [_ ($String::literal dummy/1)
                             _ ($String::literal expected/1)
                             _ /.swap]
                            /.pop))
                      )]
     expected/2 $Long::random
     #let [long_test (: (-> Any Bit)
                        (|>> (:as Int) (i.= (:as Int expected/2))))]
     dummy/2 $Long::random
     #let [double ($_ _.and
                      (<| (_.lift "DUP2")
                          (..bytecode long_test)
                          (do /.monad
                            [_ ($Long::literal expected/2)
                             _ /.dup2
                             _ /.pop2]
                            ..$Long::wrap))
                      (<| (_.lift "DUP2_X1")
                          (..bytecode long_test)
                          (do /.monad
                            [_ ($String::literal dummy/1)
                             _ ($Long::literal expected/2)
                             _ /.dup2_x1
                             _ /.pop2
                             _ /.pop]
                            ..$Long::wrap))
                      (<| (_.lift "DUP2_X2")
                          (..bytecode long_test)
                          (do /.monad
                            [_ ($Long::literal dummy/2)
                             _ ($Long::literal expected/2)
                             _ /.dup2_x2
                             _ /.pop2
                             _ /.pop2]
                            ..$Long::wrap))
                      )]]
    ($_ _.and
        (<| (_.context "single")
            single)
        (<| (_.context "double")
            double)
        )))

(def: resource
  Test
  ($_ _.and
      (<| (_.context "registry")
          ..registry)
      (<| (_.context "stack")
          ..stack)
      ))

(def: return
  Test
  (let [primitive_return (: (All [a] (-> (Primitive a) (Bytecode Any) (Maybe (-> a (Bytecode Any))) (-> a Any Bit) (Random Bit)))
                            (function (_ primitive return substitute test)
                              (do random.monad
                                [class_name ..class_name
                                 primitive_method_name (random.ascii/upper 10)
                                 #let [primitive_method_type (/type.method [(list) (get@ #unboxed primitive) (list)])]
                                 object_method_name (|> (random.ascii/upper 10)
                                                        (random.filter (|>> (text\= primitive_method_name) not)))
                                 expected (get@ #random primitive)
                                 #let [$Self (/type.class class_name (list))]]
                                (wrap (case (do try.monad
                                              [class (/class.class /version.v6_0 /class.public
                                                                   (/name.internal class_name)
                                                                   (/name.internal "java.lang.Object")
                                                                   (list)
                                                                   (list)
                                                                   (list (/method.method ..method_modifier
                                                                                         primitive_method_name
                                                                                         primitive_method_type
                                                                                         (list)
                                                                                         (#.Some (do /.monad
                                                                                                   [_ ((get@ #literal primitive) expected)]
                                                                                                   return)))
                                                                         (/method.method ..method_modifier
                                                                                         object_method_name
                                                                                         (/type.method [(list) (get@ #boxed primitive) (list)])
                                                                                         (list)
                                                                                         (#.Some (do /.monad
                                                                                                   [_ (/.invokestatic $Self primitive_method_name primitive_method_type)
                                                                                                    _ (case substitute
                                                                                                        #.None
                                                                                                        (wrap [])

                                                                                                        (#.Some substitute)
                                                                                                        (substitute expected))
                                                                                                    _ (get@ #wrap primitive)]
                                                                                                   /.areturn))))
                                                                   (row.row))
                                               #let [bytecode (format.run /class.writer class)
                                                     loader (/loader.memory (/loader.new_library []))]
                                               _ (/loader.define class_name bytecode loader)
                                               class (io.run (/loader.load class_name loader))
                                               method (try (get_method object_method_name class))]
                                              (java/lang/reflect/Method::invoke (ffi.null) (ffi.array java/lang/Object 0) method))
                                        (#try.Success actual)
                                        (test expected actual)

                                        (#try.Failure error)
                                        false)
                                      ))))]
    ($_ _.and
        (_.lift "IRETURN" (primitive_return ..$Integer::primitive /.ireturn #.None (!::= java/lang/Integer "jvm ieq" "jvm int =")))
        (_.lift "LRETURN" (primitive_return ..$Long::primitive /.lreturn #.None (!::= java/lang/Long "jvm leq" "jvm long =")))
        (_.lift "FRETURN" (primitive_return ..$Float::primitive /.freturn #.None (!::= java/lang/Float "jvm feq" "jvm float =")))
        (_.lift "DRETURN" (primitive_return ..$Double::primitive /.dreturn #.None (!::= java/lang/Double "jvm deq" "jvm double =")))
        (_.lift "ARETURN" (primitive_return ..$String::primitive /.areturn #.None (function (_ expected actual) (text\= (:as Text expected) (:as Text actual)))))
        (_.lift "RETURN" (primitive_return (: (Primitive java/lang/String)
                                              {#unboxed /type.void
                                               #boxed ..$String
                                               #wrap /.nop
                                               #random ..$String::random
                                               #literal (function.constant /.nop)})
                                           /.return
                                           (#.Some ..$String::literal)
                                           (function (_ expected actual) (text\= (:as Text expected) (:as Text actual)))))
        )))

(def: branching
  Test
  (do random.monad
    [expected ..$Long::random
     dummy ..$Long::random
     #let [if! (: (-> (-> Label (Bytecode Any)) (Bytecode Any) (Random Bit))
                  (function (_ instruction prelude)
                    (<| (..bytecode ((!::= java/lang/Long "jvm leq" "jvm long =") expected))
                        (do /.monad
                          [@then /.new_label
                           @end /.new_label
                           _ prelude
                           _ (instruction @then)
                           _ (..$Long::literal dummy)
                           _ (/.goto @end)
                           _ (/.set_label @then)
                           _ (..$Long::literal expected)
                           _ (/.set_label @end)]
                          ..$Long::wrap))))
           comparison_against_zero ($_ _.and
                                       (_.lift "IFEQ" (if! /.ifeq /.iconst_0))
                                       (_.lift "IFNE" (if! /.ifne /.iconst_1))
                                       (_.lift "IFLT" (if! /.iflt /.iconst_m1))
                                       (_.lift "IFLE" (if! /.ifle /.iconst_0))
                                       (_.lift "IFGT" (if! /.ifgt /.iconst_1))
                                       (_.lift "IFGE" (if! /.ifge /.iconst_0)))
           null_test ($_ _.and
                         (_.lift "IFNULL" (if! /.ifnull /.aconst_null))
                         (_.lift "IFNONNULL" (if! /.ifnonnull (/.string ""))))]
     reference ..$Integer::random
     subject (|> ..$Integer::random
                 (random.filter (|>> ((!::= java/lang/Integer "jvm ieq" "jvm int =") reference) not)))
     #let [[lesser greater] (if (for {@.old
                                      ("jvm ilt" reference subject)
                                      
                                      @.jvm
                                      ("jvm int <" ("jvm object cast" subject) ("jvm object cast" reference))})
                              [reference subject]
                              [subject reference])
           int_comparison ($_ _.and
                              (_.lift "IF_ICMPEQ" (if! /.if_icmpeq (do /.monad [_ (..$Integer::literal reference)] /.dup)))
                              (_.lift "IF_ICMPNE" (if! /.if_icmpne (do /.monad [_ (..$Integer::literal reference)] (..$Integer::literal subject))))
                              (_.lift "IF_ICMPLT" (if! /.if_icmplt (do /.monad [_ (..$Integer::literal lesser)] (..$Integer::literal greater))))
                              (_.lift "IF_ICMPLE" (if! /.if_icmple (do /.monad [_ (..$Integer::literal lesser)] (..$Integer::literal greater))))
                              (_.lift "IF_ICMPGT" (if! /.if_icmpgt (do /.monad [_ (..$Integer::literal greater)] (..$Integer::literal lesser))))
                              (_.lift "IF_ICMPGE" (if! /.if_icmpge (do /.monad [_ (..$Integer::literal greater)] (..$Integer::literal lesser)))))
           new_object (: (Bytecode Any)
                         (do /.monad
                           [_ (/.new ..$Object)
                            _ /.dup]
                           (/.invokespecial ..$Object "<init>" (/type.method [(list) /type.void (list)]))))
           reference_comparison ($_ _.and
                                    (_.lift "IF_ACMPEQ" (if! /.if_acmpeq (do /.monad [_ new_object] /.dup)))
                                    (_.lift "IF_ACMPNE" (if! /.if_acmpne (do /.monad [_ new_object] new_object)))
                                    )]]
    ($_ _.and
        comparison_against_zero
        null_test
        int_comparison
        reference_comparison
        )))

(def: jump
  Test
  (do random.monad
    [expected ..$Long::random
     dummy ..$Long::random
     #let [jump (: (-> (-> Label (Bytecode Any)) (Random Bit))
                   (function (_ goto)
                     (<| (..bytecode ((!::= java/lang/Long "jvm leq" "jvm long =") expected))
                         (do /.monad
                           [@skipped /.new_label
                            @value /.new_label
                            @end /.new_label
                            _ (goto @value)
                            _ (/.set_label @skipped)
                            _ (..$Long::literal dummy)
                            _ (goto @end)
                            _ (/.set_label @value)
                            _ (..$Long::literal expected)
                            _ (/.set_label @end)]
                           ..$Long::wrap))))]]
    ($_ _.and
        (_.lift "GOTO" (jump /.goto))
        (_.lift "GOTO_W" (jump /.goto_w)))))

(def: switch
  Test
  ($_ _.and
      (<| (_.lift "TABLESWITCH")
          (do {! random.monad}
            [expected ..$Long::random
             dummy ..$Long::random
             minimum (\ ! map (|>> (n.% 100) .int /signed.s4 try.assume)
                        random.nat)
             afterwards (\ ! map (n.% 10) random.nat)])
          (..bytecode ((!::= java/lang/Long "jvm leq" "jvm long =") expected))
          (do /.monad
            [@right /.new_label
             @wrong /.new_label
             @return /.new_label
             _ (/.bipush (|> minimum /signed.value .int /signed.s1 try.assume))
             _ (/.tableswitch minimum @wrong [@right (list.repeat afterwards @wrong)])
             _ (/.set_label @wrong)
             _ (..$Long::literal dummy)
             _ (/.goto @return)
             _ (/.set_label @right)
             _ (..$Long::literal expected)
             _ (/.set_label @return)]
            ..$Long::wrap))
      (<| (_.lift "LOOKUPSWITCH")
          (do {! random.monad}
            [options (\ ! map (|>> (n.% 10) (n.+ 1))
                        random.nat)
             choice (\ ! map (n.% options) random.nat)
             options (|> random.int
                         (\ ! map (|>> (:as java/lang/Long) ffi.long_to_int ffi.int_to_long (:as Int)))
                         (random.set i.hash options)
                         (\ ! map set.to_list))
             #let [choice (maybe.assume (list.nth choice options))]
             expected ..$Long::random
             dummy ..$Long::random])
          (..bytecode ((!::= java/lang/Long "jvm leq" "jvm long =") expected))
          (do /.monad
            [@right /.new_label
             @wrong /.new_label
             @return /.new_label
             _ (..$Integer::literal (ffi.long_to_int (:as java/lang/Long choice)))
             _ (/.lookupswitch @wrong (list\map (function (_ option)
                                                  [(|> option /signed.s4 try.assume)
                                                   (if (i.= choice option) @right @wrong)])
                                                options))
             _ (/.set_label @wrong)
             _ (..$Long::literal dummy)
             _ (/.goto @return)
             _ (/.set_label @right)
             _ (..$Long::literal expected)
             _ (/.set_label @return)]
            ..$Long::wrap))
      ))

(def: exception
  Test
  (do random.monad
    [expected ..$Long::random
     dummy ..$Long::random
     exception ..$String::random]
    (<| (_.lift "ATHROW")
        (..bytecode ((!::= java/lang/Long "jvm leq" "jvm long =") expected))
        (do /.monad
          [#let [$Exception (/type.class "java.lang.Exception" (list))]
           @skipped /.new_label
           @try /.new_label
           @handler /.new_label
           @return /.new_label
           _ (/.try @try @handler @handler $Exception)
           _ (/.set_label @try)
           _ (/.new $Exception)
           _ /.dup
           _ (..$String::literal exception)
           _ (/.invokespecial $Exception "<init>" (/type.method [(list ..$String) /type.void (list)]))
           _ /.athrow
           _ (/.set_label @skipped)
           _ (..$Long::literal dummy)
           _ (/.goto @return)
           _ (/.set_label @handler)
           _ /.pop
           _ (..$Long::literal expected)
           _ (/.set_label @return)]
          ..$Long::wrap))))

(def: code
  Test
  ($_ _.and
      (<| (_.context "return")
          ..return)
      (<| (_.context "branching")
          ..branching)
      (<| (_.context "jump")
          ..jump)
      (<| (_.context "switch")
          ..switch)
      (<| (_.context "exception")
          ..exception)
      ))

(def: instruction
  Test
  ($_ _.and
      (<| (_.context "value")
          ..value)
      (<| (_.context "resource")
          ..resource)
      (<| (_.context "code")
          ..code)
      ))

(def: inheritance
  Test
  (do random.monad
    [abstract_class ..class_name
     interface_class (|> ..class_name
                         (random.filter (|>> (text\= abstract_class) not)))
     concrete_class (|> ..class_name
                        (random.filter (function (_ class)
                                         (not (or (text\= abstract_class class)
                                                  (text\= interface_class class))))))
     part0 ..$Long::random
     part1 ..$Long::random
     part2 ..$Long::random
     fake_part2 ..$Long::random
     part3 ..$Long::random
     part4 ..$Long::random
     #let [expected ($_ i.+
                        (:as Int part0)
                        (:as Int part1)
                        (:as Int part2)
                        (:as Int part3)
                        (:as Int part4))
           $Concrete (/type.class concrete_class (list))
           $Abstract (/type.class abstract_class (list))
           $Interface (/type.class interface_class (list))

           constructor::type (/type.method [(list) /type.void (list)])
           method::type (/type.method [(list) /type.long (list)])

           inherited_method "inherited_method"
           overriden_method "overriden_method"
           abstract_method "abstract_method"
           interface_method "interface_method"
           virtual_method "virtual_method"
           static_method "static_method"

           method (: (-> Text java/lang/Long (Resource Method))
                     (function (_ name value)
                       (/method.method /method.public
                                       name
                                       method::type
                                       (list)
                                       (#.Some (do /.monad
                                                 [_ (..$Long::literal value)]
                                                 /.lreturn)))))

           interface_bytecode (|> (/class.class /version.v6_0 ($_ /modifier\compose /class.public /class.abstract /class.interface)
                                                (/name.internal interface_class)
                                                (/name.internal "java.lang.Object")
                                                (list)
                                                (list)
                                                (list (/method.method ($_ /modifier\compose /method.public /method.abstract)
                                                                      interface_method method::type (list) #.None))
                                                (row.row))
                                  try.assume
                                  (format.run /class.writer))
           abstract_bytecode (|> (/class.class /version.v6_0 ($_ /modifier\compose /class.public /class.abstract)
                                               (/name.internal abstract_class)
                                               (/name.internal "java.lang.Object")
                                               (list)
                                               (list)
                                               (list (/method.method /method.public
                                                                     "<init>"
                                                                     constructor::type
                                                                     (list)
                                                                     (#.Some (do /.monad
                                                                               [_ /.aload_0
                                                                                _ (/.invokespecial ..$Object "<init>" constructor::type)]
                                                                               /.return)))
                                                     (method inherited_method part0)
                                                     (method overriden_method fake_part2)
                                                     (/method.method ($_ /modifier\compose /method.public /method.abstract)
                                                                     abstract_method method::type (list) #.None))
                                               (row.row))
                                 try.assume
                                 (format.run /class.writer))
           invoke (: (-> (Type Class) Text (Bytecode Any))
                     (function (_ class method)
                       (do /.monad
                         [_ /.aload_0]
                         (/.invokevirtual class method method::type))))
           concrete_bytecode (|> (/class.class /version.v6_0 /class.public
                                               (/name.internal concrete_class)
                                               (/name.internal abstract_class)
                                               (list (/name.internal interface_class))
                                               (list)
                                               (list (/method.method /method.public
                                                                     "<init>"
                                                                     constructor::type
                                                                     (list)
                                                                     (#.Some (do /.monad
                                                                               [_ /.aload_0
                                                                                _ (/.invokespecial $Abstract "<init>" constructor::type)]
                                                                               /.return)))
                                                     (method virtual_method part1)
                                                     (method overriden_method part2)
                                                     (method abstract_method part3)
                                                     (method interface_method part4)
                                                     (/method.method ($_ /modifier\compose
                                                                         /method.public
                                                                         /method.static)
                                                                     static_method
                                                                     (/type.method [(list) ..$Long (list)])
                                                                     (list)
                                                                     (#.Some (do /.monad
                                                                               [_ (/.new $Concrete)
                                                                                _ /.dup
                                                                                _ (/.invokespecial $Concrete "<init>" constructor::type)
                                                                                _ /.astore_0
                                                                                _ (invoke $Abstract inherited_method)
                                                                                _ (invoke $Concrete virtual_method)
                                                                                _ /.ladd
                                                                                _ (invoke $Abstract overriden_method)
                                                                                _ /.ladd
                                                                                _ /.aload_0 _ (/.invokeinterface $Interface interface_method method::type)
                                                                                _ /.ladd
                                                                                _ (invoke $Abstract abstract_method)
                                                                                _ /.ladd
                                                                                _ ..$Long::wrap]
                                                                               /.areturn))))
                                               (row.row))
                                 try.assume
                                 (format.run /class.writer))
           loader (/loader.memory (/loader.new_library []))]]
    (_.test "Class & interface inheritance"
            (case (do try.monad
                    [_ (/loader.define abstract_class abstract_bytecode loader)
                     _ (/loader.define interface_class interface_bytecode loader)
                     _ (/loader.define concrete_class concrete_bytecode loader)
                     class (io.run (/loader.load concrete_class loader))
                     method (try (get_method static_method class))
                     output (java/lang/reflect/Method::invoke (ffi.null) (ffi.array java/lang/Object 0) method)]
                    (wrap (:as Int output)))
              (#try.Success actual)
              (i.= (:as Int expected) (:as Int actual))

              (#try.Failure error)
              false))))

(def: #export test
  Test
  (<| (_.context (%.name (name_of .._)))
      ($_ _.and
          (<| (_.context "instruction")
              ..instruction)
          (<| (_.context "inheritance")
              ..inheritance)
          )))
