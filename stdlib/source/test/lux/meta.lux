(.module:
  [lux #*
   ["_" test (#+ Test)]
   [abstract
    [monad (#+ do)]
    {[0 #spec]
     [/
      ["$." functor (#+ Injection Comparison)]
      ["$." apply]
      ["$." monad]]}]
   [control
    ["." try]]
   [data
    ["." text ("#\." equivalence)
     ["%" format (#+ format)]]]
   [meta
    ["." location]]
   [math
    ["." random (#+ Random)]
    [number
     ["n" nat]]]]
  {1
   ["." /]}
  ["." / #_
   ["#." annotation]])

(template: (!expect <pattern> <value>)
  (case <value>
    <pattern> true
    _ false))

(def: compiler_related
  Test
  (do random.monad
    [target (random.ascii/upper_alpha 1)
     version (random.ascii/upper_alpha 1)
     source_code (random.ascii/upper_alpha 1)
     expected_current_module (random.ascii/upper_alpha 1)
     primitive_type (random.ascii/upper_alpha 1)
     expected_seed random.nat
     expected random.nat
     dummy (random.filter (|>> (n.= expected) not) random.nat)
     expected_error (random.ascii/upper_alpha 1)
     expected_short (random.ascii/upper_alpha 1)
     dummy_module (random.filter (|>> (text\= expected_current_module) not)
                                 (random.ascii/upper_alpha 1))
     expected_gensym (random.ascii/upper_alpha 1)
     #let [expected_lux {#.info            {#.target  target
                                            #.version version
                                            #.mode    #.Build}
                         #.source          [location.dummy 0 source_code]
                         #.location         location.dummy
                         #.current_module  (#.Some expected_current_module)
                         #.modules         (list)
                         #.scopes          (list)
                         #.type_context    {#.ex_counter 0
                                            #.var_counter 0
                                            #.var_bindings (list)}
                         #.expected        (#.Some (#.Primitive primitive_type (list)))
                         #.seed            expected_seed
                         #.scope_type_vars (list)
                         #.extensions      []
                         #.host            []}]]
    ($_ _.and
        (_.cover [/.run]
                 (|> (\ /.monad wrap expected)
                     (/.run expected_lux)
                     (!expect (^multi (#try.Success actual)
                                      (n.= expected actual)))))
        (_.cover [/.run']
                 (|> (\ /.monad wrap expected)
                     (/.run' expected_lux)
                     (!expect (^multi (#try.Success [actual_lux actual])
                                      (and (is? expected_lux actual_lux)
                                           (n.= expected actual))))))
        (_.cover [/.get_compiler]
                 (|> /.get_compiler
                     (/.run expected_lux)
                     (!expect (^multi (#try.Success actual_lux)
                                      (is? expected_lux actual_lux)))))
        )))

(def: error_handling
  Test
  (do random.monad
    [target (random.ascii/upper_alpha 1)
     version (random.ascii/upper_alpha 1)
     source_code (random.ascii/upper_alpha 1)
     expected_current_module (random.ascii/upper_alpha 1)
     primitive_type (random.ascii/upper_alpha 1)
     expected_seed random.nat
     expected random.nat
     dummy (random.filter (|>> (n.= expected) not) random.nat)
     expected_error (random.ascii/upper_alpha 1)
     #let [expected_lux {#.info            {#.target  target
                                            #.version version
                                            #.mode    #.Build}
                         #.source          [location.dummy 0 source_code]
                         #.location         location.dummy
                         #.current_module  (#.Some expected_current_module)
                         #.modules         (list)
                         #.scopes          (list)
                         #.type_context    {#.ex_counter 0
                                            #.var_counter 0
                                            #.var_bindings (list)}
                         #.expected        (#.Some (#.Primitive primitive_type (list)))
                         #.seed            expected_seed
                         #.scope_type_vars (list)
                         #.extensions      []
                         #.host            []}]]
    ($_ _.and
        (_.cover [/.fail]
                 (|> (/.fail expected_error)
                     (: (Meta Any))
                     (/.run expected_lux)
                     (!expect (^multi (#try.Failure actual_error)
                                      (text\= (location.with location.dummy expected_error)
                                              actual_error)))))
        (_.cover [/.assert]
                 (and (|> (/.assert expected_error true)
                          (: (Meta Any))
                          (/.run expected_lux)
                          (!expect (#try.Success [])))
                      (|> (/.assert expected_error false)
                          (/.run expected_lux)
                          (!expect (^multi (#try.Failure actual_error)
                                           (text\= expected_error actual_error))))))
        (_.cover [/.either]
                 (and (|> (/.either (\ /.monad wrap expected)
                                    (: (Meta Nat)
                                       (/.fail expected_error)))
                          (/.run expected_lux)
                          (!expect (^multi (#try.Success actual)
                                           (n.= expected actual))))
                      (|> (/.either (: (Meta Nat)
                                       (/.fail expected_error))
                                    (\ /.monad wrap expected))
                          (/.run expected_lux)
                          (!expect (^multi (#try.Success actual)
                                           (n.= expected actual))))
                      (|> (/.either (: (Meta Nat)
                                       (/.fail expected_error))
                                    (: (Meta Nat)
                                       (/.fail expected_error)))
                          (/.run expected_lux)
                          (!expect (^multi (#try.Failure actual_error)
                                           (text\= (location.with location.dummy expected_error)
                                                   actual_error))))
                      (|> (/.either (\ /.monad wrap expected)
                                    (\ /.monad wrap dummy))
                          (/.run expected_lux)
                          (!expect (^multi (#try.Success actual)
                                           (n.= expected actual))))
                      ))
        )))

(def: module_related
  Test
  (do random.monad
    [target (random.ascii/upper_alpha 1)
     version (random.ascii/upper_alpha 1)
     source_code (random.ascii/upper_alpha 1)
     expected_current_module (random.ascii/upper_alpha 1)
     primitive_type (random.ascii/upper_alpha 1)
     expected_seed random.nat
     expected random.nat
     dummy (random.filter (|>> (n.= expected) not) random.nat)
     expected_error (random.ascii/upper_alpha 1)
     expected_short (random.ascii/upper_alpha 1)
     dummy_module (random.filter (|>> (text\= expected_current_module) not)
                                 (random.ascii/upper_alpha 1))
     #let [expected_lux {#.info            {#.target  target
                                            #.version version
                                            #.mode    #.Build}
                         #.source          [location.dummy 0 source_code]
                         #.location         location.dummy
                         #.current_module  (#.Some expected_current_module)
                         #.modules         (list)
                         #.scopes          (list)
                         #.type_context    {#.ex_counter 0
                                            #.var_counter 0
                                            #.var_bindings (list)}
                         #.expected        (#.Some (#.Primitive primitive_type (list)))
                         #.seed            expected_seed
                         #.scope_type_vars (list)
                         #.extensions      []
                         #.host            []}]]
    ($_ _.and
        (_.cover [/.current_module_name]
                 (|> /.current_module_name
                     (/.run expected_lux)
                     (!expect (^multi (#try.Success actual_current_module)
                                      (text\= expected_current_module actual_current_module)))))
        (_.cover [/.normalize]
                 (and (|> (/.normalize ["" expected_short])
                          (/.run expected_lux)
                          (!expect (^multi (#try.Success [actual_module actual_short])
                                           (and (text\= expected_current_module actual_module)
                                                (is? expected_short actual_short)))))
                      (|> (/.normalize [dummy_module expected_short])
                          (/.run expected_lux)
                          (!expect (^multi (#try.Success [actual_module actual_short])
                                           (and (text\= dummy_module actual_module)
                                                (is? expected_short actual_short)))))))
        )))

(def: random_location
  (Random Location)
  ($_ random.and
      (random.ascii/upper_alpha 1)
      random.nat
      random.nat))

(def: injection
  (Injection Meta)
  (\ /.monad wrap))

(def: (comparison init)
  (-> Lux (Comparison Meta))
  (function (_ == left right)
    (case [(/.run init left)
           (/.run init right)]
      [(#try.Success left) (#try.Success right)]
      (== left right)
      
      _
      false)))

(def: #export test
  Test
  (<| (_.covering /._)
      ($_ _.and
          (do {! random.monad}
            [target (random.ascii/upper_alpha 1)
             version (random.ascii/upper_alpha 1)
             source_code (random.ascii/upper_alpha 1)
             expected_current_module (random.ascii/upper_alpha 1)
             expected_type (\ ! map (function (_ name)
                                      (#.Primitive name (list)))
                              (random.ascii/upper_alpha 1))
             expected_seed random.nat
             expected random.nat
             dummy (random.filter (|>> (n.= expected) not) random.nat)
             expected_error (random.ascii/upper_alpha 1)
             expected_short (random.ascii/upper_alpha 1)
             dummy_module (random.filter (|>> (text\= expected_current_module) not)
                                         (random.ascii/upper_alpha 1))
             expected_gensym (random.ascii/upper_alpha 1)
             expected_location ..random_location
             #let [expected_lux {#.info            {#.target  target
                                                    #.version version
                                                    #.mode    #.Build}
                                 #.source          [location.dummy 0 source_code]
                                 #.location         expected_location
                                 #.current_module  (#.Some expected_current_module)
                                 #.modules         (list)
                                 #.scopes          (list)
                                 #.type_context    {#.ex_counter 0
                                                    #.var_counter 0
                                                    #.var_bindings (list)}
                                 #.expected        (#.Some expected_type)
                                 #.seed            expected_seed
                                 #.scope_type_vars (list)
                                 #.extensions      []
                                 #.host            []}]]
            ($_ _.and
                (_.for [/.functor]
                       ($functor.spec ..injection (..comparison expected_lux) /.functor))
                (_.for [/.apply]
                       ($apply.spec ..injection (..comparison expected_lux) /.apply))
                (_.for [/.monad]
                       ($monad.spec ..injection (..comparison expected_lux) /.monad))
                
                ..compiler_related
                ..error_handling
                ..module_related
                (_.cover [/.count]
                         (|> (do /.monad
                               [pre /.count
                                post /.count]
                               (wrap [pre post]))
                             (/.run expected_lux)
                             (!expect (^multi (#try.Success [actual_pre actual_post])
                                              (and (n.= expected_seed actual_pre)
                                                   (n.= (inc expected_seed) actual_post))))))
                (_.cover [/.gensym]
                         (|> (/.gensym expected_gensym)
                             (\ /.monad map %.code)
                             (/.run expected_lux)
                             (!expect (^multi (#try.Success actual_gensym)
                                              (and (text.contains? expected_gensym actual_gensym)
                                                   (text.contains? (%.nat expected_seed) actual_gensym))))))
                (_.cover [/.location]
                         (|> /.location
                             (/.run expected_lux)
                             (!expect (^multi (#try.Success actual_location)
                                              (is? expected_location actual_location)))))
                (_.cover [/.expected_type]
                         (|> /.expected_type
                             (/.run expected_lux)
                             (!expect (^multi (#try.Success actual_type)
                                              (is? expected_type actual_type)))))
                ))
          
          /annotation.test
          )))
