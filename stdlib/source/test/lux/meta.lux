(.require
 [library
  [lux (.except)
   ["_" test (.only Test)]
   [abstract
    [equivalence (.only Equivalence)]
    [monad (.only do)]
    [\\specification
     ["$[0]" functor (.only Injection Comparison)]
     ["$[0]" apply]
     ["$[0]" monad]]]
   [control
    ["[0]" maybe]
    ["[0]" try (.only Try) (.use "[1]#[0]" functor)]]
   [data
    ["[0]" product]
    ["[0]" bit (.use "[1]#[0]" equivalence)]
    ["[0]" text (.use "[1]#[0]" equivalence)
     ["%" \\format (.only format)]]
    [collection
     ["[0]" list (.use "[1]#[0]" functor monoid)]
     ["[0]" set]]]
   [macro
    ["^" pattern]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" nat]]]
   [meta
    ["[0]" location]
    ["[0]" symbol (.use "[1]#[0]" equivalence)]]]]
 [\\library
  ["[0]" / (.only)
   ["[0]" type (.use "[1]#[0]" equivalence)]]]
 ["[0]" /
  ["[1][0]" location]
  ["[1][0]" symbol]
  ["[1][0]" configuration]
  ["[1][0]" version]
  ["[1][0]" type]])

(def !expect
  (template (_ <pattern> <value>)
    [(case <value>
       <pattern> true
       _ false)]))

(def compiler_related
  Test
  (do random.monad
    [target (random.upper_case 1)
     version (random.upper_case 1)
     source_code (random.upper_case 1)
     expected_current_module (random.upper_case 1)
     primitive_type (random.upper_case 1)
     expected_seed random.nat
     expected random.nat
     dummy (random.only (|>> (n.= expected) not) random.nat)
     configuration_feature (random.upper_case 1)
     configuration_value (random.upper_case 1)
     .let [configuration (list [configuration_feature configuration_value])
           expected_lux [.#info            [.#target target
                                            .#version version
                                            .#mode {.#Build}
                                            .#configuration configuration]
                         .#source          [location.dummy 0 source_code]
                         .#location         location.dummy
                         .#current_module  {.#Some expected_current_module}
                         .#modules         (list)
                         .#scopes          (list)
                         .#type_context    [.#ex_counter 0
                                            .#var_counter 0
                                            .#var_bindings (list)]
                         .#expected        {.#Some {.#Primitive primitive_type (list)}}
                         .#seed            expected_seed
                         .#scope_type_vars (list)
                         .#extensions      []
                         .#eval            (as (-> Type Code (Meta Any)) [])
                         .#host            []]]]
    (all _.and
         (_.coverage [/.result]
           (|> (at /.monad in expected)
               (/.result expected_lux)
               (!expect (^.multi {try.#Success actual}
                                 (n.= expected actual)))))
         (_.coverage [/.result']
           (|> (at /.monad in expected)
               (/.result' expected_lux)
               (!expect (^.multi {try.#Success [actual_lux actual]}
                                 (and (same? expected_lux actual_lux)
                                      (n.= expected actual))))))
         (_.coverage [/.compiler_state]
           (|> /.compiler_state
               (/.result expected_lux)
               (!expect (^.multi {try.#Success actual_lux}
                                 (same? expected_lux actual_lux)))))
         (_.coverage [/.version]
           (|> /.version
               (/.result expected_lux)
               (!expect (^.multi {try.#Success it}
                                 (same? version it)))))
         (_.coverage [/.configuration]
           (|> /.configuration
               (/.result expected_lux)
               (!expect (^.multi {try.#Success it}
                                 (same? configuration it)))))
         )))

(def error_handling
  Test
  (do random.monad
    [target (random.upper_case 1)
     version (random.upper_case 1)
     source_code (random.upper_case 1)
     expected_current_module (random.upper_case 1)
     primitive_type (random.upper_case 1)
     expected_seed random.nat
     expected random.nat
     dummy (random.only (|>> (n.= expected) not) random.nat)
     expected_error (random.upper_case 1)
     .let [expected_lux [.#info            [.#target target
                                            .#version version
                                            .#mode {.#Build}
                                            .#configuration (list)]
                         .#source          [location.dummy 0 source_code]
                         .#location         location.dummy
                         .#current_module  {.#Some expected_current_module}
                         .#modules         (list)
                         .#scopes          (list)
                         .#type_context    [.#ex_counter 0
                                            .#var_counter 0
                                            .#var_bindings (list)]
                         .#expected        {.#Some {.#Primitive primitive_type (list)}}
                         .#seed            expected_seed
                         .#scope_type_vars (list)
                         .#extensions      []
                         .#eval            (as (-> Type Code (Meta Any)) [])
                         .#host            []]]]
    (all _.and
         (_.coverage [/.failure]
           (|> (/.failure expected_error)
               (is (Meta Any))
               (/.result expected_lux)
               (!expect (^.multi {try.#Failure actual_error}
                                 (text#= (location.with location.dummy expected_error)
                                         actual_error)))))
         (_.coverage [/.assertion]
           (and (|> (/.assertion expected_error true)
                    (is (Meta Any))
                    (/.result expected_lux)
                    (!expect {try.#Success []}))
                (|> (/.assertion expected_error false)
                    (/.result expected_lux)
                    (!expect (^.multi {try.#Failure actual_error}
                                      (text#= expected_error actual_error))))))
         (_.coverage [/.either]
           (and (|> (/.either (at /.monad in expected)
                              (is (Meta Nat)
                                  (/.failure expected_error)))
                    (/.result expected_lux)
                    (!expect (^.multi {try.#Success actual}
                                      (n.= expected actual))))
                (|> (/.either (is (Meta Nat)
                                  (/.failure expected_error))
                              (at /.monad in expected))
                    (/.result expected_lux)
                    (!expect (^.multi {try.#Success actual}
                                      (n.= expected actual))))
                (|> (/.either (is (Meta Nat)
                                  (/.failure expected_error))
                              (is (Meta Nat)
                                  (/.failure expected_error)))
                    (/.result expected_lux)
                    (!expect (^.multi {try.#Failure actual_error}
                                      (text#= (location.with location.dummy expected_error)
                                              actual_error))))
                (|> (/.either (at /.monad in expected)
                              (at /.monad in dummy))
                    (/.result expected_lux)
                    (!expect (^.multi {try.#Success actual}
                                      (n.= expected actual))))
                ))
         (_.coverage [/.try]
           (and (|> (/.try (/.failure expected_error))
                    (/.result expected_lux)
                    (!expect (^.multi {try.#Success {try.#Failure actual_error}}
                                      (text#= (location.with location.dummy expected_error)
                                              actual_error))))
                (|> (/.try (at /.monad in expected))
                    (/.result expected_lux)
                    (!expect (^.multi {try.#Success {try.#Success actual}}
                                      (same? expected actual))))))
         )))

(def module_related
  Test
  (do random.monad
    [target (random.upper_case 1)
     version (random.upper_case 1)
     source_code (random.upper_case 1)
     expected_current_module (random.upper_case 1)
     imported_module_name (random.only (|>> (text#= expected_current_module) not)
                                       (random.upper_case 1))
     primitive_type (random.upper_case 1)
     expected_seed random.nat
     expected random.nat
     dummy (random.only (|>> (n.= expected) not) random.nat)
     expected_short (random.upper_case 1)
     dummy_module (random.only (function (_ module)
                                 (not (or (text#= expected_current_module module)
                                          (text#= imported_module_name module))))
                               (random.upper_case 1))
     .let [imported_module [.#module_hash        0
                            .#module_aliases     (list)
                            .#definitions        (list)
                            .#imports            (list)
                            .#module_state       {.#Active}]
           expected_module [.#module_hash        0
                            .#module_aliases     (list)
                            .#definitions        (list)
                            .#imports            (list imported_module_name)
                            .#module_state       {.#Active}]
           expected_modules (list [expected_current_module
                                   expected_module]
                                  [imported_module_name
                                   imported_module])
           expected_lux [.#info            [.#target target
                                            .#version version
                                            .#mode {.#Build}
                                            .#configuration (list)]
                         .#source          [location.dummy 0 source_code]
                         .#location         location.dummy
                         .#current_module  {.#Some expected_current_module}
                         .#modules         expected_modules
                         .#scopes          (list)
                         .#type_context    [.#ex_counter 0
                                            .#var_counter 0
                                            .#var_bindings (list)]
                         .#expected        {.#Some {.#Primitive primitive_type (list)}}
                         .#seed            expected_seed
                         .#scope_type_vars (list)
                         .#extensions      []
                         .#eval            (as (-> Type Code (Meta Any)) [])
                         .#host            []]]]
    (<| (_.for [.Module])
        (all _.and
             (_.coverage [/.current_module_name]
               (|> /.current_module_name
                   (/.result expected_lux)
                   (!expect (^.multi {try.#Success actual_current_module}
                                     (text#= expected_current_module actual_current_module)))))
             (_.coverage [/.current_module]
               (|> /.current_module
                   (/.result expected_lux)
                   (!expect (^.multi {try.#Success actual_module}
                                     (same? expected_module actual_module)))))
             (_.coverage [/.module]
               (|> (/.module expected_current_module)
                   (/.result expected_lux)
                   (!expect (^.multi {try.#Success actual_module}
                                     (same? expected_module actual_module)))))
             (_.coverage [/.module_exists?]
               (and (|> (/.module_exists? expected_current_module)
                        (/.result expected_lux)
                        (!expect {try.#Success #1}))
                    (|> (/.module_exists? dummy_module)
                        (/.result expected_lux)
                        (!expect {try.#Success #0}))))
             (_.coverage [/.modules]
               (|> /.modules
                   (/.result expected_lux)
                   (!expect (^.multi {try.#Success actual_modules}
                                     (same? expected_modules actual_modules)))))
             (_.coverage [/.imported_modules]
               (and (|> (/.imported_modules expected_current_module)
                        (/.result expected_lux)
                        (try#each (at (list.equivalence text.equivalence) =
                                      (list imported_module_name)))
                        (try.else false))
                    (|> (/.imported_modules imported_module_name)
                        (/.result expected_lux)
                        (try#each (at (list.equivalence text.equivalence) =
                                      (list)))
                        (try.else false))))
             (_.coverage [/.imported_by?]
               (|> (/.imported_by? imported_module_name expected_current_module)
                   (/.result expected_lux)
                   (try.else false)))
             (_.coverage [/.imported?]
               (|> (/.imported? imported_module_name)
                   (/.result expected_lux)
                   (try.else false)))
             (_.coverage [/.normal]
               (and (|> (/.normal ["" expected_short])
                        (/.result expected_lux)
                        (!expect (^.multi {try.#Success [actual_module actual_short]}
                                          (and (text#= expected_current_module actual_module)
                                               (same? expected_short actual_short)))))
                    (|> (/.normal [dummy_module expected_short])
                        (/.result expected_lux)
                        (!expect (^.multi {try.#Success [actual_module actual_short]}
                                          (and (text#= dummy_module actual_module)
                                               (same? expected_short actual_short)))))))
             ))))

(def random_location
  (Random Location)
  (all random.and
       (random.upper_case 1)
       random.nat
       random.nat))

(def context_related
  (do [! random.monad]
    [target (random.upper_case 1)
     version (random.upper_case 1)
     source_code (random.upper_case 1)
     expected_current_module (random.upper_case 1)
     expected_type (at ! each (function (_ name)
                                {.#Primitive name (list)})
                       (random.upper_case 1))
     expected_seed random.nat
     expected random.nat
     dummy (random.only (|>> (n.= expected) not) random.nat)
     expected_location ..random_location
     .let [type_context [.#ex_counter 0
                         .#var_counter 0
                         .#var_bindings (list)]
           expected_lux [.#info            [.#target target
                                            .#version version
                                            .#mode {.#Build}
                                            .#configuration (list)]
                         .#source          [location.dummy 0 source_code]
                         .#location         expected_location
                         .#current_module  {.#Some expected_current_module}
                         .#modules         (list)
                         .#scopes          (list)
                         .#type_context    type_context
                         .#expected        {.#Some expected_type}
                         .#seed            expected_seed
                         .#scope_type_vars (list)
                         .#extensions      []
                         .#eval            (as (-> Type Code (Meta Any)) [])
                         .#host            []]]]
    (all _.and
         (_.coverage [/.target]
           (|> /.target
               (/.result expected_lux)
               (try#each (same? target))
               (try.else false)))
         (_.coverage [/.seed]
           (|> (do /.monad
                 [pre /.seed
                  post /.seed]
                 (in [pre post]))
               (/.result expected_lux)
               (!expect (^.multi {try.#Success [actual_pre actual_post]}
                                 (and (n.= expected_seed actual_pre)
                                      (n.= (++ expected_seed) actual_post))))))
         (_.coverage [/.location]
           (|> /.location
               (/.result expected_lux)
               (!expect (^.multi {try.#Success actual_location}
                                 (same? expected_location actual_location)))))
         (_.coverage [/.expected_type]
           (|> /.expected_type
               (/.result expected_lux)
               (!expect (^.multi {try.#Success actual_type}
                                 (same? expected_type actual_type)))))
         (_.coverage [.Type_Context /.type_context]
           (|> /.type_context
               (/.result expected_lux)
               (try#each (same? type_context))
               (try.else false)))
         )))

(def definition_related
  Test
  (do [! random.monad]
    [expected_current_module (random.upper_case 1)
     expected_macro_module (random.only (|>> (text#= expected_current_module) not)
                                        (random.upper_case 1))
     expected_short (random.upper_case 1)
     expected_type (at ! each (function (_ name)
                                {.#Primitive name (list)})
                       (random.upper_case 1))
     expected_value (random.either (in .def)
                                   (in .macro))
     .let [expected_lux
           (is (-> Bit (Maybe Type)
                   [(List [Text .Global])
                    (List [Text .Global])
                    Lux])
               (function (_ exported? def_type)
                 (let [current_globals (is (List [Text .Global])
                                           (list [expected_short
                                                  {.#Alias [expected_macro_module expected_short]}]))
                       macro_globals (is (List [Text .Global])
                                         (case def_type
                                           {.#Some def_type}
                                           (list [expected_short
                                                  {.#Definition [exported? def_type expected_value]}])

                                           {.#None}
                                           (list)))]
                   [current_globals
                    macro_globals
                    [.#info            [.#target ""
                                        .#version ""
                                        .#mode {.#Build}
                                        .#configuration (list)]
                     .#source          [location.dummy 0 ""]
                     .#location         location.dummy
                     .#current_module  {.#Some expected_current_module}
                     .#modules         (list [expected_current_module
                                              [.#module_hash        0
                                               .#module_aliases     (list)
                                               .#definitions        current_globals
                                               .#imports            (list)
                                               .#module_state       {.#Active}]]
                                             [expected_macro_module
                                              [.#module_hash        0
                                               .#module_aliases     (list)
                                               .#definitions        macro_globals
                                               .#imports            (list)
                                               .#module_state       {.#Active}]])
                     .#scopes          (list)
                     .#type_context    [.#ex_counter 0
                                        .#var_counter 0
                                        .#var_bindings (list)]
                     .#expected        {.#None}
                     .#seed            0
                     .#scope_type_vars (list)
                     .#extensions      []
                     .#eval            (as (-> Type Code (Meta Any)) [])
                     .#host            []]])))]]
    (all _.and
         (_.coverage [.Global .Alias /.globals]
           (let [[current_globals macro_globals expected_lux]
                 (expected_lux true {.#Some .Macro})

                 current_globals!
                 (|> (/.globals expected_current_module)
                     (/.result expected_lux)
                     (!expect (^.multi {try.#Success actual_globals}
                                       (same? current_globals actual_globals))))

                 macro_globals!
                 (|> (/.globals expected_macro_module)
                     (/.result expected_lux)
                     (!expect (^.multi {try.#Success actual_globals}
                                       (same? macro_globals actual_globals))))]
             (and current_globals!
                  macro_globals!)))
         (_.coverage [.Definition /.definitions]
           (let [[current_globals macro_globals expected_lux]
                 (expected_lux true {.#Some .Macro})]
             (and (|> (/.definitions expected_current_module)
                      (/.result expected_lux)
                      (!expect (^.multi {try.#Success actual_definitions}
                                        (n.= 0 (list.size actual_definitions)))))
                  (|> (/.definitions expected_macro_module)
                      (/.result expected_lux)
                      (!expect (^.multi {try.#Success actual_definitions}
                                        (n.= 1 (list.size actual_definitions)))))
                  )))
         (_.coverage [/.exports]
           (and (let [[current_globals macro_globals expected_lux]
                      (expected_lux true {.#Some .Macro})]
                  (and (|> (/.exports expected_current_module)
                           (/.result expected_lux)
                           (!expect (^.multi {try.#Success actual_definitions}
                                             (n.= 0 (list.size actual_definitions)))))
                       (|> (/.exports expected_macro_module)
                           (/.result expected_lux)
                           (!expect (^.multi {try.#Success actual_definitions}
                                             (n.= 1 (list.size actual_definitions)))))
                       ))
                (let [[current_globals macro_globals expected_lux]
                      (expected_lux false {.#Some .Macro})]
                  (and (|> (/.exports expected_current_module)
                           (/.result expected_lux)
                           (!expect (^.multi {try.#Success actual_definitions}
                                             (n.= 0 (list.size actual_definitions)))))
                       (|> (/.exports expected_macro_module)
                           (/.result expected_lux)
                           (!expect (^.multi {try.#Success actual_definitions}
                                             (n.= 0 (list.size actual_definitions)))))
                       ))))
         )))

(def search_related
  Test
  (do [! random.monad]
    [expected_exported? random.bit
     expected_current_module (random.upper_case 1)
     expected_macro_module (random.only (|>> (text#= expected_current_module) not)
                                        (random.upper_case 1))
     expected_short (random.upper_case 1)
     expected_type (at ! each (function (_ name)
                                {.#Primitive name (list)})
                       (random.upper_case 1))
     expected_value (random.either (in .def)
                                   (in .macro))
     .let [expected_lux
           (is (-> Bit (Maybe Type)
                   [(List [Text .Global])
                    (List [Text .Global])
                    Lux])
               (function (_ exported? def_type)
                 (let [current_globals (is (List [Text .Global])
                                           (list [expected_short
                                                  {.#Alias [expected_macro_module expected_short]}]))
                       macro_globals (is (List [Text .Global])
                                         (case def_type
                                           {.#Some def_type}
                                           (list [expected_short
                                                  {.#Definition [exported? def_type expected_value]}])

                                           {.#None}
                                           (list)))]
                   [current_globals
                    macro_globals
                    [.#info            [.#target ""
                                        .#version ""
                                        .#mode {.#Build}
                                        .#configuration (list)]
                     .#source          [location.dummy 0 ""]
                     .#location         location.dummy
                     .#current_module  {.#Some expected_current_module}
                     .#modules         (list [expected_current_module
                                              [.#module_hash        0
                                               .#module_aliases     (list)
                                               .#definitions        current_globals
                                               .#imports            (list)
                                               .#module_state       {.#Active}]]
                                             [expected_macro_module
                                              [.#module_hash        0
                                               .#module_aliases     (list)
                                               .#definitions        macro_globals
                                               .#imports            (list)
                                               .#module_state       {.#Active}]])
                     .#scopes          (list)
                     .#type_context    [.#ex_counter 0
                                        .#var_counter 0
                                        .#var_bindings (list)]
                     .#expected        {.#None}
                     .#seed            0
                     .#scope_type_vars (list)
                     .#extensions      []
                     .#eval            (as (-> Type Code (Meta Any)) [])
                     .#host            []]])))]]
    (all _.and
         (_.coverage [/.export]
           (and (let [[current_globals macro_globals expected_lux]
                      (expected_lux true {.#Some expected_type})]
                  (|> (/.export [expected_macro_module expected_short])
                      (/.result expected_lux)
                      (!expect {try.#Success _})))
                (let [[current_globals macro_globals expected_lux]
                      (expected_lux false {.#Some expected_type})]
                  (|> (/.export [expected_macro_module expected_short])
                      (/.result expected_lux)
                      (!expect {try.#Failure _})))))
         (_.coverage [/.macro]
           (let [same_module!
                 (let [[current_globals macro_globals expected_lux]
                       (expected_lux true {.#Some .Macro})]
                   (|> (/.macro [expected_macro_module expected_short])
                       (/.result expected_lux)
                       (!expect (^.multi {try.#Success {.#Some actual_value}}
                                         (same? expected_value actual_value)))))

                 not_macro!
                 (let [[current_globals macro_globals expected_lux]
                       (expected_lux true {.#Some expected_type})]
                   (|> (/.macro [expected_macro_module expected_short])
                       (/.result expected_lux)
                       (!expect {try.#Success {.#None}})))

                 not_found!
                 (let [[current_globals macro_globals expected_lux]
                       (expected_lux true {.#None})]
                   (|> (/.macro [expected_macro_module expected_short])
                       (/.result expected_lux)
                       (!expect {try.#Success {.#None}})))

                 aliasing!
                 (let [[current_globals macro_globals expected_lux]
                       (expected_lux true {.#Some .Macro})]
                   (|> (/.macro [expected_current_module expected_short])
                       (/.result expected_lux)
                       (!expect (^.multi {try.#Success {.#Some actual_value}}
                                         (same? expected_value actual_value)))))]
             (and same_module!
                  not_macro!
                  not_found!
                  aliasing!)))
         (_.coverage [/.de_aliased]
           (let [[current_globals macro_globals expected_lux]
                 (expected_lux true {.#Some .Macro})]
             (and (|> (/.de_aliased [expected_macro_module expected_short])
                      (/.result expected_lux)
                      (try#each (symbol#= [expected_macro_module expected_short]))
                      (try.else false))
                  (|> (/.de_aliased [expected_current_module expected_short])
                      (/.result expected_lux)
                      (try#each (symbol#= [expected_macro_module expected_short]))
                      (try.else false)))))
         (_.coverage [/.definition]
           (let [[current_globals macro_globals expected_lux]
                 (expected_lux expected_exported? {.#Some expected_type})

                 definition!
                 (|> (/.definition [expected_macro_module expected_short])
                     (/.result expected_lux)
                     (!expect (^.multi {try.#Success {.#Definition [actual_exported? actual_type actual_value]}}
                                       (and (bit#= expected_exported? actual_exported?)
                                            (same? expected_type actual_type)
                                            (same? (as Any expected_value) actual_value)))))

                 alias!
                 (|> (/.definition [expected_current_module expected_short])
                     (/.result expected_lux)
                     (!expect (^.multi {try.#Success {.#Alias [actual_module actual_short]}}
                                       (and (same? expected_macro_module actual_module)
                                            (same? expected_short actual_short)))))]
             (and definition!
                  alias!)))
         (_.coverage [/.definition_type]
           (let [[current_globals macro_globals expected_lux]
                 (expected_lux expected_exported? {.#Some expected_type})

                 definition!
                 (|> (/.definition_type [expected_macro_module expected_short])
                     (/.result expected_lux)
                     (!expect (^.multi {try.#Success actual_type}
                                       (same? expected_type actual_type))))

                 alias!
                 (|> (/.definition_type [expected_current_module expected_short])
                     (/.result expected_lux)
                     (!expect (^.multi {try.#Success actual_type}
                                       (same? expected_type actual_type))))]
             (and definition!
                  alias!)))
         (_.coverage [/.type_definition]
           (let [[current_globals macro_globals expected_lux]
                 (expected_lux expected_exported? {.#Some .Type})

                 definition!
                 (|> (/.type_definition [expected_macro_module expected_short])
                     (/.result expected_lux)
                     (!expect (^.multi {try.#Success actual_value}
                                       (same? (as .Type expected_value) actual_value))))

                 alias!
                 (|> (/.type_definition [expected_current_module expected_short])
                     (/.result expected_lux)
                     (!expect (^.multi {try.#Success actual_value}
                                       (same? (as .Type expected_value) actual_value))))]
             (and definition!
                  alias!)))
         )))

(def label_related
  Test
  (do [! random.monad]
    [current_module (random.upper_case 1)
     label_module (random.only (|>> (text#= current_module) not)
                               (random.upper_case 1))

     name_0 (random.upper_case 1)
     name_1 (random.only (|>> (text#= name_0) not)
                         (random.upper_case 1))
     
     .let [random_tag (at ! each (|>> [label_module])
                          (random.upper_case 1))
           random_labels (is (Random [Text (List Text)])
                             (do !
                               [head (random.lower_case 5)]
                               (|> (random.lower_case 5)
                                   (random.only (|>> (text#= head) not))
                                   (random.set text.hash 3)
                                   (at ! each set.list)
                                   (random.and (in head)))))]
     tags_0 random_labels
     tags_1 (let [set/0 (set.of_list text.hash {.#Item tags_0})]
              (random.only (|>> {.#Item}
                                (list.any? (set.member? set/0))
                                not)
                           random_labels))
     .let [type_0 {.#Primitive name_0 (list)}
           type_1 {.#Primitive name_1 (list)}
           
           expected_lux
           (is Lux
               [.#info            [.#target ""
                                   .#version ""
                                   .#mode {.#Build}
                                   .#configuration (list)]
                .#source          [location.dummy 0 ""]
                .#location        location.dummy
                .#current_module  {.#Some current_module}
                .#modules         (list [current_module
                                         [.#module_hash        0
                                          .#module_aliases     (list)
                                          .#definitions        (list)
                                          .#imports            (list label_module)
                                          .#module_state       {.#Active}]]
                                        [label_module
                                         [.#module_hash        0
                                          .#module_aliases     (list)
                                          .#definitions        (list.partial [name_0 {.#Type [true type_0 {.#Left tags_0}]}]
                                                                             [name_1 {.#Type [true type_1 {.#Right tags_1}]}]
                                                                             (all list#composite
                                                                                  (|> {.#Item tags_0}
                                                                                      list.enumeration
                                                                                      (list#each (function (_ [index short])
                                                                                                   [short {.#Tag [true type_0 {.#Item tags_0} index]}])))
                                                                                  (|> {.#Item tags_1}
                                                                                      list.enumeration
                                                                                      (list#each (function (_ [index short])
                                                                                                   [short {.#Slot [true type_1 {.#Item tags_1} index]}])))))
                                          .#imports            (list)
                                          .#module_state       {.#Active}]])
                .#scopes          (list)
                .#type_context    [.#ex_counter 0
                                   .#var_counter 0
                                   .#var_bindings (list)]
                .#expected        {.#None}
                .#seed            0
                .#scope_type_vars (list)
                .#extensions      []
                .#eval            (as (-> Type Code (Meta Any)) [])
                .#host            []])]]
    (all _.and
         (_.coverage [/.tag_lists]
           (let [equivalence (list.equivalence
                              (product.equivalence
                               (list.equivalence symbol.equivalence)
                               type.equivalence))]
             (|> (/.tag_lists label_module)
                 (/.result expected_lux)
                 (try#each (at equivalence = (list [(list#each (|>> [label_module]) {.#Item tags_0})
                                                    type_0]
                                                   [(list#each (|>> [label_module]) {.#Item tags_1})
                                                    type_1])))
                 (try.else false))))
         (_.coverage [/.tags_of]
           (|> (/.tags_of [label_module name_1])
               (/.result expected_lux)
               (try#each (at (maybe.equivalence (list.equivalence symbol.equivalence)) = {.#Some (list#each (|>> [label_module]) {.#Item tags_1})}))
               (try.else false)))
         (_.coverage [/.tag]
           (|> {.#Item tags_0}
               list.enumeration
               (list.every? (function (_ [expected_index label])
                              (|> [label_module label]
                                  /.tag
                                  (/.result expected_lux)
                                  (!expect (^.multi {try.#Success [actual_index actual_tags actual_type]}
                                                    (let [correct_index!
                                                          (n.= expected_index
                                                               actual_index)

                                                          correct_tags!
                                                          (at (list.equivalence symbol.equivalence) =
                                                              (list#each (|>> [label_module]) {.#Item tags_0})
                                                              actual_tags)

                                                          correct_type!
                                                          (type#= type_0
                                                                  actual_type)]
                                                      (and correct_index!
                                                           correct_tags!
                                                           correct_type!))))
                                  )))))
         (_.coverage [/.slot]
           (|> {.#Item tags_1}
               list.enumeration
               (list.every? (function (_ [expected_index label])
                              (|> [label_module label]
                                  /.slot
                                  (/.result expected_lux)
                                  (!expect (^.multi {try.#Success [actual_index actual_tags actual_type]}
                                                    (let [correct_index!
                                                          (n.= expected_index
                                                               actual_index)

                                                          correct_tags!
                                                          (at (list.equivalence symbol.equivalence) =
                                                              (list#each (|>> [label_module]) {.#Item tags_1})
                                                              actual_tags)

                                                          correct_type!
                                                          (type#= type_1
                                                                  actual_type)]
                                                      (and correct_index!
                                                           correct_tags!
                                                           correct_type!))))
                                  )))))
         )))

(def locals_related
  Test
  (do [! random.monad]
    [current_module (random.upper_case 1)
     [name_0 name_1 name_2 name_3 name_4] (|> (random.upper_case 1)
                                              (random.set text.hash 5)
                                              (at ! each set.list)
                                              (random.one (function (_ values)
                                                            (case values
                                                              (pattern (list name_0 name_1 name_2 name_3 name_4))
                                                              {.#Some [name_0 name_1 name_2 name_3 name_4]}

                                                              _
                                                              {.#None}))))
     .let [type_0 {.#Primitive name_0 (list)}
           type_1 {.#Primitive name_1 (list)}
           type_2 {.#Primitive name_2 (list)}
           type_3 {.#Primitive name_3 (list)}
           type_4 {.#Primitive name_4 (list)}

           globals (is (List [Text .Global])
                       (list [name_4
                              {.#Definition [false type_4 []]}]))

           scopes (list [.#name     (list)
                         .#inner    0
                         .#locals   [.#counter 1
                                     .#mappings (list [name_3 [type_3 3]])]
                         .#captured [.#counter 0
                                     .#mappings (list)]]
                        [.#name     (list)
                         .#inner    0
                         .#locals   [.#counter 2
                                     .#mappings (list [name_1 [type_1 1]]
                                                      [name_2 [type_2 2]])]
                         .#captured [.#counter 0
                                     .#mappings (list)]]
                        [.#name     (list)
                         .#inner    0
                         .#locals   [.#counter 1
                                     .#mappings (list [name_0 [type_0 0]])]
                         .#captured [.#counter 0
                                     .#mappings (list)]])]
     .let [expected_lux
           (is Lux
               [.#info            [.#target ""
                                   .#version ""
                                   .#mode {.#Build}
                                   .#configuration (list)]
                .#source          [location.dummy 0 ""]
                .#location        location.dummy
                .#current_module  {.#Some current_module}
                .#modules         (list [current_module
                                         [.#module_hash        0
                                          .#module_aliases     (list)
                                          .#definitions        globals
                                          .#imports            (list)
                                          .#module_state       {.#Active}]])
                .#scopes          scopes
                .#type_context    [.#ex_counter 0
                                   .#var_counter 0
                                   .#var_bindings (list)]
                .#expected        {.#None}
                .#seed            0
                .#scope_type_vars (list)
                .#extensions      []
                .#eval            (as (-> Type Code (Meta Any)) [])
                .#host            []])]]
    (all _.and
         (_.coverage [.Scope /.locals]
           (let [equivalence (is (Equivalence (List (List [Text Type])))
                                 (list.equivalence
                                  (list.equivalence
                                   (product.equivalence
                                    text.equivalence
                                    type.equivalence))))]
             (|> /.locals
                 (/.result expected_lux)
                 (try#each (at equivalence = (list (list [name_3 type_3])
                                                   (list [name_1 type_1]
                                                         [name_2 type_2]))))
                 (try.else false))))
         (_.coverage [/.var_type]
           (and (|> (/.var_type name_0)
                    (/.result expected_lux)
                    (try#each (at type.equivalence = type_0))
                    (try.else false))
                (|> (/.var_type name_1)
                    (/.result expected_lux)
                    (try#each (at type.equivalence = type_1))
                    (try.else false))
                (|> (/.var_type name_2)
                    (/.result expected_lux)
                    (try#each (at type.equivalence = type_2))
                    (try.else false))
                (|> (/.var_type name_3)
                    (/.result expected_lux)
                    (try#each (at type.equivalence = type_3))
                    (try.else false))))
         (_.coverage [/.type]
           (and (|> (/.type ["" name_0])
                    (/.result expected_lux)
                    (try#each (at type.equivalence = type_0))
                    (try.else false))
                (|> (/.type ["" name_1])
                    (/.result expected_lux)
                    (try#each (at type.equivalence = type_1))
                    (try.else false))
                (|> (/.type ["" name_2])
                    (/.result expected_lux)
                    (try#each (at type.equivalence = type_2))
                    (try.else false))
                (|> (/.type ["" name_3])
                    (/.result expected_lux)
                    (try#each (at type.equivalence = type_3))
                    (try.else false))
                (|> (/.type [current_module name_4])
                    (/.result expected_lux)
                    (try#each (at type.equivalence = type_4))
                    (try.else false))
                (|> (/.type ["" name_4])
                    (/.result expected_lux)
                    (try#each (at type.equivalence = type_4))
                    (try.else false))))
         )))

(def injection
  (Injection Meta)
  (at /.monad in))

(def (comparison init)
  (-> Lux (Comparison Meta))
  (function (_ == left right)
    (case [(/.result init left)
           (/.result init right)]
      [{try.#Success left} {try.#Success right}]
      (== left right)
      
      _
      false)))

(def .public test
  Test
  (<| (_.covering /._)
      (_.for [.Meta .Lux])
      (all _.and
           (do [! random.monad]
             [target (random.upper_case 1)
              version (random.upper_case 1)
              source_code (random.upper_case 1)
              expected_current_module (random.upper_case 1)
              expected_type (at ! each (function (_ name)
                                         {.#Primitive name (list)})
                                (random.upper_case 1))
              expected_seed random.nat
              expected random.nat
              dummy (random.only (|>> (n.= expected) not) random.nat)
              expected_location ..random_location
              .let [expected_lux [.#info            [.#target target
                                                     .#version version
                                                     .#mode {.#Build}
                                                     .#configuration (list)]
                                  .#source          [expected_location 0 source_code]
                                  .#location         expected_location
                                  .#current_module  {.#Some expected_current_module}
                                  .#modules         (list)
                                  .#scopes          (list)
                                  .#type_context    [.#ex_counter 0
                                                     .#var_counter 0
                                                     .#var_bindings (list)]
                                  .#expected        {.#Some expected_type}
                                  .#seed            expected_seed
                                  .#scope_type_vars (list)
                                  .#extensions      []
                                  .#eval            (as (-> Type Code (Meta Any)) [])
                                  .#host            []]]]
             (all _.and
                  (_.for [/.functor]
                         ($functor.spec ..injection (..comparison expected_lux) /.functor))
                  (_.for [/.apply]
                         ($apply.spec ..injection (..comparison expected_lux) /.apply))
                  (_.for [/.monad]
                         ($monad.spec ..injection (..comparison expected_lux) /.monad))

                  (do random.monad
                    [expected_value random.nat
                     expected_error (random.upper_case 1)]
                    (_.coverage [/.lifted]
                      (and (|> expected_error
                               {try.#Failure}
                               (is (Try Nat))
                               /.lifted
                               (/.result expected_lux)
                               (!expect (^.multi {try.#Failure actual}
                                                 (text#= (location.with expected_location expected_error)
                                                         actual))))
                           (|> expected_value
                               {try.#Success}
                               (is (Try Nat))
                               /.lifted
                               (/.result expected_lux)
                               (!expect (^.multi {try.#Success actual}
                                                 (same? expected_value actual)))))))
                  
                  ..compiler_related
                  ..error_handling
                  ..module_related
                  ..context_related
                  ..definition_related
                  ..search_related
                  ..locals_related
                  (_.for [.Label]
                         ..label_related)
                  ))
           
           /location.test
           /symbol.test
           /configuration.test
           /version.test
           /type.test
           )))
