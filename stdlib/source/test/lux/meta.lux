(.module:
  [library
   [lux #*
    ["_" test (#+ Test)]
    ["." type ("#\." equivalence)]
    [abstract
     [equivalence (#+ Equivalence)]
     [monad (#+ do)]
     [\\specification
      ["$." functor (#+ Injection Comparison)]
      ["$." apply]
      ["$." monad]]]
    [control
     ["." try (#+ Try) ("#\." functor)]]
    [data
     ["." product]
     ["." maybe]
     ["." bit ("#\." equivalence)]
     ["." name ("#\." equivalence)]
     ["." text ("#\." equivalence)
      ["%" format (#+ format)]]
     [collection
      ["." list ("#\." functor monoid)]
      ["." set]]]
    [meta
     ["." location]]
    [math
     ["." random (#+ Random)]
     [number
      ["n" nat]]]]]
  [\\library
   ["." /]]
  ["." / #_
   ["#." annotation]
   ["#." location]])

(template: (!expect <pattern> <value>)
  [(case <value>
     <pattern> true
     _ false)])

(def: compiler_related
  Test
  (do random.monad
    [target (random.ascii/upper 1)
     version (random.ascii/upper 1)
     source_code (random.ascii/upper 1)
     expected_current_module (random.ascii/upper 1)
     primitive_type (random.ascii/upper 1)
     expected_seed random.nat
     expected random.nat
     dummy (random.only (|>> (n.= expected) not) random.nat)
     .let [expected_lux {#.info            {#.target  target
                                            #.version version
                                            #.mode    #.Build}
                         #.source          [location.dummy 0 source_code]
                         #.location         location.dummy
                         #.current_module  (#.Some expected_current_module)
                         #.modules         (list)
                         #.scopes          (list)
                         #.type_context    {#.ex_counter 0
                                            #.var_counter 0
                                            #.var_bindings (list)}
                         #.expected        (#.Some (#.Primitive primitive_type (list)))
                         #.seed            expected_seed
                         #.scope_type_vars (list)
                         #.extensions      []
                         #.host            []}]]
    ($_ _.and
        (_.cover [/.run]
                 (|> (\ /.monad in expected)
                     (/.run expected_lux)
                     (!expect (^multi (#try.Success actual)
                                      (n.= expected actual)))))
        (_.cover [/.run']
                 (|> (\ /.monad in expected)
                     (/.run' expected_lux)
                     (!expect (^multi (#try.Success [actual_lux actual])
                                      (and (is? expected_lux actual_lux)
                                           (n.= expected actual))))))
        (_.cover [/.get_compiler]
                 (|> /.get_compiler
                     (/.run expected_lux)
                     (!expect (^multi (#try.Success actual_lux)
                                      (is? expected_lux actual_lux)))))
        )))

(def: error_handling
  Test
  (do random.monad
    [target (random.ascii/upper 1)
     version (random.ascii/upper 1)
     source_code (random.ascii/upper 1)
     expected_current_module (random.ascii/upper 1)
     primitive_type (random.ascii/upper 1)
     expected_seed random.nat
     expected random.nat
     dummy (random.only (|>> (n.= expected) not) random.nat)
     expected_error (random.ascii/upper 1)
     .let [expected_lux {#.info            {#.target  target
                                            #.version version
                                            #.mode    #.Build}
                         #.source          [location.dummy 0 source_code]
                         #.location         location.dummy
                         #.current_module  (#.Some expected_current_module)
                         #.modules         (list)
                         #.scopes          (list)
                         #.type_context    {#.ex_counter 0
                                            #.var_counter 0
                                            #.var_bindings (list)}
                         #.expected        (#.Some (#.Primitive primitive_type (list)))
                         #.seed            expected_seed
                         #.scope_type_vars (list)
                         #.extensions      []
                         #.host            []}]]
    ($_ _.and
        (_.cover [/.failure]
                 (|> (/.failure expected_error)
                     (: (Meta Any))
                     (/.run expected_lux)
                     (!expect (^multi (#try.Failure actual_error)
                                      (text\= (location.with location.dummy expected_error)
                                              actual_error)))))
        (_.cover [/.assertion]
                 (and (|> (/.assertion expected_error true)
                          (: (Meta Any))
                          (/.run expected_lux)
                          (!expect (#try.Success [])))
                      (|> (/.assertion expected_error false)
                          (/.run expected_lux)
                          (!expect (^multi (#try.Failure actual_error)
                                           (text\= expected_error actual_error))))))
        (_.cover [/.either]
                 (and (|> (/.either (\ /.monad in expected)
                                    (: (Meta Nat)
                                       (/.failure expected_error)))
                          (/.run expected_lux)
                          (!expect (^multi (#try.Success actual)
                                           (n.= expected actual))))
                      (|> (/.either (: (Meta Nat)
                                       (/.failure expected_error))
                                    (\ /.monad in expected))
                          (/.run expected_lux)
                          (!expect (^multi (#try.Success actual)
                                           (n.= expected actual))))
                      (|> (/.either (: (Meta Nat)
                                       (/.failure expected_error))
                                    (: (Meta Nat)
                                       (/.failure expected_error)))
                          (/.run expected_lux)
                          (!expect (^multi (#try.Failure actual_error)
                                           (text\= (location.with location.dummy expected_error)
                                                   actual_error))))
                      (|> (/.either (\ /.monad in expected)
                                    (\ /.monad in dummy))
                          (/.run expected_lux)
                          (!expect (^multi (#try.Success actual)
                                           (n.= expected actual))))
                      ))
        )))

(def: module_related
  Test
  (do random.monad
    [target (random.ascii/upper 1)
     version (random.ascii/upper 1)
     source_code (random.ascii/upper 1)
     expected_current_module (random.ascii/upper 1)
     imported_module_name (random.only (|>> (text\= expected_current_module) not)
                                       (random.ascii/upper 1))
     primitive_type (random.ascii/upper 1)
     expected_seed random.nat
     expected random.nat
     dummy (random.only (|>> (n.= expected) not) random.nat)
     expected_short (random.ascii/upper 1)
     dummy_module (random.only (function (_ module)
                                 (not (or (text\= expected_current_module module)
                                          (text\= imported_module_name module))))
                               (random.ascii/upper 1))
     .let [imported_module {#.module_hash        0
                            #.module_aliases     (list)
                            #.definitions        (list)
                            #.imports            (list)
                            #.tags               (list)
                            #.types              (list)
                            #.module_annotations #.None
                            #.module_state       #.Active}
           expected_module {#.module_hash        0
                            #.module_aliases     (list)
                            #.definitions        (list)
                            #.imports            (list imported_module_name)
                            #.tags               (list)
                            #.types              (list)
                            #.module_annotations #.None
                            #.module_state       #.Active}
           expected_modules (list [expected_current_module
                                   expected_module]
                                  [imported_module_name
                                   imported_module])
           expected_lux {#.info            {#.target  target
                                            #.version version
                                            #.mode    #.Build}
                         #.source          [location.dummy 0 source_code]
                         #.location         location.dummy
                         #.current_module  (#.Some expected_current_module)
                         #.modules         expected_modules
                         #.scopes          (list)
                         #.type_context    {#.ex_counter 0
                                            #.var_counter 0
                                            #.var_bindings (list)}
                         #.expected        (#.Some (#.Primitive primitive_type (list)))
                         #.seed            expected_seed
                         #.scope_type_vars (list)
                         #.extensions      []
                         #.host            []}]]
    (<| (_.for [.Module])
        ($_ _.and
            (_.cover [/.current_module_name]
                     (|> /.current_module_name
                         (/.run expected_lux)
                         (!expect (^multi (#try.Success actual_current_module)
                                          (text\= expected_current_module actual_current_module)))))
            (_.cover [/.current_module]
                     (|> /.current_module
                         (/.run expected_lux)
                         (!expect (^multi (#try.Success actual_module)
                                          (is? expected_module actual_module)))))
            (_.cover [/.module]
                     (|> (/.module expected_current_module)
                         (/.run expected_lux)
                         (!expect (^multi (#try.Success actual_module)
                                          (is? expected_module actual_module)))))
            (_.cover [/.module_exists?]
                     (and (|> (/.module_exists? expected_current_module)
                              (/.run expected_lux)
                              (!expect (#try.Success #1)))
                          (|> (/.module_exists? dummy_module)
                              (/.run expected_lux)
                              (!expect (#try.Success #0)))))
            (_.cover [/.modules]
                     (|> /.modules
                         (/.run expected_lux)
                         (!expect (^multi (#try.Success actual_modules)
                                          (is? expected_modules actual_modules)))))
            (_.cover [/.imported_modules]
                     (and (|> (/.imported_modules expected_current_module)
                              (/.run expected_lux)
                              (try\map (\ (list.equivalence text.equivalence) =
                                          (list imported_module_name)))
                              (try.else false))
                          (|> (/.imported_modules imported_module_name)
                              (/.run expected_lux)
                              (try\map (\ (list.equivalence text.equivalence) =
                                          (list)))
                              (try.else false))))
            (_.cover [/.imported_by?]
                     (|> (/.imported_by? imported_module_name expected_current_module)
                         (/.run expected_lux)
                         (try.else false)))
            (_.cover [/.imported?]
                     (|> (/.imported? imported_module_name)
                         (/.run expected_lux)
                         (try.else false)))
            (_.cover [/.normal]
                     (and (|> (/.normal ["" expected_short])
                              (/.run expected_lux)
                              (!expect (^multi (#try.Success [actual_module actual_short])
                                               (and (text\= expected_current_module actual_module)
                                                    (is? expected_short actual_short)))))
                          (|> (/.normal [dummy_module expected_short])
                              (/.run expected_lux)
                              (!expect (^multi (#try.Success [actual_module actual_short])
                                               (and (text\= dummy_module actual_module)
                                                    (is? expected_short actual_short)))))))
            ))))

(def: random_location
  (Random Location)
  ($_ random.and
      (random.ascii/upper 1)
      random.nat
      random.nat))

(def: context_related
  (do {! random.monad}
    [target (random.ascii/upper 1)
     version (random.ascii/upper 1)
     source_code (random.ascii/upper 1)
     expected_current_module (random.ascii/upper 1)
     expected_type (\ ! map (function (_ name)
                              (#.Primitive name (list)))
                      (random.ascii/upper 1))
     expected_seed random.nat
     expected random.nat
     dummy (random.only (|>> (n.= expected) not) random.nat)
     expected_location ..random_location
     .let [type_context {#.ex_counter 0
                         #.var_counter 0
                         #.var_bindings (list)}
           expected_lux {#.info            {#.target  target
                                            #.version version
                                            #.mode    #.Build}
                         #.source          [location.dummy 0 source_code]
                         #.location         expected_location
                         #.current_module  (#.Some expected_current_module)
                         #.modules         (list)
                         #.scopes          (list)
                         #.type_context    type_context
                         #.expected        (#.Some expected_type)
                         #.seed            expected_seed
                         #.scope_type_vars (list)
                         #.extensions      []
                         #.host            []}]]
    ($_ _.and
        (_.cover [/.seed]
                 (|> (do /.monad
                       [pre /.seed
                        post /.seed]
                       (in [pre post]))
                     (/.run expected_lux)
                     (!expect (^multi (#try.Success [actual_pre actual_post])
                                      (and (n.= expected_seed actual_pre)
                                           (n.= (inc expected_seed) actual_post))))))
        (_.cover [/.location]
                 (|> /.location
                     (/.run expected_lux)
                     (!expect (^multi (#try.Success actual_location)
                                      (is? expected_location actual_location)))))
        (_.cover [/.expected_type]
                 (|> /.expected_type
                     (/.run expected_lux)
                     (!expect (^multi (#try.Success actual_type)
                                      (is? expected_type actual_type)))))
        (_.cover [.Type_Context /.type_context]
                 (|> /.type_context
                     (/.run expected_lux)
                     (try\map (is? type_context))
                     (try.else false)))
        )))

(def: definition_related
  Test
  (do {! random.monad}
    [expected_current_module (random.ascii/upper 1)
     expected_macro_module (random.only (|>> (text\= expected_current_module) not)
                                        (random.ascii/upper 1))
     expected_short (random.ascii/upper 1)
     expected_type (\ ! map (function (_ name)
                              (#.Primitive name (list)))
                      (random.ascii/upper 1))
     expected_value (random.either (in .def:)
                                   (in .macro:))
     .let [expected_lux
           (: (-> Bit (Maybe Type)
                  [(List [Text .Global])
                   (List [Text .Global])
                   Lux])
              (function (_ exported? def_type)
                (let [current_globals (: (List [Text .Global])
                                         (list [expected_short
                                                (#.Alias [expected_macro_module expected_short])]))
                      macro_globals (: (List [Text .Global])
                                       (case def_type
                                         (#.Some def_type)
                                         (list [expected_short
                                                (#.Definition [exported? def_type (' []) expected_value])])

                                         #.None
                                         (list)))]
                  [current_globals
                   macro_globals
                   {#.info            {#.target  ""
                                       #.version ""
                                       #.mode    #.Build}
                    #.source          [location.dummy 0 ""]
                    #.location         location.dummy
                    #.current_module  (#.Some expected_current_module)
                    #.modules         (list [expected_current_module
                                             {#.module_hash        0
                                              #.module_aliases     (list)
                                              #.definitions        current_globals
                                              #.imports            (list)
                                              #.tags               (list)
                                              #.types              (list)
                                              #.module_annotations #.None
                                              #.module_state       #.Active}]
                                            [expected_macro_module
                                             {#.module_hash        0
                                              #.module_aliases     (list)
                                              #.definitions        macro_globals
                                              #.imports            (list)
                                              #.tags               (list)
                                              #.types              (list)
                                              #.module_annotations #.None
                                              #.module_state       #.Active}])
                    #.scopes          (list)
                    #.type_context    {#.ex_counter 0
                                       #.var_counter 0
                                       #.var_bindings (list)}
                    #.expected        #.None
                    #.seed            0
                    #.scope_type_vars (list)
                    #.extensions      []
                    #.host            []}])))]]
    ($_ _.and
        (_.cover [.Global .Alias /.globals]
                 (let [[current_globals macro_globals expected_lux]
                       (expected_lux true (#.Some .Macro))

                       current_globals!
                       (|> (/.globals expected_current_module)
                           (/.run expected_lux)
                           (!expect (^multi (#try.Success actual_globals)
                                            (is? current_globals actual_globals))))

                       macro_globals!
                       (|> (/.globals expected_macro_module)
                           (/.run expected_lux)
                           (!expect (^multi (#try.Success actual_globals)
                                            (is? macro_globals actual_globals))))]
                   (and current_globals!
                        macro_globals!)))
        (_.cover [.Definition /.definitions]
                 (let [[current_globals macro_globals expected_lux]
                       (expected_lux true (#.Some .Macro))]
                   (and (|> (/.definitions expected_current_module)
                            (/.run expected_lux)
                            (!expect (^multi (#try.Success actual_definitions)
                                             (n.= 0 (list.size actual_definitions)))))
                        (|> (/.definitions expected_macro_module)
                            (/.run expected_lux)
                            (!expect (^multi (#try.Success actual_definitions)
                                             (n.= 1 (list.size actual_definitions)))))
                        )))
        (_.cover [/.exports]
                 (and (let [[current_globals macro_globals expected_lux]
                            (expected_lux true (#.Some .Macro))]
                        (and (|> (/.exports expected_current_module)
                                 (/.run expected_lux)
                                 (!expect (^multi (#try.Success actual_definitions)
                                                  (n.= 0 (list.size actual_definitions)))))
                             (|> (/.exports expected_macro_module)
                                 (/.run expected_lux)
                                 (!expect (^multi (#try.Success actual_definitions)
                                                  (n.= 1 (list.size actual_definitions)))))
                             ))
                      (let [[current_globals macro_globals expected_lux]
                            (expected_lux false (#.Some .Macro))]
                        (and (|> (/.exports expected_current_module)
                                 (/.run expected_lux)
                                 (!expect (^multi (#try.Success actual_definitions)
                                                  (n.= 0 (list.size actual_definitions)))))
                             (|> (/.exports expected_macro_module)
                                 (/.run expected_lux)
                                 (!expect (^multi (#try.Success actual_definitions)
                                                  (n.= 0 (list.size actual_definitions)))))
                             ))))
        )))

(def: search_related
  Test
  (do {! random.monad}
    [expected_exported? random.bit
     expected_current_module (random.ascii/upper 1)
     expected_macro_module (random.only (|>> (text\= expected_current_module) not)
                                        (random.ascii/upper 1))
     expected_short (random.ascii/upper 1)
     expected_type (\ ! map (function (_ name)
                              (#.Primitive name (list)))
                      (random.ascii/upper 1))
     .let [expected_annotations (' [])]
     expected_value (random.either (in .def:)
                                   (in .macro:))
     .let [expected_lux
           (: (-> Bit (Maybe Type)
                  [(List [Text .Global])
                   (List [Text .Global])
                   Lux])
              (function (_ exported? def_type)
                (let [current_globals (: (List [Text .Global])
                                         (list [expected_short
                                                (#.Alias [expected_macro_module expected_short])]))
                      macro_globals (: (List [Text .Global])
                                       (case def_type
                                         (#.Some def_type)
                                         (list [expected_short
                                                (#.Definition [exported? def_type expected_annotations expected_value])])

                                         #.None
                                         (list)))]
                  [current_globals
                   macro_globals
                   {#.info            {#.target  ""
                                       #.version ""
                                       #.mode    #.Build}
                    #.source          [location.dummy 0 ""]
                    #.location         location.dummy
                    #.current_module  (#.Some expected_current_module)
                    #.modules         (list [expected_current_module
                                             {#.module_hash        0
                                              #.module_aliases     (list)
                                              #.definitions        current_globals
                                              #.imports            (list)
                                              #.tags               (list)
                                              #.types              (list)
                                              #.module_annotations #.None
                                              #.module_state       #.Active}]
                                            [expected_macro_module
                                             {#.module_hash        0
                                              #.module_aliases     (list)
                                              #.definitions        macro_globals
                                              #.imports            (list)
                                              #.tags               (list)
                                              #.types              (list)
                                              #.module_annotations #.None
                                              #.module_state       #.Active}])
                    #.scopes          (list)
                    #.type_context    {#.ex_counter 0
                                       #.var_counter 0
                                       #.var_bindings (list)}
                    #.expected        #.None
                    #.seed            0
                    #.scope_type_vars (list)
                    #.extensions      []
                    #.host            []}])))]]
    ($_ _.and
        (_.cover [/.export]
                 (and (let [[current_globals macro_globals expected_lux]
                            (expected_lux true (#.Some expected_type))]
                        (|> (/.export [expected_macro_module expected_short])
                            (/.run expected_lux)
                            (!expect (#try.Success _))))
                      (let [[current_globals macro_globals expected_lux]
                            (expected_lux false (#.Some expected_type))]
                        (|> (/.export [expected_macro_module expected_short])
                            (/.run expected_lux)
                            (!expect (#try.Failure _))))))
        (_.cover [/.macro]
                 (let [same_module!
                       (let [[current_globals macro_globals expected_lux]
                             (expected_lux true (#.Some .Macro))]
                         (|> (/.macro [expected_macro_module expected_short])
                             (/.run expected_lux)
                             (!expect (^multi (#try.Success (#.Some actual_value))
                                              (is? expected_value actual_value)))))

                       not_macro!
                       (let [[current_globals macro_globals expected_lux]
                             (expected_lux true (#.Some expected_type))]
                         (|> (/.macro [expected_macro_module expected_short])
                             (/.run expected_lux)
                             (!expect (#try.Success #.None))))

                       not_found!
                       (let [[current_globals macro_globals expected_lux]
                             (expected_lux true #.None)]
                         (|> (/.macro [expected_macro_module expected_short])
                             (/.run expected_lux)
                             (!expect (#try.Success #.None))))

                       aliasing!
                       (let [[current_globals macro_globals expected_lux]
                             (expected_lux true (#.Some .Macro))]
                         (|> (/.macro [expected_current_module expected_short])
                             (/.run expected_lux)
                             (!expect (^multi (#try.Success (#.Some actual_value))
                                              (is? expected_value actual_value)))))]
                   (and same_module!
                        not_macro!
                        not_found!
                        aliasing!)))
        (_.cover [/.de_aliased]
                 (let [[current_globals macro_globals expected_lux]
                       (expected_lux true (#.Some .Macro))]
                   (and (|> (/.de_aliased [expected_macro_module expected_short])
                            (/.run expected_lux)
                            (try\map (name\= [expected_macro_module expected_short]))
                            (try.else false))
                        (|> (/.de_aliased [expected_current_module expected_short])
                            (/.run expected_lux)
                            (try\map (name\= [expected_macro_module expected_short]))
                            (try.else false)))))
        (_.cover [/.definition]
                 (let [[current_globals macro_globals expected_lux]
                       (expected_lux expected_exported? (#.Some expected_type))

                       definition!
                       (|> (/.definition [expected_macro_module expected_short])
                           (/.run expected_lux)
                           (!expect (^multi (#try.Success (#.Definition [actual_exported? actual_type actual_annotations actual_value]))
                                            (and (bit\= expected_exported? actual_exported?)
                                                 (is? expected_type actual_type)
                                                 (is? expected_annotations actual_annotations)
                                                 (is? (:as Any expected_value) actual_value)))))

                       alias!
                       (|> (/.definition [expected_current_module expected_short])
                           (/.run expected_lux)
                           (!expect (^multi (#try.Success (#.Alias [actual_module actual_short]))
                                            (and (is? expected_macro_module actual_module)
                                                 (is? expected_short actual_short)))))]
                   (and definition!
                        alias!)))
        (_.cover [/.definition_type]
                 (let [[current_globals macro_globals expected_lux]
                       (expected_lux expected_exported? (#.Some expected_type))

                       definition!
                       (|> (/.definition_type [expected_macro_module expected_short])
                           (/.run expected_lux)
                           (!expect (^multi (#try.Success actual_type)
                                            (is? expected_type actual_type))))

                       alias!
                       (|> (/.definition_type [expected_current_module expected_short])
                           (/.run expected_lux)
                           (!expect (^multi (#try.Success actual_type)
                                            (is? expected_type actual_type))))]
                   (and definition!
                        alias!)))
        (_.cover [/.type_definition]
                 (let [[current_globals macro_globals expected_lux]
                       (expected_lux expected_exported? (#.Some .Type))

                       definition!
                       (|> (/.type_definition [expected_macro_module expected_short])
                           (/.run expected_lux)
                           (!expect (^multi (#try.Success actual_value)
                                            (is? (:as .Type expected_value) actual_value))))

                       alias!
                       (|> (/.type_definition [expected_current_module expected_short])
                           (/.run expected_lux)
                           (!expect (^multi (#try.Success actual_value)
                                            (is? (:as .Type expected_value) actual_value))))]
                   (and definition!
                        alias!)))
        )))

(def: tags_related
  Test
  (do {! random.monad}
    [current_module (random.ascii/upper 1)
     tag_module (random.only (|>> (text\= current_module) not)
                             (random.ascii/upper 1))

     name_0 (random.ascii/upper 1)
     name_1 (random.only (|>> (text\= name_0) not)
                         (random.ascii/upper 1))
     
     .let [random_tag (\ ! map (|>> [tag_module])
                         (random.ascii/upper 1))]
     all_tags (|> random_tag
                  (random.set name.hash 10)
                  (\ ! map set.list))
     .let [tags_0 (list.take 5 all_tags)
           tags_1 (list.drop 5 all_tags)

           type_0 (#.Primitive name_0 (list))
           type_1 (#.Primitive name_1 (list))
           
           entry_0 [name_0 [tags_0 false type_0]]
           entry_1 [name_1 [tags_1 true type_1]]

           expected_lux
           (: Lux
              {#.info            {#.target  ""
                                  #.version ""
                                  #.mode    #.Build}
               #.source          [location.dummy 0 ""]
               #.location        location.dummy
               #.current_module  (#.Some current_module)
               #.modules         (list [current_module
                                        {#.module_hash        0
                                         #.module_aliases     (list)
                                         #.definitions        (list)
                                         #.imports            (list tag_module)
                                         #.tags               (list)
                                         #.types              (list)
                                         #.module_annotations #.None
                                         #.module_state       #.Active}]
                                       [tag_module
                                        {#.module_hash        0
                                         #.module_aliases     (list)
                                         #.definitions        (list)
                                         #.imports            (list)
                                         #.tags               (list\compose (|> tags_0
                                                                                list.enumeration
                                                                                (list\map (function (_ [index [_ short]])
                                                                                            [short [index tags_0 false type_0]])))
                                                                            (|> tags_1
                                                                                list.enumeration
                                                                                (list\map (function (_ [index [_ short]])
                                                                                            [short [index tags_1 true type_1]]))))
                                         #.types              (list entry_0 entry_1)
                                         #.module_annotations #.None
                                         #.module_state       #.Active}])
               #.scopes          (list)
               #.type_context    {#.ex_counter 0
                                  #.var_counter 0
                                  #.var_bindings (list)}
               #.expected        #.None
               #.seed            0
               #.scope_type_vars (list)
               #.extensions      []
               #.host            []})]]
    ($_ _.and
        (_.cover [/.tag_lists]
                 (let [equivalence (list.equivalence
                                    (product.equivalence
                                     (list.equivalence name.equivalence)
                                     type.equivalence))]
                   (|> (/.tag_lists tag_module)
                       (/.run expected_lux)
                       (try\map (\ equivalence = (list [tags_1 type_1])))
                       (try.else false))))
        (_.cover [/.tags_of]
                 (|> (/.tags_of [tag_module name_1])
                     (/.run expected_lux)
                     (try\map (\ (maybe.equivalence (list.equivalence name.equivalence)) = (#.Some tags_1)))
                     (try.else false)))
        (_.cover [/.tag]
                 (|> tags_1
                     list.enumeration
                     (list.every? (function (_ [expected_index tag])
                                    (|> tag
                                        /.tag
                                        (/.run expected_lux)
                                        (!expect (^multi (^ (#try.Success [actual_index actual_tags actual_type]))
                                                         (let [correct_index!
                                                               (n.= expected_index
                                                                    actual_index)

                                                               correct_tags!
                                                               (\ (list.equivalence name.equivalence) =
                                                                  tags_1
                                                                  actual_tags)

                                                               correct_type!
                                                               (type\= type_1
                                                                       actual_type)]
                                                           (and correct_index!
                                                                correct_tags!
                                                                correct_type!)))))))))
        )))

(def: locals_related
  Test
  (do {! random.monad}
    [current_module (random.ascii/upper 1)
     [name_0 name_1 name_2 name_3 name_4] (|> (random.ascii/upper 1)
                                              (random.set text.hash 5)
                                              (\ ! map set.list)
                                              (random.one (function (_ values)
                                                            (case values
                                                              (^ (list name_0 name_1 name_2 name_3 name_4))
                                                              (#.Some [name_0 name_1 name_2 name_3 name_4])

                                                              _
                                                              #.None))))
     .let [type_0 (#.Primitive name_0 (list))
           type_1 (#.Primitive name_1 (list))
           type_2 (#.Primitive name_2 (list))
           type_3 (#.Primitive name_3 (list))
           type_4 (#.Primitive name_4 (list))

           globals (: (List [Text .Global])
                      (list [name_4
                             (#.Definition [false type_4 (' {}) []])]))

           scopes (list {#.name     (list)
                         #.inner    0
                         #.locals   {#.counter 1
                                     #.mappings (list [name_3 [type_3 3]])}
                         #.captured {#.counter 0
                                     #.mappings (list)}}
                        {#.name     (list)
                         #.inner    0
                         #.locals   {#.counter 2
                                     #.mappings (list [name_1 [type_1 1]]
                                                      [name_2 [type_2 2]])}
                         #.captured {#.counter 0
                                     #.mappings (list)}}
                        {#.name     (list)
                         #.inner    0
                         #.locals   {#.counter 1
                                     #.mappings (list [name_0 [type_0 0]])}
                         #.captured {#.counter 0
                                     #.mappings (list)}})]
     .let [expected_lux
           (: Lux
              {#.info            {#.target  ""
                                  #.version ""
                                  #.mode    #.Build}
               #.source          [location.dummy 0 ""]
               #.location        location.dummy
               #.current_module  (#.Some current_module)
               #.modules         (list [current_module
                                        {#.module_hash        0
                                         #.module_aliases     (list)
                                         #.definitions        globals
                                         #.imports            (list)
                                         #.tags               (list)
                                         #.types              (list)
                                         #.module_annotations #.None
                                         #.module_state       #.Active}])
               #.scopes          scopes
               #.type_context    {#.ex_counter 0
                                  #.var_counter 0
                                  #.var_bindings (list)}
               #.expected        #.None
               #.seed            0
               #.scope_type_vars (list)
               #.extensions      []
               #.host            []})]]
    ($_ _.and
        (_.cover [.Scope /.locals]
                 (let [equivalence (: (Equivalence (List (List [Text Type])))
                                      (list.equivalence
                                       (list.equivalence
                                        (product.equivalence
                                         text.equivalence
                                         type.equivalence))))]
                   (|> /.locals
                       (/.run expected_lux)
                       (try\map (\ equivalence = (list (list [name_3 type_3])
                                                       (list [name_1 type_1]
                                                             [name_2 type_2]))))
                       (try.else false))))
        (_.cover [/.var_type]
                 (and (|> (/.var_type name_0)
                          (/.run expected_lux)
                          (try\map (\ type.equivalence = type_0))
                          (try.else false))
                      (|> (/.var_type name_1)
                          (/.run expected_lux)
                          (try\map (\ type.equivalence = type_1))
                          (try.else false))
                      (|> (/.var_type name_2)
                          (/.run expected_lux)
                          (try\map (\ type.equivalence = type_2))
                          (try.else false))
                      (|> (/.var_type name_3)
                          (/.run expected_lux)
                          (try\map (\ type.equivalence = type_3))
                          (try.else false))))
        (_.cover [/.type]
                 (and (|> (/.type ["" name_0])
                          (/.run expected_lux)
                          (try\map (\ type.equivalence = type_0))
                          (try.else false))
                      (|> (/.type ["" name_1])
                          (/.run expected_lux)
                          (try\map (\ type.equivalence = type_1))
                          (try.else false))
                      (|> (/.type ["" name_2])
                          (/.run expected_lux)
                          (try\map (\ type.equivalence = type_2))
                          (try.else false))
                      (|> (/.type ["" name_3])
                          (/.run expected_lux)
                          (try\map (\ type.equivalence = type_3))
                          (try.else false))
                      (|> (/.type [current_module name_4])
                          (/.run expected_lux)
                          (try\map (\ type.equivalence = type_4))
                          (try.else false))
                      (|> (/.type ["" name_4])
                          (/.run expected_lux)
                          (try\map (\ type.equivalence = type_4))
                          (try.else false))))
        )))

(def: injection
  (Injection Meta)
  (\ /.monad in))

(def: (comparison init)
  (-> Lux (Comparison Meta))
  (function (_ == left right)
    (case [(/.run init left)
           (/.run init right)]
      [(#try.Success left) (#try.Success right)]
      (== left right)
      
      _
      false)))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [.Meta .Lux])
      ($_ _.and
          (do {! random.monad}
            [target (random.ascii/upper 1)
             version (random.ascii/upper 1)
             source_code (random.ascii/upper 1)
             expected_current_module (random.ascii/upper 1)
             expected_type (\ ! map (function (_ name)
                                      (#.Primitive name (list)))
                              (random.ascii/upper 1))
             expected_seed random.nat
             expected random.nat
             dummy (random.only (|>> (n.= expected) not) random.nat)
             expected_location ..random_location
             .let [expected_lux {#.info            {#.target  target
                                                    #.version version
                                                    #.mode    #.Build}
                                 #.source          [expected_location 0 source_code]
                                 #.location         expected_location
                                 #.current_module  (#.Some expected_current_module)
                                 #.modules         (list)
                                 #.scopes          (list)
                                 #.type_context    {#.ex_counter 0
                                                    #.var_counter 0
                                                    #.var_bindings (list)}
                                 #.expected        (#.Some expected_type)
                                 #.seed            expected_seed
                                 #.scope_type_vars (list)
                                 #.extensions      []
                                 #.host            []}]]
            ($_ _.and
                (_.for [/.functor]
                       ($functor.spec ..injection (..comparison expected_lux) /.functor))
                (_.for [/.apply]
                       ($apply.spec ..injection (..comparison expected_lux) /.apply))
                (_.for [/.monad]
                       ($monad.spec ..injection (..comparison expected_lux) /.monad))

                (do random.monad
                  [expected_value random.nat
                   expected_error (random.ascii/upper 1)]
                  (_.cover [/.lift]
                           (and (|> expected_error
                                    #try.Failure
                                    (: (Try Nat))
                                    /.lift
                                    (/.run expected_lux)
                                    (!expect (^multi (#try.Failure actual)
                                                     (text\= (location.with expected_location expected_error)
                                                             actual))))
                                (|> expected_value
                                    #try.Success
                                    (: (Try Nat))
                                    /.lift
                                    (/.run expected_lux)
                                    (!expect (^multi (#try.Success actual)
                                                     (is? expected_value actual)))))))
                
                ..compiler_related
                ..error_handling
                ..module_related
                ..context_related
                ..definition_related
                ..search_related
                ..tags_related
                ..locals_related
                ))
          
          /annotation.test
          /location.test
          )))
