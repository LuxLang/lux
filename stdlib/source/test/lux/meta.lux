... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except)
   [abstract
    [equivalence (.only Equivalence)]
    ["[0]" monad (.only do)
     ["[1]T" \\test]]
    ["[0]" functor
     ["[1]T" \\test (.only Injection Comparison)]]
    ["[0]" apply
     ["[1]T" \\test]]]
   [control
    ["[0]" maybe]
    ["[0]" try (.only Try) (.use "[1]#[0]" functor)]]
   [data
    ["[0]" product]
    ["[0]" bit (.use "[1]#[0]" equivalence)]
    ["[0]" text (.use "[1]#[0]" equivalence)]
    [collection
     ["[0]" list (.use "[1]#[0]" functor monoid)]
     ["[0]" set]]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" nat]]]
   [meta
    ["[0]" location]
    ["[0]" symbol (.use "[1]#[0]" equivalence)]
    [macro
     ["^" pattern]
     ["[0]" template]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" / (.only)
   ["[0]" type (.use "[1]#[0]" equivalence)]]]
 ["[0]" /
  ["[1][0]" code]
  ["[1][0]" location]
  ["[1][0]" symbol]
  ["[1][0]" configuration]
  ["[1][0]" version]
  ["[1][0]" type]
  ["[1][0]" macro]
  ["[1][0]" static]
  ["[1][0]" extension]
  ["[1][0]" global]
  ["[1][0]" compiler]
  ["[1][0]" label]
  ["[1][0]" binding]
  [module
   ["[1][0]" import]]])

(the !expect
  (template.macro (_ <pattern> <value>)
    [(when <value>
       <pattern> true
       _ false)]))

(the compiler_related
  Test
  (do random.monad
    [target (random.upper_cased 1)
     version (random.upper_cased 1)
     source_code (random.upper_cased 1)
     expected_current_module (random.upper_cased 1)
     nominal_type (random.upper_cased 1)
     expected_seed random.nat
     expected random.nat
     dummy (random.only (|>> (n.= expected) not) random.nat)
     configuration_feature (random.upper_cased 1)
     configuration_value (random.upper_cased 1)
     .let [configuration (list [configuration_feature configuration_value])
           expected_lux [.#info            [.#target target
                                            .#version version
                                            .#mode {.#Build}
                                            .#configuration configuration]
                         .#source          [location.dummy 0 source_code]
                         .#location         location.dummy
                         .#current_module  {.#Some expected_current_module}
                         .#modules         (list)
                         .#scopes          (list)
                         .#type_context    [.#ex_counter 0
                                            .#var_counter 0
                                            .#var_bindings (list)]
                         .#expected        {.#Some {.#Nominal nominal_type (list)}}
                         .#seed            expected_seed
                         .#scope_type_vars (list)
                         .#extensions      []
                         .#eval            (as (-> Type Code (Meta Any)) [])
                         .#host            []]]]
    (all _.and
         (_.coverage [/.value]
           (|> (of /.monad in expected)
               (/.value expected_lux)
               (!expect (^.multi {try.#Success actual}
                                 (n.= expected actual)))))
         (_.coverage [/.value']
           (|> (of /.monad in expected)
               (/.value' expected_lux)
               (!expect (^.multi {try.#Success [actual_lux actual]}
                                 (and (same? expected_lux actual_lux)
                                      (n.= expected actual))))))
         (_.coverage [/.compiler_state]
           (|> /.compiler_state
               (/.value expected_lux)
               (!expect (^.multi {try.#Success actual_lux}
                                 (same? expected_lux actual_lux)))))
         (_.coverage [/.version]
           (|> /.version
               (/.value expected_lux)
               (!expect (^.multi {try.#Success it}
                                 (same? version it)))))
         (_.coverage [/.configuration]
           (|> /.configuration
               (/.value expected_lux)
               (!expect (^.multi {try.#Success it}
                                 (same? configuration it)))))
         )))

(the error_handling
  Test
  (do random.monad
    [target (random.upper_cased 1)
     version (random.upper_cased 1)
     source_code (random.upper_cased 1)
     expected_current_module (random.upper_cased 1)
     nominal_type (random.upper_cased 1)
     expected_seed random.nat
     expected random.nat
     dummy (random.only (|>> (n.= expected) not) random.nat)
     expected_error (random.upper_cased 1)
     .let [expected_lux [.#info            [.#target target
                                            .#version version
                                            .#mode {.#Build}
                                            .#configuration (list)]
                         .#source          [location.dummy 0 source_code]
                         .#location         location.dummy
                         .#current_module  {.#Some expected_current_module}
                         .#modules         (list)
                         .#scopes          (list)
                         .#type_context    [.#ex_counter 0
                                            .#var_counter 0
                                            .#var_bindings (list)]
                         .#expected        {.#Some {.#Nominal nominal_type (list)}}
                         .#seed            expected_seed
                         .#scope_type_vars (list)
                         .#extensions      []
                         .#eval            (as (-> Type Code (Meta Any)) [])
                         .#host            []]]]
    (all _.and
         (_.coverage [/.failure]
           (|> (/.failure expected_error)
               (is (Meta Any))
               (/.value expected_lux)
               (!expect (^.multi {try.#Failure actual_error}
                                 (text#= (location.with location.dummy expected_error)
                                         actual_error)))))
         (_.coverage [/.assertion]
           (and (|> (/.assertion expected_error true)
                    (is (Meta Any))
                    (/.value expected_lux)
                    (!expect {try.#Success []}))
                (|> (/.assertion expected_error false)
                    (/.value expected_lux)
                    (!expect (^.multi {try.#Failure actual_error}
                                      (text#= expected_error actual_error))))))
         (_.coverage [/.either]
           (and (|> (/.either (of /.monad in expected)
                              (is (Meta Nat)
                                  (/.failure expected_error)))
                    (/.value expected_lux)
                    (!expect (^.multi {try.#Success actual}
                                      (n.= expected actual))))
                (|> (/.either (is (Meta Nat)
                                  (/.failure expected_error))
                              (of /.monad in expected))
                    (/.value expected_lux)
                    (!expect (^.multi {try.#Success actual}
                                      (n.= expected actual))))
                (|> (/.either (is (Meta Nat)
                                  (/.failure expected_error))
                              (is (Meta Nat)
                                  (/.failure expected_error)))
                    (/.value expected_lux)
                    (!expect (^.multi {try.#Failure actual_error}
                                      (text#= (location.with location.dummy expected_error)
                                              actual_error))))
                (|> (/.either (of /.monad in expected)
                              (of /.monad in dummy))
                    (/.value expected_lux)
                    (!expect (^.multi {try.#Success actual}
                                      (n.= expected actual))))
                ))
         (_.coverage [/.try]
           (and (|> (/.try (/.failure expected_error))
                    (/.value expected_lux)
                    (!expect (^.multi {try.#Success {try.#Failure actual_error}}
                                      (text#= (location.with location.dummy expected_error)
                                              actual_error))))
                (|> (/.try (of /.monad in expected))
                    (/.value expected_lux)
                    (!expect (^.multi {try.#Success {try.#Success actual}}
                                      (same? expected actual))))))
         )))

(the module_related
  Test
  (do random.monad
    [target (random.upper_cased 1)
     version (random.upper_cased 1)
     source_code (random.upper_cased 1)
     expected_current_module (random.upper_cased 1)
     imported_module_name (random.only (|>> (text#= expected_current_module) not)
                                       (random.upper_cased 1))
     nominal_type (random.upper_cased 1)
     expected_seed random.nat
     expected random.nat
     dummy (random.only (|>> (n.= expected) not) random.nat)
     expected_short (random.upper_cased 1)
     dummy_module (random.only (function (_ module)
                                 (not (or (text#= expected_current_module module)
                                          (text#= imported_module_name module))))
                               (random.upper_cased 1))
     .let [imported_module [.#module_hash        0
                            .#module_aliases     (list)
                            .#definitions        (list)
                            .#imports            (list)
                            .#module_state       {.#Active}]
           expected_module [.#module_hash        0
                            .#module_aliases     (list)
                            .#definitions        (list)
                            .#imports            (list imported_module_name)
                            .#module_state       {.#Active}]
           expected_modules (list [expected_current_module
                                   expected_module]
                                  [imported_module_name
                                   imported_module])
           expected_lux [.#info            [.#target target
                                            .#version version
                                            .#mode {.#Build}
                                            .#configuration (list)]
                         .#source          [location.dummy 0 source_code]
                         .#location         location.dummy
                         .#current_module  {.#Some expected_current_module}
                         .#modules         expected_modules
                         .#scopes          (list)
                         .#type_context    [.#ex_counter 0
                                            .#var_counter 0
                                            .#var_bindings (list)]
                         .#expected        {.#Some {.#Nominal nominal_type (list)}}
                         .#seed            expected_seed
                         .#scope_type_vars (list)
                         .#extensions      []
                         .#eval            (as (-> Type Code (Meta Any)) [])
                         .#host            []]]]
    (<| (_.for [.Module
                .#module_hash .#module_aliases .#definitions .#imports .#module_state])
        (all _.and
             (_.coverage [/.current_module_name]
               (|> /.current_module_name
                   (/.value expected_lux)
                   (!expect (^.multi {try.#Success actual_current_module}
                                     (text#= expected_current_module actual_current_module)))))
             (_.coverage [/.current_module]
               (|> /.current_module
                   (/.value expected_lux)
                   (!expect (^.multi {try.#Success actual_module}
                                     (same? expected_module actual_module)))))
             (_.coverage [/.module]
               (|> (/.module expected_current_module)
                   (/.value expected_lux)
                   (!expect (^.multi {try.#Success actual_module}
                                     (same? expected_module actual_module)))))
             (_.coverage [/.module_exists?]
               (and (|> (/.module_exists? expected_current_module)
                        (/.value expected_lux)
                        (!expect {try.#Success .true}))
                    (|> (/.module_exists? dummy_module)
                        (/.value expected_lux)
                        (!expect {try.#Success .false}))))
             (_.coverage [/.modules]
               (|> /.modules
                   (/.value expected_lux)
                   (!expect (^.multi {try.#Success actual_modules}
                                     (same? expected_modules actual_modules)))))
             ))))

(the random_location
  (Random Location)
  (all random.and
       (random.upper_cased 1)
       random.nat
       random.nat))

(the context_related
  (do [! random.monad]
    [target (random.upper_cased 1)
     version (random.upper_cased 1)
     source_code (random.upper_cased 1)
     expected_current_module (random.upper_cased 1)
     expected_type (of ! each (function (_ name)
                                {.#Nominal name (list)})
                       (random.upper_cased 1))
     expected_seed random.nat
     expected random.nat
     dummy (random.only (|>> (n.= expected) not) random.nat)
     expected_location ..random_location
     .let [type_context [.#ex_counter 0
                         .#var_counter 0
                         .#var_bindings (list)]
           expected_lux [.#info            [.#target target
                                            .#version version
                                            .#mode {.#Build}
                                            .#configuration (list)]
                         .#source          [location.dummy 0 source_code]
                         .#location         expected_location
                         .#current_module  {.#Some expected_current_module}
                         .#modules         (list)
                         .#scopes          (list)
                         .#type_context    type_context
                         .#expected        {.#Some expected_type}
                         .#seed            expected_seed
                         .#scope_type_vars (list)
                         .#extensions      []
                         .#eval            (as (-> Type Code (Meta Any)) [])
                         .#host            []]]]
    (all _.and
         (_.coverage [/.target]
           (|> /.target
               (/.value expected_lux)
               (try#each (same? target))
               (try.else false)))
         (_.coverage [/.seed]
           (|> (do /.monad
                 [pre /.seed
                  post /.seed]
                 (in [pre post]))
               (/.value expected_lux)
               (!expect (^.multi {try.#Success [actual_pre actual_post]}
                                 (and (n.= expected_seed actual_pre)
                                      (n.= (++ expected_seed) actual_post))))))
         (_.coverage [/.location]
           (|> /.location
               (/.value expected_lux)
               (!expect (^.multi {try.#Success actual_location}
                                 (same? expected_location actual_location)))))
         (_.coverage [/.expected_type]
           (|> /.expected_type
               (/.value expected_lux)
               (!expect (^.multi {try.#Success actual_type}
                                 (same? expected_type actual_type)))))
         (_.coverage [.Type_Context
                      .#ex_counter .#var_counter .#var_bindings

                      /.type_context]
           (|> /.type_context
               (/.value expected_lux)
               (try#each (same? type_context))
               (try.else false)))
         )))

(the label_related
  Test
  (do [! random.monad]
    [current_module (random.upper_cased 1)
     label_module (random.upper_cased 2)

     name_0 (random.upper_cased 3)
     name_1 (random.upper_cased 4)

     .let [random_tag (of ! each (|>> [label_module])
                          (random.upper_cased 1))
           random_labels (is (-> Nat
                                 (Random [Text (List Text)]))
                             (function (_ size)
                               (do !
                                 [head (random.lower_cased size)]
                                 (|> (random.lower_cased size)
                                     (random.only (|>> (text#= head) not))
                                     (random.set text.hash 3)
                                     (of ! each set.list)
                                     (random.and (in head))))))]
     tags_0 (random_labels 5)
     tags_1 (random_labels 6)
     .let [type_0 {.#Named [label_module name_1] {.#Nominal name_0 (list)}}
           type_1 {.#Named [label_module name_1] {.#Nominal name_1 (list)}}

           expected_lux
           (is Lux
               [.#info            [.#target ""
                                   .#version ""
                                   .#mode {.#Build}
                                   .#configuration (list)]
                .#source          [location.dummy 0 ""]
                .#location        location.dummy
                .#current_module  {.#Some current_module}
                .#modules         (list [current_module
                                         [.#module_hash        0
                                          .#module_aliases     (list)
                                          .#definitions        (list)
                                          .#imports            (list label_module)
                                          .#module_state       {.#Active}]]
                                        [label_module
                                         [.#module_hash        0
                                          .#module_aliases     (list)
                                          .#definitions        (list.partial [name_0 [true {.#Definition [.Type type_0]}]]
                                                                             [name_1 [true {.#Definition [.Type type_1]}]]
                                                                             (all list#composite
                                                                                  (let [cohort (is (List Symbol)
                                                                                                   (list#each (|>> [label_module])
                                                                                                              {.#Item tags_0}))
                                                                                        last (-- (list.size cohort))
                                                                                        right? (n.= last)
                                                                                        lefts (is (-> Nat Nat)
                                                                                                  (function (_ index)
                                                                                                    (if (right? index)
                                                                                                      (-- index)
                                                                                                      index)))]
                                                                                    (|> {.#Item tags_0}
                                                                                        list.enumeration
                                                                                        (list#each (function (_ [index short])
                                                                                                     [short [true {.#Definition [.Tag
                                                                                                                                 (|> [{.#Some [(lefts index) (right? index) cohort]} type_0]
                                                                                                                                     (is Label)
                                                                                                                                     (as .Tag))]}]]))))
                                                                                  (let [cohort (is (List Symbol)
                                                                                                   (list#each (|>> [label_module])
                                                                                                              {.#Item tags_1}))
                                                                                        last (-- (list.size cohort))
                                                                                        right? (n.= last)
                                                                                        lefts (is (-> Nat Nat)
                                                                                                  (function (_ index)
                                                                                                    (if (right? index)
                                                                                                      (-- index)
                                                                                                      index)))]
                                                                                    (|> {.#Item tags_1}
                                                                                        list.enumeration
                                                                                        (list#each (function (_ [index short])
                                                                                                     [short [true {.#Definition [.Slot
                                                                                                                                 (|> [{.#Some [(lefts index) (right? index) cohort]} type_1]
                                                                                                                                     (is Label)
                                                                                                                                     (as .Slot))]}]]))))))
                                          .#imports            (list)
                                          .#module_state       {.#Active}]])
                .#scopes          (list)
                .#type_context    [.#ex_counter 0
                                   .#var_counter 0
                                   .#var_bindings (list)]
                .#expected        {.#None}
                .#seed            0
                .#scope_type_vars (list)
                .#extensions      []
                .#eval            (as (-> Type Code (Meta Any)) [])
                .#host            []])]]
    (all _.and
         (_.coverage [/.tag_lists]
           (let [equivalence (list.equivalence
                              (product.equivalence
                               (list.equivalence symbol.equivalence)
                               type.equivalence))]
             (|> (/.tag_lists label_module)
                 (/.value expected_lux)
                 (try#each (of equivalence = (list [(list#each (|>> [label_module]) {.#Item tags_1})
                                                    type_1])))
                 (try.else false))))
         )))

(the injection
  (Injection Meta)
  (of /.monad in))

(the (comparison init)
  (-> Lux (Comparison Meta))
  (function (_ == left right)
    (when [(/.value init left)
           (/.value init right)]
      [{try.#Success left} {try.#Success right}]
      (== left right)

      _
      false)))

(`` (`` (the .public test
          Test
          (<| (_.covering /._)
              (_.for [.Meta .Lux
                      .#info .#source .#location .#current_module
                      .#modules .#scopes .#type_context .#expected
                      .#seed .#scope_type_vars .#extensions .#eval
                      .#host])
              (all _.and
                   (do [! random.monad]
                     [target (random.upper_cased 1)
                      version (random.upper_cased 1)
                      source_code (random.upper_cased 1)
                      expected_current_module (random.upper_cased 1)
                      expected_type (of ! each (function (_ name)
                                                 {.#Nominal name (list)})
                                        (random.upper_cased 1))
                      expected_seed random.nat
                      expected random.nat
                      dummy (random.only (|>> (n.= expected) not) random.nat)
                      expected_location ..random_location
                      .let [expected_lux [.#info            [.#target target
                                                             .#version version
                                                             .#mode {.#Build}
                                                             .#configuration (list)]
                                          .#source          [expected_location 0 source_code]
                                          .#location         expected_location
                                          .#current_module  {.#Some expected_current_module}
                                          .#modules         (list)
                                          .#scopes          (list)
                                          .#type_context    [.#ex_counter 0
                                                             .#var_counter 0
                                                             .#var_bindings (list)]
                                          .#expected        {.#Some expected_type}
                                          .#seed            expected_seed
                                          .#scope_type_vars (list)
                                          .#extensions      []
                                          .#eval            (as (-> Type Code (Meta Any)) [])
                                          .#host            []]]]
                     (all _.and
                          (_.for [/.functor]
                                 (functorT.spec ..injection (..comparison expected_lux) /.functor))
                          (_.for [/.apply]
                                 (applyT.spec ..injection (..comparison expected_lux) /.apply))
                          (_.for [/.monad]
                                 (monadT.spec ..injection (..comparison expected_lux) /.monad))

                          (do random.monad
                            [expected_value random.nat
                             expected_error (random.upper_cased 1)]
                            (_.coverage [/.of_try]
                              (and (|> expected_error
                                       {try.#Failure}
                                       (is (Try Nat))
                                       /.of_try
                                       (/.value expected_lux)
                                       (!expect (^.multi {try.#Failure actual}
                                                         (text#= (location.with expected_location expected_error)
                                                                 actual))))
                                   (|> expected_value
                                       {try.#Success}
                                       (is (Try Nat))
                                       /.of_try
                                       (/.value expected_lux)
                                       (!expect (^.multi {try.#Success actual}
                                                         (same? expected_value actual)))))))
                          
                          ..compiler_related
                          ..error_handling
                          ..module_related
                          ..context_related
                          (_.for [.Label]
                                 ..label_related)
                          ))
                   
                   /code.test
                   /location.test
                   /symbol.test
                   /configuration.test
                   /version.test
                   /type.test
                   /macro.test
                   /static.test
                   (,, (for .old (,, (these))
                            (,, (these /extension.test))))
                   /global.test
                   /compiler.test
                   /label.test
                   /binding.test
                   /import.test
                   )))))
