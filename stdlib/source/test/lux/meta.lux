... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except)
   [abstract
    [equivalence (.only Equivalence)]
    ["[0]" monad (.only do)
     ["[1]T" \\test]]
    ["[0]" functor
     ["[1]T" \\test (.only Injection Comparison)]]
    ["[0]" apply
     ["[1]T" \\test]]]
   [control
    ["[0]" maybe]
    ["[0]" try (.only Try) (.use "[1]#[0]" functor)]]
   [data
    ["[0]" product]
    ["[0]" bit (.use "[1]#[0]" equivalence)]
    ["[0]" text (.use "[1]#[0]" equivalence)
     ["%" \\format (.only format)]]
    [collection
     ["[0]" list (.use "[1]#[0]" functor monoid)]
     ["[0]" set]]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" nat]]]
   [meta
    ["[0]" location]
    ["[0]" symbol (.use "[1]#[0]" equivalence)]
    [macro
     ["^" pattern]]
    [compiler
     ["@" target]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" / (.only)
   ["[0]" type (.use "[1]#[0]" equivalence)]]]
 ["[0]" /
  ["[1][0]" code]
  ["[1][0]" location]
  ["[1][0]" symbol]
  ["[1][0]" configuration]
  ["[1][0]" version]
  ["[1][0]" type]
  ["[1][0]" macro]
  ["[1][0]" static]
  ["[1][0]" extension]
  ["[1][0]" global]
  ["[1][0]" compiler
   ... ["[1]/[0]" phase]
   ]
  ])

(def !expect
  (template (_ <pattern> <value>)
    [(when <value>
       <pattern> true
       _ false)]))

(def compiler_related
  Test
  (do random.monad
    [target (random.upper_cased 1)
     version (random.upper_cased 1)
     source_code (random.upper_cased 1)
     expected_current_module (random.upper_cased 1)
     nominal_type (random.upper_cased 1)
     expected_seed random.nat
     expected random.nat
     dummy (random.only (|>> (n.= expected) not) random.nat)
     configuration_feature (random.upper_cased 1)
     configuration_value (random.upper_cased 1)
     .let [configuration (list [configuration_feature configuration_value])
           expected_lux [.#info            [.#target target
                                            .#version version
                                            .#mode {.#Build}
                                            .#configuration configuration]
                         .#source          [location.dummy 0 source_code]
                         .#location         location.dummy
                         .#current_module  {.#Some expected_current_module}
                         .#modules         (list)
                         .#scopes          (list)
                         .#type_context    [.#ex_counter 0
                                            .#var_counter 0
                                            .#var_bindings (list)]
                         .#expected        {.#Some {.#Nominal nominal_type (list)}}
                         .#seed            expected_seed
                         .#scope_type_vars (list)
                         .#extensions      []
                         .#eval            (as (-> Type Code (Meta Any)) [])
                         .#host            []]]]
    (all _.and
         (_.coverage [/.result]
           (|> (of /.monad in expected)
               (/.result expected_lux)
               (!expect (^.multi {try.#Success actual}
                                 (n.= expected actual)))))
         (_.coverage [/.result']
           (|> (of /.monad in expected)
               (/.result' expected_lux)
               (!expect (^.multi {try.#Success [actual_lux actual]}
                                 (and (same? expected_lux actual_lux)
                                      (n.= expected actual))))))
         (_.coverage [/.compiler_state]
           (|> /.compiler_state
               (/.result expected_lux)
               (!expect (^.multi {try.#Success actual_lux}
                                 (same? expected_lux actual_lux)))))
         (_.coverage [/.version]
           (|> /.version
               (/.result expected_lux)
               (!expect (^.multi {try.#Success it}
                                 (same? version it)))))
         (_.coverage [/.configuration]
           (|> /.configuration
               (/.result expected_lux)
               (!expect (^.multi {try.#Success it}
                                 (same? configuration it)))))
         )))

(def error_handling
  Test
  (do random.monad
    [target (random.upper_cased 1)
     version (random.upper_cased 1)
     source_code (random.upper_cased 1)
     expected_current_module (random.upper_cased 1)
     nominal_type (random.upper_cased 1)
     expected_seed random.nat
     expected random.nat
     dummy (random.only (|>> (n.= expected) not) random.nat)
     expected_error (random.upper_cased 1)
     .let [expected_lux [.#info            [.#target target
                                            .#version version
                                            .#mode {.#Build}
                                            .#configuration (list)]
                         .#source          [location.dummy 0 source_code]
                         .#location         location.dummy
                         .#current_module  {.#Some expected_current_module}
                         .#modules         (list)
                         .#scopes          (list)
                         .#type_context    [.#ex_counter 0
                                            .#var_counter 0
                                            .#var_bindings (list)]
                         .#expected        {.#Some {.#Nominal nominal_type (list)}}
                         .#seed            expected_seed
                         .#scope_type_vars (list)
                         .#extensions      []
                         .#eval            (as (-> Type Code (Meta Any)) [])
                         .#host            []]]]
    (all _.and
         (_.coverage [/.failure]
           (|> (/.failure expected_error)
               (is (Meta Any))
               (/.result expected_lux)
               (!expect (^.multi {try.#Failure actual_error}
                                 (text#= (location.with location.dummy expected_error)
                                         actual_error)))))
         (_.coverage [/.assertion]
           (and (|> (/.assertion expected_error true)
                    (is (Meta Any))
                    (/.result expected_lux)
                    (!expect {try.#Success []}))
                (|> (/.assertion expected_error false)
                    (/.result expected_lux)
                    (!expect (^.multi {try.#Failure actual_error}
                                      (text#= expected_error actual_error))))))
         (_.coverage [/.either]
           (and (|> (/.either (of /.monad in expected)
                              (is (Meta Nat)
                                  (/.failure expected_error)))
                    (/.result expected_lux)
                    (!expect (^.multi {try.#Success actual}
                                      (n.= expected actual))))
                (|> (/.either (is (Meta Nat)
                                  (/.failure expected_error))
                              (of /.monad in expected))
                    (/.result expected_lux)
                    (!expect (^.multi {try.#Success actual}
                                      (n.= expected actual))))
                (|> (/.either (is (Meta Nat)
                                  (/.failure expected_error))
                              (is (Meta Nat)
                                  (/.failure expected_error)))
                    (/.result expected_lux)
                    (!expect (^.multi {try.#Failure actual_error}
                                      (text#= (location.with location.dummy expected_error)
                                              actual_error))))
                (|> (/.either (of /.monad in expected)
                              (of /.monad in dummy))
                    (/.result expected_lux)
                    (!expect (^.multi {try.#Success actual}
                                      (n.= expected actual))))
                ))
         (_.coverage [/.try]
           (and (|> (/.try (/.failure expected_error))
                    (/.result expected_lux)
                    (!expect (^.multi {try.#Success {try.#Failure actual_error}}
                                      (text#= (location.with location.dummy expected_error)
                                              actual_error))))
                (|> (/.try (of /.monad in expected))
                    (/.result expected_lux)
                    (!expect (^.multi {try.#Success {try.#Success actual}}
                                      (same? expected actual))))))
         )))

(def module_related
  Test
  (do random.monad
    [target (random.upper_cased 1)
     version (random.upper_cased 1)
     source_code (random.upper_cased 1)
     expected_current_module (random.upper_cased 1)
     imported_module_name (random.only (|>> (text#= expected_current_module) not)
                                       (random.upper_cased 1))
     nominal_type (random.upper_cased 1)
     expected_seed random.nat
     expected random.nat
     dummy (random.only (|>> (n.= expected) not) random.nat)
     expected_short (random.upper_cased 1)
     dummy_module (random.only (function (_ module)
                                 (not (or (text#= expected_current_module module)
                                          (text#= imported_module_name module))))
                               (random.upper_cased 1))
     .let [imported_module [.#module_hash        0
                            .#module_aliases     (list)
                            .#definitions        (list)
                            .#imports            (list)
                            .#module_state       {.#Active}]
           expected_module [.#module_hash        0
                            .#module_aliases     (list)
                            .#definitions        (list)
                            .#imports            (list imported_module_name)
                            .#module_state       {.#Active}]
           expected_modules (list [expected_current_module
                                   expected_module]
                                  [imported_module_name
                                   imported_module])
           expected_lux [.#info            [.#target target
                                            .#version version
                                            .#mode {.#Build}
                                            .#configuration (list)]
                         .#source          [location.dummy 0 source_code]
                         .#location         location.dummy
                         .#current_module  {.#Some expected_current_module}
                         .#modules         expected_modules
                         .#scopes          (list)
                         .#type_context    [.#ex_counter 0
                                            .#var_counter 0
                                            .#var_bindings (list)]
                         .#expected        {.#Some {.#Nominal nominal_type (list)}}
                         .#seed            expected_seed
                         .#scope_type_vars (list)
                         .#extensions      []
                         .#eval            (as (-> Type Code (Meta Any)) [])
                         .#host            []]]]
    (<| (_.for [.Module])
        (all _.and
             (_.coverage [/.current_module_name]
               (|> /.current_module_name
                   (/.result expected_lux)
                   (!expect (^.multi {try.#Success actual_current_module}
                                     (text#= expected_current_module actual_current_module)))))
             (_.coverage [/.current_module]
               (|> /.current_module
                   (/.result expected_lux)
                   (!expect (^.multi {try.#Success actual_module}
                                     (same? expected_module actual_module)))))
             (_.coverage [/.module]
               (|> (/.module expected_current_module)
                   (/.result expected_lux)
                   (!expect (^.multi {try.#Success actual_module}
                                     (same? expected_module actual_module)))))
             (_.coverage [/.module_exists?]
               (and (|> (/.module_exists? expected_current_module)
                        (/.result expected_lux)
                        (!expect {try.#Success .true}))
                    (|> (/.module_exists? dummy_module)
                        (/.result expected_lux)
                        (!expect {try.#Success .false}))))
             (_.coverage [/.modules]
               (|> /.modules
                   (/.result expected_lux)
                   (!expect (^.multi {try.#Success actual_modules}
                                     (same? expected_modules actual_modules)))))
             (_.coverage [/.imported_modules]
               (and (|> (/.imported_modules expected_current_module)
                        (/.result expected_lux)
                        (try#each (of (list.equivalence text.equivalence) =
                                      (list imported_module_name)))
                        (try.else false))
                    (|> (/.imported_modules imported_module_name)
                        (/.result expected_lux)
                        (try#each (of (list.equivalence text.equivalence) =
                                      (list)))
                        (try.else false))))
             (_.coverage [/.imported_by?]
               (|> (/.imported_by? imported_module_name expected_current_module)
                   (/.result expected_lux)
                   (try.else false)))
             (_.coverage [/.imported?]
               (|> (/.imported? imported_module_name)
                   (/.result expected_lux)
                   (try.else false)))
             (_.coverage [/.normal]
               (and (|> (/.normal ["" expected_short])
                        (/.result expected_lux)
                        (!expect (^.multi {try.#Success [actual_module actual_short]}
                                          (and (text#= expected_current_module actual_module)
                                               (same? expected_short actual_short)))))
                    (|> (/.normal [dummy_module expected_short])
                        (/.result expected_lux)
                        (!expect (^.multi {try.#Success [actual_module actual_short]}
                                          (and (text#= dummy_module actual_module)
                                               (same? expected_short actual_short)))))))
             ))))

(def random_location
  (Random Location)
  (all random.and
       (random.upper_cased 1)
       random.nat
       random.nat))

(def context_related
  (do [! random.monad]
    [target (random.upper_cased 1)
     version (random.upper_cased 1)
     source_code (random.upper_cased 1)
     expected_current_module (random.upper_cased 1)
     expected_type (of ! each (function (_ name)
                                {.#Nominal name (list)})
                       (random.upper_cased 1))
     expected_seed random.nat
     expected random.nat
     dummy (random.only (|>> (n.= expected) not) random.nat)
     expected_location ..random_location
     .let [type_context [.#ex_counter 0
                         .#var_counter 0
                         .#var_bindings (list)]
           expected_lux [.#info            [.#target target
                                            .#version version
                                            .#mode {.#Build}
                                            .#configuration (list)]
                         .#source          [location.dummy 0 source_code]
                         .#location         expected_location
                         .#current_module  {.#Some expected_current_module}
                         .#modules         (list)
                         .#scopes          (list)
                         .#type_context    type_context
                         .#expected        {.#Some expected_type}
                         .#seed            expected_seed
                         .#scope_type_vars (list)
                         .#extensions      []
                         .#eval            (as (-> Type Code (Meta Any)) [])
                         .#host            []]]]
    (all _.and
         (_.coverage [/.target]
           (|> /.target
               (/.result expected_lux)
               (try#each (same? target))
               (try.else false)))
         (_.coverage [/.seed]
           (|> (do /.monad
                 [pre /.seed
                  post /.seed]
                 (in [pre post]))
               (/.result expected_lux)
               (!expect (^.multi {try.#Success [actual_pre actual_post]}
                                 (and (n.= expected_seed actual_pre)
                                      (n.= (++ expected_seed) actual_post))))))
         (_.coverage [/.location]
           (|> /.location
               (/.result expected_lux)
               (!expect (^.multi {try.#Success actual_location}
                                 (same? expected_location actual_location)))))
         (_.coverage [/.expected_type]
           (|> /.expected_type
               (/.result expected_lux)
               (!expect (^.multi {try.#Success actual_type}
                                 (same? expected_type actual_type)))))
         (_.coverage [.Type_Context /.type_context]
           (|> /.type_context
               (/.result expected_lux)
               (try#each (same? type_context))
               (try.else false)))
         )))

(def definition_related
  Test
  (do [! random.monad]
    [expected_current_module (random.upper_cased 1)
     expected_macro_module (random.only (|>> (text#= expected_current_module) not)
                                        (random.upper_cased 1))
     expected_short (random.upper_cased 1)
     expected_type (of ! each (function (_ name)
                                {.#Nominal name (list)})
                       (random.upper_cased 1))
     expected_value (random.either (in .def)
                                   (in .macro))
     .let [expected_lux
           (is (-> Bit (Maybe Type)
                   [(List [Text [Bit .Global]])
                    (List [Text [Bit .Global]])
                    Lux])
               (function (_ exported? def_type)
                 (let [current_globals (is (List [Text [Bit .Global]])
                                           (list [expected_short
                                                  [false {.#Alias [expected_macro_module expected_short]}]]))
                       macro_globals (is (List [Text [Bit .Global]])
                                         (when def_type
                                           {.#Some def_type}
                                           (list [expected_short
                                                  [exported? {.#Definition [def_type expected_value]}]])

                                           {.#None}
                                           (list)))]
                   [current_globals
                    macro_globals
                    [.#info            [.#target ""
                                        .#version ""
                                        .#mode {.#Build}
                                        .#configuration (list)]
                     .#source          [location.dummy 0 ""]
                     .#location         location.dummy
                     .#current_module  {.#Some expected_current_module}
                     .#modules         (list [expected_current_module
                                              [.#module_hash        0
                                               .#module_aliases     (list)
                                               .#definitions        current_globals
                                               .#imports            (list)
                                               .#module_state       {.#Active}]]
                                             [expected_macro_module
                                              [.#module_hash        0
                                               .#module_aliases     (list)
                                               .#definitions        macro_globals
                                               .#imports            (list)
                                               .#module_state       {.#Active}]])
                     .#scopes          (list)
                     .#type_context    [.#ex_counter 0
                                        .#var_counter 0
                                        .#var_bindings (list)]
                     .#expected        {.#None}
                     .#seed            0
                     .#scope_type_vars (list)
                     .#extensions      []
                     .#eval            (as (-> Type Code (Meta Any)) [])
                     .#host            []]])))]]
    (all _.and
         (_.coverage [.Global .Alias /.globals]
           (let [[current_globals macro_globals expected_lux]
                 (expected_lux true {.#Some .Macro})

                 current_globals!
                 (|> (/.globals expected_current_module)
                     (/.result expected_lux)
                     (!expect (^.multi {try.#Success actual_globals}
                                       (same? current_globals actual_globals))))

                 macro_globals!
                 (|> (/.globals expected_macro_module)
                     (/.result expected_lux)
                     (!expect (^.multi {try.#Success actual_globals}
                                       (same? macro_globals actual_globals))))]
             (and current_globals!
                  macro_globals!)))
         (_.coverage [.Definition /.definitions]
           (let [[current_globals macro_globals expected_lux]
                 (expected_lux true {.#Some .Macro})]
             (and (|> (/.definitions expected_current_module)
                      (/.result expected_lux)
                      (!expect (^.multi {try.#Success actual_definitions}
                                        (n.= 0 (list.size actual_definitions)))))
                  (|> (/.definitions expected_macro_module)
                      (/.result expected_lux)
                      (!expect (^.multi {try.#Success actual_definitions}
                                        (n.= 1 (list.size actual_definitions)))))
                  )))
         (_.coverage [/.exports]
           (and (let [[current_globals macro_globals expected_lux]
                      (expected_lux true {.#Some .Macro})]
                  (and (|> (/.exports expected_current_module)
                           (/.result expected_lux)
                           (!expect (^.multi {try.#Success actual_definitions}
                                             (n.= 0 (list.size actual_definitions)))))
                       (|> (/.exports expected_macro_module)
                           (/.result expected_lux)
                           (!expect (^.multi {try.#Success actual_definitions}
                                             (n.= 1 (list.size actual_definitions)))))
                       ))
                (let [[current_globals macro_globals expected_lux]
                      (expected_lux false {.#Some .Macro})]
                  (and (|> (/.exports expected_current_module)
                           (/.result expected_lux)
                           (!expect (^.multi {try.#Success actual_definitions}
                                             (n.= 0 (list.size actual_definitions)))))
                       (|> (/.exports expected_macro_module)
                           (/.result expected_lux)
                           (!expect (^.multi {try.#Success actual_definitions}
                                             (n.= 0 (list.size actual_definitions)))))
                       ))))
         )))

(def search_related
  Test
  (do [! random.monad]
    [expected_exported? random.bit
     expected_current_module (random.upper_cased 1)
     expected_macro_module (random.only (|>> (text#= expected_current_module) not)
                                        (random.upper_cased 1))
     expected_short (random.upper_cased 1)
     expected_type (of ! each (function (_ name)
                                {.#Nominal name (list)})
                       (random.upper_cased 1))
     expected_value (random.either (in .def)
                                   (in .macro))
     .let [expected_lux
           (is (-> Bit (Maybe Type)
                   [(List [Text [Bit .Global]])
                    (List [Text [Bit .Global]])
                    Lux])
               (function (_ exported? def_type)
                 (let [current_globals (is (List [Text [Bit .Global]])
                                           (list [expected_short
                                                  [false {.#Alias [expected_macro_module expected_short]}]]))
                       macro_globals (is (List [Text [Bit .Global]])
                                         (when def_type
                                           {.#Some def_type}
                                           (list [expected_short
                                                  [exported? {.#Definition [def_type expected_value]}]])

                                           {.#None}
                                           (list)))]
                   [current_globals
                    macro_globals
                    [.#info            [.#target ""
                                        .#version ""
                                        .#mode {.#Build}
                                        .#configuration (list)]
                     .#source          [location.dummy 0 ""]
                     .#location         location.dummy
                     .#current_module  {.#Some expected_current_module}
                     .#modules         (list [expected_current_module
                                              [.#module_hash        0
                                               .#module_aliases     (list)
                                               .#definitions        current_globals
                                               .#imports            (list)
                                               .#module_state       {.#Active}]]
                                             [expected_macro_module
                                              [.#module_hash        0
                                               .#module_aliases     (list)
                                               .#definitions        macro_globals
                                               .#imports            (list)
                                               .#module_state       {.#Active}]])
                     .#scopes          (list)
                     .#type_context    [.#ex_counter 0
                                        .#var_counter 0
                                        .#var_bindings (list)]
                     .#expected        {.#None}
                     .#seed            0
                     .#scope_type_vars (list)
                     .#extensions      []
                     .#eval            (as (-> Type Code (Meta Any)) [])
                     .#host            []]])))]]
    (all _.and
         (_.coverage [/.export]
           (and (let [[current_globals macro_globals expected_lux]
                      (expected_lux true {.#Some expected_type})]
                  (|> (/.export [expected_macro_module expected_short])
                      (/.result expected_lux)
                      (!expect {try.#Success _})))
                (let [[current_globals macro_globals expected_lux]
                      (expected_lux false {.#Some expected_type})]
                  (|> (/.export [expected_macro_module expected_short])
                      (/.result expected_lux)
                      (!expect {try.#Failure _})))))
         (_.coverage [/.macro]
           (let [same_module!
                 (let [[current_globals macro_globals expected_lux]
                       (expected_lux true {.#Some .Macro})]
                   (|> (/.macro [expected_macro_module expected_short])
                       (/.result expected_lux)
                       (!expect (^.multi {try.#Success {.#Some actual_value}}
                                         (same? expected_value actual_value)))))

                 not_macro!
                 (let [[current_globals macro_globals expected_lux]
                       (expected_lux true {.#Some expected_type})]
                   (|> (/.macro [expected_macro_module expected_short])
                       (/.result expected_lux)
                       (!expect {try.#Success {.#None}})))

                 not_found!
                 (let [[current_globals macro_globals expected_lux]
                       (expected_lux true {.#None})]
                   (|> (/.macro [expected_macro_module expected_short])
                       (/.result expected_lux)
                       (!expect {try.#Success {.#None}})))

                 aliasing!
                 (let [[current_globals macro_globals expected_lux]
                       (expected_lux true {.#Some .Macro})]
                   (|> (/.macro [expected_current_module expected_short])
                       (/.result expected_lux)
                       (!expect (^.multi {try.#Success {.#Some actual_value}}
                                         (same? expected_value actual_value)))))]
             (and same_module!
                  not_macro!
                  not_found!
                  aliasing!)))
         (_.coverage [/.de_aliased]
           (let [[current_globals macro_globals expected_lux]
                 (expected_lux true {.#Some .Macro})]
             (and (|> (/.de_aliased [expected_macro_module expected_short])
                      (/.result expected_lux)
                      (try#each (symbol#= [expected_macro_module expected_short]))
                      (try.else false))
                  (|> (/.de_aliased [expected_current_module expected_short])
                      (/.result expected_lux)
                      (try#each (symbol#= [expected_macro_module expected_short]))
                      (try.else false)))))
         (_.coverage [/.definition]
           (let [[current_globals macro_globals expected_lux]
                 (expected_lux expected_exported? {.#Some expected_type})

                 definition!
                 (|> (/.definition [expected_macro_module expected_short])
                     (/.result expected_lux)
                     (!expect (^.multi {try.#Success [actual_exported? {.#Definition [actual_type actual_value]}]}
                                       (and (bit#= expected_exported? actual_exported?)
                                            (same? expected_type actual_type)
                                            (same? (as Any expected_value) actual_value)))))

                 alias!
                 (|> (/.definition [expected_current_module expected_short])
                     (/.result expected_lux)
                     (!expect (^.multi {try.#Success [.false {.#Alias [actual_module actual_short]}]}
                                       (and (same? expected_macro_module actual_module)
                                            (same? expected_short actual_short)))))]
             (and definition!
                  alias!)))
         (_.coverage [/.definition_type]
           (let [[current_globals macro_globals expected_lux]
                 (expected_lux expected_exported? {.#Some expected_type})

                 definition!
                 (|> (/.definition_type [expected_macro_module expected_short])
                     (/.result expected_lux)
                     (!expect (^.multi {try.#Success actual_type}
                                       (same? expected_type actual_type))))

                 alias!
                 (|> (/.definition_type [expected_current_module expected_short])
                     (/.result expected_lux)
                     (!expect (^.multi {try.#Success actual_type}
                                       (same? expected_type actual_type))))]
             (and definition!
                  alias!)))
         (_.coverage [/.type_definition]
           (let [[current_globals macro_globals expected_lux]
                 (expected_lux expected_exported? {.#Some .Type})

                 definition!
                 (|> (/.type_definition [expected_macro_module expected_short])
                     (/.result expected_lux)
                     (!expect (^.multi {try.#Success actual_value}
                                       (same? (as .Type expected_value) actual_value))))

                 alias!
                 (|> (/.type_definition [expected_current_module expected_short])
                     (/.result expected_lux)
                     (!expect (^.multi {try.#Success actual_value}
                                       (same? (as .Type expected_value) actual_value))))]
             (and definition!
                  alias!)))
         )))

(def locals_related
  Test
  (do [! random.monad]
    [current_module (random.upper_cased 1)
     [name_0 name_1 name_2 name_3 name_4] (|> (random.upper_cased 1)
                                              (random.set text.hash 5)
                                              (of ! each set.list)
                                              (random.one (function (_ values)
                                                            (when values
                                                              (list name_0 name_1 name_2 name_3 name_4)
                                                              {.#Some [name_0 name_1 name_2 name_3 name_4]}

                                                              _
                                                              {.#None}))))
     .let [type_0 {.#Nominal name_0 (list)}
           type_1 {.#Nominal name_1 (list)}
           type_2 {.#Nominal name_2 (list)}
           type_3 {.#Nominal name_3 (list)}
           type_4 {.#Nominal name_4 (list)}

           globals (is (List [Text [Bit .Global]])
                       (list [name_4
                              [false {.#Definition [type_4 []]}]]))

           scopes (list [.#scope_name (list)
                         .#inner_scopes 0
                         .#locals [.#counter 1
                                   .#mappings (list [name_3 [type_3 3]])]
                         .#captured [.#counter 0
                                     .#mappings (list)]]
                        [.#scope_name (list)
                         .#inner_scopes 0
                         .#locals [.#counter 2
                                   .#mappings (list [name_1 [type_1 1]]
                                                    [name_2 [type_2 2]])]
                         .#captured [.#counter 0
                                     .#mappings (list)]]
                        [.#scope_name (list)
                         .#inner_scopes 0
                         .#locals [.#counter 1
                                   .#mappings (list [name_0 [type_0 0]])]
                         .#captured [.#counter 0
                                     .#mappings (list)]])]
     .let [expected_lux
           (is Lux
               [.#info            [.#target ""
                                   .#version ""
                                   .#mode {.#Build}
                                   .#configuration (list)]
                .#source          [location.dummy 0 ""]
                .#location        location.dummy
                .#current_module  {.#Some current_module}
                .#modules         (list [current_module
                                         [.#module_hash        0
                                          .#module_aliases     (list)
                                          .#definitions        globals
                                          .#imports            (list)
                                          .#module_state       {.#Active}]])
                .#scopes          scopes
                .#type_context    [.#ex_counter 0
                                   .#var_counter 0
                                   .#var_bindings (list)]
                .#expected        {.#None}
                .#seed            0
                .#scope_type_vars (list)
                .#extensions      []
                .#eval            (as (-> Type Code (Meta Any)) [])
                .#host            []])]]
    (all _.and
         (_.coverage [.Scope /.locals]
           (let [equivalence (is (Equivalence (List (List [Text Type])))
                                 (list.equivalence
                                  (list.equivalence
                                   (product.equivalence
                                    text.equivalence
                                    type.equivalence))))]
             (|> /.locals
                 (/.result expected_lux)
                 (try#each (of equivalence = (list (list [name_3 type_3])
                                                   (list [name_1 type_1]
                                                         [name_2 type_2]))))
                 (try.else false))))
         (_.coverage [/.var_type]
           (and (|> (/.var_type name_0)
                    (/.result expected_lux)
                    (try#each (of type.equivalence = type_0))
                    (try.else false))
                (|> (/.var_type name_1)
                    (/.result expected_lux)
                    (try#each (of type.equivalence = type_1))
                    (try.else false))
                (|> (/.var_type name_2)
                    (/.result expected_lux)
                    (try#each (of type.equivalence = type_2))
                    (try.else false))
                (|> (/.var_type name_3)
                    (/.result expected_lux)
                    (try#each (of type.equivalence = type_3))
                    (try.else false))))
         (_.coverage [/.type]
           (and (|> (/.type ["" name_0])
                    (/.result expected_lux)
                    (try#each (of type.equivalence = type_0))
                    (try.else false))
                (|> (/.type ["" name_1])
                    (/.result expected_lux)
                    (try#each (of type.equivalence = type_1))
                    (try.else false))
                (|> (/.type ["" name_2])
                    (/.result expected_lux)
                    (try#each (of type.equivalence = type_2))
                    (try.else false))
                (|> (/.type ["" name_3])
                    (/.result expected_lux)
                    (try#each (of type.equivalence = type_3))
                    (try.else false))
                (|> (/.type [current_module name_4])
                    (/.result expected_lux)
                    (try#each (of type.equivalence = type_4))
                    (try.else false))
                (|> (/.type ["" name_4])
                    (/.result expected_lux)
                    (try#each (of type.equivalence = type_4))
                    (try.else false))))
         )))

(def label_related
  Test
  (do [! random.monad]
    [current_module (random.upper_cased 1)
     label_module (random.upper_cased 2)

     name_0 (random.upper_cased 3)
     name_1 (random.upper_cased 4)

     .let [random_tag (of ! each (|>> [label_module])
                          (random.upper_cased 1))
           random_labels (is (-> Nat
                                 (Random [Text (List Text)]))
                             (function (_ size)
                               (do !
                                 [head (random.lower_cased size)]
                                 (|> (random.lower_cased size)
                                     (random.only (|>> (text#= head) not))
                                     (random.set text.hash 3)
                                     (of ! each set.list)
                                     (random.and (in head))))))]
     tags_0 (random_labels 5)
     tags_1 (random_labels 6)
     .let [type_0 {.#Nominal name_0 (list)}
           type_1 {.#Nominal name_1 (list)}

           expected_lux
           (is Lux
               [.#info            [.#target ""
                                   .#version ""
                                   .#mode {.#Build}
                                   .#configuration (list)]
                .#source          [location.dummy 0 ""]
                .#location        location.dummy
                .#current_module  {.#Some current_module}
                .#modules         (list [current_module
                                         [.#module_hash        0
                                          .#module_aliases     (list)
                                          .#definitions        (list)
                                          .#imports            (list label_module)
                                          .#module_state       {.#Active}]]
                                        [label_module
                                         [.#module_hash        0
                                          .#module_aliases     (list)
                                          .#definitions        (list.partial [name_0 [true {.#Definition [.Type type_0]}]]
                                                                             [name_1 [true {.#Definition [.Type type_1]}]]
                                                                             (all list#composite
                                                                                  (let [cohort (is (List Symbol)
                                                                                                   (list#each (|>> [label_module])
                                                                                                              {.#Item tags_0}))
                                                                                        last (-- (list.size cohort))
                                                                                        right? (n.= last)]
                                                                                    (|> {.#Item tags_0}
                                                                                        list.enumeration
                                                                                        (list#each (function (_ [index short])
                                                                                                     [short [true {.#Definition [.Tag
                                                                                                                                 (|> [{.#Some [index (right? index) cohort]} type_0]
                                                                                                                                     (is Label)
                                                                                                                                     (as .Tag))]}]]))))
                                                                                  (let [cohort (is (List Symbol)
                                                                                                   (list#each (|>> [label_module])
                                                                                                              {.#Item tags_1}))
                                                                                        last (-- (list.size cohort))
                                                                                        right? (n.= last)]
                                                                                    (|> {.#Item tags_1}
                                                                                        list.enumeration
                                                                                        (list#each (function (_ [index short])
                                                                                                     [short [true {.#Definition [.Slot
                                                                                                                                 (|> [{.#Some [index (right? index) cohort]} type_1]
                                                                                                                                     (is Label)
                                                                                                                                     (as .Slot))]}]]))))))
                                          .#imports            (list)
                                          .#module_state       {.#Active}]])
                .#scopes          (list)
                .#type_context    [.#ex_counter 0
                                   .#var_counter 0
                                   .#var_bindings (list)]
                .#expected        {.#None}
                .#seed            0
                .#scope_type_vars (list)
                .#extensions      []
                .#eval            (as (-> Type Code (Meta Any)) [])
                .#host            []])]]
    (all _.and
         (_.coverage [/.tag_lists]
           (let [equivalence (list.equivalence
                              (product.equivalence
                               (list.equivalence symbol.equivalence)
                               type.equivalence))]
             (|> (/.tag_lists label_module)
                 (/.result expected_lux)
                 (try#each (of equivalence = (list [(list#each (|>> [label_module]) {.#Item tags_1})
                                                    type_1])))
                 (try.else false))))
         (_.coverage [/.tags_of]
           (|> (/.tags_of [label_module name_1])
               (/.result expected_lux)
               (try#each (of (maybe.equivalence (list.equivalence symbol.equivalence)) =
                             {.#Some (list#each (|>> [label_module]) {.#Item tags_1})}))
               (try.else false)))
         ... (_.coverage [/.tag]
         ...   (|> {.#Item tags_0}
         ...       list.enumeration
         ...       (list.every? (function (_ [expected_index label])
         ...                      (|> [label_module label]
         ...                          /.tag
         ...                          (/.result expected_lux)
         ...                          (!expect (^.multi {try.#Success [actual_index actual_tags actual_type]}
         ...                                            (let [correct_index!
         ...                                                  (n.= expected_index
         ...                                                       actual_index)

         ...                                                  correct_tags!
         ...                                                  (of (list.equivalence symbol.equivalence) =
         ...                                                      (list#each (|>> [label_module]) {.#Item tags_0})
         ...                                                      actual_tags)

         ...                                                  correct_type!
         ...                                                  (type#= type_0
         ...                                                          actual_type)]
         ...                                              (and correct_index!
         ...                                                   correct_tags!
         ...                                                   correct_type!))))
         ...                          )))))
         ... (_.coverage [/.slot]
         ...   (|> {.#Item tags_1}
         ...       list.enumeration
         ...       (list.every? (function (_ [expected_index label])
         ...                      (|> [label_module label]
         ...                          /.slot
         ...                          (/.result expected_lux)
         ...                          (!expect (^.multi {try.#Success [actual_index actual_tags actual_type]}
         ...                                            (let [correct_index!
         ...                                                  (n.= expected_index
         ...                                                       actual_index)

         ...                                                  correct_tags!
         ...                                                  (of (list.equivalence symbol.equivalence) =
         ...                                                      (list#each (|>> [label_module]) {.#Item tags_1})
         ...                                                      actual_tags)

         ...                                                  correct_type!
         ...                                                  (type#= type_1
         ...                                                          actual_type)]
         ...                                              (and correct_index!
         ...                                                   correct_tags!
         ...                                                   correct_type!))))
         ...                          )))))
         )))

(def injection
  (Injection Meta)
  (of /.monad in))

(def (comparison init)
  (-> Lux (Comparison Meta))
  (function (_ == left right)
    (when [(/.result init left)
           (/.result init right)]
      [{try.#Success left} {try.#Success right}]
      (== left right)

      _
      false)))

(`` (`` (def .public test
          Test
          (<| (_.covering /._)
              (_.for [.Meta .Lux
                      .#info .#source .#location .#current_module
                      .#modules .#scopes .#type_context .#expected
                      .#seed .#scope_type_vars .#extensions .#eval
                      .#host])
              (all _.and
                   (do [! random.monad]
                     [target (random.upper_cased 1)
                      version (random.upper_cased 1)
                      source_code (random.upper_cased 1)
                      expected_current_module (random.upper_cased 1)
                      expected_type (of ! each (function (_ name)
                                                 {.#Nominal name (list)})
                                        (random.upper_cased 1))
                      expected_seed random.nat
                      expected random.nat
                      dummy (random.only (|>> (n.= expected) not) random.nat)
                      expected_location ..random_location
                      .let [expected_lux [.#info            [.#target target
                                                             .#version version
                                                             .#mode {.#Build}
                                                             .#configuration (list)]
                                          .#source          [expected_location 0 source_code]
                                          .#location         expected_location
                                          .#current_module  {.#Some expected_current_module}
                                          .#modules         (list)
                                          .#scopes          (list)
                                          .#type_context    [.#ex_counter 0
                                                             .#var_counter 0
                                                             .#var_bindings (list)]
                                          .#expected        {.#Some expected_type}
                                          .#seed            expected_seed
                                          .#scope_type_vars (list)
                                          .#extensions      []
                                          .#eval            (as (-> Type Code (Meta Any)) [])
                                          .#host            []]]]
                     (all _.and
                          (_.for [/.functor]
                                 (functorT.spec ..injection (..comparison expected_lux) /.functor))
                          (_.for [/.apply]
                                 (applyT.spec ..injection (..comparison expected_lux) /.apply))
                          (_.for [/.monad]
                                 (monadT.spec ..injection (..comparison expected_lux) /.monad))

                          (do random.monad
                            [expected_value random.nat
                             expected_error (random.upper_cased 1)]
                            (_.coverage [/.of_try]
                              (and (|> expected_error
                                       {try.#Failure}
                                       (is (Try Nat))
                                       /.of_try
                                       (/.result expected_lux)
                                       (!expect (^.multi {try.#Failure actual}
                                                         (text#= (location.with expected_location expected_error)
                                                                 actual))))
                                   (|> expected_value
                                       {try.#Success}
                                       (is (Try Nat))
                                       /.of_try
                                       (/.result expected_lux)
                                       (!expect (^.multi {try.#Success actual}
                                                         (same? expected_value actual)))))))
                          
                          ..compiler_related
                          ..error_handling
                          ..module_related
                          ..context_related
                          ..definition_related
                          ..search_related
                          ..locals_related
                          (_.for [.Label]
                                 ..label_related)
                          ))
                   
                   /code.test
                   /location.test
                   /symbol.test
                   /configuration.test
                   /version.test
                   /type.test
                   /macro.test
                   /static.test
                   (,, (for @.old (,, (these))
                            (,, (these /extension.test))))
                   /global.test

                   /compiler.test
                   )))))
