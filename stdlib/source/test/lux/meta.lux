(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    ["[0]" type ("[1]\[0]" equivalence)]
    [abstract
     [equivalence {"+" [Equivalence]}]
     [monad {"+" [do]}]
     [\\specification
      ["$[0]" functor {"+" [Injection Comparison]}]
      ["$[0]" apply]
      ["$[0]" monad]]]
    [control
     ["[0]" maybe]
     ["[0]" try {"+" [Try]} ("[1]\[0]" functor)]]
    [data
     ["[0]" product]
     ["[0]" bit ("[1]\[0]" equivalence)]
     ["[0]" name ("[1]\[0]" equivalence)]
     ["[0]" text ("[1]\[0]" equivalence)
      ["%" format {"+" [format]}]]
     [collection
      ["[0]" list ("[1]\[0]" functor monoid)]
      ["[0]" set]]]
    [meta
     ["[0]" location]]
    [math
     ["[0]" random {"+" [Random]}]
     [number
      ["n" nat]]]]]
  [\\library
   ["[0]" /]]
  ["[0]" / "_"
   ["[1][0]" annotation]
   ["[1][0]" location]])

(template: (!expect <pattern> <value>)
  [(case <value>
     <pattern> true
     _ false)])

(def: compiler_related
  Test
  (do random.monad
    [target (random.ascii/upper 1)
     version (random.ascii/upper 1)
     source_code (random.ascii/upper 1)
     expected_current_module (random.ascii/upper 1)
     primitive_type (random.ascii/upper 1)
     expected_seed random.nat
     expected random.nat
     dummy (random.only (|>> (n.= expected) not) random.nat)
     .let [expected_lux [#.info            [#.target  target
                                            #.version version
                                            #.mode    #.Build]
                         #.source          [location.dummy 0 source_code]
                         #.location         location.dummy
                         #.current_module  (#.Some expected_current_module)
                         #.modules         (list)
                         #.scopes          (list)
                         #.type_context    [#.ex_counter 0
                                            #.var_counter 0
                                            #.var_bindings (list)]
                         #.expected        (#.Some (#.Primitive primitive_type (list)))
                         #.seed            expected_seed
                         #.scope_type_vars (list)
                         #.extensions      []
                         #.eval            (:as (-> Type Code (Meta Any)) [])
                         #.host            []]]]
    ($_ _.and
        (_.cover [/.result]
                 (|> (\ /.monad in expected)
                     (/.result expected_lux)
                     (!expect (^multi (#try.Success actual)
                                      (n.= expected actual)))))
        (_.cover [/.result']
                 (|> (\ /.monad in expected)
                     (/.result' expected_lux)
                     (!expect (^multi (#try.Success [actual_lux actual])
                                      (and (same? expected_lux actual_lux)
                                           (n.= expected actual))))))
        (_.cover [/.compiler_state]
                 (|> /.compiler_state
                     (/.result expected_lux)
                     (!expect (^multi (#try.Success actual_lux)
                                      (same? expected_lux actual_lux)))))
        )))

(def: error_handling
  Test
  (do random.monad
    [target (random.ascii/upper 1)
     version (random.ascii/upper 1)
     source_code (random.ascii/upper 1)
     expected_current_module (random.ascii/upper 1)
     primitive_type (random.ascii/upper 1)
     expected_seed random.nat
     expected random.nat
     dummy (random.only (|>> (n.= expected) not) random.nat)
     expected_error (random.ascii/upper 1)
     .let [expected_lux [#.info            [#.target  target
                                            #.version version
                                            #.mode    #.Build]
                         #.source          [location.dummy 0 source_code]
                         #.location         location.dummy
                         #.current_module  (#.Some expected_current_module)
                         #.modules         (list)
                         #.scopes          (list)
                         #.type_context    [#.ex_counter 0
                                            #.var_counter 0
                                            #.var_bindings (list)]
                         #.expected        (#.Some (#.Primitive primitive_type (list)))
                         #.seed            expected_seed
                         #.scope_type_vars (list)
                         #.extensions      []
                         #.eval            (:as (-> Type Code (Meta Any)) [])
                         #.host            []]]]
    ($_ _.and
        (_.cover [/.failure]
                 (|> (/.failure expected_error)
                     (: (Meta Any))
                     (/.result expected_lux)
                     (!expect (^multi (#try.Failure actual_error)
                                      (text\= (location.with location.dummy expected_error)
                                              actual_error)))))
        (_.cover [/.assertion]
                 (and (|> (/.assertion expected_error true)
                          (: (Meta Any))
                          (/.result expected_lux)
                          (!expect (#try.Success [])))
                      (|> (/.assertion expected_error false)
                          (/.result expected_lux)
                          (!expect (^multi (#try.Failure actual_error)
                                           (text\= expected_error actual_error))))))
        (_.cover [/.either]
                 (and (|> (/.either (\ /.monad in expected)
                                    (: (Meta Nat)
                                       (/.failure expected_error)))
                          (/.result expected_lux)
                          (!expect (^multi (#try.Success actual)
                                           (n.= expected actual))))
                      (|> (/.either (: (Meta Nat)
                                       (/.failure expected_error))
                                    (\ /.monad in expected))
                          (/.result expected_lux)
                          (!expect (^multi (#try.Success actual)
                                           (n.= expected actual))))
                      (|> (/.either (: (Meta Nat)
                                       (/.failure expected_error))
                                    (: (Meta Nat)
                                       (/.failure expected_error)))
                          (/.result expected_lux)
                          (!expect (^multi (#try.Failure actual_error)
                                           (text\= (location.with location.dummy expected_error)
                                                   actual_error))))
                      (|> (/.either (\ /.monad in expected)
                                    (\ /.monad in dummy))
                          (/.result expected_lux)
                          (!expect (^multi (#try.Success actual)
                                           (n.= expected actual))))
                      ))
        )))

(def: module_related
  Test
  (do random.monad
    [target (random.ascii/upper 1)
     version (random.ascii/upper 1)
     source_code (random.ascii/upper 1)
     expected_current_module (random.ascii/upper 1)
     imported_module_name (random.only (|>> (text\= expected_current_module) not)
                                       (random.ascii/upper 1))
     primitive_type (random.ascii/upper 1)
     expected_seed random.nat
     expected random.nat
     dummy (random.only (|>> (n.= expected) not) random.nat)
     expected_short (random.ascii/upper 1)
     dummy_module (random.only (function (_ module)
                                 (not (or (text\= expected_current_module module)
                                          (text\= imported_module_name module))))
                               (random.ascii/upper 1))
     .let [imported_module [#.module_hash        0
                            #.module_aliases     (list)
                            #.definitions        (list)
                            #.imports            (list)
                            #.module_state       #.Active]
           expected_module [#.module_hash        0
                            #.module_aliases     (list)
                            #.definitions        (list)
                            #.imports            (list imported_module_name)
                            #.module_state       #.Active]
           expected_modules (list [expected_current_module
                                   expected_module]
                                  [imported_module_name
                                   imported_module])
           expected_lux [#.info            [#.target  target
                                            #.version version
                                            #.mode    #.Build]
                         #.source          [location.dummy 0 source_code]
                         #.location         location.dummy
                         #.current_module  (#.Some expected_current_module)
                         #.modules         expected_modules
                         #.scopes          (list)
                         #.type_context    [#.ex_counter 0
                                            #.var_counter 0
                                            #.var_bindings (list)]
                         #.expected        (#.Some (#.Primitive primitive_type (list)))
                         #.seed            expected_seed
                         #.scope_type_vars (list)
                         #.extensions      []
                         #.eval            (:as (-> Type Code (Meta Any)) [])
                         #.host            []]]]
    (<| (_.for [.Module])
        ($_ _.and
            (_.cover [/.current_module_name]
                     (|> /.current_module_name
                         (/.result expected_lux)
                         (!expect (^multi (#try.Success actual_current_module)
                                          (text\= expected_current_module actual_current_module)))))
            (_.cover [/.current_module]
                     (|> /.current_module
                         (/.result expected_lux)
                         (!expect (^multi (#try.Success actual_module)
                                          (same? expected_module actual_module)))))
            (_.cover [/.module]
                     (|> (/.module expected_current_module)
                         (/.result expected_lux)
                         (!expect (^multi (#try.Success actual_module)
                                          (same? expected_module actual_module)))))
            (_.cover [/.module_exists?]
                     (and (|> (/.module_exists? expected_current_module)
                              (/.result expected_lux)
                              (!expect (#try.Success #1)))
                          (|> (/.module_exists? dummy_module)
                              (/.result expected_lux)
                              (!expect (#try.Success #0)))))
            (_.cover [/.modules]
                     (|> /.modules
                         (/.result expected_lux)
                         (!expect (^multi (#try.Success actual_modules)
                                          (same? expected_modules actual_modules)))))
            (_.cover [/.imported_modules]
                     (and (|> (/.imported_modules expected_current_module)
                              (/.result expected_lux)
                              (try\each (\ (list.equivalence text.equivalence) =
                                           (list imported_module_name)))
                              (try.else false))
                          (|> (/.imported_modules imported_module_name)
                              (/.result expected_lux)
                              (try\each (\ (list.equivalence text.equivalence) =
                                           (list)))
                              (try.else false))))
            (_.cover [/.imported_by?]
                     (|> (/.imported_by? imported_module_name expected_current_module)
                         (/.result expected_lux)
                         (try.else false)))
            (_.cover [/.imported?]
                     (|> (/.imported? imported_module_name)
                         (/.result expected_lux)
                         (try.else false)))
            (_.cover [/.normal]
                     (and (|> (/.normal ["" expected_short])
                              (/.result expected_lux)
                              (!expect (^multi (#try.Success [actual_module actual_short])
                                               (and (text\= expected_current_module actual_module)
                                                    (same? expected_short actual_short)))))
                          (|> (/.normal [dummy_module expected_short])
                              (/.result expected_lux)
                              (!expect (^multi (#try.Success [actual_module actual_short])
                                               (and (text\= dummy_module actual_module)
                                                    (same? expected_short actual_short)))))))
            ))))

(def: random_location
  (Random Location)
  ($_ random.and
      (random.ascii/upper 1)
      random.nat
      random.nat))

(def: context_related
  (do [! random.monad]
    [target (random.ascii/upper 1)
     version (random.ascii/upper 1)
     source_code (random.ascii/upper 1)
     expected_current_module (random.ascii/upper 1)
     expected_type (\ ! each (function (_ name)
                               (#.Primitive name (list)))
                      (random.ascii/upper 1))
     expected_seed random.nat
     expected random.nat
     dummy (random.only (|>> (n.= expected) not) random.nat)
     expected_location ..random_location
     .let [type_context [#.ex_counter 0
                         #.var_counter 0
                         #.var_bindings (list)]
           expected_lux [#.info            [#.target  target
                                            #.version version
                                            #.mode    #.Build]
                         #.source          [location.dummy 0 source_code]
                         #.location         expected_location
                         #.current_module  (#.Some expected_current_module)
                         #.modules         (list)
                         #.scopes          (list)
                         #.type_context    type_context
                         #.expected        (#.Some expected_type)
                         #.seed            expected_seed
                         #.scope_type_vars (list)
                         #.extensions      []
                         #.eval            (:as (-> Type Code (Meta Any)) [])
                         #.host            []]]]
    ($_ _.and
        (_.cover [/.seed]
                 (|> (do /.monad
                       [pre /.seed
                        post /.seed]
                       (in [pre post]))
                     (/.result expected_lux)
                     (!expect (^multi (#try.Success [actual_pre actual_post])
                                      (and (n.= expected_seed actual_pre)
                                           (n.= (++ expected_seed) actual_post))))))
        (_.cover [/.location]
                 (|> /.location
                     (/.result expected_lux)
                     (!expect (^multi (#try.Success actual_location)
                                      (same? expected_location actual_location)))))
        (_.cover [/.expected_type]
                 (|> /.expected_type
                     (/.result expected_lux)
                     (!expect (^multi (#try.Success actual_type)
                                      (same? expected_type actual_type)))))
        (_.cover [.Type_Context /.type_context]
                 (|> /.type_context
                     (/.result expected_lux)
                     (try\each (same? type_context))
                     (try.else false)))
        )))

(def: definition_related
  Test
  (do [! random.monad]
    [expected_current_module (random.ascii/upper 1)
     expected_macro_module (random.only (|>> (text\= expected_current_module) not)
                                        (random.ascii/upper 1))
     expected_short (random.ascii/upper 1)
     expected_type (\ ! each (function (_ name)
                               (#.Primitive name (list)))
                      (random.ascii/upper 1))
     expected_value (random.either (in .def:)
                                   (in .macro:))
     .let [expected_lux
           (: (-> Bit (Maybe Type)
                  [(List [Text .Global])
                   (List [Text .Global])
                   Lux])
              (function (_ exported? def_type)
                (let [current_globals (: (List [Text .Global])
                                         (list [expected_short
                                                (#.Alias [expected_macro_module expected_short])]))
                      macro_globals (: (List [Text .Global])
                                       (case def_type
                                         (#.Some def_type)
                                         (list [expected_short
                                                (#.Definition [exported? def_type expected_value])])

                                         #.None
                                         (list)))]
                  [current_globals
                   macro_globals
                   [#.info            [#.target  ""
                                       #.version ""
                                       #.mode    #.Build]
                    #.source          [location.dummy 0 ""]
                    #.location         location.dummy
                    #.current_module  (#.Some expected_current_module)
                    #.modules         (list [expected_current_module
                                             [#.module_hash        0
                                              #.module_aliases     (list)
                                              #.definitions        current_globals
                                              #.imports            (list)
                                              #.module_state       #.Active]]
                                            [expected_macro_module
                                             [#.module_hash        0
                                              #.module_aliases     (list)
                                              #.definitions        macro_globals
                                              #.imports            (list)
                                              #.module_state       #.Active]])
                    #.scopes          (list)
                    #.type_context    [#.ex_counter 0
                                       #.var_counter 0
                                       #.var_bindings (list)]
                    #.expected        #.None
                    #.seed            0
                    #.scope_type_vars (list)
                    #.extensions      []
                    #.eval            (:as (-> Type Code (Meta Any)) [])
                    #.host            []]])))]]
    ($_ _.and
        (_.cover [.Global .Alias /.globals]
                 (let [[current_globals macro_globals expected_lux]
                       (expected_lux true (#.Some .Macro))

                       current_globals!
                       (|> (/.globals expected_current_module)
                           (/.result expected_lux)
                           (!expect (^multi (#try.Success actual_globals)
                                            (same? current_globals actual_globals))))

                       macro_globals!
                       (|> (/.globals expected_macro_module)
                           (/.result expected_lux)
                           (!expect (^multi (#try.Success actual_globals)
                                            (same? macro_globals actual_globals))))]
                   (and current_globals!
                        macro_globals!)))
        (_.cover [.Definition /.definitions]
                 (let [[current_globals macro_globals expected_lux]
                       (expected_lux true (#.Some .Macro))]
                   (and (|> (/.definitions expected_current_module)
                            (/.result expected_lux)
                            (!expect (^multi (#try.Success actual_definitions)
                                             (n.= 0 (list.size actual_definitions)))))
                        (|> (/.definitions expected_macro_module)
                            (/.result expected_lux)
                            (!expect (^multi (#try.Success actual_definitions)
                                             (n.= 1 (list.size actual_definitions)))))
                        )))
        (_.cover [/.exports]
                 (and (let [[current_globals macro_globals expected_lux]
                            (expected_lux true (#.Some .Macro))]
                        (and (|> (/.exports expected_current_module)
                                 (/.result expected_lux)
                                 (!expect (^multi (#try.Success actual_definitions)
                                                  (n.= 0 (list.size actual_definitions)))))
                             (|> (/.exports expected_macro_module)
                                 (/.result expected_lux)
                                 (!expect (^multi (#try.Success actual_definitions)
                                                  (n.= 1 (list.size actual_definitions)))))
                             ))
                      (let [[current_globals macro_globals expected_lux]
                            (expected_lux false (#.Some .Macro))]
                        (and (|> (/.exports expected_current_module)
                                 (/.result expected_lux)
                                 (!expect (^multi (#try.Success actual_definitions)
                                                  (n.= 0 (list.size actual_definitions)))))
                             (|> (/.exports expected_macro_module)
                                 (/.result expected_lux)
                                 (!expect (^multi (#try.Success actual_definitions)
                                                  (n.= 0 (list.size actual_definitions)))))
                             ))))
        )))

(def: search_related
  Test
  (do [! random.monad]
    [expected_exported? random.bit
     expected_current_module (random.ascii/upper 1)
     expected_macro_module (random.only (|>> (text\= expected_current_module) not)
                                        (random.ascii/upper 1))
     expected_short (random.ascii/upper 1)
     expected_type (\ ! each (function (_ name)
                               (#.Primitive name (list)))
                      (random.ascii/upper 1))
     expected_value (random.either (in .def:)
                                   (in .macro:))
     .let [expected_lux
           (: (-> Bit (Maybe Type)
                  [(List [Text .Global])
                   (List [Text .Global])
                   Lux])
              (function (_ exported? def_type)
                (let [current_globals (: (List [Text .Global])
                                         (list [expected_short
                                                (#.Alias [expected_macro_module expected_short])]))
                      macro_globals (: (List [Text .Global])
                                       (case def_type
                                         (#.Some def_type)
                                         (list [expected_short
                                                (#.Definition [exported? def_type expected_value])])

                                         #.None
                                         (list)))]
                  [current_globals
                   macro_globals
                   [#.info            [#.target  ""
                                       #.version ""
                                       #.mode    #.Build]
                    #.source          [location.dummy 0 ""]
                    #.location         location.dummy
                    #.current_module  (#.Some expected_current_module)
                    #.modules         (list [expected_current_module
                                             [#.module_hash        0
                                              #.module_aliases     (list)
                                              #.definitions        current_globals
                                              #.imports            (list)
                                              #.module_state       #.Active]]
                                            [expected_macro_module
                                             [#.module_hash        0
                                              #.module_aliases     (list)
                                              #.definitions        macro_globals
                                              #.imports            (list)
                                              #.module_state       #.Active]])
                    #.scopes          (list)
                    #.type_context    [#.ex_counter 0
                                       #.var_counter 0
                                       #.var_bindings (list)]
                    #.expected        #.None
                    #.seed            0
                    #.scope_type_vars (list)
                    #.extensions      []
                    #.eval            (:as (-> Type Code (Meta Any)) [])
                    #.host            []]])))]]
    ($_ _.and
        (_.cover [/.export]
                 (and (let [[current_globals macro_globals expected_lux]
                            (expected_lux true (#.Some expected_type))]
                        (|> (/.export [expected_macro_module expected_short])
                            (/.result expected_lux)
                            (!expect (#try.Success _))))
                      (let [[current_globals macro_globals expected_lux]
                            (expected_lux false (#.Some expected_type))]
                        (|> (/.export [expected_macro_module expected_short])
                            (/.result expected_lux)
                            (!expect (#try.Failure _))))))
        (_.cover [/.macro]
                 (let [same_module!
                       (let [[current_globals macro_globals expected_lux]
                             (expected_lux true (#.Some .Macro))]
                         (|> (/.macro [expected_macro_module expected_short])
                             (/.result expected_lux)
                             (!expect (^multi (#try.Success (#.Some actual_value))
                                              (same? expected_value actual_value)))))

                       not_macro!
                       (let [[current_globals macro_globals expected_lux]
                             (expected_lux true (#.Some expected_type))]
                         (|> (/.macro [expected_macro_module expected_short])
                             (/.result expected_lux)
                             (!expect (#try.Success #.None))))

                       not_found!
                       (let [[current_globals macro_globals expected_lux]
                             (expected_lux true #.None)]
                         (|> (/.macro [expected_macro_module expected_short])
                             (/.result expected_lux)
                             (!expect (#try.Success #.None))))

                       aliasing!
                       (let [[current_globals macro_globals expected_lux]
                             (expected_lux true (#.Some .Macro))]
                         (|> (/.macro [expected_current_module expected_short])
                             (/.result expected_lux)
                             (!expect (^multi (#try.Success (#.Some actual_value))
                                              (same? expected_value actual_value)))))]
                   (and same_module!
                        not_macro!
                        not_found!
                        aliasing!)))
        (_.cover [/.de_aliased]
                 (let [[current_globals macro_globals expected_lux]
                       (expected_lux true (#.Some .Macro))]
                   (and (|> (/.de_aliased [expected_macro_module expected_short])
                            (/.result expected_lux)
                            (try\each (name\= [expected_macro_module expected_short]))
                            (try.else false))
                        (|> (/.de_aliased [expected_current_module expected_short])
                            (/.result expected_lux)
                            (try\each (name\= [expected_macro_module expected_short]))
                            (try.else false)))))
        (_.cover [/.definition]
                 (let [[current_globals macro_globals expected_lux]
                       (expected_lux expected_exported? (#.Some expected_type))

                       definition!
                       (|> (/.definition [expected_macro_module expected_short])
                           (/.result expected_lux)
                           (!expect (^multi (#try.Success (#.Definition [actual_exported? actual_type actual_value]))
                                            (and (bit\= expected_exported? actual_exported?)
                                                 (same? expected_type actual_type)
                                                 (same? (:as Any expected_value) actual_value)))))

                       alias!
                       (|> (/.definition [expected_current_module expected_short])
                           (/.result expected_lux)
                           (!expect (^multi (#try.Success (#.Alias [actual_module actual_short]))
                                            (and (same? expected_macro_module actual_module)
                                                 (same? expected_short actual_short)))))]
                   (and definition!
                        alias!)))
        (_.cover [/.definition_type]
                 (let [[current_globals macro_globals expected_lux]
                       (expected_lux expected_exported? (#.Some expected_type))

                       definition!
                       (|> (/.definition_type [expected_macro_module expected_short])
                           (/.result expected_lux)
                           (!expect (^multi (#try.Success actual_type)
                                            (same? expected_type actual_type))))

                       alias!
                       (|> (/.definition_type [expected_current_module expected_short])
                           (/.result expected_lux)
                           (!expect (^multi (#try.Success actual_type)
                                            (same? expected_type actual_type))))]
                   (and definition!
                        alias!)))
        (_.cover [/.type_definition]
                 (let [[current_globals macro_globals expected_lux]
                       (expected_lux expected_exported? (#.Some .Type))

                       definition!
                       (|> (/.type_definition [expected_macro_module expected_short])
                           (/.result expected_lux)
                           (!expect (^multi (#try.Success actual_value)
                                            (same? (:as .Type expected_value) actual_value))))

                       alias!
                       (|> (/.type_definition [expected_current_module expected_short])
                           (/.result expected_lux)
                           (!expect (^multi (#try.Success actual_value)
                                            (same? (:as .Type expected_value) actual_value))))]
                   (and definition!
                        alias!)))
        )))

(def: tags_related
  Test
  (do [! random.monad]
    [current_module (random.ascii/upper 1)
     tag_module (random.only (|>> (text\= current_module) not)
                             (random.ascii/upper 1))

     name_0 (random.ascii/upper 1)
     name_1 (random.only (|>> (text\= name_0) not)
                         (random.ascii/upper 1))
     
     .let [random_tag (\ ! each (|>> [tag_module])
                         (random.ascii/upper 1))
           random_labels (: (Random [Text (List Text)])
                            (do !
                              [head (random.ascii/lower 5)]
                              (|> (random.ascii/lower 5)
                                  (random.only (|>> (text\= head) not))
                                  (random.set text.hash 3)
                                  (\ ! each set.list)
                                  (random.and (in head)))))]
     tags_0 random_labels
     tags_1 (let [set/0 (set.of_list text.hash (#.Item tags_0))]
              (random.only (|>> #.Item (list.any? (set.member? set/0))not)
                           random_labels))
     .let [type_0 (#.Primitive name_0 (list))
           type_1 (#.Primitive name_1 (list))
           
           expected_lux
           (: Lux
              [#.info            [#.target  ""
                                  #.version ""
                                  #.mode    #.Build]
               #.source          [location.dummy 0 ""]
               #.location        location.dummy
               #.current_module  (#.Some current_module)
               #.modules         (list [current_module
                                        [#.module_hash        0
                                         #.module_aliases     (list)
                                         #.definitions        (list)
                                         #.imports            (list tag_module)
                                         #.module_state       #.Active]]
                                       [tag_module
                                        [#.module_hash        0
                                         #.module_aliases     (list)
                                         #.definitions        (list& [name_0 (#.Type [false type_0 (#.Left tags_0)])]
                                                                     [name_1 (#.Type [true type_1 (#.Right tags_1)])]
                                                                     ($_ list\composite
                                                                         (|> (#.Item tags_0)
                                                                             list.enumeration
                                                                             (list\each (function (_ [index short])
                                                                                          [(format "#" short) (#.Label [false type_0 (#.Item tags_0) index])])))
                                                                         (|> (#.Item tags_1)
                                                                             list.enumeration
                                                                             (list\each (function (_ [index short])
                                                                                          [(format "#" short) (#.Slot [true type_1 (#.Item tags_1) index])])))))
                                         #.imports            (list)
                                         #.module_state       #.Active]])
               #.scopes          (list)
               #.type_context    [#.ex_counter 0
                                  #.var_counter 0
                                  #.var_bindings (list)]
               #.expected        #.None
               #.seed            0
               #.scope_type_vars (list)
               #.extensions      []
               #.eval            (:as (-> Type Code (Meta Any)) [])
               #.host            []])]]
    ($_ _.and
        (_.cover [/.tag_lists]
                 (let [equivalence (list.equivalence
                                    (product.equivalence
                                     (list.equivalence name.equivalence)
                                     type.equivalence))]
                   (|> (/.tag_lists tag_module)
                       (/.result expected_lux)
                       (try\each (\ equivalence = (list [(list\each (|>> [tag_module]) (#.Item tags_1))
                                                         type_1])))
                       (try.else false))))
        (_.cover [/.tags_of]
                 (|> (/.tags_of [tag_module name_1])
                     (/.result expected_lux)
                     (try\each (\ (maybe.equivalence (list.equivalence name.equivalence)) = (#.Some (list\each (|>> [tag_module]) (#.Item tags_1)))))
                     (try.else false)))
        (_.cover [/.slot]
                 (|> (#.Item tags_1)
                     list.enumeration
                     (list.every? (function (_ [expected_index tag])
                                    (|> [tag_module tag]
                                        /.slot
                                        (/.result expected_lux)
                                        (!expect (^multi (#try.Success [actual_index actual_tags actual_type])
                                                         (let [correct_index!
                                                               (n.= expected_index
                                                                    actual_index)

                                                               correct_tags!
                                                               (\ (list.equivalence name.equivalence) =
                                                                  (list\each (|>> [tag_module]) (#.Item tags_1))
                                                                  actual_tags)

                                                               correct_type!
                                                               (type\= type_1
                                                                       actual_type)]
                                                           (and correct_index!
                                                                correct_tags!
                                                                correct_type!))))
                                        )))))
        )))

(def: locals_related
  Test
  (do [! random.monad]
    [current_module (random.ascii/upper 1)
     [name_0 name_1 name_2 name_3 name_4] (|> (random.ascii/upper 1)
                                              (random.set text.hash 5)
                                              (\ ! each set.list)
                                              (random.one (function (_ values)
                                                            (case values
                                                              (^ (list name_0 name_1 name_2 name_3 name_4))
                                                              (#.Some [name_0 name_1 name_2 name_3 name_4])

                                                              _
                                                              #.None))))
     .let [type_0 (#.Primitive name_0 (list))
           type_1 (#.Primitive name_1 (list))
           type_2 (#.Primitive name_2 (list))
           type_3 (#.Primitive name_3 (list))
           type_4 (#.Primitive name_4 (list))

           globals (: (List [Text .Global])
                      (list [name_4
                             (#.Definition [false type_4 []])]))

           scopes (list [#.name     (list)
                         #.inner    0
                         #.locals   [#.counter 1
                                     #.mappings (list [name_3 [type_3 3]])]
                         #.captured [#.counter 0
                                     #.mappings (list)]]
                        [#.name     (list)
                         #.inner    0
                         #.locals   [#.counter 2
                                     #.mappings (list [name_1 [type_1 1]]
                                                      [name_2 [type_2 2]])]
                         #.captured [#.counter 0
                                     #.mappings (list)]]
                        [#.name     (list)
                         #.inner    0
                         #.locals   [#.counter 1
                                     #.mappings (list [name_0 [type_0 0]])]
                         #.captured [#.counter 0
                                     #.mappings (list)]])]
     .let [expected_lux
           (: Lux
              [#.info            [#.target  ""
                                  #.version ""
                                  #.mode    #.Build]
               #.source          [location.dummy 0 ""]
               #.location        location.dummy
               #.current_module  (#.Some current_module)
               #.modules         (list [current_module
                                        [#.module_hash        0
                                         #.module_aliases     (list)
                                         #.definitions        globals
                                         #.imports            (list)
                                         #.module_state       #.Active]])
               #.scopes          scopes
               #.type_context    [#.ex_counter 0
                                  #.var_counter 0
                                  #.var_bindings (list)]
               #.expected        #.None
               #.seed            0
               #.scope_type_vars (list)
               #.extensions      []
               #.eval            (:as (-> Type Code (Meta Any)) [])
               #.host            []])]]
    ($_ _.and
        (_.cover [.Scope /.locals]
                 (let [equivalence (: (Equivalence (List (List [Text Type])))
                                      (list.equivalence
                                       (list.equivalence
                                        (product.equivalence
                                         text.equivalence
                                         type.equivalence))))]
                   (|> /.locals
                       (/.result expected_lux)
                       (try\each (\ equivalence = (list (list [name_3 type_3])
                                                        (list [name_1 type_1]
                                                              [name_2 type_2]))))
                       (try.else false))))
        (_.cover [/.var_type]
                 (and (|> (/.var_type name_0)
                          (/.result expected_lux)
                          (try\each (\ type.equivalence = type_0))
                          (try.else false))
                      (|> (/.var_type name_1)
                          (/.result expected_lux)
                          (try\each (\ type.equivalence = type_1))
                          (try.else false))
                      (|> (/.var_type name_2)
                          (/.result expected_lux)
                          (try\each (\ type.equivalence = type_2))
                          (try.else false))
                      (|> (/.var_type name_3)
                          (/.result expected_lux)
                          (try\each (\ type.equivalence = type_3))
                          (try.else false))))
        (_.cover [/.type]
                 (and (|> (/.type ["" name_0])
                          (/.result expected_lux)
                          (try\each (\ type.equivalence = type_0))
                          (try.else false))
                      (|> (/.type ["" name_1])
                          (/.result expected_lux)
                          (try\each (\ type.equivalence = type_1))
                          (try.else false))
                      (|> (/.type ["" name_2])
                          (/.result expected_lux)
                          (try\each (\ type.equivalence = type_2))
                          (try.else false))
                      (|> (/.type ["" name_3])
                          (/.result expected_lux)
                          (try\each (\ type.equivalence = type_3))
                          (try.else false))
                      (|> (/.type [current_module name_4])
                          (/.result expected_lux)
                          (try\each (\ type.equivalence = type_4))
                          (try.else false))
                      (|> (/.type ["" name_4])
                          (/.result expected_lux)
                          (try\each (\ type.equivalence = type_4))
                          (try.else false))))
        )))

(def: injection
  (Injection Meta)
  (\ /.monad in))

(def: (comparison init)
  (-> Lux (Comparison Meta))
  (function (_ == left right)
    (case [(/.result init left)
           (/.result init right)]
      [(#try.Success left) (#try.Success right)]
      (== left right)
      
      _
      false)))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [.Meta .Lux])
      ($_ _.and
          (do [! random.monad]
            [target (random.ascii/upper 1)
             version (random.ascii/upper 1)
             source_code (random.ascii/upper 1)
             expected_current_module (random.ascii/upper 1)
             expected_type (\ ! each (function (_ name)
                                       (#.Primitive name (list)))
                              (random.ascii/upper 1))
             expected_seed random.nat
             expected random.nat
             dummy (random.only (|>> (n.= expected) not) random.nat)
             expected_location ..random_location
             .let [expected_lux [#.info            [#.target  target
                                                    #.version version
                                                    #.mode    #.Build]
                                 #.source          [expected_location 0 source_code]
                                 #.location         expected_location
                                 #.current_module  (#.Some expected_current_module)
                                 #.modules         (list)
                                 #.scopes          (list)
                                 #.type_context    [#.ex_counter 0
                                                    #.var_counter 0
                                                    #.var_bindings (list)]
                                 #.expected        (#.Some expected_type)
                                 #.seed            expected_seed
                                 #.scope_type_vars (list)
                                 #.extensions      []
                                 #.eval            (:as (-> Type Code (Meta Any)) [])
                                 #.host            []]]]
            ($_ _.and
                (_.for [/.functor]
                       ($functor.spec ..injection (..comparison expected_lux) /.functor))
                (_.for [/.apply]
                       ($apply.spec ..injection (..comparison expected_lux) /.apply))
                (_.for [/.monad]
                       ($monad.spec ..injection (..comparison expected_lux) /.monad))

                (do random.monad
                  [expected_value random.nat
                   expected_error (random.ascii/upper 1)]
                  (_.cover [/.lifted]
                           (and (|> expected_error
                                    #try.Failure
                                    (: (Try Nat))
                                    /.lifted
                                    (/.result expected_lux)
                                    (!expect (^multi (#try.Failure actual)
                                                     (text\= (location.with expected_location expected_error)
                                                             actual))))
                                (|> expected_value
                                    #try.Success
                                    (: (Try Nat))
                                    /.lifted
                                    (/.result expected_lux)
                                    (!expect (^multi (#try.Success actual)
                                                     (same? expected_value actual)))))))
                
                ..compiler_related
                ..error_handling
                ..module_related
                ..context_related
                ..definition_related
                ..search_related
                ..tags_related
                ..locals_related
                ))
          
          /annotation.test
          /location.test
          )))
