(.module:
  [library
   [lux #*
    ["_" test (#+ Test)]
    ["." type ("#\." equivalence)]
    ["." meta]
    [abstract
     [monad (#+ do)]]
    [control
     [pipe (#+ case>)]
     ["." try]
     ["." exception]]
    [data
     ["." bit ("#\." equivalence)]
     ["." text ("#\." equivalence)]
     [collection
      ["." array (#+ Array)]]]
    ["." macro
     [syntax (#+ syntax:)]
     ["." code]]
    [math
     ["." random]
     [number
      ["n" nat]
      ["i" int ("#\." equivalence)]
      ["f" frac ("#\." equivalence)]]]]]
  [\\library
   ["." /]])

(/.import: java/lang/Boolean)
(/.import: java/lang/Long)

(/.import: java/lang/String)

(/.import: java/lang/Object)

(/.import: (java/lang/Class a)
  ["#::."
   (getName [] java/lang/String)])

## TODO: Handle "/.class:" ASAP.
## (/.class: #final (TestClass A) [java/lang/Runnable]
##   ## Fields
##   (#private foo boolean)
##   (#private bar A)
##   (#private baz java/lang/Object)
##   ## Methods
##   (#public [] (new self {value A}) []
##            (exec (:= ::foo #1)
##              (:= ::bar value)
##              (:= ::baz "")
##              []))
##   (#public (virtual self) java/lang/Object
##            "")
##   (#public #static (static) java/lang/Object
##            "")
##   (java/lang/Runnable [] (run self) void
##                       []))

(template [<name> <type> <conversion> <lux> <=>]
  [(def: (<name> left right)
     (-> <type> <type> Bit)
     (<=> (:as <lux> (<conversion> left))
          (:as <lux> (<conversion> right))))]

  [boolean\= /.Boolean <| Bit bit\=]
  [byte\= /.Byte /.byte_to_long Int i\=]
  [short\= /.Short /.short_to_long Int i\=]
  [integer\= /.Integer /.int_to_long Int i\=]
  [long\= /.Long <| Int i\=]
  [float\= /.Float /.float_to_double Frac f\=]
  [double\= /.Double <| Frac f\=]
  [character\= /.Character /.char_to_long Int i\=]
  )

(syntax: (macro_error expression)
  (function (_ lux)
    (|> (macro.expand_once expression)
        (meta.run lux)
        (case> (#try.Success expansion)
               (#try.Failure "OOPS!")
               
               (#try.Failure error)
               (#try.Success [lux (list (code.text error))])))))

(def: conversions
  Test
  (do {! random.monad}
    [long (\ ! map (|>> (:as /.Long)) random.int)
     integer (\ ! map (|>> (:as /.Long) /.long_to_int) random.int)
     byte (\ ! map (|>> (:as /.Long) /.long_to_byte) random.int)
     short (\ ! map (|>> (:as /.Long) /.long_to_short) random.int)
     float (\ ! map (|>> (:as /.Double) /.double_to_float) random.frac)]
    (`` ($_ _.and
            (~~ (template [<sample> <=> <to> <from>]
                  [(_.cover [<to> <from>]
                            (or (|> <sample> <to> <from> (<=> <sample>))
                                (let [capped (|> <sample> <to> <from>)]
                                  (|> capped <to> <from> (<=> capped)))))]

                  [long long\= /.long_to_byte /.byte_to_long]
                  [long long\= /.long_to_short /.short_to_long]
                  [long long\= /.long_to_int /.int_to_long]
                  [long long\= /.long_to_float /.float_to_long]
                  [long long\= /.long_to_double /.double_to_long]
                  [long long\= /.long_to_char /.char_to_long]

                  [integer integer\= /.int_to_double /.double_to_int]
                  [integer integer\= /.int_to_float /.float_to_int]
                  [integer integer\= /.int_to_char /.char_to_int]

                  [byte byte\= /.byte_to_int /.int_to_byte]
                  [short short\= /.short_to_int /.int_to_short]
                  [byte byte\= /.byte_to_char /.char_to_byte]
                  [short short\= /.short_to_char /.char_to_short]
                  [float float\= /.float_to_double /.double_to_float]
                  ))))))

(def: arrays
  Test
  (do {! random.monad}
    [size (|> random.nat (\ ! map (|>> (n.% 100) (n.max 1))))
     idx (|> random.nat (\ ! map (n.% size)))
     value (\ ! map (|>> (:as java/lang/Long)) random.int)]
    ($_ _.and
        (_.cover [/.array /.array_length]
                 (|> size
                     (/.array java/lang/Long)
                     /.array_length
                     (n.= size)))
        (_.cover [/.array_write /.array_read]
                 (|> (/.array java/lang/Long size)
                     (/.array_write idx value)
                     (/.array_read idx)
                     (:as Int)
                     (i.= (:as Int value))))
        (_.cover [/.cannot_convert_to_jvm_type]
                 (let [array (:as (Array Nothing)
                                  (array.new 1))]
                   (|> array
                       /.array_length
                       ..macro_error
                       (text.contains? (get@ #exception.label /.cannot_convert_to_jvm_type))))))))

(def: miscellaneous
  Test
  (`` (do {! random.monad}
        [sample (\ ! map (|>> (:as java/lang/Object))
                   (random.ascii 1))
         boolean (\ ! map (|>> (:as /.Boolean)) random.bit)
         byte (\ ! map (|>> (:as /.Long) /.long_to_byte) random.int)
         short (\ ! map (|>> (:as /.Long) /.long_to_short) random.int)
         integer (\ ! map (|>> (:as /.Long) /.long_to_int) random.int)
         long (\ ! map (|>> (:as /.Long)) random.int)
         float (\ ! map (|>> (:as /.Double) /.double_to_float) random.frac)
         double (\ ! map (|>> (:as /.Double)) random.frac)
         character (\ ! map (|>> (:as /.Long) /.long_to_int /.int_to_char) random.int)
         string (\ ! map (|>> (:as java/lang/String))
                   (random.ascii 1))]
        ($_ _.and
            (_.cover [/.check]
                     (and (case (/.check java/lang/String sample) (#.Some _) true #.None false)
                          (case (/.check java/lang/Long sample) (#.Some _) false #.None true)
                          (case (/.check java/lang/Object sample) (#.Some _) true #.None false)
                          (case (/.check java/lang/Object (/.null)) (#.Some _) false #.None true)))
            (_.cover [/.synchronized]
                     (/.synchronized sample #1))
            (_.cover [/.class_for]
                     (text\= "java.lang.Class" (java/lang/Class::getName (/.class_for java/lang/Class))))
            (_.cover [/.null /.null?]
                     (and (/.null? (/.null))
                          (not (/.null? sample))))
            (_.cover [/.???]
                     (and (|> (/.??? (/.null))
                              (: (Maybe java/lang/Object))
                              (case> #.None #1
                                     (#.Some _) #0))
                          (|> (/.??? sample)
                              (: (Maybe java/lang/Object))
                              (case> (#.Some _) #1
                                     #.None #0))))
            (_.cover [/.!!!]
                     (and (|> (/.??? (/.null))
                              /.!!!
                              /.null?)
                          (|> (/.??? sample)
                              /.!!!
                              /.null?
                              not)))
            (~~ (template [<object> <primitive> <value> <=>]
                  [(|> <value>
                       (: <object>)
                       "jvm object cast"
                       (: <primitive>)
                       "jvm object cast"
                       (: <object>)
                       (<=> <value>)
                       (_.cover [<object> <primitive>]))]

                  [/.Boolean /.boolean boolean boolean\=]
                  [/.Byte /.byte byte byte\=]
                  [/.Short /.short short short\=]
                  [/.Integer /.int integer integer\=]
                  [/.Long /.long long long\=]
                  [/.Float /.float float float\=]
                  [/.Double /.double double double\=]
                  [/.Character /.char character character\=]
                  ))
            (_.cover [/.cannot_cast_to_non_object]
                     (text.contains? (get@ #exception.label /.cannot_cast_to_non_object)
                                     (macro_error (/.:cast boolean (: /.Boolean boolean)))))
            (_.cover [/.:cast]
                     (|> string
                         (/.:cast java/lang/Object)
                         (is? (:as java/lang/Object string))))
            (_.cover [/.type]
                     (and (and (type\= /.Boolean (/.type java/lang/Boolean))
                               (type\= /.Boolean (/.type boolean)))
                          (and (type\= /.Byte (/.type java/lang/Byte))
                               (type\= /.Byte (/.type byte)))
                          (and (type\= /.Short (/.type java/lang/Short))
                               (type\= /.Short (/.type short)))
                          (and (type\= /.Integer (/.type java/lang/Integer))
                               (type\= /.Integer (/.type int)))
                          (and (type\= /.Long (/.type java/lang/Long))
                               (type\= /.Long (/.type long)))
                          (and (type\= /.Float (/.type java/lang/Float))
                               (type\= /.Float (/.type float)))
                          (and (type\= /.Double (/.type java/lang/Double))
                               (type\= /.Double (/.type double)))
                          (and (type\= /.Character (/.type java/lang/Character))
                               (type\= /.Character (/.type char)))))
            ))))

(/.interface: test/TestInterface0
  ([] actual0 [] java/lang/Long))

(/.import: test/TestInterface0
  ["#::."
   (actual0 [] java/lang/Long)])

(/.interface: test/TestInterface1
  ([] actual1 [java/lang/Boolean] java/lang/Long #throws [java/lang/Throwable]))

(/.import: test/TestInterface1
  ["#::."
   (actual1 [java/lang/Boolean] #try java/lang/Long)])

(/.interface: test/TestInterface2
  ([a] actual2 [a] a))

(/.import: test/TestInterface2
  ["#::."
   ([a] actual2 [a] a)])

(/.interface: (test/TestInterface3 a)
  ([] actual3 [] a))

(/.import: (test/TestInterface3 a)
  ["#::."
   (actual3 [] a)])

(def: interface
  (do random.monad
    [expected random.nat
     #let [object/0 (/.object [] [test/TestInterface0]
                      []
                      (test/TestInterface0
                       [] (actual0 self)
                       java/lang/Long
                       (:as java/lang/Long
                            expected)))
           object/1 (/.object [] [test/TestInterface1]
                      []
                      (test/TestInterface1
                       [] (actual1 self {throw? java/lang/Boolean})
                       java/lang/Long
                       #throws [java/lang/Throwable]
                       (if (:as Bit throw?)
                         (error! "YOLO")
                         (:as java/lang/Long
                              expected))))
           object/2 (/.object [] [test/TestInterface2]
                      []
                      (test/TestInterface2
                       [a] (actual2 self {input a})
                       a
                       input))
           object/3 (/.object [] [(test/TestInterface3 java/lang/Long)]
                      []
                      ((test/TestInterface3 a)
                       [] (actual3 self)
                       a
                       (:as java/lang/Long
                            expected)))

           example/0!
           (is? (: Any expected)
                (: Any (test/TestInterface0::actual0 object/0)))

           example/1!
           (and (case (test/TestInterface1::actual1 false object/1)
                  (#try.Success actual)
                  (is? (: Any expected)
                       (: Any actual))
                  
                  (#try.Failure error)
                  false)
                (case (test/TestInterface1::actual1 true object/1)
                  (#try.Success actual)
                  false
                  
                  (#try.Failure error)
                  true))

           example/2!
           (is? (: Any expected)
                (: Any (test/TestInterface2::actual2 (:as /.Long expected) object/2)))

           example/3!
           (is? (: Any expected)
                (: Any (test/TestInterface3::actual3 object/3)))]]
    (_.cover [/.interface:]
             (and example/0!
                  example/1!
                  example/2!
                  example/3!))))

(def: #export test
  (<| (_.covering /._)
      ($_ _.and
          ..conversions
          ..arrays
          ..miscellaneous
          ..interface
          )))
