(.module:
  [lux #*
   ["_" test (#+ Test)]
   ["." type ("#\." equivalence)]
   ["." meta]
   [abstract
    [monad (#+ do)]]
   [control
    [pipe (#+ case>)]
    ["." try]
    ["." exception]]
   [data
    ["." bit ("#\." equivalence)]
    ["." text ("#\." equivalence)]
    [collection
     ["." array (#+ Array)]]]
   ["." macro
    [syntax (#+ syntax:)]
    ["." code]]
   [math
    ["." random]
    [number
     ["n" nat]
     ["i" int ("#\." equivalence)]
     ["f" frac ("#\." equivalence)]]]]
  [\\
   ["." /]])

(/.import: (java/util/concurrent/Callable a))

(/.import: java/lang/Long)

(/.import: java/lang/String)

(/.import: java/lang/Exception
  ["#::."
   (new [java/lang/String])])

(/.import: java/lang/Object)

(/.import: (java/lang/Class a)
  ["#::."
   (getName [] java/lang/String)])

(/.import: java/lang/Runnable)

(/.import: java/lang/System
  ["#::."
   (#static out java/io/PrintStream)
   (#static currentTimeMillis [] #io long)
   (#static getenv [java/lang/String] #io #? java/lang/String)])

## TODO: Handle "/.class:" ASAP.
## (/.class: #final (TestClass A) [java/lang/Runnable]
##   ## Fields
##   (#private foo boolean)
##   (#private bar A)
##   (#private baz java/lang/Object)
##   ## Methods
##   (#public [] (new self {value A}) []
##            (exec (:= ::foo #1)
##              (:= ::bar value)
##              (:= ::baz "")
##              []))
##   (#public (virtual self) java/lang/Object
##            "")
##   (#public #static (static) java/lang/Object
##            "")
##   (java/lang/Runnable [] (run self) void
##                       []))

(def: test_runnable
  (/.object [] [java/lang/Runnable]
    []
    (java/lang/Runnable
     [] (run self) void
     [])))

(def: test_callable
  (/.object [a] [(java/util/concurrent/Callable a)]
    []
    ((java/util/concurrent/Callable a)
     [] (call self) a #throws [java/lang/Exception]
     (undefined))))

## (/.interface: TestInterface
##   ([] foo [boolean java/lang/String] void #throws [java/lang/Exception]))

(template [<name> <type> <conversion> <lux> <=>]
  [(def: (<name> left right)
     (-> <type> <type> Bit)
     (<=> (:as <lux> (<conversion> left))
          (:as <lux> (<conversion> right))))]

  [boolean\= /.Boolean <| Bit bit\=]
  [byte\= /.Byte /.byte_to_long Int i\=]
  [short\= /.Short /.short_to_long Int i\=]
  [integer\= /.Integer /.int_to_long Int i\=]
  [long\= /.Long <| Int i\=]
  [float\= /.Float /.float_to_double Frac f\=]
  [double\= /.Double <| Frac f\=]
  [character\= /.Character /.char_to_long Int i\=]
  )

(syntax: (macro_error expression)
  (function (_ lux)
    (|> (macro.expand_once expression)
        (meta.run lux)
        (case> (#try.Success expansion)
               (#try.Failure "OOPS!")
               
               (#try.Failure error)
               (#try.Success [lux (list (code.text error))])))))

(def: conversions
  Test
  (do {! random.monad}
    [long (\ ! map (|>> (:as /.Long)) random.int)
     integer (\ ! map (|>> (:as /.Long) /.long_to_int) random.int)
     byte (\ ! map (|>> (:as /.Long) /.long_to_byte) random.int)
     short (\ ! map (|>> (:as /.Long) /.long_to_short) random.int)
     float (\ ! map (|>> (:as /.Double) /.double_to_float) random.frac)]
    (`` ($_ _.and
            (~~ (template [<sample> <=> <to> <from>]
                  [(_.cover [<to> <from>]
                            (or (|> <sample> <to> <from> (<=> <sample>))
                                (let [capped (|> <sample> <to> <from>)]
                                  (|> capped <to> <from> (<=> capped)))))]

                  [long long\= /.long_to_byte /.byte_to_long]
                  [long long\= /.long_to_short /.short_to_long]
                  [long long\= /.long_to_int /.int_to_long]
                  [long long\= /.long_to_float /.float_to_long]
                  [long long\= /.long_to_double /.double_to_long]
                  [long long\= /.long_to_char /.char_to_long]

                  [integer integer\= /.int_to_double /.double_to_int]
                  [integer integer\= /.int_to_float /.float_to_int]
                  [integer integer\= /.int_to_char /.char_to_int]

                  [byte byte\= /.byte_to_int /.int_to_byte]
                  [short short\= /.short_to_int /.int_to_short]
                  [byte byte\= /.byte_to_char /.char_to_byte]
                  [short short\= /.short_to_char /.char_to_short]
                  [float float\= /.float_to_double /.double_to_float]
                  ))))))

(def: arrays
  Test
  (do {! random.monad}
    [size (|> random.nat (\ ! map (|>> (n.% 100) (n.max 1))))
     idx (|> random.nat (\ ! map (n.% size)))
     value (\ ! map (|>> (:as java/lang/Long)) random.int)]
    ($_ _.and
        (_.cover [/.array /.array_length]
                 (|> size
                     (/.array java/lang/Long)
                     /.array_length
                     (n.= size)))
        (_.cover [/.array_write /.array_read]
                 (|> (/.array java/lang/Long size)
                     (/.array_write idx value)
                     (/.array_read idx)
                     (:as Int)
                     (i.= (:as Int value))))
        (_.cover [/.cannot_convert_to_jvm_type]
                 (let [array (:as (Array Nothing)
                                  (array.new 1))]
                   (|> array
                       /.array_length
                       ..macro_error
                       (text.contains? (get@ #exception.label /.cannot_convert_to_jvm_type))))))))

(def: miscellaneous
  Test
  (`` (do {! random.monad}
        [sample (\ ! map (|>> (:as java/lang/Object))
                   (random.ascii 1))
         boolean (\ ! map (|>> (:as /.Boolean)) random.bit)
         byte (\ ! map (|>> (:as /.Long) /.long_to_byte) random.int)
         short (\ ! map (|>> (:as /.Long) /.long_to_short) random.int)
         integer (\ ! map (|>> (:as /.Long) /.long_to_int) random.int)
         long (\ ! map (|>> (:as /.Long)) random.int)
         float (\ ! map (|>> (:as /.Double) /.double_to_float) random.frac)
         double (\ ! map (|>> (:as /.Double)) random.frac)
         character (\ ! map (|>> (:as /.Long) /.long_to_int /.int_to_char) random.int)
         string (\ ! map (|>> (:as java/lang/String))
                   (random.ascii 1))]
        ($_ _.and
            (_.cover [/.check]
                     (and (case (/.check java/lang/String sample) (#.Some _) true #.None false)
                          (case (/.check java/lang/Long sample) (#.Some _) false #.None true)
                          (case (/.check java/lang/Object sample) (#.Some _) true #.None false)
                          (case (/.check java/lang/Object (/.null)) (#.Some _) false #.None true)))
            (_.cover [/.synchronized]
                     (/.synchronized sample #1))
            (_.cover [/.class_for]
                     (text\= "java.lang.Class" (java/lang/Class::getName (/.class_for java/lang/Class))))
            (_.cover [/.null /.null?]
                     (and (/.null? (/.null))
                          (not (/.null? sample))))
            (_.cover [/.???]
                     (and (|> (/.??? (/.null))
                              (: (Maybe java/lang/Object))
                              (case> #.None #1
                                     (#.Some _) #0))
                          (|> (/.??? sample)
                              (: (Maybe java/lang/Object))
                              (case> (#.Some _) #1
                                     #.None #0))))
            (_.cover [/.!!!]
                     (and (|> (/.??? (/.null))
                              /.!!!
                              /.null?)
                          (|> (/.??? sample)
                              /.!!!
                              /.null?
                              not)))
            (~~ (template [<object> <primitive> <value> <=>]
                  [(|> <value>
                       (: <object>)
                       "jvm object cast"
                       (: <primitive>)
                       "jvm object cast"
                       (: <object>)
                       (<=> <value>)
                       (_.cover [<object> <primitive>]))]

                  [/.Boolean /.boolean boolean boolean\=]
                  [/.Byte /.byte byte byte\=]
                  [/.Short /.short short short\=]
                  [/.Integer /.int integer integer\=]
                  [/.Long /.long long long\=]
                  [/.Float /.float float float\=]
                  [/.Double /.double double double\=]
                  [/.Character /.char character character\=]
                  ))
            (_.cover [/.cannot_cast_to_non_object]
                     (text.contains? (get@ #exception.label /.cannot_cast_to_non_object)
                                     (macro_error (/.:cast boolean (: /.Boolean boolean)))))
            (_.cover [/.:cast]
                     (|> string
                         (/.:cast java/lang/Object)
                         (is? (:as java/lang/Object string))))
            (_.cover [/.type]
                     (and (and (type\= /.Boolean (/.type java/lang/Boolean))
                               (type\= /.Boolean (/.type boolean)))
                          (and (type\= /.Byte (/.type java/lang/Byte))
                               (type\= /.Byte (/.type byte)))
                          (and (type\= /.Short (/.type java/lang/Short))
                               (type\= /.Short (/.type short)))
                          (and (type\= /.Integer (/.type java/lang/Integer))
                               (type\= /.Integer (/.type int)))
                          (and (type\= /.Long (/.type java/lang/Long))
                               (type\= /.Long (/.type long)))
                          (and (type\= /.Float (/.type java/lang/Float))
                               (type\= /.Float (/.type float)))
                          (and (type\= /.Double (/.type java/lang/Double))
                               (type\= /.Double (/.type double)))
                          (and (type\= /.Character (/.type java/lang/Character))
                               (type\= /.Character (/.type char)))))
            ))))

(def: #export test
  (<| (_.covering /._)
      ($_ _.and
          ..conversions
          ..arrays
          ..miscellaneous)))
