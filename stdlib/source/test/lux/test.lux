(.using
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" io]
    ["[0]" exception]
    [concurrency
     ["[0]" async]
     ["[0]" atom (.only Atom)]]]
   [data
    ["[0]" text (.open: "[1]#[0]" equivalence)
     ["%" \\format]]
    [collection
     ["[0]" list]
     ["[0]" set]]]
   [math
    ["[0]" random]
    [number
     ["n" nat]]]]]
 [\\library
  ["[0]" /]])

(def (verify expected_message/0 expected_message/1 successes failures [tally message])
  (-> Text Text Nat Nat [/.Tally Text] Bit)
  (and (text.contains? expected_message/0 message)
       (text.contains? expected_message/1 message)
       (n.= successes (the /.#successes tally))
       (n.= failures (the /.#failures tally))))

(def assertion
  /.Test
  (do [! random.monad]
    [expected_message/0 (random.lower_case 5)
     expected_message/1 (random.only (|>> (text#= expected_message/0) not)
                                     (random.lower_case 5))]
    (all /.and
         (in (do async.monad
               [[success_tally success_message] (/.assertion expected_message/0 true)
                [failure_tally failure_message] (/.assertion expected_message/0 false)]
               (/.coverage' [/.assertion /.Tally]
                 (and (text.ends_with? expected_message/0 success_message)
                      (text.ends_with? expected_message/0 failure_message)
                      (and (n.= 1 (the /.#successes success_tally))
                           (n.= 0 (the /.#failures success_tally)))
                      (and (n.= 0 (the /.#successes failure_tally))
                           (n.= 1 (the /.#failures failure_tally)))))))
         (in (do async.monad
               [tt (/.and' (/.assertion expected_message/0 true)
                           (/.assertion expected_message/1 true))
                ff (/.and' (/.assertion expected_message/0 false)
                           (/.assertion expected_message/1 false))
                tf (/.and' (/.assertion expected_message/0 true)
                           (/.assertion expected_message/1 false))
                ft (/.and' (/.assertion expected_message/0 false)
                           (/.assertion expected_message/1 true))]
               (/.coverage' [/.and']
                 (and (..verify expected_message/0 expected_message/1 2 0 tt)
                      (..verify expected_message/0 expected_message/1 0 2 ff)
                      (..verify expected_message/0 expected_message/1 1 1 tf)
                      (..verify expected_message/0 expected_message/1 1 1 ft)))))
         )))

(def seed
  /.Test
  (do [! random.monad]
    [seed random.nat
     .let [[read write] (is [(async.Async Nat) (async.Resolver Nat)]
                            (async.async []))]
     pre (<| (/.seed seed)
             (do !
               [sample random.nat
                .let [wrote? (io.run! (write sample))]]
               (/.property "" wrote?)))
     post (<| (/.seed seed)
              (do !
                [actual random.nat]
                (in (do async.monad
                      [expected read]
                      (/.assertion "" (n.= expected actual))))))]
    (in (do async.monad
          [[pre_tally pre_message] pre
           [post_tally post_message] post]
          (/.coverage' [/.seed]
            (and (and (n.= 1 (the /.#successes pre_tally))
                      (n.= 0 (the /.#failures pre_tally)))
                 (and (n.= 1 (the /.#successes post_tally))
                      (n.= 0 (the /.#failures post_tally)))))))))

(def times
  /.Test
  (all /.and
       (do [! random.monad]
         [times_assertion (/.times 0 (/.property "" true))]
         (in (do async.monad
               [[tally error] times_assertion]
               (/.coverage' [/.must_try_test_at_least_once]
                 (and (text.contains? (the exception.#label /.must_try_test_at_least_once) error)
                      (n.= 0 (the /.#successes tally))
                      (n.= 1 (the /.#failures tally)))))))
       (do [! random.monad]
         [expected (at ! each (|>> (n.% 10) ++) random.nat)
          .let [counter (is (Atom Nat)
                            (atom.atom 0))]
          times_assertion (<| (/.times expected)
                              (do !
                                [_ (in [])
                                 .let [_ (io.run! (atom.update! ++ counter))]]
                                (/.property "" true)))]
         (in (do async.monad
               [[tally error] times_assertion
                actual (async.future (atom.read! counter))]
               (/.coverage' [/.times]
                 (and (n.= expected actual)
                      (n.= 1 (the /.#successes tally))
                      (n.= 0 (the /.#failures tally)))))))
       ))

(def in_parallel
  /.Test
  (all /.and
       (do [! random.monad]
         [expected (at ! each (|>> (n.% 10) ++) random.nat)
          .let [counter (is (Atom Nat)
                            (atom.atom 0))]
          assertion (<| /.in_parallel
                        (list.repeated expected)
                        (is /.Test)
                        (do !
                          [_ (in [])
                           .let [_ (io.run! (atom.update! ++ counter))]]
                          (/.property "" true)))]
         (in (do async.monad
               [[tally error] assertion
                actual (async.future (atom.read! counter))]
               (/.coverage' [/.in_parallel]
                 (and (n.= expected actual)
                      (n.= expected (the /.#successes tally))
                      (n.= 0 (the /.#failures tally)))))))
       (do [! random.monad]
         [expected (at ! each (|>> (n.% 10) ++) random.nat)
          .let [counter (is (Atom Nat)
                            (atom.atom 0))]
          assertion (<| /.in_parallel
                        (list.repeated expected)
                        (is /.Test)
                        (do !
                          [_ (in [])
                           .let [_ (undefined)
                                 _ (io.run! (atom.update! ++ counter))]]
                          (/.property "" true)))]
         (in (do async.monad
               [[tally error] assertion
                actual (async.future (atom.read! counter))]
               (/.coverage' [/.error_during_execution]
                 (let [correct_error! (text.contains? (the exception.#label /.error_during_execution) error)
                       no_complete_run! (n.= 0 actual)
                       no_successes! (n.= 0 (the /.#successes tally))
                       ran_all_tests! (n.= expected (the /.#failures tally))]
                   (and correct_error!
                        no_complete_run!
                        no_successes!
                        ran_all_tests!))))))
       ))

(def .public dummy_target
  "YOLO")

(def coverage
  /.Test
  (all /.and
       (do random.monad
         [not_covering (/.property "" true)
          covering (/.covering .._ (/.property "" true))]
         (in (do async.monad
               [[not_covering _] not_covering
                [covering _] covering]
               (/.coverage' [/.covering]
                 (and (and (set.empty? (the /.#expected_coverage not_covering))
                           (set.empty? (the /.#actual_coverage not_covering)))
                      (and (not (set.empty? (the /.#expected_coverage covering)))
                           (set.empty? (the /.#actual_coverage covering))))))))
       (do random.monad
         [not_covering (/.covering .._ (/.property "" true))
          covering (/.covering .._ (/.coverage [..dummy_target] true))]
         (in (do async.monad
               [[not_covering _] not_covering
                [covering _] covering]
               (/.coverage' [/.coverage]
                 (and (and (not (set.empty? (the /.#expected_coverage not_covering)))
                           (not (set.member? (the /.#actual_coverage not_covering) (symbol ..dummy_target))))
                      (and (not (set.empty? (the /.#expected_coverage covering)))
                           (set.member? (the /.#actual_coverage covering) (symbol ..dummy_target))))))))
       (do random.monad
         [not_covering (/.covering .._ (/.property "" true))
          covering (/.covering .._ (in (/.coverage' [..dummy_target] true)))]
         (in (do async.monad
               [[not_covering _] not_covering
                [covering _] covering]
               (/.coverage' [/.coverage']
                 (and (and (not (set.empty? (the /.#expected_coverage not_covering)))
                           (not (set.member? (the /.#actual_coverage not_covering) (symbol ..dummy_target))))
                      (and (not (set.empty? (the /.#expected_coverage covering)))
                           (set.member? (the /.#actual_coverage covering) (symbol ..dummy_target))))))))
       (do random.monad
         [not_covering (/.covering .._ (/.property "" true))
          covering (/.covering .._ (/.for [..dummy_target] (/.property "" true)))]
         (in (do async.monad
               [[not_covering _] not_covering
                [covering _] covering]
               (/.coverage' [/.for]
                 (and (and (not (set.empty? (the /.#expected_coverage not_covering)))
                           (not (set.member? (the /.#actual_coverage not_covering) (symbol ..dummy_target))))
                      (and (not (set.empty? (the /.#expected_coverage covering)))
                           (set.member? (the /.#actual_coverage covering) (symbol ..dummy_target))))))))
       ))

(def .public test
  /.Test
  (<| (/.covering /._)
      (/.for [/.Test])
      (do [! random.monad]
        [expected_context (random.lower_case 5)
         expected_message/0 (random.only (|>> (text#= expected_context) not)
                                         (random.lower_case 5))
         expected_message/1 (random.only (|>> (text#= expected_message/0) not)
                                         (random.lower_case 5))]
        (all /.and
             (/.for [/.Assertion]
                    ..assertion)
             (/.for [/.Seed]
                    seed)
             (do !
               [success_assertion (/.property expected_message/0 true)
                failure_assertion (/.property expected_message/0 false)]
               (in (do async.monad
                     [[success_tally success_message] success_assertion
                      [failure_tally failure_message] failure_assertion]
                     (/.coverage' [/.property]
                       (and (text.ends_with? (%.text expected_message/0) success_message)
                            (text.ends_with? (%.text expected_message/0) failure_message)
                            (and (n.= 1 (the /.#successes success_tally))
                                 (n.= 0 (the /.#failures success_tally)))
                            (and (n.= 0 (the /.#successes failure_tally))
                                 (n.= 1 (the /.#failures failure_tally))))))))
             (do !
               [tt (/.and (/.property expected_message/0 true)
                          (/.property expected_message/1 true))
                ff (/.and (/.property expected_message/0 false)
                          (/.property expected_message/1 false))
                tf (/.and (/.property expected_message/0 true)
                          (/.property expected_message/1 false))
                ft (/.and (/.property expected_message/0 false)
                          (/.property expected_message/1 true))]
               (in (do async.monad
                     [tt tt
                      ff ff
                      tf tf
                      ft ft]
                     (/.coverage' [/.and]
                       (and (..verify expected_message/0 expected_message/1 2 0 tt)
                            (..verify expected_message/0 expected_message/1 0 2 ff)
                            (..verify expected_message/0 expected_message/1 1 1 tf)
                            (..verify expected_message/0 expected_message/1 1 1 ft))))))
             (do !
               [success_assertion (/.context expected_context (/.property expected_message/0 true))
                failure_assertion (/.context expected_context (/.property expected_message/0 false))]
               (in (do async.monad
                     [[success_tally success_message] success_assertion
                      [failure_tally failure_message] failure_assertion]
                     (/.coverage' [/.context]
                       (and (and (text.contains? expected_context success_message)
                                 (text.contains? expected_message/0 success_message))
                            (and (text.contains? expected_context failure_message)
                                 (text.contains? expected_message/0 failure_message))
                            (and (n.= 1 (the /.#successes success_tally))
                                 (n.= 0 (the /.#failures success_tally)))
                            (and (n.= 0 (the /.#successes failure_tally))
                                 (n.= 1 (the /.#failures failure_tally))))))))
             (do !
               [failure_assertion (/.failure expected_message/0)]
               (in (do async.monad
                     [[failure_tally failure_message] failure_assertion]
                     (/.coverage' [/.failure]
                       (and (text.contains? expected_message/0 failure_message)
                            (and (n.= 0 (the /.#successes failure_tally))
                                 (n.= 1 (the /.#failures failure_tally))))))))
             (do !
               [success_assertion (/.lifted expected_message/0 (in true))
                failure_assertion (/.lifted expected_message/0 (in false))]
               (in (do async.monad
                     [[success_tally success_message] success_assertion
                      [failure_tally failure_message] failure_assertion]
                     (/.coverage' [/.lifted]
                       (and (text.contains? expected_message/0 success_message)
                            (text.contains? expected_message/0 failure_message)
                            (and (n.= 1 (the /.#successes success_tally))
                                 (n.= 0 (the /.#failures success_tally)))
                            (and (n.= 0 (the /.#successes failure_tally))
                                 (n.= 1 (the /.#failures failure_tally))))))))
             ..times
             ..in_parallel
             ..coverage
             ))))
