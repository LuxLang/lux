(.require
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]
    ["[0]" order]]
   [control
    ["[0]" io (.only IO)]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" nat]
     ["f" frac]]]
   [world
    [time
     ["[0]" duration]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" /]])

(def .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [angle random.safe_frac

         times (of ! each (n.% 10) random.nat)

         .let [computation (is (IO Frac)
                               (io.io (|> angle
                                          f.cos f.acos
                                          f.sin f.asin
                                          f.tan f.atan
                                          f.exp f.log)))]])
      (all _.and
           (_.coverage [/.time]
             (io.run!
              (do io.monad
                [duration (/.time computation)]
                (in (duration.positive? duration)))))
           (<| (_.for [/.Benchmark
                       /.#times /.#minimum /.#maximum /.#average])
               (all _.and
                    (_.coverage [/.test]
                      (io.run!
                       (do io.monad
                         [it (/.test times computation)]
                         (in (and (n.= times (the /.#times it))
                                  (when times
                                    0 (and (duration.neutral? (the /.#minimum it))
                                           (duration.neutral? (the /.#maximum it))
                                           (duration.neutral? (the /.#average it)))
                                    _ (and (duration.positive? (the /.#minimum it))
                                           (duration.positive? (the /.#maximum it))
                                           (duration.positive? (the /.#average it))

                                           (order.<= duration.order
                                                     (the /.#maximum it)
                                                     (the /.#minimum it))
                                           (order.<= duration.order
                                                     (the /.#maximum it)
                                                     (the /.#average it))
                                           (order.>= duration.order
                                                     (the /.#minimum it)
                                                     (the /.#average it)))))))))
                    ))
           )))
