... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]]
   [data
    ["[0]" text (.only \n)
     ["%" \\injection]]
    [collection
     ["[0]" dictionary]]]
   [math
    ["[0]" random (.only Random) (.use "[1]#[0]" functor)]
    ["[0]" unit]
    [number
     ["n" natural]
     ["i" integer]
     ["d" decimal]
     ["[0]" fraction (.only)
      ["[1]T" \\test]]
     ["[0]" rational (.only)
      ["[1]T" \\test]]]]
   [macro
    ["[0]" template]]
   [meta
    ["[0]" code]
    ["[0]" provenance]
    ["[0]" name]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" /]])

(the name_part^
  (Random Text)
  (do [! random.monad]
    [size (|> random.natural (by ! each (|>> (n.% 20) (n.major 1))))]
    (random.lower_cased size)))

(the name^
  (Random Name)
  (random.and name_part^
              name_part^))

(the code^
  (Random Code)
  (let [numeric^ (is (Random Code)
                     (all random.either
                          (|> random.bit (random#each code.bit))
                          (|> random.natural (random#each code.natural))
                          (|> random.integer (random#each code.integer))
                          (|> random.revolution (random#each code.revolution))
                          (|> random.unit_decimal (random#each code.decimal))
                          ))
        textual^ (is (Random Code)
                     (all random.either
                          (do random.monad
                            [size (|> random.natural (random#each (n.% 20)))]
                            (|> (random.upper_cased size) (random#each code.text)))
                          (|> name^ (random#each code.name))
                          ))
        simple^ (is (Random Code)
                    (all random.either
                         numeric^
                         textual^
                         ))]
    (random.rec
     (function (_ code^)
       (let [multi^ (is (Random (List Code))
                        (do random.monad
                          [size (|> random.natural (random#each (n.% 3)))]
                          (random.list size code^)))
             composite^ (is (Random Code)
                            (all random.either
                                 (|> multi^ (random#each code.form))
                                 (|> multi^ (random#each code.tuple))
                                 ))]
         (all random.either
              simple^
              composite^
              ))))))

(the code
  Test
  (do [! random.monad]
    [sample code^
     expected_fraction fractionT.random
     expected_rational rationalT.random

     natural_numerator random.natural
     integer_numerator random.integer
     decimal_numerator random.safe_decimal]
    (`` (all _.and
             (_.test "Can parse Lux code."
               (when (let [source_code (code.as_text sample)]
                       (/.parse source_code "" (dictionary.empty text.hash)
                                [provenance.dummy 0 source_code]))
                 {.#Left error}
                 false

                 {.#Right [_ parsed]}
                 (by code.equivalence = parsed sample)))
             (do !
               [other code^]
               (_.test "Can parse multiple Lux code nodes."
                 (let [source_code (text (code.as_text sample) " " (code.as_text other))]
                   (when (/.parse source_code "" (dictionary.empty text.hash)
                                  [provenance.dummy 0 source_code])
                     {.#Left error}
                     false

                     {.#Right [remaining =sample]}
                     (when (/.parse source_code "" (dictionary.empty text.hash)
                                    remaining)
                       {.#Left error}
                       false

                       {.#Right [_ =other]}
                       (and (by code.equivalence = sample =sample)
                            (by code.equivalence = other =other)))))))
             (_.coverage [fraction.extension]
               (when (let [source_code (by fraction.text as expected_fraction)]
                       (/.parse source_code "" (dictionary.empty text.hash)
                                [provenance.dummy 0 source_code]))
                 {.#Left _}
                 false

                 {.#Right [_ actual]}
                 (by code.equivalence =
                     (` ((, (code.name [.prelude fraction.extension]))
                         (, (code.natural (its fraction.#numerator expected_fraction)))
                         (, (code.natural (its fraction.#denominator expected_fraction)))))
                     actual)))
             (_.coverage [rational.extension]
               (when (let [source_code (by rational.text as expected_rational)]
                       (/.parse source_code "" (dictionary.empty text.hash)
                                [provenance.dummy 0 source_code]))
                 {.#Left _}
                 false

                 {.#Right [_ actual]}
                 (by code.equivalence =
                     (` ((, (code.name [.prelude rational.extension]))
                         (, (code.integer (its rational.#numerator expected_rational)))
                         (, (code.natural (its rational.#denominator expected_rational)))))
                     actual)))
             (,, (template.with [,unit]
                   [(_.coverage [,unit]
                      (and (when (let [source_code (text (by n.base_10 as natural_numerator)
                                                         (its unit.#suffix ,unit))]
                                   (/.parse source_code "" (dictionary.empty text.hash)
                                            [provenance.dummy 0 source_code]))
                             {.#Left _}
                             false

                             {.#Right [_ actual]}
                             (by code.equivalence =
                                 (` ((, (code.name [.prelude fraction.extension]))
                                     (, (code.natural natural_numerator))
                                     (, (code.natural (its unit.#factor ,unit)))))
                                 actual))
                           (when (let [source_code (text (by i.base_10 as integer_numerator)
                                                         (its unit.#suffix ,unit))]
                                   (/.parse source_code "" (dictionary.empty text.hash)
                                            [provenance.dummy 0 source_code]))
                             {.#Left _}
                             false

                             {.#Right [_ actual]}
                             (by code.equivalence =
                                 (` ((, (code.name [.prelude rational.extension]))
                                     (, (code.integer integer_numerator))
                                     (, (code.natural (its unit.#factor ,unit)))))
                                 actual))
                           (when (let [source_code (text (by d.base_10 as decimal_numerator)
                                                         (its unit.#suffix ,unit))]
                                   (/.parse source_code "" (dictionary.empty text.hash)
                                            [provenance.dummy 0 source_code]))
                             {.#Left _}
                             false

                             {.#Right [_ actual]}
                             (let [expected (code.decimal (d./ (n.decimal (its unit.#factor ,unit))
                                                               decimal_numerator))]
                               (by code.equivalence = expected actual)))
                           ))]

                   [unit.degree]
                   [unit.gradian]
                   [unit.per_cent]
                   [unit.per_mille]
                   [unit.per_myriad]
                   ))
             (,, (template.with [,unit]
                   [(_.coverage [,unit]
                      (when (let [source_code (text (by d.base_10 as decimal_numerator)
                                                    (its unit.#suffix ,unit))]
                              (/.parse source_code "" (dictionary.empty text.hash)
                                       [provenance.dummy 0 source_code]))
                        {.#Left _}
                        false

                        {.#Right [_ actual]}
                        (let [expected (code.decimal (d.* (its unit.#factor ,unit)
                                                          decimal_numerator))]
                          (by code.equivalence = expected actual))))]

                   [unit.radian]
                   [unit.turn]
                   ))
             ))))

(the comment_text^
  (Random Text)
  (let [character_gen (|> random.natural (random.only (|>> (n.= (`` (character (,, (static \n))))) not)))]
    (do random.monad
      [size (|> random.natural (random#each (n.% 20)))]
      (random.text character_gen size))))

(the comment^
  (Random Text)
  (do random.monad
    [comment comment_text^]
    (in (text "... " comment \n))))

(the comments
  Test
  (do random.monad
    [sample code^
     comment comment^]
    (all _.and
         (_.test "Can handle comments."
           (when (let [source_code (text comment (code.as_text sample))]
                   (/.parse source_code "" (dictionary.empty text.hash)
                            [provenance.dummy 0 source_code]))
             {.#Left error}
             false

             {.#Right [_ parsed]}
             (by code.equivalence = parsed sample)))
         )))

(the .public test
  Test
  (<| (_.covering /._)
      (all _.and
           ..code
           ..comments
           )))
