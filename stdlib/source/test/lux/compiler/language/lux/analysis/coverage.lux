... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except Pattern)
   [abstract
    [monad (.only do)]
    ["[0]" equivalence
     ["[1]T" \\test]]]
   [control
    ["[0]" pipe]]
   [error
    ["[0]" try (.only Try) (.use "[1]#[0]" functor)]
    ["[0]" exception (.only Exception)]]
   [function
    ["[0]" predicate]]
   [data
    ["[0]" product]
    ["[0]" bit]
    ["[0]" text (.only)
     ["%" \\injection]]
    [collection
     ["[0]" set]
     ["[0]" dictionary]
     ["[0]" stack (.use "[1]#[0]" functor mix)]]]
   [math
    ["[0]" random (.only Random) (.use "[1]#[0]" monad)]
    [number
     ["n" natural (.use "[1]#[0]" interval)]
     ["i" integer]
     ["r" revolution]
     ["d" decimal]]]
   [macro
    ["^" pattern]
    ["[0]" template]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" / (.only)
   ["/[1]" //
    ["[1][0]" simple]
    ["[1][0]" complex]
    ["[1][0]" pattern (.only Pattern)]]]])

(the spread 16)

(the random_tag
  (Random Natural)
  (random#each (n.% ..spread) random.natural))

(the .public random
  (Random /.Coverage)
  (<| random.rec
      (function (_ again))
      (all random.or
           (random#in [])
           random.bit
           (random.set n.hash ..spread random.natural)
           (random.set i.hash ..spread random.integer)
           (random.set r.hash ..spread random.revolution)
           (random.set d.hash ..spread random.unit_decimal)
           (random.set text.hash ..spread (random.unicode 1))
           (all random.and
                (random.maybe (random#in ..spread))
                (do [! random.monad]
                  [whens ..random_tag
                   whens (random.set n.hash whens ..random_tag)]
                  (|> whens
                      set.stack
                      (stack.each' ! (function (_ when) (by ! each (|>> [when]) again)))
                      (by ! each (dictionary.of_stack n.hash))))
                )
           (random.and again again)
           (random.and again again)
           )))

(the (ranged min range)
  (-> Natural Natural (Random Natural))
  (random#each (|>> (n.% (++ range)) (n.+ min))
               random.natural))

(the random_pattern
  (Random [/.Coverage Pattern])
  (<| random.rec
      (function (_ again))
      (`` (all random.either
               (random#in [{/.#Exhaustive}
                           {//pattern.#Simple {//simple.#Unit}}])
               (do random.monad
                 [it random.bit]
                 (in [{/.#Bit it}
                      {//pattern.#Simple {//simple.#Bit it}}]))
               (,, (template.with [<random> <hash> <coverage> <pattern>]
                     [(do random.monad
                        [it <random>]
                        (in [{<coverage> (set.of_stack <hash> (stack it))}
                             {//pattern.#Simple {<pattern> it}}]))]

                     [random.natural n.hash /.#Natural //simple.#Natural]
                     [random.integer i.hash /.#Integer //simple.#Integer]
                     [random.revolution r.hash /.#Revolution //simple.#Revolution]
                     [random.unit_decimal d.hash /.#Decimal //simple.#Decimal]
                     [(random.unicode 1) text.hash /.#Text //simple.#Text]
                     ))
               
               (do [! random.monad]
                 [tag (by ! each ++ ..random_tag)
                  right? random.bit
                  .let [lefts (//complex.lefts right? tag)]
                  [sub_coverage sub_pattern] again]
                 (in [{/.#Variant (if right? {.#Some (++ tag)} {.#None})
                                  (dictionary.of_stack n.hash (stack [tag sub_coverage]))}
                      {//pattern.#Complex
                       {//complex.#Variant
                        [//complex.#lefts lefts
                         //complex.#right? right?
                         //complex.#value sub_pattern]}}]))
               
               (do [! random.monad]
                 [arity (..ranged 2 (n.- 2 ..spread))
                  it (random.stack arity again)]
                 (in [(when (|> it
                                (stack#each product.left)
                                stack.reversed
                                (stack.until (|>> /.exhaustive? not)))
                        {.#Empty}
                        {/.#Exhaustive}

                        {.#Top last prevs}
                        (stack#mix (function (_ left right)
                                     {/.#Seq left right})
                                   last
                                   prevs))
                      {//pattern.#Complex {//complex.#Tuple (stack#each product.right it)}}]))
               
               (do random.monad
                 [register random.natural]
                 (in [{/.#Exhaustive}
                      {//pattern.#Bind register}]))
               ))))

(the (failure? exception it)
  (for_any (_ a)
    (-> (Exception a) (Try /.Coverage)
        Bit))
  (when it
    {try.#Failure error}
    (exception.is? exception error)

    _
    false))

(the test|value
  Test
  (<| (let [(open "/#[0]") /.equivalence])
      (do [! random.monad]
        [left ..random
         right ..random]
        (all _.and
             (_.for [/.equivalence]
                    (equivalenceT.spec /.equivalence ..random))

             (_.coverage [/.exhaustive?]
               (bit.= (/#= {/.#Exhaustive} left)
                      (/.exhaustive? left)))
             (_.coverage [/.as_text]
               (bit.= (/#= left right)
                      (text.= (/.as_text left) (/.as_text right))))
             ))))

(the test|coverage
  Test
  (<| (let [(open "/#[0]") /.equivalence])
      (do [! random.monad]
        [[expected pattern] ..random_pattern]
        (all _.and
             (_.coverage [/.coverage]
               (|> pattern
                   /.coverage
                   (try#each (/#= expected))
                   (try.else false)))
             (_.coverage [/.invalid_tuple]
               (let [invalid? (..failure? /.invalid_tuple)]
                 (and (|> (stack)
                          {//complex.#Tuple}
                          {//pattern.#Complex}
                          /.coverage
                          invalid?)
                      (|> (stack pattern)
                          {//complex.#Tuple}
                          {//pattern.#Complex}
                          /.coverage
                          invalid?)
                      (|> (stack pattern pattern)
                          {//complex.#Tuple}
                          {//pattern.#Complex}
                          /.coverage
                          invalid?
                          not))))
             ))))

(the random_partial_pattern
  (Random [/.Coverage Pattern])
  (random.only (|>> product.left /.exhaustive? not)
               ..random_pattern))

(the test|variant
  Test
  (<| (let [(open "/#[0]") /.equivalence])
      (do [! random.monad]
        [[expected/0 pattern/0] ..random_partial_pattern
         [expected/1 pattern/1] (random.only (|>> product.left (/#= expected/0) not)
                                             ..random_partial_pattern)
         expected_maximum (by ! each (n.+ 2) ..random_tag)
         .let [random_tag (random#each (n.% expected_maximum) random.natural)]
         tag/0 random_tag
         tag/1 (random.only (|>> (n.= tag/0) not) random_tag)
         .let [whens (dictionary.of_stack n.hash (stack [tag/0 expected/0]
                                                        [tag/1 expected/1]))
               expected_minimum (++ (n.major tag/0 tag/1))]]
        (all _.and
             (_.coverage [/.minimum]
               (and (n.= expected_minimum (/.minimum [{.#None} whens]))
                    (n.= expected_maximum (/.minimum [{.#Some expected_maximum} whens]))))
             (_.coverage [/.maximum]
               (and (n.= n#maximum (/.maximum [{.#None} whens]))
                    (n.= expected_maximum (/.maximum [{.#Some expected_maximum} whens]))))
             ))))

(the random_value_pattern
  (Random [/.Coverage Pattern])
  (random.only (function (_ [coverage pattern])
                 (when coverage
                   (^.or {/.#Alt _} {/.#Seq _})
                   false

                   _
                   true))
               ..random_partial_pattern))

(the test|composite
  Test
  (<| (let [(open "/#[0]") /.equivalence])
      (do [! random.monad]
        [[expected/0 pattern/0] ..random_value_pattern
         [expected/1 pattern/1] (random.only (|>> product.left (/#= expected/0) not)
                                             ..random_value_pattern)
         [expected/2 pattern/2] (random.only (all predicate.and
                                                  (|>> product.left (/#= expected/0) not)
                                                  (|>> product.left (/#= expected/1) not)
                                                  (|>> product.left (pipe.when {/.#Variant _} false _ true)))
                                             ..random_value_pattern)

         bit random.bit
         natural random.natural
         integer random.integer
         revolution random.revolution
         decimal random.unit_decimal
         text (random.unicode 1)
         
         arity (by ! each (n.+ 2) ..random_tag)
         .let [random_tag (random#each (n.% arity) random.natural)]
         tag/0 random_tag
         tag/1 (random.only (|>> (n.= tag/0) not) random_tag)]
        (all _.and
             (_.coverage [/.composite]
               (let [composes_simples!
                     (`` (and (|> (/.composite {/.#Bit bit} {/.#Bit (not bit)})
                                  (try#each (/#= {/.#Exhaustive}))
                                  (try.else false))

                              (|> {/.#Bit bit}
                                  (/.composite {/.#Exhaustive})
                                  (try#each (/#= {/.#Exhaustive}))
                                  (try.else false))
                              
                              (,, (template.with [<tag> <hash> <value> <next>]
                                    [(|> (/.composite {<tag> (set.of_stack <hash> (stack <value>))}
                                                      {<tag> (set.of_stack <hash> (stack (|> <value> <next>)))})
                                         (try#each (/#= {<tag> (set.of_stack <hash> (stack <value> (|> <value> <next>)))}))
                                         (try.else false))
                                     
                                     (|> {<tag> (set.of_stack <hash> (stack <value>))}
                                         (/.composite {/.#Exhaustive})
                                         (try#each (/#= {/.#Exhaustive}))
                                         (try.else false))]

                                    [/.#Natural n.hash natural ++]
                                    [/.#Integer i.hash integer ++]
                                    [/.#Revolution r.hash revolution ++]
                                    [/.#Decimal d.hash decimal (d.+ decimal)]
                                    [/.#Text text.hash text (.text text)]
                                    ))
                              ))

                     composes_variants!
                     (let [composes_different_variants!
                           (let [composes? (is (-> (Maybe Natural) (Maybe Natural) (Maybe Natural) Bit)
                                               (function (_ left right both)
                                                 (|> (/.composite {/.#Variant left (dictionary.of_stack n.hash (stack [tag/0 expected/0]))}
                                                                  {/.#Variant right (dictionary.of_stack n.hash (stack [tag/1 expected/1]))})
                                                     (try#each (/#= {/.#Variant both (dictionary.of_stack n.hash (stack [tag/0 expected/0]
                                                                                                                        [tag/1 expected/1]))}))
                                                     (try.else false))))]
                             (and (composes? {.#None} {.#None} {.#None})
                                  (composes? {.#Some arity} {.#None} {.#Some arity})
                                  (composes? {.#None} {.#Some arity} {.#Some arity})
                                  (composes? {.#Some arity} {.#Some arity} {.#Some arity})))

                           composes_same_variants!
                           (let [composes? (is (-> (Maybe Natural) (Maybe Natural) (Maybe Natural) Bit)
                                               (function (_ left right both)
                                                 (|> (do try.monad
                                                       [variant (/.composite {/.#Variant left (dictionary.of_stack n.hash (stack [tag/0 expected/0]))}
                                                                             {/.#Variant right (dictionary.of_stack n.hash (stack [tag/0 expected/1]))})
                                                        expected (/.composite expected/0 expected/1)]
                                                       (in (/#= {/.#Variant both (dictionary.of_stack n.hash (stack [tag/0 expected]))}
                                                                variant)))
                                                     (try.else false))))]
                             (and (composes? {.#None} {.#None} {.#None})
                                  (composes? {.#Some arity} {.#None} {.#Some arity})
                                  (composes? {.#None} {.#Some arity} {.#Some arity})
                                  (composes? {.#Some arity} {.#Some arity} {.#Some arity})))]
                       (and composes_different_variants!
                            composes_same_variants!
                            (and (|> {/.#Variant {.#None} (dictionary.of_stack n.hash (stack [tag/0 expected/0]))}
                                     (/.composite {/.#Exhaustive})
                                     (try#each (/#= {/.#Exhaustive}))
                                     (try.else false))
                                 (|> {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/0 expected/0]))}
                                     (/.composite {/.#Exhaustive})
                                     (try#each (/#= {/.#Exhaustive}))
                                     (try.else false)))))

                     composes_sequences!
                     (and (|> (/.composite {/.#Seq expected/0 expected/1}
                                           {/.#Seq expected/1 expected/0})
                              (try#each (/#= {/.#Alt {/.#Seq expected/0 expected/1}
                                                     {/.#Seq expected/1 expected/0}}))
                              (try.else false))
                          (|> (do try.monad
                                [seq (/.composite {/.#Seq expected/0 expected/0}
                                                  {/.#Seq expected/0 expected/1})
                                 expected (/.composite expected/0 expected/1)]
                                (in (/#= (if (/.exhaustive? expected)
                                           expected/0
                                           {/.#Seq expected/0 expected})
                                         seq)))
                              (try.else false))
                          (|> (do try.monad
                                [seq (/.composite {/.#Seq expected/0 expected/0}
                                                  {/.#Seq expected/1 expected/0})
                                 expected (/.composite expected/0 expected/1)]
                                (in (/#= {/.#Seq expected expected/0}
                                         seq)))
                              (try.else false))
                          (|> (/.composite {/.#Seq expected/0 expected/1}
                                           expected/1)
                              (try#each (/#= {/.#Alt {/.#Seq expected/0 expected/1}
                                                     expected/1}))
                              (try.else false))
                          (|> (/.composite expected/1
                                           {/.#Seq expected/0 expected/1})
                              (try#each (/#= {/.#Alt expected/1
                                                     {/.#Seq expected/0 expected/1}}))
                              (try.else false))
                          (|> (/.composite expected/0
                                           {/.#Seq expected/0 expected/1})
                              (try#each (/#= expected/0))
                              (try.else false)))

                     composes_alts!
                     (and (|> (do try.monad
                                [alt (/.composite {/.#Exhaustive}
                                                  {/.#Alt expected/0
                                                          expected/1})]
                                (in (/#= {/.#Exhaustive}
                                         alt)))
                              (try.else false))
                          (|> (do try.monad
                                [alt (/.composite {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/0 {/.#Exhaustive}]))}
                                                  {/.#Alt {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/0 expected/0]))}
                                                          {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/0 expected/1]))}})]
                                (in (/#= {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/0 {/.#Exhaustive}]))}
                                         alt)))
                              (try.else false))
                          (|> (do try.monad
                                [alt (/.composite {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/0 {/.#Exhaustive}]))}
                                                  {/.#Alt {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/0 expected/0]))}
                                                          {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/1 expected/1]))}})]
                                (in (/#= {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/0 {/.#Exhaustive}]
                                                                                                       [tag/1 expected/1]))}
                                         alt)))
                              (try.else false))
                          (|> (do try.monad
                                [alt (/.composite {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/0 expected/2]))}
                                                  {/.#Alt {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/0 expected/0]))}
                                                          {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/1 expected/1]))}})
                                 expected (/.composite expected/2 expected/0)]
                                (in (/#= {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/0 expected]
                                                                                                       [tag/1 expected/1]))}
                                         alt)))
                              (try.else false))
                          (|> (do try.monad
                                [alt (/.composite {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/1 expected/2]))}
                                                  {/.#Alt {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/0 expected/0]))}
                                                          {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/1 expected/1]))}})
                                 expected (/.composite expected/2 expected/1)]
                                (in (/#= {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/0 expected/0]
                                                                                                       [tag/1 expected]))}
                                         alt)))
                              (try.else false))
                          (|> (do try.monad
                                [alt (/.composite {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/1 expected/1]))}
                                                  {/.#Alt {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/0 expected/0]))}
                                                          expected/2})]
                                (in (/#= {/.#Alt expected/2
                                                 {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/0 expected/0]
                                                                                                               [tag/1 expected/1]))}}
                                         alt)))
                              (try.else false)))]
                 (and composes_simples!
                      composes_variants!
                      composes_sequences!
                      composes_alts!)))
             (_.coverage [/.redundancy]
               (let [redundant? (..failure? /.redundancy)]
                 (`` (and (redundant? (/.composite {/.#Exhaustive} {/.#Exhaustive}))
                          (,, (template.with [<it>]
                                [(redundant? (/.composite <it> <it>))
                                 (redundant? (/.composite <it> {/.#Exhaustive}))]
                                
                                [{/.#Bit bit}]
                                [{/.#Natural (set.of_stack n.hash (stack natural))}]
                                [{/.#Integer (set.of_stack i.hash (stack integer))}]
                                [{/.#Revolution (set.of_stack r.hash (stack revolution))}]
                                [{/.#Decimal (set.of_stack d.hash (stack decimal))}]
                                [{/.#Text (set.of_stack text.hash (stack text))}]
                                [{/.#Variant {.#None} (dictionary.of_stack n.hash (stack [tag/0 expected/0]))}]
                                [{/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/0 expected/0]))}]
                                [{/.#Seq expected/0 expected/1}]))
                          (redundant? (/.composite {/.#Seq expected/0 expected/1} expected/0))))))
             (_.coverage [/.variant_mismatch]
               (let [mismatch? (..failure? /.variant_mismatch)]
                 (and (not (mismatch? (/.composite {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/0 expected/0]))}
                                                   {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/1 expected/1]))})))
                      
                      (mismatch? (/.composite {/.#Variant {.#Some (++ arity)} (dictionary.of_stack n.hash (stack [tag/0 expected/0]))}
                                              {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/1 expected/1]))}))
                      (mismatch? (/.composite {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/0 expected/0]))}
                                              {/.#Variant {.#Some (++ arity)} (dictionary.of_stack n.hash (stack [tag/1 expected/1]))}))
                      
                      (mismatch? (/.composite {/.#Variant {.#Some (-- arity)} (dictionary.of_stack n.hash (stack [tag/0 expected/0]))}
                                              {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/1 expected/1]))}))
                      (mismatch? (/.composite {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/0 expected/0]))}
                                              {/.#Variant {.#Some (-- arity)} (dictionary.of_stack n.hash (stack [tag/1 expected/1]))}))
                      
                      (not (mismatch? (/.composite {/.#Variant {.#None} (dictionary.of_stack n.hash (stack [tag/0 expected/0]))}
                                                   {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/1 expected/1]))})))
                      (mismatch? (/.composite {/.#Variant {.#None} (dictionary.of_stack n.hash (stack [arity expected/0]))}
                                              {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/1 expected/1]))}))
                      (not (mismatch? (/.composite {/.#Variant {.#None} (dictionary.of_stack n.hash (stack [(-- arity) expected/0]))}
                                                   {/.#Variant {.#Some arity} (dictionary.of_stack n.hash (stack [tag/1 expected/1]))}))))))
             ))))

(the .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Coverage])
      (all _.and
           ..test|value
           ..test|coverage
           (_.for [/.Variant]
                  ..test|variant)
           ..test|composite
           )))
