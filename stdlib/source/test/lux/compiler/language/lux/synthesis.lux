... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    ["<>" projection]
    ["[0]" monad]
    ["[0]" equivalence
     ["[1]T" \\test]]
    ["[0]" hash
     ["[1]T" \\test]]]
   [error
    ["[0]" try]
    ["[0]" exception]]
   [data
    ["[0]" maybe (.use "[1]:[0]" functor)]
    ["[0]" product]
    ["[0]" text]
    [collection
     ["[0]" list (.use "[1]:[0]" functor)
      ["?[1]" \\projection]]
     ["[0]" dictionary]]]
   [logic
    ["[0]" bit]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["[0]" /64 (.only)
      ["n" natural]
      ["[0]" decimal]]]]
   [macro
    ["^" pattern]
    ["[0]" template]
    ["[0]" expansion]]
   [meta
    ["[0]" static]
    ["[0]" name (.only)
     ["[1]T" \\test]]
    ["[0]" provenance (.only)
     ["[1]T" \\test]]]
   [compiler
    ["@[0]" type (.only Environment Variable)]
    [language
     [lux
      ["[0]" phase (.only)
       ["[0]" extension]]]]]
   [test
    ["_" property (.only Test)]]
   [type
    ["[0]" check]]
   [aspect
    ["[0]" view]]]]
 [\\library
  ["[0]" / (.only)
   ["[0]" path]
   ["[0]" access (.only)
    ["[0]" side]
    ["[0]" member]]]]
 ["[0]" \\projection]
 ["[0]" /
  ["[1][0]" simple]
  ["[1][0]" access]
  ["[1][0]" path]])

(the random_constant
  (Random Name)
  (random.and (random.lower_cased 1)
              (random.upper_cased 1)))

(the random_variable
  (Random Variable)
  (random.or random.natural
             random.natural))

(the random_environment
  (Random (Environment /.Term))
  (monad.let [! random.monad]
    [size (by ! each (n.% 5) random.natural)]
    (|> ..random_variable
        (by ! each (|>> (/.variable provenance.dummy)))
        (random.list size))))

(the \\projection
  Test
  (<| (_.covering \\projection._)
      (_.for [\\projection.Projection])
      (`` (all _.and
               (,, (template.with [<query> <check> <random> <synthesis> <equivalence>]
                     [(monad.let [! random.monad]
                        [expected <random>
                         dummy (|> <random> (random.only (|>> (by <equivalence> = expected) not)))]
                        (all _.and
                             (_.coverage [<query>]
                               (|> <query>
                                   (?list.value (list (<synthesis> provenance.dummy expected)))
                                   (match? (^.multi {try.:Success actual}
                                                    (by <equivalence> = expected actual)))))
                             (_.coverage [<check>]
                               (and (|> (<check> expected)
                                        (?list.value (list (<synthesis> provenance.dummy expected)))
                                        (match? {try.:Success _}))
                                    (|> (<check> expected)
                                        (?list.value (list (<synthesis> provenance.dummy dummy)))
                                        (match? {try.:Failure error}))))
                             ))]

                     [[\\projection.bit \\projection.this_bit random.bit /.bit bit.equivalence]
                      [\\projection.i64 \\projection.this_i64 random.i64 /.i64 /64.equivalence]
                      [\\projection.f64 \\projection.this_f64 random.unit_decimal /.f64 decimal.equivalence]
                      [\\projection.text \\projection.this_text (random.unicode 1) /.text text.equivalence]
                      [\\projection.local \\projection.this_local random.natural /.local n.equivalence]
                      [\\projection.foreign \\projection.this_foreign random.natural /.foreign n.equivalence]
                      [\\projection.constant \\projection.this_constant ..random_constant /.constant name.equivalence]]))

               (monad.let [! random.monad]
                 [expected_bit random.bit
                  expected_i64 random.i64
                  expected_f64 random.unit_decimal
                  expected_text (random.unicode 1)]
                 (_.coverage [\\projection.tuple]
                   (and (|> (?list.value (list (/.tuple provenance.dummy
                                                        (list (/.bit provenance.dummy expected_bit)
                                                              (/.i64 provenance.dummy expected_i64)
                                                              (/.f64 provenance.dummy expected_f64)
                                                              (/.text provenance.dummy expected_text))))
                                         (\\projection.tuple (all <>.and \\projection.bit \\projection.i64 \\projection.f64 \\projection.text)))
                            (match? (^.multi {try.:Success [actual_bit actual_i64 actual_f64 actual_text]}
                                             (and (by bit.equivalence = expected_bit actual_bit)
                                                  (by /64.equivalence = expected_i64 actual_i64)
                                                  (by decimal.equivalence = expected_f64 actual_f64)
                                                  (by text.equivalence = expected_text actual_text)))))
                        (|> (?list.value (list (/.text provenance.dummy expected_text))
                                         (\\projection.tuple (all <>.and \\projection.bit \\projection.i64 \\projection.f64 \\projection.text)))
                            (match? {try.:Failure error})))))
               (monad.let [! random.monad]
                 [arity random.natural
                  expected_environment ..random_environment
                  expected_body (random.unicode 1)]
                 (_.coverage [\\projection.function]
                   (and (|> (\\projection.function arity \\projection.text)
                            (?list.value (list (/.abstraction provenance.dummy
                                                              [expected_environment arity (/.text provenance.dummy expected_body)])))
                            (match? (^.multi {try.:Success [actual_environment actual_body]}
                                             (and (by (list.equivalence /.equivalence) =
                                                      expected_environment
                                                      actual_environment)
                                                  (by text.equivalence = expected_body actual_body)))))
                        (|> (\\projection.function arity \\projection.text)
                            (?list.value (list (/.text provenance.dummy expected_body)))
                            (match? {try.:Failure error})))))
               (monad.let [! random.monad]
                 [arity (by ! each (|>> (n.% 10) ++) random.natural)
                  expected_offset random.natural
                  expected_inits (random.list arity random.bit)
                  expected_body (random.unicode 1)]
                 (_.coverage [\\projection.loop]
                   (and (|> (\\projection.loop (<>.many \\projection.bit) \\projection.text)
                            (?list.value (list (/.tail_recursion provenance.dummy
                                                                 [expected_offset
                                                                  (list:each (|>> (/.bit provenance.dummy)) expected_inits)
                                                                  (/.text provenance.dummy expected_body)])))
                            (match? (^.multi {try.:Success [actual_offset actual_inits actual_body]}
                                             (and (by n.equivalence = expected_offset actual_offset)
                                                  (by (list.equivalence bit.equivalence) =
                                                      expected_inits
                                                      actual_inits)
                                                  (by text.equivalence = expected_body actual_body)))))
                        (|> (\\projection.loop (<>.many \\projection.bit) \\projection.text)
                            (?list.value (list (/.text provenance.dummy expected_body)))
                            (match? {try.:Failure error})))))
               ))))

(the simple
  Test
  (<| (monad.let [! random.monad]
        [expected_provenance provenanceT.random
         
         expected_bit random.bit
         expected_i64 random.i64
         expected_f64 random.safe_decimal
         expected_text (random.lower_cased 1)])
      (_.for [/.:Simple])
      (`` (all _.and
               (,, (template.with [,tag ,expected]
                     [(_.coverage [,tag]
                        (when (is /.Term (,tag expected_provenance ,expected))
                          (,tag actual_provenance actual)
                          (and (identical? expected_provenance actual_provenance)
                               (identical? ,expected actual))

                          else
                          false))]

                     [[/.bit expected_bit]
                      [/.i64 expected_i64]
                      [/.f64 expected_f64]
                      [/.text expected_text]]
                     ))))))

(the structure
  Test
  (<| (monad.let [! random.monad]
        [expected_provenance provenanceT.random
         
         expected_bit random.bit
         expected_i64 random.i64
         expected_f64 random.safe_decimal
         expected_text (random.lower_cased 1)])
      (_.for [/.:Structure])
      (all _.and
           (_.coverage [/.variant]
             (let [expected_choice (is /.Term (/.text expected_provenance expected_text))]
               (when (is /.Term (/.variant expected_provenance [(.natural expected_i64) expected_bit expected_choice]))
                 (/.variant actual_provenance [actual_lefts actual_right? actual_choice])
                 (and (identical? expected_provenance actual_provenance)
                      (identical? (.natural expected_i64) actual_lefts)
                      (identical? expected_bit actual_right?)
                      (identical? expected_choice actual_choice))

                 else
                 false)))
           (_.coverage [/.tuple]
             (let [expected_tuple (is (List /.Term)
                                      (list (/.bit expected_provenance expected_bit)
                                            (/.i64 expected_provenance expected_i64)
                                            (/.f64 expected_provenance expected_f64)
                                            (/.text expected_provenance expected_text)))]
               (when (is /.Term (/.tuple expected_provenance expected_tuple))
                 (/.tuple actual_provenance actual_tuple)
                 (and (identical? expected_provenance actual_provenance)
                      (identical? expected_tuple actual_tuple))

                 else
                 false))))))

(the reference
  Test
  (<| (monad.let [! random.monad]
        [expected_provenance provenanceT.random
         
         expected_register random.natural
         expected_variable (is (Random Variable)
                               (random.or random.natural
                                          random.natural))
         expected_constant (nameT.random 1 2)])
      (_.for [/.:Reference])
      (`` (all _.and
               (,, (template.with [,tag ,expected]
                     [(_.coverage [,tag]
                        (when (is /.Term (,tag expected_provenance ,expected))
                          (,tag actual_provenance actual)
                          (and (identical? expected_provenance actual_provenance)
                               (identical? ,expected actual))

                          else
                          false))]

                     [[/.local expected_register]
                      [/.foreign expected_register]
                      [/.variable expected_variable]
                      [/.constant expected_constant]]))))))

(the control/when
  Test
  (<| (monad.let [! random.monad]
        [expected_provenance provenanceT.random

         expected_bit random.bit
         expected_i64 random.i64
         expected_f64 random.safe_decimal
         expected_text (random.lower_cased 1)

         expected_register random.natural

         expected_access random.natural

         expected_member_0 member.random
         expected_member_1 member.random])
      (_.for [/.When
              /.:input /.:output
              
              /.:When
              /.when])
      (`` (all _.and
               (let [expected_when (is /.Term (/.bit expected_provenance expected_bit))
                     expected_then (is /.Term (/.text expected_provenance expected_text))
                     expected_else (is /.Term (/.f64 expected_provenance expected_f64))]
                 (all _.and
                      (<| (_.for [/.If
                                  /.:if_when /.:if_then /.:if_else])
                          (all _.and
                               (_.coverage [/.if]
                                 (and (when (/.if [/.:input expected_when
                                                   /.:output {path.:Bit_Fork .true {path.:Then expected_then} {.:Some {path.:Then expected_else}}}])
                                        {.:Some [/.:if_when actual_when
                                                 /.:if_then actual_then
                                                 /.:if_else actual_else]}
                                        (and (identical? expected_when actual_when)
                                             (identical? expected_then actual_then)
                                             (identical? expected_else actual_else))

                                        else
                                        false)
                                      (when (/.if [/.:input expected_when
                                                   /.:output {path.:Bit_Fork .false {path.:Then expected_else} {.:Some {path.:Then expected_then}}}])
                                        {.:Some [/.:if_when actual_when
                                                 /.:if_then actual_then
                                                 /.:if_else actual_else]}
                                        (and (identical? expected_when actual_when)
                                             (identical? expected_then actual_then)
                                             (identical? expected_else actual_else))

                                        else
                                        false)))
                               (_.coverage [/.variant_if]
                                 (<| (template.let [(complete ,right? ,binding ,body)
                                                    [(all {path.:And}
                                                          {path.:Access {access.:Side [side.:lefts 0
                                                                                       side.:right? ,right?]}}
                                                          {path.:Bind ,binding}
                                                          {path.:Then ,body})]

                                                    (partial ,right? ,body)
                                                    [(all {path.:And}
                                                          {path.:Access {access.:Side [side.:lefts 0
                                                                                       side.:right? ,right?]}}
                                                          {path.:Then ,body})]

                                                    (trust ,body)
                                                    [{path.:Then ,body}]])
                                     (expansion.let [,complete_then (complete .false expected_register expected_then)
                                                     ,complete_else (complete .true expected_register expected_else)

                                                     ,partial_then (partial .false expected_then)
                                                     ,partial_else (partial .true expected_else)])
                                     (and (when [(/.variant_if [/.:input expected_when
                                                                /.:output {path.:Or ,complete_then ,complete_else}])
                                                 (/.variant_if [/.:input expected_when
                                                                /.:output {path.:Or ,complete_else ,complete_then}])]
                                            [{.:Some [/.:if_when actual_when_0
                                                      /.:if_then [actual_@then_0 actual_then_0]
                                                      /.:if_else [actual_@else_0 actual_else_0]]}
                                             {.:Some [/.:if_when actual_when_1
                                                      /.:if_then [actual_@then_1 actual_then_1]
                                                      /.:if_else [actual_@else_1 actual_else_1]]}]
                                            (with (maybe.equivalence n.equivalence)
                                              (and (and (identical? expected_when actual_when_0)
                                                        (identical? expected_then actual_then_0)
                                                        (identical? expected_else actual_else_0)
                                                        (= {.:Some expected_register} actual_@then_0)
                                                        (= {.:Some expected_register} actual_@else_0))
                                                   (and (identical? actual_when_0 actual_when_1)
                                                        (identical? actual_then_0 actual_then_1)
                                                        (identical? actual_else_0 actual_else_1)
                                                        (= actual_@then_0 actual_@then_1)
                                                        (= actual_@else_0 actual_@else_1))))

                                            else
                                            false)
                                          (when [(/.variant_if [/.:input expected_when
                                                                /.:output {path.:Or ,partial_then ,complete_else}])
                                                 (/.variant_if [/.:input expected_when
                                                                /.:output {path.:Or ,complete_else ,partial_then}])
                                                 (/.variant_if [/.:input expected_when
                                                                /.:output {path.:Or ,complete_else (trust expected_then)}])]
                                            [{.:Some [/.:if_when actual_when_0
                                                      /.:if_then [actual_@then_0 actual_then_0]
                                                      /.:if_else [actual_@else_0 actual_else_0]]}
                                             {.:Some [/.:if_when actual_when_1
                                                      /.:if_then [actual_@then_1 actual_then_1]
                                                      /.:if_else [actual_@else_1 actual_else_1]]}
                                             {.:Some [/.:if_when actual_when_2
                                                      /.:if_then [actual_@then_2 actual_then_2]
                                                      /.:if_else [actual_@else_2 actual_else_2]]}]
                                            (with (maybe.equivalence n.equivalence)
                                              (and (and (identical? expected_when actual_when_0)
                                                        (identical? expected_then actual_then_0)
                                                        (identical? expected_else actual_else_0)
                                                        (= {.:None} actual_@then_0)
                                                        (= {.:Some expected_register} actual_@else_0))
                                                   (and (identical? actual_when_0 actual_when_1)
                                                        (identical? actual_then_0 actual_then_1)
                                                        (identical? actual_else_0 actual_else_1)
                                                        (= actual_@then_0 actual_@then_1)
                                                        (= actual_@else_0 actual_@else_1))
                                                   (and (identical? actual_when_0 actual_when_2)
                                                        (identical? actual_then_0 actual_then_2)
                                                        (identical? actual_else_0 actual_else_2)
                                                        (= actual_@then_0 actual_@then_2)
                                                        (= actual_@else_0 actual_@else_2))))

                                            else
                                            false)
                                          (when [(/.variant_if [/.:input expected_when
                                                                /.:output {path.:Or ,complete_then ,partial_else}])
                                                 (/.variant_if [/.:input expected_when
                                                                /.:output {path.:Or ,partial_else ,complete_then}])]
                                            [{.:Some [/.:if_when actual_when_0
                                                      /.:if_then [actual_@then_0 actual_then_0]
                                                      /.:if_else [actual_@else_0 actual_else_0]]}
                                             {.:Some [/.:if_when actual_when_1
                                                      /.:if_then [actual_@then_1 actual_then_1]
                                                      /.:if_else [actual_@else_1 actual_else_1]]}]
                                            (with (maybe.equivalence n.equivalence)
                                              (and (and (identical? expected_when actual_when_0)
                                                        (identical? expected_then actual_then_0)
                                                        (identical? expected_else actual_else_0)
                                                        (= {.:Some expected_register} actual_@then_0)
                                                        (= {.:None} actual_@else_0))
                                                   (and (identical? actual_when_0 actual_when_1)
                                                        (identical? actual_then_0 actual_then_1)
                                                        (identical? actual_else_0 actual_else_1)
                                                        (= actual_@then_0 actual_@then_1)
                                                        (= actual_@else_0 actual_@else_1))))

                                            else
                                            false)
                                          (when [(/.variant_if [/.:input expected_when
                                                                /.:output {path.:Or ,partial_then ,partial_else}])
                                                 (/.variant_if [/.:input expected_when
                                                                /.:output {path.:Or ,partial_else ,partial_then}])
                                                 (/.variant_if [/.:input expected_when
                                                                /.:output {path.:Or ,partial_else (trust expected_then)}])]
                                            [{.:Some [/.:if_when actual_when_0
                                                      /.:if_then [actual_@then_0 actual_then_0]
                                                      /.:if_else [actual_@else_0 actual_else_0]]}
                                             {.:Some [/.:if_when actual_when_1
                                                      /.:if_then [actual_@then_1 actual_then_1]
                                                      /.:if_else [actual_@else_1 actual_else_1]]}
                                             {.:Some [/.:if_when actual_when_2
                                                      /.:if_then [actual_@then_2 actual_then_2]
                                                      /.:if_else [actual_@else_2 actual_else_2]]}]
                                            (with (maybe.equivalence n.equivalence)
                                              (and (and (identical? expected_when actual_when_0)
                                                        (identical? expected_then actual_then_0)
                                                        (identical? expected_else actual_else_0)
                                                        (= {.:None} actual_@then_0)
                                                        (= {.:None} actual_@else_0))
                                                   (and (identical? actual_when_0 actual_when_1)
                                                        (identical? actual_then_0 actual_then_1)
                                                        (identical? actual_else_0 actual_else_1)
                                                        (= actual_@then_0 actual_@then_1)
                                                        (= actual_@else_0 actual_@else_1))
                                                   (and (identical? actual_when_0 actual_when_2)
                                                        (identical? actual_then_0 actual_then_2)
                                                        (identical? actual_else_0 actual_else_2)
                                                        (= actual_@then_0 actual_@then_2)
                                                        (= actual_@else_0 actual_@else_2))))

                                            else
                                            false)
                                          )))
                               ))
                      (_.coverage [/.or]
                        (when (/.or [/.:if_when expected_when
                                     /.:if_then (/.bit expected_provenance .true)
                                     /.:if_else expected_else])
                          {.:Some [left right]}
                          (and (identical? expected_else left)
                               (identical? expected_when right))

                          else
                          false))
                      (_.coverage [/.and]
                        (when (/.and [/.:if_when expected_when
                                      /.:if_else (/.bit expected_provenance .false)
                                      /.:if_then expected_else])
                          {.:Some [left right]}
                          (and (identical? expected_else left)
                               (identical? expected_when right))

                          else
                          false))))
               (let [expected_input (is /.Term (/.text expected_provenance expected_text))
                     expected_body (is /.Term (/.f64 expected_provenance expected_f64))]
                 (all _.and
                      (_.coverage [/.Let
                                   /.:let_binding /.:let_input /.:let_body

                                   /.let]
                        (when (/.let expected_provenance expected_register expected_input expected_body)
                          (/.let actual_provenance actual_register actual_input actual_body)
                          (and (identical? expected_provenance actual_provenance)
                               (identical? expected_register actual_register)
                               (identical? expected_input actual_input)
                               (identical? expected_body actual_body))

                          else
                          false))
                      (_.coverage [/.flat_let]
                        (let [expected_register' (++ expected_register)
                              expected_input' (is /.Term (/.text expected_provenance (text expected_text expected_text)))]
                          (when (<| /.flat_let
                                    (/.let expected_provenance expected_register expected_input)
                                    (/.let expected_provenance expected_register' expected_input')
                                    expected_body)
                            [(list [actual_register actual_input] [actual_register' actual_input']) actual_body]
                            (and (identical? expected_register actual_register)
                                 (identical? expected_input actual_input)
                                 (identical? expected_register' actual_register')
                                 (identical? expected_input' actual_input')
                                 (identical? expected_body actual_body))

                            else
                            false)))))
               (let [expected_before (is /.Term (/.text expected_provenance expected_text))
                     expected_after (is /.Term (/.f64 expected_provenance expected_f64))]
                 (all _.and
                      (_.coverage [/.Exec
                                   /.:exec_before /.:exec_after

                                   /.exec]
                        (when (/.exec expected_provenance expected_before expected_after)
                          (/.exec actual_provenance actual_before actual_after)
                          (and (identical? expected_provenance actual_provenance)
                               (identical? expected_before actual_before)
                               (identical? expected_after actual_after))

                          else
                          false))
                      (_.coverage [/.flat_exec]
                        (let [expected_before' (is /.Term (/.text expected_provenance (text expected_text expected_text)))]
                          (when (<| /.flat_exec
                                    (/.exec expected_provenance expected_before)
                                    (/.exec expected_provenance expected_before')
                                    expected_after)
                            [(list actual_before actual_before') actual_after]
                            (and (identical? expected_before actual_before)
                                 (identical? expected_before' actual_before')
                                 (identical? expected_after actual_after))

                            else
                            false)))))
               (_.coverage [/.Its
                            /.:its_path /.:its_source

                            /.its]
                 (let [expected_source (/.bit expected_provenance expected_bit)]
                   (and (|> (/.its [/.:input expected_source
                                    /.:output (all {path.:And}
                                                   {path.:Access {access.:Member expected_member_0}}
                                                   {path.:Bind expected_register}
                                                   {path.:Then (/.local expected_provenance (++ expected_register))})])
                            (match? {.:None}))
                        (|> (/.its [/.:input expected_source
                                    /.:output (all {path.:And}
                                                   {path.:Access {access.:Member expected_member_0}}
                                                   {path.:Bind expected_register}
                                                   {path.:Then (/.local expected_provenance expected_register)})])
                            (maybe:each (function (_ actual)
                                          (and (/.= expected_source
                                                    (its /.:its_source actual))
                                               (with (list.equivalence member.equivalence)
                                                 (= (list expected_member_0)
                                                    (its /.:its_path actual))))))
                            (maybe.else false))
                        (|> (/.its [/.:input expected_source
                                    /.:output (all {path.:And}
                                                   {path.:Access {access.:Member expected_member_1}}
                                                   {path.:Pop}
                                                   {path.:Access {access.:Member expected_member_0}}
                                                   {path.:Bind expected_register}
                                                   {path.:Then (/.local expected_provenance expected_register)})])
                            (maybe:each (function (_ actual)
                                          (and (/.= expected_source
                                                    (its /.:its_source actual))
                                               (with (list.equivalence member.equivalence)
                                                 (= (list expected_member_0)
                                                    (its /.:its_path actual))))))
                            (maybe.else false))
                        (|> (/.its [/.:input expected_source
                                    /.:output (all {path.:And}
                                                   {path.:Access {access.:Member expected_member_1}}
                                                   {path.:Access {access.:Member expected_member_0}}
                                                   {path.:Bind expected_register}
                                                   {path.:Then (/.local expected_provenance expected_register)})])
                            (maybe:each (function (_ actual)
                                          (and (/.= expected_source
                                                    (its /.:its_source actual))
                                               (with (list.equivalence member.equivalence)
                                                 (= (list expected_member_1 expected_member_0)
                                                    (its /.:its_path actual))))))
                            (maybe.else false)))))
               (_.coverage [/.Multi_Let
                            /.multi_let]
                 (let [expected_source (/.bit expected_provenance expected_bit)
                       expected_output (/.text expected_provenance expected_text)]
                   (and (|> (/.multi_let [/.:input expected_source
                                          /.:output (all {path.:And}
                                                         {path.:Access {access.:Member expected_member_0}}
                                                         {path.:Bind expected_register}
                                                         {path.:Then expected_output})])
                            (maybe:each (function (_ [actual_source
                                                      actual_projections
                                                      actual_output])
                                          (and (/.= expected_source
                                                    actual_source)
                                               (/.= expected_output
                                                    actual_output)
                                               (with (list.equivalence (product.equivalence n.equivalence member.equivalence))
                                                 (= (list [expected_register expected_member_0])
                                                    actual_projections)))))
                            (maybe.else false))
                        (|> (/.multi_let [/.:input expected_source
                                          /.:output (all {path.:And}
                                                         {path.:Access {access.:Member expected_member_0}}
                                                         {path.:Bind expected_register}
                                                         {path.:Pop}
                                                         {path.:Access {access.:Member expected_member_1}}
                                                         {path.:Bind (++ expected_register)}
                                                         {path.:Then expected_output})])
                            (maybe:each (function (_ [actual_source
                                                      actual_projections
                                                      actual_output])
                                          (and (/.= expected_source
                                                    actual_source)
                                               (/.= expected_output
                                                    actual_output)
                                               (with (list.equivalence (product.equivalence n.equivalence member.equivalence))
                                                 (= (list [expected_register expected_member_0]
                                                          [(++ expected_register) expected_member_1])
                                                    actual_projections)))))
                            (maybe.else false)))))
               (,, (template.with [,when ,fork ,equivalence ,then_0 ,then_1]
                     [(_.coverage [,when]
                        (let [expected_source (/.bit expected_provenance expected_bit)
                              expected_output_0 (/.text expected_provenance expected_text)
                              expected_output_1 (/.f64 expected_provenance expected_f64)
                              expected_output_2 (/.i64 expected_provenance expected_i64)]
                          (|> (,when [/.:input expected_source
                                      /.:output {path.:Or {,fork [[,then_0 {path.:Then expected_output_0}]
                                                                  (list [,then_1 {path.:Then expected_output_1}])]}
                                                          {path.:Then expected_output_2}}])
                              (maybe:each (function (_ [actual_source
                                                        actual_thens
                                                        actual_else])
                                            (and (/.= expected_source
                                                      actual_source)
                                                 (with (list.equivalence (product.equivalence ,equivalence /.equivalence))
                                                   (= (list [,then_0 expected_output_0]
                                                            [,then_1 expected_output_1])
                                                      actual_thens))
                                                 (/.= expected_output_2
                                                      actual_else))))
                              (maybe.else false))))]

                     [[/.when_i64 path.:I64_Fork /64.equivalence expected_i64 (++ expected_i64)]
                      [/.when_f64 path.:F64_Fork decimal.equivalence expected_f64 (decimal.+ expected_f64 expected_f64)]
                      [/.when_text path.:Text_Fork text.equivalence expected_text (text expected_text expected_text)]]))
               ))))

(the control
  Test
  (<| (monad.let [! random.monad]
        [expected_provenance provenanceT.random
         
         expected_bit random.bit
         expected_i64 random.i64
         expected_f64 random.safe_decimal
         expected_text (random.lower_cased 1)

         expected_register random.natural
         expected_variable (is (Random Variable)
                               (random.or random.natural
                                          random.natural))
         expected_constant (nameT.random 1 2)
         expected_arity random.natural])
      (_.for [/.Control /.:Control])
      (`` (all _.and
               ..control/when
               (<| (_.for [/.Loop /.:Loop])
                   (let [expected_environment (is (List /.Term)
                                                  (list (/.bit expected_provenance expected_bit)
                                                        (/.i64 expected_provenance expected_i64)
                                                        (/.f64 expected_provenance expected_f64)
                                                        (/.text expected_provenance expected_text)))
                         expected_term (is /.Term (/.text expected_provenance expected_text))])
                   (all _.and
                        (_.coverage [/.Tail_Recursion
                                     /.:start /.:inits /.:iteration
                                     
                                     /.:Tail_Recursion
                                     /.tail_recursion]
                          (when (is /.Term (/.tail_recursion expected_provenance
                                                             [/.:start expected_register
                                                              /.:inits expected_environment
                                                              /.:iteration expected_term]))
                            (/.tail_recursion actual_provenance
                                              [/.:start actual_register
                                               /.:inits actual_environment
                                               /.:iteration actual_term])
                            (and (identical? expected_provenance actual_provenance)
                                 (identical? expected_register actual_register)
                                 (identical? expected_environment actual_environment)
                                 (identical? expected_term actual_term))

                            else
                            false))
                        (_.coverage [/.:Tail_Iteration
                                     /.tail_iteration]
                          (when (is /.Term (/.tail_iteration expected_provenance expected_environment))
                            (/.tail_iteration actual_provenance actual_environment)
                            (and (identical? expected_provenance actual_provenance)
                                 (identical? expected_environment actual_environment))

                            else
                            false))))
               (<| (_.for [/.Function /.:Function])
                   (let [expected_environment (is (List /.Term)
                                                  (list (/.bit expected_provenance expected_bit)
                                                        (/.i64 expected_provenance expected_i64)
                                                        (/.f64 expected_provenance expected_f64)
                                                        (/.text expected_provenance expected_text)))
                         expected_term (is /.Term (/.text expected_provenance expected_text))])
                   (all _.and
                        (_.coverage [/.Abstraction /.Abstraction'
                                     /.:environment /.:arity /.:body
                                     
                                     /.:Abstraction
                                     /.abstraction]
                          (when (is /.Term (/.abstraction expected_provenance [/.:environment expected_environment
                                                                               /.:arity expected_arity
                                                                               /.:body expected_term]))
                            (/.abstraction actual_provenance [/.:environment actual_environment
                                                              /.:arity actual_arity
                                                              /.:body actual_term])
                            (and (identical? expected_provenance actual_provenance)
                                 (identical? expected_environment actual_environment)
                                 (identical? expected_arity actual_arity)
                                 (identical? expected_term actual_term))

                            else
                            false))
                        (_.coverage [/.Reification /.Reification'
                                     /.:function /.:arguments
                                     
                                     /.:Reification
                                     /.reification]
                          (when (is /.Term (/.reification expected_provenance [/.:function expected_term
                                                                               /.:arguments expected_environment]))
                            (/.reification actual_provenance [/.:function actual_term
                                                              /.:arguments actual_environment])
                            (and (identical? expected_provenance actual_provenance)
                                 (identical? expected_term actual_term)
                                 (identical? expected_environment actual_environment))

                            else
                            false))))
               ))))

(the test_of_state
  Test
  (<| (monad.let [! random.monad]
        [expected_locals random.natural
         expected_currying? random.bit])
      (_.for [/.State
              /.:locals /.:currying?])
      (all _.and
           (_.coverage [/.init]
             (and (n.= 0 (its /.:locals /.init))
                  (bit.= false (its /.:currying? /.init))))
           (_.coverage [/.with_currying? /.currying?]
             (with (try.equivalence bit.equivalence)
               (|> (/.with_currying? expected_currying?
                     /.currying?)
                   (phase.value /.init)
                   (= {try.:Success expected_currying?}))))
           (_.coverage [/.with_locals /.locals]
             (with (try.equivalence n.equivalence)
               (|> (/.with_locals expected_locals
                     /.locals)
                   (phase.value /.init)
                   (= {try.:Success expected_locals}))))
           (_.coverage [/.with_new_local]
             (with (try.equivalence n.equivalence)
               (|> (/.with_locals expected_locals
                     (/.with_new_local
                       /.locals))
                   (phase.value /.init)
                   (= {try.:Success (++ expected_locals)}))))
           )))

(the .public test
  Test
  (<| (_.covering /._)
      (monad.let [! random.monad]
        [left /.random
         right /.random])
      (_.for [/.Term /.Term'
              /.random])
      (`` (all _.and
               ..\\projection

               (_.for [/.equivalence /.=]
                      (static.when (identical? /.equivalence /.=)
                        (equivalenceT.spec /.equivalence /.random)))
               (_.for [/.hash]
                      (hashT.spec /.hash /.random))

               (_.coverage [/.as_text]
                 (bit.= (text.= (/.as_text left) (/.as_text right))
                        (by /.equivalence = left right)))
               
               ..simple
               ..structure
               ..reference
               ..control
               
               ..test_of_state
               
               (,, (template.with [,synthesis ,phase]
                     [(_.coverage [,synthesis]
                        (check.< ,synthesis ,phase))]

                     [[/.Operation phase.Operation]
                      [/.Phase phase.Phase]]))
               (<| (_.for [/.:Extension])
                   (all _.and
                        (,, (template.with [,synthesis ,phase]
                              [(_.coverage [,synthesis]
                                 (check.< ,synthesis ,phase))]

                              [[/.Handler extension.Handler]
                               [/.Bundle extension.Bundle]
                               [/.Extender extension.Extender]]))
                        ))
               (_.coverage [/.unit]
                 (identical? text.empty /.unit))
               (<| (_.for [/.Resolver])
                   (_.coverage [/.fresh_resolver]
                     (dictionary.empty? /.fresh_resolver)))

               /simple.test
               /access.test
               /path.test
               ))))
