... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    ["<>" projection]
    ["[0]" monad]]
   [error
    ["[0]" try]
    ["[0]" exception]]
   [data
    ["[0]" text]
    [collection
     ["[0]" list (.use "[1]:[0]" functor)]
     ["[0]" stack (.use "[1]:[0]" functor)]
     ["[0]" dictionary]]]
   [logic
    ["[0]" bit]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["[0]" /64 (.only)
      ["n" natural]
      ["[0]" decimal]]]]
   [macro
    ["^" pattern]
    ["[0]" template]]
   [meta
    ["[0]" name (.only)
     ["[1]T" \\test]]
    ["[0]" provenance
     ["[1]T" \\test]]]
   [compiler
    ["@[0]" type (.only Environment Variable)]
    [language
     [lux
      ["[0]" phase (.only)
       ["[0]" extension]]]]]
   [test
    ["_" property (.only Test)]]
   [type
    ["[0]" check]]
   [aspect
    ["[0]" view]]]]
 [\\library
  ["[0]" /]]
 ["[0]" \\projection]
 ["[0]" /
  ["[1][0]" simple]
  ["[1][0]" access]])

... (the !expect
...   (template.macro (_ <pattern> <value>)
...     [(when <value>
...        <pattern>
...        true

...        _
...        false)]))

... (the random_constant
...   (Random Name)
...   (random.and (random.unicode 1)
...               (random.unicode 1)))

... (the random_variable
...   (Random Variable)
...   (random.or random.natural
...              random.natural))

... (the random_environment
...   (Random (Environment /.Term))
...   (monad.let [! random.monad]
...     [size (by ! each (n.% 5) random.natural)]
...     (|> ..random_variable
...         (by ! each (|>> /.variable))
...         (random.stack size)
...         (by ! each (view.of list.stack)))))

... (the simple
...   Test
...   (`` (all _.and
...            (,, (template.with [<query> <check> <random> <synthesis> <equivalence>]
...                  [(monad.let [! random.monad]
...                     [expected <random>
...                      dummy (|> <random> (random.only (|>> (by <equivalence> = expected) not)))]
...                     (all _.and
...                          (_.coverage [<query>]
...                            (|> (\\projection.value <query> (stack (<synthesis> expected)))
...                                (!expect (^.multi {try.#Success actual}
...                                                  (by <equivalence> = expected actual)))))
...                          (_.coverage [<check>]
...                            (and (|> (\\projection.value (<check> expected) (stack (<synthesis> expected)))
...                                     (!expect {try.#Success _}))
...                                 (|> (\\projection.value (<check> expected) (stack (<synthesis> dummy)))
...                                     (!expect (^.multi {try.#Failure error}
...                                                       (exception.is? \\projection.cannot_parse error))))))
...                          ))]

...                  [[\\projection.bit \\projection.this_bit random.bit /.bit bit.equivalence]
...                   [\\projection.i64 \\projection.this_i64 random.i64 /.i64 /64.equivalence]
...                   [\\projection.f64 \\projection.this_f64 random.unit_decimal /.f64 decimal.equivalence]
...                   [\\projection.text \\projection.this_text (random.unicode 1) /.text text.equivalence]
...                   [\\projection.local \\projection.this_local random.natural /.local n.equivalence]
...                   [\\projection.foreign \\projection.this_foreign random.natural /.foreign n.equivalence]
...                   [\\projection.constant \\projection.this_constant ..random_constant /.constant name.equivalence]]))
...            )))

... (the complex
...   Test
...   (all _.and
...        (monad.let [! random.monad]
...          [expected_bit random.bit
...           expected_i64 random.i64
...           expected_f64 random.unit_decimal
...           expected_text (random.unicode 1)]
...          (_.coverage [\\projection.tuple]
...            (and (|> (\\projection.value (\\projection.tuple (all <>.and \\projection.bit \\projection.i64 \\projection.f64 \\projection.text))
...                                         (stack (/.tuple (stack (/.bit expected_bit)
...                                                                (/.i64 expected_i64)
...                                                                (/.f64 expected_f64)
...                                                                (/.text expected_text)))))
...                     (!expect (^.multi {try.#Success [actual_bit actual_i64 actual_f64 actual_text]}
...                                       (and (by bit.equivalence = expected_bit actual_bit)
...                                            (by /64.equivalence = expected_i64 actual_i64)
...                                            (by decimal.equivalence = expected_f64 actual_f64)
...                                            (by text.equivalence = expected_text actual_text)))))
...                 (|> (\\projection.value (\\projection.tuple (all <>.and \\projection.bit \\projection.i64 \\projection.f64 \\projection.text))
...                                         (stack (/.text expected_text)))
...                     (!expect (^.multi {try.#Failure error}
...                                       (exception.is? \\projection.cannot_parse error)))))))
...        (monad.let [! random.monad]
...          [arity random.natural
...           expected_environment ..random_environment
...           expected_body (random.unicode 1)]
...          (_.coverage [\\projection.function]
...            (and (|> (\\projection.value (\\projection.function arity \\projection.text)
...                                         (stack (/.abstraction [expected_environment arity (/.text expected_body)])))
...                     (!expect (^.multi {try.#Success [actual_environment actual_body]}
...                                       (and (by (stack.equivalence /.equivalence) =
...                                                expected_environment
...                                                actual_environment)
...                                            (by text.equivalence = expected_body actual_body)))))
...                 (|> (\\projection.value (\\projection.function arity \\projection.text)
...                                         (stack (/.text expected_body)))
...                     (!expect (^.multi {try.#Failure error}
...                                       (exception.is? \\projection.cannot_parse error)))))))
...        (monad.let [! random.monad]
...          [arity random.natural
...           expected_environment ..random_environment
...           expected_body (random.unicode 1)]
...          (_.coverage [\\projection.wrong_arity]
...            (|> (\\projection.value (\\projection.function (++ arity) \\projection.text)
...                                    (stack (/.abstraction [expected_environment arity (/.text expected_body)])))
...                (!expect (^.multi {try.#Failure error}
...                                  (exception.is? \\projection.wrong_arity error))))))
...        (monad.let [! random.monad]
...          [arity (by ! each (|>> (n.% 10) ++) random.natural)
...           expected_offset random.natural
...           expected_inits (random.stack arity random.bit)
...           expected_body (random.unicode 1)]
...          (_.coverage [\\projection.loop]
...            (and (|> (\\projection.value (\\projection.loop (<>.many \\projection.bit) \\projection.text)
...                                         (stack (/.scope [expected_offset
...                                                          (stack:each (|>> /.bit) expected_inits)
...                                                          (/.text expected_body)])))
...                     (!expect (^.multi {try.#Success [actual_offset actual_inits actual_body]}
...                                       (and (by n.equivalence = expected_offset actual_offset)
...                                            (by (stack.equivalence bit.equivalence) =
...                                                expected_inits
...                                                actual_inits)
...                                            (by text.equivalence = expected_body actual_body)))))
...                 (|> (\\projection.value (\\projection.loop (<>.many \\projection.bit) \\projection.text)
...                                         (stack (/.text expected_body)))
...                     (!expect (^.multi {try.#Failure error}
...                                       (exception.is? \\projection.cannot_parse error)))))))
...        ))

... (the \\projection
...   Test
...   (<| (_.covering \\projection._)
...       (_.for [\\projection.Projection])
...       (all _.and
...            (monad.let [! random.monad]
...              [expected (by ! each (|>> /.i64) random.i64)]
...              (_.coverage [\\projection.value \\projection.any]
...                (|> (\\projection.value \\projection.any (stack expected))
...                    (!expect (^.multi {try.#Success actual}
...                                      (by /.equivalence = expected actual))))))
...            (_.coverage [\\projection.empty_input]
...              (|> (\\projection.value \\projection.any (stack))
...                  (!expect (^.multi {try.#Failure error}
...                                    (exception.is? \\projection.empty_input error)))))
...            (monad.let [! random.monad]
...              [expected (by ! each (|>> /.i64) random.i64)]
...              (_.coverage [\\projection.unconsumed_input]
...                (|> (\\projection.value \\projection.any (stack expected expected))
...                    (!expect (^.multi {try.#Failure error}
...                                      (exception.is? \\projection.unconsumed_input error))))))
...            (_.for [\\projection.cannot_parse]
...                   (all _.and
...                        ..simple
...                        ..complex
...                        ))
...            )))

(the simple
  Test
  (<| (monad.let [! random.monad]
        [expected_provenance provenanceT.random
         
         expected_bit random.bit
         expected_i64 random.i64
         expected_f64 random.safe_decimal
         expected_text (random.lower_cased 1)])
      (_.for [/.#Simple])
      (`` (all _.and
               (,, (template.with [,tag ,expected]
                     [(_.coverage [,tag]
                        (when (is /.Term (,tag expected_provenance ,expected))
                          (,tag actual_provenance actual)
                          (and (identical? expected_provenance actual_provenance)
                               (identical? ,expected actual))

                          else
                          false))]

                     [[/.bit expected_bit]
                      [/.i64 expected_i64]
                      [/.f64 expected_f64]
                      [/.text expected_text]]
                     ))))))

(the structure
  Test
  (<| (monad.let [! random.monad]
        [expected_provenance provenanceT.random
         
         expected_bit random.bit
         expected_i64 random.i64
         expected_f64 random.safe_decimal
         expected_text (random.lower_cased 1)])
      (_.for [/.#Structure])
      (all _.and
           (_.coverage [/.variant]
             (let [expected_choice (is /.Term (/.text expected_provenance expected_text))]
               (when (is /.Term (/.variant expected_provenance [(.natural expected_i64) expected_bit expected_choice]))
                 (/.variant actual_provenance [actual_lefts actual_right? actual_choice])
                 (and (identical? expected_provenance actual_provenance)
                      (identical? (.natural expected_i64) actual_lefts)
                      (identical? expected_bit actual_right?)
                      (identical? expected_choice actual_choice))

                 else
                 false)))
           (_.coverage [/.tuple]
             (let [expected_tuple (is (List /.Term)
                                      (list (/.bit expected_provenance expected_bit)
                                            (/.i64 expected_provenance expected_i64)
                                            (/.f64 expected_provenance expected_f64)
                                            (/.text expected_provenance expected_text)))]
               (when (is /.Term (/.tuple expected_provenance expected_tuple))
                 (/.tuple actual_provenance actual_tuple)
                 (and (identical? expected_provenance actual_provenance)
                      (identical? expected_tuple actual_tuple))

                 else
                 false))))))

(the reference
  Test
  (<| (monad.let [! random.monad]
        [expected_provenance provenanceT.random
         
         expected_register random.natural
         expected_variable (is (Random Variable)
                               (random.or random.natural
                                          random.natural))
         expected_constant (nameT.random 1 2)])
      (_.for [/.#Reference])
      (`` (all _.and
               (,, (template.with [,tag ,expected]
                     [(_.coverage [,tag]
                        (when (is /.Term (,tag expected_provenance ,expected))
                          (,tag actual_provenance actual)
                          (and (identical? expected_provenance actual_provenance)
                               (identical? ,expected actual))

                          else
                          false))]

                     [[/.local expected_register]
                      [/.foreign expected_register]
                      [/.variable expected_variable]
                      [/.constant expected_constant]]))))))

(the control/when/path
  Test
  (<| (monad.let [! random.monad]
        [expected_provenance provenanceT.random

         expected_right? random.bit
         expected_access random.natural
         expected_text (random.lower_cased 1)])
      (`` (<| (_.for [/.Path /.Path'])
              (all _.and
                   (,, (template.with [,path]
                         [(_.coverage [,path]
                            (when (is /.Path (,path expected_access expected_right?))
                              (,path actual_access actual_right?)
                              (and (identical? expected_access actual_access)
                                   (identical? expected_right? actual_right?))

                              else
                              false))]

                         [[/.side]
                          [/.member]]))
                   (,, (template.with [,path]
                         [(_.coverage [,path]
                            (when (is /.Path (,path expected_access))
                              (,path actual_access)
                              (identical? expected_access actual_access)

                              else
                              false))]

                         [[/.left_side]
                          [/.right_side]

                          [/.left_member]
                          [/.right_member]]))
                   (,, (template.with [,path]
                         [(let [expected_next (is /.Path {/.#Then (/.text expected_provenance expected_text)})]
                            (_.coverage [,path]
                              (when (is /.Path (,path expected_access expected_next))
                                (,path actual_access actual_next)
                                (and (identical? expected_access actual_access)
                                     (identical? expected_next actual_next))

                                else
                                false)))]

                         [[/.simple_left_side]
                          [/.simple_right_side]]))
                   )))))

(the control/when
  Test
  (<| (monad.let [! random.monad]
        [expected_provenance provenanceT.random

         expected_bit random.bit
         expected_f64 random.safe_decimal
         expected_text (random.lower_cased 1)

         expected_register random.natural

         expected_access random.natural])
      (`` (all _.and
               ..control/when/path
               (let [expected_when (is /.Term (/.bit expected_provenance expected_bit))
                     expected_then (is /.Term (/.text expected_provenance expected_text))
                     expected_else (is /.Term (/.f64 expected_provenance expected_f64))]
                 (all _.and
                      (_.coverage [/.If
                                   /.#if_when /.#if_then /.#if_else

                                   /.if]
                        (and (when (/.if [/.#input expected_when
                                          /.#output {/.#Bit_Fork .true {/.#Then expected_then} {.#Some {/.#Then expected_else}}}])
                               {.#Some [/.#if_when actual_when
                                        /.#if_then actual_then
                                        /.#if_else actual_else]}
                               (and (identical? expected_when actual_when)
                                    (identical? expected_then actual_then)
                                    (identical? expected_else actual_else))

                               else
                               false)
                             (when (/.if [/.#input expected_when
                                          /.#output {/.#Bit_Fork .false {/.#Then expected_else} {.#Some {/.#Then expected_then}}}])
                               {.#Some [/.#if_when actual_when
                                        /.#if_then actual_then
                                        /.#if_else actual_else]}
                               (and (identical? expected_when actual_when)
                                    (identical? expected_then actual_then)
                                    (identical? expected_else actual_else))

                               else
                               false)))
                      (_.coverage [/.or]
                        (when (/.or [/.#if_when expected_when
                                     /.#if_then (/.bit expected_provenance .true)
                                     /.#if_else expected_else])
                          {.#Some [left right]}
                          (and (identical? expected_else left)
                               (identical? expected_when right))

                          else
                          false))
                      (_.coverage [/.and]
                        (when (/.and [/.#if_when expected_when
                                      /.#if_else (/.bit expected_provenance .false)
                                      /.#if_then expected_else])
                          {.#Some [left right]}
                          (and (identical? expected_else left)
                               (identical? expected_when right))

                          else
                          false))))
               (let [expected_input (is /.Term (/.text expected_provenance expected_text))
                     expected_body (is /.Term (/.f64 expected_provenance expected_f64))]
                 (all _.and
                      (_.coverage [/.Let
                                   /.#let_binding /.#let_input /.#let_body

                                   /.let]
                        (when (/.let expected_provenance expected_register expected_input expected_body)
                          (/.let actual_provenance actual_register actual_input actual_body)
                          (and (identical? expected_provenance actual_provenance)
                               (identical? expected_register actual_register)
                               (identical? expected_input actual_input)
                               (identical? expected_body actual_body))

                          else
                          false))
                      (_.coverage [/.flat_let]
                        (let [expected_register' (++ expected_register)
                              expected_input' (is /.Term (/.text expected_provenance (text expected_text expected_text)))]
                          (when (<| /.flat_let
                                    (/.let expected_provenance expected_register expected_input)
                                    (/.let expected_provenance expected_register' expected_input')
                                    expected_body)
                            [(list [actual_register actual_input] [actual_register' actual_input']) actual_body]
                            (and (identical? expected_register actual_register)
                                 (identical? expected_input actual_input)
                                 (identical? expected_register' actual_register')
                                 (identical? expected_input' actual_input')
                                 (identical? expected_body actual_body))

                            else
                            false)))))
               (let [expected_before (is /.Term (/.text expected_provenance expected_text))
                     expected_after (is /.Term (/.f64 expected_provenance expected_f64))]
                 (all _.and
                      (_.coverage [/.Exec
                                   /.#exec_before /.#exec_after

                                   /.exec]
                        (when (/.exec expected_provenance expected_before expected_after)
                          (/.exec actual_provenance actual_before actual_after)
                          (and (identical? expected_provenance actual_provenance)
                               (identical? expected_before actual_before)
                               (identical? expected_after actual_after))

                          else
                          false))
                      (_.coverage [/.flat_exec]
                        (let [expected_before' (is /.Term (/.text expected_provenance (text expected_text expected_text)))]
                          (when (<| /.flat_exec
                                    (/.exec expected_provenance expected_before)
                                    (/.exec expected_provenance expected_before')
                                    expected_after)
                            [(list actual_before actual_before') actual_after]
                            (and (identical? expected_before actual_before)
                                 (identical? expected_before' actual_before')
                                 (identical? expected_after actual_after))

                            else
                            false)))))
               ))))

(the control
  Test
  (<| (monad.let [! random.monad]
        [expected_provenance provenanceT.random
         
         expected_bit random.bit
         expected_i64 random.i64
         expected_f64 random.safe_decimal
         expected_text (random.lower_cased 1)

         expected_register random.natural
         expected_variable (is (Random Variable)
                               (random.or random.natural
                                          random.natural))
         expected_constant (nameT.random 1 2)
         expected_arity random.natural])
      (_.for [/.Control /.#Control])
      (`` (all _.and
               ..control/when
               (<| (_.for [/.Loop /.#Loop])
                   (let [expected_environment (is (List /.Term)
                                                  (list (/.bit expected_provenance expected_bit)
                                                        (/.i64 expected_provenance expected_i64)
                                                        (/.f64 expected_provenance expected_f64)
                                                        (/.text expected_provenance expected_text)))
                         expected_term (is /.Term (/.text expected_provenance expected_text))])
                   (all _.and
                        (_.coverage [/.Tail_Recursion
                                     /.#start /.#inits /.#iteration
                                     
                                     /.#Tail_Recursion
                                     /.tail_recursion]
                          (when (is /.Term (/.tail_recursion expected_provenance
                                                             [/.#start expected_register
                                                              /.#inits expected_environment
                                                              /.#iteration expected_term]))
                            (/.tail_recursion actual_provenance
                                              [/.#start actual_register
                                               /.#inits actual_environment
                                               /.#iteration actual_term])
                            (and (identical? expected_provenance actual_provenance)
                                 (identical? expected_register actual_register)
                                 (identical? expected_environment actual_environment)
                                 (identical? expected_term actual_term))

                            else
                            false))
                        (_.coverage [/.#Tail_Iteration
                                     /.tail_iteration]
                          (when (is /.Term (/.tail_iteration expected_provenance expected_environment))
                            (/.tail_iteration actual_provenance actual_environment)
                            (and (identical? expected_provenance actual_provenance)
                                 (identical? expected_environment actual_environment))

                            else
                            false))))
               (<| (_.for [/.Function /.#Function])
                   (let [expected_environment (is (List /.Term)
                                                  (list (/.bit expected_provenance expected_bit)
                                                        (/.i64 expected_provenance expected_i64)
                                                        (/.f64 expected_provenance expected_f64)
                                                        (/.text expected_provenance expected_text)))
                         expected_term (is /.Term (/.text expected_provenance expected_text))])
                   (all _.and
                        (_.coverage [/.Abstraction /.Abstraction'
                                     /.#environment /.#arity /.#body
                                     
                                     /.#Abstraction
                                     /.abstraction]
                          (when (is /.Term (/.abstraction expected_provenance [/.#environment expected_environment
                                                                               /.#arity expected_arity
                                                                               /.#body expected_term]))
                            (/.abstraction actual_provenance [/.#environment actual_environment
                                                              /.#arity actual_arity
                                                              /.#body actual_term])
                            (and (identical? expected_provenance actual_provenance)
                                 (identical? expected_environment actual_environment)
                                 (identical? expected_arity actual_arity)
                                 (identical? expected_term actual_term))

                            else
                            false))
                        (_.coverage [/.Reification /.Reification'
                                     /.#function /.#arguments
                                     
                                     /.#Reification
                                     /.reification]
                          (when (is /.Term (/.reification expected_provenance [/.#function expected_term
                                                                               /.#arguments expected_environment]))
                            (/.reification actual_provenance [/.#function actual_term
                                                              /.#arguments actual_environment])
                            (and (identical? expected_provenance actual_provenance)
                                 (identical? expected_term actual_term)
                                 (identical? expected_environment actual_environment))

                            else
                            false))))
               ))))

(the term
  Test
  (<| (_.for [/.Term /.Term'])
      (`` (all _.and
               ..simple
               ..structure
               ..reference
               ..control
               ))))

(the .public test
  Test
  (<| (_.covering /._)
      (monad.let [! random.monad]
        [])
      (`` (all _.and
               ... ..\\projection

               ..term
               (,, (template.with [,synthesis ,phase]
                     [(_.coverage [,synthesis]
                        (check.< ,synthesis ,phase))]

                     [[/.Operation phase.Operation]
                      [/.Phase phase.Phase]]))
               (<| (_.for [/.#Extension])
                   (all _.and
                        (,, (template.with [,synthesis ,phase]
                              [(_.coverage [,synthesis]
                                 (check.< ,synthesis ,phase))]

                              [[/.Handler extension.Handler]
                               [/.Bundle extension.Bundle]
                               [/.Extender extension.Extender]]))
                        ))
               (_.coverage [/.unit]
                 (identical? text.empty /.unit))
               (<| (_.for [/.State
                           /.#locals /.#currying?])
                   (_.coverage [/.init]
                     (and (n.= 0 (its /.#locals /.init))
                          (bit.= false (its /.#currying? /.init)))))
               (<| (_.for [/.Resolver])
                   (_.coverage [/.fresh_resolver]
                     (dictionary.empty? /.fresh_resolver)))

               /simple.test
               /access.test
               ))))
