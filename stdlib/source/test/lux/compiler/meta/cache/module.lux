... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    ["[0]" monad]]
   [concurrency
    ["[0]" future (.only Future) (.use "[1]:[0]" monad)]]
   [error
    ["[0]" try (.use "[1]:[0]" functor)]
    ["[0]" exception]]
   [math
    ["[0]" random]]
   [macro
    ["[0]" template]]
   [world
    ["[0]" file]]
   [test
    ["[0]" unit]
    ["_" property (.only Test)]]
   [data
    ["[0]" text]
    ["[0]" binary (.only)
     ["[1]T" \\test]]
    [collection
     ["[0]" dictionary]]]]]
 [\\library
  ["[0]" /]])

(`` (the (bad it)
      (-> (file.System Future) (file.System Future))
      (implementation
       (,, (template.with [<name>]
             [(the <name>
                (by it <name>))]

             [[delimiter]
              [file?]
              [directory?]
              [modify]
              [write]
              [append]
              [move]
              [directory_files]
              [sub_directories]
              [file_size]
              [last_modified]
              [can_execute?]
              [read]
              [delete]]))

       (the (make_directory path)
         (future:pure {try.:Failure ""}))
       )))

(the .public test
  Test
  (<| (_.covering /._)
      (monad.let [! random.monad]
        [@module random.natural
         expected_content_of_module (binaryT.random 1)
         name_of_file_0 (random.lower_cased 1)
         name_of_file_1 (random.lower_cased 2)
         file_0 (binaryT.random 2)
         file_1 (binaryT.random 3)]
        (all _.and
             (pure (monad.let [! future.monad]
                     [.let [/ "/"
                            fs (file.memory /)]
                      pre/0 (by fs directory? (/.path fs @module))
                      pre/1 (/.enabled? fs @module)
                      outcome (/.enable! ! fs @module)
                      post/0 (by fs directory? (/.path fs @module))
                      post/1 (/.enabled? fs @module)]
                     (unit.coverage [/.path /.enabled? /.enable!]
                       (and (not pre/0)
                            (not pre/1)
                            
                            (when outcome
                              {try.:Success _} true
                              {try.:Failure _} false)
                            
                            post/0
                            post/1))))
             (pure (monad.let [! future.monad]
                     [.let [/ "/"
                            fs (file.memory /)]
                      pre/0 (by fs directory? (/.path fs @module))
                      pre/1 (/.enabled? fs @module)
                      outcome (/.enable! ! (..bad fs) @module)
                      post/0 (by fs directory? (/.path fs @module))
                      post/1 (/.enabled? fs @module)]
                     (unit.coverage [/.cannot_enable]
                       (and (not pre/0)
                            (not pre/1)
                            
                            (when outcome
                              {try.:Success _}
                              false
                              
                              {try.:Failure error}
                              (exception.is? /.cannot_enable error))
                            
                            (not post/0)
                            (not post/1)))))
             (pure (monad.let [! future.monad]
                     [.let [/ "/"
                            fs (file.memory /)]
                      _ (/.enable! ! fs @module)
                      _ (/.cache! fs @module expected_content_of_module)
                      actual_content_of_module (/.cache fs @module)]
                     (unit.coverage [/.descriptor /.cache! /.cache]
                       (|> actual_content_of_module
                           (try:each (binary.= expected_content_of_module))
                           (try.else false)))))
             (pure (monad.let [! future.monad]
                     [.let [/ "/"
                            fs (file.memory /)]
                      _ (/.enable! ! fs @module)
                      _ (by fs write
                            (text (/.path fs @module) / name_of_file_0)
                            file_0)
                      _ (by fs write
                            (text (/.path fs @module) / name_of_file_1)
                            file_1)
                      actual (/.artifacts ! fs @module)
                      .let [expected (dictionary.of_list text.hash
                                                         (list [name_of_file_0 file_0]
                                                               [name_of_file_1 file_1]))]]
                     (unit.coverage [/.artifacts]
                       (|> actual
                           (try:each (by (dictionary.equality binary.equality) = expected))
                           (try.else false)))))
             ))))
