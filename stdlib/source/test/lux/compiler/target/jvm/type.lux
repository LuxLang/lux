... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]
    ["[0]" equivalence
     ["[1]T" \\test]]
    ["[0]" hash
     ["[1]T" \\test]]]
   [function
    ["?" predicate]]
   [data
    ["[0]" text]
    [collection
     ["[0]" stack (.use "[1]#[0]" functor)]
     ["[0]" set]]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" natural]]]
   [macro
    ["[0]" expansion]]
   [meta
    ["[0]" static]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" / (.only)
   ["[0]" category]
   ["[0]" box]
   ["[0]" descriptor]
   ["[0]" reflection]
   ["[0]" signature]]]
 ["[0]" /
  ["[1][0]" box]
  ["[1][0]" category]
  ["[1][0]" descriptor]
  ["[1][0]" reflection]
  ["[1][0]" signature]
  ["[1][0]" projection]])

(<| (expansion.let [,*descriptor_primitives (these descriptor.boolean
                                                   descriptor.byte
                                                   descriptor.short
                                                   descriptor.int
                                                   descriptor.long
                                                   descriptor.float
                                                   descriptor.double
                                                   descriptor.char)
                    ,*reflection_primitives (these reflection.boolean
                                                   reflection.byte
                                                   reflection.short
                                                   reflection.int
                                                   reflection.long
                                                   reflection.float
                                                   reflection.double
                                                   reflection.char)
                    ,*signature_primitives (these signature.boolean
                                                  signature.byte
                                                  signature.short
                                                  signature.int
                                                  signature.long
                                                  signature.float
                                                  signature.double
                                                  signature.char)
                    ,*primitives (these /.boolean
                                        /.byte
                                        /.short
                                        /.int
                                        /.long
                                        /.float
                                        /.double
                                        /.char)
                    ,*boxes (these box.boolean
                                   box.byte
                                   box.short
                                   box.int
                                   box.long
                                   box.float
                                   box.double
                                   box.char)])
    (these (the random_class
             (Random /.Class)
             (let [boxes (stack ,*boxes)
                   boxes_amount (stack.size boxes)]
               (do [! random.monad]
                 [choice (by ! each (n.% boxes_amount) random.natural)
                  choice (random.try (in (stack.item choice boxes)))]
                 (in (/.class (stack) choice)))))
           (the .public random
             (Random /.Value)
             (let [primitives (is (Stack /.Primitive)
                                  (stack ,*primitives))
                   primitives_amount (stack.size primitives)

                   boxes (stack ,*boxes)
                   boxes_amount (stack.size boxes)]
               (all random.either
                    (do [! random.monad]
                      [choice (by ! each (n.% primitives_amount) random.natural)]
                      (random.try (in (stack.item choice primitives))))
                    ..random_class))))
    (the .public test
      Test
      (<| (_.covering /._)
          (do [! random.monad]
            [argument_0 ..random
             argument_1 ..random
             name (random.lower_cased 2)
             return (is (Random /.Return)
                        (all random.either
                             (in /.void)
                             ..random))
             expected_class ..random_class
             expected_variable (random.lower_cased 2)])
          (_.for [/.Type])
          (all _.and
               (_.for [/.equivalence /.=]
                      (static.when (same? /.equivalence /.=)
                        (equivalenceT.spec /.equivalence ..random)))
               (_.for [/.hash]
                      (hashT.spec /.hash ..random))

               (_.coverage [/.descriptor]
                 (set.= (set.of_stack descriptor.hash (stack ,*descriptor_primitives))
                        (set.of_stack descriptor.hash (stack#each /.descriptor (stack ,*primitives)))))
               (_.coverage [/.reflection]
                 (set.= (set.of_stack reflection.hash (stack ,*reflection_primitives))
                        (set.of_stack reflection.hash (stack#each /.reflection (stack ,*primitives)))))
               (_.coverage [/.signature]
                 (set.= (set.of_stack signature.hash (stack ,*signature_primitives))
                        (set.of_stack signature.hash (stack#each /.signature (stack ,*primitives)))))

               (_.coverage [/.as_text]
                 (text.= (signature.signature (/.signature argument_0))
                         (/.as_text argument_0)))
               (_.coverage [/.Declaration /.declaration /.as_class]
                 (let [expected (is (Stack /.Class)
                                    (stack#each (|>> (/.declaration (stack)) /.as_class) (stack ,*boxes)))
                       actual (is (Stack /.Class)
                                  (stack#each (/.class (stack)) (stack ,*boxes)))]
                   (by (stack.equivalence /.equivalence) =
                       expected
                       actual)))
               (<| (_.for [/.Return])
                   (all _.and
                        (_.coverage [/.Void /.void]
                          (let [options (is (Stack /.Void)
                                            (stack /.void))
                                uniques (set.of_stack /.hash options)]
                            (n.= (stack.size options)
                                 (set.size uniques))))
                        (_.coverage [/.void?]
                          (and (|> /.void
                                   /.void?
                                   (match? {.#Right _}))
                               (|> argument_0
                                   /.void?
                                   (match? {.#Left value}))))
                        (<| (_.for [/.Value])
                            (all _.and
                                 (_.coverage [/.Primitive ,*primitives]
                                   (let [options (is (Stack /.Primitive)
                                                     (stack ,*primitives))
                                         uniques (set.of_stack /.hash options)]
                                     (n.= (stack.size options)
                                          (set.size uniques))))
                                 (_.coverage [/.primitive?]
                                   (stack.every? (|>> /.primitive?
                                                      (match? {.#Right _}))
                                                 (stack ,*primitives)))
                                 (<| (_.for [/.Parameter])
                                     (all _.and
                                          (_.coverage [/.Var /.var]
                                            (exec
                                              (is /.Var
                                                  (/.var expected_variable))
                                              true))
                                          (_.coverage [/.lower /.upper]
                                            (not (/.= (/.lower expected_class)
                                                      (/.upper expected_class))))
                                          (_.coverage [/.wildcard]
                                            (and (not (/.= (/.lower expected_class)
                                                           /.wildcard))
                                                 (not (/.= (/.upper expected_class)
                                                           /.wildcard))))
                                          (<| (_.for [/.Object])
                                              (all _.and
                                                   (_.coverage [/.Class /.class]
                                                     (let [options (is (Stack /.Class)
                                                                       (stack#each (/.class (stack)) (stack ,*boxes)))
                                                           uniques (set.of_stack /.hash options)]
                                                       (n.= (stack.size options)
                                                            (set.size uniques))))
                                                   (_.coverage [/.class?]
                                                     (stack.every? (|>> /.class?
                                                                        (match? {.#Some _}))
                                                                   (stack#each (/.class (stack)) (stack ,*boxes))))
                                                   (_.coverage [/.Array /.array]
                                                     (and (let [options (is (Stack /.Array)
                                                                            (stack#each (|>> (/.class (stack)) /.array)
                                                                                        (stack ,*boxes)))
                                                                uniques (set.of_stack /.hash options)]
                                                            (n.= (stack.size options)
                                                                 (set.size uniques)))
                                                          (let [single (stack#each (|>> (/.class (stack)) /.array) (stack ,*boxes))
                                                                double (stack#each /.array single)]
                                                            (not (by (stack.equivalence /.equivalence) =
                                                                     single
                                                                     double)))))))
                                          ))))))

               /box.test
               /category.test
               /descriptor.test
               /reflection.test
               /signature.test
               /projection.test
               ))))
