(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]
    [\\specification
     ["$[0]" equivalence]
     ["$[0]" hash]]]
   [control
    ["[0]" maybe]]
   [data
    [collection
     ["[0]" list]
     ["[0]" set {"+" Set}]]]
   [math
    ["[0]" random {"+" Random}]
    [number
     ["n" nat]]]]]
 [\\library
  ["[0]" /]])

(with_expansions [<resolutions> (these /.svga
                                       /.wsvga
                                       /.xga
                                       /.xga+
                                       /.wxga_16:9
                                       /.wxga_5:3
                                       /.wxga_16:10
                                       /.sxga
                                       /.wxga+
                                       /.hd+
                                       /.wsxga+
                                       /.fhd
                                       /.wuxga
                                       /.wqhd
                                       /.uhd_4k)]
  (def: listing
    (List /.Resolution)
    (list <resolutions>))

  (def: catalogue
    (Set /.Resolution)
    (set.of_list /.hash ..listing))

  (def: .public random
    (Random /.Resolution)
    (let [count (list.size ..listing)]
      (do [! random.monad]
        [choice (# ! each (n.% count) random.nat)]
        (in (maybe.trusted (list.item choice ..listing))))))

  (def: .public test
    Test
    (<| (_.covering /._)
        (_.for [/.Resolution])
        (all _.and
             (_.for [/.equivalence]
                    ($equivalence.spec /.equivalence ..random))
             (_.for [/.hash]
                    ($hash.spec /.hash ..random))

             (_.coverage [<resolutions>]
               (n.= (list.size ..listing)
                    (set.size ..catalogue)))
             ))))
