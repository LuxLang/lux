(.require
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]
    [\\specification
     ["[0]S" equivalence]]
    ["[0]" order
     ["[1]T" \\test]]]
   [control
    ["[0]" maybe (.use "[1]#[0]" functor)]]
   [data
    ["[0]" bit (.use "[1]#[0]" equivalence)]
    ["[0]" text (.only)
     ["%" \\format]]]
   [math
    ["[0]" random (.only Random) (.use "[1]#[0]" functor)]
    [number
     ["i" int]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" / (.only)
   [///
    [money
     ["[0]" currency (.only Currency)]]]]])

(def .public (random $)
  (All (_ $)
    (-> (Currency $)
        (Random (/.Action $))))
  (random#each (/.action $)
               random.int))

(def .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [expected_movement random.int

         expected_parameter random.int
         expected_subject random.int])
      (_.for [/.Price /.Action])
      (all _.and
           (_.for [/.equivalence /.=]
                  (equivalenceS.spec /.equivalence (..random currency.usd)))
           (_.for [/.order /.<]
                  (orderT.spec /.order (..random currency.usd)))
           
           (_.coverage [/.action /.currency /.movement]
             (let [it (/.action currency.usd expected_movement)]
               (and (same? currency.usd (/.currency it))
                    (same? expected_movement (/.movement it)))))
           (_.coverage [/.+ /.-]
             (let [parameter (/.action currency.usd expected_parameter)
                   subject (/.action currency.usd expected_subject)]
               (and (|> subject
                        (/.+ parameter)
                        (of /.equivalence = subject)
                        not)
                    (|> subject
                        (/.+ parameter)
                        (/.- parameter)
                        (of /.equivalence = subject)))))
           (_.coverage [/.min]
             (let [expected_parameter (/.action currency.usd expected_parameter)
                   expected_subject (/.action currency.usd expected_subject)]
               (and (/.<= expected_parameter
                          (/.min expected_parameter expected_subject))
                    (/.<= expected_subject
                          (/.min expected_parameter expected_subject)))))
           (_.coverage [/.max]
             (let [expected_parameter (/.action currency.usd expected_parameter)
                   expected_subject (/.action currency.usd expected_subject)]
               (and (/.>= expected_parameter
                          (/.max expected_parameter expected_subject))
                    (/.>= expected_subject
                          (/.max expected_parameter expected_subject)))))
           (let [expected_parameter (/.action currency.usd expected_parameter)
                 expected_subject (/.action currency.usd expected_subject)]
             (all _.and
                  (_.coverage [/.>]
                    (bit#= (/.> expected_parameter expected_subject)
                           (/.< expected_subject expected_parameter)))
                  (_.coverage [/.<= /.>=]
                    (bit#= (/.<= expected_parameter expected_subject)
                           (/.>= expected_subject expected_parameter)))
                  ))
           (_.coverage [/.units /.sub_units]
             (let [expected (/.action currency.usd expected_movement)
                   actual (/.action currency.usd (i.+ (/.units expected)
                                                      (/.sub_units expected)))]
               (/.= expected actual)))
           (_.coverage [/.of_units /.of_sub_units]
             (let [expected (/.action currency.usd expected_movement)
                   actual (/.+ (/.of_units currency.usd (/.units expected))
                               (/.of_sub_units currency.usd (/.sub_units expected)))]
               (/.= expected actual)))
           (do !
             [it (..random currency.usd)]
             (_.coverage [/.format]
               (and (text.starts_with? (%.int (/.movement it))
                                       (text.replaced_once "." "" (/.format it)))
                    (text.ends_with? (currency.alphabetic_code (/.currency it))
                                     (/.format it)))))
           )))
