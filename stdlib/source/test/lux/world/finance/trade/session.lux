(.require
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]
    [\\specification
     ["[0]S" equivalence]]]
   [data
    ["[0]" bit (.use "[1]#[0]" equivalence)]
    ["[0]" text (.use "[1]#[0]" equivalence)]
    [collection
     ["[0]" list]]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" nat]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" / (.only)
   [///
    ["[0]" money (.only)
     ["[0]" currency (.only Currency)]]]]]
 [///
  ["[0]T" money]])

(def .public (random $)
  (All (_ $)
    (-> (Currency $)
        (Random (/.Session $))))
  (do random.monad
    [p0 (moneyT.random $)
     p1 (moneyT.random $)
     p2 (moneyT.random $)
     p3 (moneyT.random $)
     bullish? random.bit
     volume random.nat]
    (when (list.sorted money.< (list p0 p1 p2 p3))
      (list low bottom top high)
      (in [/.#open (if bullish?
                     bottom
                     top)
           /.#high high
           /.#low low
           /.#close (if bullish?
                      top
                      bottom)
           /.#volume volume])

      _
      (undefined))))

(def .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [before (..random currency.usd)
         after (..random currency.usd)])
      (_.for [/.Session /.Price /.Volume
              /.#open /.#high /.#low /.#close /.#volume])
      (all _.and
           (_.for [/.equivalence]
                  (equivalenceS.spec /.equivalence (..random currency.usd)))
           
           (_.coverage [/.composite]
             (let [both (/.composite before after)]
               (and (money.= (the /.#open before)
                             (the /.#open both))
                    (and (money.>= (the /.#high before)
                                   (the /.#high both))
                         (money.>= (the /.#high after)
                                   (the /.#high both)))
                    (and (money.<= (the /.#low before)
                                   (the /.#low both))
                         (money.<= (the /.#low after)
                                   (the /.#low both)))
                    (money.= (the /.#close after)
                             (the /.#close both))
                    (and (n.>= (the /.#volume before)
                               (the /.#volume both))
                         (n.>= (the /.#volume after)
                               (the /.#volume both))))))
           (_.coverage [/.format]
             (bit#= (of /.equivalence =
                        before
                        after)
                    (text#= (/.format before)
                            (/.format after))))
           )))
