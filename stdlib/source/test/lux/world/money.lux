(.require
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]
    [\\specification
     ["[0]S" equivalence]]]
   [control
    ["[0]" maybe (.use "[1]#[0]" functor)]]
   [data
    ["[0]" text (.only)
     ["%" \\format]]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" nat]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" / (.only)
   ["[0]" currency]]]
 ["[0]" /
  ["[1][0]" currency]])

(def .public random
  (Random (Ex (_ of)
            (/.Money of)))
  (do random.monad
    [expected_currency /currency.random
     expected_amount random.nat]
    (in (/.money expected_currency expected_amount))))

(def .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [.let [expected_currency currency.usd]
         expected_amount random.nat

         expected_parameter (random.only (n.> 0) random.nat)
         expected_subject random.nat])
      (_.for [/.Money])
      (all _.and
           (_.for [/.equivalence]
                  (equivalenceS.spec /.equivalence ..random))
           
           (_.coverage [/.money /.currency /.amount]
             (let [it (/.money expected_currency expected_amount)]
               (and (same? expected_currency (/.currency it))
                    (same? expected_amount (/.amount it)))))
           (_.coverage [/.+ /.-]
             (let [parameter (/.money expected_currency expected_parameter)
                   subject (/.money expected_currency expected_subject)]
               (and (|> subject
                        (/.+ parameter)
                        (of /.equivalence = subject)
                        not)
                    (|> subject
                        (/.+ parameter)
                        (/.- parameter)
                        (maybe#each (of /.equivalence = subject))
                        (maybe.else false)))))
           (do !
             [it ..random]
             (_.coverage [/.format]
               (and (text.starts_with? (%.nat (/.amount it))
                                       (text.replaced_once "." "" (/.format it)))
                    (text.ends_with? (currency.alphabetic_code (/.currency it))
                                     (/.format it)))))

           /currency.test
           )))
