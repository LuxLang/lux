(.module:
  [library
   [lux #*
    ["_" test (#+ Test)]
    [abstract
     [predicate (#+ Predicate)]
     [monad (#+ do)]]
    [control
     ["." try (#+ Try)]
     ["." exception]
     [concurrency
      ["." async (#+ Async)]]]
    [data
     ["." binary (#+ Binary) ("#\." equivalence)]
     ["." text ("#\." equivalence)
      ["%" format (#+ format)]]
     [collection
      ["." list]]]
    [math
     ["." random (#+ Random) ("#\." monad)]]]]
  [\\library
   ["." /
    ["/#" //]]]
  [////
   [data
    ["$." binary]]])

(def: concern
  (Random [/.Concern (Predicate /.Concern)])
  ($_ random.either
      (random\in [/.creation /.creation?])
      (random\in [/.modification /.modification?])
      (random\in [/.deletion /.deletion?])
      ))

(def: concern\\test
  Test
  (<| (_.for [/.Concern])
      ($_ _.and
          (_.cover [/.creation /.creation?]
                   (and (/.creation? /.creation)
                        (not (/.creation? /.modification))
                        (not (/.creation? /.deletion))))
          (_.cover [/.modification /.modification?]
                   (and (not (/.modification? /.creation))
                        (/.modification? /.modification)
                        (not (/.modification? /.deletion))))
          (_.cover [/.deletion /.deletion?]
                   (and (not (/.deletion? /.creation))
                        (not (/.deletion? /.modification))
                        (/.deletion? /.deletion)))
          (do random.monad
            [left ..concern
             right (random.only (|>> (same? left) not)
                                ..concern)
             .let [[left left?] left
                   [right right?] right]]
            (_.cover [/.also]
                     (let [composition (/.also left right)]
                       (and (left? composition)
                            (right? composition)))))
          (_.cover [/.all]
                   (and (/.creation? /.all)
                        (/.modification? /.all)
                        (/.deletion? /.all)))
          )))

(def: exception
  Test
  (do {! random.monad}
    [directory (random.ascii/alpha 5)
     .let [[fs watcher] (/.mock "/")]]
    ($_ _.and
        (in (do async.monad
              [?concern (\ watcher concern directory)
               ?stop (\ watcher stop directory)]
              (_.cover' [/.not_being_watched]
                        (and (case ?concern
                               (#try.Failure error)
                               (exception.match? /.not_being_watched error)

                               (#try.Success _)
                               false)
                             (case ?stop
                               (#try.Failure error)
                               (exception.match? /.not_being_watched error)

                               (#try.Success _)
                               false)))))
        )))

(def: (no_events_prior_to_creation! fs watcher directory)
  (-> (//.System Async) (/.Watcher Async) //.Path (Async (Try Bit)))
  (do {! (try.with async.monad)}
    [_ (\ fs make_directory directory)
     _ (\ watcher start /.all directory)]
    (|> (\ watcher poll [])
        (\ ! each list.empty?))))

(def: (after_creation! fs watcher expected_path)
  (-> (//.System Async) (/.Watcher Async) //.Path (Async (Try Bit)))
  (do (try.with async.monad)
    [_ (: (Async (Try Any))
          (//.make_file async.monad fs (binary.empty 0) expected_path))
     poll/pre (\ watcher poll [])
     poll/post (\ watcher poll [])]
    (in (and (case poll/pre
               (^ (list [concern actual_path]))
               (and (text\= expected_path actual_path)
                    (and (/.creation? concern)
                         (not (/.modification? concern))
                         (not (/.deletion? concern))))

               _
               false)
             (list.empty? poll/post)))))

(def: (after_modification! fs watcher data expected_path)
  (-> (//.System Async) (/.Watcher Async) Binary //.Path (Async (Try Bit)))
  (do (try.with async.monad)
    [_ (async.after 1 (#try.Success "Delay to make sure the over_write time-stamp always changes."))
     _ (\ fs write data expected_path)
     poll/2 (\ watcher poll [])
     poll/2' (\ watcher poll [])]
    (in (and (case poll/2
               (^ (list [concern actual_path]))
               (and (text\= expected_path actual_path)
                    (and (not (/.creation? concern))
                         (/.modification? concern)
                         (not (/.deletion? concern))))

               _
               false)
             (list.empty? poll/2')))))

(def: (after_deletion! fs watcher expected_path)
  (-> (//.System Async) (/.Watcher Async) //.Path (Async (Try Bit)))
  (do (try.with async.monad)
    [_ (\ fs delete expected_path)
     poll/3 (\ watcher poll [])
     poll/3' (\ watcher poll [])]
    (in (and (case poll/3
               (^ (list [concern actual_path]))
               (and (not (/.creation? concern))
                    (not (/.modification? concern))
                    (/.deletion? concern))

               _
               false)
             (list.empty? poll/3')))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Watcher])
      ($_ _.and
          ..concern\\test
          ..exception

          (do {! random.monad}
            [directory (random.ascii/alpha 5)
             .let [/ "/"
                   [fs watcher] (/.mock /)]
             expected_path (\ ! each (|>> (format directory /))
                              (random.ascii/alpha 5))
             data ($binary.random 10)]
            (in (do {! async.monad}
                  [verdict (do (try.with !)
                             [no_events_prior_to_creation!
                              (..no_events_prior_to_creation! fs watcher directory)

                              after_creation!
                              (..after_creation! fs watcher expected_path)

                              after_modification!
                              (..after_modification! fs watcher data expected_path)

                              after_deletion!
                              (..after_deletion! fs watcher expected_path)]
                             (in (and no_events_prior_to_creation!
                                      after_creation!
                                      after_modification!
                                      after_deletion!)))]
                  (_.cover' [/.mock /.polling]
                            (try.else false verdict)))))
          (do random.monad
            [directory (random.ascii/alpha 5)
             .let [/ "/"
                   [fs watcher] (/.mock /)]]
            (in (do async.monad
                  [started? ( \ watcher start /.all directory)]
                  (_.cover' [/.cannot_poll_a_non_existent_directory]
                            (case started?
                              (#try.Success _)
                              false
                              
                              (#try.Failure error)
                              (exception.match? /.cannot_poll_a_non_existent_directory error))))))
          )))
