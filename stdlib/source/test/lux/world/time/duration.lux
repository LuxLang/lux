... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]
    ["[0]" enum
     ["[1]T" \\test]]
    ["[0]" format
     ["[1]T" \\test]]
    ["[0]" equivalence
     ["[1]T" \\test]]
    ["[0]" order
     ["[1]T" \\test]]
    ["[0]" monoid
     ["[1]T" \\test]]]
   [control
    ["[0]" try (.use "[1]#[0]" functor)]]
   [data
    ["[0]" bit]
    ["[0]" text
     ["?[1]" \\projection]]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" natural]
     ["i" int]]]
   [meta
    [macro
     ["[0]" template]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" /]])

(the .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Duration])
      (all _.and
           (_.for [/.equivalence]
                  (equivalenceT.spec /.equivalence /.random))
           (_.for [/.order]
                  (orderT.spec /.order /.random))
           (_.for [/.enum]
                  (enumT.spec /.enum /.random))
           (_.for [/.monoid]
                  (monoidT.spec /.equivalence /.monoid /.random))
           (_.for [/.format]
                  (formatT.spec /.equivalence /.format /.random))

           (do random.monad
             [duration /.random]
             (_.coverage [/.of_millis /.millis]
               (|> duration /.millis /.of_millis (of /.equivalence = duration))))
           (do random.monad
             [expected /.random
              parameter /.random]
             (all _.and
                  (_.coverage [/.composite /.difference]
                    (|> expected (/.composite parameter) (/.difference parameter) (/.= expected)))
                  (_.coverage [/.empty]
                    (|> expected (/.composite /.empty) (/.= expected)))
                  (_.coverage [/.inverse]
                    (and (|> expected /.inverse /.inverse (/.= expected))
                         (|> expected (/.composite (/.inverse expected)) (/.= /.empty))))
                  (_.coverage [/.positive? /.negative? /.neutral?]
                    (or (bit.= (/.positive? expected)
                               (/.negative? (/.inverse expected)))
                        (bit.= (/.neutral? expected)
                               (/.neutral? (/.inverse expected)))))
                  ))
           (do random.monad
             [factor random.natural]
             (_.coverage [/.up /.down]
               (|> /.milli_second (/.up factor) (/.down factor) (/.= /.milli_second))))
           (do [! random.monad]
             [.let [(open "/#[0]") /.order
                    positive (|> /.random
                                 (random.only (|>> (/.= /.empty) not))
                                 (of ! each (function (_ duration)
                                              (if (/.positive? duration)
                                                duration
                                                (/.inverse duration)))))]
              sample positive
              frame positive]
             (`` (all _.and
                      (_.coverage [/.framed]
                        (let [sample' (/.framed frame sample)]
                          (and (/#< frame sample')
                               (bit.= (/#< frame sample)
                                      (/.= sample sample')))))
                      (_.coverage [/.ticks]
                        (i.= +1 (/.ticks sample sample)))
                      (_.coverage [/.milli_second]
                        (/.= /.empty (of /.enum pred /.milli_second)))
                      (,, (template.with [<factor> <big> <small>]
                            [(_.coverage [<big>]
                               (|> <big> (/.ticks <small>) (i.= <factor>)))]

                            [+1,000 /.second /.milli_second]
                            [+60 /.minute /.second]
                            [+60 /.hour /.minute]
                            [+24 /.day /.hour]

                            [+7 /.week /.day]
                            [+365 /.normal_year /.day]
                            [+366 /.leap_year /.day]
                            ))
                      )))
           (do random.monad
             [expected /.random]
             (_.coverage [/.as_text /.projection]
               (|> expected
                   /.as_text
                   (?text.value /.projection)
                   (try#each (of /.equivalence = expected))
                   (try.else false))))
           (do random.monad
             [expected /.random
              actual (random.only (|>> (of /.equivalence = expected) not)
                                  /.random)]
             (_.coverage [/.random]
               (not (of /.equivalence = expected actual))))
           )))
