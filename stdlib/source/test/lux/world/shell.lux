(.require
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" try (.only Try)]
    ["[0]" exception]
    ["[0]" io (.only IO)]
    [concurrency
     ["[0]" async (.only Async)]]]
   [data
    ["[0]" text (.use "[1]#[0]" equivalence)]
    [collection
     ["[0]" list]]]
   [math
    ["[0]" random]
    [number
     ["n" nat]
     ["i" int]]]
   [test
    ["[0]" unit]
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" / (.only)
   [//
    [file (.only Path)]
    ["[0]" environment
     ["[1]" \\parser (.only Environment)]]]]]
 [\\specification
  ["$[0]" /]])

(exception.def dead)

(def (mock [environment working_directory command arguments])
  (-> [Environment Path /.Command (List /.Argument)]
      (/.Mock Bit))
  (implementation
   (def (on_read dead?)
     (if dead?
       (exception.except ..dead [])
       (do try.monad
         [echo (try.of_maybe (list.head arguments))]
         (in [dead? echo]))))
   
   (def (on_fail dead?)
     (if dead?
       (exception.except ..dead [])
       {try.#Success [dead? ""]}))
   
   (def (on_write message dead?)
     (if dead?
       (exception.except ..dead [])
       {try.#Success dead?}))

   (def (on_destroy dead?)
     (if dead?
       (exception.except ..dead [])
       {try.#Success true}))

   (def (on_await dead?)
     (if dead?
       (exception.except ..dead [])
       {try.#Success [true /.normal]}))))

(def (io_shell command oops input destruction exit)
  (-> /.Command Text Text Text /.Exit (/.Shell IO))
  (implementation
   (def (execute [environment working_directory command arguments])
     (<| io.io
         {try.#Success}
         (is (/.Process IO))
         (implementation
          (def (read _)
            (io.io {try.#Success command}))
          (def (fail _)
            (io.io {try.#Success oops}))
          (def (write message)
            (io.io {try.#Failure message}))
          (def (destroy _)
            (io.io {try.#Failure destruction}))
          (def (await _)
            (io.io {try.#Success exit})))))))

(def .public test
  Test
  (<| (_.covering /._)
      (all _.and
           (_.for [/.Mock /.mock
                   /.on_read /.on_fail /.on_write /.on_destroy /.on_await

                   /.async]
                  ($/.spec (/.async (/.mock (|>> ..mock {try.#Success})
                                            false))))
           (_.coverage [/.error]
             (not (i.= /.normal /.error)))
           (do random.monad
             [command (random.alphabetic 5)
              oops (random.alphabetic 5)
              input (random.alphabetic 5)
              destruction (random.alphabetic 5)
              exit random.int
              .let [shell (/.async (..io_shell command oops input destruction exit))]]
             (in (do [! async.monad]
                   [verdict (do (try.with !)
                              [process (of shell execute [environment.empty "~" command (list)])
                               read (of process read [])
                               failure (of process fail [])
                               wrote! (do !
                                        [write (of process write input)]
                                        (in {try.#Success (when write
                                                            {try.#Success _}
                                                            false
                                                            
                                                            {try.#Failure write}
                                                            (text#= input write))}))
                               destroyed! (do !
                                            [destroy (of process destroy [])]
                                            (in {try.#Success (when destroy
                                                                {try.#Success _}
                                                                false
                                                                
                                                                {try.#Failure destroy}
                                                                (text#= destruction destroy))}))
                               await (of process await [])]
                              (in (and (text#= command read)
                                       (text#= oops failure)
                                       wrote!
                                       destroyed!
                                       (i.= exit await))))]
                   (unit.coverage [/.Shell]
                     (try.else false verdict)))))
           )))
