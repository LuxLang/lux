(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    [abstract
     ["[0]" monad {"+" [do]}]
     [\\specification
      ["$[0]" equivalence]]]
    [data
     ["[0]" text ("[1]#[0]" equivalence)
      ["%" format {"+" [format]}]]]
    [math
     ["[0]" random {"+" [Random]}]
     [number
      ["n" nat ("[1]#[0]" equivalence)]]]]]
  [\\library
   ["[0]" /]])

(def: .public (random class super)
  (All (_ t c %) (-> (/.Class t c %) (Random t) (Random (/.Quotient t c %))))
  (# random.monad each (/.quotient class) super))

(def: mod_10_class
  (/.class (|>> (n.% 10) %.nat)))

(def: Mod_10
  (/.type ..mod_10_class))

(def: .public test
  Test
  (<| (_.covering /._)
      (do random.monad
        [modulus (random.only (n.> 0) random.nat)
         .let [class (: (-> Nat Text)
                        (|>> (n.% modulus) %.nat))]
         value random.nat]
        ($_ _.and
            (_.for [/.equivalence]
                   ($equivalence.spec (/.equivalence text.equivalence)
                                      (..random (/.class class) random.nat)))

            (_.for [/.Class]
                   (_.cover [/.class]
                            (same? (: Any class)
                                   (: Any (/.class class)))))
            (_.for [/.Quotient]
                   ($_ _.and
                       (_.cover [/.quotient /.value /.label]
                                (let [quotient (/.quotient (/.class class) value)]
                                  (and (same? value
                                              (/.value quotient))
                                       (text#= (class value)
                                               (/.label quotient)))))
                       (_.cover [/.type]
                                (exec
                                  (: ..Mod_10
                                     (/.quotient ..mod_10_class value))
                                  true))
                       ))
            ))))
