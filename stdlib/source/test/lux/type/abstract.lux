(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   ["[0]" meta]
   [abstract
    [monad {"+" do}]]
   [control
    ["[0]" try]
    ["[0]" exception]
    [parser
     ["<[0]>" code]]]
   [data
    ["[0]" text ("[1]#[0]" equivalence)]]
   ["[0]" macro
    [syntax {"+" syntax:}]
    ["[0]" code]
    ["[0]" template]]
   ["[0]" math
    ["[0]" random]
    [number
     ["n" nat]]]]]
 [\\library
  ["[0]" /]])

(template.with_locals [g!Foo g!Bar]
  (these (template [<syntax> <meta>]
           [(syntax: (<syntax> [])
              (do meta.monad
                [frame <meta>]
                (in (list (code.text (the /.#name frame))))))]

           [current /.current]
           [specific (/.specific (template.text [g!Foo]))]
           )

         (syntax: (with_no_active_frames [macro <code>.any])
           (function (_ compiler)
             (let [verdict (case ((macro.expansion macro) compiler)
                             {try.#Failure error}
                             (exception.match? /.no_active_frames error)
                             
                             {try.#Success _}
                             false)]
               {try.#Success [compiler (list (code.bit verdict))]})))

         (with_expansions [no_current! (..with_no_active_frames (..current))
                           no_specific! (..with_no_active_frames (..specific))]
           (/.abstract: (g!Foo a)
             Text

             (/.abstract: (g!Bar a)
               Nat

               (def: .public test
                 Test
                 (<| (_.covering /._)
                     (_.for [/.abstract:])
                     (do random.monad
                       [expected_foo (random.ascii/lower 5)
                        expected_bar random.nat]
                       (all _.and
                            (_.cover [/.abstraction]
                                     (and (exec (is (g!Foo Text)
                                                    (/.abstraction g!Foo expected_foo))
                                            true)
                                          (exec (is (g!Bar Text)
                                                    (/.abstraction expected_bar))
                                            true)))
                            (_.cover [/.representation]
                                     (and (|> expected_foo
                                              (/.abstraction g!Foo)
                                              (is (g!Foo Bit))
                                              (/.representation g!Foo)
                                              (text#= expected_foo))
                                          (|> (/.abstraction expected_bar)
                                              (is (g!Bar Bit))
                                              /.representation
                                              (n.= expected_bar))))
                            (_.cover [/.transmutation]
                                     (and (exec (|> expected_foo
                                                    (/.abstraction g!Foo)
                                                    (is (g!Foo .Macro))
                                                    (/.transmutation g!Foo)
                                                    (is (g!Foo .Lux)))
                                            true)
                                          (exec (|> (/.abstraction expected_bar)
                                                    (is (g!Bar .Macro))
                                                    /.transmutation
                                                    (is (g!Bar .Lux)))
                                            true)))
                            (_.cover [/.pattern]
                                     (and (let [(/.pattern g!Foo actual_foo)
                                                (is (g!Foo .Module)
                                                    (/.abstraction g!Foo expected_foo))]
                                            (text#= expected_foo actual_foo))
                                          (let [(/.pattern actual_bar)
                                                (is (g!Bar .Module)
                                                    (/.abstraction expected_bar))]
                                            (n.= expected_bar actual_bar))))
                            (_.for [/.Frame]
                                   (all _.and
                                        (_.cover [/.current]
                                                 (text#= (template.text [g!Bar])
                                                         (..current)))
                                        (_.cover [/.specific]
                                                 (text#= (template.text [g!Foo])
                                                         (..specific)))
                                        (_.cover [/.no_active_frames]
                                                 (and no_current!
                                                      no_specific!))
                                        ))
                            )))))))))
