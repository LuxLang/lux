(.module:
  [library
   [lux {"-" [Variant Record]}
    ["_" test {"+" [Test]}]
    ["[0]" debug]
    [abstract
     codec
     [monad {"+" [do]}]
     ["[0]" equivalence {"+" [Equivalence]}
      ["poly/[1]" \\poly]]
     [\\specification
      ["$[0]" equivalence]
      ["$[0]" codec]]]
    [control
     pipe
     ["[0]" try]
     ["p" parser
      ... TODO: Get rid of this import ASAP
      [json {"+" []}]]]
    [data
     ["[0]" bit]
     ["[0]" text]
     [format
      [json {"+" []}
       [\\poly
        ["[0]" /]]]]
     [collection
      [row {"+" [row]}]
      ["d" dictionary]
      ["[0]" list]]]
    [type
     [poly {"+" [derived:]}]
     ["[0]" unit]]
    [math
     ["[0]" random {"+" [Random]}]
     [number
      ["n" nat]
      ["[0]" frac]]]
    [time
     ["ti" instant]
     ["tda" date]
     ... ["tdu" duration]
     ]]]
  [test
   [lux
    [time
     ["_[0]" instant]
     ... ["_[0]" duration]
     ]]])

(type: Variant
  (.Variant
   (#Bit Bit)
   (#Text Text)
   (#Frac Frac)))

(type: Recursive
  (Rec Recursive
    (.Variant
     (#Number Frac)
     (#Addition Frac Recursive))))

(type: Record
  (.Record
   [#bit Bit
    #frac Frac
    #text Text
    #maybe (Maybe Frac)
    #list (List Frac)
    #dictionary (d.Dictionary Text Frac)
    #variant Variant
    #tuple [Bit Text Frac]
    #recursive Recursive
    ... #instant ti.Instant
    ... #duration tdu.Duration
    #date tda.Date
    #grams (unit.Qty unit.Gram)]))

(def: gen_recursive
  (Random Recursive)
  (random.rec
   (function (_ gen_recursive)
     (random.or random.safe_frac
                (random.and random.safe_frac
                            gen_recursive)))))

(def: qty
  (All (_ unit) (Random (unit.Qty unit)))
  (\ random.monad each (debug.private unit.in) random.int))

(def: gen_record
  (Random Record)
  (do [! random.monad]
    [size (\ ! each (n.% 2) random.nat)]
    ($_ random.and
        random.bit
        random.safe_frac
        (random.unicode size)
        (random.maybe random.safe_frac)
        (random.list size random.safe_frac)
        (random.dictionary text.hash size (random.unicode size) random.safe_frac)
        ($_ random.or random.bit (random.unicode size) random.safe_frac)
        ($_ random.and random.bit (random.unicode size) random.safe_frac)
        ..gen_recursive
        ... _instant.instant
        ... _duration.duration
        random.date
        ..qty
        )))

(derived: equivalence
  (poly/equivalence.equivalence Record))

(derived: codec
  (/.codec Record))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.codec]
             ($codec.spec ..equivalence ..codec ..gen_record))))
