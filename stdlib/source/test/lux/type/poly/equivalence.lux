(.using
 [library
  [lux (.except Variant Record)
   ["_" test (.only Test)]
   ["@" target]
   [abstract
    [monad (.only do)]
    [equivalence (.only Equivalence)
     [\\poly
      ["[0]" /]]]
    [\\specification
     ["$[0]" equivalence]]]
   [control
    ["[0]" maybe]]
   [data
    ["[0]" bit]
    ["[0]" text]
    [collection
     ["[0]" list]]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" nat]
     ["i" int]]]]])

(type: Variant
  (.Variant
   {#Case0 Bit}
   {#Case1 Int}
   {#Case2 Frac}))

(type: Recursive
  (Rec Recursive
    (.Variant
     {#Number Frac}
     {#Addition Frac Recursive})))

(type: Record
  (.Record
   [#bit Bit
    #int Int
    #frac Frac
    #text Text
    #maybe (Maybe Int)
    #list (List Int)
    #variant Variant
    #tuple [Int Frac Text]
    #recursive Recursive]))

(def: gen_recursive
  (Random Recursive)
  (random.rec (function (_ gen_recursive)
                (random.or random.safe_frac
                           (random.and random.safe_frac
                                       gen_recursive)))))

(def: random
  (Random Record)
  (do [! random.monad]
    [size (at ! each (n.% 2) random.nat)
     .let [gen_int (|> random.int (at ! each (|>> i.abs (i.% +1,000,000))))]]
    (all random.and
         random.bit
         gen_int
         random.safe_frac
         (random.unicode size)
         (random.maybe gen_int)
         (random.list size gen_int)
         (all random.or
              random.bit
              gen_int
              random.safe_frac)
         (all random.and
              gen_int
              random.safe_frac
              (random.unicode size))
         gen_recursive)))

(for @.old (these)
     (these (def: equivalence
              (Equivalence ..Record)
              (/.equivalence ..Record))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.equivalence]
             (for @.old (_.property "PLACEHOLDER" true)
                  ($equivalence.spec ..equivalence ..random)))))
