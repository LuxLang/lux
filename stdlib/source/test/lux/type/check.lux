(.module:
  [lux (#- type)
   ["%" data/text/format (#+ format)]
   ["_" test (#+ Test)]
   [abstract
    ["." monad (#+ do)]]
   [control
    [pipe (#+ case>)]]
   [data
    ["." product]
    ["." maybe]
    ["." text ("#\." equivalence)]
    [collection
     ["." list ("#\." functor)]
     ["." set]]]
   [math
    ["." random (#+ Random)]
    [number
     ["n" nat]]]
   ["." type ("#\." equivalence)]]
  {1
   ["." /]})

## TODO: Remove the following 3 definitions ASAP. //.type already exists...
(def: short
  (Random Text)
  (random.unicode 10))

(def: name
  (Random Name)
  (random.and ..short ..short))

(def: (type' num_vars)
  (-> Nat (Random Type))
  (random.rec
   (function (_ recur)
     (let [(^open "R\.") random.monad
           pairG (random.and recur recur)
           quantifiedG (random.and (R\wrap (list)) (type' (inc num_vars)))
           random_pair (random.either (random.either (R\map (|>> #.Sum) pairG)
                                                     (R\map (|>> #.Product) pairG))
                                      (random.either (R\map (|>> #.Function) pairG)
                                                     (R\map (|>> #.Apply) pairG)))
           random_id (let [random_id (random.either (R\map (|>> #.Var) random.nat)
                                                    (R\map (|>> #.Ex) random.nat))]
                       (case num_vars
                         0 random_id
                         _ (random.either (R\map (|>> (n.% num_vars) (n.* 2) inc #.Parameter) random.nat)
                                          random_id)))
           random_quantified (random.either (R\map (|>> #.UnivQ) quantifiedG)
                                            (R\map (|>> #.ExQ) quantifiedG))]
       ($_ random.either
           (R\map (|>> #.Primitive) (random.and ..short (R\wrap (list))))
           random_pair
           random_id
           random_quantified
           (R\map (|>> #.Named) (random.and ..name (type' 0)))
           )))))

(def: type
  (Random Type)
  (..type' 0))

(def: (valid_type? type)
  (-> Type Bit)
  (case type
    (#.Primitive name params)
    (list.every? valid_type? params)
    
    (#.Ex id)
    #1

    (^template [<tag>]
      [(<tag> left right)
       (and (valid_type? left) (valid_type? right))])
    ([#.Sum] [#.Product] [#.Function])

    (#.Named name type')
    (valid_type? type')

    _
    #0))

(def: (type_checks? input)
  (-> (/.Check []) Bit)
  (case (/.run /.fresh_context input)
    (#.Right [])
    #1

    (#.Left error)
    #0))

(def: (build_ring num_connections)
  (-> Nat (/.Check [[Nat Type] (List [Nat Type]) [Nat Type]]))
  (do {! /.monad}
    [[head_id head_type] /.var
     ids+types (monad.seq ! (list.repeat num_connections /.var))
     [tail_id tail_type] (monad.fold ! (function (_ [tail_id tail_type] [_head_id _head_type])
                                         (do !
                                           [_ (/.check head_type tail_type)]
                                           (wrap [tail_id tail_type])))
                                     [head_id head_type]
                                     ids+types)]
    (wrap [[head_id head_type] ids+types [tail_id tail_type]])))

(def: #export test
  Test
  (<| (_.context (%.name (name_of /._)))
      ($_ _.and
          (do random.monad
            [sample (random.filter ..valid_type? ..type)]
            ($_ _.and
                (_.test "Any is the super-type of everything."
                        (/.checks? Any sample))
                (_.test "Nothing is the sub-type of everything."
                        (/.checks? sample Nothing))
                ))
          ($_ _.and
              (_.test "Any and Nothing match themselves."
                      (and (/.checks? Nothing Nothing)
                           (/.checks? Any Any)))
              (_.test "Existential types only match with themselves."
                      (and (type_checks? (do /.monad
                                           [[_ exT] /.existential]
                                           (/.check exT exT)))
                           (not (type_checks? (do /.monad
                                                [[_ exTL] /.existential
                                                 [_ exTR] /.existential]
                                                (/.check exTL exTR))))))
              (_.test "Names do not affect type-checking."
                      (and (type_checks? (do /.monad
                                           [[_ exT] /.existential]
                                           (/.check (#.Named ["module" "name"] exT)
                                                    exT)))
                           (type_checks? (do /.monad
                                           [[_ exT] /.existential]
                                           (/.check exT
                                                    (#.Named ["module" "name"] exT))))
                           (type_checks? (do /.monad
                                           [[_ exT] /.existential]
                                           (/.check (#.Named ["module" "name"] exT)
                                                    (#.Named ["module" "name"] exT))))))
              (_.test "Functions are covariant on inputs and contravariant on outputs."
                      (and (/.checks? (#.Function Nothing Any)
                                      (#.Function Any Nothing))
                           (not (/.checks? (#.Function Any Nothing)
                                           (#.Function Nothing Any)))))
              )
          (do random.monad
            [meta ..type
             data ..type]
            (_.test "Can type-check type application."
                    (and (/.checks? (|> Ann (#.Apply meta) (#.Apply data))
                                    (type.tuple (list meta data)))
                         (/.checks? (type.tuple (list meta data))
                                    (|> Ann (#.Apply meta) (#.Apply data))))))
          (do random.monad
            [#let [gen_short (random.ascii 10)]
             nameL gen_short
             nameR (|> gen_short (random.filter (|>> (text\= nameL) not)))
             paramL ..type
             paramR (random.filter (|>> (/.checks? paramL) not) ..type)]
            ($_ _.and
                (_.test "Primitive types match when they have the same name and the same parameters."
                        (/.checks? (#.Primitive nameL (list paramL))
                                   (#.Primitive nameL (list paramL))))
                (_.test "Names matter to primitive types."
                        (not (/.checks? (#.Primitive nameL (list paramL))
                                        (#.Primitive nameR (list paramL)))))
                (_.test "Parameters matter to primitive types."
                        (not (/.checks? (#.Primitive nameL (list paramL))
                                        (#.Primitive nameL (list paramR)))))
                ))
          ($_ _.and
              (_.test "Type-vars check against themselves."
                      (type_checks? (do /.monad
                                      [[id var] /.var]
                                      (/.check var var))))
              (_.test "Can bind unbound type-vars by type-checking against them."
                      (and (type_checks? (do /.monad
                                           [[id var] /.var]
                                           (/.check var .Any)))
                           (type_checks? (do /.monad
                                           [[id var] /.var]
                                           (/.check .Any var)))))
              (_.test "Cannot rebind already bound type-vars."
                      (not (type_checks? (do /.monad
                                           [[id var] /.var
                                            _ (/.check var .Bit)]
                                           (/.check var .Nat)))))
              (_.test "If the type bound to a var is a super-type to another, then the var is also a super-type."
                      (type_checks? (do /.monad
                                      [[id var] /.var
                                       _ (/.check var Any)]
                                      (/.check var .Bit))))
              (_.test "If the type bound to a var is a sub-type of another, then the var is also a sub-type."
                      (type_checks? (do /.monad
                                      [[id var] /.var
                                       _ (/.check var Nothing)]
                                      (/.check .Bit var))))
              )
          (do {! random.monad}
            [num_connections (|> random.nat (\ ! map (n.% 100)))
             boundT (|> ..type (random.filter (|>> (case> (#.Var _) #0 _ #1))))
             pick_pcg (random.and random.nat random.nat)]
            ($_ _.and
                (_.test "Can create rings of variables."
                        (type_checks? (do /.monad
                                        [[[head_id head_type] ids+types [tail_id tail_type]] (build_ring num_connections)
                                         #let [ids (list\map product.left ids+types)]
                                         headR (/.ring head_id)
                                         tailR (/.ring tail_id)]
                                        (/.assert ""
                                                  (let [same_rings? (\ set.equivalence = headR tailR)
                                                        expected_size? (n.= (inc num_connections) (set.size headR))
                                                        same_vars? (|> (set.to_list headR)
                                                                       (list.sort n.<)
                                                                       (\ (list.equivalence n.equivalence) = (list.sort n.< (#.Cons head_id ids))))]
                                                    (and same_rings?
                                                         expected_size?
                                                         same_vars?))))))
                (_.test "When a var in a ring is bound, all the ring is bound."
                        (type_checks? (do {! /.monad}
                                        [[[head_id headT] ids+types tailT] (build_ring num_connections)
                                         #let [ids (list\map product.left ids+types)]
                                         _ (/.check headT boundT)
                                         head_bound (/.read head_id)
                                         tail_bound (monad.map ! /.read ids)
                                         headR (/.ring head_id)
                                         tailR+ (monad.map ! /.ring ids)]
                                        (let [rings_were_erased? (and (set.empty? headR)
                                                                      (list.every? set.empty? tailR+))
                                              same_types? (list.every? (type\= boundT) (list& (maybe.default headT head_bound)
                                                                                              (list\map (function (_ [tail_id ?tailT])
                                                                                                          (maybe.default (#.Var tail_id) ?tailT))
                                                                                                        (list.zip/2 ids tail_bound))))]
                                          (/.assert ""
                                                    (and rings_were_erased?
                                                         same_types?))))))
                (_.test "Can merge multiple rings of variables."
                        (type_checks? (do /.monad
                                        [[[head_idL headTL] ids+typesL [tail_idL tailTL]] (build_ring num_connections)
                                         [[head_idR headTR] ids+typesR [tail_idR tailTR]] (build_ring num_connections)
                                         headRL_pre (/.ring head_idL)
                                         headRR_pre (/.ring head_idR)
                                         _ (/.check headTL headTR)
                                         headRL_post (/.ring head_idL)
                                         headRR_post (/.ring head_idR)]
                                        (/.assert ""
                                                  (let [same_rings? (\ set.equivalence = headRL_post headRR_post)
                                                        expected_size? (n.= (n.* 2 (inc num_connections))
                                                                            (set.size headRL_post))
                                                        union? (\ set.equivalence = headRL_post (set.union headRL_pre headRR_pre))]
                                                    (and same_rings?
                                                         expected_size?
                                                         union?))))))
                ))
          )))
