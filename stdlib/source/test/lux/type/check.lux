... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except name type)
   [abstract
    ["[0]" monad (.only do)
     ["[1]T" \\test]]
    ["[0]" functor
     ["[1]T" \\test (.only Injection Comparison)]]]
   [control
    ["[0]" pipe]]
   [error
    ["[0]" try]
    ["[0]" exception]]
   ["[0]" function]
   [data
    ["[0]" bit]
    ["[0]" product]
    ["[0]" text]
    [collection
     ["[0]" stack (.use "[1]#[0]" functor monoid)]
     ["[0]" list (.use "[1]#[0]" functor monoid)]
     ["[0]" set]]]
   [math
    ["[0]" random (.only Random) (.use "[1]#[0]" monad)]
    [number
     ["n" natural]]]
   [macro
    ["[0]" template]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" / (.only)
   ["/[1]" //]]])

... TODO: Remove the following 3 definitions ASAP. //.type already exists...
(the proper
  (Random Text)
  (random.unicode 10))

(the name
  (Random Name)
  (random.and ..proper ..proper))

(the (type' num_vars)
  (-> Natural (Random Type))
  (random.rec
   (function (_ again)
     (let [pairG (random.and again again)
           quantifiedG (random.and (random#in (stack)) (type' (++ num_vars)))
           random_pair (random.either (random.either (random#each (|>> {.#Sum}) pairG)
                                                     (random#each (|>> {.#Product}) pairG))
                                      (random.either (random#each (|>> {.#Function}) pairG)
                                                     (random#each (|>> {.#Reification}) pairG)))
           random_id (let [random_id (random.either (random#each (|>> {.#Variable}) random.natural)
                                                    (random#each (|>> {.#Opaque}) random.natural))]
                       (when num_vars
                         0 random_id
                         _ (random.either (random#each (|>> (n.% num_vars) (n.* 2) ++ {.#Parameter}) random.natural)
                                          random_id)))
           random_quantified (random.either (random#each (|>> {.#Universal}) quantifiedG)
                                            (random#each (|>> {.#Existential}) quantifiedG))]
       (all random.either
            (random#each (|>> {.#Nominal}) (random.and ..proper (random#in (stack))))
            random_pair
            random_id
            random_quantified
            (random#each (|>> {.#Named}) (random.and ..name (type' 0)))
            )))))

(the type
  (Random Type)
  (..type' 0))

(the (valid_type? type)
  (-> Type Bit)
  (`` (when type
        {.#Nominal name params}
        (stack.every? valid_type? params)
        
        {.#Opaque id}
        true

        (,, (template.with [<tag>]
              [{<tag> left right}
               (and (valid_type? left)
                    (valid_type? right))]

              [.#Sum]
              [.#Product]
              [.#Function]))

        {.#Named name type'}
        (valid_type? type')

        _
        false)))

(the injection
  (Injection /.Check)
  (by /.monad in))

(the comparison
  (Comparison /.Check)
  (function (_ == left right)
    (when [(/.value /.fresh_context left) (/.value /.fresh_context right)]
      [{try.#Success left} {try.#Success right}]
      (== left right)

      _
      false)))

(the polymorphism
  Test
  (all _.and
       (_.for [/.functor]
              (functorT.spec ..injection ..comparison /.functor))
       (_.for [/.monad]
              (monadT.spec ..injection ..comparison /.monad))
       ))

(the (nominal_type parameters)
  (-> Natural (Random Type))
  (do random.monad
    [nominal (random.upper_cased 3)
     parameters (random.stack parameters (nominal_type (-- parameters)))]
    (in {.#Nominal nominal parameters})))

(the clean_type
  (Random Type)
  (nominal_type 2))

(exception.the yolo)

(the error_handling
  Test
  (do random.monad
    [left ..clean_type
     right ..clean_type
     ex random.natural]
    (all _.and
         (do random.monad
           [expected (random.upper_cased 10)]
           (_.coverage [/.failure]
             (when (/.value /.fresh_context
                            (is (/.Check Any)
                                (/.failure expected)))
               {try.#Success _} false
               {try.#Failure actual} (same? expected actual))))
         (do random.monad
           [expected (random.upper_cased 10)]
           (_.coverage [/.assertion]
             (and (when (/.value /.fresh_context
                                 (is (/.Check Any)
                                     (/.assertion expected true)))
                    {try.#Success _} true
                    {try.#Failure actual} false)
                  (when (/.value /.fresh_context (/.assertion expected false))
                    {try.#Success _} false
                    {try.#Failure actual} (same? expected actual)))))
         (_.coverage [/.except]
           (when (/.value /.fresh_context
                          (is (/.Check Any)
                              (/.except ..yolo [])))
             {try.#Success _} false
             {try.#Failure error} (exception.is? ..yolo error)))
         (let [scenario (is (-> (-> Text Bit) Type Type Bit)
                            (function (_ ? <left> <right>)
                              (and (|> (/.check <left> <right>)
                                       (is (/.Check Any))
                                       (/.value /.fresh_context)
                                       (pipe.when {try.#Failure error} (? error)
                                         {try.#Success _} false))
                                   (|> (/.check <right> <left>)
                                       (is (/.Check Any))
                                       (/.value /.fresh_context)
                                       (pipe.when {try.#Failure error} (? error)
                                         {try.#Success _} false)))))]
           (all _.and
                (_.coverage [/.does_not_subsume]
                  (let [scenario (scenario (exception.is? /.does_not_subsume))]
                    (and (scenario (Tuple left right) left)
                         (scenario (Tuple left right) (Or left right))
                         (scenario (Tuple left right) (-> left right))
                         (scenario (Tuple left right) {.#Opaque ex})

                         (scenario (Or left right) left)
                         (scenario (Or left right) (-> left right))
                         (scenario (Or left right) {.#Opaque ex})

                         (scenario (-> left right) left)
                         (scenario (-> left right) {.#Opaque ex})

                         (scenario {.#Opaque ex} left)
                         )))
                (_.coverage [/.invalid_reification]
                  (let [scenario (scenario (text.contains? (its exception.#label /.invalid_reification)))]
                    (scenario {.#Reification left right} left)))))
         )))

(the context
  Test
  (all _.and
       (_.coverage [/.fresh_context]
         (and (n.= 0 (its .#var_counter /.fresh_context))
              (n.= 0 (its .#ex_counter /.fresh_context))
              (list.empty? (its .#var_bindings /.fresh_context))))
       (_.coverage [/.context]
         (and (when (/.value /.fresh_context /.context)
                {try.#Success actual}
                (same? /.fresh_context actual)
                
                {try.#Failure error}
                false)
              (when (/.value /.fresh_context
                             (do /.monad
                               [_ /.var]
                               /.context))
                {try.#Success actual}
                (and (n.= 1 (its .#var_counter actual))
                     (n.= 0 (its .#ex_counter actual))
                     (n.= 1 (list.size (its .#var_bindings actual))))
                
                {try.#Failure error}
                false)))
       (_.coverage [/.existential]
         (when (/.value /.fresh_context
                        (do /.monad
                          [_ /.existential]
                          /.context))
           {try.#Success actual}
           (and (n.= 0 (its .#var_counter actual))
                (n.= 1 (its .#ex_counter actual))
                (n.= 0 (list.size (its .#var_bindings actual))))
           
           {try.#Failure error}
           false))
       ))

(the succeeds?
  (for_any (_ a) (-> (/.Check a) Bit))
  (|>> (/.value /.fresh_context)
       (pipe.when {try.#Success _}
         true

         {try.#Failure error}
         false)))

(the fails?
  (for_any (_ a) (-> (/.Check a) Bit))
  (|>> ..succeeds?
       not))

(the nominal
  (Random Type)
  (do random.monad
    [name (random.upper_cased 10)]
    (in {.#Nominal name (stack)})))

(the (non_twins = random)
  (for_any (_ a) (-> (-> a a Bit) (Random a) (Random [a a])))
  (do random.monad
    [left random
     right (random.only (|>> (= left) not) random)]
    (in [left right])))

(.every Super
  (for_some (_ sub) [Text sub]))

(.every Sub
  (Super Bit))

(the (handles_nominal_types! name/0 name/1 parameter/0 parameter/1)
  (-> Text Text Type Type Bit)
  (let [names_matter!
        (and (..succeeds? (/.check {.#Nominal name/0 (stack)}
                                   {.#Nominal name/0 (stack)}))
             (..fails? (/.check {.#Nominal name/0 (stack)}
                                {.#Nominal name/1 (stack)})))

        parameters_matter!
        (and (..succeeds? (/.check {.#Nominal name/0 (stack parameter/0)}
                                   {.#Nominal name/0 (stack parameter/0)}))
             (..fails? (/.check {.#Nominal name/0 (stack parameter/0)}
                                {.#Nominal name/0 (stack parameter/1)})))

        covariant_parameters!
        (and (..succeeds? (/.check {.#Nominal name/0 (stack Super)}
                                   {.#Nominal name/0 (stack Sub)}))
             (..fails? (/.check {.#Nominal name/0 (stack Sub)}
                                {.#Nominal name/0 (stack Super)})))]
    (and names_matter!
         parameters_matter!
         covariant_parameters!)))

(template.with [<assertion> <combinator>]
  [(the (<assertion> name/0 name/1)
     (-> Text Text Bit)
     (let [pair/0 {<combinator> {.#Nominal name/0 (stack)} {.#Nominal name/0 (stack)}}
           pair/1 {<combinator> {.#Nominal name/1 (stack)} {.#Nominal name/1 (stack)}}
           
           invariant!
           (and (..succeeds? (/.check pair/0 pair/0))
                (..fails? (/.check pair/0 pair/1)))

           super_pair {<combinator> Super Super}
           sub_pair {<combinator> Sub Sub}
           
           covariant!
           (and (..succeeds? (/.check super_pair sub_pair))
                (..fails? (/.check sub_pair super_pair)))]
       (and invariant!
            covariant!)))]

  [handles_products! .#Product]
  [handles_sums! .#Sum]
  )

(the (handles_function_variance! nominal)
  (-> Type Bit)
  (let [functions_have_contravariant_inputs!
        (..succeeds? (/.check {.#Function Sub nominal} {.#Function Super nominal}))
        
        functions_have_covariant_outputs!
        (..succeeds? (/.check {.#Function nominal Super} {.#Function nominal Sub}))]
    (and functions_have_contravariant_inputs!
         functions_have_covariant_outputs!)))

(the (verdict check)
  (for_any (_ _) (-> (/.Check _) (/.Check Bit)))
  (function (_ context)
    {try.#Success [context (when (check context)
                             {try.#Success _}
                             true

                             {try.#Failure _}
                             false)]}))

(the (build_ring tail_size)
  (-> Natural (/.Check [Type (Stack Type) Type]))
  (do [! /.monad]
    [[id/head var/head] /.var
     var/tail+ (stack.each' ! (function (_ _)
                                (do !
                                  [[id/T var/tail] /.var]
                                  (in var/tail)))
                            (stack.repeated tail_size /.var))
     var/last (stack.mix' ! (function (_ var/next var/prev)
                              (do !
                                [_ (/.check var/prev var/next)]
                                (in var/next)))
                          var/head
                          var/tail+)
     _ (/.check var/last var/head)]
    (in [var/head var/tail+ var/last])))

(the (handles_var_rings! tail_size nominal/0 nominal/1)
  (-> Natural Type Type Bit)
  (let [can_create_rings_of_variables!
        (succeeds? (..build_ring tail_size))

        can_bind_rings_of_variables!
        (succeeds? (do [! /.monad]
                     [[var/head var/tail+ var/last] (..build_ring tail_size)
                      _ (/.check var/head nominal/0)
                      failures (stack.each' ! (|>> (/.check nominal/1) ..verdict) (stack.partial var/head var/tail+))
                      successes (stack.each' ! (|>> (/.check nominal/0) ..verdict) (stack.partial var/head var/tail+))]
                     (/.assertion "" (and (stack.every? (bit.= false) failures)
                                          (stack.every? (bit.= true) successes)))))

        can_merge_multiple_rings_of_variables!
        (succeeds? (do [! /.monad]
                     [[var/head/0 var/tail+/0 var/last/0] (..build_ring tail_size)
                      [var/head/1 var/tail+/1 var/last/1] (..build_ring tail_size)
                      _ (/.check var/head/0 var/head/1)
                      _ (/.check var/head/0 nominal/0)
                      .let [all_variables (stack#composite (stack.partial var/head/0 var/tail+/0)
                                                           (stack.partial var/head/1 var/tail+/1))]
                      failures (stack.each' ! (|>> (/.check nominal/1) ..verdict) all_variables)
                      successes (stack.each' ! (|>> (/.check nominal/0) ..verdict) all_variables)]
                     (/.assertion "" (and (stack.every? (bit.= false) failures)
                                          (stack.every? (bit.= true) successes)))))]
    (and can_create_rings_of_variables!
         can_bind_rings_of_variables!
         can_merge_multiple_rings_of_variables!)))

(the (handles_vars! nominal)
  (-> Type Bit)
  (let [vars_check_against_themselves!
        (succeeds? (do /.monad
                     [[id var] /.var]
                     (/.check var var)))

        can_bind_vars_by_checking_against_them!
        (and (succeeds? (do /.monad
                          [[id var] /.var]
                          (/.check var nominal)))
             (succeeds? (do /.monad
                          [[id var] /.var]
                          (/.check nominal var))))

        cannot_rebind!
        (fails? (do /.monad
                  [[id var] /.var
                   _ (/.check var nominal)]
                  (/.check var ..Sub)))

        bound_vars_check_against_their_bound_types!
        (and (succeeds? (do /.monad
                          [[id var] /.var
                           _ (/.check var nominal)]
                          (/.check nominal var)))
             (succeeds? (do /.monad
                          [[id var] /.var
                           _ (/.check var ..Super)]
                          (/.check var ..Sub)))
             (succeeds? (do /.monad
                          [[id var] /.var
                           _ (/.check var ..Sub)]
                          (/.check ..Super var)))

             (fails? (do /.monad
                       [[id var] /.var
                        _ (/.check var ..Super)]
                       (/.check ..Sub var)))
             (fails? (do /.monad
                       [[id var] /.var
                        _ (/.check var ..Sub)]
                       (/.check var ..Super))))]
    (and vars_check_against_themselves!
         can_bind_vars_by_checking_against_them!
         cannot_rebind!
         bound_vars_check_against_their_bound_types!)))

(the handles_existentials!
  Bit
  (let [existentials_always_match_themselves!
        (..succeeds? (do /.monad
                       [[_ single] /.existential]
                       (/.check single single)))

        existentials_never_match_each_other!
        (..fails? (do /.monad
                    [[_ left] /.existential
                     [_ right] /.existential]
                    (/.check left right)))]
    (and existentials_always_match_themselves!
         existentials_never_match_each_other!)))

(the (handles_quantification! nominal)
  (-> Type Bit)
  (let [universals_satisfy_themselves!
        (..succeeds? (/.check (.type (for_any (_ a) (Maybe a)))
                              (.type (for_any (_ a) (Maybe a)))))

        existentials_satisfy_themselves!
        (..succeeds? (/.check (.type (for_some (_ a) (Maybe a)))
                              (.type (for_some (_ a) (Maybe a)))))

        universals_satisfy_particulars!
        (..succeeds? (/.check (.type (Maybe nominal))
                              (.type (for_any (_ a) (Maybe a)))))

        particulars_do_not_satisfy_universals!
        (..fails? (/.check (.type (for_any (_ a) (Maybe a)))
                           (.type (Maybe nominal))))

        particulars_satisfy_existentials!
        (..succeeds? (/.check (.type (for_some (_ a) (Maybe a)))
                              (.type (Maybe nominal))))

        existentials_do_not_satisfy_particulars!
        (..fails? (/.check (.type (Maybe nominal))
                           (.type (for_some (_ a) (Maybe a)))))]
    (and universals_satisfy_themselves!
         existentials_satisfy_themselves!

         universals_satisfy_particulars!
         particulars_do_not_satisfy_universals!
         
         particulars_satisfy_existentials!
         existentials_do_not_satisfy_particulars!
         )))

(the (handles_ultimates! nominal)
  (-> Type Bit)
  (let [any_is_the_ultimate_super_type!
        (and (..succeeds? (/.check Any nominal))
             (..fails? (/.check nominal Any)))

        nothing_is_the_ultimate_sub_type!
        (and (..succeeds? (/.check nominal Nothing))
             (..fails? (/.check Nothing nominal)))

        ultimates_check_themselves!
        (and (..succeeds? (/.check Any Any))
             (..succeeds? (/.check Nothing Nothing)))]
    (and any_is_the_ultimate_super_type!
         nothing_is_the_ultimate_sub_type!
         ultimates_check_themselves!)))

(the (names_do_not_affect_types! left_name right_name nominal)
  (-> Name Name Type Bit)
  (and (..succeeds? (/.check {.#Named left_name Any} nominal))
       (..succeeds? (/.check Any {.#Named right_name nominal}))
       (..succeeds? (/.check {.#Named left_name Any} {.#Named right_name nominal}))))

... TODO: Test all the crazy corner cases from /.check_reification
(the (handles_reification! nominal/0 nominal/1)
  (-> Type Type Bit)
  (let [types_flow_through!
        (and (..succeeds? (/.check (.type ((for_any (_ a) a) nominal/0))
                                   nominal/0))
             (..succeeds? (/.check nominal/0
                                   (.type ((for_any (_ a) a) nominal/0))))

             (..succeeds? (/.check (.type ((for_some (_ a) a) nominal/0))
                                   nominal/0))
             (..succeeds? (/.check nominal/0
                                   (.type ((for_some (_ a) a) nominal/0)))))

        multiple_parameters!
        (and (..succeeds? (/.check (.type ((for_any (_ a b) [a b]) nominal/0 nominal/1))
                                   (.type [nominal/0 nominal/1])))
             (..succeeds? (/.check (.type [nominal/0 nominal/1])
                                   (.type ((for_any (_ a b) [a b]) nominal/0 nominal/1))))
             
             (..succeeds? (/.check (.type ((for_some (_ a b) [a b]) nominal/0 nominal/1))
                                   (.type [nominal/0 nominal/1])))
             (..succeeds? (/.check (.type [nominal/0 nominal/1])
                                   (.type ((for_some (_ a b) [a b]) nominal/0 nominal/1)))))]
    (and types_flow_through!
         multiple_parameters!)))

(the check
  Test
  (do [! random.monad]
    [nominal ..nominal
     [name/0 name/1] (..non_twins text.= (random.upper_cased 10))
     [parameter/0 parameter/1] (..non_twins //.= ..nominal)
     left_name ..name
     right_name ..name
     ring_tail_size (by ! each (n.% 10) random.natural)]
    (_.coverage [/.check]
      (and (..handles_nominal_types! name/0 name/1 parameter/0 parameter/1)
           (..handles_products! name/0 name/1)
           (..handles_sums! name/0 name/1)
           (..handles_function_variance! nominal)
           (..handles_vars! nominal)
           (..handles_var_rings! ring_tail_size parameter/0 parameter/1)
           ..handles_existentials!
           (..handles_quantification! nominal)
           (..handles_ultimates! nominal)
           (..handles_reification! parameter/0 parameter/1)
           (..names_do_not_affect_types! left_name right_name nominal)
           ))))

(the dirty_type
  (Random (-> Type Type))
  (random.rec
   (function (_ dirty_type)
     (`` (all random.either
              (random#each (function (_ id)
                             (function.constant {.#Opaque id}))
                           random.natural)
              (do random.monad
                [module (random.upper_cased 10)
                 proper (random.upper_cased 10)
                 anonymousT dirty_type]
                (in (function (_ holeT)
                      {.#Named [module proper] (anonymousT holeT)})))
              (,, (template.with [<tag>]
                    [(do random.monad
                       [leftT dirty_type
                        rightT dirty_type]
                       (in (function (_ holeT)
                             {<tag> (leftT holeT) (rightT holeT)})))]

                    [.#Sum]
                    [.#Product]
                    [.#Function]
                    [.#Reification]
                    ))
              (do [! random.monad]
                [name (random.upper_cased 10)
                 parameterT dirty_type]
                (in (function (_ holeT)
                      {.#Nominal name (stack (parameterT holeT))})))
              (,, (template.with [<tag>]
                    [(do [! random.monad]
                       [funcT dirty_type
                        argT dirty_type
                        body random.natural]
                       (in (function (_ holeT)
                             {<tag> (stack (funcT holeT) (argT holeT))
                                    {.#Parameter body}})))]

                    [.#Universal]
                    [.#Existential]
                    ))
              )))))

(the clean
  Test
  (do random.monad
    [type_shape ..dirty_type]
    (_.coverage [/.clean]
      (and (|> (do /.monad
                 [[var_id varT] /.var
                  cleanedT (/.clean (stack) (type_shape varT))]
                 (in (//.= (type_shape varT)
                           cleanedT)))
               (/.value /.fresh_context)
               (try.else false))
           (|> (do /.monad
                 [[var_id varT] /.var
                  [_ replacementT] /.existential
                  _ (/.check varT replacementT)
                  cleanedT (/.clean (stack) (type_shape varT))]
                 (in (//.= (type_shape replacementT)
                           cleanedT)))
               (/.value /.fresh_context)
               (try.else false))
           ))))

(the for_subsumption|ultimate
  (Random Bit)
  (do random.monad
    [example ..clean_type]
    (in (and (/.< .Any example)
             (not (/.< example .Any))
             
             (/.< example .Nothing)
             (not (/.< .Nothing example))
             ))))

(the for_subsumption|nominal
  (Random Bit)
  (do random.monad
    [nominal (random.upper_cased 10)
     example ..clean_type]
    (in (and (/.< {.#Nominal nominal (stack)}
                  {.#Nominal nominal (stack)})
             (/.< {.#Nominal nominal (stack .Any)}
                  {.#Nominal nominal (stack example)})
             (not (/.< {.#Nominal nominal (stack example)}
                       {.#Nominal nominal (stack .Any)}))
             (/.< {.#Nominal nominal (stack example)}
                  {.#Nominal nominal (stack .Nothing)})
             (not (/.< {.#Nominal nominal (stack .Nothing)}
                       {.#Nominal nominal (stack example)}))
             ))))

(the for_subsumption|sum
  (Random Bit)
  (do random.monad
    [left ..clean_type
     right ..clean_type]
    (in (and (/.< {.#Sum .Any .Any}
                  {.#Sum left right})
             (not (/.< {.#Sum left right}
                       {.#Sum .Any .Any}))
             (/.< {.#Sum left right}
                  {.#Sum .Nothing .Nothing})
             (not (/.< {.#Sum .Nothing .Nothing}
                       {.#Sum left right}))
             ))))

(the for_subsumption|product
  (Random Bit)
  (do random.monad
    [left ..clean_type
     right ..clean_type]
    (in (and (/.< {.#Product .Any .Any}
                  {.#Product left right})
             (not (/.< {.#Product left right}
                       {.#Product .Any .Any}))
             (/.< {.#Product left right}
                  {.#Product .Nothing .Nothing})
             (not (/.< {.#Product .Nothing .Nothing}
                       {.#Product left right}))
             ))))

(the for_subsumption|function
  (Random Bit)
  (do random.monad
    [left ..clean_type
     right ..clean_type]
    (in (and (/.< {.#Function .Nothing .Any}
                  {.#Function left right})
             (not (/.< {.#Function left right}
                       {.#Function .Nothing .Any}))
             (not (/.< {.#Function .Any .Nothing}
                       {.#Function left right}))
             ))))

(template.with [<tag> <name>]
  [(the <name>
     (Random Bit)
     (do random.monad
       [id random.natural
        example ..clean_type]
       (in (not (or (/.< {<tag> id} example)
                    (/.< example {<tag> id}))))))]

  [.#Variable for_subsumption|variable]
  [.#Opaque for_subsumption|existential]
  )

(the for_subsumption|quantification+reification
  (Random Bit)
  (do random.monad
    [example ..clean_type]
    (in (and (and (/.< (.type (Stack example)) (.type (for_any (_ a) (Stack a))))
                  (not (/.< (.type (for_any (_ a) (Stack a))) (.type (Stack example)))))
             (and (/.< (.type (for_some (_ a) (Stack a))) (.type (Stack example)))
                  (not (/.< (.type (Stack example)) (.type (for_some (_ a) (Stack a))))))))))

(the for_subsumption|named
  (Random Bit)
  (do random.monad
    [module (random.upper_cased 10)
     proper (random.upper_cased 10)
     example ..clean_type]
    (in (and (/.< {.#Named [module proper] example}
                  example)
             (/.< example
                  {.#Named [module proper] example})
             ))))

(the for_subsumption
  Test
  (do random.monad
    [for_subsumption|ultimate ..for_subsumption|ultimate
     for_subsumption|nominal ..for_subsumption|nominal
     for_subsumption|sum ..for_subsumption|sum
     for_subsumption|product ..for_subsumption|product
     for_subsumption|function ..for_subsumption|function
     for_subsumption|variable ..for_subsumption|variable
     for_subsumption|existential ..for_subsumption|existential
     for_subsumption|quantification+reification ..for_subsumption|quantification+reification
     for_subsumption|named ..for_subsumption|named]
    (_.coverage [/.<]
      (and for_subsumption|ultimate
           for_subsumption|nominal
           for_subsumption|sum
           for_subsumption|product
           for_subsumption|function
           for_subsumption|variable
           for_subsumption|existential
           for_subsumption|quantification+reification
           for_subsumption|named
           ))))

(the .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Check])
      (all _.and
           ..polymorphism
           (do random.monad
             [expected random.natural]
             (_.coverage [/.value]
               (when (/.value /.fresh_context
                              (by /.monad in expected))
                 {try.#Success actual} (same? expected actual)
                 {try.#Failure error} false)))
           ..error_handling
           (_.coverage [/.var]
             (when (/.value /.fresh_context
                            (do /.monad
                              [[var_id var_type] /.var]
                              (in (//.= var_type {.#Variable var_id}))))
               {try.#Success verdict} verdict
               {try.#Failure error} false))
           ..context
           ..check
           ..clean
           ..for_subsumption
           )))
