(.module:
  [library
   [lux #*
    ["_" test (#+ Test)]
    ["." meta]
    [abstract
     ["." monad
      [indexed (#+ do)]]]
    [control
     ["." io (#+ IO)]
     ["." try]
     ["." exception (#+ Exception)]
     [concurrency
      ["." async (#+ Async)]]
     [parser
      ["<.>" code]]]
    [data
     ["." identity (#+ Identity)]
     ["." text ("#\." equivalence)
      ["%" format (#+ format)]]]
    ["." macro
     [syntax (#+ syntax:)]
     ["." code]]
    [math
     ["." random]]]]
  [\\library
   ["." / (#+ Res)]])

(def: pure
  Test
  (monad.do {! random.monad}
    [pre (\ ! map %.nat random.nat)
     post (\ ! map %.nat random.nat)
     .let [! identity.monad]]
    (_.for [/.Linear /.run! /.monad]
           (`` ($_ _.and
                   (~~ (template [<coverage> <bindings>]
                         [(_.cover <coverage>
                                   (<| (text\= (format pre post))
                                       (: (Identity Text))
                                       (/.run! !)
                                       (do (/.monad !)
                                         <bindings>
                                         (in (format left right)))))]
                         
                         [[/.Affine /.Key /.Res /.Ordered /.ordered
                           /.Relevant /.read]
                          [res|left (/.ordered ! pre)
                           res|right (/.ordered ! post)
                           right (/.read ! res|right)
                           left (/.read ! res|left)]]
                         [[/.Commutative /.commutative /.exchange]
                          [res|left (/.commutative ! pre)
                           res|right (/.commutative ! post)
                           _ ((/.exchange [1 0]) !)
                           left (/.read ! res|left)
                           right (/.read ! res|right)]]
                         [[/.group /.un_group]
                          [res|left (/.commutative ! pre)
                           res|right (/.commutative ! post)
                           _ ((/.group 2) !)
                           _ ((/.un_group 2) !)
                           right (/.read ! res|right)
                           left (/.read ! res|left)]]
                         [[/.lifted]
                          [left (/.lifted ! pre)
                           right (/.lifted ! post)]]
                         ))
                   )))))

(def: sync
  Test
  (monad.do {! random.monad}
    [pre (\ ! map %.nat random.nat)
     post (\ ! map %.nat random.nat)
     .let [! io.monad]]
    (_.for [/.Linear /.run! /.monad]
           (`` ($_ _.and
                   (~~ (template [<coverage> <bindings>]
                         [(_.cover <coverage>
                                   (<| (text\= (format pre post))
                                       io.run!
                                       (: (IO Text))
                                       (/.run! !)
                                       (do (/.monad !)
                                         <bindings>
                                         (in (format left right)))))]

                         [[/.Affine /.Key /.Res /.Ordered /.ordered
                           /.Relevant /.read]
                          [res|left (/.ordered ! pre)
                           res|right (/.ordered ! post)
                           right (/.read ! res|right)
                           left (/.read ! res|left)]]
                         [[/.Commutative /.commutative /.exchange]
                          [res|left (/.commutative ! pre)
                           res|right (/.commutative ! post)
                           _ ((/.exchange [1 0]) !)
                           left (/.read ! res|left)
                           right (/.read ! res|right)]]
                         [[/.group /.un_group]
                          [res|left (/.commutative ! pre)
                           res|right (/.commutative ! post)
                           _ ((/.group 2) !)
                           _ ((/.un_group 2) !)
                           right (/.read ! res|right)
                           left (/.read ! res|left)]]
                         [[/.lifted]
                          [left (/.lifted ! (io.io pre))
                           right (/.lifted ! (io.io post))]]
                         ))
                   )))))

(def: async
  Test
  (monad.do {! random.monad}
    [pre (\ ! map %.nat random.nat)
     post (\ ! map %.nat random.nat)
     .let [! async.monad]]
    (_.for [/.Linear /.run! /.monad]
           (`` ($_ _.and
                   (~~ (template [<coverage> <bindings>]
                         [(in (monad.do !
                                [outcome (<| (: (Async Text))
                                             (/.run! !)
                                             (do (/.monad !)
                                               <bindings>
                                               (in (format left right))))]
                                (_.cover' <coverage>
                                          (text\= (format pre post)
                                                  outcome))))]

                         [[/.Affine /.Key /.Res /.Ordered /.ordered
                           /.Relevant /.read]
                          [res|left (/.ordered ! pre)
                           res|right (/.ordered ! post)
                           right (/.read ! res|right)
                           left (/.read ! res|left)]]
                         [[/.Commutative /.commutative /.exchange]
                          [res|left (/.commutative ! pre)
                           res|right (/.commutative ! post)
                           _ ((/.exchange [1 0]) !)
                           left (/.read ! res|left)
                           right (/.read ! res|right)]]
                         [[/.group /.un_group]
                          [res|left (/.commutative ! pre)
                           res|right (/.commutative ! post)
                           _ ((/.group 2) !)
                           _ ((/.un_group 2) !)
                           right (/.read ! res|right)
                           left (/.read ! res|left)]]
                         [[/.lifted]
                          [left (/.lifted ! (async.resolved pre))
                           right (/.lifted ! (async.resolved post))]]
                         ))
                   )))))

(syntax: (with_error {exception <code>.identifier} to_expand)
  (monad.do meta.monad
    [[_ _ _ exception] (meta.export exception)]
    (function (_ compiler)
      (#.Right [compiler
                (list (code.bit (case ((macro.single_expansion to_expand) compiler)
                                  (#try.Success _)
                                  false
                                  
                                  (#try.Failure error)
                                  true)))]))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Procedure])
      ($_ _.and
          ..pure
          ..sync
          ..async

          (_.cover [/.amount_cannot_be_zero]
                   (`` (and (~~ (template [<group|un_group>]
                                  [(with_error /.amount_cannot_be_zero
                                     (<group|un_group> 0))]

                                  [/.group]
                                  [/.un_group]
                                  )))))
          (_.cover [/.index_cannot_be_repeated]
                   (with_error /.index_cannot_be_repeated
                     (/.exchange [0 0])))
          )))
