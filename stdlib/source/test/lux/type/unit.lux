(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   ["[0]" debug]
   ["[0]" meta]
   [abstract
    [monad {"+" do}]
    [equivalence {"+" Equivalence}]
    [\\specification
     ["$[0]" equivalence]
     ["$[0]" order]
     ["$[0]" enum]]]
   [macro
    [syntax {"+" syntax:}]
    ["[0]" code]]
   [math
    ["[0]" random {"+" Random}]
    [number
     ["i" int]
     ["[0]" ratio ("[1]#[0]" equivalence)]]]]]
 [\\library
  ["[0]" /]])

(template [<name> <type> <unit>]
  [(def: (<name> range)
     (-> Nat (Random (/.Qty <type>)))
     (|> random.int
         (# random.monad each (i.% (.int range)))
         (random.only (|>> (i.= +0) not))
         (# random.monad each (# <unit> in))))]

  [meter /.Meter /.meter]
  [second /.Second /.second]
  )

(def: polymorphism
  Test
  ($_ _.and
      (_.for [/.equivalence]
             ($equivalence.spec /.equivalence (..meter 1,000)))
      (_.for [/.order]
             ($order.spec /.order (..meter 1,000)))
      (_.for [/.enum]
             ($enum.spec /.enum (..meter 1,000)))
      ))

(/.unit: What what)

(def: unit
  Test
  (do random.monad
    [expected random.int]
    (_.for [/.Unit]
           (`` ($_ _.and
                   (~~ (template [<type> <unit>]
                         [(_.cover [<type> <unit>]
                                   (|> expected
                                       (# <unit> in)
                                       (# <unit> out)
                                       (i.= expected)))]

                         [/.Gram /.gram]
                         [/.Meter /.meter]
                         [/.Litre /.litre]
                         [/.Second /.second]
                         ))
                   (_.cover [/.Pure /.pure /.number]
                            (|> expected
                                /.pure
                                /.number
                                (i.= expected)))
                   (_.cover [/.unit:]
                            (|> expected
                                (# ..what in)
                                (# ..what out)
                                (i.= expected)))
                   )))))

(syntax: (natural [])
  (# meta.monad each
     (|>> code.nat list)
     meta.seed))

(with_expansions [<from> (..natural)
                  <to> (..natural)]
  (/.scale: How how
    [<from> <to>])

  (def: how::from <from>)
  (def: how::to <to>)
  )

(def: scale
  Test
  (do [! random.monad]
    [small (|> random.int
               (# ! each (i.% +1,000))
               (# ! each (# /.meter in)))
     large (|> random.int
               (# ! each (i.% +1,000))
               (# ! each (i.* +1,000,000,000))
               (# ! each (# /.meter in)))
     .let [(open "meter#[0]") (is (Equivalence (/.Qty /.Meter))
                                  /.equivalence)]
     unscaled (|> random.int
                  (# ! each (i.% +1,000))
                  (# ! each (i.* (.int how::to)))
                  (# ! each (# /.meter in)))]
    (_.for [/.Scale]
           (`` ($_ _.and
                   (~~ (template [<type> <scale>]
                         [(_.cover [<type> <scale>]
                                   (|> large
                                       (# <scale> scale)
                                       (is (/.Qty (<type> /.Meter)))
                                       (# <scale> de_scale)
                                       (is (/.Qty /.Meter))
                                       (meter#= large)))]

                         [/.Kilo /.kilo]
                         [/.Mega /.mega]
                         [/.Giga /.giga]
                         ))
                   (~~ (template [<type> <scale>]
                         [(_.cover [<type> <scale>]
                                   (|> small
                                       (# <scale> scale)
                                       (is (/.Qty (<type> /.Meter)))
                                       (# <scale> de_scale)
                                       (is (/.Qty /.Meter))
                                       (meter#= small)))]

                         [/.Milli /.milli]
                         [/.Micro /.micro]
                         [/.Nano /.nano]
                         ))
                   (_.cover [/.re_scaled]
                            (|> large (is (/.Qty /.Meter))
                                (# /.kilo scale) (is (/.Qty (/.Kilo /.Meter)))
                                (/.re_scaled /.kilo /.milli) (is (/.Qty (/.Milli /.Meter)))
                                (/.re_scaled /.milli /.kilo) (is (/.Qty (/.Kilo /.Meter)))
                                (# /.kilo de_scale) (is (/.Qty /.Meter))
                                (meter#= large)))
                   (_.cover [/.scale:]
                            (and (|> unscaled
                                     (# ..how scale)
                                     (# ..how de_scale)
                                     (meter#= unscaled))
                                 (ratio#= [..how::from
                                           ..how::to]
                                          (# ..how ratio))))
                   )))))

(def: arithmetic
  Test
  (do random.monad
    [.let [zero (# /.meter in +0)
           (open "meter#[0]") (is (Equivalence (/.Qty /.Meter))
                                  /.equivalence)]
     left (random.only (|>> (meter#= zero) not) (..meter 1,000))
     right (..meter 1,000)
     extra (..second 1,000)]
    (`` ($_ _.and
            (~~ (template [<q> <i>]
                  [(_.cover [<q>]
                            (i.= (<i> (# /.meter out left) (# /.meter out right))
                                 (# /.meter out (<q> left right))))]

                  [/.+ i.+]
                  [/.- i.-]
                  ))
            (_.cover [/.*]
                     (let [expected (i.* (# /.meter out left) (# /.meter out right))
                           actual ((debug.private /.out') (is (/.Qty [/.Meter /.Meter])
                                                              (/.* left right)))]
                       (i.= expected actual)))
            (_.cover [/./]
                     (|> right
                         (/.* left)
                         (/./ left)
                         (meter#= right)))
            ))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Qty])
      ($_ _.and
          ..polymorphism
          ..unit
          ..scale
          ..arithmetic
          )))
