(.using
 [library
  [lux (.except)
   ["_" test (.only Test)]
   ["[0]" debug]
   ["[0]" meta]
   [abstract
    [monad (.only do)]
    [equivalence (.only Equivalence)]
    [\\specification
     ["$[0]" equivalence]
     ["$[0]" order]
     ["$[0]" enum]]]
   [macro
    [syntax (.only syntax)]
    ["[0]" code]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["i" int]
     ["[0]" ratio (.open: "[1]#[0]" equivalence)]]]]]
 [\\library
  ["[0]" /]])

(with_template [<name> <type> <unit>]
  [(def: (<name> range)
     (-> Nat (Random (/.Qty <type>)))
     (|> random.int
         (at random.monad each (i.% (.int range)))
         (random.only (|>> (i.= +0) not))
         (at random.monad each (at <unit> in))))]

  [meter /.Meter /.meter]
  [second /.Second /.second]
  )

(def: polymorphism
  Test
  (all _.and
       (_.for [/.equivalence]
              ($equivalence.spec /.equivalence (..meter 1,000)))
       (_.for [/.order]
              ($order.spec /.order (..meter 1,000)))
       (_.for [/.enum]
              ($enum.spec /.enum (..meter 1,000)))
       ))

(/.unit: What what)

(def: unit
  Test
  (do random.monad
    [expected random.int]
    (_.for [/.Unit]
           (`` (all _.and
                    (~~ (with_template [<type> <unit>]
                          [(_.coverage [<type> <unit>]
                             (|> expected
                                 (at <unit> in)
                                 (at <unit> out)
                                 (i.= expected)))]

                          [/.Gram /.gram]
                          [/.Meter /.meter]
                          [/.Litre /.litre]
                          [/.Second /.second]
                          ))
                    (_.coverage [/.Pure /.pure /.number]
                      (|> expected
                          /.pure
                          /.number
                          (i.= expected)))
                    (_.coverage [/.unit:]
                      (|> expected
                          (at ..what in)
                          (at ..what out)
                          (i.= expected)))
                    )))))

(def: natural
  (syntax (_ [])
    (at meta.monad each
        (|>> code.nat list)
        meta.seed)))

(with_expansions [<from> (..natural)
                  <to> (..natural)]
  (/.scale: How how
    [<from> <to>])

  (def: how::from <from>)
  (def: how::to <to>)
  )

(def: scale
  Test
  (do [! random.monad]
    [small (|> random.int
               (at ! each (i.% +1,000))
               (at ! each (at /.meter in)))
     large (|> random.int
               (at ! each (i.% +1,000))
               (at ! each (i.* +1,000,000,000))
               (at ! each (at /.meter in)))
     .let [(open "meter#[0]") (is (Equivalence (/.Qty /.Meter))
                                  /.equivalence)]
     unscaled (|> random.int
                  (at ! each (i.% +1,000))
                  (at ! each (i.* (.int how::to)))
                  (at ! each (at /.meter in)))]
    (_.for [/.Scale]
           (`` (all _.and
                    (~~ (with_template [<type> <scale>]
                          [(_.coverage [<type> <scale>]
                             (|> large
                                 (at <scale> scale)
                                 (is (/.Qty (<type> /.Meter)))
                                 (at <scale> de_scale)
                                 (is (/.Qty /.Meter))
                                 (meter#= large)))]

                          [/.Kilo /.kilo]
                          [/.Mega /.mega]
                          [/.Giga /.giga]
                          ))
                    (~~ (with_template [<type> <scale>]
                          [(_.coverage [<type> <scale>]
                             (|> small
                                 (at <scale> scale)
                                 (is (/.Qty (<type> /.Meter)))
                                 (at <scale> de_scale)
                                 (is (/.Qty /.Meter))
                                 (meter#= small)))]

                          [/.Milli /.milli]
                          [/.Micro /.micro]
                          [/.Nano /.nano]
                          ))
                    (_.coverage [/.re_scaled]
                      (|> large (is (/.Qty /.Meter))
                          (at /.kilo scale) (is (/.Qty (/.Kilo /.Meter)))
                          (/.re_scaled /.kilo /.milli) (is (/.Qty (/.Milli /.Meter)))
                          (/.re_scaled /.milli /.kilo) (is (/.Qty (/.Kilo /.Meter)))
                          (at /.kilo de_scale) (is (/.Qty /.Meter))
                          (meter#= large)))
                    (_.coverage [/.scale:]
                      (and (|> unscaled
                               (at ..how scale)
                               (at ..how de_scale)
                               (meter#= unscaled))
                           (ratio#= [..how::from
                                     ..how::to]
                                    (at ..how ratio))))
                    )))))

(def: arithmetic
  Test
  (do random.monad
    [.let [zero (at /.meter in +0)
           (open "meter#[0]") (is (Equivalence (/.Qty /.Meter))
                                  /.equivalence)]
     left (random.only (|>> (meter#= zero) not) (..meter 1,000))
     right (..meter 1,000)
     extra (..second 1,000)]
    (`` (all _.and
             (~~ (with_template [<q> <i>]
                   [(_.coverage [<q>]
                      (i.= (<i> (at /.meter out left) (at /.meter out right))
                           (at /.meter out (<q> left right))))]

                   [/.+ i.+]
                   [/.- i.-]
                   ))
             (_.coverage [/.*]
               (let [expected (i.* (at /.meter out left) (at /.meter out right))
                     actual ((debug.private /.out') (is (/.Qty [/.Meter /.Meter])
                                                        (/.* left right)))]
                 (i.= expected actual)))
             (_.coverage [/./]
               (|> right
                   (/.* left)
                   (/./ left)
                   (meter#= right)))
             ))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Qty])
      (all _.and
           ..polymorphism
           ..unit
           ..scale
           ..arithmetic
           )))
