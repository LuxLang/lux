(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    [abstract
     ["." monad {"+" [do]}]
     [\\specification
      ["$." equivalence]]]
    [control
     [pipe {"+" [case>]}]
     ["." maybe]]
    [data
     ["." bit ("#\." equivalence)]
     ["." text ("#\." equivalence)]
     [collection
      ["." list]
      ["." array]]]
    [macro
     ["." code ("#\." equivalence)]]
    [math
     ["." random {"+" [Random]} ("#\." monad)]
     [number
      ["n" nat]]]]]
  [\\library
   ["." / ("#\." equivalence)]]
  ["." / "_"
   ["#." abstract]
   ["#." check]
   ["#." dynamic]
   ["#." implicit]
   ["#." poly]
   ["#." quotient]
   ["#." refinement]
   ["#." resource]
   ["#." unit]
   ["#." variance]])

(def: short
  (Random Text)
  (do {! random.monad}
    [size (|> random.nat (\ ! each (n.% 10)))]
    (random.unicode size)))

(def: name
  (Random Name)
  (random.and ..short ..short))

(def: (random' parameters)
  (-> Nat (Random Type))
  (random.rec
   (function (_ recur)
     (let [pairG (random.and recur recur)
           un_parameterized (: (Random Type)
                               ($_ random.either
                                   (random\each (|>> #.Primitive) (random.and ..short (random.list 0 recur)))
                                   (random\each (|>> #.Primitive) (random.and ..short (random.list 1 recur)))
                                   (random\each (|>> #.Primitive) (random.and ..short (random.list 2 recur)))
                                   (random\each (|>> #.Sum) pairG)
                                   (random\each (|>> #.Product) pairG)
                                   (random\each (|>> #.Function) pairG)
                                   ))]
       (case parameters
         0 un_parameterized
         _ (|> random.nat
               (random\each (|>> (n.% parameters) #.Parameter))
               (random.either un_parameterized)))))))

(def: .public (random parameters)
  (-> Nat (Random Type))
  ($_ random.either
      (random\each (/.univ_q parameters) (random' parameters))
      (random\each (/.ex_q parameters) (random' parameters))
      ))

(def: .public test
  Test
  (<| (_.covering /._)
      ($_ _.and
          (_.for [/.equivalence]
                 ($equivalence.spec /.equivalence (..random 0)))
          
          (do {! random.monad}
            [anonymousT (random.only (|>> (case> (#.Named _ _) false
                                                 _ true))
                                     (..random 0))
             name/0 ..name
             name/1 ..name
             .let [namedT (#.Named name/0 anonymousT)
                   aliasedT (#.Named name/1 namedT)]]
            ($_ _.and
                (_.cover [/.de_aliased]
                         (\ /.equivalence = namedT (/.de_aliased aliasedT)))
                (_.cover [/.anonymous]
                         (\ /.equivalence = anonymousT (/.anonymous aliasedT)))))
          (do {! random.monad}
            [size (|> random.nat (\ ! each (n.% 3)))
             members (|> (..random 0)
                         (random.only (function (_ type)
                                        (case type
                                          (^or (#.Sum _) (#.Product _))
                                          #0

                                          _
                                          #1)))
                         (list.repeated size)
                         (monad.all !))
             .let [(^open "/\.") /.equivalence
                   (^open "list\.") (list.equivalence /.equivalence)]]
            (`` ($_ _.and
                    (~~ (template [<ctor> <dtor> <unit>]
                          [(_.cover [<ctor> <dtor>]
                                    (let [flat (|> members <ctor> <dtor>)]
                                      (or (list\= members flat)
                                          (and (list\= (list) members)
                                               (list\= (list <unit>) flat)))))]

                          [/.variant /.flat_variant Nothing]
                          [/.tuple   /.flat_tuple   Any]
                          ))
                    )))
          (_.cover [/.applied]
                   (and (<| (maybe.else #0)
                            (do maybe.monad
                              [partial (/.applied (list Bit) Ann)
                               full (/.applied (list Int) partial)]
                              (in (\ /.equivalence = full (#.Product Bit Int)))))
                        (|> (/.applied (list Bit) Text)
                            (case> #.None #1 _ #0))))
          (do {! random.monad}
            [size (|> random.nat (\ ! each (n.% 3)))
             members (monad.all ! (list.repeated size (..random 0)))
             extra (|> (..random 0)
                       (random.only (function (_ type)
                                      (case type
                                        (^or (#.Function _) (#.Apply _))
                                        #0

                                        _
                                        #1))))
             .let [(^open "/\.") /.equivalence
                   (^open "list\.") (list.equivalence /.equivalence)]]
            ($_ _.and
                (_.cover [/.function /.flat_function]
                         (let [[inputs output] (|> (/.function members extra) /.flat_function)]
                           (and (list\= members inputs)
                                (/\= extra output))))
                (_.cover [/.application /.flat_application]
                         (let [[tfunc tparams] (|> extra (/.application members) /.flat_application)]
                           (n.= (list.size members) (list.size tparams))))
                ))
          (do {! random.monad}
            [size (|> random.nat (\ ! each (|>> (n.% 3) ++)))
             body_type (|> (..random 0)
                           (random.only (function (_ type)
                                          (case type
                                            (^or (#.UnivQ _) (#.ExQ _))
                                            #0

                                            _
                                            #1))))
             .let [(^open "/\.") /.equivalence]]
            (`` ($_ _.and
                    (~~ (template [<ctor> <dtor>]
                          [(_.cover [<ctor> <dtor>]
                                    (let [[flat_size flat_body] (|> body_type (<ctor> size) <dtor>)]
                                      (and (n.= size flat_size)
                                           (/\= body_type flat_body))))]

                          [/.univ_q /.flat_univ_q]
                          [/.ex_q   /.flat_ex_q]
                          ))
                    (_.cover [/.quantified?]
                             (and (not (/.quantified? body_type))
                                  (|> body_type (/.univ_q size) /.quantified?)
                                  (|> body_type (/.ex_q size) /.quantified?)))
                    )))
          (do {! random.monad}
            [depth (|> random.nat (\ ! each (|>> (n.% 3) ++)))
             element_type (|> (..random 0)
                              (random.only (function (_ type)
                                             (case type
                                               (^ (#.Primitive name (list element_type)))
                                               (not (text\= array.type_name name))

                                               _
                                               #1))))
             .let [(^open "/\.") /.equivalence]]
            ($_ _.and
                (_.cover [/.array /.flat_array]
                         (let [[flat_depth flat_element] (|> element_type (/.array depth) /.flat_array)]
                           (and (n.= depth flat_depth)
                                (/\= element_type flat_element))))
                (_.cover [/.array?]
                         (and (not (/.array? element_type))
                              (/.array? (/.array depth element_type))))
                ))
          (_.cover [/.:by_example]
                   (let [example (: (Maybe Nat)
                                    #.None)]
                     (/\= (.type (List Nat))
                          (/.:by_example [a]
                                         (Maybe a)
                                         example
                                         
                                         (List a)))))
          (do random.monad
            [sample random.nat]
            (_.cover [/.:log!]
                     (exec
                       (/.:log! sample)
                       true)))
          (do random.monad
            [left random.nat
             right (random.ascii/lower 1)
             .let [left,right [left right]]]
            (_.cover [/.:as]
                     (|> left,right
                         (/.:as [l r] (And l r) (Or l r))
                         (/.:as [l r] (Or l r) (And l r))
                         (same? left,right))))
          (do random.monad
            [expected random.nat]
            (_.cover [/.:sharing]
                     (n.= expected
                          (/.:sharing [a]
                                      (I64 a)
                                      expected

                                      (I64 a)
                                      (.i64 expected)))))
          (do random.monad
            [.let [(^open "/\.") /.equivalence]
             left (..random 0)
             right (..random 0)]
            ($_ _.and
                (_.cover [/.code]
                         (bit\= (/\= left right)
                                (code\= (/.code left) (/.code right))))
                (_.cover [/.format]
                         (bit\= (/\= left right)
                                (text\= (/.format left) (/.format right))))
                ))

          /abstract.test
          /check.test
          /dynamic.test
          /implicit.test
          /poly.test
          /quotient.test
          /refinement.test
          /resource.test
          /unit.test
          /variance.test
          )))
