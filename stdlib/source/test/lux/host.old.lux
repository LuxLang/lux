(.module:
  [lux #*
   [abstract/monad (#+ Monad do)]
   [control
    pipe]
   [data
    ["." text ("#\." equivalence)]
    [number
     ["n" nat]
     ["i" int]]]
   [math
    ["r" random]]
   ["_" test (#+ Test)]]
  {1
   ["." / (#+ import: class: interface: object)]})

(import: (java/util/concurrent/Callable a))

(import: java/lang/Object)
(import: java/lang/String)

(import: java/lang/Exception
  ["#::."
   (new [java/lang/String])])

(import: java/lang/Runnable)

(import: (java/lang/Class a)
  ["#::."
   (getName [] java/lang/String)])

(import: java/lang/System
  ["#::."
   (#static out java/io/PrintStream)
   (#static currentTimeMillis [] #io long)
   (#static getenv [java/lang/String] #io #? java/lang/String)])

(class: #final (TestClass A) [java/lang/Runnable]
  ## Fields
  (#private foo boolean)
  (#private bar A)
  (#private baz java/lang/Object)
  ## Methods
  (#public [] (new {value A}) []
           (exec (:= ::foo #1)
             (:= ::bar value)
             (:= ::baz "")
             []))
  (#public (virtual self) java/lang/Object
           "")
  (#public #static (static) java/lang/Object
           "")
  (java/lang/Runnable [] (run self) void
                      []))

(def: test-runnable
  (object [] [java/lang/Runnable]
    []
    (java/lang/Runnable [] (run self) void
                        [])))

(def: test-callable
  (object [a] [(java/util/concurrent/Callable a)]
    []
    (java/util/concurrent/Callable [] (call self) a
                                   (undefined))))

(interface: TestInterface
  ([] foo [boolean java/lang/String] void #throws [java/lang/Exception]))

(def: conversions
  Test
  (do r.monad
    [sample r.int]
    (`` ($_ _.and
            (~~ (template [<to> <from> <message>]
                  [(_.test <message>
                           (or (|> sample <to> <from> (i.= sample))
                               (let [capped-sample (|> sample <to> <from>)]
                                 (|> capped-sample <to> <from> (i.= capped-sample)))))]

                  [/.long-to-byte /.byte-to-long "Can succesfully convert to/from byte."]
                  [/.long-to-short /.short-to-long "Can succesfully convert to/from short."]
                  [/.long-to-int /.int-to-long "Can succesfully convert to/from int."]
                  [/.long-to-float /.float-to-long "Can succesfully convert to/from float."]
                  [/.long-to-double /.double-to-long "Can succesfully convert to/from double."]
                  [(<| /.int-to-char /.long-to-int) (<| /.int-to-long /.char-to-int) "Can succesfully convert to/from char."]
                  ))
            ))))

(def: miscellaneous
  Test
  (do r.monad
    [sample (r.ascii 1)]
    ($_ _.and
        (_.test "Can check if an object is of a certain class."
                (and (case (/.check java/lang/String sample) (#.Some _) true #.None false)
                     (case (/.check java/lang/Long sample) (#.Some _) false #.None true)
                     (case (/.check java/lang/Object sample) (#.Some _) true #.None false)
                     (case (/.check java/lang/Object (/.null)) (#.Some _) false #.None true)))

        (_.test "Can run code in a 'synchronized' block."
                (/.synchronized sample #1))

        (_.test "Can access Class instances."
                (text\= "java.lang.Class" (java/lang/Class::getName (/.class-for java/lang/Class))))

        (_.test "Can check if a value is null."
                (and (/.null? (/.null))
                     (not (/.null? sample))))

        (_.test "Can safely convert nullable references into Maybe values."
                (and (|> (: (Maybe java/lang/Object) (/.??? (/.null)))
                         (case> #.None #1
                                _ #0))
                     (|> (: (Maybe java/lang/Object) (/.??? sample))
                         (case> (#.Some _) #1
                                _ #0))))
        )))

(def: arrays
  Test
  (do {! r.monad}
    [size (|> r.nat (\ ! map (|>> (n.% 100) (n.max 1))))
     idx (|> r.nat (\ ! map (n.% size)))
     value r.int]
    ($_ _.and
        (_.test "Can create arrays of some length."
                (n.= size (/.array-length (/.array java/lang/Long size))))

        (_.test "Can set and get array values."
                (let [arr (/.array java/lang/Long size)]
                  (exec (/.array-write idx value arr)
                    (i.= value (/.array-read idx arr)))))
        )))

(def: #export test
  ($_ _.and
      (<| (_.context "Conversions.")
          ..conversions)
      (<| (_.context "Miscellaneous.")
          ..miscellaneous)
      (<| (_.context "Arrays.")
          ..arrays)
      ))
