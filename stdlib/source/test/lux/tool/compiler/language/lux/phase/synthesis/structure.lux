(.module:
  [lux "*"
   [abstract
    ["[0]" monad {"+" [do]}]]
   [data
    ["%" text/format {"+" [format]}]
    ["[0]" name]]
   ["r" math/random {"+" [Random]}]
   ["_" test {"+" [Test]}]
   [control
    pipe
    ["[0]" try]]
   [data
    ["[0]" bit ("[1]\[0]" equivalence)]
    ["[0]" product]
    [number
     ["n" nat]]
    [collection
     ["[0]" list]]]]
  ["[0]" // "_"
   ["[1][0]" primitive]]
  [\\
   ["[0]" / "_"
    ["/[1]" //
     ["/[1]" // "_"
      [extension
       ["[1][0]" bundle]]
      ["/[1]" //
       ["[1][0]" analysis {"+" [Analysis]}]
       ["[1][0]" synthesis {"+" [Synthesis]}]
       [///
        ["[0]" phase]
        [meta
         ["[0]" archive]]]]]]]])

(def: variant
  Test
  (do [! r.monad]
    [size (|> r.nat (\ ! each (|>> (n.% 10) (n.+ 2))))
     tagA (|> r.nat (\ ! each (n.% size)))
     .let [right? (n.= (-- size) tagA)
           lefts (if right?
                   (-- tagA)
                   tagA)]
     memberA //primitive.primitive]
    (_.test "Can synthesize variants."
            (|> (////analysis.variant [lefts right? memberA])
                (//.phase archive.empty)
                (phase.result [///bundle.empty ////synthesis.init])
                (case> (^ {#try.Success (////synthesis.variant [leftsS right?S valueS])})
                       (let [tagS (if right?S (++ leftsS) leftsS)]
                         (and (n.= tagA tagS)
                              (|> tagS (n.= (-- size)) (bit\= right?S))
                              (//primitive.corresponds? memberA valueS)))
                       
                       _
                       false)))))

(def: tuple
  Test
  (do [! r.monad]
    [size (|> r.nat (\ ! each (|>> (n.% 10) (n.max 2))))
     membersA (r.list size //primitive.primitive)]
    (_.test "Can synthesize tuple."
            (|> (////analysis.tuple membersA)
                (//.phase archive.empty)
                (phase.result [///bundle.empty ////synthesis.init])
                (case> (^ {#try.Success (////synthesis.tuple membersS)})
                       (and (n.= size (list.size membersS))
                            (list.every? (product.uncurried //primitive.corresponds?)
                                         (list.zipped/2 membersA membersS)))

                       _
                       false)))))

(def: .public test
  Test
  (<| (_.context (%.name (name_of #////synthesis.Structure)))
      ($_ _.and
          ..variant
          ..tuple
          )))
