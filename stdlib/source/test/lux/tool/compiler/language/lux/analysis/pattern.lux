(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]
    [\\specification
     ["$[0]" equivalence]]]
   [data
    ["[0]" bit ("[1]#[0]" equivalence)]
    ["[0]" text ("[1]#[0]" equivalence)]]
   [math
    ["[0]" random {"+" Random} ("[1]#[0]" monad)]
    [number
     ["f" frac]]]]]
 [\\library
  ["[0]" /]]
 ["[0]" // "_"
  ["[1][0]" simple]
  ["[1][0]" complex]])

(def: .public random
  (Random /.Pattern)
  (random.rec
   (function (_ random)
     ($_ random.or
         //simple.random
         (//complex.random 4 random)
         random.nat
         ))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Pattern])
      (do random.monad
        [expected_register random.nat
         expected_bit random.bit
         expected_nat random.nat
         expected_int random.int
         expected_rev random.rev
         expected_frac random.frac
         expected_text (random.ascii/lower 2)

         expected_lefts random.nat
         expected_right? random.bit])
      (`` ($_ _.and
              (_.for [/.equivalence]
                     ($equivalence.spec /.equivalence ..random))
              
              (_.cover [/.unit]
                       (case (/.unit)
                         (^ (/.unit))
                         true

                         _
                         false))
              (~~ (template [<tag> <value>]
                    [(_.cover [<tag>]
                              (case (<tag> <value>)
                                (^ (<tag> actual))
                                (same? <value> actual)

                                _
                                false))]

                    [/.bind expected_register]
                    [/.bit expected_bit]
                    [/.nat expected_nat]
                    [/.int expected_int]
                    [/.rev expected_rev]
                    [/.frac expected_frac]
                    [/.text expected_text]
                    ))
              (_.cover [/.variant]
                       (case (/.variant [expected_lefts expected_right? (/.text expected_text)])
                         (^ (/.variant [actual_lefts actual_right? (/.text actual_text)]))
                         (and (same? expected_lefts actual_lefts)
                              (same? expected_right? actual_right?)
                              (same? expected_text actual_text))

                         _
                         false))
              (_.cover [/.tuple]
                       (case (/.tuple (list (/.bit expected_bit)
                                            (/.nat expected_nat)
                                            (/.int expected_int)
                                            (/.rev expected_rev)
                                            (/.frac expected_frac)
                                            (/.text expected_text)))
                         (^ (/.tuple (list (/.bit actual_bit)
                                           (/.nat actual_nat)
                                           (/.int actual_int)
                                           (/.rev actual_rev)
                                           (/.frac actual_frac)
                                           (/.text actual_text))))
                         (and (same? expected_bit actual_bit)
                              (same? expected_nat actual_nat)
                              (same? expected_int actual_int)
                              (same? expected_rev actual_rev)
                              (same? expected_frac actual_frac)
                              (same? expected_text actual_text))

                         _
                         false))
              ))))
