(.using
 [library
  [lux (.full)
   ["_" test (.only Test)]
   ["[0]" type ("[1]#[0]" equivalence)]
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" pipe]
    ["[0]" try]]
   [data
    ["[0]" product]]
   [math
    ["[0]" random]]
   [meta
    ["[0]" configuration "_"
     ["$[1]" \\test]]]]]
 [\\library
  ["[0]" /
   [///
    ["[1][0]" extension]
    [//
     ["[1][0]" analysis (.only Analysis Operation)
      ["[2][0]" type]
      ["[2][0]" module]]
     [///
      ["[1][0]" phase ("[1]#[0]" functor)]]]]]])

(def: (analysis state module type it ?)
  (-> Lux Text Type (Operation Analysis) (-> Analysis Bit) Bit)
  (and (|> it
           (/type.expecting type)
           (/module.with 0 module)
           (/phase#each product.right)
           (/phase.result [/extension.#bundle /extension.empty
                           /extension.#state state])
           (pipe.case
             (pattern {try.#Success analysis})
             (? analysis)

             _
             false))
       (|> it
           (/type.expecting .Nothing)
           (/module.with 0 module)
           (/phase#each product.right)
           (/phase.result [/extension.#bundle /extension.empty
                           /extension.#state state])
           (pipe.case
             (pattern {try.#Failure error})
             true

             _
             false))
       (|> it
           /type.inferring
           (/module.with 0 module)
           (/phase#each product.right)
           (/phase.result [/extension.#bundle /extension.empty
                           /extension.#state state])
           (pipe.case
             (pattern {try.#Success [inferred analysis]})
             (and (type#= type inferred)
                  (? analysis))

             _
             false))))

(template: (analysis? <type> <tag>)
  [(is (-> <type> Analysis Bit)
       (function (_ expected)
         (|>> (pipe.case
                (pattern (<tag> actual))
                (same? expected actual)

                _
                false))))])

(def: .public test
  (<| (_.covering /._)
      (do [! random.monad]
        [version random.nat
         host (random.lower_case 1)
         module (random.lower_case 2)
         configuration ($configuration.random 5)
         .let [state (/analysis.state (/analysis.info version host configuration))]]
        (`` (all _.and
                 (_.coverage [/.unit]
                   (..analysis state module .Any /.unit
                               (|>> (pipe.case (pattern (/analysis.unit)) true _ false))))
                 (~~ (template [<analysis> <type> <random> <tag>]
                       [(do !
                          [sample <random>]
                          (_.coverage [<analysis>]
                            (..analysis state module <type> (<analysis> sample)
                                        ((..analysis? <type> <tag>) sample))))]

                       [/.bit .Bit random.bit /analysis.bit]
                       [/.nat .Nat random.nat /analysis.nat]
                       [/.int .Int random.int /analysis.int]
                       [/.rev .Rev random.rev /analysis.rev]
                       [/.frac .Frac random.frac /analysis.frac]
                       [/.text .Text (random.unicode 1) /analysis.text]
                       ))
                 )))))
