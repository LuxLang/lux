(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   ["[0]" type ("[1]#[0]" equivalence)]
   [abstract
    [monad {"+" do}]]
   [control
    ["[0]" pipe]
    ["[0]" try]]
   [data
    ["[0]" product]]
   [math
    ["[0]" random]]
   [meta
    ["[0]" configuration "_"
     ["$[1]" \\test]]]]]
 [\\library
  ["[0]" /
   [///
    ["[1][0]" extension]
    [//
     ["[1][0]" analysis {"+" Analysis Operation}
      ["[2][0]" type]
      ["[2][0]" module]]
     [///
      ["[1][0]" phase ("[1]#[0]" functor)]]]]]])

(def: (analysis state module type it ?)
  (-> Lux Text Type (Operation Analysis) (-> Analysis Bit) Bit)
  (and (|> it
           (/type.expecting type)
           (/module.with 0 module)
           (/phase#each product.right)
           (/phase.result [/extension.#bundle /extension.empty
                           /extension.#state state])
           (pipe.case
             (pattern {try.#Success analysis})
             (? analysis)

             _
             false))
       (|> it
           (/type.expecting .Nothing)
           (/module.with 0 module)
           (/phase#each product.right)
           (/phase.result [/extension.#bundle /extension.empty
                           /extension.#state state])
           (pipe.case
             (pattern {try.#Failure error})
             true

             _
             false))
       (|> it
           /type.inferring
           (/module.with 0 module)
           (/phase#each product.right)
           (/phase.result [/extension.#bundle /extension.empty
                           /extension.#state state])
           (pipe.case
             (pattern {try.#Success [inferred analysis]})
             (and (type#= type inferred)
                  (? analysis))

             _
             false))))

(template: (analysis? <type> <tag>)
  [(: (-> <type> Analysis Bit)
      (function (_ expected)
        (|>> (pipe.case
               (pattern (<tag> actual))
               (same? expected actual)

               _
               false))))])

(def: .public test
  (<| (_.covering /._)
      (do [! random.monad]
        [version random.nat
         host (random.ascii/lower 1)
         module (random.ascii/lower 2)
         configuration ($configuration.random 5)
         .let [state (/analysis.state (/analysis.info version host configuration))]]
        (`` ($_ _.and
                (_.cover [/.unit]
                         (..analysis state module .Any /.unit
                                     (|>> (pipe.case (pattern (/analysis.unit)) true _ false))))
                (~~ (template [<analysis> <type> <random> <tag>]
                      [(do !
                         [sample <random>]
                         (_.cover [<analysis>]
                                  (..analysis state module <type> (<analysis> sample)
                                              ((..analysis? <type> <tag>) sample))))]

                      [/.bit .Bit random.bit /analysis.bit]
                      [/.nat .Nat random.nat /analysis.nat]
                      [/.int .Int random.int /analysis.int]
                      [/.rev .Rev random.rev /analysis.rev]
                      [/.frac .Frac random.frac /analysis.frac]
                      [/.text .Text (random.unicode 1) /analysis.text]
                      ))
                )))))
