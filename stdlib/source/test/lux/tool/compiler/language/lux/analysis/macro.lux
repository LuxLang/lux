(.using
 [library
  [lux (.except)
   ["_" test (.only Test)]
   [abstract
    [monad (.only do)]
    [\\specification
     ["$[0]" equivalence]]]
   [control
    ["[0]" pipe]
    ["[0]" maybe (.open: "[1]#[0]" functor)]
    ["[0]" try (.open: "[1]#[0]" functor)]
    ["[0]" exception]]
   [data
    ["[0]" bit (.open: "[1]#[0]" equivalence)]
    ["[0]" text (.open: "[1]#[0]" equivalence)]
    [collection
     ["[0]" list (.open: "[1]#[0]" monad)]]]
   ["[0]" macro (.only)
    ["[0]" code (.open: "[1]#[0]" equivalence)]]
   [math
    ["[0]" random (.only Random) (.open: "[1]#[0]" monad)]
    [number
     ["n" nat]]]
   ["[0]" meta (.only)
    ["[0]" configuration
     ["$[1]" \\test]]]]]
 ["$" ///////
  [macro
   ["[1][0]" code]]
  [meta
   ["[1][0]" symbol]]]
 [\\library
  ["[0]" / (.only)
   ["/[1]" //]]])

(def: random_state
  (Random Lux)
  (do random.monad
    [version random.nat
     host (random.lower_case 1)
     configuration ($configuration.random 5)]
    (in (//.state (//.info version host configuration)))))

(def: (expander macro inputs state)
  /.Expander
  {try.#Success ((macro.function macro) inputs state)})

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Expander])
      (do [! random.monad]
        [multiplicity (at ! each (|>> (n.% 8) (n.+ 2))
                          random.nat)
         choice (at ! each (n.% multiplicity)
                    random.nat)
         expected_error (random.upper_case 5)

         name ($symbol.random 2 2)
         mono $code.random
         poly (random.list multiplicity $code.random)

         lux ..random_state
         .let [singular (<| (as Macro)
                            (is Macro')
                            (function (_ inputs state)
                              (case (list.item choice inputs)
                                {.#Some it}
                                {try.#Success [state (list it)]}

                                {.#None}
                                {try.#Failure expected_error})))
               multiple (<| (as Macro)
                            (is Macro')
                            (function (_ inputs state)
                              {try.#Success [state (|> inputs
                                                       (list.repeated multiplicity)
                                                       list#conjoint)]}))]])
      (all _.and
           (_.coverage [/.expansion]
             (|> (/.expansion ..expander name multiple (list mono))
                 (meta.result lux)
                 (try#each (at (list.equivalence code.equivalence) =
                               (list.repeated multiplicity mono)))
                 (try.else false)))
           (_.coverage [/.expansion_failed]
             (|> (/.expansion ..expander name singular (list))
                 (meta.result lux)
                 (pipe.case
                   {try.#Failure it}
                   (and (text.contains? expected_error it)
                        (text.contains? (the exception.#label /.expansion_failed) it))

                   _
                   false)))
           (_.coverage [/.single_expansion]
             (|> (/.single_expansion ..expander name singular poly)
                 (meta.result lux)
                 (try#each (code#= (|> poly (list.item choice) maybe.trusted)))
                 (try.else false)))
           (_.coverage [/.must_have_single_expansion]
             (|> (/.single_expansion ..expander name multiple (list mono))
                 (meta.result lux)
                 (pipe.case
                   {try.#Failure it}
                   (text.contains? (the exception.#label /.must_have_single_expansion) it)

                   _
                   false)))
           )))
