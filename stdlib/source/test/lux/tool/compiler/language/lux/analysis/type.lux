(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]]
   [control
    [pipe {"+" case>}]
    ["[0]" try ("[1]#[0]" functor)]]
   [data
    ["[0]" product]]
   [math
    ["[0]" random {"+" Random}]]
   [meta
    ["[0]" configuration "_"
     ["$[1]" \\test]]]
   ["[0]" type ("[1]#[0]" equivalence)
    ["[0]" check]]]]
 [\\library
  ["[0]" /
   ["/[1]" //
    ["[2][0]" module]
    [//
     [phase
      ["[2][0]" extension]]
     [///
      ["[2][0]" phase ("[1]#[0]" functor)]]]]]])

(def: .public random_state
  (Random Lux)
  (do random.monad
    [version random.nat
     host (random.ascii/lower 1)
     configuration ($configuration.random 5)]
    (in (//.state (//.info version host configuration)))))

(def: primitive
  (Random Type)
  (do random.monad
    [name (random.ascii/lower 1)]
    (in {.#Primitive name (list)})))

(def: .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [lux ..random_state
         .let [state [/extension.#bundle /extension.empty
                      /extension.#state lux]]
         expected ..primitive
         dummy (random.only (|>> (type#= expected) not)
                            ..primitive)
         module (random.ascii/lower 1)]
        ($_ _.and
            (_.cover [/.expecting /.inference]
                     (and (|> (/.inference expected)
                              (/.expecting expected)
                              (/module.with 0 module)
                              (/phase#each product.right)
                              (/phase.result state)
                              (case> {try.#Success _} true
                                     {try.#Failure _} false))
                          (|> (/.inference dummy)
                              (/.expecting expected)
                              (/module.with 0 module)
                              (/phase#each product.right)
                              (/phase.result state)
                              (case> {try.#Success _} false
                                     {try.#Failure _} true))
                          (|> (/.inference expected)
                              (/.expecting dummy)
                              (/module.with 0 module)
                              (/phase#each product.right)
                              (/phase.result state)
                              (case> {try.#Success _} false
                                     {try.#Failure _} true))))
            (_.cover [/.inferring]
                     (|> (/.inference expected)
                         /.inferring
                         (/module.with 0 module)
                         (/phase#each product.right)
                         (/phase.result state)
                         (try#each (|>> product.left (type#= expected)))
                         (try.else false)))
            (_.cover [/.check]
                     (|> (do /phase.monad
                           [exT (/.check (do check.monad
                                           [[id type] check.existential]
                                           (in type)))]
                           (|> (/.inference exT)
                               (/.expecting exT)))
                         (/module.with 0 module)
                         (/phase#each product.right)
                         (/phase.result state)
                         (case> {try.#Success _} true
                                {try.#Failure _} false)))
            (_.cover [/.existential /.existential?]
                     (|> (do /phase.monad
                           [:it: /.existential]
                           (in (/.existential? :it:)))
                         (/module.with 0 module)
                         (/phase#each product.right)
                         (/phase.result state)
                         (try.else false)))
            (_.cover [/.fresh]
                     (and (|> (do /phase.monad
                                [varT (/.check (do check.monad
                                                 [[id type] check.var]
                                                 (in type)))]
                                (|> (/.inference expected)
                                    (/.expecting varT)))
                              (/module.with 0 module)
                              (/phase#each product.right)
                              (/phase.result state)
                              (case> {try.#Success _} true
                                     {try.#Failure _} false))
                          (|> (do /phase.monad
                                [varT (/.check (do check.monad
                                                 [[id type] check.var]
                                                 (in type)))]
                                (|> (/.inference expected)
                                    (/.expecting varT)
                                    /.fresh))
                              (/module.with 0 module)
                              (/phase#each product.right)
                              (/phase.result state)
                              (case> {try.#Success _} false
                                     {try.#Failure _} true))))
            ))))
