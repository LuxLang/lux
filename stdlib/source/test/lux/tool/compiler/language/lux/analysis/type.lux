(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   ["[0]" meta]
   [abstract
    [monad {"+" do}]
    [\\specification
     ["$[0]" equivalence]]]
   [control
    [pipe {"+" case>}]
    ["[0]" maybe ("[1]#[0]" functor)]
    ["[0]" try ("[1]#[0]" functor)]
    ["[0]" exception]]
   [data
    ["[0]" product]
    ["[0]" bit ("[1]#[0]" equivalence)]
    ["[0]" text ("[1]#[0]" equivalence)]
    [collection
     ["[0]" list ("[1]#[0]" monad)]]]
   [macro
    ["[0]" code ("[1]#[0]" equivalence)]]
   [math
    ["[0]" random {"+" Random} ("[1]#[0]" monad)]
    [number
     ["n" nat]]]
   ["[0]" type ("[1]#[0]" equivalence)
    ["[0]" check]]]]
 ["$" /////// "_"
  [macro
   ["[1][0]" code]]
  [meta
   ["[1][0]" symbol]]]
 [\\library
  ["[0]" /
   ["/[1]" //
    [//
     [phase
      ["[2][0]" extension]]
     [///
      ["[2][0]" phase]]]]]])

(def: random_state
  (Random Lux)
  (do random.monad
    [version random.nat
     host (random.ascii/lower 1)]
    (in (//.state (//.info version host)))))

(def: primitive
  (Random Type)
  (do random.monad
    [name (random.ascii/lower 1)]
    (in {.#Primitive name (list)})))

(def: .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [lux ..random_state
         .let [state [/extension.#bundle /extension.empty
                      /extension.#state lux]]
         expected ..primitive
         dummy (random.only (|>> (type#= expected) not)
                            ..primitive)]
        ($_ _.and
            (_.cover [/.expecting /.inference]
                     (and (|> (/.inference expected)
                              (/.expecting expected)
                              (/phase.result state)
                              (case> {try.#Success _} true
                                     {try.#Failure _} false))
                          (|> (/.inference dummy)
                              (/.expecting expected)
                              (/phase.result state)
                              (case> {try.#Success _} false
                                     {try.#Failure _} true))
                          (|> (/.inference expected)
                              (/.expecting dummy)
                              (/phase.result state)
                              (case> {try.#Success _} false
                                     {try.#Failure _} true))))
            (_.cover [/.inferring]
                     (|> (/.inference expected)
                         /.inferring
                         (/phase.result state)
                         (try#each (|>> product.left (type#= expected)))
                         (try.else false)))
            (_.cover [/.check]
                     (|> (do /phase.monad
                           [exT (/.check (do check.monad
                                           [[id type] check.existential]
                                           (in type)))]
                           (|> (/.inference exT)
                               (/.expecting exT)))
                         (/phase.result state)
                         (case> {try.#Success _} true
                                {try.#Failure _} false)))
            (_.cover [/.fresh]
                     (and (|> (do /phase.monad
                                [varT (/.check (do check.monad
                                                 [[id type] check.var]
                                                 (in type)))]
                                (|> (/.inference expected)
                                    (/.expecting varT)))
                              (/phase.result state)
                              (case> {try.#Success _} true
                                     {try.#Failure _} false))
                          (|> (do /phase.monad
                                [varT (/.check (do check.monad
                                                 [[id type] check.var]
                                                 (in type)))]
                                (|> (/.inference expected)
                                    (/.expecting varT)
                                    /.fresh))
                              (/phase.result state)
                              (case> {try.#Success _} false
                                     {try.#Failure _} true))))
            ))))
