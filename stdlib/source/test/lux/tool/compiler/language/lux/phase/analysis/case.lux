(.module:
  [lux "*"
   [abstract
    ["[0]" monad {"+" [do]}]]
   [data
    ["%" text/format {"+" [format]}]
    ["[0]" name]]
   ["r" math/random {"+" [Random]} ("[1]\[0]" monad)]
   ["_" test {"+" [Test]}]
   [control
    pipe
    ["[0]" maybe]]
   [data
    ["[0]" product]
    ["[0]" text ("[1]\[0]" equivalence)]
    [number
     ["n" nat]]
    [collection
     ["[0]" list ("[1]\[0]" monad)]
     ["[0]" set]]]
   ["[0]" type
    ["[0]" check]]
   [macro
    ["[0]" code]]]
  [//
   ["_[0]" primitive]
   ["_[0]" structure]]
  [\\
   ["[0]" /
    ["/[1]" //
     ["[1][0]" module]
     ["[1][0]" type]
     ["/[1]" // "_"
      ["/[1]" //
       ["[1][0]" analysis {"+" [Analysis Variant Tag Operation]}]
       [///
        ["[0]" phase]
        [meta
         ["[0]" archive]]]]]]]])

(def: (exhaustive_weaving branchings)
  (-> (List (List Code)) (List (List Code)))
  (case branchings
    #.End
    #.End

    {#.Item head+ #.End}
    (list\each (|>> list) head+)

    {#.Item head+ tail++}
    (do list.monad
      [tail+ (exhaustive_weaving tail++)
       head head+]
      (in {#.Item head tail+}))))

(def: .public (exhaustive_branches allow_literals? variantTC inputC)
  (-> Bit (List [Code Code]) Code (Random (List Code)))
  (case inputC
    [_ {#.Bit _}]
    (r\in (list (' #0) (' #1)))

    (^template [<tag> <gen> <wrapper>]
      [[_ {<tag> _}]
       (if allow_literals?
         (do [! r.monad]
           [?sample (r.maybe <gen>)]
           (case ?sample
             {#.Some sample}
             (do !
               [else (exhaustive_branches allow_literals? variantTC inputC)]
               (in (list& (<wrapper> sample) else)))

             #.None
             (in (list (' _)))))
         (r\in (list (' _))))])
    ([#.Nat  r.nat         code.nat]
     [#.Int  r.int         code.int]
     [#.Rev  r.rev         code.rev]
     [#.Frac r.frac        code.frac]
     [#.Text (r.unicode 5) code.text])
    
    (^ [_ {#.Tuple (list)}])
    (r\in (list (' [])))

    [_ {#.Tuple members}]
    (do [! r.monad]
      [member_wise_patterns (monad.each ! (exhaustive_branches allow_literals? variantTC) members)]
      (in (|> member_wise_patterns
              exhaustive_weaving
              (list\each code.tuple))))

    (^ [_ {#.Record (list)}])
    (r\in (list (' {})))

    [_ {#.Record kvs}]
    (do [! r.monad]
      [.let [ks (list\each product.left kvs)
             vs (list\each product.right kvs)]
       member_wise_patterns (monad.each ! (exhaustive_branches allow_literals? variantTC) vs)]
      (in (|> member_wise_patterns
              exhaustive_weaving
              (list\each (|>> (list.zipped/2 ks) code.record)))))

    (^ [_ {#.Form (list [_ {#.Tag _}] _)}])
    (do [! r.monad]
      [bundles (monad.each !
                           (function (_ [_tag _code])
                             (do !
                               [v_branches (exhaustive_branches allow_literals? variantTC _code)]
                               (in (list\each (function (_ pattern) (` ((~ _tag) (~ pattern))))
                                              v_branches))))
                           variantTC)]
      (in (list\conjoint bundles)))

    _
    (r\in (list))
    ))

(def: .public (input variant_tags record_tags primitivesC)
  (-> (List Code) (List Code) (List Code) (Random Code))
  (r.rec
   (function (_ input)
     ($_ r.either
         (r\each product.right _primitive.primitive)
         (do [! r.monad]
           [choice (|> r.nat (\ ! each (n.% (list.size variant_tags))))
            .let [choiceT (maybe.trusted (list.item choice variant_tags))
                  choiceC (maybe.trusted (list.item choice primitivesC))]]
           (in (` ((~ choiceT) (~ choiceC)))))
         (do [! r.monad]
           [size (|> r.nat (\ ! each (n.% 3)))
            elems (r.list size input)]
           (in (code.tuple elems)))
         (r\in (code.record (list.zipped/2 record_tags primitivesC)))
         ))))

(def: (branch body pattern)
  (-> Code Code [Code Code])
  [pattern body])

(def: .public test
  (<| (_.context (name.module (name_of /._)))
      (do [! r.monad]
        [module_name (r.unicode 5)
         variant_name (r.unicode 5)
         record_name (|> (r.unicode 5) (r.only (|>> (text\= variant_name) not)))
         size (|> r.nat (\ ! each (|>> (n.% 10) (n.max 2))))
         variant_tags (|> (r.set text.hash size (r.unicode 5)) (\ ! each set.list))
         record_tags (|> (r.set text.hash size (r.unicode 5)) (\ ! each set.list))
         primitivesTC (r.list size _primitive.primitive)
         .let [primitivesT (list\each product.left primitivesTC)
               primitivesC (list\each product.right primitivesTC)
               code_tag (|>> [module_name] code.tag)
               variant_tags+ (list\each code_tag variant_tags)
               record_tags+ (list\each code_tag record_tags)
               variantTC (list.zipped/2 variant_tags+ primitivesC)]
         inputC (input variant_tags+ record_tags+ primitivesC)
         [outputT outputC] (r.only (|>> product.left (same? Any) not)
                                   _primitive.primitive)
         .let [analyse_pm (function (_ branches)
                            (|> (/.case _primitive.phase branches archive.empty inputC)
                                (//type.with_type outputT)
                                ////analysis.with_scope
                                (do phase.monad
                                  [_ (//module.declare_tags variant_tags false
                                                            {#.Named [module_name variant_name]
                                                                     (type.variant primitivesT)})
                                   _ (//module.declare_tags record_tags false
                                                            {#.Named [module_name record_name]
                                                                     (type.tuple primitivesT)})])
                                (//module.with_module 0 module_name)))]
         exhaustive_patterns (exhaustive_branches true variantTC inputC)
         .let [exhaustive_branchesC (list\each (branch outputC)
                                               exhaustive_patterns)]]
        ($_ _.and
            (_.test "Will reject empty pattern-matching (no branches)."
                    (|> (analyse_pm (list))
                        _structure.check_fails))
            (_.test "Can analyse exhaustive pattern-matching."
                    (|> (analyse_pm exhaustive_branchesC)
                        _structure.check_succeeds))
            (let [non_exhaustive_branchesC (list.first (-- (list.size exhaustive_branchesC))
                                                       exhaustive_branchesC)]
              (_.test "Will reject non-exhaustive pattern-matching."
                      (|> (analyse_pm non_exhaustive_branchesC)
                          _structure.check_fails)))
            (do !
              [redundant_patterns (exhaustive_branches false variantTC inputC)
               redundancy_idx (|> r.nat (\ ! each (n.% (list.size redundant_patterns))))
               .let [redundant_branchesC (<| (list!each (branch outputC))
                                             list.together
                                             (list (list.first redundancy_idx redundant_patterns)
                                                   (list (maybe.trusted (list.item redundancy_idx redundant_patterns)))
                                                   (list.after redundancy_idx redundant_patterns)))]]
              (_.test "Will reject redundant pattern-matching."
                      (|> (analyse_pm redundant_branchesC)
                          _structure.check_fails)))
            (do !
              [[heterogeneousT heterogeneousC] (r.only (|>> product.left (check.subsumes? outputT) not)
                                                       _primitive.primitive)
               heterogeneous_idx (|> r.nat (\ ! each (n.% (list.size exhaustive_patterns))))
               .let [heterogeneous_branchesC (list.together (list (list.first heterogeneous_idx exhaustive_branchesC)
                                                                  (list (let [[_pattern _body] (maybe.trusted (list.item heterogeneous_idx exhaustive_branchesC))]
                                                                          [_pattern heterogeneousC]))
                                                                  (list.after (++ heterogeneous_idx) exhaustive_branchesC)))]]
              (_.test "Will reject pattern-matching if the bodies of the branches do not all have the same type."
                      (|> (analyse_pm heterogeneous_branchesC)
                          _structure.check_fails)))
            ))))
