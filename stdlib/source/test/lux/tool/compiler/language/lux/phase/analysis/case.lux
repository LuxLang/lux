(.module:
  [lux #*
   [abstract
    ["." monad (#+ do)]]
   [data
    ["%" text/format (#+ format)]
    ["." name]]
   ["r" math/random (#+ Random) ("#\." monad)]
   ["_" test (#+ Test)]
   [control
    pipe]
   [data
    ["." product]
    ["." maybe]
    ["." text ("#\." equivalence)]
    [number
     ["n" nat]]
    [collection
     ["." list ("#\." monad)]
     ["." set]]]
   ["." type
    ["." check]]
   [macro
    ["." code]]]
  [//
   ["_." primitive]
   ["_." structure]]
  [\\
   ["." /
    ["/#" //
     ["#." module]
     ["#." type]
     ["/#" // #_
      ["/#" //
       ["#." analysis (#+ Analysis Variant Tag Operation)]
       [///
        ["." phase]
        [meta
         ["." archive]]]]]]]])

(def: (exhaustive_weaving branchings)
  (-> (List (List Code)) (List (List Code)))
  (case branchings
    #.End
    #.End

    (#.Item head+ #.End)
    (list\map (|>> list) head+)

    (#.Item head+ tail++)
    (do list.monad
      [tail+ (exhaustive_weaving tail++)
       head head+]
      (in (#.Item head tail+)))))

(def: #export (exhaustive_branches allow_literals? variantTC inputC)
  (-> Bit (List [Code Code]) Code (Random (List Code)))
  (case inputC
    [_ (#.Bit _)]
    (r\in (list (' #0) (' #1)))

    (^template [<tag> <gen> <wrapper>]
      [[_ (<tag> _)]
       (if allow_literals?
         (do {! r.monad}
           [?sample (r.maybe <gen>)]
           (case ?sample
             (#.Some sample)
             (do !
               [else (exhaustive_branches allow_literals? variantTC inputC)]
               (in (list& (<wrapper> sample) else)))

             #.None
             (in (list (' _)))))
         (r\in (list (' _))))])
    ([#.Nat  r.nat         code.nat]
     [#.Int  r.int         code.int]
     [#.Rev  r.rev         code.rev]
     [#.Frac r.frac        code.frac]
     [#.Text (r.unicode 5) code.text])
    
    (^ [_ (#.Tuple (list))])
    (r\in (list (' [])))

    [_ (#.Tuple members)]
    (do {! r.monad}
      [member_wise_patterns (monad.map ! (exhaustive_branches allow_literals? variantTC) members)]
      (in (|> member_wise_patterns
              exhaustive_weaving
              (list\map code.tuple))))

    (^ [_ (#.Record (list))])
    (r\in (list (' {})))

    [_ (#.Record kvs)]
    (do {! r.monad}
      [.let [ks (list\map product.left kvs)
             vs (list\map product.right kvs)]
       member_wise_patterns (monad.map ! (exhaustive_branches allow_literals? variantTC) vs)]
      (in (|> member_wise_patterns
              exhaustive_weaving
              (list\map (|>> (list.zipped/2 ks) code.record)))))

    (^ [_ (#.Form (list [_ (#.Tag _)] _))])
    (do {! r.monad}
      [bundles (monad.map !
                          (function (_ [_tag _code])
                            (do !
                              [v_branches (exhaustive_branches allow_literals? variantTC _code)]
                              (in (list\map (function (_ pattern) (` ((~ _tag) (~ pattern))))
                                            v_branches))))
                          variantTC)]
      (in (list\join bundles)))

    _
    (r\in (list))
    ))

(def: #export (input variant_tags record_tags primitivesC)
  (-> (List Code) (List Code) (List Code) (Random Code))
  (r.rec
   (function (_ input)
     ($_ r.either
         (r\map product.right _primitive.primitive)
         (do {! r.monad}
           [choice (|> r.nat (\ ! map (n.% (list.size variant_tags))))
            .let [choiceT (maybe.assume (list.item choice variant_tags))
                  choiceC (maybe.assume (list.item choice primitivesC))]]
           (in (` ((~ choiceT) (~ choiceC)))))
         (do {! r.monad}
           [size (|> r.nat (\ ! map (n.% 3)))
            elems (r.list size input)]
           (in (code.tuple elems)))
         (r\in (code.record (list.zipped/2 record_tags primitivesC)))
         ))))

(def: (branch body pattern)
  (-> Code Code [Code Code])
  [pattern body])

(def: #export test
  (<| (_.context (name.module (name_of /._)))
      (do {! r.monad}
        [module_name (r.unicode 5)
         variant_name (r.unicode 5)
         record_name (|> (r.unicode 5) (r.only (|>> (text\= variant_name) not)))
         size (|> r.nat (\ ! map (|>> (n.% 10) (n.max 2))))
         variant_tags (|> (r.set text.hash size (r.unicode 5)) (\ ! map set.list))
         record_tags (|> (r.set text.hash size (r.unicode 5)) (\ ! map set.list))
         primitivesTC (r.list size _primitive.primitive)
         .let [primitivesT (list\map product.left primitivesTC)
               primitivesC (list\map product.right primitivesTC)
               code_tag (|>> [module_name] code.tag)
               variant_tags+ (list\map code_tag variant_tags)
               record_tags+ (list\map code_tag record_tags)
               variantTC (list.zipped/2 variant_tags+ primitivesC)]
         inputC (input variant_tags+ record_tags+ primitivesC)
         [outputT outputC] (r.only (|>> product.left (is? Any) not)
                                   _primitive.primitive)
         .let [analyse_pm (function (_ branches)
                            (|> (/.case _primitive.phase branches archive.empty inputC)
                                (//type.with_type outputT)
                                ////analysis.with_scope
                                (do phase.monad
                                  [_ (//module.declare_tags variant_tags false
                                                            (#.Named [module_name variant_name]
                                                                     (type.variant primitivesT)))
                                   _ (//module.declare_tags record_tags false
                                                            (#.Named [module_name record_name]
                                                                     (type.tuple primitivesT)))])
                                (//module.with_module 0 module_name)))]
         exhaustive_patterns (exhaustive_branches true variantTC inputC)
         .let [exhaustive_branchesC (list\map (branch outputC)
                                              exhaustive_patterns)]]
        ($_ _.and
            (_.test "Will reject empty pattern-matching (no branches)."
                    (|> (analyse_pm (list))
                        _structure.check_fails))
            (_.test "Can analyse exhaustive pattern-matching."
                    (|> (analyse_pm exhaustive_branchesC)
                        _structure.check_succeeds))
            (let [non_exhaustive_branchesC (list.take (dec (list.size exhaustive_branchesC))
                                                      exhaustive_branchesC)]
              (_.test "Will reject non-exhaustive pattern-matching."
                      (|> (analyse_pm non_exhaustive_branchesC)
                          _structure.check_fails)))
            (do !
              [redundant_patterns (exhaustive_branches false variantTC inputC)
               redundancy_idx (|> r.nat (\ ! map (n.% (list.size redundant_patterns))))
               .let [redundant_branchesC (<| (list!map (branch outputC))
                                             list.concat
                                             (list (list.take redundancy_idx redundant_patterns)
                                                   (list (maybe.assume (list.item redundancy_idx redundant_patterns)))
                                                   (list.drop redundancy_idx redundant_patterns)))]]
              (_.test "Will reject redundant pattern-matching."
                      (|> (analyse_pm redundant_branchesC)
                          _structure.check_fails)))
            (do !
              [[heterogeneousT heterogeneousC] (r.only (|>> product.left (check.checks? outputT) not)
                                                       _primitive.primitive)
               heterogeneous_idx (|> r.nat (\ ! map (n.% (list.size exhaustive_patterns))))
               .let [heterogeneous_branchesC (list.concat (list (list.take heterogeneous_idx exhaustive_branchesC)
                                                                (list (let [[_pattern _body] (maybe.assume (list.item heterogeneous_idx exhaustive_branchesC))]
                                                                        [_pattern heterogeneousC]))
                                                                (list.drop (inc heterogeneous_idx) exhaustive_branchesC)))]]
              (_.test "Will reject pattern-matching if the bodies of the branches do not all have the same type."
                      (|> (analyse_pm heterogeneous_branchesC)
                          _structure.check_fails)))
            ))))
