(.module:
  [lux {"-" [primitive]}
   ["@" target]
   [abstract
    ["[0]" monad {"+" [do]}]]
   [data
    ["%" text/format {"+" [format]}]
    ["[0]" name]]
   ["r" math/random {"+" [Random]} ("[1]\[0]" monad)]
   ["_" test {"+" [Test]}]
   [control
    pipe
    ["[0]" try {"+" [Try]}]
    ["[0]" exception {"+" [exception:]}]]
   [macro
    ["[0]" code]]]
  [\\
   ["[0]" /
    ["/[1]" //
     ["[1][0]" type]
     ["/[1]" // "_"
      [extension
       ["[0]" bundle]
       ["[1][0]" analysis]]
      ["/[1]" // "_"
       ["[0]" version]
       ["[1][0]" analysis {"+" [Analysis Operation]}
        [macro {"+" [Expander]}]
        [evaluation {"+" [Eval]}]]
       [///
        ["[0]" phase]
        [meta
         ["[0]" archive]]]]]]]])

(def: .public (expander macro inputs state)
  Expander
  (#try.Failure "NOPE"))

(def: .public (eval archive count type expression)
  Eval
  (function (_ state)
    (#try.Failure "NO!")))

(def: .public phase
  ////analysis.Phase
  (//.phase ..expander))

(def: .public state
  ////analysis.State+
  [(///analysis.bundle ..eval bundle.empty)
   (////analysis.state (////analysis.info version.version @.jvm))])

(def: .public primitive
  (Random [Type Code])
  (`` ($_ r.either
          (~~ (template [<type> <code_wrapper> <value_gen>]
                [(r.and (r\in <type>) (r\each <code_wrapper> <value_gen>))]

                [Any  code.tuple (r.list 0 (r\in (' [])))]
                [Bit  code.bit   r.bit]
                [Nat  code.nat   r.nat]
                [Int  code.int   r.int]
                [Rev  code.rev   r.rev]
                [Frac code.frac  r.frac]
                [Text code.text  (r.unicode 5)]
                )))))

(exception: (wrong_inference {expected Type} {inferred Type})
  (exception.report
   ["Expected" (%.type expected)]
   ["Inferred" (%.type inferred)]))

(def: (infer expected_type analysis)
  (-> Type (Operation Analysis) (Try Analysis))
  (|> analysis
      //type.with_inference
      (phase.result ..state)
      (case> (#try.Success [inferred_type output])
             (if (same? expected_type inferred_type)
               (#try.Success output)
               (exception.except wrong_inference [expected_type inferred_type]))

             (#try.Failure error)
             (#try.Failure error))))

(def: .public test
  (<| (_.context (name.module (name_of /._)))
      (`` ($_ _.and
              (_.test (%.name (name_of #////analysis.Unit))
                      (|> (infer Any (..phase archive.empty (' [])))
                          (case> (^ (#try.Success (#////analysis.Primitive (#////analysis.Unit output))))
                                 (same? [] output)

                                 _
                                 false)))
              (~~ (template [<type> <tag> <random> <constructor>]
                    [(do r.monad
                       [sample <random>]
                       (_.test (%.name (name_of <tag>))
                               (|> (infer <type> (..phase archive.empty (<constructor> sample)))
                                   (case> (#try.Success (#////analysis.Primitive (<tag> output)))
                                          (same? sample output)

                                          _
                                          false))))]

                    [Bit  #////analysis.Bit  r.bit         code.bit]
                    [Nat  #////analysis.Nat  r.nat         code.nat]
                    [Int  #////analysis.Int  r.int         code.int]
                    [Rev  #////analysis.Rev  r.rev         code.rev]
                    [Frac #////analysis.Frac r.frac        code.frac]
                    [Text #////analysis.Text (r.unicode 5) code.text]
                    ))))))
