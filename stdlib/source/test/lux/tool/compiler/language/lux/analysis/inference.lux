(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]]
   [control
    ["[0]" maybe ("[1]#[0]" functor)]
    ["[0]" try {"+" Try} ("[1]#[0]" functor)]
    ["[0]" exception {"+" Exception}]]
   [data
    ["[0]" product]
    ["[0]" bit ("[1]#[0]" equivalence)]
    ["[0]" text]
    [collection
     ["[0]" list ("[1]#[0]" monad)]]]
   [macro
    ["[0]" code]]
   [math
    ["[0]" random {"+" Random} ("[1]#[0]" monad)]
    [number
     ["n" nat]]]
   [meta
    ["[0]" symbol "_"
     ["$[1]" \\test]]]
   ["[0]" type ("[1]#[0]" equivalence)
    ["[0]" check {"+" Check}]]]]
 [\\library
  ["[0]" /
   ["/[1]" //
    [evaluation {"+" Eval}]
    ["[1][0]" macro]
    ["[1][0]" type]
    ["[1][0]" module]
    ["[1][0]" complex]
    [//
     [phase
      ["[2][0]" analysis]
      ["[2][0]" extension
       ["[1]/[0]" analysis "_"
        ["[1]" lux]]]]
     [///
      ["[2][0]" phase ("[1]#[0]" monad)]
      [meta
       ["[0]" archive]]]]]]])

(def: (eval archive type term)
  Eval
  (/phase#in []))

(def: (expander macro inputs state)
  //macro.Expander
  {try.#Success ((.macro macro) inputs state)})

(def: random_state
  (Random Lux)
  (do random.monad
    [version random.nat
     host (random.ascii/lower 1)]
    (in (//.state (//.info version host)))))

(def: primitive
  (Random Type)
  (do random.monad
    [name (random.ascii/lower 1)]
    (in {.#Primitive name (list)})))

(def: analysis
  //.Phase
  (/analysis.phase ..expander))

(def: (fails? exception try)
  (All (_ e a) (-> (Exception e) (Try a) Bit))
  (case try
    {try.#Success _}
    false
    
    {try.#Failure error}
    (text.contains? (value@ exception.#label exception) error)))

(def: simple_parameter
  (Random [Type Code])
  (`` ($_ random.either
          (~~ (template [<type> <random> <code>]
                [(random#each (|>> <code> [<type>]) <random>)]

                [.Bit random.bit code.bit]
                [.Nat random.nat code.nat]
                [.Int random.int code.int]
                [.Rev random.rev code.rev]
                [.Frac random.frac code.frac]
                [.Text (random.ascii/lower 1) code.text]
                ))
          )))

(def: test|general
  Test
  (do [! random.monad]
    [lux ..random_state
     .let [state [/extension.#bundle (/extension/analysis.bundle ..eval)
                  /extension.#state lux]]
     expected ..primitive
     name ($symbol.random 1 1)
     [type/0 term/0] ..simple_parameter
     arity (# ! each (n.% 10) random.nat)
     nats (random.list arity random.nat)]
    ($_ _.and
        (_.cover [/.general]
                 (and (|> (/.general archive.empty ..analysis expected (list))
                          (//type.expecting expected)
                          (/phase.result state)
                          (try#each (|>> product.left (type#= expected)))
                          (try.else false))
                      (|> (/.general archive.empty ..analysis
                                     (type.function (list.repeated arity .Nat) expected)
                                     (list#each code.nat nats))
                          (//type.expecting expected)
                          (/phase.result state)
                          (try#each (function (_ [actual analysis/*])
                                      (and (type#= expected actual)
                                           (# (list.equivalence //.equivalence) =
                                              (list#each (|>> //.nat) nats)
                                              analysis/*))))
                          (try.else false))
                      (|> (/.general archive.empty ..analysis
                                     (type (-> type/0 expected))
                                     (list term/0))
                          (//type.expecting expected)
                          (/phase.result state)
                          (try#each (|>> product.left (type#= expected)))
                          (try.else false))
                      (|> (/.general archive.empty ..analysis
                                     (type {.#Named name (-> type/0 expected)})
                                     (list term/0))
                          (//type.expecting expected)
                          (/phase.result state)
                          (try#each (|>> product.left (type#= expected)))
                          (try.else false))
                      (|> (/.general archive.empty ..analysis
                                     (type (All (_ a) (-> a a)))
                                     (list term/0))
                          (//type.expecting type/0)
                          (/phase#each (|>> product.left check.clean //type.check))
                          /phase#conjoint
                          (/phase.result state)
                          (try#each (type#= type/0))
                          (try.else false))
                      (|> (/.general archive.empty ..analysis
                                     (type ((All (_ a) (-> a a)) type/0))
                                     (list term/0))
                          (//type.expecting type/0)
                          (/phase.result state)
                          (try#each (|>> product.left (type#= type/0)))
                          (try.else false))
                      (|> (do /phase.monad
                            [[@var varT] (//type.check check.var)
                             _ (//type.check (check.check varT (type (-> type/0 expected))))]
                            (/.general archive.empty ..analysis varT (list term/0)))
                          (//type.expecting expected)
                          (/phase#each (|>> product.left check.clean //type.check))
                          /phase#conjoint
                          (/phase.result state)
                          (try#each (type#= expected))
                          (try.else false))
                      ))
        (_.cover [/.cannot_infer]
                 (and (|> (/.general archive.empty ..analysis expected (list term/0))
                          (//type.expecting expected)
                          (/phase.result state)
                          (..fails? /.cannot_infer))
                      (|> (do /phase.monad
                            [[@var varT] (//type.check check.var)]
                            (/.general archive.empty ..analysis varT (list term/0)))
                          (//type.expecting expected)
                          (/phase.result state)
                          (..fails? /.cannot_infer))))
        (_.cover [/.cannot_infer_argument]
                 (|> (/.general archive.empty ..analysis
                                (type (-> expected expected))
                                (list term/0))
                     (//type.expecting expected)
                     (/phase.result state)
                     (..fails? /.cannot_infer_argument)))
        (_.cover [/.existential?]
                 (|> (/.general archive.empty ..analysis
                                (type (Ex (_ a) (-> a a)))
                                (list (` ("lux io error" ""))))
                     //type.inferring
                     (//module.with_module 0 (product.left name))
                     (/phase#each (|>> product.right product.left check.clean //type.check))
                     /phase#conjoint
                     (/phase.result state)
                     (try#each /.existential?)
                     (try.else false)))
        )))

(def: test|variant
  Test
  (do [! random.monad]
    [lux ..random_state
     .let [state [/extension.#bundle (/extension/analysis.bundle ..eval)
                  /extension.#state lux]]
     name ($symbol.random 1 1)
     arity (# ! each (|>> (n.% 5) (n.+ 2)) random.nat)
     [type/0 term/0] ..simple_parameter
     [type/1 term/1] (random.only (|>> product.left (same? type/0) not)
                                  ..simple_parameter)
     types/*,terms/* (random.list arity ..simple_parameter)
     tag (# ! each (n.% arity) random.nat)
     .let [[lefts right?] (//complex.choice arity tag)]
     arbitrary_right? random.bit]
    ($_ _.and
        (_.cover [/.variant]
                 (let [variantT (type.variant (list#each product.left types/*,terms/*))
                       [tagT tagC] (|> types/*,terms/*
                                       (list.item tag)
                                       (maybe.else [Any (' [])]))
                       variant?' (: (-> Type (Maybe Type) Nat Bit Code Bit)
                                    (function (_ variant inferred lefts right? term)
                                      (|> (do /phase.monad
                                            [inferT (/.variant lefts right? variant)
                                             [_ [it _]] (|> (/.general archive.empty ..analysis inferT (list term))
                                                            //type.inferring)]
                                            (case inferred
                                              {.#Some inferred}
                                              (//type.check
                                               (do check.monad
                                                 [_ (check.check inferred it)
                                                  _ (check.check it inferred)]
                                                 (in true)))
                                              
                                              {.#None}
                                              (in true)))
                                          (//module.with_module 0 (product.left name))
                                          (/phase#each product.right)
                                          (/phase.result state)
                                          (try.else false))))
                       variant? (: (-> Type Nat Bit Code Bit)
                                   (function (_ type lefts right? term)
                                     (variant?' type {.#Some type} lefts right? term)))

                       can_match_case!
                       (variant? variantT lefts right? tagC)

                       names_do_not_matter!
                       (variant? {.#Named name variantT} lefts right? tagC)

                       cases_independent_of_parameters_conform_to_anything!
                       (variant? (type (Maybe type/0)) 0 #0 (' []))

                       cases_dependent_on_parameters_are_tettered_to_those_parameters!
                       (and (variant? (type (Maybe type/0)) 0 #1 term/0)
                            (not (variant? (type (Maybe type/0)) 0 #1 term/1)))

                       only_bottom_conforms_to_tags_outside_of_range!
                       (`` (and (~~ (template [<verdict> <term>]
                                      [(bit#= <verdict> (variant? variantT arity arbitrary_right? <term>))]

                                      [#0 term/0]
                                      [#1 (` ("lux io error" ""))]))))

                       can_handle_universal_quantification!
                       (and (variant?' (type (All (_ a) (Maybe a)))
                                       {.#Some Maybe}
                                       0 #0 (' []))
                            (variant?' (type (All (_ a) (Maybe a)))
                                       {.#Some (type (Maybe type/0))}
                                       0 #1 term/0)
                            (not (variant?' (type (All (_ a) (Maybe a)))
                                            {.#Some Maybe}
                                            0 #1 term/0)))

                       existential_types_do_not_affect_independent_cases!
                       (variant?' (type (Ex (_ a) (Maybe a)))
                                  {.#None}
                                  0 #0 (' []))

                       existential_types_affect_dependent_cases!
                       (`` (and (~~ (template [<verdict> <term>]
                                      [(bit#= <verdict> (variant?' (type (Ex (_ a) (Maybe a))) {.#None} 0 #1 <term>))]

                                      [#0 term/0]
                                      [#1 (` ("lux io error" ""))]))))]
                   (and can_match_case!
                        names_do_not_matter!

                        cases_independent_of_parameters_conform_to_anything!
                        cases_dependent_on_parameters_are_tettered_to_those_parameters!

                        only_bottom_conforms_to_tags_outside_of_range!

                        can_handle_universal_quantification!

                        existential_types_do_not_affect_independent_cases!
                        existential_types_affect_dependent_cases!
                        )))
        (_.cover [/.not_a_variant]
                 (let [[tagT tagC] (|> types/*,terms/*
                                       (list.item tag)
                                       (maybe.else [Any (' [])]))]
                   (|> (/.variant lefts right? tagT)
                       (/phase.result state)
                       (..fails? /.not_a_variant))))
        )))

(def: test|record
  Test
  (do [! random.monad]
    [lux ..random_state
     .let [state [/extension.#bundle (/extension/analysis.bundle ..eval)
                  /extension.#state lux]]
     name ($symbol.random 1 1)
     arity (# ! each (|>> (n.% 5) (n.+ 2)) random.nat)
     [type/0 term/0] ..simple_parameter
     [type/1 term/1] (random.only (|>> product.left (same? type/0) not)
                                  ..simple_parameter)
     types/*,terms/* (random.list arity ..simple_parameter)
     .let [record? (: (-> Type (Maybe Type) Nat (List Code) Bit)
                      (function (_ record expected arity terms)
                        (|> (do /phase.monad
                              [inference (/.record arity record)
                               [_ [it _]] (|> (/.general archive.empty ..analysis inference terms)
                                              //type.inferring)]
                              (case expected
                                {.#Some expected}
                                (//type.check
                                 (do check.monad
                                   [_ (check.check expected it)
                                    _ (check.check it expected)]
                                   (in true)))
                                
                                {.#None}
                                (in true)))
                            (//module.with_module 0 (product.left name))
                            (/phase#each product.right)
                            (/phase.result state)
                            (try.else false))))
           record (type.tuple (list#each product.left types/*,terms/*))
           terms (list#each product.right types/*,terms/*)]]
    ($_ _.and
        (_.cover [/.record]
                 (let [can_infer_record!
                       (record? record {.#None} arity terms)

                       names_do_not_matter!
                       (record? {.#Named name record} {.#None} arity terms)

                       can_handle_universal_quantification!
                       (and (record? (All (_ a) (Tuple type/0 a))
                                     {.#Some (Tuple type/0 type/1)}
                                     2 (list term/0 term/1))
                            (record? (All (_ a) (Tuple a type/0))
                                     {.#Some (Tuple type/1 type/0)}
                                     2 (list term/1 term/0)))

                       can_handle_existential_quantification!
                       (and (not (record? (Ex (_ a) (Tuple type/0 a))
                                          {.#Some (Tuple type/0 type/1)}
                                          2 (list term/0 term/1)))
                            (record? (Ex (_ a) (Tuple type/0 a))
                                     {.#None}
                                     2 (list term/0 (` ("lux io error" ""))))
                            (not (record? (Ex (_ a) (Tuple a type/0))
                                          {.#Some (Tuple type/1 type/0)}
                                          2 (list term/1 term/0)))
                            (record? (Ex (_ a) (Tuple a type/0))
                                     {.#None}
                                     2 (list (` ("lux io error" "")) term/0)))]
                   (and can_infer_record!
                        names_do_not_matter!
                        can_handle_universal_quantification!
                        can_handle_existential_quantification!
                        )))
        (_.cover [/.not_a_record]
                 (|> (/.record arity type/0)
                     (/phase.result state)
                     (..fails? /.not_a_record)))
        )))

(def: .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [lux ..random_state
         .let [state [/extension.#bundle (/extension/analysis.bundle ..eval)
                      /extension.#state lux]]
         [type/0 term/0] ..simple_parameter
         [type/1 term/1] (random.only (|>> product.left (same? type/0) not)
                                      ..simple_parameter)
         lefts (# ! each (n.% 10) random.nat)
         right? random.bit]
        ($_ _.and
            ..test|general
            ..test|variant
            ..test|record
            (_.cover [/.invalid_type_application]
                     (and (|> (/.general archive.empty ..analysis (type (type/0 type/1)) (list term/0))
                              (/phase.result state)
                              (..fails? /.invalid_type_application))
                          (|> (/.variant lefts right? (type (type/0 type/1)))
                              (/phase.result state)
                              (..fails? /.invalid_type_application))
                          (|> (/.record lefts (type (type/0 type/1)))
                              (/phase.result state)
                              (..fails? /.invalid_type_application))))
            ))))
