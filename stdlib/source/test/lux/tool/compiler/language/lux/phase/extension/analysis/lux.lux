(.module:
  [lux (#- i64 int primitive)
   [abstract
    ["." monad (#+ do)]]
   [data
    ["%" text/format (#+ format)]
    ["." name]]
   ["r" math/random (#+ Random)]
   ["_" test (#+ Test)]
   [control
    pipe
    [io (#+ IO)]
    ["." try]
    [concurrency
     ["." atom]]]
   [data
    ["." product]]
   ["." type ("#\." equivalence)]
   [macro
    ["." code]]]
  [////
   [analysis
    ["_." primitive]]]
  [\\
   ["." /
    ["///#" //// #_
     [analysis
      ["#." scope]
      ["#." type]]
     [////
      ["." phase]
      [meta
       ["." archive]]]]]])

(template [<name> <success> <failure>]
  [(def: (<name> procedure params output_type)
     (-> Text (List Code) Type Bit)
     (|> (////scope.with_scope ""
                               (////type.with_type output_type
                                                   (_primitive.phase archive.empty (` ((~ (code.text procedure)) (~+ params))))))
         (phase.run _primitive.state)
         (case> (#try.Success _)
                <success>

                (#try.Failure _)
                <failure>)))]

  [check_success+ true false]
  [check_failure+ false true]
  )

(def: primitive
  (Random [Type Code])
  (r.only (|>> product.left (is? Any) not) _primitive.primitive))

(def: lux
  Test
  (do r.monad
    [[primT primC] ..primitive
     [antiT antiC] (|> ..primitive
                       (r.only (|>> product.left (type\= primT) not)))]
    ($_ _.and
        (_.test "Can test for reference equality."
                (check_success+ "lux is" (list primC primC) Bit))
        (_.test "Reference equality must be done with elements of the same type."
                (check_failure+ "lux is" (list primC antiC) Bit))
        (_.test "Can 'try' risky IO computations."
                (check_success+ "lux try"
                                (list (` ("lux io error" "YOLO")))
                                (type (Either Text primT))))
        )))

(def: i64
  Test
  (do {! r.monad}
    [subjectC (|> r.nat (\ ! map code.nat))
     signedC (|> r.int (\ ! map code.int))
     paramC (|> r.nat (\ ! map code.nat))]
    ($_ _.and
        (_.test "i64 'and'."
                (check_success+ "lux i64 and" (list paramC subjectC) Nat))
        (_.test "i64 'or'."
                (check_success+ "lux i64 or" (list paramC subjectC) Nat))
        (_.test "i64 'xor'."
                (check_success+ "lux i64 xor" (list paramC subjectC) Nat))
        (_.test "i64 left-shift."
                (check_success+ "lux i64 left-shift" (list paramC subjectC) Nat))
        (_.test "i64 logical-right-shift."
                (check_success+ "lux i64 logical-right-shift" (list paramC subjectC) Nat))
        (_.test "i64 arithmetic-right-shift."
                (check_success+ "lux i64 arithmetic-right-shift" (list paramC signedC) Int))
        (_.test "i64 equivalence."
                (check_success+ "lux i64 =" (list paramC subjectC) Bit))
        (_.test "i64 addition."
                (check_success+ "lux i64 +" (list paramC subjectC) Int))
        (_.test "i64 subtraction."
                (check_success+ "lux i64 -" (list paramC subjectC) Int))
        )))

(def: int
  Test
  (do {! r.monad}
    [subjectC (|> r.int (\ ! map code.int))
     paramC (|> r.int (\ ! map code.int))]
    ($_ _.and
        (_.test "Can multiply integers."
                (check_success+ "lux i64 *" (list paramC subjectC) Int))
        (_.test "Can divide integers."
                (check_success+ "lux i64 /" (list paramC subjectC) Int))
        (_.test "Can calculate remainder of integers."
                (check_success+ "lux i64 %" (list paramC subjectC) Int))
        (_.test "Can compare integers."
                (check_success+ "lux i64 <" (list paramC subjectC) Bit))
        (_.test "Can convert integer to text."
                (check_success+ "lux i64 char" (list subjectC) Text))
        (_.test "Can convert integer to fraction."
                (check_success+ "lux i64 f64" (list subjectC) Frac))
        )))

(def: frac
  Test
  (do {! r.monad}
    [subjectC (|> r.safe_frac (\ ! map code.frac))
     paramC (|> r.safe_frac (\ ! map code.frac))
     encodedC (|> r.safe_frac (\ ! map (|>> %.frac code.text)))]
    ($_ _.and
        (_.test "Can add frac numbers."
                (check_success+ "lux f64 +" (list paramC subjectC) Frac))
        (_.test "Can subtract frac numbers."
                (check_success+ "lux f64 -" (list paramC subjectC) Frac))
        (_.test "Can multiply frac numbers."
                (check_success+ "lux f64 *" (list paramC subjectC) Frac))
        (_.test "Can divide frac numbers."
                (check_success+ "lux f64 /" (list paramC subjectC) Frac))
        (_.test "Can calculate remainder of frac numbers."
                (check_success+ "lux f64 %" (list paramC subjectC) Frac))
        (_.test "Can test equivalence of frac numbers."
                (check_success+ "lux f64 =" (list paramC subjectC) Bit))
        (_.test "Can compare frac numbers."
                (check_success+ "lux f64 <" (list paramC subjectC) Bit))
        (_.test "Can obtain minimum frac number."
                (check_success+ "lux f64 min" (list) Frac))
        (_.test "Can obtain maximum frac number."
                (check_success+ "lux f64 max" (list) Frac))
        (_.test "Can obtain smallest frac number."
                (check_success+ "lux f64 smallest" (list) Frac))
        (_.test "Can convert frac number to integer."
                (check_success+ "lux f64 i64" (list subjectC) Int))
        (_.test "Can convert frac number to text."
                (check_success+ "lux f64 encode" (list subjectC) Text))
        (_.test "Can convert text to frac number."
                (check_success+ "lux f64 decode" (list encodedC) (type (Maybe Frac))))
        )))

(def: text
  Test
  (do {! r.monad}
    [subjectC (|> (r.unicode 5) (\ ! map code.text))
     paramC (|> (r.unicode 5) (\ ! map code.text))
     replacementC (|> (r.unicode 5) (\ ! map code.text))
     fromC (|> r.nat (\ ! map code.nat))
     toC (|> r.nat (\ ! map code.nat))]
    ($_ _.and
        (_.test "Can test text equivalence."
                (check_success+ "lux text =" (list paramC subjectC) Bit))
        (_.test "Compare texts in lexicographical order."
                (check_success+ "lux text <" (list paramC subjectC) Bit))
        (_.test "Can concatenate one text to another."
                (check_success+ "lux text concat" (list subjectC paramC) Text))
        (_.test "Can find the index of a piece of text inside a larger one that (may) contain it."
                (check_success+ "lux text index" (list fromC paramC subjectC) (type (Maybe Nat))))
        (_.test "Can query the size/length of a text."
                (check_success+ "lux text size" (list subjectC) Nat))
        (_.test "Can obtain the character code of a text at a given index."
                (check_success+ "lux text char" (list fromC subjectC) Nat))
        (_.test "Can clip a piece of text between 2 indices."
                (check_success+ "lux text clip" (list fromC toC subjectC) Text))
        )))

(def: io
  Test
  (do {! r.monad}
    [logC (|> (r.unicode 5) (\ ! map code.text))
     exitC (|> r.int (\ ! map code.int))]
    ($_ _.and
        (_.test "Can log messages to standard output."
                (check_success+ "lux io log" (list logC) Any))
        (_.test "Can throw a run-time error."
                (check_success+ "lux io error" (list logC) Nothing))
        (_.test "Can query the current time (as milliseconds since epoch)."
                (check_success+ "lux io current-time" (list) Int))
        )))

(def: .public test
  Test
  (<| (_.context (name.module (name_of /._)))
      ($_ _.and
          ..lux
          ..i64
          ..int
          ..frac
          ..text
          ..io
          )))
