(.module:
  [lux #*
   [abstract
    ["." monad (#+ do)]]
   [data
    ["%" text/format (#+ format)]
    ["." name]]
   ["r" math/random (#+ Random)]
   ["_" test (#+ Test)]
   [control
    pipe
    ["." try]]
   [data
    ["." maybe]
    ["." product]
    ["." text ("#\." equivalence)]
    [number
     ["n" nat]]
    [collection
     ["." list ("#\." functor)]]]
   ["." type]
   ["." macro
    ["." code]]]
  [//
   ["_." primitive]
   ["_." structure]]
  [\\
   ["." /
    ["/#" //
     ["#." module]
     ["#." type]
     ["/#" // #_
      ["/#" //
       ["#." analysis (#+ Analysis Operation)]
       [///
        ["#." reference]
        ["." phase]
        [meta
         ["." archive]]]]]]]])

(def: (check_apply expectedT num_args analysis)
  (-> Type Nat (Operation Analysis) Bit)
  (|> analysis
      (//type.with_type expectedT)
      (phase.run _primitive.state)
      (case> (#try.Success applyA)
             (let [[funcA argsA] (////analysis.application applyA)]
               (n.= num_args (list.size argsA)))

             (#try.Failure _)
             false)))

(def: abstraction
  (do r.monad
    [func_name (r.unicode 5)
     arg_name (|> (r.unicode 5) (r.only (|>> (text\= func_name) not)))
     [outputT outputC] _primitive.primitive
     [inputT _] _primitive.primitive
     #let [g!arg (code.local_identifier arg_name)]]
    (<| (_.context (%.name (name_of /.function)))
        ($_ _.and
            (_.test "Can analyse function."
                    (and (|> (//type.with_type (All [a] (-> a outputT))
                                               (/.function _primitive.phase func_name arg_name archive.empty outputC))
                             _structure.check_succeeds)
                         (|> (//type.with_type (All [a] (-> a a))
                                               (/.function _primitive.phase func_name arg_name archive.empty g!arg))
                             _structure.check_succeeds)))
            (_.test "Generic functions can always be specialized."
                    (and (|> (//type.with_type (-> inputT outputT)
                                               (/.function _primitive.phase func_name arg_name archive.empty outputC))
                             _structure.check_succeeds)
                         (|> (//type.with_type (-> inputT inputT)
                                               (/.function _primitive.phase func_name arg_name archive.empty g!arg))
                             _structure.check_succeeds)))
            (_.test "The function's name is bound to the function's type."
                    (|> (//type.with_type (Rec self (-> inputT self))
                                          (/.function _primitive.phase func_name arg_name archive.empty (code.local_identifier func_name)))
                        _structure.check_succeeds))
            ))))

(def: apply
  (do {! r.monad}
    [full_args (|> r.nat (\ ! map (|>> (n.% 10) (n.max 2))))
     partial_args (|> r.nat (\ ! map (n.% full_args)))
     var_idx (|> r.nat (\ ! map (|>> (n.% full_args) (n.max 1))))
     inputsTC (r.list full_args _primitive.primitive)
     #let [inputsT (list\map product.left inputsTC)
           inputsC (list\map product.right inputsTC)]
     [outputT outputC] _primitive.primitive
     #let [funcT (type.function inputsT outputT)
           partialT (type.function (list.drop partial_args inputsT) outputT)
           varT (#.Parameter 1)
           polyT (<| (type.univ_q 1)
                     (type.function (list.concat (list (list.take var_idx inputsT)
                                                       (list varT)
                                                       (list.drop (inc var_idx) inputsT))))
                     varT)
           poly_inputT (maybe.assume (list.item var_idx inputsT))
           partial_poly_inputsT (list.drop (inc var_idx) inputsT)
           partial_polyT1 (<| (type.function partial_poly_inputsT)
                              poly_inputT)
           partial_polyT2 (<| (type.univ_q 1)
                              (type.function (#.Item varT partial_poly_inputsT))
                              varT)
           dummy_function (#////analysis.Function (list) (#////analysis.Reference (////reference.local 1)))]]
    (<| (_.context (%.name (name_of /.apply)))
        ($_ _.and
            (_.test "Can analyse monomorphic type application."
                    (|> (/.apply _primitive.phase inputsC funcT dummy_function archive.empty (' []))
                        (check_apply outputT full_args)))
            (_.test "Can partially apply functions."
                    (|> (/.apply _primitive.phase (list.take partial_args inputsC) funcT dummy_function archive.empty (' []))
                        (check_apply partialT partial_args)))
            (_.test "Can apply polymorphic functions."
                    (|> (/.apply _primitive.phase inputsC polyT dummy_function archive.empty (' []))
                        (check_apply poly_inputT full_args)))
            (_.test "Polymorphic partial application propagates found type-vars."
                    (|> (/.apply _primitive.phase (list.take (inc var_idx) inputsC) polyT dummy_function archive.empty (' []))
                        (check_apply partial_polyT1 (inc var_idx))))
            (_.test "Polymorphic partial application preserves quantification for type-vars."
                    (|> (/.apply _primitive.phase (list.take var_idx inputsC) polyT dummy_function archive.empty (' []))
                        (check_apply partial_polyT2 var_idx)))
            ))))

(def: #export test
  Test
  (<| (_.context (name.module (name_of /._)))
      ($_ _.and
          ..abstraction
          ..apply
          )))
