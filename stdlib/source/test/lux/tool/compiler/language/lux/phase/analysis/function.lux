(.module:
  [lux "*"
   [abstract
    ["[0]" monad {"+" do}]]
   [data
    ["%" text/format {"+" format}]]
   ["r" math/random {"+" Random}]
   ["_" test {"+" Test}]
   [control
    pipe
    ["[0]" maybe]
    ["[0]" try]]
   [data
    ["[0]" product]
    ["[0]" text ("[1]#[0]" equivalence)]
    [number
     ["n" nat]]
    [collection
     ["[0]" list ("[1]#[0]" functor)]]]
   ["[0]" type]
   ["[0]" macro
    ["[0]" code]]
   [meta
    ["[0]" symbol]]]
  [//
   ["_[0]" primitive]
   ["_[0]" structure]]
  [\\
   ["[0]" /
    ["/[1]" //
     ["[1][0]" module]
     ["[1][0]" type]
     ["/[1]" // "_"
      ["/[1]" //
       ["[1][0]" analysis {"+" Analysis Operation}]
       [///
        ["[1][0]" reference]
        ["[0]" phase]
        [meta
         ["[0]" archive]]]]]]]])

(def: (check_apply expectedT num_args analysis)
  (-> Type Nat (Operation Analysis) Bit)
  (|> analysis
      (//type.with_type expectedT)
      (phase.result _primitive.state)
      (case> {try.#Success applyA}
             (let [[funcA argsA] (////analysis.application applyA)]
               (n.= num_args (list.size argsA)))

             {try.#Failure _}
             false)))

(def: abstraction
  (do r.monad
    [func_name (r.unicode 5)
     arg_name (|> (r.unicode 5) (r.only (|>> (text#= func_name) not)))
     [outputT outputC] _primitive.primitive
     [inputT _] _primitive.primitive
     .let [g!arg (code.local_identifier arg_name)]]
    (<| (_.context (%.symbol (name_of /.function)))
        ($_ _.and
            (_.test "Can analyse function."
                    (and (|> (//type.with_type (All (_ a) (-> a outputT))
                               (/.function _primitive.phase func_name arg_name archive.empty outputC))
                             _structure.check_succeeds)
                         (|> (//type.with_type (All (_ a) (-> a a))
                               (/.function _primitive.phase func_name arg_name archive.empty g!arg))
                             _structure.check_succeeds)))
            (_.test "Generic functions can always be specialized."
                    (and (|> (//type.with_type (-> inputT outputT)
                               (/.function _primitive.phase func_name arg_name archive.empty outputC))
                             _structure.check_succeeds)
                         (|> (//type.with_type (-> inputT inputT)
                               (/.function _primitive.phase func_name arg_name archive.empty g!arg))
                             _structure.check_succeeds)))
            (_.test "The function's name is bound to the function's type."
                    (|> (//type.with_type (Rec self (-> inputT self))
                          (/.function _primitive.phase func_name arg_name archive.empty (code.local_identifier func_name)))
                        _structure.check_succeeds))
            ))))

(def: apply
  (do [! r.monad]
    [full_args (|> r.nat (# ! each (|>> (n.% 10) (n.max 2))))
     partial_args (|> r.nat (# ! each (n.% full_args)))
     var_idx (|> r.nat (# ! each (|>> (n.% full_args) (n.max 1))))
     inputsTC (r.list full_args _primitive.primitive)
     .let [inputsT (list#each product.left inputsTC)
           inputsC (list#each product.right inputsTC)]
     [outputT outputC] _primitive.primitive
     .let [funcT (type.function inputsT outputT)
           partialT (type.function (list.after partial_args inputsT) outputT)
           varT {.#Parameter 1}
           polyT (<| (type.univ_q 1)
                     (type.function (list.together (list (list.first var_idx inputsT)
                                                         (list varT)
                                                         (list.after (++ var_idx) inputsT))))
                     varT)
           poly_inputT (maybe.trusted (list.item var_idx inputsT))
           partial_poly_inputsT (list.after (++ var_idx) inputsT)
           partial_polyT1 (<| (type.function partial_poly_inputsT)
                              poly_inputT)
           partial_polyT2 (<| (type.univ_q 1)
                              (type.function {.#Item varT partial_poly_inputsT})
                              varT)
           dummy_function {////analysis.#Function (list) {////analysis.#Reference (////reference.local 1)}}]]
    (<| (_.context (%.symbol (name_of /.apply)))
        ($_ _.and
            (_.test "Can analyse monomorphic type application."
                    (|> (/.apply _primitive.phase inputsC funcT dummy_function archive.empty (' []))
                        (check_apply outputT full_args)))
            (_.test "Can partially apply functions."
                    (|> (/.apply _primitive.phase (list.first partial_args inputsC) funcT dummy_function archive.empty (' []))
                        (check_apply partialT partial_args)))
            (_.test "Can apply polymorphic functions."
                    (|> (/.apply _primitive.phase inputsC polyT dummy_function archive.empty (' []))
                        (check_apply poly_inputT full_args)))
            (_.test "Polymorphic partial application propagates found type-vars."
                    (|> (/.apply _primitive.phase (list.first (++ var_idx) inputsC) polyT dummy_function archive.empty (' []))
                        (check_apply partial_polyT1 (++ var_idx))))
            (_.test "Polymorphic partial application preserves quantification for type-vars."
                    (|> (/.apply _primitive.phase (list.first var_idx inputsC) polyT dummy_function archive.empty (' []))
                        (check_apply partial_polyT2 var_idx)))
            ))))

(def: .public test
  Test
  (<| (_.context (symbol.module (name_of /._)))
      ($_ _.and
          ..abstraction
          ..apply
          )))
