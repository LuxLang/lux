(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]]
   [control
    ["[0]" function]
    ["[0]" try ("[1]#[0]" functor)]
    ["[0]" exception]]
   [data
    ["[0]" product]
    ["[0]" text
     ["%" format]]
    [collection
     ["[0]" list]]]
   [macro
    ["[0]" code]]
   [math
    ["[0]" random]
    [number
     ["n" nat]]]
   [meta
    ["[0]" symbol "_"
     ["$[1]" \\test]]]
   ["[0]" type ("[1]#[0]" equivalence)
    ["$[1]" \\test]
    ["[0]" check]]]]
 [\\library
  ["[0]" /
   ["/[1]" //
    [//
     ["[1][0]" extension
      ["[1]/[0]" analysis "_"
       ["[1]" lux]]]
     [//
      ["[1][0]" analysis {"+" Analysis}
       [evaluation {"+" Eval}]
       ["[2][0]" macro]
       ["[2][0]" module]
       ["[2][0]" type
        ["$[1]" \\test]]
       ["[2][0]" inference "_"
        ["$[1]" \\test]]]
      [///
       ["[1][0]" phase ("[1]#[0]" monad)]
       [meta
        ["[0]" archive]]]]]]]])

(def: (eval archive type term)
  Eval
  (//phase#in []))

(def: (expander macro inputs state)
  //macro.Expander
  {try.#Success ((.macro macro) inputs state)})

(def: analysis
  //analysis.Phase
  (//.phase ..expander))

(def: test|function
  Test
  (do [! random.monad]
    [lux $//type.random_state
     .let [state [//extension.#bundle (//extension/analysis.bundle ..eval)
                  //extension.#state lux]]
     input/0 ($type.random 0)
     input/1 ($type.random 0)
     function/0 (random.lower_case 1)
     function/1 (random.lower_case 2)
     argument/0 (random.lower_case 3)
     argument/1 (random.lower_case 4)
     module/0 (random.lower_case 5)
     [output/0 term/0] $//inference.simple_parameter
     [output/1 term/1] (random.only (|>> product.left (same? output/0) not)
                                    $//inference.simple_parameter)
     name/0 ($symbol.random 1 1)
     .let [$function/0 (code.local function/0)
           $function/1 (code.local function/1)
           $argument/0 (code.local argument/0)
           $argument/1 (code.local argument/1)]]
    (all _.and
         (_.cover [/.function]
                  (let [function?' (is (-> Type Code (-> [(List Analysis) Analysis] Bit) Bit)
                                       (function (_ function_type output_term ?)
                                         (|> (do //phase.monad
                                               [analysis (|> (/.function ..analysis function/0 argument/0 archive.empty
                                                               output_term)
                                                             (//type.expecting function_type))]
                                               (in (case analysis
                                                     {//analysis.#Function it}
                                                     (? it)

                                                     _
                                                     false)))
                                             (//module.with 0 module/0)
                                             (//phase#each product.right)
                                             (//phase.result state)
                                             (try.else false))))
                        function? (is (-> Type Code Bit)
                                      (function (_ function_type output_term)
                                        (function?' function_type output_term (function.constant true))))
                        inferring? (is (-> Type Code Bit)
                                       (function (_ :expected: term)
                                         (|> (do //phase.monad
                                               [[:actual: analysis] (|> (/.function ..analysis function/0 argument/0 archive.empty
                                                                          term)
                                                                        //type.inferring)]
                                               (in (case analysis
                                                     {//analysis.#Function [actual_env actual_body]}
                                                     (type#= :expected: :actual:)

                                                     _
                                                     false)))
                                             (//module.with 0 module/0)
                                             (//phase#each product.right)
                                             (//phase.result state)
                                             (try.else false))))]
                    (and (function? (-> input/0 output/0) term/0)
                         (function? (-> input/0 input/0) $argument/0)

                         (function? {.#Named name/0 (-> input/0 output/0)} term/0)
                         
                         (function? (All (_ a) (-> a a)) $argument/0)
                         (function? (Ex (_ a) (-> a a)) $argument/0)
                         (function? (Ex (_ a) (-> input/0 a)) term/0)
                         (function? (Ex (_ a) (-> a a)) term/0)
                         (function? (Rec self (-> input/0 self)) $function/0)

                         (function? (type ((All (_ a) (-> a a)) output/0)) term/0)
                         (not (function? (type ((All (_ a) (-> a a)) output/1)) term/0))

                         (function? (type ((Ex (_ a) (-> a a)) output/0)) term/0)
                         (not (function? (type ((Ex (_ a) (-> a a)) output/1)) term/0))

                         (function?' (-> input/0 input/1 input/0) (` ([(~ $function/1) (~ $argument/1)] (~ $argument/0)))
                                     (function (_ [outer body])
                                       (and (list.empty? outer)
                                            (case body
                                              {//analysis.#Function [inner body]}
                                              (n.= 1 (list.size inner))

                                              _
                                              false))))
                         (function?' (-> input/0 input/1 input/1) (` ([(~ $function/1) (~ $argument/1)] (~ $argument/1)))
                                     (function (_ [outer body])
                                       (and (list.empty? outer)
                                            (case body
                                              {//analysis.#Function [inner body]}
                                              (n.= 0 (list.size inner))

                                              _
                                              false))))

                         (|> (do //phase.monad
                               [[@var :var:] (//type.check check.var)
                                _ (//type.check (check.check :var: (-> input/0 output/0)))
                                analysis (|> (/.function ..analysis function/0 argument/0 archive.empty
                                               term/0)
                                             (//type.expecting :var:))]
                               (in (case analysis
                                     {//analysis.#Function [actual_env actual_body]}
                                     true

                                     _
                                     false)))
                             (//module.with 0 module/0)
                             (//phase#each product.right)
                             (//phase.result state)
                             (try.else false))
                         
                         (inferring? (All (_ a) (-> a output/0)) term/0)
                         (inferring? (All (_ a) (-> a a)) $argument/0)
                         (inferring? (All (_ @0) (-> @0 @0 (And .Bit @0)))
                                     (` ([(~ $function/1) (~ $argument/1)]
                                         [("lux is" (~ $argument/0) (~ $argument/1))
                                          (~ $argument/1)]))))))
         (_.cover [/.cannot_analyse]
                  (|> (do //phase.monad
                        [analysis (|> (/.function ..analysis function/0 argument/0 archive.empty
                                        term/1)
                                      (//type.expecting (-> input/0 output/0)))]
                        (in (case analysis
                              {//analysis.#Function [actual_env actual_body]}
                              true

                              _
                              false)))
                      (//module.with 0 module/0)
                      (//phase#each product.right)
                      (//phase.result state)
                      (exception.otherwise (text.contains? (the exception.#label /.cannot_analyse)))))
         )))

(def: test|apply
  Test
  (do [! random.monad]
    [lux $//type.random_state
     .let [state [//extension.#bundle (//extension/analysis.bundle ..eval)
                  //extension.#state lux]]
     [input/0 term/0] $//inference.simple_parameter
     [input/1 term/1] (random.only (|>> product.left (same? input/0) not)
                                   $//inference.simple_parameter)
     output/0 ($type.random 0)
     module/0 (random.lower_case 1)]
    (all _.and
         (_.cover [/.apply]
                  (let [reification? (is (-> Type (List Code) Type Bit)
                                         (function (_ :abstraction: terms :expected:)
                                           (|> (do //phase.monad
                                                 [[:actual: analysis] (|> (/.apply ..analysis terms
                                                                                   :abstraction:
                                                                                   (//analysis.unit)
                                                                                   archive.empty
                                                                                   (' []))
                                                                          //type.inferring)]
                                                 (in (and (check.subsumes? :expected: :actual:)
                                                          (case analysis
                                                            {//analysis.#Apply _}
                                                            true

                                                            _
                                                            false))))
                                               (//module.with 0 module/0)
                                               (//phase#each product.right)
                                               (//phase.result state)
                                               (try.else false))))]
                    (and (reification? (-> input/0 input/1 output/0) (list term/0 term/1) output/0)
                         (reification? (-> input/0 input/1 output/0) (list term/0) (-> input/1 output/0))
                         (reification? (All (_ a) (-> a a)) (list term/0) input/0)
                         (reification? (All (_ a) (-> a a a)) (list term/0) (-> input/0 input/0))
                         (reification? (All (_ a) (-> input/0 a)) (list term/0) .Nothing)
                         (reification? (All (_ a b) (-> a b a)) (list term/0) (All (_ b) (-> b input/0)))
                         (reification? (Ex (_ a) (-> a input/0)) (list (` ("lux io error" ""))) input/0)
                         (reification? (Ex (_ a) (-> input/0 a)) (list term/0) .Any))))
         (_.cover [/.cannot_apply]
                  (|> (do //phase.monad
                        [_ (|> (/.apply ..analysis (list term/1 term/0)
                                        (-> input/0 input/1 output/0)
                                        (//analysis.unit)
                                        archive.empty
                                        (' []))
                               (//type.expecting output/0))]
                        (in false))
                      (//module.with 0 module/0)
                      (//phase#each product.right)
                      (//phase.result state)
                      (exception.otherwise (text.contains? (the exception.#label /.cannot_apply)))))
         )))

(def: .public test
  Test
  (<| (_.covering /._)
      (all _.and
           ..test|function
           ..test|apply
           )))
