(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]]
   [control
    [pipe {"+" case>}]
    ["[0]" try ("[1]#[0]" functor)]
    ["[0]" exception]]
   [data
    ["[0]" product]
    ["[0]" text]]
   [math
    ["[0]" random]]
   ["[0]" type ("[1]#[0]" equivalence)
    ["$[1]" \\test]]]]
 [\\library
  ["[0]" /
   ["/[1]" // "_"
    [//
     ["[1][0]" extension]
     [//
      ["[1][0]" analysis
       ["[2][0]" scope]
       ["[2][0]" module]
       ["[2][0]" type
        ["$[1]" \\test]]]
      [///
       ["[1][0]" phase ("[1]#[0]" monad)]]]]]]])

(def: .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [lux $//type.random_state
         .let [state [//extension.#bundle //extension.empty
                      //extension.#state lux]]
         expected_name (random.ascii/lower 1)
         expected_type ($type.random 0)
         expected_module (random.ascii/lower 2)
         import (random.ascii/lower 3)
         expected_label (random.ascii/lower 4)
         record? random.bit]
        ($_ _.and
            (_.cover [/.reference]
                     (let [can_find_local_variable!
                           (|> (/.reference ["" expected_name])
                               (//scope.with_local [expected_name expected_type])
                               //type.inferring
                               //scope.with
                               (//module.with 0 expected_module)
                               (//phase#each product.right)
                               (//phase.result state)
                               (try#each (|>> product.right
                                              (case> (^ [actual_type (//analysis.local 0)])
                                                     (type#= expected_type actual_type)

                                                     _
                                                     false)))
                               (try.else false))

                           can_find_foreign_variable!
                           (|> (/.reference ["" expected_name])
                               //type.inferring
                               //scope.with
                               (//scope.with_local [expected_name expected_type])
                               //scope.with
                               (//module.with 0 expected_module)
                               (//phase#each product.right)
                               (//phase.result state)
                               (try#each (|>> product.right
                                              product.right
                                              (case> (^ [actual_type (//analysis.foreign 0)])
                                                     (type#= expected_type actual_type)

                                                     _
                                                     false)))
                               (try.else false))

                           can_find_local_definition!
                           (|> (do //phase.monad
                                 [_ (//module.define expected_name {.#Definition [#0 expected_type []]})]
                                 (/.reference ["" expected_name]))
                               //type.inferring
                               (//module.with 0 expected_module)
                               (//phase.result state)
                               (try#each (|>> product.right
                                              (case> (^ [actual_type (//analysis.constant [actual_module actual_name])])
                                                     (and (type#= expected_type actual_type)
                                                          (same? expected_module actual_module)
                                                          (same? expected_name actual_name))

                                                     _
                                                     false)))
                               (try.else false))

                           can_find_foreign_definition!
                           (|> (do //phase.monad
                                 [_ (//module.with 0 import
                                      (//module.define expected_name {.#Definition [#1 expected_type []]}))
                                  _ (//module.import import)]
                                 (/.reference [import expected_name]))
                               //type.inferring
                               (//module.with 0 expected_module)
                               (//phase.result state)
                               (try#each (|>> product.right
                                              (case> (^ [actual_type (//analysis.constant [actual_module actual_name])])
                                                     (and (type#= expected_type actual_type)
                                                          (same? import actual_module)
                                                          (same? expected_name actual_name))

                                                     _
                                                     false)))
                               (try.else false))

                           can_find_alias!
                           (|> (do //phase.monad
                                 [_ (//module.with 0 import
                                      (//module.define expected_name {.#Definition [#1 expected_type []]}))
                                  _ (//module.import import)
                                  _ (//module.define expected_name {.#Alias [import expected_name]})]
                                 (/.reference [expected_module expected_name]))
                               //type.inferring
                               (//module.with 0 expected_module)
                               (//phase.result state)
                               (try#each (|>> product.right
                                              (case> (^ [actual_type (//analysis.constant [actual_module actual_name])])
                                                     (and (type#= expected_type actual_type)
                                                          (same? import actual_module)
                                                          (same? expected_name actual_name))

                                                     _
                                                     false)))
                               (try.else false))

                           can_find_type!
                           (|> (do //phase.monad
                                 [_ (//module.define expected_name {.#Type [#0 expected_type
                                                                            (if record?
                                                                              {.#Right [expected_label (list)]}
                                                                              {.#Left [expected_label (list)]})]})]
                                 (/.reference [expected_module expected_name]))
                               //type.inferring
                               (//module.with 0 expected_module)
                               (//phase.result state)
                               (try#each (|>> product.right
                                              (case> (^ [actual_type (//analysis.constant [actual_module actual_name])])
                                                     (and (type#= .Type actual_type)
                                                          (same? expected_module actual_module)
                                                          (same? expected_name actual_name))

                                                     _
                                                     false)))
                               (try.else false))]
                       (and can_find_local_variable!
                            can_find_foreign_variable!
                            
                            can_find_local_definition!
                            can_find_foreign_definition!

                            can_find_alias!
                            can_find_type!)))
            (_.cover [/.foreign_module_has_not_been_imported]
                     (let [scenario (: (-> Type Global Bit)
                                       (function (_ expected_type it)
                                         (|> (do //phase.monad
                                               [_ (//module.with 0 import
                                                    (//module.define expected_name it))
                                                _ (/.reference [import expected_name])]
                                               (in false))
                                             (//type.expecting expected_type)
                                             (//module.with 0 expected_module)
                                             (//phase#each product.right)
                                             (//phase.result state)
                                             (exception.otherwise (text.contains? (value@ exception.#label /.foreign_module_has_not_been_imported)))
                                             )))]
                       (and (scenario expected_type {.#Definition [#1 expected_type []]})
                            (scenario .Type {.#Type [#1 expected_type
                                                     (if record?
                                                       {.#Right [expected_label (list)]}
                                                       {.#Left [expected_label (list)]})]}))))
            (_.cover [/.definition_has_not_been_exported]
                     (let [scenario (: (-> Type Global Bit)
                                       (function (_ expected_type it)
                                         (|> (do //phase.monad
                                               [_ (//module.with 0 import
                                                    (//module.define expected_name it))
                                                _ (/.reference [import expected_name])]
                                               (in false))
                                             (//type.expecting expected_type)
                                             (//module.with 0 expected_module)
                                             (//phase#each product.right)
                                             (//phase.result state)
                                             (exception.otherwise (text.contains? (value@ exception.#label /.definition_has_not_been_exported)))
                                             )))]
                       (and (scenario expected_type {.#Definition [#0 expected_type []]})
                            (scenario .Type {.#Type [#0 expected_type
                                                     (if record?
                                                       {.#Right [expected_label (list)]}
                                                       {.#Left [expected_label (list)]})]}))))
            (_.cover [/.labels_are_not_definitions]
                     (let [scenario (: (-> Type Global Bit)
                                       (function (_ expected_type it)
                                         (|> (do //phase.monad
                                               [_ (//module.with 0 import
                                                    (//module.define expected_label it))
                                                _ (/.reference [import expected_label])]
                                               (in false))
                                             (//type.expecting expected_type)
                                             (//module.with 0 expected_module)
                                             (//phase#each product.right)
                                             (//phase.result state)
                                             (exception.otherwise (text.contains? (value@ exception.#label /.labels_are_not_definitions))))))]
                       (and (scenario expected_type {.#Tag [#1 expected_type (list) 0]})
                            (scenario expected_type {.#Slot [#1 expected_type (list) 0]}))))
            ))))
