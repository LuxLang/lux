(.using
 [library
  [lux (.full)
   ["_" test (.only Test)]
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" pipe]
    ["[0]" try ("[1]#[0]" functor)]
    ["[0]" exception]]
   [data
    ["[0]" product]
    ["[0]" text]]
   [math
    ["[0]" random]]
   ["[0]" type ("[1]#[0]" equivalence)
    ["$[1]" \\test]]]]
 [\\library
  ["[0]" / (.only)
   ["/[1]" //
    [//
     ["[1][0]" extension]
     [//
      ["[1][0]" analysis (.only)
       ["[2][0]" scope]
       ["[2][0]" module]
       ["[2][0]" type (.only)
        ["$[1]" \\test]]]
      [///
       ["[1][0]" phase ("[1]#[0]" monad)]]]]]]])

(def: .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [lux $//type.random_state
         .let [state [//extension.#bundle //extension.empty
                      //extension.#state lux]]
         expected_name (random.lower_case 1)
         expected_type ($type.random 0)
         expected_module (random.lower_case 2)
         import (random.lower_case 3)
         expected_label (random.lower_case 4)
         record? random.bit]
        (all _.and
             (_.coverage [/.reference]
               (let [can_find_local_variable!
                     (|> (/.reference ["" expected_name])
                         (//scope.with_local [expected_name expected_type])
                         //type.inferring
                         //scope.with
                         (//module.with 0 expected_module)
                         (//phase#each product.right)
                         (//phase.result state)
                         (try#each (|>> product.right
                                        (pipe.case
                                          (pattern [actual_type (//analysis.local 0)])
                                          (type#= expected_type actual_type)

                                          _
                                          false)))
                         (try.else false))

                     can_find_foreign_variable!
                     (|> (/.reference ["" expected_name])
                         //type.inferring
                         //scope.with
                         (//scope.with_local [expected_name expected_type])
                         //scope.with
                         (//module.with 0 expected_module)
                         (//phase#each product.right)
                         (//phase.result state)
                         (try#each (|>> product.right
                                        product.right
                                        (pipe.case
                                          (pattern [actual_type (//analysis.foreign 0)])
                                          (type#= expected_type actual_type)

                                          _
                                          false)))
                         (try.else false))

                     can_find_local_definition!
                     (|> (do //phase.monad
                           [_ (//module.define expected_name {.#Definition [#0 expected_type []]})]
                           (/.reference ["" expected_name]))
                         //type.inferring
                         (//module.with 0 expected_module)
                         (//phase.result state)
                         (try#each (|>> product.right
                                        (pipe.case
                                          (pattern [actual_type (//analysis.constant [actual_module actual_name])])
                                          (and (type#= expected_type actual_type)
                                               (same? expected_module actual_module)
                                               (same? expected_name actual_name))

                                          _
                                          false)))
                         (try.else false))

                     can_find_foreign_definition!
                     (|> (do //phase.monad
                           [_ (//module.with 0 import
                                (//module.define expected_name {.#Definition [#1 expected_type []]}))
                            _ (//module.import import)]
                           (/.reference [import expected_name]))
                         //type.inferring
                         (//module.with 0 expected_module)
                         (//phase.result state)
                         (try#each (|>> product.right
                                        (pipe.case
                                          (pattern [actual_type (//analysis.constant [actual_module actual_name])])
                                          (and (type#= expected_type actual_type)
                                               (same? import actual_module)
                                               (same? expected_name actual_name))

                                          _
                                          false)))
                         (try.else false))

                     can_find_alias!
                     (|> (do //phase.monad
                           [_ (//module.with 0 import
                                (//module.define expected_name {.#Definition [#1 expected_type []]}))
                            _ (//module.import import)
                            _ (//module.define expected_name {.#Alias [import expected_name]})]
                           (/.reference [expected_module expected_name]))
                         //type.inferring
                         (//module.with 0 expected_module)
                         (//phase.result state)
                         (try#each (|>> product.right
                                        (pipe.case
                                          (pattern [actual_type (//analysis.constant [actual_module actual_name])])
                                          (and (type#= expected_type actual_type)
                                               (same? import actual_module)
                                               (same? expected_name actual_name))

                                          _
                                          false)))
                         (try.else false))

                     can_find_type!
                     (|> (do //phase.monad
                           [_ (//module.define expected_name {.#Type [#0 expected_type
                                                                      (if record?
                                                                        {.#Right [expected_label (list)]}
                                                                        {.#Left [expected_label (list)]})]})]
                           (/.reference [expected_module expected_name]))
                         //type.inferring
                         (//module.with 0 expected_module)
                         (//phase.result state)
                         (try#each (|>> product.right
                                        (pipe.case
                                          (pattern [actual_type (//analysis.constant [actual_module actual_name])])
                                          (and (type#= .Type actual_type)
                                               (same? expected_module actual_module)
                                               (same? expected_name actual_name))

                                          _
                                          false)))
                         (try.else false))]
                 (and can_find_local_variable!
                      can_find_foreign_variable!
                      
                      can_find_local_definition!
                      can_find_foreign_definition!

                      can_find_alias!
                      can_find_type!)))
             (_.coverage [/.foreign_module_has_not_been_imported]
               (let [scenario (is (-> Type Global Bit)
                                  (function (_ expected_type it)
                                    (|> (do //phase.monad
                                          [_ (//module.with 0 import
                                               (//module.define expected_name it))
                                           _ (/.reference [import expected_name])]
                                          (in false))
                                        (//type.expecting expected_type)
                                        (//module.with 0 expected_module)
                                        (//phase#each product.right)
                                        (//phase.result state)
                                        (exception.otherwise (text.contains? (the exception.#label /.foreign_module_has_not_been_imported)))
                                        )))]
                 (and (scenario expected_type {.#Definition [#1 expected_type []]})
                      (scenario .Type {.#Type [#1 expected_type
                                               (if record?
                                                 {.#Right [expected_label (list)]}
                                                 {.#Left [expected_label (list)]})]}))))
             (_.coverage [/.definition_has_not_been_exported]
               (let [scenario (is (-> Type Global Bit)
                                  (function (_ expected_type it)
                                    (|> (do //phase.monad
                                          [_ (//module.with 0 import
                                               (//module.define expected_name it))
                                           _ (/.reference [import expected_name])]
                                          (in false))
                                        (//type.expecting expected_type)
                                        (//module.with 0 expected_module)
                                        (//phase#each product.right)
                                        (//phase.result state)
                                        (exception.otherwise (text.contains? (the exception.#label /.definition_has_not_been_exported)))
                                        )))]
                 (and (scenario expected_type {.#Definition [#0 expected_type []]})
                      (scenario .Type {.#Type [#0 expected_type
                                               (if record?
                                                 {.#Right [expected_label (list)]}
                                                 {.#Left [expected_label (list)]})]}))))
             (_.coverage [/.labels_are_not_definitions]
               (let [scenario (is (-> Type Global Bit)
                                  (function (_ expected_type it)
                                    (|> (do //phase.monad
                                          [_ (//module.with 0 import
                                               (//module.define expected_label it))
                                           _ (/.reference [import expected_label])]
                                          (in false))
                                        (//type.expecting expected_type)
                                        (//module.with 0 expected_module)
                                        (//phase#each product.right)
                                        (//phase.result state)
                                        (exception.otherwise (text.contains? (the exception.#label /.labels_are_not_definitions))))))]
                 (and (scenario expected_type {.#Tag [#1 expected_type (list) 0]})
                      (scenario expected_type {.#Slot [#1 expected_type (list) 0]}))))
             ))))
