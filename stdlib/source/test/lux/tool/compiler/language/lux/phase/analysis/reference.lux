(.module:
  [lux "*"
   [abstract
    ["." monad {"+" [do]}]]
   [data
    ["." name ("#\." equivalence)]]
   ["r" math/random {"+" [Random]}]
   ["_" test {"+" [Test]}]
   [control
    pipe
    ["." try {"+" [Try]}]]
   [data
    ["." text ("#\." equivalence)]
    [number
     ["n" nat]]]
   ["." type ("#\." equivalence)]
   [macro
    ["." code]]]
  [//
   ["_." primitive]]
  [\\
   ["." /
    ["/#" //
     ["#." scope]
     ["#." module]
     ["#." type]
     ["/#" // "_"
      ["/#" //
       ["#." analysis {"+" [Analysis Variant Tag Operation]}]
       [///
        ["#." reference]
        ["." phase]
        [meta
         ["." archive]]]]]]]])

(type: Check (-> (Try Any) Bit))

(template [<name> <on_success> <on_failure>]
  [(def: <name>
     Check
     (|>> (case> (#try.Success _)
                 <on_success>

                 (#try.Failure _)
                 <on_failure>)))]

  [success? true false]
  [failure? false true]
  )

(def: (reach_test var_name [export? def_module] [import? dependent_module] check!)
  (-> Text [Bit Text] [Bit Text] Check Bit)
  (|> (do [! phase.monad]
        [_ (//module.with_module 0 def_module
             (//module.define var_name (#.Right [export? Any (' {}) []])))]
        (//module.with_module 0 dependent_module
          (do !
            [_ (if import?
                 (//module.import def_module)
                 (in []))]
            (//type.with_inference
              (_primitive.phase archive.empty (code.identifier [def_module var_name]))))))
      (phase.result _primitive.state)
      check!))

(def: .public test
  (<| (_.context (name.module (name_of /._)))
      (do r.monad
        [[expectedT _] _primitive.primitive
         def_module (r.unicode 5)
         scope_name (r.unicode 5)
         var_name (r.unicode 5)
         dependent_module (|> (r.unicode 5)
                              (r.only (|>> (text\= def_module) not)))]
        ($_ _.and
            (_.test "Can analyse variable."
                    (|> (//scope.with_scope scope_name
                          (//scope.with_local [var_name expectedT]
                            (//type.with_inference
                              (_primitive.phase archive.empty (code.local_identifier var_name)))))
                        (phase.result _primitive.state)
                        (case> (^ (#try.Success [inferredT (#////analysis.Reference (////reference.local var))]))
                               (and (type\= expectedT inferredT)
                                    (n.= 0 var))

                               _
                               false)))
            (_.test "Can analyse definition (in the same module)."
                    (let [def_name [def_module var_name]]
                      (|> (do phase.monad
                            [_ (//module.define var_name (#.Right [false expectedT (' {}) []]))]
                            (//type.with_inference
                              (_primitive.phase archive.empty (code.identifier def_name))))
                          (//module.with_module 0 def_module)
                          (phase.result _primitive.state)
                          (case> (^ (#try.Success [_ inferredT (#////analysis.Reference (////reference.constant constant_name))]))
                                 (and (type\= expectedT inferredT)
                                      (name\= def_name constant_name))

                                 _
                                 false))))
            (_.test "Can analyse definition (if exported from imported module)."
                    (reach_test var_name [true def_module] [true dependent_module] success?))
            (_.test "Cannot analyse definition (if not exported from imported module)."
                    (reach_test var_name [false def_module] [true dependent_module] failure?))
            (_.test "Cannot analyse definition (if exported from non-imported module)."
                    (reach_test var_name [true def_module] [false dependent_module] failure?))
            ))))
