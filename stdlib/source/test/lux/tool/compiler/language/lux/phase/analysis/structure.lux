(.module:
  [lux #*
   [abstract ["." monad (#+ do)]]
   [data
    ["%" text/format (#+ format)]
    ["." name]]
   ["r" math/random (#+ Random)]
   ["_" test (#+ Test)]
   [control
    pipe
    ["." maybe]
    ["." try]]
   [data
    ["." bit ("#\." equivalence)]
    ["." product]
    ["." text]
    [number
     ["n" nat]]
    [collection
     ["." list ("#\." functor)]
     ["." set]]]
   ["." type
    ["." check]]
   [macro
    ["." code]]]
  [//
   ["_." primitive]]
  [\\
   ["." /
    ["/#" //
     ["#." module]
     ["#." type]
     ["/#" // #_
      ["/#" //
       ["#." analysis (#+ Analysis Variant Tag Operation)]
       [///
        ["." phase]
        [meta
         ["." archive]]]]]]]])

(template [<name> <on_success> <on_error>]
  [(def: .public <name>
     (All [a] (-> (Operation a) Bit))
     (|>> (phase.result _primitive.state)
          (case> (#try.Success _)
                 <on_success>

                 _
                 <on_error>)))]

  [check_succeeds true  false]
  [check_fails    false true]
  )

(def: (check_sum' tag size variant)
  (-> Tag Nat (Variant Analysis) Bit)
  (let [expected//right? (n.= (dec size) tag)
        expected//lefts (if expected//right?
                          (dec tag)
                          tag)
        actual//right? (get@ #////analysis.right? variant)
        actual//lefts (get@ #////analysis.lefts variant)]
    (and (n.= expected//lefts
              actual//lefts)
         (bit\= expected//right?
                actual//right?))))

(def: (check_sum type tag size analysis)
  (-> Type Tag Nat (Operation Analysis) Bit)
  (|> analysis
      (//type.with_type type)
      (phase.result _primitive.state)
      (case> (^ (#try.Success (////analysis.variant variant)))
             (check_sum' tag size variant)

             _
             false)))

(def: (with_tags module tags type)
  (All [a] (-> Text (List //module.Tag) Type (Operation a) (Operation [Module a])))
  (|>> (do phase.monad
         [_ (//module.declare_tags tags false type)])
       (//module.with_module 0 module)))

(def: (check_variant module tags expectedT variantT tag analysis)
  (-> Text (List //module.Tag) Type Type Tag (Operation Analysis) Bit)
  (|> analysis
      (with_tags module tags variantT)
      (//type.with_type expectedT)
      (phase.result _primitive.state)
      (case> (^ (#try.Success [_ (////analysis.variant variant)]))
             (check_sum' tag (list.size tags) variant)

             _
             false)))

(def: (correct_size? size)
  (-> Nat (-> Analysis Bit))
  (|>> (case> (^ (////analysis.tuple elems))
              (|> elems
                  list.size
                  (n.= size))
              
              _
              false)))

(def: (check_record module tags expectedT recordT size analysis)
  (-> Text (List //module.Tag) Type Type Nat (Operation Analysis) Bit)
  (|> analysis
      (with_tags module tags recordT)
      (//type.with_type expectedT)
      (phase.result _primitive.state)
      (case> (#try.Success [_ productA])
             (correct_size? size productA)

             _
             false)))

(def: sum
  (do {! r.monad}
    [size (|> r.nat (\ ! map (|>> (n.% 10) (n.max 2))))
     choice (|> r.nat (\ ! map (n.% size)))
     primitives (r.list size _primitive.primitive)
     +choice (|> r.nat (\ ! map (n.% (inc size))))
     [_ +valueC] _primitive.primitive
     .let [variantT (type.variant (list\map product.left primitives))
           [valueT valueC] (maybe.assume (list.item choice primitives))
           +size (inc size)
           +primitives (list.concat (list (list.take choice primitives)
                                          (list [(#.Parameter 1) +valueC])
                                          (list.drop choice primitives)))
           [+valueT +valueC] (maybe.assume (list.item +choice +primitives))
           +variantT (type.variant (list\map product.left +primitives))]]
    (<| (_.context (%.name (name_of /.sum)))
        ($_ _.and
            (_.test "Can analyse."
                    (check_sum variantT choice size
                               (/.sum _primitive.phase choice archive.empty valueC)))
            (_.test "Can analyse through bound type-vars."
                    (|> (do phase.monad
                          [[_ varT] (//type.with_env check.var)
                           _ (//type.with_env
                               (check.check varT variantT))]
                          (//type.with_type varT
                            (/.sum _primitive.phase choice archive.empty valueC)))
                        (phase.result _primitive.state)
                        (case> (^ (#try.Success (////analysis.variant variant)))
                               (check_sum' choice size variant)

                               _
                               false)))
            (_.test "Cannot analyse through unbound type-vars."
                    (|> (do phase.monad
                          [[_ varT] (//type.with_env check.var)]
                          (//type.with_type varT
                            (/.sum _primitive.phase choice archive.empty valueC)))
                        check_fails))
            (_.test "Can analyse through existential quantification."
                    (|> (//type.with_type (type.ex_q 1 +variantT)
                          (/.sum _primitive.phase +choice archive.empty +valueC))
                        check_succeeds))
            (_.test "Can analyse through universal quantification."
                    (let [check_outcome (if (not (n.= choice +choice))
                                          check_succeeds
                                          check_fails)]
                      (|> (//type.with_type (type.univ_q 1 +variantT)
                            (/.sum _primitive.phase +choice archive.empty +valueC))
                          check_outcome)))
            ))))

(def: product
  (do {! r.monad}
    [size (|> r.nat (\ ! map (|>> (n.% 10) (n.max 2))))
     primitives (r.list size _primitive.primitive)
     choice (|> r.nat (\ ! map (n.% size)))
     [_ +valueC] _primitive.primitive
     .let [tupleT (type.tuple (list\map product.left primitives))
           [singletonT singletonC] (|> primitives (list.item choice) maybe.assume)
           +primitives (list.concat (list (list.take choice primitives)
                                          (list [(#.Parameter 1) +valueC])
                                          (list.drop choice primitives)))
           +tupleT (type.tuple (list\map product.left +primitives))]]
    (<| (_.context (%.name (name_of /.product)))
        ($_ _.and
            (_.test "Can analyse."
                    (|> (//type.with_type tupleT
                          (/.product archive.empty _primitive.phase (list\map product.right primitives)))
                        (phase.result _primitive.state)
                        (case> (#try.Success tupleA)
                               (correct_size? size tupleA)

                               _
                               false)))
            (_.test "Can infer."
                    (|> (//type.with_inference
                          (/.product archive.empty _primitive.phase (list\map product.right primitives)))
                        (phase.result _primitive.state)
                        (case> (#try.Success [_type tupleA])
                               (and (check.subsumes? tupleT _type)
                                    (correct_size? size tupleA))

                               _
                               false)))
            (_.test "Can analyse singleton."
                    (|> (//type.with_type singletonT
                          (_primitive.phase archive.empty (` [(~ singletonC)])))
                        check_succeeds))
            (_.test "Can analyse through bound type-vars."
                    (|> (do phase.monad
                          [[_ varT] (//type.with_env check.var)
                           _ (//type.with_env
                               (check.check varT (type.tuple (list\map product.left primitives))))]
                          (//type.with_type varT
                            (/.product archive.empty _primitive.phase (list\map product.right primitives))))
                        (phase.result _primitive.state)
                        (case> (#try.Success tupleA)
                               (correct_size? size tupleA)

                               _
                               false)))
            (_.test "Can analyse through existential quantification."
                    (|> (//type.with_type (type.ex_q 1 +tupleT)
                          (/.product archive.empty _primitive.phase (list\map product.right +primitives)))
                        check_succeeds))
            (_.test "Cannot analyse through universal quantification."
                    (|> (//type.with_type (type.univ_q 1 +tupleT)
                          (/.product archive.empty _primitive.phase (list\map product.right +primitives)))
                        check_fails))
            ))))

(def: variant
  (do {! r.monad}
    [size (|> r.nat (\ ! map (|>> (n.% 10) (n.max 2))))
     tags (|> (r.set text.hash size (r.unicode 5)) (\ ! map set.list))
     choice (|> r.nat (\ ! map (n.% size)))
     other_choice (|> r.nat (\ ! map (n.% size)) (r.only (|>> (n.= choice) not)))
     primitives (r.list size _primitive.primitive)
     module_name (r.unicode 5)
     type_name (r.unicode 5)
     .let [with_name (|>> (#.Named [module_name type_name]))
           varT (#.Parameter 1)
           primitivesT (list\map product.left primitives)
           [choiceT choiceC] (maybe.assume (list.item choice primitives))
           [other_choiceT other_choiceC] (maybe.assume (list.item other_choice primitives))
           monoT (type.variant primitivesT)
           polyT (|> (type.variant (list.concat (list (list.take choice primitivesT)
                                                      (list varT)
                                                      (list.drop (inc choice) primitivesT))))
                     (type.univ_q 1))
           choice_tag (maybe.assume (list.item choice tags))
           other_choice_tag (maybe.assume (list.item other_choice tags))]]
    (<| (_.context (%.name (name_of /.tagged_sum)))
        ($_ _.and
            (_.test "Can infer."
                    (|> (/.tagged_sum _primitive.phase [module_name choice_tag] archive.empty choiceC)
                        (check_variant module_name tags
                                       monoT (with_name monoT)
                                       choice)))
            (_.test "Inference retains universal quantification when type-vars are not bound."
                    (|> (/.tagged_sum _primitive.phase [module_name other_choice_tag] archive.empty other_choiceC)
                        (check_variant module_name tags
                                       polyT (with_name polyT)
                                       other_choice)))
            (_.test "Can specialize."
                    (|> (//type.with_type monoT
                          (/.tagged_sum _primitive.phase [module_name other_choice_tag] archive.empty other_choiceC))
                        (check_variant module_name tags
                                       monoT (with_name polyT)
                                       other_choice)))
            (_.test "Specialization when type-vars get bound."
                    (|> (/.tagged_sum _primitive.phase [module_name choice_tag] archive.empty choiceC)
                        (check_variant module_name tags
                                       monoT (with_name polyT)
                                       choice)))
            ))))

(def: record
  (do {! r.monad}
    [size (|> r.nat (\ ! map (|>> (n.% 10) (n.max 2))))
     tags (|> (r.set text.hash size (r.unicode 5)) (\ ! map set.list))
     primitives (r.list size _primitive.primitive)
     module_name (r.unicode 5)
     type_name (r.unicode 5)
     choice (|> r.nat (\ ! map (n.% size)))
     .let [varT (#.Parameter 1)
           tagsC (list\map (|>> [module_name] code.tag) tags)
           primitivesT (list\map product.left primitives)
           primitivesC (list\map product.right primitives)
           monoT (#.Named [module_name type_name] (type.tuple primitivesT))
           recordC (list.zipped/2 tagsC primitivesC)
           polyT (|> (type.tuple (list.concat (list (list.take choice primitivesT)
                                                    (list varT)
                                                    (list.drop (inc choice) primitivesT))))
                     (type.univ_q 1)
                     (#.Named [module_name type_name]))]]
    (<| (_.context (%.name (name_of /.record)))
        (_.test "Can infer."
                (|> (/.record archive.empty _primitive.phase recordC)
                    (check_record module_name tags monoT monoT size))))))

(def: .public test
  Test
  (<| (_.context (name.module (name_of /._)))
      ($_ _.and
          ..sum
          ..product
          ..variant
          ..record
          )))
