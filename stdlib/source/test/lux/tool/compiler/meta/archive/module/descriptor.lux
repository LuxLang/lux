(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]
    [\\specification
     ["$[0]" equivalence]]]
   [control
    ["[0]" try ("[1]#[0]" functor)]
    [parser
     ["<[0]>" binary]]]
   [data
    ["[0]" text ("[1]#[0]" equivalence)]
    [format
     ["[0]" binary]]]
   [math
    ["[0]" random {"+" Random} ("[1]#[0]" monad)]]]]
 [\\library
  ["[0]" /]])

(def: random_module_state
  (Random Module_State)
  ($_ random.or
      (random#in [])
      (random#in [])
      (random#in [])
      ))

(def: .public (random imports)
  (-> Nat (Random /.Descriptor))
  ($_ random.and
      (random.ascii/lower 1)
      (random.ascii/lower 1)
      random.nat
      ..random_module_state
      (random.set text.hash imports (random.ascii/lower 2))
      ))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Descriptor])
      (do random.monad
        [expected (..random 5)])
      ($_ _.and
          (_.for [/.equivalence]
                 ($equivalence.spec /.equivalence (..random 1)))

          (_.for [/.Module]
                 (_.cover [/.runtime]
                          (text#= "" /.runtime)))
          (_.cover [/.writer /.parser]
                   (|> expected
                       (binary.result /.writer)
                       (<binary>.result /.parser)
                       (try#each (|>> (# /.equivalence = (has /.#state {.#Cached} expected))))
                       (try.else false)))
          )))
