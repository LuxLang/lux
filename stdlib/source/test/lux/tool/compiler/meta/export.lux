(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]]
   [control
    [pipe {"+" case>}]
    ["[0]" try ("[1]#[0]" functor)]
    [concurrency
     ["[0]" async]]
    [parser
     ["<[0]>" binary]]]
   [data
    ["[0]" product]
    ["[0]" binary {"+" Binary} ("[1]#[0]" equivalence)]
    ["[0]" bit ("[1]#[0]" equivalence)]
    [format
     ["[0]" tar]]
    ["[0]" text ("[1]#[0]" equivalence)
     ["%" format {"+" format}]
     [encoding
      ["[0]" utf8]]]
    [collection
     ["[0]" sequence]]]
   [math
    ["[0]" random {"+" Random}]
    [number
     ["n" nat]]]
   [world
    ["[0]" file]]]]
 [\\library
  ["[0]" /
   [//
    ["[0]" io "_"
     ["[1]" context]]]]])

(def: .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [.let [/ .module_separator]
         source/0 (random.ascii/lower 1)
         source/1 (random.ascii/lower 2)
         target (random.ascii/lower 3)

         .let [random_file (: (Random file.Path)
                              (# ! each (text.suffix io.lux_extension) (random.ascii/lower 4)))]
         file/0' random_file
         .let [file/0 (format source/0 / file/0')]
         
         dir/0 (random.ascii/lower 5)
         file/1' (# ! each (|>> (format dir/0 /)) random_file)
         .let [file/1 (format source/1 / file/1')]
         
         .let [random_content (: (Random Binary)
                                 (# ! each (|>> %.nat (# utf8.codec encoded)) random.nat))]
         content/0 random_content
         content/1 random_content]
        ($_ _.and
            (in (do [! async.monad]
                  [it (do (try.with !)
                        [.let [fs (file.mock /)]
                         _ (# fs make_directory source/0)
                         _ (# fs write content/0 file/0)
                         
                         _ (# fs make_directory source/1)
                         _ (# fs make_directory (format source/1 / dir/0))
                         _ (# fs write content/1 file/1)

                         _ (# fs make_directory target)
                         library_tar (/.library fs (list source/0 source/1))
                         _ (/.export fs [(list source/0 source/1) target])
                         export_tar (# fs read (format target / /.file))
                         export_tar (# ! in (<binary>.result tar.parser export_tar))]
                        (in [library_tar export_tar]))]
                  ($_ _.and'
                      (_.cover' [/.library]
                                (|> it
                                    (try#each (|>> product.left
                                                   sequence.list
                                                   (case> (^ (list {tar.#Normal [actual_path/0 _ _ _ actual_content/0]}
                                                                   {tar.#Normal [actual_path/1 _ _ _ actual_content/1]}))
                                                          (with_expansions [<test> (and (and (text#= file/0' (tar.from_path actual_path/0))
                                                                                             (binary#= content/0 (tar.data actual_content/0)))
                                                                                        (and (text#= file/1' (tar.from_path actual_path/1))
                                                                                             (binary#= content/1 (tar.data actual_content/1))))]
                                                            (or <test>
                                                                (let [[[actual_path/0 actual_content/0] [actual_path/1 actual_content/1]]
                                                                      [[actual_path/1 actual_content/1] [actual_path/0 actual_content/0]]]
                                                                  <test>)))
                                                          
                                                          _
                                                          false)))
                                    (try.else false)))
                      (_.cover' [/.export /.file]
                                (|> it
                                    (try#each (|>> product.right
                                                   sequence.list
                                                   (case> (^ (list {tar.#Normal [actual_path/0 _ _ _ actual_content/0]}
                                                                   {tar.#Normal [actual_path/1 _ _ _ actual_content/1]}))
                                                          (with_expansions [<test> (and (and (text#= file/0' (tar.from_path actual_path/0))
                                                                                             (binary#= content/0 (tar.data actual_content/0)))
                                                                                        (and (text#= file/1' (tar.from_path actual_path/1))
                                                                                             (binary#= content/1 (tar.data actual_content/1))))]
                                                            (or <test>
                                                                (let [[[actual_path/0 actual_content/0] [actual_path/1 actual_content/1]]
                                                                      [[actual_path/1 actual_content/1] [actual_path/0 actual_content/0]]]
                                                                  <test>)))
                                                          
                                                          _
                                                          false)))
                                    (try.else false)))
                      )))
            ))))
