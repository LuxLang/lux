(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]]
   [control
    ["[0]" maybe ("[1]#[0]" functor)]
    ["[0]" try ("[1]#[0]" functor)]
    ["[0]" exception]
    [concurrency
     ["[0]" async]]
    [parser
     ["<[0]>" binary]]]
   [data
    ["[0]" product]
    ["[0]" binary {"+" Binary} ("[1]#[0]" equivalence)]
    ["[0]" bit ("[1]#[0]" equivalence)]
    ["[0]" format "_"
     ["[0]" tar {"+" Tar}]
     ["[1]" binary]]
    ["[0]" text ("[1]#[0]" equivalence)
     ["%" format {"+" format}]
     [encoding
      ["[0]" utf8]]]
    [collection
     ["[0]" sequence]
     ["[0]" dictionary]]]
   [math
    ["[0]" random {"+" Random}]
    [number
     ["n" nat]]]
   [world
    ["[0]" file]]]]
 [\\library
  ["[0]" /
   [//
    ["[0]" export]
    ["[0]" io "_"
     ["[1]" context]]]]])

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Import])
      (do [! random.monad]
        [library/0 (random.ascii/lower 1)
         library/1 (random.ascii/lower 2)
         
         .let [/ .module_separator
               random_file (is (Random file.Path)
                               (# ! each (text.suffix io.lux_extension) (random.ascii/lower 3)))]
         file/0 random_file
         
         dir/0 (random.ascii/lower 4)
         file/1 (# ! each (|>> (format dir/0 /)) random_file)
         
         .let [random_content (is (Random Binary)
                                  (# ! each (|>> %.nat (# utf8.codec encoded)) random.nat))]
         now random.instant
         content/0 random_content
         content/1 random_content
         .let [library_content (|> (do try.monad
                                     [file/0 (tar.path file/0)
                                      file/1 (tar.path file/1)
                                      content/0 (tar.content content/0)
                                      content/1 (tar.content content/1)]
                                     (in (|> (sequence.sequence {tar.#Normal [file/0 now export.mode export.ownership content/0]}
                                                                {tar.#Normal [file/1 now export.mode export.ownership content/1]})
                                             (format.result tar.writer))))
                                   (try.else (binary.empty 0)))
               library_content/0 (|> (do try.monad
                                       [file/0 (tar.path file/0)
                                        content/0 (tar.content content/0)]
                                       (in (|> (sequence.sequence {tar.#Normal [file/0 now export.mode export.ownership content/0]})
                                               (format.result tar.writer))))
                                     (try.else (binary.empty 0)))
               library_content/1 (|> (do try.monad
                                       [file/1 (tar.path file/1)
                                        content/1 (tar.content content/1)]
                                       (in (|> (sequence.sequence {tar.#Normal [file/1 now export.mode export.ownership content/1]})
                                               (format.result tar.writer))))
                                     (try.else (binary.empty 0)))
               library_content/-0 (|> (do try.monad
                                        [file/0 (tar.path file/0)
                                         content/0 (tar.content content/0)]
                                        (in (|> (sequence.sequence {tar.#Contiguous [file/0 now export.mode export.ownership content/0]})
                                                (format.result tar.writer))))
                                      (try.else (binary.empty 0)))
               library_content/-1 (|> (do try.monad
                                        [file/0 (tar.path file/0)]
                                        (in (|> (sequence.sequence {tar.#Symbolic_Link file/0})
                                                (format.result tar.writer))))
                                      (try.else (binary.empty 0)))
               library_content/-2 (|> (do try.monad
                                        [file/0 (tar.path file/0)]
                                        (in (|> (sequence.sequence {tar.#Directory file/0})
                                                (format.result tar.writer))))
                                      (try.else (binary.empty 0)))
               imported? (is (-> /.Import Bit)
                             (function (_ it)
                               (and (n.= 2 (dictionary.size it))
                                    (|> it
                                        (dictionary.value file/0)
                                        (maybe#each (binary#= content/0))
                                        (maybe.else false))
                                    (|> it
                                        (dictionary.value file/1)
                                        (maybe#each (binary#= content/1))
                                        (maybe.else false)))))]]
        ($_ _.and
            (in (do [! async.monad]
                  [it/0 (do (try.with !)
                          [.let [fs (file.mock /)]
                           _ (# fs write library_content library/0)]
                          (/.import fs (list library/0)))
                   it/1 (do (try.with !)
                          [.let [fs (file.mock /)]
                           _ (# fs write library_content/0 library/0)
                           _ (# fs write library_content/1 library/1)]
                          (/.import fs (list library/0 library/1)))]
                  (_.cover' [/.import]
                            (and (|> it/0
                                     (try#each imported?)
                                     (try.else false))
                                 (|> it/1
                                     (try#each imported?)
                                     (try.else false))))))
            (in (do [! async.monad]
                  [it (do (try.with !)
                        [.let [fs (file.mock /)]
                         _ (# fs write library_content library/0)
                         _ (/.import fs (list library/0 library/0))]
                        (in false))]
                  (_.cover' [/.duplicate]
                            (exception.otherwise (exception.match? /.duplicate) it))))
            (in (do [! async.monad]
                  [it/0 (do (try.with !)
                          [.let [fs (file.mock /)]
                           _ (# fs write library_content/-0 library/0)
                           _ (/.import fs (list library/0))]
                          (in false))
                   it/1 (do (try.with !)
                          [.let [fs (file.mock /)]
                           _ (# fs write library_content/-1 library/0)
                           _ (/.import fs (list library/0))]
                          (in false))
                   it/2 (do (try.with !)
                          [.let [fs (file.mock /)]
                           _ (# fs write library_content/-2 library/0)
                           _ (/.import fs (list library/0))]
                          (in false))]
                  (_.cover' [/.useless_tar_entry]
                            (and (exception.otherwise (exception.match? /.useless_tar_entry) it/0)
                                 (exception.otherwise (exception.match? /.useless_tar_entry) it/1)
                                 (exception.otherwise (exception.match? /.useless_tar_entry) it/2)))))
            ))))
