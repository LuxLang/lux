(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    ["@" target]
    [abstract
     [monad {"+" [do]}]]
    [control
     ["[0]" try ("[1]\[0]" functor)]
     ["[0]" exception]
     [parser
      ["<[0]>" code]]]
    [data
     ["[0]" text ("[1]\[0]" equivalence)
      ["%" format {"+" [format]}]]
     [collection
      ["[0]" list ("[1]\[0]" functor)]]
     [format
      [json {"+" [JSON]}]
      [xml {"+" [XML]}]]]
    ["[0]" macro
     [syntax {"+" [syntax:]}]
     ["[0]" code]]
    [math
     ["[0]" random {"+" [Random]}]
     [number
      [ratio {"+" [Ratio]}]]]
    [time {"+" [Time]}
     [instant {"+" [Instant]}]
     [date {"+" [Date]}]
     [duration {"+" [Duration]}]
     [month {"+" [Month]}]
     [day {"+" [Day]}]]]]
  [\\library
   ["[0]" /]]
  ["$[0]" // "_"
   ["[1][0]" type]
   [data
    ["[1][0]" name]
    [format
     ["[1][0]" json]
     ["[1][0]" xml]]]
   [macro
    ["[1][0]" code]]
   [math
    [number
     ["[1][0]" ratio]]]
   [meta
    ["[1][0]" location]]])

(def: can_represent_simple_types
  (Random Bit)
  (do random.monad
    [sample_bit random.bit
     sample_int random.int
     sample_frac random.frac
     sample_text (random.ascii/upper 10)
     sample_nat random.nat
     sample_rev random.rev]
    (in (`` (and (~~ (template [<type> <format> <sample>]
                       [(|> (/.representation <type> <sample>)
                            (try\each (text\= (<format> <sample>)))
                            (try.else false))]

                       [Bit %.bit sample_bit]
                       [Nat %.nat sample_nat]
                       [Int %.int sample_int]
                       [Rev %.rev sample_rev]
                       [Frac %.frac sample_frac]
                       [Text %.text sample_text]))
                 )))))

(def: can_represent_structure_types
  (Random Bit)
  (do random.monad
    [sample_bit random.bit
     sample_int random.int
     sample_frac random.frac]
    (in (`` (and (case (/.representation (type [Bit Int Frac])
                                         [sample_bit sample_int sample_frac])
                   (#try.Success actual)
                   (text\= (format "[" (%.bit sample_bit)
                                   " " (%.int sample_int)
                                   " " (%.frac sample_frac)
                                   "]")
                           actual)

                   (#try.Failure error)
                   false)
                 ... TODO: Uncomment after switching from the old (tag+last?) to the new (lefts+right?) representation for variants 
                 ... (~~ (template [<lefts> <right?> <value> <format>]
                 ...       [(|> (/.representation (type (Or Bit Int Frac))
                 ...                         (: (Or Bit Int Frac)
                 ...                            (<lefts> <right?> <value>)))
                 ...            (try\each (text\= (format "(" (%.nat <lefts>)
                 ...                                     " " (%.bit <right?>)
                 ...                                     " " (<format> <value>) ")")))
                 ...            (try.else false))]

                 ...       [0 #0 sample_bit %.bit]
                 ...       [1 #0 sample_int %.int]
                 ...       [1 #1 sample_frac %.frac]
                 ...       ))
                 )))))

(def: can_represent_complex_types
  (Random Bit)
  (do random.monad
    [sample_ratio $//ratio.random
     sample_name ($//name.random 5 5)
     sample_location $//location.random
     sample_type ($//type.random 0)
     sample_code $//code.random
     sample_xml $//xml.random
     sample_json $//json.random]
    (in (`` (and (~~ (template [<type> <format> <sample>]
                       [(|> (/.representation <type> <sample>)
                            (try\each (text\= (<format> <sample>)))
                            (try.else false))]

                       [Ratio %.ratio sample_ratio]
                       [Name %.name sample_name]
                       [Location %.location sample_location]
                       [Code %.code sample_code]
                       [Type %.type sample_type]
                       [XML %.xml sample_xml]
                       [JSON %.json sample_json]))
                 )))))

(def: can_represent_time_types
  (Random Bit)
  (do random.monad
    [sample_instant random.instant
     sample_duration random.duration
     sample_date random.date
     sample_month random.month
     sample_time random.time
     sample_day random.day]
    (in (`` (and (~~ (template [<type> <format> <sample>]
                       [(|> (/.representation <type> <sample>)
                            (try\each (text\= (<format> <sample>)))
                            (try.else false))]

                       [Instant %.instant sample_instant]
                       [Duration %.duration sample_duration]
                       [Date %.date sample_date]
                       [Month %.month sample_month]
                       [Time %.time sample_time]
                       [Day %.day sample_day]))
                 )))))

(def: representation
  Test
  (do random.monad
    [sample_bit random.bit
     sample_nat random.nat
     sample_int random.int
     sample_frac random.frac

     can_represent_simple_types! ..can_represent_simple_types
     can_represent_structure_types! ..can_represent_structure_types
     can_represent_complex_types! ..can_represent_complex_types
     can_represent_time_types! ..can_represent_time_types]
    ($_ _.and
        (_.cover [/.representation]
                 (`` (and can_represent_simple_types!
                          can_represent_structure_types!
                          can_represent_complex_types!
                          can_represent_time_types!
                          
                          (|> (/.representation .Any sample_frac)
                              (try\each (text\= "[]"))
                              (try.else false))
                          (|> (/.representation (type (List Nat)) (: (List Nat) (list sample_nat)))
                              (try\each (text\= (%.list %.nat (list sample_nat))))
                              (try.else false))
                          (~~ (template [<sample>]
                                [(|> (/.representation (type (Maybe Nat)) (: (Maybe Nat) <sample>))
                                     (try\each (text\= (%.maybe %.nat <sample>)))
                                     (try.else false))]
                                
                                [(#.Some sample_nat)]
                                [#.None]
                                ))
                          )))
        (_.cover [/.cannot_represent_value]
                 (case (/.representation (-> Nat Nat) (|>>))
                   (#try.Success representation)
                   false

                   (#try.Failure error)
                   (exception.match? /.cannot_represent_value error)))
        )))

(def: inspection
  Test
  (do random.monad
    [sample_bit random.bit
     sample_int random.int
     sample_frac random.frac
     sample_text (random.ascii/upper 10)]
    (_.cover [/.inspection]
             (`` (and (~~ (template [<format> <sample>]
                            [(text\= (<format> <sample>) (/.inspection <sample>))]

                            [%.bit sample_bit]
                            [%.int sample_int]
                            [%.frac sample_frac]
                            [%.text sample_text]
                            ))
                      (text\= (|> (list sample_bit sample_int sample_frac sample_text)
                                  (: (List Any))
                                  (list\each /.inspection)
                                  (text.interposed " ")
                                  (text.enclosed ["[" "]"]))
                              (/.inspection [sample_bit sample_int sample_frac sample_text]))
                      )))))

(syntax: (macro_error [macro <code>.any])
  (function (_ compiler)
    (case ((macro.expansion macro) compiler)
      (#try.Failure error)
      (#try.Success [compiler (list (code.text error))])
      
      (#try.Success _)
      (#try.Failure "OOPS!"))))

(type: My_Text
  Text)

(def: .public test
  Test
  (<| (_.covering /._)
      (do random.monad
        [message (random.ascii/lower 5)]
        ($_ _.and
            ..inspection
            ..representation
            (_.cover [/.:hole /.type_hole]
                     (let [error (: My_Text (..macro_error (/.:hole)))]
                       (and (exception.match? /.type_hole error)
                            (text.contains? (%.type My_Text) error))))
            (do random.monad
              [foo (random.ascii/upper 10)
               bar random.nat
               baz random.bit]
              (_.cover [/.here]
                       (with_expansions [<no_parameters> (for [@.js (~~ (as_is))]
                                                              (~~ (as_is (/.here))))]
                         (`` (exec
                               <no_parameters>
                               (/.here foo
                                       [bar %.nat])
                               true)))))
            (_.cover [/.unknown_local_binding]
                     (exception.match? /.unknown_local_binding
                                       (..macro_error (/.here yolo))))
            (_.cover [/.private]
                     (exec
                       (: (/.private /.Inspector)
                          /.inspection)
                       true))
            (_.cover [/.log!]
                     (exec
                       (/.log! (format (%.name (name_of /.log!))
                                       " works: " (%.text message)))
                       true))
            ))))
