... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except character)
   [abstract
    ["<>" projection]
    ["[0]" monad]
    ["[0]" equivalence (.only Equivalence)
     ["[1]T" \\test]]
    ["[0]" hash
     ["[1]T" \\test]]
    ["[0]" order
     ["[1]T" \\test]]
    ["[0]" monoid
     ["[1]T" \\test]]
    [functor
     ["[0]" contravariant
      ["[1]T" \\test]]]]
   [control
    ["[0]" pipe]
    ["[0]" maybe]]
   [error
    ["[0]" try (.only Try)]
    ["[0]" exception (.only Exception)]]
   ["[0]" function]
   [data
    [collection
     ["[0]" set]
     ["[0]" list (.use "[1]#[0]" functor)
      ["?[1]" \\projection]]
     [tree
      ["[0]" finger]]]
    [text
     ["[0]" unicode
      ["[1]" set]
      ["[1]/[0]" block]]]]
   [logic
    ["[0]" bit]]
   [math
    ["[0]" random (.only Random) (.use "[1]#[0]" monad)]
    ["[0]" modulus]
    [number
     [/64
      ["[0]" natural]
      ["[0]" integer]
      ["[0]" revolution]
      ["[0]" decimal]]]
    [arithmetic
     ["[0]" modular]]]
   [macro
    ["^" pattern]
    ["[0]" template]]
   [meta
    ["[0]" name]
    ["[0]" static]
    ["[0]" code (.only)
     ["<[1]>" \\projection]]]
   [test
    ["_" property (.only Test)]]]]
 ["$[0]" //
  [//
   ["[1][0]" type]
   [meta
    ["[1][0]" code]]]]
 ["[0]" /
  ["[1][0]" character (.only)
   [\\library (.only Character)]]
  ["[1][0]" buffer]
  ["[1][0]" encoding]
  ["[1][0]" regex]
  ["[1][0]" escape]
  ["[1][0]" unicode
   ["[1]" set]]
  ["[1][0]" slice]]
 [\\library
  ["[0]" /]]
 ["[0]" \\projection]
 ["[0]" \\injection])

(the (equivalence example)
  (for_any (_ it)
    (-> it
        (Equivalence (/.Injection it))))
  (implementation
   (the (= expected actual)
     (/.= (expected example) (actual example)))))

(the random_contravariant
  (Random (for_some (_ it)
            [(/.Injection it)
             (Random it)]))
  (all random.either
       (random#pure [bit.as_text random.bit])
       (random#pure [\\injection.natural random.natural])
       (random#pure [\\injection.integer random.integer])
       (random#pure [\\injection.revolution random.revolution])
       (random#pure [\\injection.decimal random.decimal])
       ))

(the format
  Test
  (`` (all _.and
           (,, (template.with [<injection> <format> <random>]
                 [(monad.let random.monad
                    [sample <random>]
                    (_.coverage [<injection>]
                      (/.= (by <format> as sample)
                           (<injection> sample))))]

                 [[\\injection.natural natural.base_10 random.natural]
                  [\\injection.integer integer.base_10 random.integer]
                  [\\injection.revolution revolution.base_10 random.revolution]
                  [\\injection.decimal decimal.base_10 random.decimal]
                  
                  [\\injection.integer_02 integer.base_02 random.integer]
                  [\\injection.integer_08 integer.base_08 random.integer]
                  [\\injection.integer_10 integer.base_10 random.integer]
                  [\\injection.integer_16 integer.base_16 random.integer]
                  
                  [\\injection.revolution_02 revolution.base_02 random.revolution]
                  [\\injection.revolution_08 revolution.base_08 random.revolution]
                  [\\injection.revolution_10 revolution.base_10 random.revolution]
                  [\\injection.revolution_16 revolution.base_16 random.revolution]
                  
                  [\\injection.decimal_02 decimal.base_02 random.decimal]
                  [\\injection.decimal_08 decimal.base_08 random.decimal]
                  [\\injection.decimal_10 decimal.base_10 random.decimal]
                  [\\injection.decimal_16 decimal.base_16 random.decimal]]))
           (,, (template.with [<injection> <format> <random>]
                 [(monad.let [! random.monad]
                    [sample <random>
                     .let [limit (|> (by natural.interval maximum)
                                     <injection>
                                     /.size
                                     ++)]
                     expected_size (by ! each (natural.% limit) random.natural)]
                    (_.coverage [<injection> \\injection.padded]
                      (/.= (by (natural.padded expected_size <format>) as sample)
                           (\\injection.padded expected_size <injection> sample))))]

                 [[\\injection.natural_02 natural.base_02 random.natural]
                  [\\injection.natural_08 natural.base_08 random.natural]
                  [\\injection.natural_10 natural.base_10 random.natural]
                  [\\injection.natural_16 natural.base_16 random.natural]]))
           (,, (template.with [<injection> <type>]
                 [(monad.let [! random.monad]
                    [it (by ! each (|>> <type>
                                        decimal.integer
                                        integer.decimal
                                        (decimal./ (<type> +1.0)))
                            random.unit_decimal)]
                    (_.coverage [<injection>]
                      (/.contains? (\\injection.integer (decimal.integer (<type> it)))
                                   (<injection> it))))]

                 [[\\injection.degree decimal.as_degree]
                  [\\injection.per_cent decimal.as_per_cent]
                  [\\injection.per_mille decimal.as_per_mille]
                  [\\injection.per_myriad decimal.as_per_myriad]]))
           )))

(the \\injection
  Test
  (<| (_.covering \\injection._)
      (_.for [/.Injection])
      (`` (all _.and
               (_.for [/.functor]
                      (monad.let random.monad
                        [[injection random] ..random_contravariant
                         example random]
                        (contravariantT.spec (..equivalence example)
                                             injection
                                             /.functor)))
               
               (monad.let random.monad
                 [left (random.unicode 5)
                  mid (random.unicode 5)
                  right (random.unicode 5)]
                 (_.coverage [.text]
                   (/.= (.text left mid right)
                        (.text_composite# left mid right))))
               ..format
               (,, (template.with [<injection> <alias> <random>]
                     [(monad.let random.monad
                        [sample <random>]
                        (_.coverage [<injection>]
                          (/.= (<alias> sample)
                               (<injection> sample))))]

                     [[\\injection.text /.as_text (random.unicode 5)]]))
               (monad.let random.monad
                 [sample (random.maybe random.natural)]
                 (_.coverage [\\injection.maybe]
                   (when sample
                     {.#None}
                     true
                     
                     {.#Some value}
                     (/.contains? (\\injection.natural value)
                                  (\\injection.maybe \\injection.natural sample)))))
               (monad.let [! random.monad]
                 [modulus (random.one (|>> modulus.modulus
                                           try.maybe)
                                      random.integer)
                  sample (by ! each (modular.modular modulus)
                             random.integer)]
                 (_.coverage [\\injection.mod]
                   (/.= (by (modular.text modulus) as sample)
                        (\\injection.mod sample))))
               ))))

(the !expect
  (template.macro (_ <pattern> <value>)
    [(when <value>
       <pattern>
       true
       
       _
       false)]))

(the (should_fail' sample projection exception)
  (for_any (_ a e) (-> Text (\\projection.Projection a) (Exception e) Bit))
  (when (\\projection.value projection sample)
    {try.#Failure error}
    (exception.is? exception error)
    
    _
    false))

(the (should_fail sample projection)
  (for_any (_ a)
    (-> Text (\\projection.Projection a)
        Bit))
  (when (\\projection.value projection sample)
    {try.#Failure _}
    true
    
    _
    false))

(the (should_pass expected projection)
  (-> Text (\\projection.Projection Text) Bit)
  (|> expected
      (\\projection.value projection)
      (by try.functor each (/.= expected))
      (try.else false)))

(the \\projection#character_classes
  Test
  (`` (all _.and
           (monad.let [! random.monad]
             [offset (by ! each (natural.% 50) random.natural)
              range (by ! each (|>> (natural.% 50) (natural.+ 10)) random.natural)
              .let [limit (natural.+ offset range)]
              expected (by ! each (|>> (natural.% range) (natural.+ offset) /.of_character) random.natural)
              out_of_range (when offset
                             0 (by ! each (|>> (natural.% 10) ++ (natural.+ limit) /.of_character) random.natural)
                             _ (by ! each (|>> (natural.% offset) /.of_character) random.natural))]
             (_.coverage [\\projection.range]
               (and (..should_pass expected (\\projection.range offset limit))
                    (..should_fail out_of_range (\\projection.range offset limit)))))
           (monad.let [! random.monad]
             [expected (random.character unicode.upper_case)
              invalid (random.only (|>> (unicode/block.within? unicode/block.upper_case) not)
                                   (random.character unicode.character))]
             (_.coverage [\\projection.upper]
               (and (..should_pass (/.of_character expected) \\projection.upper)
                    (..should_fail (/.of_character invalid) \\projection.upper))))
           (monad.let [! random.monad]
             [expected (random.character unicode.lower_case)
              invalid (random.only (|>> (unicode/block.within? unicode/block.lower_case) not)
                                   (random.character unicode.character))]
             (_.coverage [\\projection.lower]
               (and (..should_pass (/.of_character expected) \\projection.lower)
                    (..should_fail (/.of_character invalid) \\projection.lower))))
           (,, (template.with [,arity ,case ,projection]
                 [(monad.let [! random.monad]
                    [expected (by ! each (natural.% ,arity) random.natural)]
                    (_.coverage [,projection]
                      (..should_pass (by ,case as expected) ,projection)))]

                 [[02 natural.base_02 \\projection.base_02]
                  [08 natural.base_08 \\projection.base_08]
                  [10 natural.base_10 \\projection.base_10]
                  [16 natural.base_16 \\projection.base_16]]))
           (monad.let [! random.monad]
             [expected (random.character unicode.alphabetic)
              invalid (random.only (function (_ character)
                                     (not (or (unicode/block.within? unicode/block.upper_case character)
                                              (unicode/block.within? unicode/block.lower_case character))))
                                   (random.character unicode.character))]
             (_.coverage [\\projection.alpha]
               (and (..should_pass (/.of_character expected) \\projection.alpha)
                    (..should_fail (/.of_character invalid) \\projection.alpha))))
           (monad.let [! random.monad]
             [expected (random.character unicode.alpha_numeric)
              invalid (random.only (function (_ character)
                                     (not (or (unicode/block.within? unicode/block.upper_case character)
                                              (unicode/block.within? unicode/block.lower_case character)
                                              (unicode/block.within? unicode/block.numeric character))))
                                   (random.character unicode.character))]
             (_.coverage [\\projection.alpha_numeric]
               (and (..should_pass (/.of_character expected) \\projection.alpha_numeric)
                    (..should_fail (/.of_character invalid) \\projection.alpha_numeric))))
           (monad.let [! random.monad]
             [expected (all random.either
                            (pure /.tab)
                            (pure /.vertical_tab)
                            (pure /.space)
                            (pure /.new_line)
                            (pure /.carriage_return)
                            (pure /.form_feed))
              invalid (|> (random.unicode 1) (random.only (function (_ character)
                                                            (not (or (/.= /.tab character)
                                                                     (/.= /.vertical_tab character)
                                                                     (/.= /.space character)
                                                                     (/.= /.new_line character)
                                                                     (/.= /.carriage_return character)
                                                                     (/.= /.form_feed character))))))]
             (_.coverage [\\projection.space]
               (and (..should_pass expected \\projection.space)
                    (..should_fail invalid \\projection.space))))
           (monad.let [! random.monad]
             [.let [num_options 3]
              options (|> (random.character unicode.character)
                          (random.set natural.hash num_options)
                          (by ! each (|>> set.as_list
                                          (list#each /.of_character)
                                          /.together)))
              expected (by ! each (function (_ value)
                                    (|> options
                                        (/.character (natural.% num_options value))
                                        maybe.trusted))
                           random.natural)
              invalid (random.only (function (_ character)
                                     (not (/.contains? (/.of_character character) options)))
                                   (random.character unicode.character))]
             (_.coverage [\\projection.one_of \\projection.character_should_be]
               (and (..should_pass (/.of_character expected) (\\projection.one_of options))
                    (..should_fail (/.of_character invalid) (\\projection.one_of options))
                    (..should_fail' (/.of_character invalid) (\\projection.one_of options)
                                    \\projection.character_should_be))))
           (monad.let [! random.monad]
             [.let [num_options 3]
              options (|> (random.character unicode.character)
                          (random.set natural.hash num_options)
                          (by ! each (|>> set.as_list
                                          (list#each /.of_character)
                                          /.together)))
              invalid (by ! each (function (_ value)
                                   (|> options
                                       (/.character (natural.% num_options value))
                                       maybe.trusted))
                          random.natural)
              expected (random.only (function (_ character)
                                      (not (/.contains? (/.of_character character) options)))
                                    (random.character unicode.character))]
             (_.coverage [\\projection.none_of
                          \\projection.character_should_not_be]
               (and (..should_pass (/.of_character expected) (\\projection.none_of options))
                    (..should_fail (/.of_character invalid) (\\projection.none_of options))
                    (..should_fail' (/.of_character invalid) (\\projection.none_of options)
                                    \\projection.character_should_not_be)
                    )))
           )))

(the \\projection#runs
  Test
  (all _.and
       (monad.let [! random.monad]
         [left (by ! each (|>> (natural.% 8) (by natural.base_08 as)) random.natural)
          right (by ! each (|>> (natural.% 8) (by natural.base_08 as)) random.natural)
          .let [expected (.text left right)]
          invalid (|> random.natural
                      (by ! each (natural.% 16))
                      (random.only (natural.>= 8))
                      (by ! each (by natural.base_16 as)))]
         (_.coverage [\\projection.many]
           (and (..should_pass expected (\\projection.many \\projection.base_08))
                (..should_fail invalid (\\projection.many \\projection.base_08)))))
       (monad.let [! random.monad]
         [left (by ! each (|>> (natural.% 8) (by natural.base_08 as)) random.natural)
          right (by ! each (|>> (natural.% 8) (by natural.base_08 as)) random.natural)
          .let [expected (.text left right)]
          invalid (|> random.natural
                      (by ! each (natural.% 16))
                      (random.only (natural.>= 8))
                      (by ! each (by natural.base_16 as)))]
         (_.coverage [\\projection.some]
           (and (..should_pass expected (\\projection.some \\projection.base_08))
                (..should_pass "" (\\projection.some \\projection.base_08))
                (..should_fail invalid (\\projection.some \\projection.base_08)))))
       (monad.let [! random.monad]
         [.let [base_08 (by ! each (|>> (natural.% 8) (by natural.base_08 as)) random.natural)]
          first base_08
          second base_08
          third base_08]
         (_.coverage [\\projection.exactly]
           (and (..should_pass (.text first second) (\\projection.exactly 2 \\projection.base_08))
                (..should_fail (.text first second third) (\\projection.exactly 2 \\projection.base_08))
                (..should_fail (.text first) (\\projection.exactly 2 \\projection.base_08)))))
       (monad.let [! random.monad]
         [.let [base_08 (by ! each (|>> (natural.% 8) (by natural.base_08 as)) random.natural)]
          first base_08
          second base_08
          third base_08]
         (_.coverage [\\projection.at_most]
           (and (..should_pass (.text first second) (\\projection.at_most 2 \\projection.base_08))
                (..should_pass (.text first) (\\projection.at_most 2 \\projection.base_08))
                (..should_fail (.text first second third) (\\projection.at_most 2 \\projection.base_08)))))
       (monad.let [! random.monad]
         [.let [base_08 (by ! each (|>> (natural.% 8) (by natural.base_08 as)) random.natural)]
          first base_08
          second base_08
          third base_08]
         (_.coverage [\\projection.at_least]
           (and (..should_pass (.text first second) (\\projection.at_least 2 \\projection.base_08))
                (..should_pass (.text first second third) (\\projection.at_least 2 \\projection.base_08))
                (..should_fail (.text first) (\\projection.at_least 2 \\projection.base_08)))))
       (monad.let [! random.monad]
         [.let [base_08 (by ! each (|>> (natural.% 8) (by natural.base_08 as)) random.natural)]
          first base_08
          second base_08
          third base_08]
         (_.coverage [\\projection.between]
           (and (..should_pass (.text first second) (\\projection.between 2 1 \\projection.base_08))
                (..should_pass (.text first second third) (\\projection.between 2 1 \\projection.base_08))
                (..should_fail (.text first) (\\projection.between 2 1 \\projection.base_08)))))
       ))

(the \\projection
  Test
  (<| (_.covering \\projection._)
      (_.for [\\projection.Projection])
      (all _.and
           (monad.let [! random.monad]
             [sample (random.unicode 1)]
             (_.coverage [\\projection.value \\projection.end]
               (and (|> (\\projection.value \\projection.end
                                            "")
                        (!expect {try.#Success _}))
                    (|> (\\projection.value \\projection.end
                                            sample)
                        (!expect {try.#Failure _})))))
           (monad.let [! random.monad]
             [.let [size 10]
              expected (random.unicode size)
              dummy (|> (random.unicode size)
                        (random.only (|>> (/.= expected) not)))]
             (_.coverage [\\projection.this \\projection.cannot_match]
               (and (|> (\\projection.value (\\projection.this expected)
                                            expected)
                        (!expect {try.#Success []}))
                    (|> (\\projection.value (\\projection.this expected)
                                            dummy)
                        (!expect (^.multi {try.#Failure error}
                                          (exception.is? \\projection.cannot_match error)))))))
           (monad.let [! random.monad]
             [expected (random.unicode 1)]
             (_.coverage [\\projection.any]
               (and (..should_pass expected \\projection.any)
                    (..should_fail "" \\projection.any))))
           (monad.let [! random.monad]
             [expected (random.unicode 1)]
             (_.coverage [\\projection.next \\projection.cannot_parse]
               (and (..should_pass expected (<>.before \\projection.any \\projection.next))
                    (|> ""
                        (\\projection.value (<>.before \\projection.any \\projection.next))
                        (!expect (^.multi {try.#Failure error}
                                          (exception.is? \\projection.cannot_parse error)))))))
           (monad.let [! random.monad]
             [dummy (random.unicode 1)]
             (_.coverage [\\projection.unconsumed_input]
               (|> (.text dummy dummy)
                   (\\projection.value \\projection.any)
                   (!expect (^.multi {try.#Failure error}
                                     (exception.is? \\projection.unconsumed_input error))))))
           (monad.let [! random.monad]
             [sample (random.unicode 1)]
             (_.coverage [\\projection.Offset \\projection.offset]
               (|> sample
                   (\\projection.value (monad.let <>.monad
                                         [pre \\projection.offset
                                          _ \\projection.any
                                          post \\projection.offset]
                                         (pure [pre post])))
                   (!expect {try.#Success [0 1]}))))
           (monad.let [! random.monad]
             [left (random.unicode 1)
              right (random.unicode 1)
              .let [input (.text left right)]]
             (_.coverage [\\projection.remaining]
               (|> input
                   (\\projection.value (monad.let <>.monad
                                         [pre \\projection.remaining
                                          _ \\projection.any
                                          post \\projection.remaining
                                          _ \\projection.any]
                                         (pure (and (/.= input pre)
                                                    (/.= right post)))))
                   (!expect {try.#Success .true}))))
           (monad.let [! random.monad]
             [left (random.unicode 1)
              right (random.unicode 1)
              expected (random.only (|>> (/.= right) not)
                                    (random.unicode 1))]
             (_.coverage [\\projection.enclosed]
               (|> (.text left expected right)
                   (\\projection.value (\\projection.enclosed [left right] (\\projection.this expected)))
                   (!expect {try.#Success _}))))
           (monad.let [! random.monad]
             [input (random.unicode 1)
              output (random.unicode 1)]
             (_.coverage [\\projection.local]
               (|> output
                   (\\projection.value (monad.let <>.monad
                                         [_ (\\projection.local input (\\projection.this input))]
                                         (\\projection.this output)))
                   (!expect {try.#Success _}))))
           (monad.let [! random.monad]
             [expected (by ! each (|>> (natural.% 8) (by natural.base_08 as)) random.natural)]
             (_.coverage [\\projection.then]
               (|> (\\projection.then \\projection.base_08 <code>.text)
                   (?list.value (list (code.text expected)))
                   (!expect (^.multi {try.#Success actual}
                                     (/.= expected actual))))))
           (monad.let [! random.monad]
             [invalid (random.upper_cased 1)
              expected (random.only (|>> (unicode/block.within? unicode/block.upper_case)
                                         not)
                                    (random.character unicode.character))]
             (_.coverage [\\projection.not
                          \\projection.expected_to_fail]
               (and (..should_pass (/.of_character expected) (\\projection.not \\projection.upper))
                    (|> invalid
                        (\\projection.value (\\projection.not \\projection.upper))
                        (!expect (^.multi {try.#Failure error}
                                          (exception.is? \\projection.expected_to_fail error)))))))
           (monad.let [! random.monad]
             [upper (random.upper_cased 1)
              lower (random.lower_cased 1)
              invalid (random.only (function (_ character)
                                     (not (or (unicode/block.within? unicode/block.upper_case character)
                                              (unicode/block.within? unicode/block.lower_case character))))
                                   (random.character unicode.character))]
             (_.coverage [\\projection.and]
               (and (..should_pass (.text upper lower) (\\projection.and \\projection.upper \\projection.lower))
                    (..should_fail (.text (/.of_character invalid) lower) (\\projection.and \\projection.upper \\projection.lower))
                    (..should_fail (.text upper (/.of_character invalid)) (\\projection.and \\projection.upper \\projection.lower)))))
           (monad.let [! random.monad]
             [expected (random.unicode 1)
              invalid (random.unicode 1)]
             (_.coverage [\\projection.satisfies
                          \\projection.character_does_not_satisfy_predicate]
               (and (..should_pass expected (\\projection.satisfies (function.constant true)))
                    (..should_fail' invalid (\\projection.satisfies (function.constant false))
                                    \\projection.character_does_not_satisfy_predicate))))

           \\projection#character_classes
           \\projection#runs
           )))

(the bounded_size
  (random.Random Natural)
  (|> random.natural
      (by random.monad each (|>> (natural.% 20) (natural.+ 1)))))

(the size
  Test
  (monad.let [! random.monad]
    [size (by ! each (natural.% 10) random.natural)
     sample (random.unicode size)]
    (all _.and
         (_.coverage [/.size]
           (natural.= size (/.size sample)))
         (_.coverage [/.empty]
           (natural.= 0 (/.size /.empty)))
         (_.coverage [/.empty?]
           (and (/.empty? /.empty)
                (bit.= (/.= /.empty sample)
                       (/.empty? sample)))))))

(the affix
  Test
  (monad.let [! random.monad]
    [inner (random.unicode 1)
     outer (random.only (|>> (by /.equivalence = inner) not)
                        (random.unicode 1))
     left (random.unicode 1)
     right (random.unicode 1)
     .let [full (by /.monoid composite inner outer)
           fake_index (-- 0)]]
    (`` (all _.and
             (,, (template.with [<affix> <predicate>]
                   [(_.coverage [<affix> <predicate>]
                      (<predicate> outer (<affix> outer inner)))]

                   [[/.prefix /.starts_with?]
                    [/.suffix /.ends_with?]
                    [/.enclosed' /.enclosed_by?]]))
             (_.coverage [/.enclosed /.enclosed?]
               (|> inner
                   (/.enclosed [left right])
                   (/.enclosed? [left right])))
             (_.coverage [/.as_text]
               (let [sample (/.as_text inner)]
                 (and (/.enclosed_by? /.double_quote sample)
                      (/.contains? inner sample))))
             ))))

(the index
  Test
  (monad.let [! random.monad]
    [inner (random.unicode 1)
     outer (random.only (|>> (by /.equivalence = inner) not)
                        (random.unicode 1))
     .let [fake_index (-- 0)]]
    (all _.and
         (_.coverage [/.contains?]
           (let [full (by /.monoid composite inner outer)]
             (and (/.contains? inner full)
                  (/.contains? outer full))))
         (_.coverage [/.index]
           (and (|> (/.index inner (by /.monoid composite inner outer))
                    (maybe.else fake_index)
                    (natural.= 0))
                (|> (/.index outer (by /.monoid composite inner outer))
                    (maybe.else fake_index)
                    (natural.= 1))))
         (_.coverage [/.index_since]
           (let [full (by /.monoid composite inner outer)]
             (and (|> (/.index_since 0 inner full)
                      (maybe.else fake_index)
                      (natural.= 0))
                  (|> (/.index_since 1 inner full)
                      (maybe.else fake_index)
                      (natural.= fake_index))
                  
                  (|> (/.index_since 0 outer full)
                      (maybe.else fake_index)
                      (natural.= 1))
                  (|> (/.index_since 1 outer full)
                      (maybe.else fake_index)
                      (natural.= 1))
                  (|> (/.index_since 2 outer full)
                      (maybe.else fake_index)
                      (natural.= fake_index)))))
         (_.coverage [/.last_index]
           (let [full (all (by /.monoid composite) outer inner outer)]
             (and (|> (/.last_index inner full)
                      (maybe.else fake_index)
                      (natural.= 1))
                  (|> (/.last_index outer full)
                      (maybe.else fake_index)
                      (natural.= 2)))))
         )))

(the character
  Test
  (all _.and
       (_.for [/.of_character]
              (`` (all _.and
                       (,, (template.with [<short> <long>]
                             [(_.coverage [<short> <long>]
                                (by /.equivalence = <short> <long>))]

                             [[/.\0  /.null]
                              [/.\a  /.alarm]
                              [/.\b  /.back_space]
                              [/.\t  /.tab]
                              [/.\n  /.new_line]
                              [/.\v  /.vertical_tab]
                              [/.\f  /.form_feed]
                              [/.\r  /.carriage_return]
                              [/.\'' /.double_quote]]))
                       (_.coverage [/.line_feed]
                         (by /.equivalence = /.new_line /.line_feed))
                       )))
       (monad.let [! random.monad]
         [size (by ! each (|>> (natural.% 10) ++) random.natural)
          characters (random.set /.hash size (random.alphabetic 1))
          .let [sample (|> characters set.as_list /.together)]
          expected (by ! each (natural.% size) random.natural)]
         (_.coverage [/.Index /.character]
           (when (/.character expected sample)
             {.#Some character}
             (when (/.index (/.of_character character) sample)
               {.#Some actual}
               (natural.= expected actual)

               _
               false)
             
             {.#None}
             false)))
       (_.coverage [/.space /.space?]
         (`` (and (,, (template.with [<character>]
                        [(/.space? (`` (.character (,, (static <character>)))))]
                        
                        [[/.tab]
                         [/.vertical_tab]
                         [/.space]
                         [/.new_line]
                         [/.carriage_return]
                         [/.form_feed]])))))
       ))

(the manipulation
  Test
  (monad.let [! random.monad]
    [size (by ! each (|>> (natural.% 10) (natural.+ 2)) random.natural)
     characters (random.set /.hash size (random.alphabetic 1))
     delimiter (random.only (|>> (set.member? characters) not)
                            (random.alphabetic 1))
     .let [with_no_delimiter (|> characters set.as_list /.together)]
     static (random.alphabetic 1)
     .let [dynamic (random.only (|>> (by /.equivalence = static) not)
                                (random.alphabetic 1))]
     pre dynamic
     post dynamic

     lower (random.lower_cased 1)
     upper (random.upper_cased 1)]
    (all _.and
         (_.coverage [/.together]
           (natural.= (set.size characters)
                      (/.size (/.together (set.as_list characters)))))
         (_.coverage [/.interposed /.all_split_by]
           (let [characters (set.as_list characters)]
             (|> characters
                 (/.interposed delimiter)
                 (/.all_split_by delimiter)
                 (by (list.equivalence /.equivalence) = characters))))
         (_.coverage [/.replaced_once]
           (by /.equivalence =
               (by /.monoid composite post static)
               (/.replaced_once pre post (by /.monoid composite pre static))))
         (_.coverage [/.split_by]
           (when (/.split_by static (all (by /.monoid composite) pre static post))
             {.#Some [left right]}
             (and (by /.equivalence = pre left)
                  (by /.equivalence = post right))
             
             {.#None}
             false))
         (_.coverage [/.lower_cased]
           (let [effectiveness!
                 (|> upper
                     /.lower_cased
                     (by /.equivalence = upper)
                     not)

                 idempotence!
                 (|> lower
                     /.lower_cased
                     (by /.equivalence = lower))
                 
                 inverse!
                 (|> lower
                     /.upper_cased
                     /.lower_cased
                     (by /.equivalence = lower))]
             (and effectiveness!
                  idempotence!
                  inverse!)))
         (_.coverage [/.upper_cased]
           (let [effectiveness!
                 (|> lower
                     /.upper_cased
                     (by /.equivalence = lower)
                     not)

                 idempotence!
                 (|> upper
                     /.upper_cased
                     (by /.equivalence = upper))
                 
                 inverse!
                 (|> upper
                     /.lower_cased
                     /.upper_cased
                     (by /.equivalence = upper))]
             (and effectiveness!
                  idempotence!
                  inverse!)))
         )))

(the .public test
  Test
  (<| (_.covering /._)
      (_.for [.Text])
      (all _.and
           (_.for [/.equivalence /.=]
                  (static.when (identical? /.equivalence /.=)
                    (equivalenceT.spec /.equivalence (random.ascii 2))))
           (_.for [/.hash]
                  (hashT.spec /.hash (random.ascii 1)))
           (_.for [/.order
                   /.< /.<= /.> /.>=
                   /.minor /.major]
                  (orderT.spec /.order (random.ascii 2)))
           (_.for [/.monoid]
                  (monoidT.spec /.equivalence /.monoid (random.ascii 2)))

           ..size
           ..affix
           ..index
           ..character
           ..manipulation
           
           (monad.let random.monad
             [sizeL bounded_size
              sizeR bounded_size
              sampleL (random.unicode sizeL)
              sampleR (random.unicode sizeR)
              middle (random.unicode 1)
              .let [sample (/.together (list sampleL sampleR))
                    (open "/#[0]") /.equivalence]]
             (all _.and
                  (_.coverage [/.split_at]
                    (|> (/.split_at sizeL sample)
                        (pipe.when
                          {.#Right [_l _r]}
                          (and (/.= sampleL _l)
                               (/.= sampleR _r)
                               (/.= sample (/.together (list _l _r))))

                          _
                          false)))
                  (_.coverage [/.clip /.clip_since]
                    (|> [(/.clip 0 sizeL sample)
                         (/.clip sizeL (natural.- sizeL (/.size sample)) sample)
                         (/.clip_since sizeL sample)
                         (/.clip_since 0 sample)]
                        (pipe.when
                          [{.#Right _l} {.#Right _r} {.#Right _r'} {.#Right _f}]
                          (and (/.= sampleL _l)
                               (/.= sampleR _r)
                               (/.= _r _r')
                               (/.= sample _f))

                          _
                          false)))
                  ))
           (monad.let [! random.monad]
             [sizeP bounded_size
              sizeL bounded_size
              .let [... The wider unicode charset includes control characters that
                    ... can make text replacement work improperly.
                    ... Because of that, I restrict the charset.
                    normal_character_gen (is (Random Character)
                                             (by ! each (|>> (natural.% 128) (natural.major 1)) random.natural))]
              sep1 (random.text normal_character_gen 1)
              sep2 (random.text normal_character_gen 1)
              .let [part_gen (|> (random.text normal_character_gen sizeP)
                                 (random.only (|>> (/.contains? sep1) not)))]
              parts (random.list sizeL part_gen)
              .let [sample1 (/.interposed sep1 parts)
                    sample2 (/.interposed sep2 parts)
                    (open "/#[0]") /.equivalence]]
             (_.coverage [/.replaced]
               (/.= sample2
                    (/.replaced sep1 sep2 sample1))))

           /character.test
           /buffer.test
           /encoding.test
           /regex.test
           /escape.test
           /unicode.test
           /slice.test

           ..\\projection
           ..\\injection
           )))
