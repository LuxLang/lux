... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except char)
   [abstract
    [monad (.only do)]
    [equivalence (.only Equivalence)]
    ["[0]" hash
     ["[1]T" \\test]]
    [functor
     ["[0]" contravariant
      ["[1]T" \\test]]]
    ["[0]" equivalence
     ["[1]T" \\test]]
    ["[0]" order
     ["[1]T" \\test]]
    ["[0]" monoid
     ["[1]T" \\test]]]
   [control
    ["<>" parser]
    ["[0]" pipe]
    ["[0]" maybe]
    ["[0]" try (.only Try)]
    ["[0]" exception (.only Exception)]
    ["[0]" function]]
   [data
    ["[0]" bit]
    [collection
     ["[0]" set]
     ["[0]" list (.use "[1]#[0]" functor)]
     [tree
      ["[0]" finger]]]
    [format
     ["[0]" xml]
     ["[0]" json]]
    [text
     ["[0]" unicode
      ["[1]" set]
      ["[1]/[0]" block]]]]
   [math
    ["[0]" random (.only Random) (.use "[1]#[0]" monad)]
    ["[0]" modulus]
    [number
     ["[0]" nat]
     ["[0]" int]
     ["[0]" rev]
     ["[0]" frac]
     ["[0]" ratio]]
    [arithmetic
     ["[0]" modular]]]
   [meta
    ["[0]" location]
    ["[0]" symbol]
    ["[0]" type]
    ["[0]" code (.only)
     ["<[1]>" \\parser]]
    [macro
     ["^" pattern]]]
   [world
    ["[0]" time (.only)
     ["[0]" day]
     ["[0]" month]
     ["[0]" instant]
     ["[0]" duration]
     ["[0]" date]]]
   [test
    ["_" property (.only Test)]]]]
 ["$[0]" //
  [format
   ["[1][0]" xml]
   ["[1][0]" json]]
  [//
   [meta
    ["[1][0]" code]
    ["[1][0]" symbol]
    ["[1][0]" type]]]]
 ["[0]" /
  ["[1][0]" char]
  ["[1][0]" buffer]
  ["[1][0]" encoding]
  ["[1][0]" regex]
  ["[1][0]" escape]
  ["[1][0]" unicode
   ["[1]" set]]]
 [\\library
  ["[0]" / (.use "[1]#[0]" equivalence)]]
 ["[0]" \\parser]
 ["[0]" \\format])

(def (equivalence example)
  (All (_ of)
    (-> of
        (Equivalence (\\format.Format of))))
  (implementation
   (def (= reference subject)
     (/#= (reference example) (subject example)))))

(def random_contravariant
  (Random (Ex (_ of)
            [(\\format.Format of)
             (Random of)]))
  (all random.either
       (random#in [\\format.bit random.bit])
       (random#in [\\format.nat random.nat])
       (random#in [\\format.int random.int])
       (random#in [\\format.rev random.rev])
       (random#in [\\format.frac random.frac])
       ))

(def codec
  Test
  (`` (all _.and
           (,, (with_template [<format> <codec> <random>]
                 [(do random.monad
                    [sample <random>]
                    (_.coverage [<format>]
                      (/#= (of <codec> encoded sample)
                           (<format> sample))))]

                 [\\format.bit bit.codec random.bit]
                 [\\format.nat nat.decimal random.nat]
                 [\\format.int int.decimal random.int]
                 [\\format.rev rev.decimal random.rev]
                 [\\format.frac frac.decimal random.frac]
                 [\\format.ratio ratio.codec random.ratio]
                 [\\format.symbol symbol.absolute ($//symbol.random 5 5)]
                 [\\format.xml xml.codec $//xml.random]
                 [\\format.json json.codec $//json.random]
                 [\\format.day day.codec random.day]
                 [\\format.month month.codec random.month]
                 [\\format.instant instant.codec random.instant]
                 [\\format.duration duration.codec random.duration]
                 [\\format.date date.codec random.date]
                 [\\format.time time.codec random.time]
                 
                 [\\format.nat_2 nat.binary random.nat]
                 [\\format.nat_8 nat.octal random.nat]
                 [\\format.nat_10 nat.decimal random.nat]
                 [\\format.nat_16 nat.hex random.nat]
                 
                 [\\format.int_2 int.binary random.int]
                 [\\format.int_8 int.octal random.int]
                 [\\format.int_10 int.decimal random.int]
                 [\\format.int_16 int.hex random.int]
                 
                 [\\format.rev_2 rev.binary random.rev]
                 [\\format.rev_8 rev.octal random.rev]
                 [\\format.rev_10 rev.decimal random.rev]
                 [\\format.rev_16 rev.hex random.rev]
                 
                 [\\format.frac_2 frac.binary random.frac]
                 [\\format.frac_8 frac.octal random.frac]
                 [\\format.frac_10 frac.decimal random.frac]
                 [\\format.frac_16 frac.hex random.frac]
                 ))

           (,, (with_template [<format> <type>]
                 [(do random.monad
                    [it random.safe_frac]
                    (_.coverage [<format>]
                      (/.contains? (\\format.int (frac.int (<type> it)))
                                   (<format> it))))]

                 [\\format.degree frac.degree]
                 [\\format.percentage frac.percentage]
                 [\\format.permille frac.permille]
                 [\\format.permyriad frac.permyriad]
                 ))
           )))

(def \\format
  Test
  (<| (_.covering \\format._)
      (_.for [\\format.Format])
      (`` (all _.and
               (_.for [\\format.functor]
                      (do random.monad
                        [[format random] ..random_contravariant
                         example random]
                        (contravariantT.spec (..equivalence example)
                                             format
                                             \\format.functor)))
               
               (do random.monad
                 [left (random.unicode 5)
                  mid (random.unicode 5)
                  right (random.unicode 5)]
                 (_.coverage [\\format.format]
                   (/#= (\\format.format left mid right)
                        (.text_composite# left mid right))))
               ..codec
               (,, (with_template [<format> <alias> <random>]
                     [(do random.monad
                        [sample <random>]
                        (_.coverage [<format>]
                          (/#= (<alias> sample)
                               (<format> sample))))]

                     [\\format.text /.format (random.unicode 5)]
                     [\\format.code code.format $//code.random]
                     [\\format.type type.absolute_format ($//type.random 0)]
                     [\\format.location location.format
                      (all random.and
                           (random.unicode 5)
                           random.nat
                           random.nat)]
                     ))
               (do random.monad
                 [members (random.list 5 random.nat)]
                 (_.coverage [\\format.list]
                   (/#= (\\format.list \\format.nat members)
                        (|> members
                            (list#each \\format.nat)
                            (/.interposed " ")
                            list
                            (\\format.list (|>>))))))
               (do random.monad
                 [sample (random.maybe random.nat)]
                 (_.coverage [\\format.maybe]
                   (when sample
                     {.#None}
                     true
                     
                     {.#Some value}
                     (/.contains? (\\format.nat value)
                                  (\\format.maybe \\format.nat sample)))))
               (do [! random.monad]
                 [modulus (random.one (|>> modulus.modulus
                                           try.maybe)
                                      random.int)
                  sample (of ! each (modular.modular modulus)
                             random.int)]
                 (_.coverage [\\format.mod]
                   (/#= (of (modular.codec modulus) encoded sample)
                        (\\format.mod sample))))
               ))))

(def !expect
  (template (_ <pattern> <value>)
    [(when <value>
       <pattern>
       true
       
       _
       false)]))

(def (should_fail' sample parser exception)
  (All (_ a e) (-> Text (\\parser.Parser a) (Exception e) Bit))
  (when (\\parser.result parser sample)
    {try.#Failure error}
    (exception.match? exception error)
    
    _
    false))

(def (should_fail sample parser)
  (All (_ a) (-> Text (\\parser.Parser a) Bit))
  (when (\\parser.result parser sample)
    {try.#Failure _}
    true
    
    _
    false))

(def (should_pass expected parser)
  (-> Text (\\parser.Parser Text) Bit)
  (|> expected
      (\\parser.result parser)
      (of try.functor each (/#= expected))
      (try.else false)))

(def (should_pass! expected parser)
  (-> Text (\\parser.Parser \\parser.Slice) Bit)
  (..should_pass expected (\\parser.slice parser)))

(def \\parser#character_classes
  Test
  (all _.and
       (do [! random.monad]
         [offset (of ! each (nat.% 50) random.nat)
          range (of ! each (|>> (nat.% 50) (nat.+ 10)) random.nat)
          .let [limit (nat.+ offset range)]
          expected (of ! each (|>> (nat.% range) (nat.+ offset) /.of_char) random.nat)
          out_of_range (when offset
                         0 (of ! each (|>> (nat.% 10) ++ (nat.+ limit) /.of_char) random.nat)
                         _ (of ! each (|>> (nat.% offset) /.of_char) random.nat))]
         (_.coverage [\\parser.range]
           (and (..should_pass expected (\\parser.range offset limit))
                (..should_fail out_of_range (\\parser.range offset limit)))))
       (do [! random.monad]
         [expected (random.char unicode.upper_case)
          invalid (random.only (|>> (unicode/block.within? unicode/block.upper_case) not)
                               (random.char unicode.character))]
         (_.coverage [\\parser.upper]
           (and (..should_pass (/.of_char expected) \\parser.upper)
                (..should_fail (/.of_char invalid) \\parser.upper))))
       (do [! random.monad]
         [expected (random.char unicode.lower_case)
          invalid (random.only (|>> (unicode/block.within? unicode/block.lower_case) not)
                               (random.char unicode.character))]
         (_.coverage [\\parser.lower]
           (and (..should_pass (/.of_char expected) \\parser.lower)
                (..should_fail (/.of_char invalid) \\parser.lower))))
       (do [! random.monad]
         [expected (of ! each (nat.% 10) random.nat)
          invalid (random.char (unicode.set [unicode/block.number_forms (list)]))]
         (_.coverage [\\parser.decimal]
           (and (..should_pass (of nat.decimal encoded expected) \\parser.decimal)
                (..should_fail (/.of_char invalid) \\parser.decimal))))
       (do [! random.monad]
         [expected (of ! each (nat.% 8) random.nat)
          invalid (random.char (unicode.set [unicode/block.number_forms (list)]))]
         (_.coverage [\\parser.octal]
           (and (..should_pass (of nat.octal encoded expected) \\parser.octal)
                (..should_fail (/.of_char invalid) \\parser.octal))))
       (do [! random.monad]
         [expected (of ! each (nat.% 16) random.nat)
          invalid (random.char (unicode.set [unicode/block.number_forms (list)]))]
         (_.coverage [\\parser.hexadecimal]
           (and (..should_pass (of nat.hex encoded expected) \\parser.hexadecimal)
                (..should_fail (/.of_char invalid) \\parser.hexadecimal))))
       (do [! random.monad]
         [expected (random.char unicode.alphabetic)
          invalid (random.only (function (_ char)
                                 (not (or (unicode/block.within? unicode/block.upper_case char)
                                          (unicode/block.within? unicode/block.lower_case char))))
                               (random.char unicode.character))]
         (_.coverage [\\parser.alpha]
           (and (..should_pass (/.of_char expected) \\parser.alpha)
                (..should_fail (/.of_char invalid) \\parser.alpha))))
       (do [! random.monad]
         [expected (random.char unicode.alpha_numeric)
          invalid (random.only (function (_ char)
                                 (not (or (unicode/block.within? unicode/block.upper_case char)
                                          (unicode/block.within? unicode/block.lower_case char)
                                          (unicode/block.within? unicode/block.numeric char))))
                               (random.char unicode.character))]
         (_.coverage [\\parser.alpha_num]
           (and (..should_pass (/.of_char expected) \\parser.alpha_num)
                (..should_fail (/.of_char invalid) \\parser.alpha_num))))
       (do [! random.monad]
         [expected (all random.either
                        (in /.tab)
                        (in /.vertical_tab)
                        (in /.space)
                        (in /.new_line)
                        (in /.carriage_return)
                        (in /.form_feed))
          invalid (|> (random.unicode 1) (random.only (function (_ char)
                                                        (not (or (/#= /.tab char)
                                                                 (/#= /.vertical_tab char)
                                                                 (/#= /.space char)
                                                                 (/#= /.new_line char)
                                                                 (/#= /.carriage_return char)
                                                                 (/#= /.form_feed char))))))]
         (_.coverage [\\parser.space]
           (and (..should_pass expected \\parser.space)
                (..should_fail invalid \\parser.space))))
       (do [! random.monad]
         [.let [num_options 3]
          options (|> (random.char unicode.character)
                      (random.set nat.hash num_options)
                      (of ! each (|>> set.list
                                      (list#each /.of_char)
                                      /.together)))
          expected (of ! each (function (_ value)
                                (|> options
                                    (/.char (nat.% num_options value))
                                    maybe.trusted))
                       random.nat)
          invalid (random.only (function (_ char)
                                 (not (/.contains? (/.of_char char) options)))
                               (random.char unicode.character))]
         (_.coverage [\\parser.one_of \\parser.one_of! \\parser.character_should_be]
           (and (..should_pass (/.of_char expected) (\\parser.one_of options))
                (..should_fail (/.of_char invalid) (\\parser.one_of options))
                (..should_fail' (/.of_char invalid) (\\parser.one_of options)
                                \\parser.character_should_be)

                (..should_pass! (/.of_char expected) (\\parser.one_of! options))
                (..should_fail (/.of_char invalid) (\\parser.one_of! options))
                (..should_fail' (/.of_char invalid) (\\parser.one_of! options)
                                \\parser.character_should_be)
                )))
       (do [! random.monad]
         [.let [num_options 3]
          options (|> (random.char unicode.character)
                      (random.set nat.hash num_options)
                      (of ! each (|>> set.list
                                      (list#each /.of_char)
                                      /.together)))
          invalid (of ! each (function (_ value)
                               (|> options
                                   (/.char (nat.% num_options value))
                                   maybe.trusted))
                      random.nat)
          expected (random.only (function (_ char)
                                  (not (/.contains? (/.of_char char) options)))
                                (random.char unicode.character))]
         (_.coverage [\\parser.none_of \\parser.none_of! \\parser.character_should_not_be]
           (and (..should_pass (/.of_char expected) (\\parser.none_of options))
                (..should_fail (/.of_char invalid) (\\parser.none_of options))
                (..should_fail' (/.of_char invalid) (\\parser.none_of options)
                                \\parser.character_should_not_be)

                (..should_pass! (/.of_char expected) (\\parser.none_of! options))
                (..should_fail (/.of_char invalid) (\\parser.none_of! options))
                (..should_fail' (/.of_char invalid) (\\parser.none_of! options)
                                \\parser.character_should_not_be)
                )))
       ))

(def \\parser#runs
  Test
  (let [octal! (\\parser.one_of! "01234567")]
    (all _.and
         (do [! random.monad]
           [left (of ! each (|>> (nat.% 8) (of nat.octal encoded)) random.nat)
            right (of ! each (|>> (nat.% 8) (of nat.octal encoded)) random.nat)
            .let [expected (\\format.format left right)]
            invalid (|> random.nat
                        (of ! each (nat.% 16))
                        (random.only (nat.>= 8))
                        (of ! each (of nat.hex encoded)))]
           (_.coverage [\\parser.many \\parser.many!]
             (and (..should_pass expected (\\parser.many \\parser.octal))
                  (..should_fail invalid (\\parser.many \\parser.octal))

                  (..should_pass! expected (\\parser.many! octal!)))))
         (do [! random.monad]
           [left (of ! each (|>> (nat.% 8) (of nat.octal encoded)) random.nat)
            right (of ! each (|>> (nat.% 8) (of nat.octal encoded)) random.nat)
            .let [expected (\\format.format left right)]
            invalid (|> random.nat
                        (of ! each (nat.% 16))
                        (random.only (nat.>= 8))
                        (of ! each (of nat.hex encoded)))]
           (_.coverage [\\parser.some \\parser.some!]
             (and (..should_pass expected (\\parser.some \\parser.octal))
                  (..should_pass "" (\\parser.some \\parser.octal))
                  (..should_fail invalid (\\parser.some \\parser.octal))

                  (..should_pass! expected (\\parser.some! octal!))
                  (..should_pass! "" (\\parser.some! octal!)))))
         (do [! random.monad]
           [.let [octal (of ! each (|>> (nat.% 8) (of nat.octal encoded)) random.nat)]
            first octal
            second octal
            third octal]
           (_.coverage [\\parser.exactly \\parser.exactly!]
             (and (..should_pass (\\format.format first second) (\\parser.exactly 2 \\parser.octal))
                  (..should_fail (\\format.format first second third) (\\parser.exactly 2 \\parser.octal))
                  (..should_fail (\\format.format first) (\\parser.exactly 2 \\parser.octal))

                  (..should_pass! (\\format.format first second) (\\parser.exactly! 2 octal!))
                  (..should_fail (\\format.format first second third) (\\parser.exactly! 2 octal!))
                  (..should_fail (\\format.format first) (\\parser.exactly! 2 octal!)))))
         (do [! random.monad]
           [.let [octal (of ! each (|>> (nat.% 8) (of nat.octal encoded)) random.nat)]
            first octal
            second octal
            third octal]
           (_.coverage [\\parser.at_most \\parser.at_most!]
             (and (..should_pass (\\format.format first second) (\\parser.at_most 2 \\parser.octal))
                  (..should_pass (\\format.format first) (\\parser.at_most 2 \\parser.octal))
                  (..should_fail (\\format.format first second third) (\\parser.at_most 2 \\parser.octal))

                  (..should_pass! (\\format.format first second) (\\parser.at_most! 2 octal!))
                  (..should_pass! (\\format.format first) (\\parser.at_most! 2 octal!))
                  (..should_fail (\\format.format first second third) (\\parser.at_most! 2 octal!)))))
         (do [! random.monad]
           [.let [octal (of ! each (|>> (nat.% 8) (of nat.octal encoded)) random.nat)]
            first octal
            second octal
            third octal]
           (_.coverage [\\parser.at_least \\parser.at_least!]
             (and (..should_pass (\\format.format first second) (\\parser.at_least 2 \\parser.octal))
                  (..should_pass (\\format.format first second third) (\\parser.at_least 2 \\parser.octal))
                  (..should_fail (\\format.format first) (\\parser.at_least 2 \\parser.octal))

                  (..should_pass! (\\format.format first second) (\\parser.at_least! 2 octal!))
                  (..should_pass! (\\format.format first second third) (\\parser.at_least! 2 octal!))
                  (..should_fail (\\format.format first) (\\parser.at_least! 2 octal!)))))
         (do [! random.monad]
           [.let [octal (of ! each (|>> (nat.% 8) (of nat.octal encoded)) random.nat)]
            first octal
            second octal
            third octal]
           (_.coverage [\\parser.between \\parser.between!]
             (and (..should_pass (\\format.format first second) (\\parser.between 2 1 \\parser.octal))
                  (..should_pass (\\format.format first second third) (\\parser.between 2 1 \\parser.octal))
                  (..should_fail (\\format.format first) (\\parser.between 2 1 \\parser.octal))

                  (..should_pass! (\\format.format first second) (\\parser.between! 2 1 octal!))
                  (..should_pass! (\\format.format first second third) (\\parser.between! 2 1 octal!))
                  (..should_fail (\\format.format first) (\\parser.between! 2 1 octal!)))))
         )))

(def \\parser
  Test
  (<| (_.covering \\parser._)
      (_.for [\\parser.Parser])
      (all _.and
           (do [! random.monad]
             [sample (random.unicode 1)]
             (_.coverage [\\parser.result \\parser.end]
               (and (|> (\\parser.result \\parser.end
                                         "")
                        (!expect {try.#Success _}))
                    (|> (\\parser.result \\parser.end
                                         sample)
                        (!expect {try.#Failure _})))))
           (do [! random.monad]
             [.let [size 10]
              expected (random.unicode size)
              dummy (|> (random.unicode size)
                        (random.only (|>> (/#= expected) not)))]
             (_.coverage [\\parser.this \\parser.cannot_match]
               (and (|> (\\parser.result (\\parser.this expected)
                                         expected)
                        (!expect {try.#Success []}))
                    (|> (\\parser.result (\\parser.this expected)
                                         dummy)
                        (!expect (^.multi {try.#Failure error}
                                          (exception.match? \\parser.cannot_match error)))))))
           (_.coverage [\\parser.Slice \\parser.slice \\parser.cannot_slice]
             (|> ""
                 (\\parser.result (\\parser.slice \\parser.any!))
                 (!expect (^.multi {try.#Failure error}
                                   (exception.match? \\parser.cannot_slice error)))))
           (do [! random.monad]
             [expected (random.unicode 1)]
             (_.coverage [\\parser.any \\parser.any!]
               (and (..should_pass expected \\parser.any)
                    (..should_fail "" \\parser.any)

                    (..should_pass! expected \\parser.any!)
                    (..should_fail "" \\parser.any!))))
           (do [! random.monad]
             [expected (random.unicode 1)]
             (_.coverage [\\parser.next \\parser.cannot_parse]
               (and (..should_pass expected (<>.before \\parser.any \\parser.next))
                    (|> ""
                        (\\parser.result (<>.before \\parser.any \\parser.next))
                        (!expect (^.multi {try.#Failure error}
                                          (exception.match? \\parser.cannot_parse error)))))))
           (do [! random.monad]
             [dummy (random.unicode 1)]
             (_.coverage [\\parser.unconsumed_input]
               (|> (\\format.format dummy dummy)
                   (\\parser.result \\parser.any)
                   (!expect (^.multi {try.#Failure error}
                                     (exception.match? \\parser.unconsumed_input error))))))
           (do [! random.monad]
             [sample (random.unicode 1)]
             (_.coverage [\\parser.Offset \\parser.offset]
               (|> sample
                   (\\parser.result (do <>.monad
                                      [pre \\parser.offset
                                       _ \\parser.any
                                       post \\parser.offset]
                                      (in [pre post])))
                   (!expect {try.#Success [0 1]}))))
           (do [! random.monad]
             [left (random.unicode 1)
              right (random.unicode 1)
              .let [input (\\format.format left right)]]
             (_.coverage [\\parser.remaining]
               (|> input
                   (\\parser.result (do <>.monad
                                      [pre \\parser.remaining
                                       _ \\parser.any
                                       post \\parser.remaining
                                       _ \\parser.any]
                                      (in (and (/#= input pre)
                                               (/#= right post)))))
                   (!expect {try.#Success .true}))))
           (do [! random.monad]
             [left (random.unicode 1)
              right (random.unicode 1)
              expected (random.only (|>> (/#= right) not)
                                    (random.unicode 1))]
             (_.coverage [\\parser.enclosed]
               (|> (\\format.format left expected right)
                   (\\parser.result (\\parser.enclosed [left right] (\\parser.this expected)))
                   (!expect {try.#Success _}))))
           (do [! random.monad]
             [input (random.unicode 1)
              output (random.unicode 1)]
             (_.coverage [\\parser.local]
               (|> output
                   (\\parser.result (do <>.monad
                                      [_ (\\parser.local input (\\parser.this input))]
                                      (\\parser.this output)))
                   (!expect {try.#Success _}))))
           (do [! random.monad]
             [expected (of ! each (|>> (nat.% 8) (of nat.octal encoded)) random.nat)]
             (_.coverage [\\parser.then]
               (|> (list (code.text expected))
                   (<code>.result (\\parser.then \\parser.octal <code>.text))
                   (!expect (^.multi {try.#Success actual}
                                     (/#= expected actual))))))
           (do [! random.monad]
             [invalid (random.upper_cased 1)
              expected (random.only (|>> (unicode/block.within? unicode/block.upper_case)
                                         not)
                                    (random.char unicode.character))
              .let [upper! (\\parser.one_of! "ABCDEFGHIJKLMNOPQRSTUVWXYZ")]]
             (_.coverage [\\parser.not \\parser.not! \\parser.expected_to_fail]
               (and (..should_pass (/.of_char expected) (\\parser.not \\parser.upper))
                    (|> invalid
                        (\\parser.result (\\parser.not \\parser.upper))
                        (!expect (^.multi {try.#Failure error}
                                          (exception.match? \\parser.expected_to_fail error))))

                    (..should_pass! (/.of_char expected) (\\parser.not! upper!))
                    (|> invalid
                        (\\parser.result (\\parser.not! upper!))
                        (!expect (^.multi {try.#Failure error}
                                          (exception.match? \\parser.expected_to_fail error)))))))
           (do [! random.monad]
             [upper (random.upper_cased 1)
              lower (random.lower_cased 1)
              invalid (random.only (function (_ char)
                                     (not (or (unicode/block.within? unicode/block.upper_case char)
                                              (unicode/block.within? unicode/block.lower_case char))))
                                   (random.char unicode.character))
              .let [upper! (\\parser.one_of! "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
                    lower! (\\parser.one_of! "abcdefghijklmnopqrstuvwxyz")]]
             (_.coverage [\\parser.and \\parser.and!]
               (and (..should_pass (\\format.format upper lower) (\\parser.and \\parser.upper \\parser.lower))
                    (..should_fail (\\format.format (/.of_char invalid) lower) (\\parser.and \\parser.upper \\parser.lower))
                    (..should_fail (\\format.format upper (/.of_char invalid)) (\\parser.and \\parser.upper \\parser.lower))

                    (..should_pass! (\\format.format upper lower) (\\parser.and! upper! lower!))
                    (..should_fail (\\format.format (/.of_char invalid) lower) (\\parser.and! upper! lower!))
                    (..should_fail (\\format.format upper (/.of_char invalid)) (\\parser.and! upper! lower!)))))
           (do [! random.monad]
             [expected (random.unicode 1)
              invalid (random.unicode 1)]
             (_.coverage [\\parser.satisfies \\parser.character_does_not_satisfy_predicate]
               (and (..should_pass expected (\\parser.satisfies (function.constant true)))
                    (..should_fail' invalid (\\parser.satisfies (function.constant false))
                                    \\parser.character_does_not_satisfy_predicate))))

           \\parser#character_classes
           \\parser#runs
           )))

(def bounded_size
  (random.Random Nat)
  (|> random.nat
      (of random.monad each (|>> (nat.% 20) (nat.+ 1)))))

(def size
  Test
  (do [! random.monad]
    [size (of ! each (nat.% 10) random.nat)
     sample (random.unicode size)]
    (all _.and
         (_.coverage [/.size]
           (nat.= size (/.size sample)))
         (_.coverage [/.empty?]
           (or (/.empty? sample)
               (not (nat.= 0 size)))))))

(def affix
  Test
  (do [! random.monad]
    [inner (random.unicode 1)
     outer (random.only (|>> (of /.equivalence = inner) not)
                        (random.unicode 1))
     left (random.unicode 1)
     right (random.unicode 1)
     .let [full (of /.monoid composite inner outer)
           fake_index (-- 0)]]
    (`` (all _.and
             (,, (with_template [<affix> <predicate>]
                   [(_.coverage [<affix> <predicate>]
                      (<predicate> outer (<affix> outer inner)))]

                   [/.prefix /.starts_with?]
                   [/.suffix /.ends_with?]
                   [/.enclosed' /.enclosed_by?]
                   ))
             (_.coverage [/.enclosed]
               (let [value (/.enclosed [left right] inner)]
                 (and (/.starts_with? left value)
                      (/.ends_with? right value))))
             (_.coverage [/.format]
               (let [sample (/.format inner)]
                 (and (/.enclosed_by? /.double_quote sample)
                      (/.contains? inner sample))))
             ))))

(def index
  Test
  (do [! random.monad]
    [inner (random.unicode 1)
     outer (random.only (|>> (of /.equivalence = inner) not)
                        (random.unicode 1))
     .let [fake_index (-- 0)]]
    (all _.and
         (_.coverage [/.contains?]
           (let [full (of /.monoid composite inner outer)]
             (and (/.contains? inner full)
                  (/.contains? outer full))))
         (_.coverage [/.index]
           (and (|> (/.index inner (of /.monoid composite inner outer))
                    (maybe.else fake_index)
                    (nat.= 0))
                (|> (/.index outer (of /.monoid composite inner outer))
                    (maybe.else fake_index)
                    (nat.= 1))))
         (_.coverage [/.index_since]
           (let [full (of /.monoid composite inner outer)]
             (and (|> (/.index_since 0 inner full)
                      (maybe.else fake_index)
                      (nat.= 0))
                  (|> (/.index_since 1 inner full)
                      (maybe.else fake_index)
                      (nat.= fake_index))
                  
                  (|> (/.index_since 0 outer full)
                      (maybe.else fake_index)
                      (nat.= 1))
                  (|> (/.index_since 1 outer full)
                      (maybe.else fake_index)
                      (nat.= 1))
                  (|> (/.index_since 2 outer full)
                      (maybe.else fake_index)
                      (nat.= fake_index)))))
         (_.coverage [/.last_index]
           (let [full (all (of /.monoid composite) outer inner outer)]
             (and (|> (/.last_index inner full)
                      (maybe.else fake_index)
                      (nat.= 1))
                  (|> (/.last_index outer full)
                      (maybe.else fake_index)
                      (nat.= 2)))))
         )))

(def char
  Test
  (all _.and
       (_.for [/.of_char]
              (`` (all _.and
                       (,, (with_template [<short> <long>]
                             [(_.coverage [<short> <long>]
                                (of /.equivalence = <short> <long>))]

                             [/.\0  /.null]
                             [/.\a  /.alarm]
                             [/.\b  /.back_space]
                             [/.\t  /.tab]
                             [/.\n  /.new_line]
                             [/.\v  /.vertical_tab]
                             [/.\f  /.form_feed]
                             [/.\r  /.carriage_return]
                             [/.\'' /.double_quote]))
                       (_.coverage [/.line_feed]
                         (of /.equivalence = /.new_line /.line_feed))
                       )))
       (do [! random.monad]
         [size (of ! each (|>> (nat.% 10) ++) random.nat)
          characters (random.set /.hash size (random.alphabetic 1))
          .let [sample (|> characters set.list /.together)]
          expected (of ! each (nat.% size) random.nat)]
         (_.coverage [/.char]
           (when (/.char expected sample)
             {.#Some char}
             (when (/.index (/.of_char char) sample)
               {.#Some actual}
               (nat.= expected actual)

               _
               false)
             
             {.#None}
             false)))
       (_.coverage [/.space /.space?]
         (`` (and (,, (with_template [<char>]
                        [(/.space? (`` (.char (,, (static <char>)))))]
                        
                        [/.tab]
                        [/.vertical_tab]
                        [/.space]
                        [/.new_line]
                        [/.carriage_return]
                        [/.form_feed]
                        )))))
       ))

(def manipulation
  Test
  (do [! random.monad]
    [size (of ! each (|>> (nat.% 10) (nat.+ 2)) random.nat)
     characters (random.set /.hash size (random.alphabetic 1))
     separator (random.only (|>> (set.member? characters) not)
                            (random.alphabetic 1))
     .let [with_no_separator (|> characters set.list /.together)]
     static (random.alphabetic 1)
     .let [dynamic (random.only (|>> (of /.equivalence = static) not)
                                (random.alphabetic 1))]
     pre dynamic
     post dynamic

     lower (random.lower_cased 1)
     upper (random.upper_cased 1)]
    (all _.and
         (_.coverage [/.together]
           (nat.= (set.size characters)
                  (/.size (/.together (set.list characters)))))
         (_.coverage [/.interposed /.all_split_by]
           (and (|> (set.list characters)
                    (/.interposed separator)
                    (/.all_split_by separator)
                    (set.of_list /.hash)
                    (of set.equivalence = characters))
                (of /.equivalence =
                    (/.together (set.list characters))
                    (/.interposed "" (set.list characters)))))
         (_.coverage [/.replaced_once]
           (of /.equivalence =
               (of /.monoid composite post static)
               (/.replaced_once pre post (of /.monoid composite pre static))))
         (_.coverage [/.split_by]
           (when (/.split_by static (all (of /.monoid composite) pre static post))
             {.#Some [left right]}
             (and (of /.equivalence = pre left)
                  (of /.equivalence = post right))
             
             {.#None}
             false))
         (_.coverage [/.lower_cased]
           (let [effectiveness!
                 (|> upper
                     /.lower_cased
                     (of /.equivalence = upper)
                     not)

                 idempotence!
                 (|> lower
                     /.lower_cased
                     (of /.equivalence = lower))
                 
                 inverse!
                 (|> lower
                     /.upper_cased
                     /.lower_cased
                     (of /.equivalence = lower))]
             (and effectiveness!
                  idempotence!
                  inverse!)))
         (_.coverage [/.upper_cased]
           (let [effectiveness!
                 (|> lower
                     /.upper_cased
                     (of /.equivalence = lower)
                     not)

                 idempotence!
                 (|> upper
                     /.upper_cased
                     (of /.equivalence = upper))
                 
                 inverse!
                 (|> upper
                     /.lower_cased
                     /.upper_cased
                     (of /.equivalence = upper))]
             (and effectiveness!
                  idempotence!
                  inverse!)))
         )))

(def .public test
  Test
  (<| (_.covering /._)
      (_.for [.Text])
      (all _.and
           (_.for [/.equivalence]
                  (equivalenceT.spec /.equivalence (random.ascii 2)))
           (_.for [/.hash]
                  (hashT.spec /.hash (random.ascii 1)))
           (_.for [/.order]
                  (orderT.spec /.order (random.ascii 2)))
           (_.for [/.monoid]
                  (monoidT.spec /.equivalence /.monoid (random.ascii 2)))

           ..size
           ..affix
           ..index
           ..char
           ..manipulation
           
           (do random.monad
             [sizeL bounded_size
              sizeR bounded_size
              sampleL (random.unicode sizeL)
              sampleR (random.unicode sizeR)
              middle (random.unicode 1)
              .let [sample (/.together (list sampleL sampleR))
                    (open "/#[0]") /.equivalence]]
             (all _.and
                  (_.coverage [/.split_at]
                    (|> (/.split_at sizeL sample)
                        (pipe.when
                          {.#Right [_l _r]}
                          (and (/#= sampleL _l)
                               (/#= sampleR _r)
                               (/#= sample (/.together (list _l _r))))

                          _
                          false)))
                  (_.coverage [/.clip /.clip_since]
                    (|> [(/.clip 0 sizeL sample)
                         (/.clip sizeL (nat.- sizeL (/.size sample)) sample)
                         (/.clip_since sizeL sample)
                         (/.clip_since 0 sample)]
                        (pipe.when
                          [{.#Right _l} {.#Right _r} {.#Right _r'} {.#Right _f}]
                          (and (/#= sampleL _l)
                               (/#= sampleR _r)
                               (/#= _r _r')
                               (/#= sample _f))

                          _
                          false)))
                  ))
           (do [! random.monad]
             [sizeP bounded_size
              sizeL bounded_size
              .let [... The wider unicode charset includes control characters that
                    ... can make text replacement work improperly.
                    ... Because of that, I restrict the charset.
                    normal_char_gen (|> random.nat (of ! each (|>> (nat.% 128) (nat.max 1))))]
              sep1 (random.text normal_char_gen 1)
              sep2 (random.text normal_char_gen 1)
              .let [part_gen (|> (random.text normal_char_gen sizeP)
                                 (random.only (|>> (/.contains? sep1) not)))]
              parts (random.list sizeL part_gen)
              .let [sample1 (/.together (list.interposed sep1 parts))
                    sample2 (/.together (list.interposed sep2 parts))
                    (open "/#[0]") /.equivalence]]
             (_.coverage [/.replaced]
               (/#= sample2
                    (/.replaced sep1 sep2 sample1))))

           /char.test
           /buffer.test
           /encoding.test
           /regex.test
           /escape.test
           /unicode.test

           ..\\parser
           ..\\format
           )))
