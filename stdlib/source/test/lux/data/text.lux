... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except character)
   [abstract
    [monad (.only do)]
    ["[0]" equivalence (.only Equivalence)
     ["[1]T" \\test]]
    ["[0]" hash
     ["[1]T" \\test]]
    ["[0]" order
     ["[1]T" \\test]]
    ["[0]" monoid
     ["[1]T" \\test]]
    [functor
     ["[0]" contravariant
      ["[1]T" \\test]]]]
   [control
    ["<>" projection]
    ["[0]" pipe]
    ["[0]" maybe]
    ["[0]" try (.only Try)]
    ["[0]" exception (.only Exception)]
    ["[0]" function]]
   [data
    ["[0]" bit]
    [collection
     ["[0]" set]
     ["[0]" list (.use "[1]#[0]" functor)]
     [tree
      ["[0]" finger]]]
    [text
     ["[0]" unicode
      ["[1]" set]
      ["[1]/[0]" block]]]]
   [math
    ["[0]" random (.only Random) (.use "[1]#[0]" monad)]
    ["[0]" modulus]
    [number
     ["[0]" natural]
     ["[0]" integer]
     ["[0]" revolution]
     ["[0]" decimal]]
    [arithmetic
     ["[0]" modular]]]
   [meta
    ["[0]" code (.only)
     ["<[1]>" \\projection]]
    [macro
     ["^" pattern]
     ["[0]" template]]]
   [test
    ["_" property (.only Test)]]]]
 ["$[0]" //
  [//
   [meta
    ["[1][0]" code]
    ["[1][0]" symbol]
    ["[1][0]" type]]]]
 ["[0]" /
  ["[1][0]" character (.only)
   [\\library (.only Character)]]
  ["[1][0]" buffer]
  ["[1][0]" encoding]
  ["[1][0]" regex]
  ["[1][0]" escape]
  ["[1][0]" unicode
   ["[1]" set]]]
 [\\library
  ["[0]" /]]
 ["[0]" \\projection]
 ["[0]" \\injection])

(the (equivalence example)
  (for_any (_ of)
    (-> of
        (Equivalence (/.Injection of))))
  (implementation
   (the (= expected actual)
     (/.= (expected example) (actual example)))))

(the random_contravariant
  (Random (for_some (_ of)
            [(/.Injection of)
             (Random of)]))
  (all random.either
       (random#in [bit.as_text random.bit])
       (random#in [\\injection.natural random.natural])
       (random#in [\\injection.integer random.integer])
       (random#in [\\injection.revolution random.revolution])
       (random#in [\\injection.decimal random.decimal])
       ))

(the format
  Test
  (`` (all _.and
           (,, (template.with [<injection> <format> <random>]
                 [(do random.monad
                    [sample <random>]
                    (_.coverage [<injection>]
                      (/.= (of <format> injection sample)
                           (<injection> sample))))]

                 [\\injection.natural natural.base_10 random.natural]
                 [\\injection.integer integer.base_10 random.integer]
                 [\\injection.revolution revolution.base_10 random.revolution]
                 [\\injection.decimal decimal.base_10 random.decimal]
                 
                 [\\injection.integer_02 integer.binary random.integer]
                 [\\injection.integer_08 integer.octal random.integer]
                 [\\injection.integer_10 integer.base_10 random.integer]
                 [\\injection.integer_16 integer.hex random.integer]
                 
                 [\\injection.revolution_02 revolution.binary random.revolution]
                 [\\injection.revolution_08 revolution.octal random.revolution]
                 [\\injection.revolution_10 revolution.base_10 random.revolution]
                 [\\injection.revolution_16 revolution.hex random.revolution]
                 
                 [\\injection.decimal_02 decimal.binary random.decimal]
                 [\\injection.decimal_08 decimal.octal random.decimal]
                 [\\injection.decimal_10 decimal.base_10 random.decimal]
                 [\\injection.decimal_16 decimal.hex random.decimal]
                 ))
           (,, (template.with [<injection> <format> <random>]
                 [(do [! random.monad]
                    [sample <random>
                     .let [limit (|> (of natural.interval top)
                                     <injection>
                                     /.size
                                     ++)]
                     expected_size (of ! each (natural.% limit) random.natural)]
                    (_.coverage [<injection> \\injection.padded]
                      (/.= (of (natural.padded expected_size <format>) injection sample)
                           (\\injection.padded expected_size <injection> sample))))]

                 [\\injection.natural_02 natural.binary random.natural]
                 [\\injection.natural_08 natural.octal random.natural]
                 [\\injection.natural_10 natural.base_10 random.natural]
                 [\\injection.natural_16 natural.hex random.natural]
                 ))
           (,, (template.with [<injection> <type>]
                 [(do [! random.monad]
                    [it (of ! each (|>> <type>
                                        decimal.integer
                                        integer.decimal
                                        (decimal./ (<type> +1.0)))
                            random.safe_decimal)]
                    (_.coverage [<injection>]
                      (/.contains? (\\injection.integer (decimal.integer (<type> it)))
                                   (<injection> it))))]

                 [\\injection.degree decimal.as_degree]
                 [\\injection.percentage decimal.as_percentage]
                 [\\injection.permille decimal.as_permille]
                 [\\injection.permyriad decimal.as_permyriad]
                 ))
           )))

(the \\injection
  Test
  (<| (_.covering \\injection._)
      (_.for [/.Injection])
      (`` (all _.and
               (_.for [/.functor]
                      (do random.monad
                        [[injection random] ..random_contravariant
                         example random]
                        (contravariantT.spec (..equivalence example)
                                             injection
                                             /.functor)))
               
               (do random.monad
                 [left (random.unicode 5)
                  mid (random.unicode 5)
                  right (random.unicode 5)]
                 (_.coverage [\\injection.message]
                   (/.= (\\injection.message left mid right)
                        (.text_composite# left mid right))))
               ..format
               (,, (template.with [<injection> <alias> <random>]
                     [(do random.monad
                        [sample <random>]
                        (_.coverage [<injection>]
                          (/.= (<alias> sample)
                               (<injection> sample))))]

                     [\\injection.text /.injection (random.unicode 5)]
                     ))
               (do random.monad
                 [members (random.list 5 random.natural)]
                 (_.coverage [\\injection.list]
                   (/.= (\\injection.list \\injection.natural members)
                        (|> members
                            (list#each \\injection.natural)
                            (/.interposed " ")
                            list
                            (\\injection.list (|>>))))))
               (do random.monad
                 [sample (random.maybe random.natural)]
                 (_.coverage [\\injection.maybe]
                   (when sample
                     {.#None}
                     true
                     
                     {.#Some value}
                     (/.contains? (\\injection.natural value)
                                  (\\injection.maybe \\injection.natural sample)))))
               (do [! random.monad]
                 [modulus (random.one (|>> modulus.modulus
                                           try.maybe)
                                      random.integer)
                  sample (of ! each (modular.modular modulus)
                             random.integer)]
                 (_.coverage [\\injection.mod]
                   (/.= (of (modular.format modulus) injection sample)
                        (\\injection.mod sample))))
               ))))

(the !expect
  (template.macro (_ <pattern> <value>)
    [(when <value>
       <pattern>
       true
       
       _
       false)]))

(the (should_fail' sample projection exception)
  (for_any (_ a e) (-> Text (\\projection.Projection a) (Exception e) Bit))
  (when (\\projection.value projection sample)
    {try.#Failure error}
    (exception.is? exception error)
    
    _
    false))

(the (should_fail sample projection)
  (for_any (_ a)
    (-> Text (\\projection.Projection a)
        Bit))
  (when (\\projection.value projection sample)
    {try.#Failure _}
    true
    
    _
    false))

(the (should_pass expected projection)
  (-> Text (\\projection.Projection Text) Bit)
  (|> expected
      (\\projection.value projection)
      (of try.functor each (/.= expected))
      (try.else false)))

(the (should_pass! expected projection)
  (-> Text (\\projection.Projection \\projection.Slice) Bit)
  (..should_pass expected (\\projection.slice projection)))

(the \\projection#character_classes
  Test
  (all _.and
       (do [! random.monad]
         [offset (of ! each (natural.% 50) random.natural)
          range (of ! each (|>> (natural.% 50) (natural.+ 10)) random.natural)
          .let [limit (natural.+ offset range)]
          expected (of ! each (|>> (natural.% range) (natural.+ offset) /.of_character) random.natural)
          out_of_range (when offset
                         0 (of ! each (|>> (natural.% 10) ++ (natural.+ limit) /.of_character) random.natural)
                         _ (of ! each (|>> (natural.% offset) /.of_character) random.natural))]
         (_.coverage [\\projection.range]
           (and (..should_pass expected (\\projection.range offset limit))
                (..should_fail out_of_range (\\projection.range offset limit)))))
       (do [! random.monad]
         [expected (random.character unicode.upper_case)
          invalid (random.only (|>> (unicode/block.within? unicode/block.upper_case) not)
                               (random.character unicode.character))]
         (_.coverage [\\projection.upper]
           (and (..should_pass (/.of_character expected) \\projection.upper)
                (..should_fail (/.of_character invalid) \\projection.upper))))
       (do [! random.monad]
         [expected (random.character unicode.lower_case)
          invalid (random.only (|>> (unicode/block.within? unicode/block.lower_case) not)
                               (random.character unicode.character))]
         (_.coverage [\\projection.lower]
           (and (..should_pass (/.of_character expected) \\projection.lower)
                (..should_fail (/.of_character invalid) \\projection.lower))))
       (do [! random.monad]
         [expected (of ! each (natural.% 10) random.natural)
          invalid (random.character (unicode.set [unicode/block.number_forms (list)]))]
         (_.coverage [\\projection.decimal]
           (and (..should_pass (of natural.base_10 injection expected) \\projection.decimal)
                (..should_fail (/.of_character invalid) \\projection.decimal))))
       (do [! random.monad]
         [expected (of ! each (natural.% 8) random.natural)
          invalid (random.character (unicode.set [unicode/block.number_forms (list)]))]
         (_.coverage [\\projection.octal]
           (and (..should_pass (of natural.octal injection expected) \\projection.octal)
                (..should_fail (/.of_character invalid) \\projection.octal))))
       (do [! random.monad]
         [expected (of ! each (natural.% 16) random.natural)
          invalid (random.character (unicode.set [unicode/block.number_forms (list)]))]
         (_.coverage [\\projection.hexadecimal]
           (and (..should_pass (of natural.hex injection expected) \\projection.hexadecimal)
                (..should_fail (/.of_character invalid) \\projection.hexadecimal))))
       (do [! random.monad]
         [expected (random.character unicode.alphabetic)
          invalid (random.only (function (_ character)
                                 (not (or (unicode/block.within? unicode/block.upper_case character)
                                          (unicode/block.within? unicode/block.lower_case character))))
                               (random.character unicode.character))]
         (_.coverage [\\projection.alpha]
           (and (..should_pass (/.of_character expected) \\projection.alpha)
                (..should_fail (/.of_character invalid) \\projection.alpha))))
       (do [! random.monad]
         [expected (random.character unicode.alpha_numeric)
          invalid (random.only (function (_ character)
                                 (not (or (unicode/block.within? unicode/block.upper_case character)
                                          (unicode/block.within? unicode/block.lower_case character)
                                          (unicode/block.within? unicode/block.numeric character))))
                               (random.character unicode.character))]
         (_.coverage [\\projection.alpha_num]
           (and (..should_pass (/.of_character expected) \\projection.alpha_num)
                (..should_fail (/.of_character invalid) \\projection.alpha_num))))
       (do [! random.monad]
         [expected (all random.either
                        (in /.tab)
                        (in /.vertical_tab)
                        (in /.space)
                        (in /.new_line)
                        (in /.carriage_return)
                        (in /.form_feed))
          invalid (|> (random.unicode 1) (random.only (function (_ character)
                                                        (not (or (/.= /.tab character)
                                                                 (/.= /.vertical_tab character)
                                                                 (/.= /.space character)
                                                                 (/.= /.new_line character)
                                                                 (/.= /.carriage_return character)
                                                                 (/.= /.form_feed character))))))]
         (_.coverage [\\projection.space]
           (and (..should_pass expected \\projection.space)
                (..should_fail invalid \\projection.space))))
       (do [! random.monad]
         [.let [num_options 3]
          options (|> (random.character unicode.character)
                      (random.set natural.hash num_options)
                      (of ! each (|>> set.list
                                      (list#each /.of_character)
                                      /.together)))
          expected (of ! each (function (_ value)
                                (|> options
                                    (/.character (natural.% num_options value))
                                    maybe.trusted))
                       random.natural)
          invalid (random.only (function (_ character)
                                 (not (/.contains? (/.of_character character) options)))
                               (random.character unicode.character))]
         (_.coverage [\\projection.one_of \\projection.one_of! \\projection.character_should_be]
           (and (..should_pass (/.of_character expected) (\\projection.one_of options))
                (..should_fail (/.of_character invalid) (\\projection.one_of options))
                (..should_fail' (/.of_character invalid) (\\projection.one_of options)
                                \\projection.character_should_be)

                (..should_pass! (/.of_character expected) (\\projection.one_of! options))
                (..should_fail (/.of_character invalid) (\\projection.one_of! options))
                (..should_fail' (/.of_character invalid) (\\projection.one_of! options)
                                \\projection.character_should_be)
                )))
       (do [! random.monad]
         [.let [num_options 3]
          options (|> (random.character unicode.character)
                      (random.set natural.hash num_options)
                      (of ! each (|>> set.list
                                      (list#each /.of_character)
                                      /.together)))
          invalid (of ! each (function (_ value)
                               (|> options
                                   (/.character (natural.% num_options value))
                                   maybe.trusted))
                      random.natural)
          expected (random.only (function (_ character)
                                  (not (/.contains? (/.of_character character) options)))
                                (random.character unicode.character))]
         (_.coverage [\\projection.none_of \\projection.none_of! \\projection.character_should_not_be]
           (and (..should_pass (/.of_character expected) (\\projection.none_of options))
                (..should_fail (/.of_character invalid) (\\projection.none_of options))
                (..should_fail' (/.of_character invalid) (\\projection.none_of options)
                                \\projection.character_should_not_be)

                (..should_pass! (/.of_character expected) (\\projection.none_of! options))
                (..should_fail (/.of_character invalid) (\\projection.none_of! options))
                (..should_fail' (/.of_character invalid) (\\projection.none_of! options)
                                \\projection.character_should_not_be)
                )))
       ))

(the \\projection#runs
  Test
  (let [octal! (\\projection.one_of! "01234567")]
    (all _.and
         (do [! random.monad]
           [left (of ! each (|>> (natural.% 8) (of natural.octal injection)) random.natural)
            right (of ! each (|>> (natural.% 8) (of natural.octal injection)) random.natural)
            .let [expected (\\injection.message left right)]
            invalid (|> random.natural
                        (of ! each (natural.% 16))
                        (random.only (natural.>= 8))
                        (of ! each (of natural.hex injection)))]
           (_.coverage [\\projection.many \\projection.many!]
             (and (..should_pass expected (\\projection.many \\projection.octal))
                  (..should_fail invalid (\\projection.many \\projection.octal))

                  (..should_pass! expected (\\projection.many! octal!)))))
         (do [! random.monad]
           [left (of ! each (|>> (natural.% 8) (of natural.octal injection)) random.natural)
            right (of ! each (|>> (natural.% 8) (of natural.octal injection)) random.natural)
            .let [expected (\\injection.message left right)]
            invalid (|> random.natural
                        (of ! each (natural.% 16))
                        (random.only (natural.>= 8))
                        (of ! each (of natural.hex injection)))]
           (_.coverage [\\projection.some \\projection.some!]
             (and (..should_pass expected (\\projection.some \\projection.octal))
                  (..should_pass "" (\\projection.some \\projection.octal))
                  (..should_fail invalid (\\projection.some \\projection.octal))

                  (..should_pass! expected (\\projection.some! octal!))
                  (..should_pass! "" (\\projection.some! octal!)))))
         (do [! random.monad]
           [.let [octal (of ! each (|>> (natural.% 8) (of natural.octal injection)) random.natural)]
            first octal
            second octal
            third octal]
           (_.coverage [\\projection.exactly \\projection.exactly!]
             (and (..should_pass (\\injection.message first second) (\\projection.exactly 2 \\projection.octal))
                  (..should_fail (\\injection.message first second third) (\\projection.exactly 2 \\projection.octal))
                  (..should_fail (\\injection.message first) (\\projection.exactly 2 \\projection.octal))

                  (..should_pass! (\\injection.message first second) (\\projection.exactly! 2 octal!))
                  (..should_fail (\\injection.message first second third) (\\projection.exactly! 2 octal!))
                  (..should_fail (\\injection.message first) (\\projection.exactly! 2 octal!)))))
         (do [! random.monad]
           [.let [octal (of ! each (|>> (natural.% 8) (of natural.octal injection)) random.natural)]
            first octal
            second octal
            third octal]
           (_.coverage [\\projection.at_most \\projection.at_most!]
             (and (..should_pass (\\injection.message first second) (\\projection.at_most 2 \\projection.octal))
                  (..should_pass (\\injection.message first) (\\projection.at_most 2 \\projection.octal))
                  (..should_fail (\\injection.message first second third) (\\projection.at_most 2 \\projection.octal))

                  (..should_pass! (\\injection.message first second) (\\projection.at_most! 2 octal!))
                  (..should_pass! (\\injection.message first) (\\projection.at_most! 2 octal!))
                  (..should_fail (\\injection.message first second third) (\\projection.at_most! 2 octal!)))))
         (do [! random.monad]
           [.let [octal (of ! each (|>> (natural.% 8) (of natural.octal injection)) random.natural)]
            first octal
            second octal
            third octal]
           (_.coverage [\\projection.at_least \\projection.at_least!]
             (and (..should_pass (\\injection.message first second) (\\projection.at_least 2 \\projection.octal))
                  (..should_pass (\\injection.message first second third) (\\projection.at_least 2 \\projection.octal))
                  (..should_fail (\\injection.message first) (\\projection.at_least 2 \\projection.octal))

                  (..should_pass! (\\injection.message first second) (\\projection.at_least! 2 octal!))
                  (..should_pass! (\\injection.message first second third) (\\projection.at_least! 2 octal!))
                  (..should_fail (\\injection.message first) (\\projection.at_least! 2 octal!)))))
         (do [! random.monad]
           [.let [octal (of ! each (|>> (natural.% 8) (of natural.octal injection)) random.natural)]
            first octal
            second octal
            third octal]
           (_.coverage [\\projection.between \\projection.between!]
             (and (..should_pass (\\injection.message first second) (\\projection.between 2 1 \\projection.octal))
                  (..should_pass (\\injection.message first second third) (\\projection.between 2 1 \\projection.octal))
                  (..should_fail (\\injection.message first) (\\projection.between 2 1 \\projection.octal))

                  (..should_pass! (\\injection.message first second) (\\projection.between! 2 1 octal!))
                  (..should_pass! (\\injection.message first second third) (\\projection.between! 2 1 octal!))
                  (..should_fail (\\injection.message first) (\\projection.between! 2 1 octal!)))))
         )))

(the \\projection
  Test
  (<| (_.covering \\projection._)
      (_.for [\\projection.Projection])
      (all _.and
           (do [! random.monad]
             [sample (random.unicode 1)]
             (_.coverage [\\projection.value \\projection.end]
               (and (|> (\\projection.value \\projection.end
                                            "")
                        (!expect {try.#Success _}))
                    (|> (\\projection.value \\projection.end
                                            sample)
                        (!expect {try.#Failure _})))))
           (do [! random.monad]
             [.let [size 10]
              expected (random.unicode size)
              dummy (|> (random.unicode size)
                        (random.only (|>> (/.= expected) not)))]
             (_.coverage [\\projection.this \\projection.cannot_match]
               (and (|> (\\projection.value (\\projection.this expected)
                                            expected)
                        (!expect {try.#Success []}))
                    (|> (\\projection.value (\\projection.this expected)
                                            dummy)
                        (!expect (^.multi {try.#Failure error}
                                          (exception.is? \\projection.cannot_match error)))))))
           (_.coverage [\\projection.Slice \\projection.slice \\projection.cannot_slice]
             (|> ""
                 (\\projection.value (\\projection.slice \\projection.any!))
                 (!expect (^.multi {try.#Failure error}
                                   (exception.is? \\projection.cannot_slice error)))))
           (do [! random.monad]
             [expected (random.unicode 1)]
             (_.coverage [\\projection.any \\projection.any!]
               (and (..should_pass expected \\projection.any)
                    (..should_fail "" \\projection.any)

                    (..should_pass! expected \\projection.any!)
                    (..should_fail "" \\projection.any!))))
           (do [! random.monad]
             [expected (random.unicode 1)]
             (_.coverage [\\projection.next \\projection.cannot_parse]
               (and (..should_pass expected (<>.before \\projection.any \\projection.next))
                    (|> ""
                        (\\projection.value (<>.before \\projection.any \\projection.next))
                        (!expect (^.multi {try.#Failure error}
                                          (exception.is? \\projection.cannot_parse error)))))))
           (do [! random.monad]
             [dummy (random.unicode 1)]
             (_.coverage [\\projection.unconsumed_input]
               (|> (\\injection.message dummy dummy)
                   (\\projection.value \\projection.any)
                   (!expect (^.multi {try.#Failure error}
                                     (exception.is? \\projection.unconsumed_input error))))))
           (do [! random.monad]
             [sample (random.unicode 1)]
             (_.coverage [\\projection.Offset \\projection.offset]
               (|> sample
                   (\\projection.value (do <>.monad
                                         [pre \\projection.offset
                                          _ \\projection.any
                                          post \\projection.offset]
                                         (in [pre post])))
                   (!expect {try.#Success [0 1]}))))
           (do [! random.monad]
             [left (random.unicode 1)
              right (random.unicode 1)
              .let [input (\\injection.message left right)]]
             (_.coverage [\\projection.remaining]
               (|> input
                   (\\projection.value (do <>.monad
                                         [pre \\projection.remaining
                                          _ \\projection.any
                                          post \\projection.remaining
                                          _ \\projection.any]
                                         (in (and (/.= input pre)
                                                  (/.= right post)))))
                   (!expect {try.#Success .true}))))
           (do [! random.monad]
             [left (random.unicode 1)
              right (random.unicode 1)
              expected (random.only (|>> (/.= right) not)
                                    (random.unicode 1))]
             (_.coverage [\\projection.enclosed]
               (|> (\\injection.message left expected right)
                   (\\projection.value (\\projection.enclosed [left right] (\\projection.this expected)))
                   (!expect {try.#Success _}))))
           (do [! random.monad]
             [input (random.unicode 1)
              output (random.unicode 1)]
             (_.coverage [\\projection.local]
               (|> output
                   (\\projection.value (do <>.monad
                                         [_ (\\projection.local input (\\projection.this input))]
                                         (\\projection.this output)))
                   (!expect {try.#Success _}))))
           (do [! random.monad]
             [expected (of ! each (|>> (natural.% 8) (of natural.octal injection)) random.natural)]
             (_.coverage [\\projection.then]
               (|> (list (code.text expected))
                   (<code>.value (\\projection.then \\projection.octal <code>.text))
                   (!expect (^.multi {try.#Success actual}
                                     (/.= expected actual))))))
           (do [! random.monad]
             [invalid (random.upper_cased 1)
              expected (random.only (|>> (unicode/block.within? unicode/block.upper_case)
                                         not)
                                    (random.character unicode.character))
              .let [upper! (\\projection.one_of! "ABCDEFGHIJKLMNOPQRSTUVWXYZ")]]
             (_.coverage [\\projection.not \\projection.not! \\projection.expected_to_fail]
               (and (..should_pass (/.of_character expected) (\\projection.not \\projection.upper))
                    (|> invalid
                        (\\projection.value (\\projection.not \\projection.upper))
                        (!expect (^.multi {try.#Failure error}
                                          (exception.is? \\projection.expected_to_fail error))))

                    (..should_pass! (/.of_character expected) (\\projection.not! upper!))
                    (|> invalid
                        (\\projection.value (\\projection.not! upper!))
                        (!expect (^.multi {try.#Failure error}
                                          (exception.is? \\projection.expected_to_fail error)))))))
           (do [! random.monad]
             [upper (random.upper_cased 1)
              lower (random.lower_cased 1)
              invalid (random.only (function (_ character)
                                     (not (or (unicode/block.within? unicode/block.upper_case character)
                                              (unicode/block.within? unicode/block.lower_case character))))
                                   (random.character unicode.character))
              .let [upper! (\\projection.one_of! "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
                    lower! (\\projection.one_of! "abcdefghijklmnopqrstuvwxyz")]]
             (_.coverage [\\projection.and \\projection.and!]
               (and (..should_pass (\\injection.message upper lower) (\\projection.and \\projection.upper \\projection.lower))
                    (..should_fail (\\injection.message (/.of_character invalid) lower) (\\projection.and \\projection.upper \\projection.lower))
                    (..should_fail (\\injection.message upper (/.of_character invalid)) (\\projection.and \\projection.upper \\projection.lower))

                    (..should_pass! (\\injection.message upper lower) (\\projection.and! upper! lower!))
                    (..should_fail (\\injection.message (/.of_character invalid) lower) (\\projection.and! upper! lower!))
                    (..should_fail (\\injection.message upper (/.of_character invalid)) (\\projection.and! upper! lower!)))))
           (do [! random.monad]
             [expected (random.unicode 1)
              invalid (random.unicode 1)]
             (_.coverage [\\projection.satisfies \\projection.character_does_not_satisfy_predicate]
               (and (..should_pass expected (\\projection.satisfies (function.constant true)))
                    (..should_fail' invalid (\\projection.satisfies (function.constant false))
                                    \\projection.character_does_not_satisfy_predicate))))

           \\projection#character_classes
           \\projection#runs
           )))

(the bounded_size
  (random.Random Natural)
  (|> random.natural
      (of random.monad each (|>> (natural.% 20) (natural.+ 1)))))

(the size
  Test
  (do [! random.monad]
    [size (of ! each (natural.% 10) random.natural)
     sample (random.unicode size)]
    (all _.and
         (_.coverage [/.size]
           (natural.= size (/.size sample)))
         (_.coverage [/.empty?]
           (or (/.empty? sample)
               (not (natural.= 0 size)))))))

(the affix
  Test
  (do [! random.monad]
    [inner (random.unicode 1)
     outer (random.only (|>> (of /.equivalence = inner) not)
                        (random.unicode 1))
     left (random.unicode 1)
     right (random.unicode 1)
     .let [full (of /.monoid composite inner outer)
           fake_index (-- 0)]]
    (`` (all _.and
             (,, (template.with [<affix> <predicate>]
                   [(_.coverage [<affix> <predicate>]
                      (<predicate> outer (<affix> outer inner)))]

                   [/.prefix /.starts_with?]
                   [/.suffix /.ends_with?]
                   [/.enclosed' /.enclosed_by?]
                   ))
             (_.coverage [/.enclosed]
               (let [value (/.enclosed [left right] inner)]
                 (and (/.starts_with? left value)
                      (/.ends_with? right value))))
             (_.coverage [/.injection]
               (let [sample (/.injection inner)]
                 (and (/.enclosed_by? /.double_quote sample)
                      (/.contains? inner sample))))
             ))))

(the index
  Test
  (do [! random.monad]
    [inner (random.unicode 1)
     outer (random.only (|>> (of /.equivalence = inner) not)
                        (random.unicode 1))
     .let [fake_index (-- 0)]]
    (all _.and
         (_.coverage [/.contains?]
           (let [full (of /.monoid composite inner outer)]
             (and (/.contains? inner full)
                  (/.contains? outer full))))
         (_.coverage [/.index]
           (and (|> (/.index inner (of /.monoid composite inner outer))
                    (maybe.else fake_index)
                    (natural.= 0))
                (|> (/.index outer (of /.monoid composite inner outer))
                    (maybe.else fake_index)
                    (natural.= 1))))
         (_.coverage [/.index_since]
           (let [full (of /.monoid composite inner outer)]
             (and (|> (/.index_since 0 inner full)
                      (maybe.else fake_index)
                      (natural.= 0))
                  (|> (/.index_since 1 inner full)
                      (maybe.else fake_index)
                      (natural.= fake_index))
                  
                  (|> (/.index_since 0 outer full)
                      (maybe.else fake_index)
                      (natural.= 1))
                  (|> (/.index_since 1 outer full)
                      (maybe.else fake_index)
                      (natural.= 1))
                  (|> (/.index_since 2 outer full)
                      (maybe.else fake_index)
                      (natural.= fake_index)))))
         (_.coverage [/.last_index]
           (let [full (all (of /.monoid composite) outer inner outer)]
             (and (|> (/.last_index inner full)
                      (maybe.else fake_index)
                      (natural.= 1))
                  (|> (/.last_index outer full)
                      (maybe.else fake_index)
                      (natural.= 2)))))
         )))

(the character
  Test
  (all _.and
       (_.for [/.of_character]
              (`` (all _.and
                       (,, (template.with [<short> <long>]
                             [(_.coverage [<short> <long>]
                                (of /.equivalence = <short> <long>))]

                             [/.\0  /.null]
                             [/.\a  /.alarm]
                             [/.\b  /.back_space]
                             [/.\t  /.tab]
                             [/.\n  /.new_line]
                             [/.\v  /.vertical_tab]
                             [/.\f  /.form_feed]
                             [/.\r  /.carriage_return]
                             [/.\'' /.double_quote]))
                       (_.coverage [/.line_feed]
                         (of /.equivalence = /.new_line /.line_feed))
                       )))
       (do [! random.monad]
         [size (of ! each (|>> (natural.% 10) ++) random.natural)
          characters (random.set /.hash size (random.alphabetic 1))
          .let [sample (|> characters set.list /.together)]
          expected (of ! each (natural.% size) random.natural)]
         (_.coverage [/.character]
           (when (/.character expected sample)
             {.#Some character}
             (when (/.index (/.of_character character) sample)
               {.#Some actual}
               (natural.= expected actual)

               _
               false)
             
             {.#None}
             false)))
       (_.coverage [/.space /.space?]
         (`` (and (,, (template.with [<character>]
                        [(/.space? (`` (.character (,, (static <character>)))))]
                        
                        [/.tab]
                        [/.vertical_tab]
                        [/.space]
                        [/.new_line]
                        [/.carriage_return]
                        [/.form_feed]
                        )))))
       ))

(the manipulation
  Test
  (do [! random.monad]
    [size (of ! each (|>> (natural.% 10) (natural.+ 2)) random.natural)
     characters (random.set /.hash size (random.alphabetic 1))
     separator (random.only (|>> (set.member? characters) not)
                            (random.alphabetic 1))
     .let [with_no_separator (|> characters set.list /.together)]
     static (random.alphabetic 1)
     .let [dynamic (random.only (|>> (of /.equivalence = static) not)
                                (random.alphabetic 1))]
     pre dynamic
     post dynamic

     lower (random.lower_cased 1)
     upper (random.upper_cased 1)]
    (all _.and
         (_.coverage [/.together]
           (natural.= (set.size characters)
                      (/.size (/.together (set.list characters)))))
         (_.coverage [/.interposed /.all_split_by]
           (and (|> (set.list characters)
                    (/.interposed separator)
                    (/.all_split_by separator)
                    (set.of_list /.hash)
                    (of set.equivalence = characters))
                (of /.equivalence =
                    (/.together (set.list characters))
                    (/.interposed "" (set.list characters)))))
         (_.coverage [/.replaced_once]
           (of /.equivalence =
               (of /.monoid composite post static)
               (/.replaced_once pre post (of /.monoid composite pre static))))
         (_.coverage [/.split_by]
           (when (/.split_by static (all (of /.monoid composite) pre static post))
             {.#Some [left right]}
             (and (of /.equivalence = pre left)
                  (of /.equivalence = post right))
             
             {.#None}
             false))
         (_.coverage [/.lower_cased]
           (let [effectiveness!
                 (|> upper
                     /.lower_cased
                     (of /.equivalence = upper)
                     not)

                 idempotence!
                 (|> lower
                     /.lower_cased
                     (of /.equivalence = lower))
                 
                 inverse!
                 (|> lower
                     /.upper_cased
                     /.lower_cased
                     (of /.equivalence = lower))]
             (and effectiveness!
                  idempotence!
                  inverse!)))
         (_.coverage [/.upper_cased]
           (let [effectiveness!
                 (|> lower
                     /.upper_cased
                     (of /.equivalence = lower)
                     not)

                 idempotence!
                 (|> upper
                     /.upper_cased
                     (of /.equivalence = upper))
                 
                 inverse!
                 (|> upper
                     /.lower_cased
                     /.upper_cased
                     (of /.equivalence = upper))]
             (and effectiveness!
                  idempotence!
                  inverse!)))
         )))

(the .public test
  Test
  (<| (_.covering /._)
      (_.for [.Text])
      (all _.and
           (_.for [/.equivalence]
                  (equivalenceT.spec /.equivalence (random.ascii 2)))
           (_.for [/.hash]
                  (hashT.spec /.hash (random.ascii 1)))
           (_.for [/.order]
                  (orderT.spec /.order (random.ascii 2)))
           (_.for [/.monoid]
                  (monoidT.spec /.equivalence /.monoid (random.ascii 2)))

           ..size
           ..affix
           ..index
           ..character
           ..manipulation
           
           (do random.monad
             [sizeL bounded_size
              sizeR bounded_size
              sampleL (random.unicode sizeL)
              sampleR (random.unicode sizeR)
              middle (random.unicode 1)
              .let [sample (/.together (list sampleL sampleR))
                    (open "/#[0]") /.equivalence]]
             (all _.and
                  (_.coverage [/.split_at]
                    (|> (/.split_at sizeL sample)
                        (pipe.when
                          {.#Right [_l _r]}
                          (and (/.= sampleL _l)
                               (/.= sampleR _r)
                               (/.= sample (/.together (list _l _r))))

                          _
                          false)))
                  (_.coverage [/.clip /.clip_since]
                    (|> [(/.clip 0 sizeL sample)
                         (/.clip sizeL (natural.- sizeL (/.size sample)) sample)
                         (/.clip_since sizeL sample)
                         (/.clip_since 0 sample)]
                        (pipe.when
                          [{.#Right _l} {.#Right _r} {.#Right _r'} {.#Right _f}]
                          (and (/.= sampleL _l)
                               (/.= sampleR _r)
                               (/.= _r _r')
                               (/.= sample _f))

                          _
                          false)))
                  ))
           (do [! random.monad]
             [sizeP bounded_size
              sizeL bounded_size
              .let [... The wider unicode charset includes control characters that
                    ... can make text replacement work improperly.
                    ... Because of that, I restrict the charset.
                    normal_character_gen (is (Random Character)
                                             (of ! each (|>> (natural.% 128) (natural.max 1)) random.natural))]
              sep1 (random.text normal_character_gen 1)
              sep2 (random.text normal_character_gen 1)
              .let [part_gen (|> (random.text normal_character_gen sizeP)
                                 (random.only (|>> (/.contains? sep1) not)))]
              parts (random.list sizeL part_gen)
              .let [sample1 (/.together (list.interposed sep1 parts))
                    sample2 (/.together (list.interposed sep2 parts))
                    (open "/#[0]") /.equivalence]]
             (_.coverage [/.replaced]
               (/.= sample2
                    (/.replaced sep1 sep2 sample1))))

           /character.test
           /buffer.test
           /encoding.test
           /regex.test
           /escape.test
           /unicode.test

           ..\\projection
           ..\\injection
           )))
