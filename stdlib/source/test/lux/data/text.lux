(.module:
  [lux (#- char)
   ["_" test (#+ Test)]
   [abstract
    [monad (#+ do)]
    {[0 #spec]
     [/
      ["$." equivalence]
      ["$." order]
      ["$." monoid]]}]
   [control
    pipe]
   [data
    ["." maybe]
    [number
     ["n" nat]]
    [collection
     ["." list]
     ["." set]]]
   [math
    ["." random]]]
  {1
   ["." /]})

(def: bounded-size
  (random.Random Nat)
  (|> random.nat
      (:: random.monad map (|>> (n.% 20) (n.+ 1)))))

(def: size
  Test
  (do {@ random.monad}
    [size (:: @ map (n.% 10) random.nat)
     sample (random.unicode size)]
    ($_ _.and
        (_.cover [/.size]
                 (n.= size (/.size sample)))
        (_.cover [/.empty?]
                 (or (/.empty? sample)
                     (not (n.= 0 size)))))))

(def: affix
  Test
  (do {@ random.monad}
    [inner (random.unicode 1)
     outer (random.filter (|>> (:: /.equivalence = inner) not)
                          (random.unicode 1))
     left (random.unicode 1)
     right (random.unicode 1)
     #let [full (:: /.monoid compose inner outer)
           fake-index (.nat -1)]]
    (`` ($_ _.and
            (~~ (template [<affix> <predicate>]
                  [(_.cover [<affix> <predicate>]
                            (<predicate> outer (<affix> outer inner)))]

                  [/.prefix /.starts-with?]
                  [/.suffix /.ends-with?]
                  [/.enclose' /.encloses?]
                  ))
            (_.cover [/.enclose]
                     (let [value (/.enclose [left right] inner)]
                       (and (/.starts-with? left value)
                            (/.ends-with? right value))))
            (_.cover [/.encode]
                     (let [sample (/.encode inner)]
                       (and (/.encloses? /.double-quote sample)
                            (/.contains? inner sample))))
            ))))

(def: index
  Test
  (do {@ random.monad}
    [inner (random.unicode 1)
     outer (random.filter (|>> (:: /.equivalence = inner) not)
                          (random.unicode 1))
     #let [fake-index (.nat -1)]]
    ($_ _.and
        (_.cover [/.contains?]
                 (let [full (:: /.monoid compose inner outer)]
                   (and (/.contains? inner full)
                        (/.contains? outer full))))
        (_.cover [/.index-of]
                 (and (|> (/.index-of inner (:: /.monoid compose inner outer))
                          (maybe.default fake-index)
                          (n.= 0))
                      (|> (/.index-of outer (:: /.monoid compose inner outer))
                          (maybe.default fake-index)
                          (n.= 1))))
        (_.cover [/.index-of']
                 (let [full (:: /.monoid compose inner outer)]
                   (and (|> (/.index-of' inner 0 full)
                            (maybe.default fake-index)
                            (n.= 0))
                        (|> (/.index-of' inner 1 full)
                            (maybe.default fake-index)
                            (n.= fake-index))
                        
                        (|> (/.index-of' outer 0 full)
                            (maybe.default fake-index)
                            (n.= 1))
                        (|> (/.index-of' outer 1 full)
                            (maybe.default fake-index)
                            (n.= 1))
                        (|> (/.index-of' outer 2 full)
                            (maybe.default fake-index)
                            (n.= fake-index)))))
        (_.cover [/.last-index-of]
                 (let [full ($_ (:: /.monoid compose) outer inner outer)]
                   (and (|> (/.last-index-of inner full)
                            (maybe.default fake-index)
                            (n.= 1))
                        (|> (/.last-index-of outer full)
                            (maybe.default fake-index)
                            (n.= 2)))))
        (_.cover [/.last-index-of']
                 (let [full ($_ (:: /.monoid compose) outer inner outer)]
                   (and (|> (/.last-index-of' inner 0 full)
                            (maybe.default fake-index)
                            (n.= 1))
                        (|> (/.last-index-of' inner 2 full)
                            (maybe.default fake-index)
                            (n.= fake-index))
                        
                        (|> (/.last-index-of' outer 0 full)
                            (maybe.default fake-index)
                            (n.= 2))
                        (|> (/.last-index-of' outer 2 full)
                            (maybe.default fake-index)
                            (n.= 2))
                        (|> (/.last-index-of' outer 3 full)
                            (maybe.default fake-index)
                            (n.= fake-index)))))
        )))

(def: char
  Test
  ($_ _.and
      (_.with-cover [/.Char /.from-code]
        (`` ($_ _.and
                (~~ (template [<short> <long>]
                      [(_.cover [<short> <long>]
                                (:: /.equivalence = <short> <long>))]

                      [/.\0  /.null]
                      [/.\a  /.alarm]
                      [/.\b  /.back-space]
                      [/.\t  /.tab]
                      [/.\n  /.new-line]
                      [/.\v  /.vertical-tab]
                      [/.\f  /.form-feed]
                      [/.\r  /.carriage-return]
                      [/.\'' /.double-quote]))
                (_.cover [/.line-feed]
                         (:: /.equivalence = /.new-line /.line-feed))
                )))
      (do {@ random.monad}
        [size (:: @ map (|>> (n.% 10) inc) random.nat)
         characters (random.set /.hash size (random.ascii/alpha 1))
         #let [sample (|> characters set.to-list /.concat)]
         expected (:: @ map (n.% size) random.nat)]
        (_.cover [/.nth]
                 (case (/.nth expected sample)
                   (#.Some char)
                   (case (/.index-of (/.from-code char) sample)
                     (#.Some actual)
                     (n.= expected actual)

                     _
                     false)
                   
                   #.None
                   false)))
      (_.cover [/.space /.space?]
               (`` (and (~~ (template [<char>]
                              [(/.space? (`` (.char (~~ (static <char>)))))]
                              
                              [/.tab]
                              [/.vertical-tab]
                              [/.space]
                              [/.new-line]
                              [/.carriage-return]
                              [/.form-feed]
                              )))))
      ))

(def: manipulation
  Test
  (do {@ random.monad}
    [size (:: @ map (|>> (n.% 10) (n.+ 2)) random.nat)
     characters (random.set /.hash size (random.ascii/alpha 1))
     separator (random.filter (|>> (set.member? characters) not)
                              (random.ascii/alpha 1))
     #let [with-no-separator (|> characters set.to-list /.concat)]
     static (random.ascii/alpha 1)
     #let [dynamic (random.filter (|>> (:: /.equivalence = static) not)
                                  (random.ascii/alpha 1))]
     pre dynamic
     post dynamic]
    ($_ _.and
        (_.cover [/.concat]
                 (n.= (set.size characters)
                      (/.size (/.concat (set.to-list characters)))))
        (_.cover [/.join-with /.split-all-with]
                 (and (|> (set.to-list characters)
                          (/.join-with separator)
                          (/.split-all-with separator)
                          (set.from-list /.hash)
                          (:: set.equivalence = characters))
                      (:: /.equivalence =
                          (/.concat (set.to-list characters))
                          (/.join-with "" (set.to-list characters)))))
        (_.cover [/.replace-once]
                 (:: /.equivalence =
                     (:: /.monoid compose post static)
                     (/.replace-once pre post (:: /.monoid compose pre static))))
        (_.cover [/.split-with]
                 (case (/.split-with static ($_ (:: /.monoid compose) pre static post))
                   (#.Some [left right])
                   (and (:: /.equivalence = pre left)
                        (:: /.equivalence = post right))
                   
                   #.None
                   false))
        )))

(def: #export test
  Test
  (<| (_.covering /._)
      (_.with-cover [.Text])
      ($_ _.and
          (_.with-cover [/.equivalence]
            ($equivalence.spec /.equivalence (random.ascii 2)))
          (_.with-cover [/.order]
            ($order.spec /.order (random.ascii 2)))
          (_.with-cover [/.monoid]
            ($monoid.spec /.equivalence /.monoid (random.ascii 2)))

          ..size
          ..affix
          ..index
          ..char
          ..manipulation
          
          (do random.monad
            [sizeL bounded-size
             sizeR bounded-size
             sampleL (random.unicode sizeL)
             sampleR (random.unicode sizeR)
             middle (random.unicode 1)
             #let [sample (/.concat (list sampleL sampleR))
                   (^open "/@.") /.equivalence]]
            ($_ _.and
                (_.cover [/.split]
                         (|> (/.split sizeL sample)
                             (case> (#.Right [_l _r])
                                    (and (/@= sampleL _l)
                                         (/@= sampleR _r)
                                         (/@= sample (/.concat (list _l _r))))

                                    _
                                    #0)))
                (_.cover [/.clip /.clip']
                         (|> [(/.clip 0 sizeL sample)
                              (/.clip sizeL (/.size sample) sample)
                              (/.clip' sizeL sample)
                              (/.clip' 0 sample)]
                             (case> [(#.Right _l) (#.Right _r) (#.Right _r') (#.Right _f)]
                                    (and (/@= sampleL _l)
                                         (/@= sampleR _r)
                                         (/@= _r _r')
                                         (/@= sample _f))

                                    _
                                    #0)))
                ))
          (do {@ random.monad}
            [sizeP bounded-size
             sizeL bounded-size
             #let [## The wider unicode charset includes control characters that
                   ## can make text replacement work improperly.
                   ## Because of that, I restrict the charset.
                   normal-char-gen (|> random.nat (:: @ map (|>> (n.% 128) (n.max 1))))]
             sep1 (random.text normal-char-gen 1)
             sep2 (random.text normal-char-gen 1)
             #let [part-gen (|> (random.text normal-char-gen sizeP)
                                (random.filter (|>> (/.contains? sep1) not)))]
             parts (random.list sizeL part-gen)
             #let [sample1 (/.concat (list.interpose sep1 parts))
                   sample2 (/.concat (list.interpose sep2 parts))
                   (^open "/@.") /.equivalence]]
            (_.cover [/.replace-all]
                     (/@= sample2
                          (/.replace-all sep1 sep2 sample1))))
          )))
