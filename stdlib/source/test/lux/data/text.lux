(.module:
  [library
   [lux {"-" [char]}
    ["_" test {"+" [Test]}]
    [abstract
     [monad {"+" [do]}]
     [\\specification
      ["$." equivalence]
      ["$." hash]
      ["$." order]
      ["$." monoid]]]
    [control
     pipe
     ["." maybe]]
    [data
     [collection
      ["." list]
      ["." set]]]
    [math
     ["." random]
     [number
      ["n" nat]]]]]
  ["." / "_"
   ["#." buffer]
   ["#." encoding]
   ["#." format]
   ["#." regex]
   ["#." escape]
   ["#." unicode "_"
    ["#" set]]]
  [\\library
   ["." /]])

(def: bounded_size
  (random.Random Nat)
  (|> random.nat
      (\ random.monad each (|>> (n.% 20) (n.+ 1)))))

(def: size
  Test
  (do {! random.monad}
    [size (\ ! each (n.% 10) random.nat)
     sample (random.unicode size)]
    ($_ _.and
        (_.cover [/.size]
                 (n.= size (/.size sample)))
        (_.cover [/.empty?]
                 (or (/.empty? sample)
                     (not (n.= 0 size)))))))

(def: affix
  Test
  (do {! random.monad}
    [inner (random.unicode 1)
     outer (random.only (|>> (\ /.equivalence = inner) not)
                        (random.unicode 1))
     left (random.unicode 1)
     right (random.unicode 1)
     .let [full (\ /.monoid composite inner outer)
           fake_index (-- 0)]]
    (`` ($_ _.and
            (~~ (template [<affix> <predicate>]
                  [(_.cover [<affix> <predicate>]
                            (<predicate> outer (<affix> outer inner)))]

                  [/.prefix /.starts_with?]
                  [/.suffix /.ends_with?]
                  [/.enclosed' /.enclosed_by?]
                  ))
            (_.cover [/.enclosed]
                     (let [value (/.enclosed [left right] inner)]
                       (and (/.starts_with? left value)
                            (/.ends_with? right value))))
            (_.cover [/.format]
                     (let [sample (/.format inner)]
                       (and (/.enclosed_by? /.double_quote sample)
                            (/.contains? inner sample))))
            ))))

(def: index
  Test
  (do {! random.monad}
    [inner (random.unicode 1)
     outer (random.only (|>> (\ /.equivalence = inner) not)
                        (random.unicode 1))
     .let [fake_index (-- 0)]]
    ($_ _.and
        (_.cover [/.contains?]
                 (let [full (\ /.monoid composite inner outer)]
                   (and (/.contains? inner full)
                        (/.contains? outer full))))
        (_.cover [/.index]
                 (and (|> (/.index inner (\ /.monoid composite inner outer))
                          (maybe.else fake_index)
                          (n.= 0))
                      (|> (/.index outer (\ /.monoid composite inner outer))
                          (maybe.else fake_index)
                          (n.= 1))))
        (_.cover [/.index_since]
                 (let [full (\ /.monoid composite inner outer)]
                   (and (|> (/.index_since 0 inner full)
                            (maybe.else fake_index)
                            (n.= 0))
                        (|> (/.index_since 1 inner full)
                            (maybe.else fake_index)
                            (n.= fake_index))
                        
                        (|> (/.index_since 0 outer full)
                            (maybe.else fake_index)
                            (n.= 1))
                        (|> (/.index_since 1 outer full)
                            (maybe.else fake_index)
                            (n.= 1))
                        (|> (/.index_since 2 outer full)
                            (maybe.else fake_index)
                            (n.= fake_index)))))
        (_.cover [/.last_index]
                 (let [full ($_ (\ /.monoid composite) outer inner outer)]
                   (and (|> (/.last_index inner full)
                            (maybe.else fake_index)
                            (n.= 1))
                        (|> (/.last_index outer full)
                            (maybe.else fake_index)
                            (n.= 2)))))
        )))

(def: char
  Test
  ($_ _.and
      (_.for [/.Char /.of_char]
             (`` ($_ _.and
                     (~~ (template [<short> <long>]
                           [(_.cover [<short> <long>]
                                     (\ /.equivalence = <short> <long>))]

                           [/.\0  /.null]
                           [/.\a  /.alarm]
                           [/.\b  /.back_space]
                           [/.\t  /.tab]
                           [/.\n  /.new_line]
                           [/.\v  /.vertical_tab]
                           [/.\f  /.form_feed]
                           [/.\r  /.carriage_return]
                           [/.\'' /.double_quote]))
                     (_.cover [/.line_feed]
                              (\ /.equivalence = /.new_line /.line_feed))
                     )))
      (do {! random.monad}
        [size (\ ! each (|>> (n.% 10) ++) random.nat)
         characters (random.set /.hash size (random.ascii/alpha 1))
         .let [sample (|> characters set.list /.together)]
         expected (\ ! each (n.% size) random.nat)]
        (_.cover [/.char]
                 (case (/.char expected sample)
                   (#.Some char)
                   (case (/.index (/.of_char char) sample)
                     (#.Some actual)
                     (n.= expected actual)

                     _
                     false)
                   
                   #.None
                   false)))
      (_.cover [/.space /.space?]
               (`` (and (~~ (template [<char>]
                              [(/.space? (`` (.char (~~ (static <char>)))))]
                              
                              [/.tab]
                              [/.vertical_tab]
                              [/.space]
                              [/.new_line]
                              [/.carriage_return]
                              [/.form_feed]
                              )))))
      ))

(def: manipulation
  Test
  (do {! random.monad}
    [size (\ ! each (|>> (n.% 10) (n.+ 2)) random.nat)
     characters (random.set /.hash size (random.ascii/alpha 1))
     separator (random.only (|>> (set.member? characters) not)
                            (random.ascii/alpha 1))
     .let [with_no_separator (|> characters set.list /.together)]
     static (random.ascii/alpha 1)
     .let [dynamic (random.only (|>> (\ /.equivalence = static) not)
                                (random.ascii/alpha 1))]
     pre dynamic
     post dynamic

     lower (random.ascii/lower 1)
     upper (random.ascii/upper 1)]
    ($_ _.and
        (_.cover [/.together]
                 (n.= (set.size characters)
                      (/.size (/.together (set.list characters)))))
        (_.cover [/.interposed /.all_split_by]
                 (and (|> (set.list characters)
                          (/.interposed separator)
                          (/.all_split_by separator)
                          (set.of_list /.hash)
                          (\ set.equivalence = characters))
                      (\ /.equivalence =
                         (/.together (set.list characters))
                         (/.interposed "" (set.list characters)))))
        (_.cover [/.replaced/1]
                 (\ /.equivalence =
                    (\ /.monoid composite post static)
                    (/.replaced/1 pre post (\ /.monoid composite pre static))))
        (_.cover [/.split_by]
                 (case (/.split_by static ($_ (\ /.monoid composite) pre static post))
                   (#.Some [left right])
                   (and (\ /.equivalence = pre left)
                        (\ /.equivalence = post right))
                   
                   #.None
                   false))
        (_.cover [/.lower_cased]
                 (let [effectiveness!
                       (|> upper
                           /.lower_cased
                           (\ /.equivalence = upper)
                           not)

                       idempotence!
                       (|> lower
                           /.lower_cased
                           (\ /.equivalence = lower))
                       
                       inverse!
                       (|> lower
                           /.upper_cased
                           /.lower_cased
                           (\ /.equivalence = lower))]
                   (and effectiveness!
                        idempotence!
                        inverse!)))
        (_.cover [/.upper_cased]
                 (let [effectiveness!
                       (|> lower
                           /.upper_cased
                           (\ /.equivalence = lower)
                           not)

                       idempotence!
                       (|> upper
                           /.upper_cased
                           (\ /.equivalence = upper))
                       
                       inverse!
                       (|> upper
                           /.lower_cased
                           /.upper_cased
                           (\ /.equivalence = upper))]
                   (and effectiveness!
                        idempotence!
                        inverse!)))
        )))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [.Text])
      ($_ _.and
          (_.for [/.equivalence]
                 ($equivalence.spec /.equivalence (random.ascii 2)))
          (_.for [/.hash]
                 (|> (random.ascii 1)
                     ($hash.spec /.hash)))
          (_.for [/.order]
                 ($order.spec /.order (random.ascii 2)))
          (_.for [/.monoid]
                 ($monoid.spec /.equivalence /.monoid (random.ascii 2)))

          ..size
          ..affix
          ..index
          ..char
          ..manipulation
          
          (do random.monad
            [sizeL bounded_size
             sizeR bounded_size
             sampleL (random.unicode sizeL)
             sampleR (random.unicode sizeR)
             middle (random.unicode 1)
             .let [sample (/.together (list sampleL sampleR))
                   (^open "/\.") /.equivalence]]
            ($_ _.and
                (_.cover [/.split_at]
                         (|> (/.split_at sizeL sample)
                             (case> (#.Right [_l _r])
                                    (and (/\= sampleL _l)
                                         (/\= sampleR _r)
                                         (/\= sample (/.together (list _l _r))))

                                    _
                                    #0)))
                (_.cover [/.clip /.clip_since]
                         (|> [(/.clip 0 sizeL sample)
                              (/.clip sizeL (n.- sizeL (/.size sample)) sample)
                              (/.clip_since sizeL sample)
                              (/.clip_since 0 sample)]
                             (case> [(#.Right _l) (#.Right _r) (#.Right _r') (#.Right _f)]
                                    (and (/\= sampleL _l)
                                         (/\= sampleR _r)
                                         (/\= _r _r')
                                         (/\= sample _f))

                                    _
                                    #0)))
                ))
          (do {! random.monad}
            [sizeP bounded_size
             sizeL bounded_size
             .let [... The wider unicode charset includes control characters that
                   ... can make text replacement work improperly.
                   ... Because of that, I restrict the charset.
                   normal_char_gen (|> random.nat (\ ! each (|>> (n.% 128) (n.max 1))))]
             sep1 (random.text normal_char_gen 1)
             sep2 (random.text normal_char_gen 1)
             .let [part_gen (|> (random.text normal_char_gen sizeP)
                                (random.only (|>> (/.contains? sep1) not)))]
             parts (random.list sizeL part_gen)
             .let [sample1 (/.together (list.interposed sep1 parts))
                   sample2 (/.together (list.interposed sep2 parts))
                   (^open "/\.") /.equivalence]]
            (_.cover [/.replaced]
                     (/\= sample2
                          (/.replaced sep1 sep2 sample1))))

          /buffer.test
          /encoding.test
          /format.test
          /regex.test
          /escape.test
          /unicode.test
          )))
