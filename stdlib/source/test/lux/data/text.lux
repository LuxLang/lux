(.using
 [library
  [lux {"-" char}
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]
    [\\specification
     ["$[0]" equivalence]
     ["$[0]" hash]
     ["$[0]" order]
     ["$[0]" monoid]]]
   [control
    ["[0]" pipe]
    ["[0]" maybe]]
   [data
    [collection
     ["[0]" list]
     ["[0]" set]]]
   [math
    ["[0]" random]
    [number
     ["n" nat]]]]]
 ["[0]" / "_"
  ["[1][0]" buffer]
  ["[1][0]" encoding]
  ["[1][0]" format]
  ["[1][0]" regex]
  ["[1][0]" escape]
  ["[1][0]" unicode "_"
   ["[1]" set]]]
 [\\library
  ["[0]" /]])

(def: bounded_size
  (random.Random Nat)
  (|> random.nat
      (# random.monad each (|>> (n.% 20) (n.+ 1)))))

(def: size
  Test
  (do [! random.monad]
    [size (# ! each (n.% 10) random.nat)
     sample (random.unicode size)]
    (all _.and
         (_.coverage [/.size]
           (n.= size (/.size sample)))
         (_.coverage [/.empty?]
           (or (/.empty? sample)
               (not (n.= 0 size)))))))

(def: affix
  Test
  (do [! random.monad]
    [inner (random.unicode 1)
     outer (random.only (|>> (# /.equivalence = inner) not)
                        (random.unicode 1))
     left (random.unicode 1)
     right (random.unicode 1)
     .let [full (# /.monoid composite inner outer)
           fake_index (-- 0)]]
    (`` (all _.and
             (~~ (template [<affix> <predicate>]
                   [(_.coverage [<affix> <predicate>]
                      (<predicate> outer (<affix> outer inner)))]

                   [/.prefix /.starts_with?]
                   [/.suffix /.ends_with?]
                   [/.enclosed' /.enclosed_by?]
                   ))
             (_.coverage [/.enclosed]
               (let [value (/.enclosed [left right] inner)]
                 (and (/.starts_with? left value)
                      (/.ends_with? right value))))
             (_.coverage [/.format]
               (let [sample (/.format inner)]
                 (and (/.enclosed_by? /.double_quote sample)
                      (/.contains? inner sample))))
             ))))

(def: index
  Test
  (do [! random.monad]
    [inner (random.unicode 1)
     outer (random.only (|>> (# /.equivalence = inner) not)
                        (random.unicode 1))
     .let [fake_index (-- 0)]]
    (all _.and
         (_.coverage [/.contains?]
           (let [full (# /.monoid composite inner outer)]
             (and (/.contains? inner full)
                  (/.contains? outer full))))
         (_.coverage [/.index]
           (and (|> (/.index inner (# /.monoid composite inner outer))
                    (maybe.else fake_index)
                    (n.= 0))
                (|> (/.index outer (# /.monoid composite inner outer))
                    (maybe.else fake_index)
                    (n.= 1))))
         (_.coverage [/.index_since]
           (let [full (# /.monoid composite inner outer)]
             (and (|> (/.index_since 0 inner full)
                      (maybe.else fake_index)
                      (n.= 0))
                  (|> (/.index_since 1 inner full)
                      (maybe.else fake_index)
                      (n.= fake_index))
                  
                  (|> (/.index_since 0 outer full)
                      (maybe.else fake_index)
                      (n.= 1))
                  (|> (/.index_since 1 outer full)
                      (maybe.else fake_index)
                      (n.= 1))
                  (|> (/.index_since 2 outer full)
                      (maybe.else fake_index)
                      (n.= fake_index)))))
         (_.coverage [/.last_index]
           (let [full (all (# /.monoid composite) outer inner outer)]
             (and (|> (/.last_index inner full)
                      (maybe.else fake_index)
                      (n.= 1))
                  (|> (/.last_index outer full)
                      (maybe.else fake_index)
                      (n.= 2)))))
         )))

(def: char
  Test
  (all _.and
       (_.for [/.Char /.of_char]
              (`` (all _.and
                       (~~ (template [<short> <long>]
                             [(_.coverage [<short> <long>]
                                (# /.equivalence = <short> <long>))]

                             [/.\0  /.null]
                             [/.\a  /.alarm]
                             [/.\b  /.back_space]
                             [/.\t  /.tab]
                             [/.\n  /.new_line]
                             [/.\v  /.vertical_tab]
                             [/.\f  /.form_feed]
                             [/.\r  /.carriage_return]
                             [/.\'' /.double_quote]))
                       (_.coverage [/.line_feed]
                         (# /.equivalence = /.new_line /.line_feed))
                       )))
       (do [! random.monad]
         [size (# ! each (|>> (n.% 10) ++) random.nat)
          characters (random.set /.hash size (random.alphabetic 1))
          .let [sample (|> characters set.list /.together)]
          expected (# ! each (n.% size) random.nat)]
         (_.coverage [/.char]
           (case (/.char expected sample)
             {.#Some char}
             (case (/.index (/.of_char char) sample)
               {.#Some actual}
               (n.= expected actual)

               _
               false)
             
             {.#None}
             false)))
       (_.coverage [/.space /.space?]
         (`` (and (~~ (template [<char>]
                        [(/.space? (`` (.char (~~ (static <char>)))))]
                        
                        [/.tab]
                        [/.vertical_tab]
                        [/.space]
                        [/.new_line]
                        [/.carriage_return]
                        [/.form_feed]
                        )))))
       ))

(def: manipulation
  Test
  (do [! random.monad]
    [size (# ! each (|>> (n.% 10) (n.+ 2)) random.nat)
     characters (random.set /.hash size (random.alphabetic 1))
     separator (random.only (|>> (set.member? characters) not)
                            (random.alphabetic 1))
     .let [with_no_separator (|> characters set.list /.together)]
     static (random.alphabetic 1)
     .let [dynamic (random.only (|>> (# /.equivalence = static) not)
                                (random.alphabetic 1))]
     pre dynamic
     post dynamic

     lower (random.lower_case 1)
     upper (random.upper_case 1)]
    (all _.and
         (_.coverage [/.together]
           (n.= (set.size characters)
                (/.size (/.together (set.list characters)))))
         (_.coverage [/.interposed /.all_split_by]
           (and (|> (set.list characters)
                    (/.interposed separator)
                    (/.all_split_by separator)
                    (set.of_list /.hash)
                    (# set.equivalence = characters))
                (# /.equivalence =
                   (/.together (set.list characters))
                   (/.interposed "" (set.list characters)))))
         (_.coverage [/.replaced_once]
           (# /.equivalence =
              (# /.monoid composite post static)
              (/.replaced_once pre post (# /.monoid composite pre static))))
         (_.coverage [/.split_by]
           (case (/.split_by static (all (# /.monoid composite) pre static post))
             {.#Some [left right]}
             (and (# /.equivalence = pre left)
                  (# /.equivalence = post right))
             
             {.#None}
             false))
         (_.coverage [/.lower_cased]
           (let [effectiveness!
                 (|> upper
                     /.lower_cased
                     (# /.equivalence = upper)
                     not)

                 idempotence!
                 (|> lower
                     /.lower_cased
                     (# /.equivalence = lower))
                 
                 inverse!
                 (|> lower
                     /.upper_cased
                     /.lower_cased
                     (# /.equivalence = lower))]
             (and effectiveness!
                  idempotence!
                  inverse!)))
         (_.coverage [/.upper_cased]
           (let [effectiveness!
                 (|> lower
                     /.upper_cased
                     (# /.equivalence = lower)
                     not)

                 idempotence!
                 (|> upper
                     /.upper_cased
                     (# /.equivalence = upper))
                 
                 inverse!
                 (|> upper
                     /.lower_cased
                     /.upper_cased
                     (# /.equivalence = upper))]
             (and effectiveness!
                  idempotence!
                  inverse!)))
         )))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [.Text])
      (all _.and
           (_.for [/.equivalence]
                  ($equivalence.spec /.equivalence (random.ascii 2)))
           (_.for [/.hash]
                  ($hash.spec /.hash (random.ascii 1)))
           (_.for [/.order]
                  ($order.spec /.order (random.ascii 2)))
           (_.for [/.monoid]
                  ($monoid.spec /.equivalence /.monoid (random.ascii 2)))

           ..size
           ..affix
           ..index
           ..char
           ..manipulation
           
           (do random.monad
             [sizeL bounded_size
              sizeR bounded_size
              sampleL (random.unicode sizeL)
              sampleR (random.unicode sizeR)
              middle (random.unicode 1)
              .let [sample (/.together (list sampleL sampleR))
                    (open "/#[0]") /.equivalence]]
             (all _.and
                  (_.coverage [/.split_at]
                    (|> (/.split_at sizeL sample)
                        (pipe.case
                          {.#Right [_l _r]}
                          (and (/#= sampleL _l)
                               (/#= sampleR _r)
                               (/#= sample (/.together (list _l _r))))

                          _
                          #0)))
                  (_.coverage [/.clip /.clip_since]
                    (|> [(/.clip 0 sizeL sample)
                         (/.clip sizeL (n.- sizeL (/.size sample)) sample)
                         (/.clip_since sizeL sample)
                         (/.clip_since 0 sample)]
                        (pipe.case
                          [{.#Right _l} {.#Right _r} {.#Right _r'} {.#Right _f}]
                          (and (/#= sampleL _l)
                               (/#= sampleR _r)
                               (/#= _r _r')
                               (/#= sample _f))

                          _
                          #0)))
                  ))
           (do [! random.monad]
             [sizeP bounded_size
              sizeL bounded_size
              .let [... The wider unicode charset includes control characters that
                    ... can make text replacement work improperly.
                    ... Because of that, I restrict the charset.
                    normal_char_gen (|> random.nat (# ! each (|>> (n.% 128) (n.max 1))))]
              sep1 (random.text normal_char_gen 1)
              sep2 (random.text normal_char_gen 1)
              .let [part_gen (|> (random.text normal_char_gen sizeP)
                                 (random.only (|>> (/.contains? sep1) not)))]
              parts (random.list sizeL part_gen)
              .let [sample1 (/.together (list.interposed sep1 parts))
                    sample2 (/.together (list.interposed sep2 parts))
                    (open "/#[0]") /.equivalence]]
             (_.coverage [/.replaced]
               (/#= sample2
                    (/.replaced sep1 sep2 sample1))))

           /buffer.test
           /encoding.test
           /format.test
           /regex.test
           /escape.test
           /unicode.test
           )))
