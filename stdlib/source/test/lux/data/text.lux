... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except char)
   [abstract
    [monad (.only do)]
    ["[0]" equivalence (.only Equivalence)
     ["[1]T" \\test]]
    ["[0]" hash
     ["[1]T" \\test]]
    ["[0]" order
     ["[1]T" \\test]]
    ["[0]" monoid
     ["[1]T" \\test]]
    [functor
     ["[0]" contravariant
      ["[1]T" \\test]]]]
   [control
    ["<>" projection]
    ["[0]" pipe]
    ["[0]" maybe]
    ["[0]" try (.only Try)]
    ["[0]" exception (.only Exception)]
    ["[0]" function]]
   [data
    ["[0]" bit]
    [collection
     ["[0]" set]
     ["[0]" list (.use "[1]#[0]" functor)]
     [tree
      ["[0]" finger]]]
    [format
     ["[0]" xml]
     ["[0]" json]]
    [text
     ["[0]" unicode
      ["[1]" set]
      ["[1]/[0]" block]]]]
   [math
    ["[0]" random (.only Random) (.use "[1]#[0]" monad)]
    ["[0]" modulus]
    [number
     ["[0]" nat]
     ["[0]" int]
     ["[0]" rev]
     ["[0]" dec]
     ["[0]" frac]]
    [arithmetic
     ["[0]" modular]]]
   [meta
    ["[0]" location]
    ["[0]" symbol]
    ["[0]" type]
    ["[0]" code (.only)
     ["<[1]>" \\projection]]
    [macro
     ["^" pattern]
     ["[0]" template]]]
   [world
    ["[0]" time (.only)
     ["[0]" day]
     ["[0]" month]
     ["[0]" instant]
     ["[0]" duration]
     ["[0]" date]]]
   [test
    ["_" property (.only Test)]]]]
 ["$[0]" //
  [format
   ["[1][0]" xml]
   ["[1][0]" json]]
  [//
   [meta
    ["[1][0]" code]
    ["[1][0]" symbol]
    ["[1][0]" type]]]]
 ["[0]" /
  ["[1][0]" char (.only)
   [\\library (.only Char)]]
  ["[1][0]" buffer]
  ["[1][0]" encoding]
  ["[1][0]" regex]
  ["[1][0]" escape]
  ["[1][0]" unicode
   ["[1]" set]]]
 [\\library
  ["[0]" / (.use "[1]#[0]" equivalence)]]
 ["[0]" \\projection]
 ["[0]" \\injection])

(the (equivalence example)
  (for_any (_ of)
    (-> of
        (Equivalence (\\injection.Injection of))))
  (implementation
   (the (= expected actual)
     (/#= (expected example) (actual example)))))

(the random_contravariant
  (Random (for_some (_ of)
            [(\\injection.Injection of)
             (Random of)]))
  (all random.either
       (random#in [\\injection.bit random.bit])
       (random#in [\\injection.nat random.nat])
       (random#in [\\injection.int random.int])
       (random#in [\\injection.rev random.rev])
       (random#in [\\injection.dec random.dec])
       ))

(the format
  Test
  (`` (all _.and
           (,, (template.with [<injection> <format> <random>]
                 [(do random.monad
                    [sample <random>]
                    (_.coverage [<injection>]
                      (/#= (of <format> injection sample)
                           (<injection> sample))))]

                 [\\injection.bit bit.format random.bit]
                 [\\injection.nat nat.decimal random.nat]
                 [\\injection.int int.decimal random.int]
                 [\\injection.rev rev.decimal random.rev]
                 [\\injection.dec dec.decimal random.dec]
                 [\\injection.frac frac.format random.frac]
                 [\\injection.symbol symbol.absolute ($//symbol.random 5 5)]
                 [\\injection.xml xml.format $//xml.random]
                 [\\injection.json json.format $//json.random]
                 [\\injection.day day.format random.day]
                 [\\injection.month month.format random.month]
                 [\\injection.instant instant.format random.instant]
                 [\\injection.duration duration.format random.duration]
                 [\\injection.date date.format random.date]
                 [\\injection.time time.format random.time]
                 
                 [\\injection.int_2 int.binary random.int]
                 [\\injection.int_8 int.octal random.int]
                 [\\injection.int_10 int.decimal random.int]
                 [\\injection.int_16 int.hex random.int]
                 
                 [\\injection.rev_2 rev.binary random.rev]
                 [\\injection.rev_8 rev.octal random.rev]
                 [\\injection.rev_10 rev.decimal random.rev]
                 [\\injection.rev_16 rev.hex random.rev]
                 
                 [\\injection.dec_2 dec.binary random.dec]
                 [\\injection.dec_8 dec.octal random.dec]
                 [\\injection.dec_10 dec.decimal random.dec]
                 [\\injection.dec_16 dec.hex random.dec]
                 ))
           (,, (template.with [<injection> <format> <random>]
                 [(do [! random.monad]
                    [sample <random>
                     .let [limit (|> (of nat.interval top)
                                     <injection>
                                     /.size
                                     ++)]
                     expected_size (of ! each (nat.% limit) random.nat)]
                    (_.coverage [<injection> \\injection.padded]
                      (/#= (of (nat.padded expected_size <format>) injection sample)
                           (\\injection.padded expected_size <injection> sample))))]

                 [\\injection.nat_2 nat.binary random.nat]
                 [\\injection.nat_8 nat.octal random.nat]
                 [\\injection.nat_10 nat.decimal random.nat]
                 [\\injection.nat_16 nat.hex random.nat]
                 ))
           (,, (template.with [<injection> <type>]
                 [(do [! random.monad]
                    [it (of ! each (|>> <type>
                                        dec.int
                                        int.dec
                                        (dec./ (<type> +1.0)))
                            random.safe_dec)]
                    (_.coverage [<injection>]
                      (/.contains? (\\injection.int (dec.int (<type> it)))
                                   (<injection> it))))]

                 [\\injection.degree dec.as_degree]
                 [\\injection.percentage dec.as_percentage]
                 [\\injection.permille dec.as_permille]
                 [\\injection.permyriad dec.as_permyriad]
                 ))
           )))

(the \\injection
  Test
  (<| (_.covering \\injection._)
      (_.for [\\injection.Injection])
      (`` (all _.and
               (_.for [\\injection.functor]
                      (do random.monad
                        [[injection random] ..random_contravariant
                         example random]
                        (contravariantT.spec (..equivalence example)
                                             injection
                                             \\injection.functor)))
               
               (do random.monad
                 [left (random.unicode 5)
                  mid (random.unicode 5)
                  right (random.unicode 5)]
                 (_.coverage [\\injection.message]
                   (/#= (\\injection.message left mid right)
                        (.text_composite# left mid right))))
               ..format
               (,, (template.with [<injection> <alias> <random>]
                     [(do random.monad
                        [sample <random>]
                        (_.coverage [<injection>]
                          (/#= (<alias> sample)
                               (<injection> sample))))]

                     [\\injection.text /.injection (random.unicode 5)]
                     [\\injection.code code.absolute $//code.random]
                     [\\injection.type type.absolute_injection ($//type.random 0)]
                     [\\injection.location location.injection
                      (all random.and
                           (random.unicode 5)
                           random.nat
                           random.nat)]
                     ))
               (do random.monad
                 [members (random.list 5 random.nat)]
                 (_.coverage [\\injection.list]
                   (/#= (\\injection.list \\injection.nat members)
                        (|> members
                            (list#each \\injection.nat)
                            (/.interposed " ")
                            list
                            (\\injection.list (|>>))))))
               (do random.monad
                 [sample (random.maybe random.nat)]
                 (_.coverage [\\injection.maybe]
                   (when sample
                     {.#None}
                     true
                     
                     {.#Some value}
                     (/.contains? (\\injection.nat value)
                                  (\\injection.maybe \\injection.nat sample)))))
               (do [! random.monad]
                 [modulus (random.one (|>> modulus.modulus
                                           try.maybe)
                                      random.int)
                  sample (of ! each (modular.modular modulus)
                             random.int)]
                 (_.coverage [\\injection.mod]
                   (/#= (of (modular.format modulus) injection sample)
                        (\\injection.mod sample))))
               ))))

(the !expect
  (template.macro (_ <pattern> <value>)
    [(when <value>
       <pattern>
       true
       
       _
       false)]))

(the (should_fail' sample projection exception)
  (for_any (_ a e) (-> Text (\\projection.Projection a) (Exception e) Bit))
  (when (\\projection.value projection sample)
    {try.#Failure error}
    (exception.is? exception error)
    
    _
    false))

(the (should_fail sample projection)
  (for_any (_ a)
    (-> Text (\\projection.Projection a)
        Bit))
  (when (\\projection.value projection sample)
    {try.#Failure _}
    true
    
    _
    false))

(the (should_pass expected projection)
  (-> Text (\\projection.Projection Text) Bit)
  (|> expected
      (\\projection.value projection)
      (of try.functor each (/#= expected))
      (try.else false)))

(the (should_pass! expected projection)
  (-> Text (\\projection.Projection \\projection.Slice) Bit)
  (..should_pass expected (\\projection.slice projection)))

(the \\projection#character_classes
  Test
  (all _.and
       (do [! random.monad]
         [offset (of ! each (nat.% 50) random.nat)
          range (of ! each (|>> (nat.% 50) (nat.+ 10)) random.nat)
          .let [limit (nat.+ offset range)]
          expected (of ! each (|>> (nat.% range) (nat.+ offset) /.of_char) random.nat)
          out_of_range (when offset
                         0 (of ! each (|>> (nat.% 10) ++ (nat.+ limit) /.of_char) random.nat)
                         _ (of ! each (|>> (nat.% offset) /.of_char) random.nat))]
         (_.coverage [\\projection.range]
           (and (..should_pass expected (\\projection.range offset limit))
                (..should_fail out_of_range (\\projection.range offset limit)))))
       (do [! random.monad]
         [expected (random.char unicode.upper_case)
          invalid (random.only (|>> (unicode/block.within? unicode/block.upper_case) not)
                               (random.char unicode.character))]
         (_.coverage [\\projection.upper]
           (and (..should_pass (/.of_char expected) \\projection.upper)
                (..should_fail (/.of_char invalid) \\projection.upper))))
       (do [! random.monad]
         [expected (random.char unicode.lower_case)
          invalid (random.only (|>> (unicode/block.within? unicode/block.lower_case) not)
                               (random.char unicode.character))]
         (_.coverage [\\projection.lower]
           (and (..should_pass (/.of_char expected) \\projection.lower)
                (..should_fail (/.of_char invalid) \\projection.lower))))
       (do [! random.monad]
         [expected (of ! each (nat.% 10) random.nat)
          invalid (random.char (unicode.set [unicode/block.number_forms (list)]))]
         (_.coverage [\\projection.decimal]
           (and (..should_pass (of nat.decimal injection expected) \\projection.decimal)
                (..should_fail (/.of_char invalid) \\projection.decimal))))
       (do [! random.monad]
         [expected (of ! each (nat.% 8) random.nat)
          invalid (random.char (unicode.set [unicode/block.number_forms (list)]))]
         (_.coverage [\\projection.octal]
           (and (..should_pass (of nat.octal injection expected) \\projection.octal)
                (..should_fail (/.of_char invalid) \\projection.octal))))
       (do [! random.monad]
         [expected (of ! each (nat.% 16) random.nat)
          invalid (random.char (unicode.set [unicode/block.number_forms (list)]))]
         (_.coverage [\\projection.hexadecimal]
           (and (..should_pass (of nat.hex injection expected) \\projection.hexadecimal)
                (..should_fail (/.of_char invalid) \\projection.hexadecimal))))
       (do [! random.monad]
         [expected (random.char unicode.alphabetic)
          invalid (random.only (function (_ char)
                                 (not (or (unicode/block.within? unicode/block.upper_case char)
                                          (unicode/block.within? unicode/block.lower_case char))))
                               (random.char unicode.character))]
         (_.coverage [\\projection.alpha]
           (and (..should_pass (/.of_char expected) \\projection.alpha)
                (..should_fail (/.of_char invalid) \\projection.alpha))))
       (do [! random.monad]
         [expected (random.char unicode.alpha_numeric)
          invalid (random.only (function (_ char)
                                 (not (or (unicode/block.within? unicode/block.upper_case char)
                                          (unicode/block.within? unicode/block.lower_case char)
                                          (unicode/block.within? unicode/block.numeric char))))
                               (random.char unicode.character))]
         (_.coverage [\\projection.alpha_num]
           (and (..should_pass (/.of_char expected) \\projection.alpha_num)
                (..should_fail (/.of_char invalid) \\projection.alpha_num))))
       (do [! random.monad]
         [expected (all random.either
                        (in /.tab)
                        (in /.vertical_tab)
                        (in /.space)
                        (in /.new_line)
                        (in /.carriage_return)
                        (in /.form_feed))
          invalid (|> (random.unicode 1) (random.only (function (_ char)
                                                        (not (or (/#= /.tab char)
                                                                 (/#= /.vertical_tab char)
                                                                 (/#= /.space char)
                                                                 (/#= /.new_line char)
                                                                 (/#= /.carriage_return char)
                                                                 (/#= /.form_feed char))))))]
         (_.coverage [\\projection.space]
           (and (..should_pass expected \\projection.space)
                (..should_fail invalid \\projection.space))))
       (do [! random.monad]
         [.let [num_options 3]
          options (|> (random.char unicode.character)
                      (random.set nat.hash num_options)
                      (of ! each (|>> set.list
                                      (list#each /.of_char)
                                      /.together)))
          expected (of ! each (function (_ value)
                                (|> options
                                    (/.char (nat.% num_options value))
                                    maybe.trusted))
                       random.nat)
          invalid (random.only (function (_ char)
                                 (not (/.contains? (/.of_char char) options)))
                               (random.char unicode.character))]
         (_.coverage [\\projection.one_of \\projection.one_of! \\projection.character_should_be]
           (and (..should_pass (/.of_char expected) (\\projection.one_of options))
                (..should_fail (/.of_char invalid) (\\projection.one_of options))
                (..should_fail' (/.of_char invalid) (\\projection.one_of options)
                                \\projection.character_should_be)

                (..should_pass! (/.of_char expected) (\\projection.one_of! options))
                (..should_fail (/.of_char invalid) (\\projection.one_of! options))
                (..should_fail' (/.of_char invalid) (\\projection.one_of! options)
                                \\projection.character_should_be)
                )))
       (do [! random.monad]
         [.let [num_options 3]
          options (|> (random.char unicode.character)
                      (random.set nat.hash num_options)
                      (of ! each (|>> set.list
                                      (list#each /.of_char)
                                      /.together)))
          invalid (of ! each (function (_ value)
                               (|> options
                                   (/.char (nat.% num_options value))
                                   maybe.trusted))
                      random.nat)
          expected (random.only (function (_ char)
                                  (not (/.contains? (/.of_char char) options)))
                                (random.char unicode.character))]
         (_.coverage [\\projection.none_of \\projection.none_of! \\projection.character_should_not_be]
           (and (..should_pass (/.of_char expected) (\\projection.none_of options))
                (..should_fail (/.of_char invalid) (\\projection.none_of options))
                (..should_fail' (/.of_char invalid) (\\projection.none_of options)
                                \\projection.character_should_not_be)

                (..should_pass! (/.of_char expected) (\\projection.none_of! options))
                (..should_fail (/.of_char invalid) (\\projection.none_of! options))
                (..should_fail' (/.of_char invalid) (\\projection.none_of! options)
                                \\projection.character_should_not_be)
                )))
       ))

(the \\projection#runs
  Test
  (let [octal! (\\projection.one_of! "01234567")]
    (all _.and
         (do [! random.monad]
           [left (of ! each (|>> (nat.% 8) (of nat.octal injection)) random.nat)
            right (of ! each (|>> (nat.% 8) (of nat.octal injection)) random.nat)
            .let [expected (\\injection.message left right)]
            invalid (|> random.nat
                        (of ! each (nat.% 16))
                        (random.only (nat.>= 8))
                        (of ! each (of nat.hex injection)))]
           (_.coverage [\\projection.many \\projection.many!]
             (and (..should_pass expected (\\projection.many \\projection.octal))
                  (..should_fail invalid (\\projection.many \\projection.octal))

                  (..should_pass! expected (\\projection.many! octal!)))))
         (do [! random.monad]
           [left (of ! each (|>> (nat.% 8) (of nat.octal injection)) random.nat)
            right (of ! each (|>> (nat.% 8) (of nat.octal injection)) random.nat)
            .let [expected (\\injection.message left right)]
            invalid (|> random.nat
                        (of ! each (nat.% 16))
                        (random.only (nat.>= 8))
                        (of ! each (of nat.hex injection)))]
           (_.coverage [\\projection.some \\projection.some!]
             (and (..should_pass expected (\\projection.some \\projection.octal))
                  (..should_pass "" (\\projection.some \\projection.octal))
                  (..should_fail invalid (\\projection.some \\projection.octal))

                  (..should_pass! expected (\\projection.some! octal!))
                  (..should_pass! "" (\\projection.some! octal!)))))
         (do [! random.monad]
           [.let [octal (of ! each (|>> (nat.% 8) (of nat.octal injection)) random.nat)]
            first octal
            second octal
            third octal]
           (_.coverage [\\projection.exactly \\projection.exactly!]
             (and (..should_pass (\\injection.message first second) (\\projection.exactly 2 \\projection.octal))
                  (..should_fail (\\injection.message first second third) (\\projection.exactly 2 \\projection.octal))
                  (..should_fail (\\injection.message first) (\\projection.exactly 2 \\projection.octal))

                  (..should_pass! (\\injection.message first second) (\\projection.exactly! 2 octal!))
                  (..should_fail (\\injection.message first second third) (\\projection.exactly! 2 octal!))
                  (..should_fail (\\injection.message first) (\\projection.exactly! 2 octal!)))))
         (do [! random.monad]
           [.let [octal (of ! each (|>> (nat.% 8) (of nat.octal injection)) random.nat)]
            first octal
            second octal
            third octal]
           (_.coverage [\\projection.at_most \\projection.at_most!]
             (and (..should_pass (\\injection.message first second) (\\projection.at_most 2 \\projection.octal))
                  (..should_pass (\\injection.message first) (\\projection.at_most 2 \\projection.octal))
                  (..should_fail (\\injection.message first second third) (\\projection.at_most 2 \\projection.octal))

                  (..should_pass! (\\injection.message first second) (\\projection.at_most! 2 octal!))
                  (..should_pass! (\\injection.message first) (\\projection.at_most! 2 octal!))
                  (..should_fail (\\injection.message first second third) (\\projection.at_most! 2 octal!)))))
         (do [! random.monad]
           [.let [octal (of ! each (|>> (nat.% 8) (of nat.octal injection)) random.nat)]
            first octal
            second octal
            third octal]
           (_.coverage [\\projection.at_least \\projection.at_least!]
             (and (..should_pass (\\injection.message first second) (\\projection.at_least 2 \\projection.octal))
                  (..should_pass (\\injection.message first second third) (\\projection.at_least 2 \\projection.octal))
                  (..should_fail (\\injection.message first) (\\projection.at_least 2 \\projection.octal))

                  (..should_pass! (\\injection.message first second) (\\projection.at_least! 2 octal!))
                  (..should_pass! (\\injection.message first second third) (\\projection.at_least! 2 octal!))
                  (..should_fail (\\injection.message first) (\\projection.at_least! 2 octal!)))))
         (do [! random.monad]
           [.let [octal (of ! each (|>> (nat.% 8) (of nat.octal injection)) random.nat)]
            first octal
            second octal
            third octal]
           (_.coverage [\\projection.between \\projection.between!]
             (and (..should_pass (\\injection.message first second) (\\projection.between 2 1 \\projection.octal))
                  (..should_pass (\\injection.message first second third) (\\projection.between 2 1 \\projection.octal))
                  (..should_fail (\\injection.message first) (\\projection.between 2 1 \\projection.octal))

                  (..should_pass! (\\injection.message first second) (\\projection.between! 2 1 octal!))
                  (..should_pass! (\\injection.message first second third) (\\projection.between! 2 1 octal!))
                  (..should_fail (\\injection.message first) (\\projection.between! 2 1 octal!)))))
         )))

(the \\projection
  Test
  (<| (_.covering \\projection._)
      (_.for [\\projection.Projection])
      (all _.and
           (do [! random.monad]
             [sample (random.unicode 1)]
             (_.coverage [\\projection.value \\projection.end]
               (and (|> (\\projection.value \\projection.end
                                            "")
                        (!expect {try.#Success _}))
                    (|> (\\projection.value \\projection.end
                                            sample)
                        (!expect {try.#Failure _})))))
           (do [! random.monad]
             [.let [size 10]
              expected (random.unicode size)
              dummy (|> (random.unicode size)
                        (random.only (|>> (/#= expected) not)))]
             (_.coverage [\\projection.this \\projection.cannot_match]
               (and (|> (\\projection.value (\\projection.this expected)
                                            expected)
                        (!expect {try.#Success []}))
                    (|> (\\projection.value (\\projection.this expected)
                                            dummy)
                        (!expect (^.multi {try.#Failure error}
                                          (exception.is? \\projection.cannot_match error)))))))
           (_.coverage [\\projection.Slice \\projection.slice \\projection.cannot_slice]
             (|> ""
                 (\\projection.value (\\projection.slice \\projection.any!))
                 (!expect (^.multi {try.#Failure error}
                                   (exception.is? \\projection.cannot_slice error)))))
           (do [! random.monad]
             [expected (random.unicode 1)]
             (_.coverage [\\projection.any \\projection.any!]
               (and (..should_pass expected \\projection.any)
                    (..should_fail "" \\projection.any)

                    (..should_pass! expected \\projection.any!)
                    (..should_fail "" \\projection.any!))))
           (do [! random.monad]
             [expected (random.unicode 1)]
             (_.coverage [\\projection.next \\projection.cannot_parse]
               (and (..should_pass expected (<>.before \\projection.any \\projection.next))
                    (|> ""
                        (\\projection.value (<>.before \\projection.any \\projection.next))
                        (!expect (^.multi {try.#Failure error}
                                          (exception.is? \\projection.cannot_parse error)))))))
           (do [! random.monad]
             [dummy (random.unicode 1)]
             (_.coverage [\\projection.unconsumed_input]
               (|> (\\injection.message dummy dummy)
                   (\\projection.value \\projection.any)
                   (!expect (^.multi {try.#Failure error}
                                     (exception.is? \\projection.unconsumed_input error))))))
           (do [! random.monad]
             [sample (random.unicode 1)]
             (_.coverage [\\projection.Offset \\projection.offset]
               (|> sample
                   (\\projection.value (do <>.monad
                                         [pre \\projection.offset
                                          _ \\projection.any
                                          post \\projection.offset]
                                         (in [pre post])))
                   (!expect {try.#Success [0 1]}))))
           (do [! random.monad]
             [left (random.unicode 1)
              right (random.unicode 1)
              .let [input (\\injection.message left right)]]
             (_.coverage [\\projection.remaining]
               (|> input
                   (\\projection.value (do <>.monad
                                         [pre \\projection.remaining
                                          _ \\projection.any
                                          post \\projection.remaining
                                          _ \\projection.any]
                                         (in (and (/#= input pre)
                                                  (/#= right post)))))
                   (!expect {try.#Success .true}))))
           (do [! random.monad]
             [left (random.unicode 1)
              right (random.unicode 1)
              expected (random.only (|>> (/#= right) not)
                                    (random.unicode 1))]
             (_.coverage [\\projection.enclosed]
               (|> (\\injection.message left expected right)
                   (\\projection.value (\\projection.enclosed [left right] (\\projection.this expected)))
                   (!expect {try.#Success _}))))
           (do [! random.monad]
             [input (random.unicode 1)
              output (random.unicode 1)]
             (_.coverage [\\projection.local]
               (|> output
                   (\\projection.value (do <>.monad
                                         [_ (\\projection.local input (\\projection.this input))]
                                         (\\projection.this output)))
                   (!expect {try.#Success _}))))
           (do [! random.monad]
             [expected (of ! each (|>> (nat.% 8) (of nat.octal injection)) random.nat)]
             (_.coverage [\\projection.then]
               (|> (list (code.text expected))
                   (<code>.value (\\projection.then \\projection.octal <code>.text))
                   (!expect (^.multi {try.#Success actual}
                                     (/#= expected actual))))))
           (do [! random.monad]
             [invalid (random.upper_cased 1)
              expected (random.only (|>> (unicode/block.within? unicode/block.upper_case)
                                         not)
                                    (random.char unicode.character))
              .let [upper! (\\projection.one_of! "ABCDEFGHIJKLMNOPQRSTUVWXYZ")]]
             (_.coverage [\\projection.not \\projection.not! \\projection.expected_to_fail]
               (and (..should_pass (/.of_char expected) (\\projection.not \\projection.upper))
                    (|> invalid
                        (\\projection.value (\\projection.not \\projection.upper))
                        (!expect (^.multi {try.#Failure error}
                                          (exception.is? \\projection.expected_to_fail error))))

                    (..should_pass! (/.of_char expected) (\\projection.not! upper!))
                    (|> invalid
                        (\\projection.value (\\projection.not! upper!))
                        (!expect (^.multi {try.#Failure error}
                                          (exception.is? \\projection.expected_to_fail error)))))))
           (do [! random.monad]
             [upper (random.upper_cased 1)
              lower (random.lower_cased 1)
              invalid (random.only (function (_ char)
                                     (not (or (unicode/block.within? unicode/block.upper_case char)
                                              (unicode/block.within? unicode/block.lower_case char))))
                                   (random.char unicode.character))
              .let [upper! (\\projection.one_of! "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
                    lower! (\\projection.one_of! "abcdefghijklmnopqrstuvwxyz")]]
             (_.coverage [\\projection.and \\projection.and!]
               (and (..should_pass (\\injection.message upper lower) (\\projection.and \\projection.upper \\projection.lower))
                    (..should_fail (\\injection.message (/.of_char invalid) lower) (\\projection.and \\projection.upper \\projection.lower))
                    (..should_fail (\\injection.message upper (/.of_char invalid)) (\\projection.and \\projection.upper \\projection.lower))

                    (..should_pass! (\\injection.message upper lower) (\\projection.and! upper! lower!))
                    (..should_fail (\\injection.message (/.of_char invalid) lower) (\\projection.and! upper! lower!))
                    (..should_fail (\\injection.message upper (/.of_char invalid)) (\\projection.and! upper! lower!)))))
           (do [! random.monad]
             [expected (random.unicode 1)
              invalid (random.unicode 1)]
             (_.coverage [\\projection.satisfies \\projection.character_does_not_satisfy_predicate]
               (and (..should_pass expected (\\projection.satisfies (function.constant true)))
                    (..should_fail' invalid (\\projection.satisfies (function.constant false))
                                    \\projection.character_does_not_satisfy_predicate))))

           \\projection#character_classes
           \\projection#runs
           )))

(the bounded_size
  (random.Random Nat)
  (|> random.nat
      (of random.monad each (|>> (nat.% 20) (nat.+ 1)))))

(the size
  Test
  (do [! random.monad]
    [size (of ! each (nat.% 10) random.nat)
     sample (random.unicode size)]
    (all _.and
         (_.coverage [/.size]
           (nat.= size (/.size sample)))
         (_.coverage [/.empty?]
           (or (/.empty? sample)
               (not (nat.= 0 size)))))))

(the affix
  Test
  (do [! random.monad]
    [inner (random.unicode 1)
     outer (random.only (|>> (of /.equivalence = inner) not)
                        (random.unicode 1))
     left (random.unicode 1)
     right (random.unicode 1)
     .let [full (of /.monoid composite inner outer)
           fake_index (-- 0)]]
    (`` (all _.and
             (,, (template.with [<affix> <predicate>]
                   [(_.coverage [<affix> <predicate>]
                      (<predicate> outer (<affix> outer inner)))]

                   [/.prefix /.starts_with?]
                   [/.suffix /.ends_with?]
                   [/.enclosed' /.enclosed_by?]
                   ))
             (_.coverage [/.enclosed]
               (let [value (/.enclosed [left right] inner)]
                 (and (/.starts_with? left value)
                      (/.ends_with? right value))))
             (_.coverage [/.injection]
               (let [sample (/.injection inner)]
                 (and (/.enclosed_by? /.double_quote sample)
                      (/.contains? inner sample))))
             ))))

(the index
  Test
  (do [! random.monad]
    [inner (random.unicode 1)
     outer (random.only (|>> (of /.equivalence = inner) not)
                        (random.unicode 1))
     .let [fake_index (-- 0)]]
    (all _.and
         (_.coverage [/.contains?]
           (let [full (of /.monoid composite inner outer)]
             (and (/.contains? inner full)
                  (/.contains? outer full))))
         (_.coverage [/.index]
           (and (|> (/.index inner (of /.monoid composite inner outer))
                    (maybe.else fake_index)
                    (nat.= 0))
                (|> (/.index outer (of /.monoid composite inner outer))
                    (maybe.else fake_index)
                    (nat.= 1))))
         (_.coverage [/.index_since]
           (let [full (of /.monoid composite inner outer)]
             (and (|> (/.index_since 0 inner full)
                      (maybe.else fake_index)
                      (nat.= 0))
                  (|> (/.index_since 1 inner full)
                      (maybe.else fake_index)
                      (nat.= fake_index))
                  
                  (|> (/.index_since 0 outer full)
                      (maybe.else fake_index)
                      (nat.= 1))
                  (|> (/.index_since 1 outer full)
                      (maybe.else fake_index)
                      (nat.= 1))
                  (|> (/.index_since 2 outer full)
                      (maybe.else fake_index)
                      (nat.= fake_index)))))
         (_.coverage [/.last_index]
           (let [full (all (of /.monoid composite) outer inner outer)]
             (and (|> (/.last_index inner full)
                      (maybe.else fake_index)
                      (nat.= 1))
                  (|> (/.last_index outer full)
                      (maybe.else fake_index)
                      (nat.= 2)))))
         )))

(the char
  Test
  (all _.and
       (_.for [/.of_char]
              (`` (all _.and
                       (,, (template.with [<short> <long>]
                             [(_.coverage [<short> <long>]
                                (of /.equivalence = <short> <long>))]

                             [/.\0  /.null]
                             [/.\a  /.alarm]
                             [/.\b  /.back_space]
                             [/.\t  /.tab]
                             [/.\n  /.new_line]
                             [/.\v  /.vertical_tab]
                             [/.\f  /.form_feed]
                             [/.\r  /.carriage_return]
                             [/.\'' /.double_quote]))
                       (_.coverage [/.line_feed]
                         (of /.equivalence = /.new_line /.line_feed))
                       )))
       (do [! random.monad]
         [size (of ! each (|>> (nat.% 10) ++) random.nat)
          characters (random.set /.hash size (random.alphabetic 1))
          .let [sample (|> characters set.list /.together)]
          expected (of ! each (nat.% size) random.nat)]
         (_.coverage [/.char]
           (when (/.char expected sample)
             {.#Some char}
             (when (/.index (/.of_char char) sample)
               {.#Some actual}
               (nat.= expected actual)

               _
               false)
             
             {.#None}
             false)))
       (_.coverage [/.space /.space?]
         (`` (and (,, (template.with [<char>]
                        [(/.space? (`` (.char (,, (static <char>)))))]
                        
                        [/.tab]
                        [/.vertical_tab]
                        [/.space]
                        [/.new_line]
                        [/.carriage_return]
                        [/.form_feed]
                        )))))
       ))

(the manipulation
  Test
  (do [! random.monad]
    [size (of ! each (|>> (nat.% 10) (nat.+ 2)) random.nat)
     characters (random.set /.hash size (random.alphabetic 1))
     separator (random.only (|>> (set.member? characters) not)
                            (random.alphabetic 1))
     .let [with_no_separator (|> characters set.list /.together)]
     static (random.alphabetic 1)
     .let [dynamic (random.only (|>> (of /.equivalence = static) not)
                                (random.alphabetic 1))]
     pre dynamic
     post dynamic

     lower (random.lower_cased 1)
     upper (random.upper_cased 1)]
    (all _.and
         (_.coverage [/.together]
           (nat.= (set.size characters)
                  (/.size (/.together (set.list characters)))))
         (_.coverage [/.interposed /.all_split_by]
           (and (|> (set.list characters)
                    (/.interposed separator)
                    (/.all_split_by separator)
                    (set.of_list /.hash)
                    (of set.equivalence = characters))
                (of /.equivalence =
                    (/.together (set.list characters))
                    (/.interposed "" (set.list characters)))))
         (_.coverage [/.replaced_once]
           (of /.equivalence =
               (of /.monoid composite post static)
               (/.replaced_once pre post (of /.monoid composite pre static))))
         (_.coverage [/.split_by]
           (when (/.split_by static (all (of /.monoid composite) pre static post))
             {.#Some [left right]}
             (and (of /.equivalence = pre left)
                  (of /.equivalence = post right))
             
             {.#None}
             false))
         (_.coverage [/.lower_cased]
           (let [effectiveness!
                 (|> upper
                     /.lower_cased
                     (of /.equivalence = upper)
                     not)

                 idempotence!
                 (|> lower
                     /.lower_cased
                     (of /.equivalence = lower))
                 
                 inverse!
                 (|> lower
                     /.upper_cased
                     /.lower_cased
                     (of /.equivalence = lower))]
             (and effectiveness!
                  idempotence!
                  inverse!)))
         (_.coverage [/.upper_cased]
           (let [effectiveness!
                 (|> lower
                     /.upper_cased
                     (of /.equivalence = lower)
                     not)

                 idempotence!
                 (|> upper
                     /.upper_cased
                     (of /.equivalence = upper))
                 
                 inverse!
                 (|> upper
                     /.lower_cased
                     /.upper_cased
                     (of /.equivalence = upper))]
             (and effectiveness!
                  idempotence!
                  inverse!)))
         )))

(the .public test
  Test
  (<| (_.covering /._)
      (_.for [.Text])
      (all _.and
           (_.for [/.equivalence]
                  (equivalenceT.spec /.equivalence (random.ascii 2)))
           (_.for [/.hash]
                  (hashT.spec /.hash (random.ascii 1)))
           (_.for [/.order]
                  (orderT.spec /.order (random.ascii 2)))
           (_.for [/.monoid]
                  (monoidT.spec /.equivalence /.monoid (random.ascii 2)))

           ..size
           ..affix
           ..index
           ..char
           ..manipulation
           
           (do random.monad
             [sizeL bounded_size
              sizeR bounded_size
              sampleL (random.unicode sizeL)
              sampleR (random.unicode sizeR)
              middle (random.unicode 1)
              .let [sample (/.together (list sampleL sampleR))
                    (open "/#[0]") /.equivalence]]
             (all _.and
                  (_.coverage [/.split_at]
                    (|> (/.split_at sizeL sample)
                        (pipe.when
                          {.#Right [_l _r]}
                          (and (/#= sampleL _l)
                               (/#= sampleR _r)
                               (/#= sample (/.together (list _l _r))))

                          _
                          false)))
                  (_.coverage [/.clip /.clip_since]
                    (|> [(/.clip 0 sizeL sample)
                         (/.clip sizeL (nat.- sizeL (/.size sample)) sample)
                         (/.clip_since sizeL sample)
                         (/.clip_since 0 sample)]
                        (pipe.when
                          [{.#Right _l} {.#Right _r} {.#Right _r'} {.#Right _f}]
                          (and (/#= sampleL _l)
                               (/#= sampleR _r)
                               (/#= _r _r')
                               (/#= sample _f))

                          _
                          false)))
                  ))
           (do [! random.monad]
             [sizeP bounded_size
              sizeL bounded_size
              .let [... The wider unicode charset includes control characters that
                    ... can make text replacement work improperly.
                    ... Because of that, I restrict the charset.
                    normal_char_gen (is (Random Char)
                                        (of ! each (|>> (nat.% 128) (nat.max 1)) random.nat))]
              sep1 (random.text normal_char_gen 1)
              sep2 (random.text normal_char_gen 1)
              .let [part_gen (|> (random.text normal_char_gen sizeP)
                                 (random.only (|>> (/.contains? sep1) not)))]
              parts (random.list sizeL part_gen)
              .let [sample1 (/.together (list.interposed sep1 parts))
                    sample2 (/.together (list.interposed sep2 parts))
                    (open "/#[0]") /.equivalence]]
             (_.coverage [/.replaced]
               (/#= sample2
                    (/.replaced sep1 sep2 sample1))))

           /char.test
           /buffer.test
           /encoding.test
           /regex.test
           /escape.test
           /unicode.test

           ..\\projection
           ..\\injection
           )))
