(.using
 [library
  [lux (.except)
   ["_" test (.only Test)]
   [abstract
    [monad (.only do)]
    [\\specification
     ["$[0]" equivalence]
     ["$[0]" hash]
     ["$[0]" monoid]
     ["$[0]" codec]]]
   [control
    ["[0]" function]]
   [math
    ["[0]" random]]]]
 [\\library
  ["[0]" /]])

(def .public test
  Test
  (<| (_.covering /._)
      (do random.monad
        [value random.bit]
        (all _.and
             (_.for [/.equivalence]
                    ($equivalence.spec /.equivalence random.bit))
             (_.for [/.hash]
                    ($hash.spec /.hash random.bit))
             (_.for [/.disjunction]
                    ($monoid.spec /.equivalence /.disjunction random.bit))
             (_.for [/.conjunction]
                    ($monoid.spec /.equivalence /.conjunction random.bit))
             (_.for [/.codec]
                    ($codec.spec /.equivalence /.codec random.bit))
             
             (_.coverage [/.no /.yes]
               (and (at /.equivalence = false /.no)
                    (at /.equivalence = true /.yes)))
             (_.coverage [/.off /.on]
               (and (at /.equivalence = false /.off)
                    (at /.equivalence = true /.on)))
             (_.coverage [/.complement]
               (and (not (at /.equivalence = value ((/.complement function.identity) value)))
                    (at /.equivalence = value ((/.complement not) value))))
             ))))
