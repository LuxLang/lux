(.module:
  [lux #*
   ["_" test (#+ Test)]
   [math
    ["." random]]
   [abstract
    [monad (#+ do)]
    [\spec
     ["$." equivalence]
     ["$." hash]
     ["$." monoid]
     ["$." codec]]]
   [control
    ["." function]]]
  [\\
   ["." /]])

(def: #export test
  Test
  (<| (_.covering /._)
      (do random.monad
        [value random.bit]
        ($_ _.and
            (_.for [/.equivalence]
                   ($equivalence.spec /.equivalence random.bit))
            (_.for [/.hash]
                   ($hash.spec /.hash random.bit))
            (_.for [/.disjunction]
                   ($monoid.spec /.equivalence /.disjunction random.bit))
            (_.for [/.conjunction]
                   ($monoid.spec /.equivalence /.conjunction random.bit))
            (_.for [/.codec]
                   ($codec.spec /.equivalence /.codec random.bit))
            
            (_.cover [/.complement]
                     (and (not (\ /.equivalence = value ((/.complement function.identity) value)))
                          (\ /.equivalence = value ((/.complement not) value))))
            ))))
