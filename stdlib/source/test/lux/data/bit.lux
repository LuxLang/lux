(.module:
  [lux #*
   ["_" test (#+ Test)]
   ["." function]
   [control
    [monad (#+ do)]
    {[0 #test]
     [/
      ["." equivalence]
      ["." codec]]}]
   data/text/format
   [math
    ["r" random]]]
  {1
   ["." /]})

(def: #export test
  Test
  (<| (_.context (%name (name-of .Bit)))
      (do r.monad
        [value r.bit]
        ($_ _.and
            (_.test "A value cannot be true and false at the same time."
                    (not (and value (not value))))
            (_.test "A value must be either true or false at any time."
                    (or value (not value)))
            (_.test "Can create the complement of a predicate."
                    (and (not (:: /.equivalence = value ((/.complement function.identity) value)))
                         (:: /.equivalence = value ((/.complement not) value))))
            (equivalence.test /.equivalence r.bit)
            (codec.test /.codec /.equivalence r.bit)
            (_.test "Or/disjunction monoid."
                    (and (not (:: /.or-monoid identity))
                         (:: /.or-monoid compose value (not value))))
            (_.test "And/conjunction monoid."
                    (and (:: /.and-monoid identity)
                         (not (:: /.and-monoid compose value (not value)))))
            ))))
