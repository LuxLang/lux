(.module:
  [library
   [lux {"-" char}
    ["_" test {"+" Test}]
    [abstract
     [monad {"+" Monad do}]
     [\\specification
      ["$[0]" equivalence]
      ["$[0]" codec]]]
    [control
     pipe
     ["[0]" maybe]
     ["[0]" try]
     ["p" parser
      ["</>" xml]]]
    [data
     ["[0]" text ("[1]#[0]" equivalence)
      ["%" format {"+" format}]]
     [collection
      ["[0]" dictionary]
      ["[0]" list ("[1]#[0]" functor)]]]
    [math
     ["[0]" random {"+" Random} ("[1]#[0]" monad)]
     [number
      ["n" nat]]]
    [meta
     ["[0]" symbol]]]]
  [\\library
   ["[0]" / {"+" XML}]])

(def: char_range
  Text
  (format "_"
          "abcdefghijklmnopqrstuvwxyz"
          "ABCDEFGHIJKLMNOPQRSTUVWXYZ"))

(def: char
  (Random Nat)
  (do [! random.monad]
    [idx (|> random.nat (# ! each (n.% (text.size char_range))))]
    (in (maybe.trusted (text.char idx char_range)))))

(def: (size bottom top)
  (-> Nat Nat (Random Nat))
  (let [constraint (|>> (n.% top) (n.max bottom))]
    (random#each constraint random.nat)))

(def: (text bottom top)
  (-> Nat Nat (Random Text))
  (do random.monad
    [size (..size bottom top)]
    (random.text ..char size)))

(def: identifier
  (Random Symbol)
  (random.and (..text 0 10)
              (..text 1 10)))

(def: .public random
  (Random XML)
  (random.rec (function (_ random)
                (random.or (..text 1 10)
                           (do random.monad
                             [size (..size 0 2)]
                             ($_ random.and
                                 ..identifier
                                 (random.dictionary symbol.hash size ..identifier (..text 0 10))
                                 (random.list size random)))))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.XML])
      ($_ _.and
          (_.for [/.equivalence]
                 ($equivalence.spec /.equivalence ..random))
          (_.for [/.codec]
                 ($codec.spec /.equivalence /.codec ..random))

          (do [! random.monad]
            [(^@ identifier [namespace name]) ..identifier]
            (`` ($_ _.and
                    (~~ (template [<type> <format>]
                          [(_.cover [<type> <format>]
                                    (and (text#= name (<format> ["" name]))
                                         (let [identifier (<format> identifier)]
                                           (and (text.starts_with? namespace identifier)
                                                (text.ends_with? name identifier)))))]

                          [/.Tag /.tag]
                          [/.Attribute /.attribute]
                          ))
                    (_.cover [/.Attrs /.attributes]
                             (dictionary.empty? /.attributes))
                    )))
          )))
