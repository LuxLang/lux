(.module:
  [lux (#- char)
   ["_" test (#+ Test)]
   [abstract
    [monad (#+ Monad do)]
    {[0 #spec]
     [/
      ["$." equivalence]
      ["$." codec]]}]
   [control
    pipe
    ["." try]
    ["p" parser
     ["</>" xml]]]
   [data
    ["." name]
    ["." maybe]
    ["." text ("#\." equivalence)
     ["%" format (#+ format)]]
    [number
     ["n" nat]]
    [collection
     ["." dictionary]
     ["." list ("#\." functor)]]]
   [math
    ["." random (#+ Random) ("#\." monad)]]]
  {1
   ["." / (#+ XML)]})

(def: char-range
  Text
  (format "_"
          "abcdefghijklmnopqrstuvwxyz"
          "ABCDEFGHIJKLMNOPQRSTUVWXYZ"))

(def: char
  (Random Nat)
  (do {! random.monad}
    [idx (|> random.nat (\ ! map (n.% (text.size char-range))))]
    (wrap (maybe.assume (text.nth idx char-range)))))

(def: (size bottom top)
  (-> Nat Nat (Random Nat))
  (let [constraint (|>> (n.% top) (n.max bottom))]
    (random\map constraint random.nat)))

(def: (text bottom top)
  (-> Nat Nat (Random Text))
  (do random.monad
    [size (..size bottom top)]
    (random.text ..char size)))

(def: identifier
  (Random Name)
  (random.and (..text 0 10)
              (..text 1 10)))

(def: #export xml
  (Random XML)
  (random.rec (function (_ xml)
                (random.or (..text 1 10)
                           (do random.monad
                             [size (..size 0 2)]
                             ($_ random.and
                                 ..identifier
                                 (random.dictionary name.hash size ..identifier (..text 0 10))
                                 (random.list size xml)))))))

(def: #export test
  Test
  (<| (_.covering /._)
      (_.for [/.XML])
      ($_ _.and
          (_.for [/.equivalence]
                 ($equivalence.spec /.equivalence ..xml))
          (_.for [/.codec]
                 ($codec.spec /.equivalence /.codec ..xml))

          (do {! random.monad}
            [(^@ identifier [namespace name]) ..identifier]
            (`` ($_ _.and
                    (~~ (template [<type> <format>]
                          [(_.cover [<type> <format>]
                                    (and (text\= name (<format> ["" name]))
                                         (let [identifier (<format> identifier)]
                                           (and (text.starts-with? namespace identifier)
                                                (text.ends-with? name identifier)))))]

                          [/.Tag /.tag]
                          [/.Attribute /.attribute]
                          ))
                    (_.cover [/.Attrs /.attributes]
                             (dictionary.empty? /.attributes))
                    )))
          )))
