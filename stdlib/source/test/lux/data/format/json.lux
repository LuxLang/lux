... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except Variant Record
                #Bit #Text #Dec)
   [abstract
    [codec (.except)]
    [monad (.only do)]
    ["[0]" equivalence (.only Equivalence)
     ["[0]/[1]" \\polytypic]
     ["[1]T" \\test]]
    ["[0]" codec
     ["[1]T" \\test]]]
   [control
    ["<>" projection]
    ["[0]" pipe]
    ["[0]" maybe]
    ["[0]" exception]
    ["[0]" try (.use "[1]#[0]" functor)]]
   [data
    ["[0]" any]
    ["[0]" product]
    ["[0]" bit]
    ["[0]" text (.only)
     ["%" \\injection]]
    [collection
     ["[0]" sequence (.only sequence) (.use "[1]#[0]" functor)]
     ["[0]" dictionary (.only Dictionary)]
     ["[0]" set]
     ["[0]" list (.use "[1]#[0]" functor)]]]
   [math
    ["[0]" random (.only Random) (.use "[1]#[0]" monad)]
    [number (.only hex)
     ["[0]" nat]
     ["[0]" int]
     ["[0]" rev]
     ["[0]" dec]
     ["[0]" i64]]]
   ["[0]" meta (.only)
    ["[0]" code]
    ["[0]" macro (.only)
     ["^" pattern]
     ["[0]" syntax (.only syntax)]]]
   [world
    [time
     ["[0]" date]
     ["[0]" instant (.only)
      ["[0]/[1]" \\test]]
     ["[0]" duration (.only)
      ["[0]/[1]" \\test]]]]
   [test
    ["_" property (.only Test)]]]]
 ["[0]" \\polytypic]
 ["[0]" \\projection]
 [\\library
  ["[0]" / (.only JSON) (.use "[1]#[0]" equivalence)]])

(the !expect
  (template (_ <pattern> <value>)
    [(when <value>
       <pattern>
       true
       
       _
       false)]))

(the safe_dec
  (Random Dec)
  (random.only (|>> dec.not_a_number? not) random.dec))

(the \\projection
  Test
  (<| (_.covering \\projection._)
      (_.for [\\projection.Projection])
      (`` (all _.and
               (do [! random.monad]
                 [expected (of ! each (|>> {/.#String}) (random.unicode 1))]
                 (_.coverage [\\projection.value \\projection.any]
                   (|> (\\projection.value \\projection.any expected)
                       (!expect (^.multi {try.#Success actual}
                                         (of /.equivalence = expected actual))))))
               (_.coverage [\\projection.null]
                 (|> (\\projection.value \\projection.null {/.#Null})
                     (!expect {try.#Success _})))
               (,, (with_template [<query> <test> <check> <random> <json> <equivalence>]
                     [(do [! random.monad]
                        [expected <random>
                         dummy (|> <random> (random.only (|>> (of <equivalence> = expected) not)))]
                        (all _.and
                             (_.coverage [<query>]
                               (|> (\\projection.value <query> {<json> expected})
                                   (!expect (^.multi {try.#Success actual}
                                                     (of <equivalence> = expected actual)))))
                             (_.coverage [<test>]
                               (and (|> (\\projection.value (<test> expected) {<json> expected})
                                        (!expect {try.#Success .true}))
                                    (|> (\\projection.value (<test> expected) {<json> dummy})
                                        (!expect {try.#Success .false}))))
                             (_.coverage [<check>]
                               (and (|> (\\projection.value (<check> expected) {<json> expected})
                                        (!expect {try.#Success _}))
                                    (|> (\\projection.value (<check> expected) {<json> dummy})
                                        (!expect {try.#Failure _}))))))]

                     [\\projection.boolean \\projection.boolean? \\projection.this_boolean random.bit /.#Boolean bit.equivalence]
                     [\\projection.number \\projection.number? \\projection.this_number ..safe_dec /.#Number dec.equivalence]
                     [\\projection.string \\projection.string? \\projection.this_string (random.unicode 1) /.#String text.equivalence]
                     ))
               (do [! random.monad]
                 [expected (random.unicode 1)
                  dummy random.bit]
                 (_.coverage [\\projection.unexpected_value]
                   (|> (\\projection.value \\projection.string {/.#Boolean dummy})
                       (!expect (^.multi {try.#Failure error}
                                         (exception.is? \\projection.unexpected_value error))))))
               (do [! random.monad]
                 [expected (random.unicode 1)
                  dummy (|> (random.unicode 1) (random.only (|>> (of text.equivalence = expected) not)))]
                 (_.coverage [\\projection.value_mismatch]
                   (|> (\\projection.value (\\projection.this_string expected) {/.#String dummy})
                       (!expect (^.multi {try.#Failure error}
                                         (exception.is? \\projection.value_mismatch error))))))
               (do [! random.monad]
                 [expected (random.unicode 1)]
                 (_.coverage [\\projection.nullable]
                   (and (|> (\\projection.value (\\projection.nullable \\projection.string) {/.#Null})
                            (!expect (^.multi {try.#Success actual}
                                              (of (maybe.equivalence text.equivalence) = {.#None} actual))))
                        (|> (\\projection.value (\\projection.nullable \\projection.string) {/.#String expected})
                            (!expect (^.multi {try.#Success actual}
                                              (of (maybe.equivalence text.equivalence) = {.#Some expected} actual)))))))
               (do [! random.monad]
                 [size (of ! each (nat.% 10) random.nat)
                  expected (|> (random.unicode 1)
                               (random.list size)
                               (of ! each sequence.of_list))]
                 (_.coverage [\\projection.array]
                   (|> (\\projection.value (\\projection.array (<>.some \\projection.string))
                                           {/.#Array (sequence#each (|>> {/.#String}) expected)})
                       (!expect (^.multi {try.#Success actual}
                                         (of (sequence.equivalence text.equivalence) = expected (sequence.of_list actual)))))))
               (do [! random.monad]
                 [expected (of ! each (|>> {/.#String}) (random.unicode 1))]
                 (_.coverage [\\projection.unconsumed_input]
                   (|> (\\projection.value (\\projection.array \\projection.any) {/.#Array (sequence expected expected)})
                       (!expect (^.multi {try.#Failure error}
                                         (exception.is? \\projection.unconsumed_input error))))))
               (_.coverage [\\projection.empty_input]
                 (|> (\\projection.value (\\projection.array \\projection.any) {/.#Array (sequence)})
                     (!expect (^.multi {try.#Failure error}
                                       (exception.is? \\projection.empty_input error)))))
               (do [! random.monad]
                 [expected_boolean random.bit
                  expected_number ..safe_dec
                  expected_string (random.unicode 1)
                  [boolean_field number_field string_field] (|> (random.set text.hash 3 (random.unicode 3))
                                                                (of ! each (|>> set.list
                                                                                (pipe.when
                                                                                  (list boolean_field number_field string_field)
                                                                                  [boolean_field number_field string_field]

                                                                                  _
                                                                                  (undefined)))))]
                 (_.coverage [\\projection.object \\projection.field]
                   (|> (\\projection.value (\\projection.object (all <>.and
                                                                     (\\projection.field boolean_field \\projection.boolean)
                                                                     (\\projection.field number_field \\projection.number)
                                                                     (\\projection.field string_field \\projection.string)))
                                           {/.#Object
                                            (dictionary.of_list text.hash
                                                                (list [boolean_field {/.#Boolean expected_boolean}]
                                                                      [number_field {/.#Number expected_number}]
                                                                      [string_field {/.#String expected_string}]))})
                       (!expect (^.multi {try.#Success [actual_boolean actual_number actual_string]}
                                         (and (of bit.equivalence = expected_boolean actual_boolean)
                                              (of dec.equivalence = expected_number actual_number)
                                              (of text.equivalence = expected_string actual_string)))))))
               (do [! random.monad]
                 [size (of ! each (nat.% 10) random.nat)
                  keys (random.list size (random.unicode 1))
                  values (random.list size (random.unicode 1))
                  .let [expected (dictionary.of_list text.hash (list.zipped_2 keys values))]]
                 (_.coverage [\\projection.dictionary]
                   (|> (\\projection.value (\\projection.dictionary \\projection.string)
                                           {/.#Object
                                            (|> values
                                                (list#each (|>> {/.#String}))
                                                (list.zipped_2 keys)
                                                (dictionary.of_list text.hash))})
                       (!expect (^.multi {try.#Success actual}
                                         (of (dictionary.equivalence text.equivalence) = expected actual))))))
               ))))

(every Variant
  (.Variant
   {#Bit Bit}
   {#Text Text}
   {#Dec Dec}))

(every Recursive
  (Rec Recursive
    (.Variant
     {#Number Dec}
     {#Addition Dec Recursive})))

(every Record
  (.Record
   [#maybe (Maybe Dec)
    #recursive Recursive]))

(the gen_recursive
  (Random Recursive)
  (random.rec
   (function (_ gen_recursive)
     (random.or random.safe_dec
                (random.and random.safe_dec
                            gen_recursive)))))

(the gen_record
  (Random Record)
  (do [! random.monad]
    [size (of ! each (nat.% 2) random.nat)]
    (all random.and
         (random.maybe random.safe_dec)
         ..gen_recursive)))

(for .old (these)
     (these (the equivalence
              (Equivalence Record)
              (\\polytypic/equivalence.equivalence Record))

            (the codec
              (Codec JSON Record)
              (\\polytypic.codec Record))))

(the \\polytypic
  Test
  (<| (_.covering \\polytypic._)
      (_.for [\\polytypic.codec]
             (for .old (_.test "PLACEHOLDER" true)
                  (codecT.spec ..equivalence ..codec ..gen_record)))))

(the .public random
  (Random /.JSON)
  (random.rec
   (function (_ again)
     (do [! random.monad]
       [size (of ! each (nat.% 2) random.nat)]
       (all random.or
            (of ! in [])
            random.bit
            random.safe_dec
            (random.unicode size)
            (random.sequence size again)
            (random.dictionary text.hash size (random.unicode size) again)
            )))))

(the boolean
  (syntax (_ [])
    (do meta.monad
      [value meta.seed]
      (in (list (code.bit (nat.even? value)))))))

(the number
  (syntax (_ [])
    (do meta.monad
      [value meta.seed]
      (in (list (code.dec (nat.dec value)))))))

(the string
  (syntax (_ [])
    (do meta.monad
      [value (macro.symbol "string")]
      (in (list (code.text (%.code value)))))))

(the (digits/4 it)
  (-> Nat Text)
  (<| (if (nat.< (hex "10") it)
        (%.format "000" (%.nat_16 it)))
      (if (nat.< (hex "100") it)
        (%.format "00" (%.nat_16 it)))
      (if (nat.< (hex "1000") it)
        (%.format "0" (%.nat_16 it)))
      (%.nat_16 it)))

(the escaped_string
  (Random [Text Text])
  (all random.either
       (random#in [text.tab "\t"])
       (random#in [text.back_space "\b"])
       (random#in [text.new_line "\n"])
       (random#in [text.carriage_return "\r"])
       (random#in [text.form_feed "\f"])
       (random#in [text.double_quote text.double_quote])
       (random#in ["\" "\\"])
       (do [! random.monad]
         [char (of ! each (i64.and (hex "FF"))
                   random.nat)]
         (in [(text.of_char char)
              (%.format "\u" (digits/4 char))]))
       ))

(the any_string
  (Random [Text Text])
  (all random.either
       escaped_string
       (do random.monad
         [it (random.alphabetic 1)]
         (in [it it]))
       ))

(the .public test
  Test
  (<| (_.covering /._)
      (_.for [/.JSON])
      (`` (all _.and
               (_.for [/.equivalence]
                      (equivalenceT.spec /.equivalence ..random))
               (_.for [/.any]
                      (all _.and
                           (codecT.spec any.equivalence /.any (random#in []))
                           (codecT.spec any.equivalence (\\polytypic.codec Any) (random#in []))
                           ))
               (_.for [/.bit]
                      (all _.and
                           (codecT.spec bit.equivalence /.bit random.bit)
                           (codecT.spec bit.equivalence (\\polytypic.codec Bit) random.bit)
                           ))
               (_.for [/.nat]
                      (all _.and
                           (codecT.spec nat.equivalence /.nat random.nat)
                           (codecT.spec nat.equivalence (\\polytypic.codec Nat) random.nat)
                           ))
               (_.for [/.int]
                      (all _.and
                           (codecT.spec int.equivalence /.int random.int)
                           (codecT.spec int.equivalence (\\polytypic.codec Int) random.int)
                           ))
               (_.for [/.rev]
                      (all _.and
                           (codecT.spec rev.equivalence /.rev random.rev)
                           (codecT.spec rev.equivalence (\\polytypic.codec Rev) random.rev)
                           ))
               (_.for [/.dec]
                      (all _.and
                           (codecT.spec dec.equivalence /.dec random.dec)
                           (codecT.spec dec.equivalence (\\polytypic.codec Dec) random.safe_dec)
                           ))
               (_.for [/.text]
                      (all _.and
                           (codecT.spec text.equivalence /.text (random.unicode 2))
                           (codecT.spec text.equivalence (\\polytypic.codec Text) (random.unicode 2))
                           ))
               (_.for [/.instant]
                      (all _.and
                           (codecT.spec instant.equivalence /.instant random.instant)
                           (codecT.spec instant.equivalence (\\polytypic.codec instant.Instant) random.instant)
                           ))
               (_.for [/.duration]
                      (all _.and
                           (codecT.spec duration.equivalence /.duration random.duration)
                           (codecT.spec duration.equivalence (\\polytypic.codec duration.Duration) random.duration)
                           ))
               (_.for [/.date]
                      (all _.and
                           (codecT.spec date.equivalence /.date random.date)
                           (codecT.spec date.equivalence (\\polytypic.codec date.Date) random.date)
                           ))
               (_.for [/.list]
                      (let [equivalence (list.equivalence nat.equivalence)
                            random (random.list 2 random.nat)]
                        (all _.and
                             (codecT.spec equivalence (/.list /.nat) random)
                             (codecT.spec equivalence (\\polytypic.codec (type (List Nat))) random)
                             )))
               (_.for [/.dictionary]
                      (let [equivalence (dictionary.equivalence nat.equivalence)
                            random (random.dictionary text.hash 2 (random.unicode 2) random.nat)]
                        (all _.and
                             (codecT.spec equivalence (/.dictionary /.nat) random)
                             (codecT.spec equivalence (\\polytypic.codec (type (Dictionary Text Nat))) random)
                             )))
               (_.for [/.sum]
                      (let [equivalence (all equivalence.sum bit.equivalence text.equivalence dec.equivalence)
                            random (all random.or random.bit (random.unicode 2) random.safe_dec)]
                        (all _.and
                             (codecT.spec equivalence (all /.sum /.bit /.text /.dec) random)
                             (codecT.spec equivalence (\\polytypic.codec Variant) random)
                             )))
               ... (_.for [/.product]
               ...        (let [equivalence (all equivalence.product bit.equivalence text.equivalence dec.equivalence)
               ...              random (all random.or random.bit (random.unicode 2) random.safe_dec)]
               ...          (all _.and
               ...               (codecT.spec equivalence (all /.product /.bit /.text /.dec) random)
               ...               (codecT.spec equivalence (\\polytypic.codec (type [Bit Text Dec])) random)
               ...               )))
               (_.for [/.codec]
                      (all _.and
                           (codecT.spec /.equivalence /.codec ..random)
                           (do random.monad
                             [key (random.alphabetic 1)
                              [expected escaped] any_string]
                             (_.coverage [/.#String]
                               (|> {/.#String escaped}
                                   (of /.codec injection)
                                   (of /.codec projection)
                                   (try#each (of /.equivalence = {/.#String expected}))
                                   (try.else false))))
                           ))

               (do random.monad
                 [sample ..random]
                 (_.coverage [/.Null /.#Null /.null?]
                   (of bit.equivalence =
                       (/.null? sample)
                       (when sample
                         {/.#Null} true
                         _ false))))
               (do random.monad
                 [expected ..random]
                 (_.coverage [/.format]
                   (|> expected
                       /.format
                       (of /.codec projection)
                       (try#each (/#= expected))
                       (try.else false))))
               (do random.monad
                 [keys (random.set text.hash 3 (random.alphabetic 1))
                  values (random.set dec.hash 3 random.safe_dec)
                  .let [expected (list.zipped_2 (set.list keys)
                                                (list#each (|>> {/.#Number}) (set.list values)))
                        object (/.object expected)]]
                 (all _.and
                      (_.coverage [/.object /.fields]
                        (when (/.fields object)
                          {try.#Success actual}
                          (of (list.equivalence text.equivalence) =
                              (list#each product.left expected)
                              actual)
                          
                          {try.#Failure error}
                          false))
                      (_.coverage [/.field]
                        (list.every? (function (_ [key expected])
                                       (|> (/.field key object)
                                           (try#each (/#= expected))
                                           (try.else false)))
                                     expected))
                      ))
               (do random.monad
                 [key (random.alphabetic 1)
                  unknown (random.only (|>> (of text.equivalence = key) not)
                                       (random.alphabetic 1))
                  expected random.safe_dec]
                 (_.coverage [/.has]
                   (<| (try.else false)
                       (do try.monad
                         [object (/.has key {/.#Number expected} (/.object (list)))
                          .let [can_find_known_key!
                                (|> object
                                    (/.field key)
                                    (try#each (/#= {/.#Number expected}))
                                    (try.else false))

                                cannot_find_unknown_key!
                                (when (/.field unknown object)
                                  {try.#Success _}
                                  false

                                  {try.#Failure error}
                                  true)]]
                         (in (and can_find_known_key!
                                  cannot_find_unknown_key!))))))
               (,, (with_template [<type> <field> <tag> <random> <equivalence>]
                     [(do random.monad
                        [key (random.alphabetic 1)
                         value <random>]
                        (_.coverage [<type> <tag> <field>]
                          (|> (/.object (list [key {<tag> value}]))
                              (<field> key)
                              (try#each (of <equivalence> = value))
                              (try.else false))))]

                     [/.Boolean /.boolean_field /.#Boolean random.bit bit.equivalence]
                     [/.Number /.number_field /.#Number random.safe_dec dec.equivalence]
                     [/.String /.string_field /.#String (random.alphabetic 1) text.equivalence]
                     [/.Array /.array_field /.#Array (random.sequence 3 ..random) (sequence.equivalence /.equivalence)]
                     [/.Object /.object_field /.#Object (random.dictionary text.hash 3 (random.alphabetic 1) ..random) (dictionary.equivalence /.equivalence)]
                     ))
               (with_expansions [<boolean> (boolean)
                                 <number> (number)
                                 <string> (string)
                                 <array_sequence> (sequence.sequence {/.#Null}
                                                                     {/.#Boolean <boolean>}
                                                                     {/.#Number <number>}
                                                                     {/.#String <string>})
                                 <key0> (string)
                                 <key1> (string)
                                 <key2> (string)
                                 <key3> (string)
                                 <key4> (string)
                                 <key5> (string)
                                 <key6> (string)]
                 (_.coverage [/.json]
                   (and (/#= {/.#Null} (/.json ()))
                        (,, (with_template [<tag> <value>]
                              [(/#= {<tag> <value>} (/.json <value>))]
                              
                              [/.#Boolean <boolean>]
                              [/.#Number <number>]
                              [/.#String <string>]
                              ))
                        (/#= {/.#Array <array_sequence>} (/.json [() <boolean> <number> <string>]))
                        (let [object (/.json {<key0> ()
                                                     <key1> <boolean>
                                                     <key2> <number>
                                                     <key3> <string>
                                                     <key4> [() <boolean> <number> <string>]
                                                     <key5> {<key6> <number>}})]
                          (<| (try.else false)
                              (do try.monad
                                [value0 (/.field <key0> object)
                                 value1 (/.field <key1> object)
                                 value2 (/.field <key2> object)
                                 value3 (/.field <key3> object)
                                 value4 (/.field <key4> object)
                                 value5 (/.field <key5> object)
                                 value6 (/.field <key6> value5)]
                                (in (and (/#= {/.#Null} value0)
                                         (/#= {/.#Boolean <boolean>} value1)
                                         (/#= {/.#Number <number>} value2)
                                         (/#= {/.#String <string>} value3)
                                         (/#= {/.#Array <array_sequence>} value4)
                                         (/#= {/.#Number <number>} value6))))))
                        )))

               ..\\polytypic
               ..\\projection
               ))))
