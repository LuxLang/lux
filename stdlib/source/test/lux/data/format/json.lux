(.using
 [library
  [lux (.full)
   ["_" test (.only Test)]
   ["[0]" meta]
   [abstract
    [monad (.only do)]
    [\\specification
     ["$[0]" equivalence]
     ["$[0]" codec]]]
   [control
    ["[0]" try ("[1]#[0]" functor)]]
   [data
    ["[0]" product]
    ["[0]" bit]
    ["[0]" text
     ["%" format (.only format)]]
    [collection
     ["[0]" sequence]
     ["[0]" dictionary]
     ["[0]" set]
     ["[0]" list ("[1]#[0]" functor)]]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" nat]
     ["[0]" frac]]]
   ["[0]" macro
    ["[0]" syntax (.only syntax:)]
    ["[0]" code]]]]
 [\\library
  ["[0]" / (.only JSON) ("#[0]" equivalence)]])

(def: .public random
  (Random /.JSON)
  (random.rec
   (function (_ again)
     (do [! random.monad]
       [size (# ! each (n.% 2) random.nat)]
       (all random.or
            (# ! in [])
            random.bit
            random.safe_frac
            (random.unicode size)
            (random.sequence size again)
            (random.dictionary text.hash size (random.unicode size) again)
            )))))

(syntax: (boolean [])
  (do meta.monad
    [value meta.seed]
    (in (list (code.bit (n.even? value))))))

(syntax: (number [])
  (do meta.monad
    [value meta.seed]
    (in (list (code.frac (n.frac value))))))

(syntax: (string [])
  (do meta.monad
    [value (macro.symbol "string")]
    (in (list (code.text (%.code value))))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.JSON])
      (`` (all _.and
               (_.for [/.equivalence]
                      ($equivalence.spec /.equivalence ..random))
               (_.for [/.codec]
                      ($codec.spec /.equivalence /.codec ..random))

               (do random.monad
                 [sample ..random]
                 (_.coverage [/.Null /.null?]
                   (# bit.equivalence =
                      (/.null? sample)
                      (case sample
                        {/.#Null} true
                        _ false))))
               (do random.monad
                 [expected ..random]
                 (_.coverage [/.format]
                   (|> expected
                       /.format
                       (# /.codec decoded)
                       (try#each (#= expected))
                       (try.else false))))
               (do random.monad
                 [keys (random.set text.hash 3 (random.alphabetic 1))
                  values (random.set frac.hash 3 random.safe_frac)
                  .let [expected (list.zipped_2 (set.list keys)
                                                (list#each (|>> {/.#Number}) (set.list values)))
                        object (/.object expected)]]
                 (all _.and
                      (_.coverage [/.object /.fields]
                        (case (/.fields object)
                          {try.#Success actual}
                          (# (list.equivalence text.equivalence) =
                             (list#each product.left expected)
                             actual)
                          
                          {try.#Failure error}
                          false))
                      (_.coverage [/.field]
                        (list.every? (function (_ [key expected])
                                       (|> (/.field key object)
                                           (try#each (#= expected))
                                           (try.else false)))
                                     expected))
                      ))
               (do random.monad
                 [key (random.alphabetic 1)
                  unknown (random.only (|>> (# text.equivalence = key) not)
                                       (random.alphabetic 1))
                  expected random.safe_frac]
                 (_.coverage [/.has]
                   (<| (try.else false)
                       (do try.monad
                         [object (/.has key {/.#Number expected} (/.object (list)))
                          .let [can_find_known_key!
                                (|> object
                                    (/.field key)
                                    (try#each (#= {/.#Number expected}))
                                    (try.else false))

                                cannot_find_unknown_key!
                                (case (/.field unknown object)
                                  {try.#Success _}
                                  false

                                  {try.#Failure error}
                                  true)]]
                         (in (and can_find_known_key!
                                  cannot_find_unknown_key!))))))
               (~~ (template [<type> <field> <tag> <random> <equivalence>]
                     [(do random.monad
                        [key (random.alphabetic 1)
                         value <random>]
                        (_.coverage [<type> <field>]
                          (|> (/.object (list [key {<tag> value}]))
                              (<field> key)
                              (try#each (# <equivalence> = value))
                              (try.else false))))]

                     [/.Boolean /.boolean_field /.#Boolean random.bit bit.equivalence]
                     [/.Number /.number_field /.#Number random.safe_frac frac.equivalence]
                     [/.String /.string_field /.#String (random.alphabetic 1) text.equivalence]
                     [/.Array /.array_field /.#Array (random.sequence 3 ..random) (sequence.equivalence /.equivalence)]
                     [/.Object /.object_field /.#Object (random.dictionary text.hash 3 (random.alphabetic 1) ..random) (dictionary.equivalence /.equivalence)]
                     ))
               (with_expansions [<boolean> (boolean)
                                 <number> (number)
                                 <string> (string)
                                 <array_sequence> (sequence.sequence {/.#Null}
                                                                     {/.#Boolean <boolean>}
                                                                     {/.#Number <number>}
                                                                     {/.#String <string>})
                                 <key0> (string)
                                 <key1> (string)
                                 <key2> (string)
                                 <key3> (string)
                                 <key4> (string)
                                 <key5> (string)
                                 <key6> (string)]
                 (_.coverage [/.json]
                   (and (#= {/.#Null} (/.json ()))
                        (~~ (template [<tag> <value>]
                              [(#= {<tag> <value>} (/.json <value>))]
                              
                              [/.#Boolean <boolean>]
                              [/.#Number <number>]
                              [/.#String <string>]
                              ))
                        (#= {/.#Array <array_sequence>} (/.json [() <boolean> <number> <string>]))
                        (let [object (/.json {<key0> ()
                                                     <key1> <boolean>
                                                     <key2> <number>
                                                     <key3> <string>
                                                     <key4> [() <boolean> <number> <string>]
                                                     <key5> {<key6> <number>}})]
                          (<| (try.else false)
                              (do try.monad
                                [value0 (/.field <key0> object)
                                 value1 (/.field <key1> object)
                                 value2 (/.field <key2> object)
                                 value3 (/.field <key3> object)
                                 value4 (/.field <key4> object)
                                 value5 (/.field <key5> object)
                                 value6 (/.field <key6> value5)]
                                (in (and (#= {/.#Null} value0)
                                         (#= {/.#Boolean <boolean>} value1)
                                         (#= {/.#Number <number>} value2)
                                         (#= {/.#String <string>} value3)
                                         (#= {/.#Array <array_sequence>} value4)
                                         (#= {/.#Number <number>} value6))))))
                        )))
               ))))
