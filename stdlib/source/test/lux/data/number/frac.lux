(.module:
  [lux #*
   ["_" test (#+ Test)]
   ["@" target]
   ["." host]
   [abstract
    [monad (#+ do)]
    {[0 #spec]
     [/
      ["$." equivalence]
      ["$." hash]
      ["$." order]
      ["$." monoid]
      ["$." codec]]}]
   [data
    ["." bit ("#\." equivalence)]]
   [math
    ["." random (#+ Random)]]]
  {1
   ["." /
    [// #*
     ["n" nat]
     ["i" int]
     ["r" rev]
     ["." i64]]]})

(def: random
  (Random Frac)
  (\ random.monad map (|>> (i.% +1,000,000) i.frac) random.int))

(def: constant
  Test
  (do random.monad
    [sample random.safe-frac]
    ($_ _.and
        (_.cover [/.biggest]
                 (/.<= /.biggest sample))
        (_.cover [/.positive-infinity]
                 (/.< /.positive-infinity sample))
        (_.cover [/.smallest]
                 (bit\= (/.positive? sample)
                        (/.>= /.smallest sample)))
        (_.cover [/.negative-infinity]
                 (/.> /.negative-infinity sample))
        (_.cover [/.not-a-number /.not-a-number?]
                 (and (/.not-a-number? /.not-a-number)
                      (not (or (/.= /.not-a-number sample)
                               (/.not-a-number? sample)))))
        )))

(def: predicate
  Test
  (do {! random.monad}
    [sample ..random
     shift (\ ! map /.abs ..random)]
    ($_ _.and
        (_.cover [/.negative?]
                 (bit\= (/.negative? sample)
                        (/.< +0.0 sample)))
        (_.cover [/.positive?]
                 (bit\= (/.positive? sample)
                        (/.> +0.0 sample)))
        (_.cover [/.zero?]
                 (bit\= (/.zero? sample)
                        (/.= +0.0 sample)))
        (_.cover [/.within?]
                 (and (/.within? /.smallest sample sample)
                      (/.within? (/.+ +1.0 shift) sample (/.+ shift sample))))
        (_.cover [/.number?]
                 (and (not (/.number? /.not-a-number))
                      (not (/.number? /.positive-infinity))
                      (not (/.number? /.negative-infinity))
                      (/.number? sample)))
        )))

(def: conversion
  Test
  ($_ _.and
      (do {! random.monad}
        [expected (\ ! map (n.% 1,000,000) random.nat)]
        (_.cover [/.nat]
                 (|> expected n.frac /.nat (n.= expected))))
      (do {! random.monad}
        [expected (\ ! map (i.% +1,000,000) random.int)]
        (_.cover [/.int]
                 (|> expected i.frac /.int (i.= expected))))
      (do {! random.monad}
        [expected (\ ! map (|>> (i64.left-shift 52) .rev)
                     random.nat)]
        (_.cover [/.rev]
                 (|> expected r.frac /.rev (r.= expected))))
      ))

(def: signature
  Test
  (`` ($_ _.and
          (_.for [/.equivalence /.=]
                 ($equivalence.spec /.equivalence random.safe-frac))
          (_.for [/.hash]
                 ($hash.spec /.hash random.frac))
          (_.for [/.order /.<]
                 ($order.spec /.order random.safe-frac))
          (~~ (template [<compose> <monoid>]
                [(_.for [<monoid> <compose>]
                        ($monoid.spec /.equivalence <monoid> ..random))]

                [/.+ /.addition]
                [/.* /.multiplication]

                [/.min /.minimum]
                [/.max /.maximum]
                ))
          (~~ (template [<codec>]
                [(_.for [<codec>]
                        ($codec.spec /.equivalence <codec> random.safe-frac))]

                [/.binary] [/.octal] [/.decimal] [/.hex]
                ))
          )))

(with-expansions [<jvm> (as-is (host.import: java/lang/Double
                                 ["#::."
                                  (#static doubleToRawLongBits #manual [double] long)
                                  (#static longBitsToDouble #manual [long] double)]))]
  (for {@.old (as-is <jvm>)
        @.jvm (as-is <jvm>)}))

(def: #export test
  Test
  (<| (_.covering /._)
      (_.for [.Frac])
      ($_ _.and
          (do random.monad
            [left random.safe-frac
             right random.safe-frac]
            ($_ _.and
                (_.cover [/.>]
                         (bit\= (/.> left right)
                                (/.< right left)))
                (_.cover [/.<= /.>=]
                         (bit\= (/.<= left right)
                                (/.>= right left)))
                ))
          (do random.monad
            [sample random.safe-frac]
            ($_ _.and
                (_.cover [/.-]
                         (and (/.= +0.0 (/.- sample sample))
                              (/.= sample (/.- +0.0 sample))
                              (/.= (/.negate sample)
                                   (/.- sample +0.0))))
                (_.cover [/./]
                         (and (/.= +1.0 (/./ sample sample))
                              (/.= sample (/./ +1.0 sample))))
                (_.cover [/.abs]
                         (bit\= (/.> sample (/.abs sample))
                                (/.negative? sample)))
                (_.cover [/.signum]
                         (/.= (/.abs sample)
                              (/.* (/.signum sample) sample)))
                ))
          (do random.monad
            [left ..random
             right ..random]
            ($_ _.and
                (_.cover [/.%]
                         (let [rem (/.% left right)
                               div (|> right (/.- rem) (/./ left))]
                           (/.= right
                                (|> div (/.* left) (/.+ rem)))))
                (_.cover [/./%]
                         (let [[div rem] (/./% left right)]
                           (and (/.= div (/./ left right))
                                (/.= rem (/.% left right)))))
                (_.cover [/.mod]
                         (and (/.= (/.signum left)
                                   (/.signum (/.mod left right)))
                              (/.= (/.signum right)
                                   (/.signum (/.% left right)))
                              (if (/.= (/.signum left) (/.signum right))
                                (/.= (/.% left right)
                                     (/.mod left right))
                                (or (and (/.= +0.0 (/.% left right))
                                         (/.= +0.0 (/.mod left right)))
                                    (/.= (/.+ left (/.% left right))
                                         (/.mod left right))))))
                ))
          (with-expansions [<jvm> ($_ _.and
                                      (let [test (: (-> Frac Bit)
                                                    (function (_ value)
                                                      (n.= (.nat (java/lang/Double::doubleToRawLongBits value))
                                                           (/.to-bits value))))]
                                        (do random.monad
                                          [sample random.frac]
                                          (_.cover [/.to-bits]
                                                   (and (test sample)
                                                        (test /.biggest)
                                                        (test /.smallest)
                                                        (test /.not-a-number)
                                                        (test /.positive-infinity)
                                                        (test /.negative-infinity)))))
                                      (do random.monad
                                        [sample random.i64]
                                        (_.cover [/.from-bits]
                                                 (let [expected (java/lang/Double::longBitsToDouble sample)
                                                       actual (/.from-bits sample)]
                                                   (or (/.= expected actual)
                                                       (and (/.not-a-number? expected)
                                                            (/.not-a-number? actual))))))
                                      )]
            (for {@.old <jvm>
                  @.jvm <jvm>}
                 (let [test (: (-> Frac Bit)
                               (function (_ expected)
                                 (let [actual (|> expected /.to-bits /.from-bits)]
                                   (or (/.= expected actual)
                                       (and (/.not-a-number? expected)
                                            (/.not-a-number? actual))))))]
                   (do random.monad
                     [sample random.frac]
                     (_.cover [/.to-bits /.from-bits]
                              (and (test sample)
                                   (test /.biggest)
                                   (test /.smallest)
                                   (test /.not-a-number)
                                   (test /.positive-infinity)
                                   (test /.negative-infinity)))))))
          (do random.monad
            [expected random.safe-frac]
            (_.cover [/.negate]
                     (let [subtraction!
                           (/.= +0.0 (/.+ (/.negate expected) expected))

                           inverse!
                           (|> expected /.negate /.negate (/.= expected))]
                       (and subtraction!
                            inverse!))))

          ..constant
          ..predicate
          ..conversion
          ..signature
          )))
