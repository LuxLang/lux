(.module:
  [lux #*
   ["_" test (#+ Test)]
   [abstract
    [monad (#+ do)]
    {[0 #spec]
     [/
      ["$." equivalence]
      ["$." order]
      ["$." monoid]
      ["$." codec]]}]
   [data
    ["." bit ("#\." equivalence)]
    [text
     ["%" format (#+ format)]]]
   [math
    ["." random (#+ Random)]]]
  {1
   ["." /
    [// #*
     ["n" nat]
     ["i" int]
     ["r" rev]
     ["." i64]]]})

(def: random
  (Random Frac)
  (\ random.monad map (|>> (i.% +1,000,000) i.frac) random.int))

(def: signature
  Test
  (`` ($_ _.and
          (_.with-cover [/.equivalence /.=]
            ($equivalence.spec /.equivalence random.safe-frac))
          (_.with-cover [/.order /.<]
            ($order.spec /.order random.safe-frac))
          (~~ (template [<compose> <monoid>]
                [(_.with-cover [<monoid> <compose>]
                   ($monoid.spec /.equivalence <monoid> ..random))]

                [/.+ /.addition]
                [/.* /.multiplication]

                [/.min /.minimum]
                [/.max /.maximum]
                ))
          (~~ (template [<codec>]
                [(_.with-cover [<codec>]
                   ($codec.spec /.equivalence <codec> random.safe-frac))]

                [/.binary] [/.octal] [/.decimal] [/.hex]
                ))
          )))

(def: constant
  Test
  (do random.monad
    [sample random.safe-frac]
    ($_ _.and
        (_.cover [/.biggest]
                 (/.<= /.biggest sample))
        (_.cover [/.positive-infinity]
                 (/.< /.positive-infinity sample))
        (_.cover [/.smallest]
                 (bit\= (/.positive? sample)
                        (/.>= /.smallest sample)))
        (_.cover [/.negative-infinity]
                 (/.> /.negative-infinity sample))
        (_.cover [/.not-a-number /.not-a-number?]
                 (and (/.not-a-number? /.not-a-number)
                      (not (or (/.= /.not-a-number sample)
                               (/.not-a-number? sample)))))
        )))

(def: predicate
  Test
  (do {! random.monad}
    [sample ..random
     shift (\ ! map /.abs ..random)]
    ($_ _.and
        (_.cover [/.negative?]
                 (bit\= (/.negative? sample)
                        (/.< +0.0 sample)))
        (_.cover [/.positive?]
                 (bit\= (/.positive? sample)
                        (/.> +0.0 sample)))
        (_.cover [/.zero?]
                 (bit\= (/.zero? sample)
                        (/.= +0.0 sample)))
        (_.cover [/.within?]
                 (and (/.within? /.smallest sample sample)
                      (/.within? (/.+ +1.0 shift) sample (/.+ shift sample))))
        (_.cover [/.number?]
                 (and (not (/.number? /.not-a-number))
                      (not (/.number? /.positive-infinity))
                      (not (/.number? /.negative-infinity))
                      (/.number? sample)))
        )))

(def: conversion
  Test
  ($_ _.and
      (do {! random.monad}
        [expected (\ ! map (n.% 1,000,000) random.nat)]
        (_.cover [/.nat]
                 (|> expected n.frac /.nat (n.= expected))))
      (do {! random.monad}
        [expected (\ ! map (i.% +1,000,000) random.int)]
        (_.cover [/.int]
                 (|> expected i.frac /.int (i.= expected))))
      (do {! random.monad}
        [expected (\ ! map (|>> (i64.left-shift 32) .rev)
                     random.nat)]
        (_.cover [/.rev]
                 (|> expected r.frac /.rev (r.= expected))))
      ))

(def: #export test
  Test
  (<| (_.covering /._)
      (_.with-cover [.Frac])
      (`` ($_ _.and
              (do random.monad
                [left random.safe-frac
                 right random.safe-frac]
                ($_ _.and
                    (_.cover [/.>]
                             (bit\= (/.> left right)
                                    (/.< right left)))
                    (_.cover [/.<= /.>=]
                             (bit\= (/.<= left right)
                                    (/.>= right left)))
                    ))
              (do random.monad
                [left ..random
                 right ..random]
                ($_ _.and
                    (_.cover [/.%]
                             (let [rem (/.% left right)
                                   div (|> right (/.- rem) (/./ left))]
                               (/.= right
                                    (|> div (/.* left) (/.+ rem)))))
                    (_.cover [/./%]
                             (let [[div rem] (/./% left right)]
                               (and (/.= div (/./ left right))
                                    (/.= rem (/.% left right)))))
                    ))
              (do random.monad
                [sample random.safe-frac]
                ($_ _.and
                    (_.cover [/.-]
                             (and (/.= +0.0 (/.- sample sample))
                                  (/.= sample (/.- +0.0 sample))
                                  (/.= (/.negate sample)
                                       (/.- sample +0.0))))
                    (_.cover [/./]
                             (and (/.= +1.0 (/./ sample sample))
                                  (/.= sample (/./ +1.0 sample))))
                    (_.cover [/.abs]
                             (bit\= (/.> sample (/.abs sample))
                                    (/.negative? sample)))
                    (_.cover [/.signum]
                             (/.= (/.abs sample)
                                  (/.* (/.signum sample) sample)))))
              (do random.monad
                [expected random.frac]
                (_.cover [/.to-bits /.from-bits]
                         (let [actual (|> expected /.to-bits /.from-bits)]
                           (or (/.= expected actual)
                               (and (/.not-a-number? expected)
                                    (/.not-a-number? actual))))))
              (do random.monad
                [expected random.safe-frac]
                (_.cover [/.negate]
                         (let [subtraction!
                               (/.= +0.0 (/.+ (/.negate expected) expected))

                               inverse!
                               (|> expected /.negate /.negate (/.= expected))]
                           (and subtraction!
                                inverse!))))
              
              ..signature
              ..constant
              ..predicate
              ..conversion
              ))))
