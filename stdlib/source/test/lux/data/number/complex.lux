(.module:
  [lux #*
   ["%" data/text/format (#+ format)]
   ["_" test (#+ Test)]
   [abstract
    [monad (#+ do)]
    {[0 #spec]
     [/
      ["$." equivalence]
      ["$." order]
      ["$." codec]]}]
   [data
    [number
     ["n" nat]
     ["." int]
     ["f" frac]]
    [collection
     ["." list ("#\." functor)]]]
   ["." math
    ["." random (#+ Random)]]]
  {1
   ["." /]})

(def: margin-of-error
  +0.000000001)

(def: dimension
  (Random Frac)
  (do {! random.monad}
    [factor (|> random.nat (:: ! map (|>> (n.% 1000) (n.max 1))))
     measure (|> random.safe-frac (random.filter (f.> +0.0)))]
    (wrap (f.* (|> factor .int int.frac)
               measure))))

(def: #export random
  (Random /.Complex)
  (do random.monad
    [real ..dimension
     imaginary ..dimension]
    (wrap (/.complex real imaginary))))

(def: angle
  (Random /.Complex)
  (:: random.monad map
      (|>> (update@ #/.real (f.% +1.0))
           (update@ #/.imaginary (f.% +1.0)))
      ..random))

(def: construction
  Test
  (do random.monad
    [real ..dimension
     imaginary ..dimension]
    ($_ _.and
        (_.cover [/.complex]
                 (and (let [r+i (/.complex real imaginary)]
                        (and (f.= real (get@ #/.real r+i))
                             (f.= imaginary (get@ #/.imaginary r+i))))
                      (let [r+i (/.complex real)]
                        (and (f.= real (get@ #/.real r+i))
                             (f.= +0.0 (get@ #/.imaginary r+i))))))
        (_.cover [/.within?]
                 (/.within? ..margin-of-error
                            (/.complex real imaginary)
                            (/.complex real imaginary)))
        (_.cover [/.not-a-number?]
                 (and (/.not-a-number? (/.complex f.not-a-number imaginary))
                      (/.not-a-number? (/.complex real f.not-a-number))))
        )))

(def: constant
  Test
  (do random.monad
    [sample ..random
     dimension ..dimension]
    ($_ _.and
        (_.cover [/.zero]
                 (/.= /.zero (/.* /.zero sample)))
        (_.cover [/.+one]
                 (/.= sample (/.* /.+one sample)))
        (_.cover [/.-one]
                 (and (/.= /.zero
                           (/.+ sample
                                (/.* /.-one sample)))
                      (/.= sample (/.* /.-one (/.* /.-one sample)))))
        (_.cover [/.i]
                 (and (/.= (/.complex +0.0 dimension)
                           (/.* /.i (/.complex dimension)))
                      (/.= (/.* /.-one sample)
                           (/.* /.i (/.* /.i sample)))))
        )))

(def: absolute-value&argument
  Test
  (do random.monad
    [real ..dimension
     imaginary ..dimension]
    ($_ _.and
        (_.cover [/.abs]
                 (let [normal!
                       (let [r+i (/.complex real imaginary)]
                         (and (f.>= (f.abs real) (/.abs r+i))
                              (f.>= (f.abs imaginary) (/.abs r+i))))

                       not-a-number!
                       (and (f.not-a-number? (/.abs (/.complex f.not-a-number imaginary)))
                            (f.not-a-number? (/.abs (/.complex real f.not-a-number))))

                       infinity!
                       (and (f.= f.positive-infinity (/.abs (/.complex f.positive-infinity imaginary)))
                            (f.= f.positive-infinity (/.abs (/.complex real f.positive-infinity)))
                            (f.= f.positive-infinity (/.abs (/.complex f.negative-infinity imaginary)))
                            (f.= f.positive-infinity (/.abs (/.complex real f.negative-infinity))))]
                   (and normal!
                        not-a-number!
                        infinity!)))
        ## https://en.wikipedia.org/wiki/Argument_(complex_analysis)#Identities
        (_.cover [/.argument]
                 (let [sample (/.complex real imaginary)]
                   (or (/.= /.zero sample)
                       (/.within? ..margin-of-error
                                  sample
                                  (/.*' (/.abs sample)
                                        (/.exp (/.* /.i (/.complex (/.argument sample)))))))))
        )))

(def: number
  Test
  (do random.monad
    [x ..random
     y ..random
     factor ..dimension]
    ($_ _.and
        (_.cover [/.+]
                 (let [z (/.+ y x)]
                   (and (/.= z
                             (/.complex (f.+ (get@ #/.real y)
                                             (get@ #/.real x))
                                        (f.+ (get@ #/.imaginary y)
                                             (get@ #/.imaginary x)))))))
        (_.cover [/.-]
                 (let [normal!
                       (let [z (/.- y x)]
                         (and (/.= z
                                   (/.complex (f.- (get@ #/.real y)
                                                   (get@ #/.real x))
                                              (f.- (get@ #/.imaginary y)
                                                   (get@ #/.imaginary x))))))

                       inverse!
                       (and (|> x (/.+ y) (/.- y) (/.within? ..margin-of-error x))
                            (|> x (/.- y) (/.+ y) (/.within? ..margin-of-error x)))]
                   (and normal!
                        inverse!)))
        (_.cover [/.* /./]
                 (|> x (/.* y) (/./ y) (/.within? ..margin-of-error x)))
        (_.cover [/.*' /./']
                 (|> x (/.*' factor) (/./' factor) (/.within? ..margin-of-error x)))
        (_.cover [/.%]
                 (let [rem (/.% y x)
                       quotient (|> x (/.- rem) (/./ y))
                       floored (|> quotient
                                   (update@ #/.real math.floor)
                                   (update@ #/.imaginary math.floor))]
                   (/.within? +0.000000000001
                              x
                              (|> quotient (/.* y) (/.+ rem)))))
        )))

(def: conjugate&reciprocal&signum&negation
  Test
  (do random.monad
    [x ..random]
    ($_ _.and
        (_.cover [/.conjugate]
                 (let [cx (/.conjugate x)]
                   (and (f.= (get@ #/.real x)
                             (get@ #/.real cx))
                        (f.= (f.negate (get@ #/.imaginary x))
                             (get@ #/.imaginary cx)))))
        (_.cover [/.reciprocal]
                 (let [reciprocal!
                       (|> x (/.* (/.reciprocal x)) (/.within? ..margin-of-error /.+one))
                       
                       own-inverse!
                       (|> x /.reciprocal /.reciprocal (/.within? ..margin-of-error x))]
                   (and reciprocal!
                        own-inverse!)))
        (_.cover [/.signum]
                 ## Absolute value of signum is always root/2(2), 1 or 0.
                 (let [signum-abs (|> x /.signum /.abs)]
                   (or (f.= +0.0 signum-abs)
                       (f.= +1.0 signum-abs)
                       (f.= (math.pow +0.5 +2.0) signum-abs))))
        (_.cover [/.negate]
                 (let [own-inverse!
                       (let [there (/.negate x)
                             back-again (/.negate there)]
                         (and (not (/.= there x))
                              (/.= back-again x)))

                       absolute!
                       (f.= (/.abs x)
                            (/.abs (/.negate x)))]
                   (and own-inverse!
                        absolute!)))
        )))

(def: (trigonometric-symmetry forward backward angle)
  (-> (-> /.Complex /.Complex) (-> /.Complex /.Complex) /.Complex Bit)
  (let [normal (|> angle forward backward)]
    (|> normal forward backward (/.within? ..margin-of-error normal))))

(def: trigonometry
  Test
  (do {! random.monad}
    [angle ..angle]
    ($_ _.and
        (_.cover [/.sin /.asin]
                 (trigonometric-symmetry /.sin /.asin angle))
        (_.cover [/.cos /.acos]
                 (trigonometric-symmetry /.cos /.acos angle))
        (_.cover [/.tan /.atan]
                 (trigonometric-symmetry /.tan /.atan angle)))))

(def: hyperbolic
  Test
  (do {! random.monad}
    [angle ..angle]
    ($_ _.and
        (_.cover [/.sinh]
                 (/.within? ..margin-of-error
                            (|> angle (/.* /.i) /.sin (/.* /.i) (/.* /.-one))
                            (/.sinh angle)))
        (_.cover [/.cosh]
                 (/.within? ..margin-of-error
                            (|> angle (/.* /.i) /.cos)
                            (/.cosh angle)))
        (_.cover [/.tanh]
                 (/.within? ..margin-of-error
                            (|> angle (/.* /.i) /.tan (/.* /.i) (/.* /.-one))
                            (/.tanh angle)))
        )))

(def: exponentiation&logarithm
  Test
  (do random.monad
    [x ..random]
    ($_ _.and
        (_.cover [/.pow /.root/2]
                 (|> x (/.pow (/.complex +2.0)) /.root/2 (/.within? ..margin-of-error x)))
        (_.cover [/.pow']
                 (|> x (/.pow' +2.0) (/.pow' +0.5) (/.within? ..margin-of-error x)))
        (_.cover [/.log /.exp]
                 (|> x /.log /.exp (/.within? ..margin-of-error x)))
        )))

(def: root
  Test
  (do {! random.monad}
    [sample ..random
     degree (|> random.nat (:: ! map (|>> (n.max 1) (n.% 5))))]
    (_.cover [/.roots]
             (|> sample
                 (/.roots degree)
                 (list\map (/.pow' (|> degree .int int.frac)))
                 (list.every? (/.within? ..margin-of-error sample))))))

(def: #export test
  Test
  (<| (_.covering /._)
      (_.with-cover [/.Complex])
      ($_ _.and
          (_.with-cover [/.= /.equivalence]
            ($equivalence.spec /.equivalence ..random))

          ..construction
          ..constant
          ..absolute-value&argument
          ..number
          ..conjugate&reciprocal&signum&negation
          ..trigonometry
          ..hyperbolic
          ..exponentiation&logarithm
          ..root
          )))
