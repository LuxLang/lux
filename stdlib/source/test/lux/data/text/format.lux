(.using
 [library
  [lux "*"
   ["_" test (.only Test)]
   [abstract
    [monad (.only do)]
    [equivalence (.only Equivalence)]
    [functor
     [\\specification
      ["$[0]" contravariant]]]]
   [control
    ["[0]" try]]
   [data
    ["[0]" text ("[1]#[0]" equivalence)]
    ["[0]" bit]
    [format
     ["[0]" xml]
     ["[0]" json]]
    [collection
     ["[0]" list ("[1]#[0]" functor)]]]
   ["[0]" time
    ["[0]" day]
    ["[0]" month]
    ["[0]" instant]
    ["[0]" duration]
    ["[0]" date]]
   [math
    ["[0]" random (.only Random) ("[1]#[0]" monad)]
    ["[0]" modulus]
    ["[0]" modular]
    [number
     ["[0]" nat]
     ["[0]" int]
     ["[0]" rev]
     ["[0]" frac]
     ["[0]" ratio]]]
   [macro
    ["[0]" code]]
   [meta
    ["[0]" location]
    ["[0]" symbol]]
   ["[0]" type]]]
 ["$[0]" /// "_"
  [format
   ["[1][0]" xml]
   ["[1][0]" json]]
  [//
   ["[1][0]" type]
   [macro
    ["[1][0]" code]]
   [meta
    ["[1][0]" symbol]]]]
 [\\library
  ["[0]" /]])

(implementation: (equivalence example)
  (All (_ a) (-> a (Equivalence (/.Format a))))

  (def: (= reference subject)
    (text#= (reference example) (subject example))))

(def: random_contravariant
  (Random (Ex (_ a) [(/.Format a)
                     (Random a)]))
  (all random.either
       (random#in [/.bit random.bit])
       (random#in [/.nat random.nat])
       (random#in [/.int random.int])
       (random#in [/.rev random.rev])
       (random#in [/.frac random.frac])
       ))

(def: codec
  Test
  (`` (all _.and
           (~~ (template [<format> <codec> <random>]
                 [(do random.monad
                    [sample <random>]
                    (_.coverage [<format>]
                      (text#= (# <codec> encoded sample)
                              (<format> sample))))]

                 [/.bit bit.codec random.bit]
                 [/.nat nat.decimal random.nat]
                 [/.int int.decimal random.int]
                 [/.rev rev.decimal random.rev]
                 [/.frac frac.decimal random.frac]
                 [/.ratio ratio.codec random.ratio]
                 [/.symbol symbol.codec ($///symbol.random 5 5)]
                 [/.xml xml.codec $///xml.random]
                 [/.json json.codec $///json.random]
                 [/.day day.codec random.day]
                 [/.month month.codec random.month]
                 [/.instant instant.codec random.instant]
                 [/.duration duration.codec random.duration]
                 [/.date date.codec random.date]
                 [/.time time.codec random.time]
                 
                 [/.nat_2 nat.binary random.nat]
                 [/.nat_8 nat.octal random.nat]
                 [/.nat_10 nat.decimal random.nat]
                 [/.nat_16 nat.hex random.nat]
                 
                 [/.int_2 int.binary random.int]
                 [/.int_8 int.octal random.int]
                 [/.int_10 int.decimal random.int]
                 [/.int_16 int.hex random.int]
                 
                 [/.rev_2 rev.binary random.rev]
                 [/.rev_8 rev.octal random.rev]
                 [/.rev_10 rev.decimal random.rev]
                 [/.rev_16 rev.hex random.rev]
                 
                 [/.frac_2 frac.binary random.frac]
                 [/.frac_8 frac.octal random.frac]
                 [/.frac_10 frac.decimal random.frac]
                 [/.frac_16 frac.hex random.frac]
                 ))
           )))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Format])
      (`` (all _.and
               (_.for [/.functor]
                      (do random.monad
                        [[format random] ..random_contravariant
                         example random]
                        ($contravariant.spec (..equivalence example)
                                             format
                                             /.functor)))
               
               (do random.monad
                 [left (random.unicode 5)
                  mid (random.unicode 5)
                  right (random.unicode 5)]
                 (_.coverage [/.format]
                   (text#= (/.format left mid right)
                           (all "lux text concat" left mid right))))
               ..codec
               (~~ (template [<format> <alias> <random>]
                     [(do random.monad
                        [sample <random>]
                        (_.coverage [<format>]
                          (text#= (<alias> sample)
                                  (<format> sample))))]

                     [/.text text.format (random.unicode 5)]
                     [/.code code.format $///code.random]
                     [/.type type.format ($///type.random 0)]
                     [/.location location.format
                      (all random.and
                           (random.unicode 5)
                           random.nat
                           random.nat)]
                     ))
               (do random.monad
                 [members (random.list 5 random.nat)]
                 (_.coverage [/.list]
                   (text#= (/.list /.nat members)
                           (|> members
                               (list#each /.nat)
                               (text.interposed " ")
                               list
                               (/.list (|>>))))))
               (do random.monad
                 [sample (random.maybe random.nat)]
                 (_.coverage [/.maybe]
                   (case sample
                     {.#None}
                     true
                     
                     {.#Some value}
                     (text.contains? (/.nat value)
                                     (/.maybe /.nat sample)))))
               (do [! random.monad]
                 [modulus (random.one (|>> modulus.modulus
                                           try.maybe)
                                      random.int)
                  sample (# ! each (modular.modular modulus)
                            random.int)]
                 (_.coverage [/.mod]
                   (text#= (# (modular.codec modulus) encoded sample)
                           (/.mod sample))))
               ))))
