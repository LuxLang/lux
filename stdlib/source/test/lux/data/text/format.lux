(.module:
  [library
   [lux "*"
    ["_" test {"+" Test}]
    [abstract
     [monad {"+" do}]
     [equivalence {"+" Equivalence}]
     [functor
      [\\specification
       ["$[0]" contravariant]]]]
    [control
     ["[0]" try]]
    [data
     ["[0]" text ("[1]#[0]" equivalence)]
     ["[0]" bit]
     [format
      ["[0]" xml]
      ["[0]" json]]
     [collection
      ["[0]" list ("[1]#[0]" functor)]]]
    ["[0]" time
     ["[0]" day]
     ["[0]" month]
     ["[0]" instant]
     ["[0]" duration]
     ["[0]" date]]
    [math
     ["[0]" random {"+" Random} ("[1]#[0]" monad)]
     ["[0]" modulus]
     ["[0]" modular]
     [number
      ["[0]" nat]
      ["[0]" int]
      ["[0]" rev]
      ["[0]" frac]
      ["[0]" ratio]]]
    [macro
     ["[0]" code]]
    [meta
     ["[0]" location]
     ["[0]" symbol]]
    ["[0]" type]]]
  ["$[0]" /// "_"
   [format
    ["[1][0]" xml]
    ["[1][0]" json]]
   [//
    ["[1][0]" type]
    [macro
     ["[1][0]" code]]
    [meta
     ["[1][0]" symbol]]]]
  [\\library
   ["[0]" /]])

(implementation: (equivalence example)
  (All (_ a) (-> a (Equivalence (/.Format a))))

  (def: (= reference subject)
    (text#= (reference example) (subject example))))

(def: random_contravariant
  (Random (Ex (_ a) [(/.Format a)
                     (Random a)]))
  ($_ random.either
      (random#in [/.bit random.bit])
      (random#in [/.nat random.nat])
      (random#in [/.int random.int])
      (random#in [/.rev random.rev])
      (random#in [/.frac random.frac])
      ))

(def: codec
  Test
  (`` ($_ _.and
          (~~ (template [<format> <codec> <random>]
                [(do random.monad
                   [sample <random>]
                   (_.cover [<format>]
                            (text#= (# <codec> encoded sample)
                                    (<format> sample))))]

                [/.bit bit.codec random.bit]
                [/.nat nat.decimal random.nat]
                [/.int int.decimal random.int]
                [/.rev rev.decimal random.rev]
                [/.frac frac.decimal random.frac]
                [/.ratio ratio.codec random.ratio]
                [/.symbol symbol.codec ($///symbol.random 5 5)]
                [/.xml xml.codec $///xml.random]
                [/.json json.codec $///json.random]
                [/.day day.codec random.day]
                [/.month month.codec random.month]
                [/.instant instant.codec random.instant]
                [/.duration duration.codec random.duration]
                [/.date date.codec random.date]
                [/.time time.codec random.time]
                
                [/.nat/2 nat.binary random.nat]
                [/.nat/8 nat.octal random.nat]
                [/.nat/10 nat.decimal random.nat]
                [/.nat/16 nat.hex random.nat]
                
                [/.int/2 int.binary random.int]
                [/.int/8 int.octal random.int]
                [/.int/10 int.decimal random.int]
                [/.int/16 int.hex random.int]
                
                [/.rev/2 rev.binary random.rev]
                [/.rev/8 rev.octal random.rev]
                [/.rev/10 rev.decimal random.rev]
                [/.rev/16 rev.hex random.rev]
                
                [/.frac/2 frac.binary random.frac]
                [/.frac/8 frac.octal random.frac]
                [/.frac/10 frac.decimal random.frac]
                [/.frac/16 frac.hex random.frac]
                ))
          )))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Format])
      (`` ($_ _.and
              (_.for [/.functor]
                     (do random.monad
                       [[format random] ..random_contravariant
                        example random]
                       ($contravariant.spec (..equivalence example)
                                            format
                                            /.functor)))
              
              (do random.monad
                [left (random.unicode 5)
                 mid (random.unicode 5)
                 right (random.unicode 5)]
                (_.cover [/.format]
                         (text#= (/.format left mid right)
                                 ($_ "lux text concat" left mid right))))
              ..codec
              (~~ (template [<format> <alias> <random>]
                    [(do random.monad
                       [sample <random>]
                       (_.cover [<format>]
                                (text#= (<alias> sample)
                                        (<format> sample))))]

                    [/.text text.format (random.unicode 5)]
                    [/.code code.format $///code.random]
                    [/.type type.format ($///type.random 0)]
                    [/.location location.format
                     ($_ random.and
                         (random.unicode 5)
                         random.nat
                         random.nat)]
                    ))
              (do random.monad
                [members (random.list 5 random.nat)]
                (_.cover [/.list]
                         (text#= (/.list /.nat members)
                                 (|> members
                                     (list#each /.nat)
                                     (text.interposed " ")
                                     list
                                     (/.list (|>>))))))
              (do random.monad
                [sample (random.maybe random.nat)]
                (_.cover [/.maybe]
                         (case sample
                           {.#None}
                           true
                           
                           {.#Some value}
                           (text.contains? (/.nat value)
                                           (/.maybe /.nat sample)))))
              (do [! random.monad]
                [modulus (random.one (|>> modulus.modulus
                                          try.maybe)
                                     random.int)
                 sample (# ! each (modular.modular modulus)
                           random.int)]
                (_.cover [/.mod]
                         (text#= (# (modular.codec modulus) encoded sample)
                                 (/.mod sample))))
              ))))
