(.module:
  [lux #*
   ["_" test (#+ Test)]
   [abstract
    [monad (#+ do)]
    {[0 #spec]
     [/
      ["$." equivalence]]}]
   [data
    ["." product]
    ["." bit ("#\." equivalence)]
    [number
     ["n" nat]]
    [collection
     ["." set ("#\." equivalence)]]]
   [math
    ["." random (#+ Random)]]]
  ["." / #_
   ["#." segment]]
  {1
   ["." /
    ["." segment]]})

(def: #export random
  (Random /.Set)
  (do {! random.monad}
    [left /segment.random
     right /segment.random]
    (wrap (/.set [left (list right)]))))

(def: #export test
  Test
  (<| (_.covering /._)
      (_.for [/.Set])
      (do {! random.monad}
        [segment /segment.random
         inside (\ ! map
                   (|>> (n.% (segment.size segment))
                        (n.+ (segment.start segment)))
                   random.nat)
         left /segment.random
         right /segment.random
         #let [equivalence (product.equivalence n.equivalence
                                                n.equivalence)]]
        (`` ($_ _.and
                (_.for [/.equivalence]
                       ($equivalence.spec /.equivalence ..random))
                
                (_.cover [/.range]
                         (let [[start end] (/.range (/.set [left (list right)]))]
                           (and (n.= (n.min (segment.start left)
                                            (segment.start right))
                                     start)
                                (n.= (n.max (segment.end left)
                                            (segment.end right))
                                     end))))
                (_.cover [/.member?]
                         (bit\= (segment.within? segment inside)
                                (/.member? (/.set [segment (list)]) inside)))
                (_.cover [/.compose]
                         (\ equivalence =
                            [(n.min (segment.start left)
                                    (segment.start right))
                             (n.max (segment.end left)
                                    (segment.end right))]
                            (/.range (/.compose (/.set [left (list)])
                                                (/.set [right (list)])))))
                (_.cover [/.set]
                         (\ equivalence =
                            (/.range (/.compose (/.set [left (list)])
                                                (/.set [right (list)])))
                            (/.range (/.set [left (list right)]))))
                (~~ (template [<set>]
                      [(do random.monad
                         [char (random.char <set>)
                          #let [[start end] (/.range <set>)]]
                         (_.cover [<set>]
                                  (and (/.member? <set> char)
                                       (not (/.member? <set> (dec start)))
                                       (not (/.member? <set> (inc end))))))]

                      [/.ascii]
                      [/.ascii/alpha]
                      [/.ascii/alpha-num]
                      [/.ascii/lower-alpha]
                      [/.ascii/upper-alpha]
                      [/.full]
                      ))

                /segment.test
                )))))
