(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   ["[0]" debug]
   ["[0]" meta]
   [abstract
    [monad {"+" do}]]
   [control
    ["[0]" try]
    ["[0]" exception]
    [parser
     ["<[0]>" code]]]
   [data
    ["[0]" bit ("[1]#[0]" equivalence)]
    ["[0]" text {"+" Char} ("[1]#[0]" equivalence)
     ["%" format {"+" format}]]
    [collection
     ["[0]" set {"+" Set}]]]
   [macro
    [syntax {"+" syntax:}]
    ["[0]" code]
    ["[0]" template]]
   [math
    ["[0]" random {"+" Random}]
    [number {"+" hex}
     ["n" nat]]]]]
 [\\library
  ["[0]" /
   [//
    ["[0]" unicode "_"
     ["[1]" set]]]]])

(def: (range max min)
  (-> Char Char (Random Char))
  (let [range (n.- min max)]
    (# random.monad each
       (|>> (n.% range) (n.+ min))
       random.nat)))

(def: under_range
  (Random Char)
  (..range (debug.private /.ascii_bottom) 0))

(def: over_range
  (Random Char)
  (..range (hex "FFFF") (++ (debug.private /.ascii_top))))

(def: in_range
  (Random Char)
  (..range (++ (debug.private /.ascii_top)) (debug.private /.ascii_bottom)))

(def: ascii_range
  (Random Char)
  (..range (++ (debug.private /.ascii_top)) 0))

(def: valid_sigils
  (Set Char)
  (set.of_list n.hash
               (list (debug.private /.\0_sigil)
                     (debug.private /.\a_sigil)
                     (debug.private /.\b_sigil)
                     (debug.private /.\t_sigil)
                     (debug.private /.\n_sigil)
                     (debug.private /.\v_sigil)
                     (debug.private /.\f_sigil)
                     (debug.private /.\r_sigil)
                     (debug.private /.\''_sigil)
                     (debug.private /.\\_sigil)
                     (debug.private /.\u_sigil))))

(syntax: (static_sample [])
  (do meta.monad
    [seed meta.seed
     .let [[_ expected] (random.result (random.pcg_32 [seed seed])
                                       (random.ascii 10))]]
    (in (list (code.text expected)))))

(syntax: (static_escaped [un_escaped <code>.text])
  (in (list (code.text (/.escaped un_escaped)))))

(def: .public test
  Test
  (<| (_.covering /._)
      (all _.and
           (do random.monad
             [ascii ..ascii_range]
             (_.coverage [/.escapable?]
               (`` (if (or (~~ (template [<char>]
                                 [(n.= (debug.private <char>) ascii)]
                                 
                                 [/.\0] [/.\a] [/.\b] [/.\t]
                                 [/.\n] [/.\v] [/.\f] [/.\r]
                                 [/.\''] [/.\\])))
                     (/.escapable? ascii)
                     (bit#= (/.escapable? ascii)
                            (or (n.< (debug.private /.ascii_bottom) ascii)
                                (n.> (debug.private /.ascii_top) ascii)))))))
           (do random.monad
             [left (random.char unicode.character)
              right (random.char unicode.character)]
             (_.coverage [/.escaped /.un_escaped]
               (let [expected (format (text.of_char left) (text.of_char right))]
                 (if (or (/.escapable? left)
                         (/.escapable? right))
                   (let [escaped (/.escaped expected)]
                     (case (/.un_escaped escaped)
                       {try.#Success un_escaped}
                       (and (not (text#= escaped expected))
                            (text#= un_escaped expected))
                       
                       {try.#Failure error}
                       false))
                   (text#= expected (/.escaped expected))))))
           (do [! random.monad]
             [dummy (|> (random.char unicode.character)
                        (# ! each text.of_char))]
             (_.coverage [/.dangling_escape]
               (case (/.un_escaped (format (/.escaped dummy) "\"))
                 {try.#Success _}
                 false

                 {try.#Failure error}
                 (exception.match? /.dangling_escape error))))
           (do [! random.monad]
             [dummy (|> (random.char unicode.character)
                        (random.only (|>> (set.member? ..valid_sigils) not))
                        (# ! each text.of_char))]
             (_.coverage [/.invalid_escape]
               (case (/.un_escaped (format "\" dummy))
                 {try.#Success _}
                 false

                 {try.#Failure error}
                 (exception.match? /.invalid_escape error))))
           (do [! random.monad]
             [too_short (|> (random.char unicode.character)
                            (# ! each (n.% (hex "1000"))))
              code (|> (random.unicode 4)
                       (random.only (function (_ code)
                                      (case (# n.hex decoded code)
                                        {try.#Failure error} true
                                        {try.#Success _} false))))]
             (_.coverage [/.invalid_unicode_escape]
               (template.let [(!invalid <code>)
                              [(case (/.un_escaped (format "\u" <code>))
                                 {try.#Success _}
                                 false

                                 {try.#Failure error}
                                 (exception.match? /.invalid_unicode_escape error))]]
                 (and (!invalid (# n.hex encoded too_short))
                      (!invalid code)))))
           (_.coverage [/.literal]
             (with_expansions [<example> (..static_sample)]
               (text#= <example> (`` (/.literal (~~ (..static_escaped <example>)))))))
           )))
