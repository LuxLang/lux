(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    [abstract
     [monad {"+" [do]}]
     [\\specification
      ["$." equivalence]]]
    [data
     ["." product]
     ["." bit ("#\." equivalence)]
     [collection
      ["." set ("#\." equivalence)]]]
    [math
     ["." random {"+" [Random]}]
     [number
      ["n" nat]]]]]
  ["." / "_"
   ["/#" // "_"
    ["#." block]]]
  [\\library
   ["." /
    [//
     ["." block]]]])

(def: .public random
  (Random /.Set)
  (do {! random.monad}
    [left //block.random
     right //block.random]
    (in (/.set [left (list right)]))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Set])
      (do {! random.monad}
        [block //block.random
         inside (\ ! each
                   (|>> (n.% (block.size block))
                        (n.+ (block.start block)))
                   random.nat)
         left //block.random
         right //block.random
         .let [equivalence (product.equivalence n.equivalence
                                                n.equivalence)]]
        (`` ($_ _.and
                (_.for [/.equivalence]
                       ($equivalence.spec /.equivalence ..random))
                
                (_.cover [/.set]
                         (and (n.= (block.start left)
                                   (/.start (/.set [left (list)])))
                              (n.= (block.end left)
                                   (/.end (/.set [left (list)])))))
                (_.cover [/.start]
                         (n.= (n.min (block.start left)
                                     (block.start right))
                              (/.start (/.set [left (list right)]))))
                (_.cover [/.end]
                         (n.= (n.max (block.end left)
                                     (block.end right))
                              (/.end (/.set [left (list right)]))))
                (_.cover [/.member?]
                         (bit\= (block.within? block inside)
                                (/.member? (/.set [block (list)]) inside)))
                (_.cover [/.composite]
                         (let [composed (/.composite (/.set [left (list)])
                                                     (/.set [right (list)]))]
                           (and (n.= (n.min (block.start left)
                                            (block.start right))
                                     (/.start composed))
                                (n.= (n.max (block.end left)
                                            (block.end right))
                                     (/.end composed)))))
                (~~ (template [<set>]
                      [(do random.monad
                         [char (random.char <set>)
                          .let [start (/.start <set>)
                                end (/.end <set>)]]
                         (_.cover [<set>]
                                  (and (/.member? <set> char)
                                       (not (/.member? <set> (-- start)))
                                       (not (/.member? <set> (++ end))))))]

                      [/.ascii]
                      [/.ascii/alpha]
                      [/.ascii/alpha_num]
                      [/.ascii/lower]
                      [/.ascii/upper]
                      [/.ascii/numeric]
                      [/.character]
                      [/.non_character]
                      [/.full]
                      ))

                //block.test
                )))))
