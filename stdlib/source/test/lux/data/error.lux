(.module:
  [lux #*
   ["_" test (#+ Test)]
   ["." io]
   [control
    pipe
    [monad (#+ do Monad)]
    {[0 #test]
     [/
      [".T" functor (#+ Injection Comparison)]
      [".T" apply]
      [".T" monad]
      [".T" equivalence]]}]
   [data
    text/format
    [number
     ["." nat]]]
   [math
    ["r" random (#+ Random)]]]
  {1
   ["." / (#+ Error)]})

(def: injection
  (Injection Error)
  (|>> #/.Success))

(def: comparison
  (Comparison Error)
  (function (_ ==)
    (:: (/.equivalence ==) =)))

(def: #export (error element)
  (All [a] (-> (Random a) (Random (Error a))))
  ($_ r.or
      (r.ascii 10)
      element))

(def: #export test
  Test
  (<| (_.context (%name (name-of /.Error)))
      ($_ _.and
          (equivalenceT.test (/.equivalence nat.equivalence) (..error r.nat))
          (functorT.laws ..injection ..comparison /.functor)
          (applyT.laws ..injection ..comparison /.apply)
          (monadT.laws ..injection ..comparison /.monad)
          (do r.monad
            [left r.nat
             right r.nat
             #let [expected (n/+ left right)
                   (^open "io@.") io.monad]]
            (let []
              (_.test "Can add error functionality to any monad."
                      (let [lift (/.lift io.monad)]
                        (|> (do (/.with io.monad)
                              [a (lift (io@wrap left))
                               b (wrap right)]
                              (wrap (n/+ a b)))
                            io.run
                            (case> (#/.Success actual)
                                   (n/= expected actual)

                                   _
                                   #0))))))
          )))
