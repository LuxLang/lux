(.module:
  [lux #*
   ["_" test (#+ Test)]
   ["." io]
   [control
    pipe
    [monad (#+ do Monad)]
    {[0 #test]
     [/
      ["$." functor (#+ Injection Comparison)]
      ["$." apply]
      ["$." monad]
      ["$." equivalence]]}]
   [data
    text/format
    [number
     ["." nat]]]
   [math
    ["r" random (#+ Random)]]]
  {1
   ["." / (#+ Error)]})

(def: injection
  (Injection Error)
  (|>> #/.Success))

(def: comparison
  (Comparison Error)
  (function (_ ==)
    (:: (/.equivalence ==) =)))

(def: #export (error element)
  (All [a] (-> (Random a) (Random (Error a))))
  ($_ r.or
      (:: r.monad wrap "KABOOM!")
      element))

(def: #export test
  Test
  (<| (_.context (%name (name-of /.Error)))
      ($_ _.and
          ($equivalence.spec (/.equivalence nat.equivalence) (..error r.nat))
          ($functor.spec ..injection ..comparison /.functor)
          ($apply.spec ..injection ..comparison /.apply)
          ($monad.spec ..injection ..comparison /.monad)
          (do r.monad
            [left r.nat
             right r.nat
             #let [expected (n/+ left right)
                   (^open "io@.") io.monad]]
            (let []
              (_.test "Can add error functionality to any monad."
                      (let [lift (/.lift io.monad)]
                        (|> (do (/.with io.monad)
                              [a (lift (io@wrap left))
                               b (wrap right)]
                              (wrap (n/+ a b)))
                            io.run
                            (case> (#/.Success actual)
                                   (n/= expected actual)

                                   _
                                   #0))))))
          )))
