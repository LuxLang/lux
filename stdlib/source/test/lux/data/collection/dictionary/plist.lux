(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]
    [\\specification
     ["$[0]" equivalence]
     ["$[0]" monoid]]]
   [control
    ["[0]" maybe ("[1]#[0]" monad)]]
   [data
    ["[0]" bit ("[1]#[0]" equivalence)]
    ["[0]" text]
    [collection
     ["[0]" set]
     ["[0]" list]]]
   [math
    ["[0]" random {"+" Random}]
    [number
     ["n" nat]]]]]
 [\\library
  ["[0]" /]])

(def: .public (random size gen_key gen_value)
  (All (_ v)
    (-> Nat (Random Text) (Random v) (Random (/.PList v))))
  (do random.monad
    [keys (random.set text.hash size gen_key)
     values (random.list size gen_value)]
    (in (list.zipped_2 (set.list keys) values))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.PList])
      (do [! random.monad]
        [.let [gen_key (random.alphabetic 10)]
         size (# ! each (n.% 100) random.nat)
         sample (..random size gen_key random.nat)

         .let [keys (|> sample /.keys (set.of_list text.hash))]
         extra_key (random.only (|>> (set.member? keys) not)
                                gen_key)
         extra_value random.nat
         shift random.nat]
        (all _.and
             (_.for [/.equivalence]
                    ($equivalence.spec (/.equivalence n.equivalence)
                                       (..random size gen_key random.nat)))
             (_.for [/.monoid]
                    ($monoid.spec (/.equivalence n.equivalence)
                                  /.monoid
                                  (..random 10 (random.lower_case 1) random.nat)))
             
             (_.cover [/.size]
                      (n.= size (/.size sample)))
             (_.cover [/.empty?]
                      (bit#= (n.= 0 (/.size sample))
                             (/.empty? sample)))
             (_.cover [/.empty]
                      (/.empty? /.empty))
             (_.cover [/.keys /.values]
                      (# (/.equivalence n.equivalence) =
                         sample
                         (list.zipped_2 (/.keys sample)
                                        (/.values sample))))
             (_.cover [/.contains?]
                      (and (list.every? (function (_ key)
                                          (/.contains? key sample))
                                        (/.keys sample))
                           (not (/.contains? extra_key sample))))
             (_.cover [/.has]
                      (let [sample+ (/.has extra_key extra_value sample)]
                        (and (not (/.contains? extra_key sample))
                             (/.contains? extra_key sample+)
                             (n.= (++ (/.size sample))
                                  (/.size sample+)))))
             (_.cover [/.value]
                      (|> sample
                          (/.has extra_key extra_value)
                          (/.value extra_key)
                          (maybe#each (n.= extra_value))
                          (maybe.else false)))
             (_.cover [/.revised]
                      (|> sample
                          (/.has extra_key extra_value)
                          (/.revised extra_key (n.+ shift))
                          (/.value extra_key)
                          (maybe#each (n.= (n.+ shift extra_value)))
                          (maybe.else false)))
             (_.cover [/.lacks]
                      (|> sample
                          (/.has extra_key extra_value)
                          (/.lacks extra_key)
                          (# (/.equivalence n.equivalence) = sample)))
             ))))
