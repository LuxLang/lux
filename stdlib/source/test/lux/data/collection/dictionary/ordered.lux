(.module:
  [lux #*
   ["_" test (#+ Test)]
   [abstract
    [monad (#+ do)]
    [equivalence (#+ Equivalence)]
    [order (#+ Order)]
    {[0 #spec]
     [/
      ["$." equivalence]]}]
   [data
    ["." product]
    ["." bit ("#\." equivalence)]
    ["." maybe ("#\." monad)]
    [number
     ["n" nat]]
    [collection
     ["." set]
     ["." list ("#\." functor)]]]
   [math
    ["." random (#+ Random) ("#\." monad)]]]
  {1
   ["." /]})

(def: #export (dictionary order gen-key gen-value size)
  (All [k v]
    (-> (Order k) (Random k) (Random v) Nat (Random (/.Dictionary k v))))
  (case size
    0
    (random\wrap (/.new order))
    
    _
    (do random.monad
      [partial (dictionary order gen-key gen-value (dec size))
       key (random.filter (|>> (/.key? partial) not)
                          gen-key)
       value gen-value]
      (wrap (/.put key value partial)))))

(def: #export test
  Test
  (<| (_.covering /._)
      (_.with-cover [/.Dictionary])
      (do {! random.monad}
        [size (\ ! map (n.% 100) random.nat)
         keys (random.set n.hash size random.nat)
         values (random.set n.hash size random.nat)
         extra-key (random.filter (|>> (set.member? keys) not)
                                  random.nat)
         extra-value random.nat
         shift random.nat
         #let [pairs (list.zip/2 (set.to-list keys)
                                 (set.to-list values))
               sample (/.from-list n.order pairs)
               sorted-pairs (list.sort (function (_ [left _] [right _])
                                         (n.< left right))
                                       pairs)
               sorted-values (list\map product.right sorted-pairs)
               (^open "list\.") (list.equivalence (: (Equivalence [Nat Nat])
                                                     (function (_ [kr vr] [ks vs])
                                                       (and (n.= kr ks)
                                                            (n.= vr vs)))))
               (^open "/\.") (/.equivalence n.equivalence)]]
        ($_ _.and
            (_.with-cover [/.equivalence]
              ($equivalence.spec (/.equivalence n.equivalence) (..dictionary n.order random.nat random.nat size)))
            
            (_.cover [/.size]
                     (n.= size (/.size sample)))
            (_.cover [/.empty?]
                     (bit\= (n.= 0 (/.size sample))
                            (/.empty? sample)))
            (_.cover [/.new]
                     (/.empty? (/.new n.order)))
            (_.cover [/.min]
                     (case [(/.min sample) (list.head sorted-values)]
                       [#.None #.None]
                       #1

                       [(#.Some reference) (#.Some sample)]
                       (n.= reference sample)

                       _
                       #0))
            (_.cover [/.max]
                     (case [(/.max sample) (list.last sorted-values)]
                       [#.None #.None]
                       #1

                       [(#.Some reference) (#.Some sample)]
                       (n.= reference sample)

                       _
                       #0))
            (_.cover [/.entries]
                     (list\= (/.entries sample)
                             sorted-pairs))
            (_.cover [/.keys /.values]
                     (list\= (/.entries sample)
                             (list.zip/2 (/.keys sample) (/.values sample))))
            (_.cover [/.from-list]
                     (|> sample
                         /.entries (/.from-list n.order)
                         (/\= sample)))
            (_.cover [/.key?]
                     (and (list.every? (/.key? sample)
                                       (/.keys sample))
                          (not (/.key? sample extra-key))))
            (_.cover [/.put]
                     (and (not (/.key? sample extra-key))
                          (let [sample+ (/.put extra-key extra-value sample)]
                            (and (/.key? sample+ extra-key)
                                 (n.= (inc (/.size sample))
                                      (/.size sample+))))))
            (_.cover [/.get]
                     (let [sample+ (/.put extra-key extra-value sample)]
                       (case [(/.get extra-key sample)
                              (/.get extra-key sample+)]
                         [#.None (#.Some actual)]
                         (n.= extra-value actual)
                         
                         _
                         false)))
            (_.cover [/.remove]
                     (|> sample
                         (/.put extra-key extra-value)
                         (/.remove extra-key)
                         (/\= sample)))
            (_.cover [/.update]
                     (|> sample
                         (/.put extra-key extra-value)
                         (/.update extra-key (n.+ shift))
                         (/.get extra-key)
                         (maybe\map (n.= (n.+ shift extra-value)))
                         (maybe.default false)))
            ))))
