(.module:
  [lux #*
   ["_" test (#+ Test)]
   [abstract
    [hash (#+ Hash)]
    [monad (#+ do)]
    {[0 #spec]
     [/
      ["$." equivalence]
      ["$." monoid]]}]
   [data
    ["." bit ("#\." equivalence)]
    [number
     ["n" nat]]
    [collection
     ["." list]]]
   [math
    ["." random (#+ Random)]]]
  {1
   ["." / ("\." equivalence)]})

(def: gen-nat
  (Random Nat)
  (\ random.monad map (n.% 100)
     random.nat))

(def: #export test
  Test
  (<| (_.covering /._)
      (_.for [/.Set])
      (do {! random.monad}
        [size ..gen-nat]
        ($_ _.and
            (_.for [/.equivalence]
                   ($equivalence.spec /.equivalence (random.set n.hash size random.nat)))
            (_.for [/.monoid]
                   ($monoid.spec /.equivalence (/.monoid n.hash) (random.set n.hash size random.nat)))

            (do !
              [sizeL ..gen-nat
               sizeR ..gen-nat
               setL (random.set n.hash sizeL random.nat)
               setR (random.set n.hash sizeR random.nat)
               non-memberL (random.filter (|>> (/.member? setL) not)
                                          random.nat)]
              ($_ _.and
                  (_.cover [/.new]
                           (/.empty? (/.new n.hash)))
                  (do !
                    [hash (\ ! map (function (_ constant)
                                     (: (Hash Nat)
                                        (structure
                                         (def: &equivalence n.equivalence)
                                         
                                         (def: (hash _)
                                           constant))))
                             random.nat)]
                    (_.cover [/.member-hash]
                             (is? hash (/.member-hash (/.new hash)))))
                  (_.cover [/.size]
                           (n.= sizeL (/.size setL)))
                  (_.cover [/.empty?]
                           (bit\= (/.empty? setL)
                                  (n.= 0 (/.size setL))))
                  (_.cover [/.to-list /.from-list]
                           (|> setL /.to-list (/.from-list n.hash) (\= setL)))
                  (_.cover [/.member?]
                           (and (list.every? (/.member? setL) (/.to-list setL))
                                (not (/.member? setL non-memberL))))
                  (_.cover [/.add]
                           (let [before-addition!
                                 (not (/.member? setL non-memberL))

                                 after-addition!
                                 (/.member? (/.add non-memberL setL) non-memberL)

                                 size-increase!
                                 (n.= (inc (/.size setL))
                                      (/.size (/.add non-memberL setL)))]
                             (and before-addition!
                                  after-addition!)))
                  (_.cover [/.remove]
                           (let [symmetry!
                                 (|> setL
                                     (/.add non-memberL)
                                     (/.remove non-memberL)
                                     (\= setL))

                                 idempotency!
                                 (|> setL
                                     (/.remove non-memberL)
                                     (\= setL))]
                             (and symmetry!
                                  idempotency!)))
                  (_.cover [/.union /.sub?]
                           (let [setLR (/.union setL setR)
                                 
                                 sets-are-subs-of-their-unions!
                                 (and (/.sub? setLR setL)
                                      (/.sub? setLR setR))

                                 union-with-empty-set!
                                 (|> setL
                                     (/.union (/.new n.hash))
                                     (\= setL))]
                             (and sets-are-subs-of-their-unions!
                                  union-with-empty-set!)))
                  (_.cover [/.intersection /.super?]
                           (let [setLR (/.intersection setL setR)
                                 
                                 sets-are-supers-of-their-intersections!
                                 (and (/.super? setLR setL)
                                      (/.super? setLR setR))

                                 intersection-with-empty-set!
                                 (|> setL
                                     (/.intersection (/.new n.hash))
                                     /.empty?)]
                             (and sets-are-supers-of-their-intersections!
                                  intersection-with-empty-set!)))
                  (_.cover [/.difference]
                           (let [setL+R (/.union setR setL)
                                 setL-R (/.difference setR setL+R)]
                             (and (list.every? (/.member? setL+R) (/.to-list setR))
                                  (not (list.any? (/.member? setL-R) (/.to-list setR))))))
                  (_.cover [/.predicate]
                           (list.every? (/.predicate setL) (/.to-list setL)))
                  ))))))
