(.module:
  [lux #*
   data/text/format
   ["_" test (#+ Test)]
   [control
    [monad (#+ do)]
    {[0 #test]
     [/
      ["$." equivalence]
      ["$." monoid]
      ["$." fold]
      ["$." functor (#+ Injection)]
      ["$." apply]
      ["$." monad]]}]
   [data
    ["." maybe]
    [number
     ["." nat]]
    [collection
     ["." list ("#@." fold)]]]
   [math
    ["r" random]]]
  {1
   ["." / ("#@." monad)]})

(def: #export test
  Test
  (<| (_.context (%name (name-of /.Row)))
      (do r.monad
        [size (|> r.nat (:: @ map (|>> (n/% 100) (n/max 1))))]
        ($_ _.and
            ($equivalence.spec (/.equivalence nat.equivalence) (r.row size r.nat))
            ($monoid.spec (/.equivalence nat.equivalence) /.monoid (r.row size r.nat))
            ($fold.spec /@wrap /.equivalence /.fold)
            ($functor.spec /@wrap /.equivalence /.functor)
            ($apply.spec /@wrap /.equivalence /.apply)
            ($monad.spec /@wrap /.equivalence /.monad)

            (do @
              [idx (|> r.nat (:: @ map (n/% size)))
               sample (r.row size r.nat)
               other-sample (r.row size r.nat)
               non-member (|> r.nat (r.filter (|>> (/.member? nat.equivalence sample) not)))
               #let [(^open "/@.") (/.equivalence nat.equivalence)]]
              ($_ _.and
                  (_.test "Can query size of row."
                          (if (/.empty? sample)
                            (and (n/= 0 size)
                                 (n/= 0 (/.size sample)))
                            (n/= size (/.size sample))))
                  (_.test "Can add and remove elements to rows."
                          (and (n/= (inc size) (/.size (/.add non-member sample)))
                               (n/= (dec size) (/.size (/.pop sample)))))
                  (_.test "Can put and get elements into rows."
                          (|> sample
                              (/.put idx non-member)
                              (/.nth idx)
                              maybe.assume
                              (is? non-member)))
                  (_.test "Can update elements of rows."
                          (|> sample
                              (/.put idx non-member) (/.update idx inc)
                              (/.nth idx) maybe.assume
                              (n/= (inc non-member))))
                  (_.test "Can safely transform to/from lists."
                          (|> sample /.to-list /.from-list (/@= sample)))
                  (_.test "Can identify members of a row."
                          (and (not (/.member? nat.equivalence sample non-member))
                               (/.member? nat.equivalence (/.add non-member sample) non-member)))
                  (_.test "Can reverse."
                          (and (not (/@= sample
                                         (/.reverse sample)))
                               (not (/@= sample
                                         (/.reverse (/.reverse sample))))))
                  ))
            ))))
