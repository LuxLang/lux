(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    [abstract
     [monad {"+" [do]}]
     [\\specification
      ["$[0]" equivalence]
      ["$[0]" monoid]
      ["$[0]" mix]
      ["$[0]" functor {"+" [Injection]}]
      ["$[0]" apply]
      ["$[0]" monad]]]
    [control
     ["[0]" try {"+" [Try]}]
     ["[0]" exception]]
    [data
     ["[0]" bit ("[1]\[0]" equivalence)]
     [collection
      ["[0]" list ("[1]\[0]" mix)]
      ["[0]" set]]]
    [math
     ["[0]" random]
     [number
      ["n" nat]]]]]
  [\\library
   ["[0]" / ("[1]\[0]" monad)]])

(def: signatures
  Test
  (do [! random.monad]
    [size (\ ! each (n.% 100) random.nat)]
    ($_ _.and
        (_.for [/.equivalence]
               ($equivalence.spec (/.equivalence n.equivalence) (random.row size random.nat)))
        (_.for [/.monoid]
               ($monoid.spec (/.equivalence n.equivalence) /.monoid (random.row size random.nat)))
        (_.for [/.mix]
               ($mix.spec /\in /.equivalence /.mix))
        (_.for [/.functor]
               ($functor.spec /\in /.equivalence /.functor))
        (_.for [/.apply]
               ($apply.spec /\in /.equivalence /.apply))
        (_.for [/.monad]
               ($monad.spec /\in /.equivalence /.monad))
        )))

(def: whole
  Test
  (do [! random.monad]
    [size (\ ! each (n.% 100) random.nat)
     sample (random.set n.hash size random.nat)
     .let [sample (|> sample set.list /.of_list)]
     .let [(^open "/\[0]") (/.equivalence n.equivalence)]]
    ($_ _.and
        (_.cover [/.size]
                 (n.= size (/.size sample)))
        (_.cover [/.empty?]
                 (bit\= (/.empty? sample) (n.= 0 (/.size sample))))
        (_.cover [/.empty]
                 (/.empty? /.empty))
        (_.cover [/.list /.of_list]
                 (|> sample /.list /.of_list (/\= sample)))
        (_.cover [/.reversed]
                 (or (n.< 2 (/.size sample))
                     (let [not_same!
                           (not (/\= sample
                                     (/.reversed sample)))

                           self_symmetry!
                           (/\= sample
                                (/.reversed (/.reversed sample)))]
                       (and not_same!
                            self_symmetry!))))
        (_.cover [/.every? /.any?]
                 (if (/.every? n.even? sample)
                   (not (/.any? (bit.complement n.even?) sample))
                   (/.any? (bit.complement n.even?) sample)))
        )))

(def: index_based
  Test
  (do [! random.monad]
    [size (\ ! each (|>> (n.% 100) ++) random.nat)]
    ($_ _.and
        (do !
          [good_index (|> random.nat (\ ! each (n.% size)))
           .let [bad_index (n.+ size good_index)]
           sample (random.set n.hash size random.nat)
           non_member (random.only (|>> (set.member? sample) not)
                                   random.nat)
           .let [sample (|> sample set.list /.of_list)]]
          ($_ _.and
              (_.cover [/.item]
                       (case (/.item good_index sample)
                         (#try.Success member)
                         (/.member? n.equivalence sample member)
                         
                         (#try.Failure error)
                         false))
              (_.cover [/.has]
                       (<| (try.else false)
                           (do try.monad
                             [sample (/.has good_index non_member sample)
                              actual (/.item good_index sample)]
                             (in (same? non_member actual)))))
              (_.cover [/.revised]
                       (<| (try.else false)
                           (do try.monad
                             [sample (/.has good_index non_member sample)
                              sample (/.revised good_index ++ sample)
                              actual (/.item good_index sample)]
                             (in (n.= (++ non_member) actual)))))
              (_.cover [/.within_bounds?]
                       (and (/.within_bounds? sample good_index)
                            (not (/.within_bounds? sample bad_index))))
              (_.cover [/.index_out_of_bounds]
                       (let [fails! (: (All (_ a) (-> (Try a) Bit))
                                       (function (_ situation)
                                         (case situation
                                           (#try.Success member)
                                           false
                                           
                                           (#try.Failure error)
                                           (exception.match? /.index_out_of_bounds error))))]
                         (and (fails! (/.item bad_index sample))
                              (fails! (/.has bad_index non_member sample))
                              (fails! (/.revised bad_index ++ sample)))))
              ))
        )))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Row])
      (do [! random.monad]
        [size (\ ! each (|>> (n.% 100) ++) random.nat)]
        ($_ _.and
            ..signatures
            ..whole
            ..index_based

            (do !
              [sample (random.set n.hash size random.nat)
               non_member (random.only (|>> (set.member? sample) not)
                                       random.nat)
               .let [sample (|> sample set.list /.of_list)]
               .let [(^open "/\[0]") (/.equivalence n.equivalence)]]
              ($_ _.and
                  (do !
                    [value/0 random.nat
                     value/1 random.nat
                     value/2 random.nat]
                    (_.cover [/.row]
                             (/\= (/.of_list (list value/0 value/1 value/2))
                                  (/.row value/0 value/1 value/2))))
                  (_.cover [/.member?]
                           (and (list.every? (/.member? n.equivalence sample)
                                             (/.list sample))
                                (not (/.member? n.equivalence sample non_member))))
                  (_.cover [/.suffix]
                           (let [added (/.suffix non_member sample)

                                 size_increases!
                                 (n.= (++ (/.size sample))
                                      (/.size added))

                                 is_a_member!
                                 (/.member? n.equivalence added non_member)]
                             (and size_increases!
                                  is_a_member!)))
                  (_.cover [/.prefix]
                           (if (/.empty? sample)
                             (/.empty? (/.prefix sample))
                             (let [expected_size!
                                   (n.= (-- (/.size sample))
                                        (/.size (/.prefix sample)))

                                   symmetry!
                                   (|> sample
                                       (/.suffix non_member)
                                       /.prefix
                                       (/\= sample))]
                               (and expected_size!
                                    symmetry!))))
                  ))
            ))))
