(.module:
  [lux #*
   ["_" test (#+ Test)]
   [abstract
    [monad (#+ do)]
    {[0 #spec]
     [/
      ["$." equivalence]
      ["$." monoid]
      ["$." fold]
      ["$." functor (#+ Injection)]]}]
   [data
    ["." bit]
    ["." maybe]
    [number
     ["n" nat]]
    [collection
     ["." list]
     ["." set]]]
   [math
    ["." random (#+ Random)]]]
  {1
   ["." / (#+ Array)]})

(def: injection
  (Injection Array)
  (|>> list /.from-list))

(def: bounded-size
  (Random Nat)
  (:: random.monad map (|>> (n.% 100) (n.+ 1))
      random.nat))

(def: #export test
  Test
  (<| (_.covering /._)
      (_.with-cover [/.Array])
      (do {@ random.monad}
        [size ..bounded-size
         base random.nat
         shift random.nat
         dummy (random.filter (|>> (n.= base) not) random.nat)
         #let [expected (n.+ base shift)]
         the-array (random.array size random.nat)]
        ($_ _.and
            (_.with-cover [/.equivalence]
              ($equivalence.spec (/.equivalence n.equivalence) (random.array size random.nat)))
            (_.with-cover [/.monoid]
              ($monoid.spec (/.equivalence n.equivalence) /.monoid (random.array size random.nat)))
            (_.with-cover [/.functor]
              ($functor.spec ..injection /.equivalence /.functor))
            (_.with-cover [/.fold]
              ($fold.spec ..injection /.equivalence /.fold))

            (_.cover [/.new /.size]
                     (n.= size (/.size (: (Array Nat)
                                          (/.new size)))))
            (_.cover [/.read /.write!]
                     (let [the-array (|> (/.new 2)
                                         (: (Array Nat))
                                         (/.write! 0 expected))]
                       (case [(/.read 0 the-array)
                              (/.read 1 the-array)]
                         [(#.Some actual) #.None]
                         (n.= expected actual)

                         _
                         false)))
            (_.cover [/.delete!]
                     (let [the-array (|> (/.new 1)
                                         (: (Array Nat))
                                         (/.write! 0 expected))]
                       (case [(/.read 0 the-array)
                              (/.read 0 (/.delete! 0 the-array))]
                         [(#.Some actual) #.None]
                         (n.= expected actual)

                         _
                         false)))
            (_.cover [/.contains?]
                     (let [the-array (|> (/.new 2)
                                         (: (Array Nat))
                                         (/.write! 0 expected))]
                       (and (/.contains? 0 the-array)
                            (not (/.contains? 1 the-array)))))
            
            (_.cover [/.update!]
                     (let [the-array (|> (/.new 1)
                                         (: (Array Nat))
                                         (/.write! 0 base)
                                         (/.update! 0 (n.+ shift)))]
                       (case (/.read 0 the-array)
                         (#.Some actual)
                         (n.= expected actual)

                         _
                         false)))
            (_.cover [/.upsert!]
                     (let [the-array (|> (/.new 2)
                                         (: (Array Nat))
                                         (/.write! 0 base)
                                         (/.upsert! 0 dummy (n.+ shift))
                                         (/.upsert! 1 base (n.+ shift)))]
                       (case [(/.read 0 the-array)
                              (/.read 1 the-array)]
                         [(#.Some actual/0) (#.Some actual/1)]
                         (and (n.= expected actual/0)
                              (n.= expected actual/1))

                         _
                         false)))
            (do @
              [occupancy (:: @ map (n.% (inc size)) random.nat)]
              (_.cover [/.occupancy /.vacancy]
                       (let [the-array (loop [output (: (Array Nat)
                                                        (/.new size))
                                              idx 0]
                                         (if (n.< occupancy idx)
                                           (recur (/.write! idx expected output)
                                                  (inc idx))
                                           output))]
                         (and (n.= occupancy (/.occupancy the-array))
                              (n.= size (n.+ (/.occupancy the-array)
                                             (/.vacancy the-array)))))))
            (do @
              [the-list (random.list size random.nat)]
              (_.cover [/.from-list /.to-list]
                       (and (|> the-list /.from-list /.to-list
                                (:: (list.equivalence n.equivalence) = the-list))
                            (|> the-array /.to-list /.from-list
                                (:: (/.equivalence n.equivalence) = the-array)))))
            (do @
              [amount (:: @ map (n.% (inc size)) random.nat)]
              (_.cover [/.copy!]
                       (let [copy (: (Array Nat)
                                     (/.new size))]
                         (exec (/.copy! amount 0 the-array 0 copy)
                           (:: (list.equivalence n.equivalence) =
                               (list.take amount (/.to-list the-array))
                               (/.to-list copy))))))
            (_.cover [/.clone]
                     (let [clone (/.clone the-array)]
                       (and (not (is? the-array clone))
                            (:: (/.equivalence n.equivalence) = the-array clone))))
            (let [the-array (/.clone the-array)
                  evens (|> the-array /.to-list (list.filter n.even?))
                  odds (|> the-array /.to-list (list.filter n.odd?))]
              (_.cover [/.filter!]
                       (exec (/.filter! n.even? the-array)
                         (and (n.= (list.size evens) (/.occupancy the-array))
                              (n.= (list.size odds) (/.vacancy the-array))
                              (|> the-array /.to-list (:: (list.equivalence n.equivalence) = evens))))))
            (do @
              [#let [the-array (/.clone the-array)
                     members (|> the-array /.to-list (set.from-list n.hash))]
               default (random.filter (function (_ value)
                                        (not (or (n.even? value)
                                                 (set.member? members value))))
                                      random.nat)]
              (_.cover [/.to-list']
                       (exec (/.filter! n.even? the-array)
                         (list.every? (function (_ value)
                                        (or (n.even? value)
                                            (is? default value)))
                                      (/.to-list' default the-array)))))
            (_.cover [/.find]
                     (:: (maybe.equivalence n.equivalence) =
                         (/.find n.even? the-array)
                         (list.find n.even? (/.to-list the-array))))
            (_.cover [/.find+]
                     (case [(/.find n.even? the-array)
                            (/.find+ (function (_ idx member)
                                       (n.even? member))
                                     the-array)]
                       [(#.Some expected) (#.Some [idx actual])]
                       (case (/.read idx the-array)
                         (#.Some again)
                         (and (n.= expected actual)
                              (n.= actual again))
                         
                         #.None
                         false)

                       [#.None #.None]
                       true))
            (_.cover [/.every?]
                     (:: bit.equivalence =
                         (list.every? n.even? (/.to-list the-array))
                         (/.every? n.even? the-array)))
            (_.cover [/.any?]
                     (:: bit.equivalence =
                         (list.any? n.even? (/.to-list the-array))
                         (/.any? n.even? the-array)))
            ))))
