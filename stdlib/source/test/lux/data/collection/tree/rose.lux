(.module:
  [lux #*
   data/text/format
   ["_" test (#+ Test)]
   [control
    [monad (#+ do)]
    {[0 #test]
     [/
      ["$." equivalence]
      ["$." fold]
      ["$." functor]]}]
   [data
    [number
     ["." nat]]
    [collection
     ["." list ("#@." functor fold)]]]
   [math
    ["r" random (#+ Random)]]]
  {1
   ["." / (#+ Tree)]})

(def: #export (tree size gen-value)
  (All [a] (-> Nat (Random a) (Random (Tree a))))
  (let [singleton (:: r.monad map /.leaf gen-value)]
    (case size
      0
      singleton
      
      1
      singleton
      
      _
      (do r.monad
        [value gen-value
         children (r.list (n/+ 2 (n/% 2 size))
                          (tree (n// 2 size) gen-value))]
        (wrap (/.branch value children)))
      )))

(def: #export test
  Test
  (<| (_.context (%name (name-of /.Tree)))
      (do r.monad
        [size (:: @ map (|>> (n/% 100) (n/max 10)) r.nat)]
        ($_ _.and
            ($equivalence.spec (/.equivalence nat.equivalence) (..tree size r.nat))
            ($fold.spec /.leaf /.equivalence /.fold)
            ($functor.spec /.leaf /.equivalence /.functor)
            
            (do @
              [sample (..tree size r.nat)]
              (_.test "Can flatten a tree to get all the nodes as a flat tree."
                      (n/= size
                           (list.size (/.flatten sample)))))
            ))))
