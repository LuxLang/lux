(.module:
  [lux #*
   ["_" test (#+ Test)]
   [abstract
    [monad (#+ do)]]
   [data
    ["." maybe ("#\." functor)]
    ["." text ("#\." equivalence monoid)]
    [number
     ["n" nat]]
    [collection
     ["." list ("#\." fold)]]]
   [math
    ["." random]]
   [type (#+ :by-example)]]
  {1
   ["." /]})

(def: builder
  (/.builder text.monoid))

(def: :@:
  (:by-example [@]
               {(/.Builder @ Text)
                ..builder}
               @))

(def: #export test
  Test
  (<| (_.covering /._)
      (_.for [/.Tree])
      (do {! random.monad}
        [tag-left (random.ascii/alpha-num 1)
         tag-right (random.filter (|>> (text\= tag-left) not)
                                  (random.ascii/alpha-num 1))
         expected-left random.nat
         expected-right random.nat]
        ($_ _.and
            (_.cover [/.Builder /.builder]
                     (exec (/.builder text.monoid)
                       true))
            (_.cover [/.tag]
                     (and (text\= tag-left
                                  (/.tag (\ ..builder leaf tag-left expected-left)))
                          (text\= (text\compose tag-left tag-right)
                                  (/.tag (\ ..builder branch
                                            (\ ..builder leaf tag-left expected-left)
                                            (\ ..builder leaf tag-right expected-right))))))
            (_.cover [/.root]
                     (and (case (/.root (\ ..builder leaf tag-left expected-left))
                            (#.Left actual)
                            (n.= expected-left actual)
                            
                            (#.Right _)
                            false)
                          (case (/.root (\ ..builder branch
                                           (\ ..builder leaf tag-left expected-left)
                                           (\ ..builder leaf tag-right expected-right)))
                            (#.Left _)
                            false
                            
                            (#.Right [left right])
                            (case [(/.root left)
                                   (/.root right)]
                              [(#.Left actual-left) (#.Left actual-right)]
                              (and (n.= expected-left actual-left)
                                   (n.= expected-right actual-right))
                              
                              _
                              false))))
            (_.cover [/.value]
                     (and (n.= expected-left
                               (/.value (\ ..builder leaf tag-left expected-left)))
                          (n.= expected-left
                               (/.value (\ ..builder branch
                                           (\ ..builder leaf tag-left expected-left)
                                           (\ ..builder leaf tag-right expected-right))))))
            (do random.monad
              [#let [tags-equivalence (list.equivalence text.equivalence)
                     values-equivalence (list.equivalence n.equivalence)]
               tags/H (random.ascii/alpha-num 1)
               tags/T (random.list 5 (random.ascii/alpha-num 1))
               values/H random.nat
               values/T (random.list 5 random.nat)]
              (_.cover [/.tags /.values]
                       (let [tree (list\fold (function (_ [tag value] tree)
                                               (\ builder branch tree (\ builder leaf tag value)))
                                             (\ builder leaf tags/H values/H)
                                             (list.zip/2 tags/T values/T))]
                         (and (\ tags-equivalence = (list& tags/H tags/T) (/.tags tree))
                              (\ values-equivalence = (list& values/H values/T) (/.values tree))))))
            (_.cover [/.search]
                     (let [can-find-correct-one!
                           (|> (\ ..builder leaf tag-left expected-left)
                               (/.search (text.contains? tag-left))
                               (maybe\map (n.= expected-left))
                               (maybe.default false))

                           cannot-find-incorrect-one!
                           (|> (\ ..builder leaf tag-right expected-right)
                               (/.search (text.contains? tag-left))
                               (maybe\map (n.= expected-left))
                               (maybe.default false)
                               not)

                           can-find-left!
                           (|> (\ ..builder branch
                                  (\ ..builder leaf tag-left expected-left)
                                  (\ ..builder leaf tag-right expected-right))
                               (/.search (text.contains? tag-left))
                               (maybe\map (n.= expected-left))
                               (maybe.default false))

                           can-find-right!
                           (|> (\ ..builder branch
                                  (\ ..builder leaf tag-left expected-left)
                                  (\ ..builder leaf tag-right expected-right))
                               (/.search (text.contains? tag-right))
                               (maybe\map (n.= expected-right))
                               (maybe.default false))]
                       (and can-find-correct-one!
                            cannot-find-incorrect-one!
                            can-find-left!
                            can-find-right!)))
            (_.cover [/.found?]
                     (let [can-find-correct-one!
                           (/.found? (text.contains? tag-left)
                                     (\ ..builder leaf tag-left expected-left))

                           cannot-find-incorrect-one!
                           (not (/.found? (text.contains? tag-left)
                                          (\ ..builder leaf tag-right expected-right)))

                           can-find-left!
                           (/.found? (text.contains? tag-left)
                                     (\ ..builder branch
                                        (\ ..builder leaf tag-left expected-left)
                                        (\ ..builder leaf tag-right expected-right)))

                           can-find-right!
                           (/.found? (text.contains? tag-right)
                                     (\ ..builder branch
                                        (\ ..builder leaf tag-left expected-left)
                                        (\ ..builder leaf tag-right expected-right)))]
                       (and can-find-correct-one!
                            cannot-find-incorrect-one!
                            can-find-left!
                            can-find-right!)))
            ))))
