(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    [abstract
     [monad {"+" [do]}]
     [order {"+" [Order]}]
     [\\specification
      ["$[0]" equivalence]]]
    [data
     ["[0]" bit ("[1]\[0]" equivalence)]
     [collection
      ["[0]" list]]]
    [math
     ["[0]" random {"+" [Random]} ("[1]\[0]" monad)]
     [number
      ["n" nat]]]]]
  [\\library
   ["[0]" / {"+" [Set]}
    ["[0]" //]]])

(def: size
  (random.Random Nat)
  (\ random.monad each (n.% 100) random.nat))

(def: .public (random size &order gen_value)
  (All (_ a) (-> Nat (Order a) (Random a) (Random (Set a))))
  (case size
    0
    (random\in (/.empty &order))

    _
    (do random.monad
      [partial (random (-- size) &order gen_value)
       value (random.only (|>> (/.member? partial) not)
                          gen_value)]
      (in (/.has value partial)))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Set])
      (do [! random.monad]
        [sizeL ..size
         sizeR ..size
         usetL (random.set n.hash sizeL random.nat)
         non_memberL (random.only (|>> (//.member? usetL) not)
                                  random.nat)
         .let [listL (//.list usetL)]
         listR (|> (random.set n.hash sizeR random.nat) (\ ! each //.list))
         .let [(^open "/\[0]") /.equivalence
               setL (/.of_list n.order listL)
               setR (/.of_list n.order listR)
               empty (/.empty n.order)]]
        (`` ($_ _.and
                (_.for [/.equivalence]
                       ($equivalence.spec /.equivalence (..random sizeL n.order random.nat)))

                (_.cover [/.size]
                         (n.= sizeL (/.size setL)))
                (_.cover [/.empty?]
                         (bit\= (n.= 0 (/.size setL))
                                (/.empty? setL)))
                (_.cover [/.empty]
                         (/.empty? (/.empty n.order)))
                (_.cover [/.list]
                         (\ (list.equivalence n.equivalence) =
                            (/.list (/.of_list n.order listL))
                            (list.sorted (\ n.order <) listL)))
                (_.cover [/.of_list]
                         (|> setL
                             /.list (/.of_list n.order)
                             (/\= setL)))
                (~~ (template [<coverage> <comparison>]
                      [(_.cover [<coverage>]
                                (case (<coverage> setL)
                                  {.#Some value}
                                  (|> setL /.list (list.every? (<comparison> value)))

                                  {.#None}
                                  (/.empty? setL)))]

                      [/.min n.>=]
                      [/.max n.<=]
                      ))
                (_.cover [/.member?]
                         (let [members_are_identified!
                               (list.every? (/.member? setL) (/.list setL))

                               non_members_are_not_identified!
                               (not (/.member? setL non_memberL))]
                           (and members_are_identified!
                                non_members_are_not_identified!)))
                (_.cover [/.has]
                         (let [setL+ (/.has non_memberL setL)]
                           (and (not (/.member? setL non_memberL))
                                (/.member? setL+ non_memberL)
                                (n.= (++ (/.size setL))
                                     (/.size setL+)))))
                (_.cover [/.lacks]
                         (|> setL
                             (/.has non_memberL)
                             (/.lacks non_memberL)
                             (\ /.equivalence = setL)))
                (_.cover [/.sub?]
                         (let [self!
                               (/.sub? setL setL)

                               empty!
                               (/.sub? setL empty)]
                           (and self!
                                empty!)))
                (_.cover [/.super?]
                         (let [self!
                               (/.super? setL setL)

                               empty!
                               (/.super? empty setL)

                               symmetry!
                               (bit\= (/.super? setL setR)
                                      (/.sub? setR setL))]
                           (and self!
                                empty!
                                symmetry!)))
                (~~ (template [<coverage> <relation> <empty?>]
                      [(_.cover [<coverage>]
                                (let [self!
                                      (\ /.equivalence =
                                         setL
                                         (<coverage> setL setL))

                                      super!
                                      (and (<relation> (<coverage> setL setR) setL)
                                           (<relation> (<coverage> setL setR) setR))

                                      empty!
                                      (\ /.equivalence =
                                         (if <empty?> empty setL)
                                         (<coverage> setL empty))

                                      idempotence!
                                      (\ /.equivalence =
                                         (<coverage> setL (<coverage> setL setR))
                                         (<coverage> setR (<coverage> setL setR)))]
                                  (and self!
                                       super!
                                       empty!
                                       idempotence!)))]

                      [/.union /.sub? false]
                      [/.intersection /.super? true]
                      ))
                (_.cover [/.difference]
                         (let [self!
                               (|> setL
                                   (/.difference setL)
                                   (\ /.equivalence = empty))

                               empty!
                               (|> setL
                                   (/.difference empty)
                                   (\ /.equivalence = setL))

                               difference!
                               (not (list.any? (/.member? (/.difference setL setR))
                                               (/.list setL)))

                               idempotence!
                               (\ /.equivalence =
                                  (/.difference setL setR)
                                  (/.difference setL (/.difference setL setR)))]
                           (and self!
                                empty!
                                difference!
                                idempotence!)))
                )))))
