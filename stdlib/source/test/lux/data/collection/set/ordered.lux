(.module:
  [lux #*
   ["_" test (#+ Test)]
   [abstract
    [monad (#+ do)]
    [order (#+ Order)]
    {[0 #spec]
     [/
      ["$." equivalence]]}]
   [data
    ["." bit ("#\." equivalence)]
    [number
     ["n" nat]]
    [collection
     ["." list]]]
   [math
    ["." random (#+ Random) ("#\." monad)]]]
  {1
   ["." / (#+ Set)
    ["." //]]})

(def: size
  (random.Random Nat)
  (:: random.monad map (n.% 100) random.nat))

(def: #export (random size &order gen-value)
  (All [a] (-> Nat (Order a) (Random a) (Random (Set a))))
  (case size
    0
    (random\wrap (/.new &order))

    _
    (do random.monad
      [partial (random (dec size) &order gen-value)
       value (random.filter (|>> (/.member? partial) not)
                            gen-value)]
      (wrap (/.add value partial)))))

(def: #export test
  Test
  (<| (_.covering /._)
      (_.with-cover [/.Set])
      (do {! random.monad}
        [sizeL ..size
         sizeR ..size
         usetL (random.set n.hash sizeL random.nat)
         non-memberL (random.filter (|>> (//.member? usetL) not)
                                    random.nat)
         #let [listL (//.to-list usetL)]
         listR (|> (random.set n.hash sizeR random.nat) (:: ! map //.to-list))
         #let [(^open "/\.") /.equivalence
               setL (/.from-list n.order listL)
               setR (/.from-list n.order listR)
               empty (/.new n.order)]]
        (`` ($_ _.and
                (_.with-cover [/.equivalence]
                  ($equivalence.spec /.equivalence (..random sizeL n.order random.nat)))

                (_.cover [/.size]
                         (n.= sizeL (/.size setL)))
                (_.cover [/.empty?]
                         (bit\= (n.= 0 (/.size setL))
                                (/.empty? setL)))
                (_.cover [/.new]
                         (/.empty? (/.new n.order)))
                (_.cover [/.to-list]
                         (:: (list.equivalence n.equivalence) =
                             (/.to-list (/.from-list n.order listL))
                             (list.sort (:: n.order <) listL)))
                (_.cover [/.from-list]
                         (|> setL
                             /.to-list (/.from-list n.order)
                             (/\= setL)))
                (~~ (template [<coverage> <comparison>]
                      [(_.cover [<coverage>]
                                (case (<coverage> setL)
                                  (#.Some value)
                                  (|> setL /.to-list (list.every? (<comparison> value)))

                                  #.None
                                  (/.empty? setL)))]

                      [/.min n.>=]
                      [/.max n.<=]
                      ))
                (_.cover [/.member?]
                         (let [members-are-identified!
                               (list.every? (/.member? setL) (/.to-list setL))

                               non-members-are-not-identified!
                               (not (/.member? setL non-memberL))]
                           (and members-are-identified!
                                non-members-are-not-identified!)))
                (_.cover [/.add]
                         (let [setL+ (/.add non-memberL setL)]
                           (and (not (/.member? setL non-memberL))
                                (/.member? setL+ non-memberL)
                                (n.= (inc (/.size setL))
                                     (/.size setL+)))))
                (_.cover [/.remove]
                         (|> setL
                             (/.add non-memberL)
                             (/.remove non-memberL)
                             (:: /.equivalence = setL)))
                (_.cover [/.sub?]
                         (let [self!
                               (/.sub? setL setL)

                               empty!
                               (/.sub? setL empty)]
                           (and self!
                                empty!)))
                (_.cover [/.super?]
                         (let [self!
                               (/.super? setL setL)

                               empty!
                               (/.super? empty setL)

                               symmetry!
                               (bit\= (/.super? setL setR)
                                      (/.sub? setR setL))]
                           (and self!
                                empty!
                                symmetry!)))
                (~~ (template [<coverage> <relation> <empty?>]
                      [(_.cover [<coverage>]
                                (let [self!
                                      (:: /.equivalence =
                                          setL
                                          (<coverage> setL setL))

                                      super!
                                      (and (<relation> (<coverage> setL setR) setL)
                                           (<relation> (<coverage> setL setR) setR))

                                      empty!
                                      (:: /.equivalence =
                                          (if <empty?> empty setL)
                                          (<coverage> setL empty))

                                      idempotence!
                                      (:: /.equivalence =
                                          (<coverage> setL (<coverage> setL setR))
                                          (<coverage> setR (<coverage> setL setR)))]
                                  (and self!
                                       super!
                                       empty!
                                       idempotence!)))]

                      [/.union /.sub? false]
                      [/.intersection /.super? true]
                      ))
                (_.cover [/.difference]
                         (let [self!
                               (|> setL
                                   (/.difference setL)
                                   (:: /.equivalence = empty))

                               empty!
                               (|> setL
                                   (/.difference empty)
                                   (:: /.equivalence = setL))

                               difference!
                               (not (list.any? (/.member? (/.difference setL setR))
                                               (/.to-list setL)))

                               idempotence!
                               (:: /.equivalence =
                                   (/.difference setL setR)
                                   (/.difference setL (/.difference setL setR)))]
                           (and self!
                                empty!
                                difference!
                                idempotence!)))
                )))))
