(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    [abstract
     ["[0]" monad {"+" [do]}]
     [\\specification
      ["$[0]" equivalence]
      ["$[0]" mix]
      ["$[0]" functor]]]
    [data
     ["[0]" product]
     [collection
      ["[0]" list ("[1]#[0]" functor mix)]]]
    [math
     ["[0]" random {"+" [Random]}]
     [number
      ["n" nat]]]]]
  [\\library
   ["[0]" / {"+" [Tree]}]])

(def: .public (tree gen_value)
  (All (_ a) (-> (Random a) (Random [Nat (Tree a)])))
  (do [! random.monad]
    [value gen_value
     num_children (# ! each (n.% 2) random.nat)
     children (random.list num_children (tree gen_value))]
    (in [(|> children
             (list#each product.left)
             (list#mix n.+ 1))
         [/.#value value
          /.#children (list#each product.right children)]])))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Tree])
      ($_ _.and
          (_.for [/.equivalence]
                 (|> (..tree random.nat)
                     (# random.monad each product.right)
                     ($equivalence.spec (/.equivalence n.equivalence))))
          (_.for [/.mix]
                 ($mix.spec /.leaf /.equivalence /.mix))
          (_.for [/.functor]
                 ($functor.spec /.leaf /.equivalence /.functor))
          
          (do random.monad
            [[size sample] (..tree random.nat)]
            (_.cover [/.flat]
                     (n.= size
                          (list.size (/.flat sample)))))
          (do random.monad
            [expected random.nat]
            (_.cover [/.leaf]
                     (# (list.equivalence n.equivalence) =
                        (list expected)
                        (/.flat (/.leaf expected)))))
          (do [! random.monad]
            [value random.nat
             num_children (# ! each (n.% 3) random.nat)
             children (random.list num_children random.nat)]
            (_.cover [/.branch]
                     (# (list.equivalence n.equivalence) =
                        (list& value children)
                        (/.flat (/.branch value (list#each /.leaf children))))))
          (do random.monad
            [expected/0 random.nat
             expected/1 random.nat
             expected/2 random.nat
             expected/3 random.nat
             expected/4 random.nat
             expected/5 random.nat]
            (_.cover [/.tree]
                     (and (# (list.equivalence n.equivalence) =
                             (list expected/0)
                             (/.flat (/.tree expected/0)))
                          (# (list.equivalence n.equivalence) =
                             (list expected/0 expected/1 expected/2)
                             (/.flat (/.tree expected/0
                                             {expected/1 {}
                                                         expected/2 {}})))
                          (# (list.equivalence n.equivalence) =
                             (list expected/0 expected/1 expected/2
                                   expected/3 expected/4 expected/5)
                             (/.flat (/.tree expected/0
                                             {expected/1 {}
                                                         expected/2 {expected/3 {}
                                                                                expected/4 {expected/5 {}}}})))
                          )))
          )))
