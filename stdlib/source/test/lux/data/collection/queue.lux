(.module:
  [lux #*
   ["_" test (#+ Test)]
   [abstract
    [monad (#+ do)]
    {[0 #spec]
     [/
      ["$." equivalence]
      ["$." functor (#+ Injection)]]}]
   [data
    ["." bit ("#@." equivalence)]
    ["%" text/format (#+ format)]
    [number
     ["n" nat]]
    [collection
     ["." set]
     ["." list ("#@." monoid)]]]
   [math
    ["." random]]]
  {1
   ["." /]})

(def: injection
  (Injection /.Queue)
  (|>> list /.from-list))

(def: #export test
  Test
  (<| (_.covering /._)
      (_.with-cover [/.Queue])
      (do {@ random.monad}
        [size (:: @ map (n.% 100) random.nat)
         members (random.set n.hash size random.nat)
         non-member (random.filter (|>> (set.member? members) not)
                                   random.nat)
         #let [members (set.to-list members)
               sample (/.from-list members)]]
        ($_ _.and
            (_.with-cover [/.equivalence]
              ($equivalence.spec (/.equivalence n.equivalence) (random.queue size random.nat)))
            (_.with-cover [/.functor]
              ($functor.spec ..injection /.equivalence /.functor))

            (_.cover [/.from-list /.to-list]
                     (|> members /.from-list /.to-list
                         (:: (list.equivalence n.equivalence) = members)))
            (_.cover [/.size]
                     (n.= size (/.size sample)))
            (_.cover [/.empty?]
                     (bit@= (n.= 0 size) (/.empty? sample)))
            (_.cover [/.empty]
                     (let [empty-is-empty!
                           (/.empty? /.empty)

                           all-empty-queues-look-the-same!
                           (bit@= (/.empty? sample)
                                  (:: (/.equivalence n.equivalence) =
                                      sample
                                      /.empty))]
                       (and empty-is-empty!
                            all-empty-queues-look-the-same!)))
            (_.cover [/.peek]
                     (case [members (/.peek sample)]
                       [(#.Cons head tail) (#.Some first)]
                       (n.= head first)
                       
                       [#.Nil #.None]
                       true

                       _
                       false))
            (_.cover [/.member?]
                     (let [every-member-is-identified!
                           (list.every? (/.member? n.equivalence sample)
                                        (/.to-list sample))

                           non-member-is-not-identified!
                           (not (/.member? n.equivalence sample non-member))]
                       (and every-member-is-identified!
                            non-member-is-not-identified!)))
            (_.cover [/.push]
                     (let [pushed (/.push non-member sample)

                           size-increases!
                           (n.= (inc (/.size sample)) (/.size pushed))

                           new-member-is-identified!
                           (/.member? n.equivalence pushed non-member)

                           has-expected-order!
                           (:: (list.equivalence n.equivalence) =
                               (list@compose (/.to-list sample) (list non-member))
                               (/.to-list pushed))]
                       (and size-increases!
                            new-member-is-identified!
                            has-expected-order!)))
            (_.cover [/.pop]
                     (case members
                       (#.Cons target expected)
                       (let [popped (/.pop sample)

                             size-decreases!
                             (n.= (dec (/.size sample))
                                  (/.size popped))

                             popped-member-is-not-identified!
                             (not (/.member? n.equivalence popped target))

                             has-expected-order!
                             (:: (list.equivalence n.equivalence) =
                                 expected
                                 (/.to-list popped))]
                         (and size-decreases!
                              popped-member-is-not-identified!
                              has-expected-order!))
                       
                       #.Nil
                       (and (/.empty? sample)
                            (/.empty? (/.pop sample)))))
            ))))
