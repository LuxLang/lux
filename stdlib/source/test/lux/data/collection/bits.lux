(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    [abstract
     [monad {"+" [do]}]
     ["." predicate]
     [\\specification
      ["$." equivalence]]]
    [math
     ["." random {"+" [Random]}]
     [number
      ["n" nat]]]]]
  [\\library
   ["." / {"+" [Bits]}]])

(def: (size min max)
  (-> Nat Nat (Random Nat))
  (|> random.nat
      (\ random.monad each (|>> (n.% (++ max)) (n.max min)))))

(def: .public random
  (Random Bits)
  (do [! random.monad]
    [size (\ ! each (n.% 1,000) random.nat)]
    (case size
      0 (in /.empty)
      _ (do [! random.monad]
          [idx (|> random.nat (\ ! each (n.% size)))]
          (in (/.one idx /.empty))))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Bits])
      ($_ _.and
          (_.for [/.equivalence]
                 ($equivalence.spec /.equivalence ..random))

          (do random.monad
            [sample ..random]
            (_.cover [/.empty? /.size]
                     (if (/.empty? sample)
                       (n.= 0 (/.size sample))
                       (n.> 0 (/.size sample)))))
          (_.cover [/.empty]
                   (/.empty? /.empty))
          
          (do [! random.monad]
            [size (\ ! each (|>> (n.% 1,000) ++) random.nat)
             idx (\ ! each (n.% size) random.nat)
             sample ..random]
            ($_ _.and
                (_.cover [/.bit /.one]
                         (and (|> /.empty (/.bit idx) not)
                              (|> /.empty (/.one idx) (/.bit idx))))
                (_.cover [/.zero]
                         (|> /.empty (/.one idx) (/.zero idx) (/.bit idx) not))
                (_.cover [/.flipped]
                         (and (|> /.empty (/.flipped idx) (/.bit idx))
                              (|> /.empty (/.flipped idx) (/.flipped idx) (/.bit idx) not)))
                (_.cover [/.Chunk /.capacity /.chunk_size]
                         (and (n.= 0 (/.capacity /.empty))
                              (|> /.empty (/.one idx) /.capacity
                                  (n.- idx)
                                  (predicate.or (n.>= 0)
                                                (n.< /.chunk_size)))
                              (let [grown (/.flipped idx /.empty)]
                                (and (n.> 0 (/.capacity grown))
                                     (same? /.empty (/.flipped idx grown))))))
                (_.cover [/.intersects?]
                         (and (not (/.intersects? /.empty
                                                  /.empty))
                              (/.intersects? (/.one idx /.empty)
                                             (/.one idx /.empty))
                              (not (/.intersects? (/.one (++ idx) /.empty)
                                                  (/.one idx /.empty)))
                              (not (/.intersects? sample (/.not sample)))))
                (_.cover [/.not]
                         (and (same? /.empty (/.not /.empty))
                              (or (same? /.empty sample)
                                  (and (not (\ /.equivalence = sample (/.not sample)))
                                       (\ /.equivalence = sample (/.not (/.not sample)))))))
                (_.cover [/.xor]
                         (and (same? /.empty (/.xor sample sample))
                              (n.= (/.size (/.xor sample (/.not sample)))
                                   (/.capacity sample))))
                (_.cover [/.or]
                         (and (\ /.equivalence = sample (/.or sample sample))
                              (n.= (/.size (/.or sample (/.not sample)))
                                   (/.capacity sample))))
                (_.cover [/.and]
                         (and (\ /.equivalence = sample (/.and sample sample))
                              (same? /.empty (/.and sample (/.not sample)))))
                )))))
