(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]
    ["[0]" predicate]
    [\\specification
     ["$[0]" equivalence]]]
   [math
    ["[0]" random {"+" Random}]
    [number
     ["n" nat]]]]]
 [\\library
  ["[0]" / {"+" Bits}]])

(def: (size min max)
  (-> Nat Nat (Random Nat))
  (|> random.nat
      (# random.monad each (|>> (n.% (++ max)) (n.max min)))))

(def: .public random
  (Random Bits)
  (do [! random.monad]
    [size (# ! each (n.% 1,000) random.nat)]
    (case size
      0 (in /.empty)
      _ (do [! random.monad]
          [idx (|> random.nat (# ! each (n.% size)))]
          (in (/.one idx /.empty))))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Bits])
      (all _.and
           (_.for [/.equivalence]
                  ($equivalence.spec /.equivalence ..random))

           (do random.monad
             [sample ..random]
             (_.coverage [/.empty? /.size]
               (if (/.empty? sample)
                 (n.= 0 (/.size sample))
                 (n.> 0 (/.size sample)))))
           (_.coverage [/.empty]
             (/.empty? /.empty))
           
           (do [! random.monad]
             [size (# ! each (|>> (n.% 1,000) ++) random.nat)
              idx (# ! each (n.% size) random.nat)
              sample ..random]
             (all _.and
                  (_.coverage [/.bit /.one]
                    (and (|> /.empty (/.bit idx) not)
                         (|> /.empty (/.one idx) (/.bit idx))))
                  (_.coverage [/.zero]
                    (|> /.empty (/.one idx) (/.zero idx) (/.bit idx) not))
                  (_.coverage [/.flipped]
                    (and (|> /.empty (/.flipped idx) (/.bit idx))
                         (|> /.empty (/.flipped idx) (/.flipped idx) (/.bit idx) not)))
                  (_.coverage [/.Chunk /.capacity /.chunk_size]
                    (and (n.= 0 (/.capacity /.empty))
                         (|> /.empty (/.one idx) /.capacity
                             (n.- idx)
                             (predicate.or (n.>= 0)
                                           (n.< /.chunk_size)))
                         (let [grown (/.flipped idx /.empty)]
                           (and (n.> 0 (/.capacity grown))
                                (same? /.empty (/.flipped idx grown))))))
                  (_.coverage [/.intersects?]
                    (and (not (/.intersects? /.empty
                                             /.empty))
                         (/.intersects? (/.one idx /.empty)
                                        (/.one idx /.empty))
                         (not (/.intersects? (/.one (++ idx) /.empty)
                                             (/.one idx /.empty)))
                         (not (/.intersects? sample (/.not sample)))))
                  (_.coverage [/.not]
                    (and (same? /.empty (/.not /.empty))
                         (or (same? /.empty sample)
                             (and (not (# /.equivalence = sample (/.not sample)))
                                  (# /.equivalence = sample (/.not (/.not sample)))))))
                  (_.coverage [/.xor]
                    (and (same? /.empty (/.xor sample sample))
                         (n.= (/.size (/.xor sample (/.not sample)))
                              (/.capacity sample))))
                  (_.coverage [/.or]
                    (and (# /.equivalence = sample (/.or sample sample))
                         (n.= (/.size (/.or sample (/.not sample)))
                              (/.capacity sample))))
                  (_.coverage [/.and]
                    (and (# /.equivalence = sample (/.and sample sample))
                         (same? /.empty (/.and sample (/.not sample)))))
                  )))))
