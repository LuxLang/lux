(.module:
  [lux #*
   ["_" test (#+ Test)]
   [abstract
    [monad (#+ do)]
    ["." enum]
    ["." equivalence]
    {[0 #spec]
     [/
      ["$." equivalence]
      ["$." monoid]
      ["$." fold]
      ["$." functor]
      ["$." apply]
      ["$." monad]]}]
   [control
    pipe
    ["." io]
    ["." function]]
   [data
    ["." bit]
    ["." product]
    ["." maybe]
    ["." text ("#@." equivalence)]
    [number
     ["n" nat]
     ["." int]]
    [collection
     ["." set]]]
   [math
    ["." random (#+ Random)]]]
  {1
   ["." / ("#@." monad)]})

(def: bounded-size
  (Random Nat)
  (:: random.monad map (n.% 100)
      random.nat))

(def: random
  (Random (List Nat))
  (do {! random.monad}
    [size ..bounded-size]
    (|> random.nat
        (random.set n.hash size)
        (:: ! map set.to-list))))

(def: signatures
  Test
  ($_ _.and
      (_.with-cover [/.equivalence]
        ($equivalence.spec (/.equivalence n.equivalence) ..random))
      (_.with-cover [/.monoid]
        ($monoid.spec (/.equivalence n.equivalence) /.monoid ..random))
      (_.with-cover [/.fold]
        ($fold.spec /@wrap /.equivalence /.fold))
      (_.with-cover [/.functor]
        ($functor.spec /@wrap /.equivalence /.functor))
      (_.with-cover [/.apply]
        ($apply.spec /@wrap /.equivalence /.apply))
      (_.with-cover [/.monad]
        ($monad.spec /@wrap /.equivalence /.monad))

      (do {! random.monad}
        [parameter random.nat
         subject random.nat]
        (let [lift (/.lift io.monad)
              (^open "io@.") io.monad
              expected (n.+ parameter subject)]
          (_.cover [/.with /.lift]
                   (|> (io.run (do (/.with io.monad)
                                 [a (lift (io@wrap parameter))
                                  b (wrap subject)]
                                 (wrap (n.+ a b))))
                       (case> (^ (list actual))
                              (n.= expected actual)
                              
                              _
                              false)))))
      ))

(def: whole
  Test
  (do {! random.monad}
    [size ..bounded-size
     #let [(^open "/@.") (/.equivalence n.equivalence)]
     sample (:: ! map set.to-list (random.set n.hash size random.nat))]
    ($_ _.and
        (_.cover [/.size]
                 (n.= size (/.size sample)))
        (_.cover [/.empty?]
                 (:: bit.equivalence =
                     (/.empty? sample)
                     (n.= 0 (/.size sample))))
        (_.cover [/.repeat]
                 (n.= size (/.size (/.repeat size []))))
        (_.cover [/.reverse]
                 (or (n.< 2 (/.size sample))
                     (let [not-same!
                           (not (/@= sample
                                     (/.reverse sample)))

                           self-symmetry!
                           (/@= sample
                                (/.reverse (/.reverse sample)))]
                       (and not-same!
                            self-symmetry!))))
        (_.cover [/.every? /.any?]
                 (if (/.every? n.even? sample)
                   (not (/.any? (bit.complement n.even?) sample))
                   (/.any? (bit.complement n.even?) sample)))
        (_.cover [/.sort]
                 (let [<<< n.<
                       
                       size-preservation!
                       (n.= (/.size sample)
                            (/.size (/.sort <<< sample)))
                       
                       symmetry!
                       (/@= (/.sort <<< sample)
                            (/.reverse (/.sort (function.flip <<<) sample)))]
                   (and size-preservation!
                        symmetry!)))
        )))

(def: indices
  Test
  (let [(^open "/@.") (/.equivalence n.equivalence)
        (^open "/@.") /.functor]
    (do {! random.monad}
      [sample ..random
       #let [size (/.size sample)]]
      ($_ _.and
          (_.cover [/.indices]
                   (let [indices (/.indices size)

                         expected-amount!
                         (n.= size (/.size indices))

                         already-sorted!
                         (/@= indices
                              (/.sort n.< indices))

                         expected-numbers!
                         (/.every? (n.= (dec size))
                                   (/.zip-with/2 n.+
                                                 indices
                                                 (/.sort n.> indices)))]
                     (and expected-amount!
                          already-sorted!
                          expected-numbers!)))
          (_.cover [/.enumeration]
                   (let [enumeration (/.enumeration sample)

                         has-correct-indices!
                         (/@= (/.indices (/.size enumeration))
                              (/@map product.left enumeration))

                         has-correct-values!
                         (/@= sample
                              (/@map product.right enumeration))]
                     (and has-correct-indices!
                          has-correct-values!)))
          (_.cover [/.nth]
                   (/.every? (function (_ [index expected])
                               (case (/.nth index sample)
                                 (#.Some actual)
                                 (n.= expected actual)
                                 
                                 #.None
                                 false))
                             (/.enumeration sample)))
          ))))

(def: slice
  Test
  (let [(^open "/@.") (/.equivalence n.equivalence)
        (^open "/@.") /.monoid]
    (do {! random.monad}
      [sample (random.filter (|>> /.size (n.> 0))
                             ..random)
       #let [size (/.size sample)]
       idx (:: ! map (n.% size) random.nat)
       chunk-size (:: ! map (|>> (n.% size) inc) random.nat)]
      ($_ _.and
          (_.cover [/.filter]
                   (let [positives (/.filter n.even? sample)
                         negatives (/.filter (bit.complement n.even?) sample)]
                     (and (/.every? n.even? positives)
                          (not (/.any? n.even? negatives))

                          (n.= (/.size sample)
                               (n.+ (/.size positives)
                                    (/.size negatives))))))
          (_.cover [/.partition]
                   (let [[positives negatives] (/.partition n.even? sample)]
                     (and (/@= (/.filter n.even? sample)
                               positives)
                          (/@= (/.filter (bit.complement n.even?) sample)
                               negatives))))
          (_.cover [/.split]
                   (let [[left right] (/.split idx sample)]
                     (/@= sample
                          (/@compose left right))))
          (_.cover [/.split-with]
                   (let [[left right] (/.split-with n.even? sample)]
                     (/@= sample
                          (/@compose left right))))
          (_.cover [/.take /.drop]
                   (/@= sample
                        (/@compose (/.take idx sample)
                                   (/.drop idx sample))))
          (_.cover [/.take-while /.drop-while]
                   (/@= sample
                        (/@compose (/.take-while n.even? sample)
                                   (/.drop-while n.even? sample))))
          (_.cover [/.chunk]
                   (let [chunks (/.chunk chunk-size sample)]
                     (and (/.every? (|>> /.size (n.<= chunk-size)) chunks)
                          (/@= sample
                               (/.concat chunks)))))
          ))))

(def: member
  Test
  (let [(^open "/@.") (/.equivalence n.equivalence)]
    (do {! random.monad}
      [sample ..random]
      (`` ($_ _.and
              (_.cover [/.member?]
                       (/.every? (/.member? n.equivalence sample)
                                 sample))
              (~~ (template [<head> <tail> <pre>]
                    [($_ _.and
                         (_.cover [<head>]
                                  (case [(<pre> sample) (<head> sample)]
                                    [(#.Cons expected _) (#.Some actual)]
                                    (n.= expected actual)

                                    [#.Nil #.None]
                                    true

                                    _
                                    false))
                         (_.cover [<tail>]
                                  (case [(<pre> sample) (<tail> sample)]
                                    [(#.Cons _ expected) (#.Some actual)]
                                    (/@= (<pre> expected) actual)

                                    [#.Nil #.None]
                                    true

                                    _
                                    false))
                         )]

                    [/.head /.tail |>]
                    [/.last /.inits /.reverse]
                    ))
              )))))

(def: grouping
  Test
  (let [(^open "/@.") (/.equivalence n.equivalence)
        (^open "/@.") /.functor
        (^open "/@.") /.monoid
        
        +/2 (: (-> Nat Nat Nat)
               (function (_ left right)
                 ($_ n.+ left right)))
        +/3 (: (-> Nat Nat Nat Nat)
               (function (_ left mid right)
                 ($_ n.+ left mid right)))]
    (do {! random.monad}
      [sample/0 ..random
       sample/1 ..random
       sample/2 ..random]
      ($_ _.and
          (_.cover [/.as-pairs]
                   (n.= (n./ 2 (/.size sample/0))
                        (/.size (/.as-pairs sample/0))))
          (_.cover [/.zip/2]
                   (let [zipped (/.zip/2 sample/0 sample/1)
                         zipped::size (/.size zipped)

                         size-of-smaller-list!
                         (n.= zipped::size
                              (n.min (/.size sample/0) (/.size sample/1)))

                         can-extract-values!
                         (and (/@= (/.take zipped::size sample/0)
                                   (/@map product.left zipped))
                              (/@= (/.take zipped::size sample/1)
                                   (/@map product.right zipped)))]
                     (and size-of-smaller-list!
                          can-extract-values!)))
          (_.cover [/.zip/3]
                   (let [zipped (/.zip/3 sample/0 sample/1 sample/2)
                         zipped::size (/.size zipped)
                         
                         size-of-smaller-list!
                         (n.= zipped::size
                              ($_ n.min
                                  (/.size sample/0)
                                  (/.size sample/1)
                                  (/.size sample/2)))

                         can-extract-values!
                         (and (/@= (/.take zipped::size sample/0)
                                   (/@map product.left zipped))
                              (/@= (/.take zipped::size sample/1)
                                   (/@map (|>> product.right product.left) zipped))
                              (/@= (/.take zipped::size sample/2)
                                   (/@map (|>> product.right product.right) zipped)))]
                     (and size-of-smaller-list!
                          can-extract-values!)))
          (_.cover [/.zip]
                   (and (:: (/.equivalence (equivalence.product n.equivalence n.equivalence)) =
                            (/.zip/2 sample/0 sample/1)
                            ((/.zip 2) sample/0 sample/1))
                        (:: (/.equivalence ($_ equivalence.product n.equivalence n.equivalence n.equivalence)) =
                            (/.zip/3 sample/0 sample/1 sample/2)
                            ((/.zip 3) sample/0 sample/1 sample/2))))

          (_.cover [/.zip-with/2]
                   (/@= (/@map (function (_ [left right])
                                 (+/2 left right))
                               (/.zip/2 sample/0 sample/1))
                        (/.zip-with/2 +/2 sample/0 sample/1)))
          (_.cover [/.zip-with/3]
                   (/@= (/@map (function (_ [left mid right])
                                 (+/3 left mid right))
                               (/.zip/3 sample/0 sample/1 sample/2))
                        (/.zip-with/3 +/3 sample/0 sample/1 sample/2)))
          (_.cover [/.zip-with]
                   (and (/@= (/.zip-with/2 +/2 sample/0 sample/1)
                             ((/.zip-with 2) +/2 sample/0 sample/1))
                        (/@= (/.zip-with/3 +/3 sample/0 sample/1 sample/2)
                             ((/.zip-with 3) +/3 sample/0 sample/1 sample/2))))
          (_.cover [/.concat]
                   (and (/@= (/@compose sample/0 sample/1)
                             (/.concat (list sample/0 sample/1)))
                        (/@= ($_ /@compose sample/0 sample/1 sample/2)
                             (/.concat (list sample/0 sample/1 sample/2)))))
          ))))

(def: search
  Test
  (let [(^open "/@.") /.functor
        
        choose (: (-> Nat (Maybe Text))
                  (function (_ value)
                    (if (n.even? value)
                      (#.Some (:: n.decimal encode value))
                      #.None)))]
    (do {! random.monad}
      [sample ..random]
      ($_ _.and
          (_.cover [/.one]
                   (case [(|> sample
                              (/.filter n.even?)
                              (/@map (:: n.decimal encode))
                              /.head)
                          (/.one choose sample)]
                     [(#.Some expected) (#.Some actual)]
                     (text@= expected actual)

                     [#.None #.None]
                     true

                     _
                     false))
          (_.cover [/.all]
                   (:: (/.equivalence text.equivalence) =
                       (|> sample
                           (/.filter n.even?)
                           (/@map (:: n.decimal encode)))
                       (/.all choose sample)))
          (_.cover [/.find]
                   (case (/.find n.even? sample)
                     (#.Some found)
                     (n.even? found)

                     #.None
                     (not (/.any? n.even? sample))))
          ))))

(def: #export test
  Test
  (<| (_.covering /._)
      (_.with-cover [.List])
      (let [(^open "/@.") (/.equivalence n.equivalence)
            (^open "/@.") /.functor]
        (do {! random.monad}
          [sample ..random
           separator random.nat]
          ($_ _.and
              ..signatures
              ..whole
              ..indices
              ..slice
              ..member
              ..grouping
              ..search
              
              (_.cover [/.interpose]
                       (or (/.empty? sample)
                           (let [sample+ (/.interpose separator sample)]
                             (and (n.= (|> (/.size sample) (n.* 2) dec)
                                       (/.size sample+))
                                  (|> sample+ /.as-pairs (/.every? (|>> product.right (n.= separator))))))))
              (_.cover [/.iterate]
                       (or (/.empty? sample)
                           (let [size (/.size sample)]
                             (/@= (/.indices size)
                                  (/.iterate (function (_ index)
                                               (if (n.< size index)
                                                 (#.Some (inc index))
                                                 #.None))
                                             0)))))
              (_.cover [/.folds]
                       (/@= (/@map (function (_ index)
                                     (:: /.fold fold n.+ 0 (/.take index sample)))
                                   (/.indices (inc (/.size sample))))
                            (/.folds n.+ 0 sample)))
              )))))
