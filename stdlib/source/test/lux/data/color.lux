(.module:
  [library
   [lux #*
    ["_" test (#+ Test)]
    [abstract
     [monad (#+ do)]
     [\\specification
      ["$." equivalence]
      ["$." hash]
      ["$." monoid]]]
    [data
     [collection
      ["." list]]]
    [macro
     ["." template]]
    ["." math
     ["." random (#+ Random)]
     [number
      ["n" nat]
      ["." int]
      ["f" frac]
      ["r" rev]]]]]
  [\\library
   ["." /]])

(def: .public random
  (Random /.Color)
  (|> ($_ random.and random.nat random.nat random.nat)
      (\ random.monad map /.of_rgb)))

(def: scale
  (-> Nat Frac)
  (|>> .int int.frac))

(def: square
  (-> Frac Frac)
  (math.pow +2.0))

(def: square_root
  (-> Frac Frac)
  (math.pow +0.5))

(def: (distance/1 from to)
  (-> Frac Frac Frac)
  (square_root
   (square
    (f.- from to))))

(def: (distance/3 from to)
  (-> /.Color /.Color Frac)
  (let [[fr fg fb] (/.rgb from)
        [tr tg tb] (/.rgb to)]
    (square_root
     ($_ f.+
         (|> (scale tr) (f.- (scale fr)) square)
         (|> (scale tg) (f.- (scale fg)) square)
         (|> (scale tb) (f.- (scale fb)) square)))))

(def: rgb_error_margin +1.8)

(template [<field>]
  [(def: (<field> color)
     (-> /.Color Frac)
     (let [[hue saturation luminance] (/.hsl color)]
       <field>))]

  [saturation]
  [luminance]
  )

(def: (encoding expected)
  (-> /.Color Test)
  ($_ _.and
      (_.cover [/.RGB /.rgb /.of_rgb]
               (|> expected /.rgb /.of_rgb
                   (\ /.equivalence = expected)))
      (_.cover [/.HSL /.hsl /.of_hsl]
               (|> expected /.hsl /.of_hsl
                   (distance/3 expected)
                   (f.<= ..rgb_error_margin)))
      (_.cover [/.HSB /.hsb /.of_hsb]
               (|> expected /.hsb /.of_hsb
                   (distance/3 expected)
                   (f.<= ..rgb_error_margin)))
      (_.cover [/.CMYK /.cmyk /.of_cmyk]
               (|> expected /.cmyk /.of_cmyk
                   (distance/3 expected)
                   (f.<= ..rgb_error_margin)))
      ))

(def: transformation
  Test
  (do random.monad
    [colorful (|> ..random
                  (random.only (function (_ color) (|> (distance/3 color /.black) (f.>= +100.0))))
                  (random.only (function (_ color) (|> (distance/3 color /.white) (f.>= +100.0)))))
     mediocre (|> ..random
                  (random.only (|>> saturation
                                    ((function (_ saturation)
                                       (and (f.>= +0.25 saturation)
                                            (f.<= +0.75 saturation)))))))
     ratio (|> random.safe_frac (random.only (f.>= +0.5)))]
    ($_ _.and
        (_.cover [/.darker /.brighter]
                 (and (f.<= (distance/3 colorful /.black)
                            (distance/3 (/.darker ratio colorful) /.black))
                      (f.<= (distance/3 colorful /.white)
                            (distance/3 (/.brighter ratio colorful) /.white))))
        (_.cover [/.interpolated]
                 (and (f.<= (distance/3 colorful /.black)
                            (distance/3 (/.interpolated ratio /.black colorful) /.black))
                      (f.<= (distance/3 colorful /.white)
                            (distance/3 (/.interpolated ratio /.white colorful) /.white))))
        (_.cover [/.saturated]
                 (f.> (saturation mediocre)
                      (saturation (/.saturated ratio mediocre))))
        (_.cover [/.un_saturated]
                 (f.< (saturation mediocre)
                      (saturation (/.un_saturated ratio mediocre))))
        (_.cover [/.gray_scale]
                 (let [gray'ed (/.gray_scale mediocre)]
                   (and (f.= +0.0
                             (saturation gray'ed))
                        (|> (luminance gray'ed)
                            (f.- (luminance mediocre))
                            f.abs
                            (f.<= ..rgb_error_margin)))))
        )))

(def: palette
  Test
  (_.for [/.Spread /.Palette]
         (do {! random.monad}
           [eH (\ ! map (|>> f.abs (f.% +0.9) (f.+ +0.05))
                  random.safe_frac)
            .let [eS +0.5]
            variations (\ ! map (|>> (n.% 3) (n.+ 2)) random.nat)
            .let [max_spread (f./ (|> variations ++ .int int.frac)
                                  +1.0)
                  min_spread (f./ +2.0 max_spread)
                  spread_space (f.- min_spread max_spread)]
            spread (\ ! map (|>> f.abs (f.% spread_space) (f.+ min_spread))
                      random.safe_frac)]
           (`` ($_ _.and
                   (~~ (template [<brightness> <palette>]
                         [(_.cover [<palette>]
                                   (let [eB <brightness>
                                         expected (/.of_hsb [eH eS eB])
                                         palette (<palette> spread variations expected)]
                                     (and (n.= variations (list.size palette))
                                          (not (list.any? (\ /.equivalence = expected) palette)))))]
                         [+1.0 /.analogous]
                         [+0.5 /.monochromatic]
                         ))
                   (~~ (template [<palette>]
                         [(_.cover [<palette>]
                                   (let [expected (/.of_hsb [eH eS +0.5])
                                         [c0 c1 c2] (<palette> expected)]
                                     (and (\ /.equivalence = expected c0)
                                          (not (\ /.equivalence = expected c1))
                                          (not (\ /.equivalence = expected c2)))))]

                         [/.triad]
                         [/.clash]
                         [/.split_complement]))
                   (~~ (template [<palette>]
                         [(_.cover [<palette>]
                                   (let [expected (/.of_hsb [eH eS +0.5])
                                         [c0 c1 c2 c3] (<palette> expected)]
                                     (and (\ /.equivalence = expected c0)
                                          (not (\ /.equivalence = expected c1))
                                          (not (\ /.equivalence = expected c2))
                                          (not (\ /.equivalence = expected c3)))))]

                         [/.square]
                         [/.tetradic]))
                   )))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Color])
      (do {! random.monad}
        [expected ..random]
        ($_ _.and
            (_.for [/.equivalence]
                   ($equivalence.spec /.equivalence ..random))
            (_.for [/.hash]
                   ($hash.spec /.hash ..random))
            (_.for [/.addition]
                   ($monoid.spec /.equivalence /.addition ..random))
            (_.for [/.subtraction]
                   ($monoid.spec /.equivalence /.addition ..random))
            
            (..encoding expected)
            (_.cover [/.complement]
                     (let [~expected (/.complement expected)
                           (^open "/\.") /.equivalence]
                       (and (not (/\= expected ~expected))
                            (/\= expected (/.complement ~expected)))))
            (_.cover [/.black /.white]
                     (and (\ /.equivalence = /.white (/.complement /.black))
                          (\ /.equivalence = /.black (/.complement /.white))))
            ..transformation
            ..palette
            (_.for [/.Alpha /.Pigment]
                   ($_ _.and
                       (_.cover [/.transparent /.opaque]
                                (and (r.= /.opaque (-- /.transparent))
                                     (r.= /.transparent (++ /.opaque))))
                       (_.cover [/.translucent]
                                (r.= /.transparent (r.+ /.translucent /.translucent)))
                       ))
            ))))
