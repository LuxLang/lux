(.using
 [library
  [lux (.full)
   ["_" test (.only Test)]
   [abstract
    [monad (.only do)]
    [\\specification
     ["$[0]" equivalence]
     ["$[0]" hash]
     ["$[0]" monoid]]]
   [data
    [collection
     ["[0]" list]]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" nat]
     ["f" frac]
     ["r" rev]
     ["[0]" int]]]]]
 [\\library
  ["[0]" /]])

(def: .public random
  (Random /.Color)
  (|> (all random.and random.nat random.nat random.nat)
      (# random.monad each /.of_rgb)))

(def: scale
  (-> Nat Frac)
  (|>> .int int.frac))

(def: square
  (-> Frac Frac)
  (f.pow +2.0))

(def: square_root
  (-> Frac Frac)
  (f.pow +0.5))

(def: (distance/1 from to)
  (-> Frac Frac Frac)
  (square_root
   (square
    (f.- from to))))

(def: (distance/3 from to)
  (-> /.Color /.Color Frac)
  (let [[fr fg fb] (/.rgb from)
        [tr tg tb] (/.rgb to)]
    (square_root
     (all f.+
          (|> (scale tr) (f.- (scale fr)) square)
          (|> (scale tg) (f.- (scale fg)) square)
          (|> (scale tb) (f.- (scale fb)) square)))))

(def: rgb_error_margin +1.8)

(template [<field>]
  [(def: (<field> color)
     (-> /.Color Frac)
     (let [[hue saturation luminance] (/.hsl color)]
       <field>))]

  [saturation]
  [luminance]
  )

(def: (encoding expected)
  (-> /.Color Test)
  (all _.and
       (_.coverage [/.RGB /.rgb /.of_rgb]
         (|> expected /.rgb /.of_rgb
             (# /.equivalence = expected)))
       (_.coverage [/.HSL /.hsl /.of_hsl]
         (|> expected /.hsl /.of_hsl
             (distance/3 expected)
             (f.<= ..rgb_error_margin)))
       (_.coverage [/.HSB /.hsb /.of_hsb]
         (|> expected /.hsb /.of_hsb
             (distance/3 expected)
             (f.<= ..rgb_error_margin)))
       (_.coverage [/.CMYK /.cmyk /.of_cmyk]
         (|> expected /.cmyk /.of_cmyk
             (distance/3 expected)
             (f.<= ..rgb_error_margin)))
       ))

(def: transformation
  Test
  (do random.monad
    [colorful (|> ..random
                  (random.only (function (_ color) (|> (distance/3 color /.black) (f.>= +100.0))))
                  (random.only (function (_ color) (|> (distance/3 color /.white) (f.>= +100.0)))))
     mediocre (|> ..random
                  (random.only (|>> saturation
                                    ((function (_ saturation)
                                       (and (f.>= +0.25 saturation)
                                            (f.<= +0.75 saturation)))))))
     ratio (|> random.safe_frac (random.only (f.>= +0.5)))]
    (all _.and
         (_.coverage [/.darker /.brighter]
           (and (f.<= (distance/3 colorful /.black)
                      (distance/3 (/.darker ratio colorful) /.black))
                (f.<= (distance/3 colorful /.white)
                      (distance/3 (/.brighter ratio colorful) /.white))))
         (_.coverage [/.interpolated]
           (and (f.<= (distance/3 colorful /.black)
                      (distance/3 (/.interpolated ratio /.black colorful) /.black))
                (f.<= (distance/3 colorful /.white)
                      (distance/3 (/.interpolated ratio /.white colorful) /.white))))
         (_.coverage [/.saturated]
           (f.> (saturation mediocre)
                (saturation (/.saturated ratio mediocre))))
         (_.coverage [/.un_saturated]
           (f.< (saturation mediocre)
                (saturation (/.un_saturated ratio mediocre))))
         (_.coverage [/.gray_scale]
           (let [gray'ed (/.gray_scale mediocre)]
             (and (f.= +0.0
                       (saturation gray'ed))
                  (|> (luminance gray'ed)
                      (f.- (luminance mediocre))
                      f.abs
                      (f.<= ..rgb_error_margin)))))
         )))

(def: palette
  Test
  (_.for [/.Spread /.Palette]
         (do [! random.monad]
           [eH (# ! each (|>> f.abs (f.% +0.9) (f.+ +0.05))
                  random.safe_frac)
            .let [eS +0.5]
            variations (# ! each (|>> (n.% 3) (n.+ 2)) random.nat)
            .let [max_spread (f./ (|> variations ++ .int int.frac)
                                  +1.0)
                  min_spread (f./ +2.0 max_spread)
                  spread_space (f.- min_spread max_spread)]
            spread (# ! each (|>> f.abs (f.% spread_space) (f.+ min_spread))
                      random.safe_frac)]
           (`` (all _.and
                    (~~ (template [<brightness> <palette>]
                          [(_.coverage [<palette>]
                             (let [eB <brightness>
                                   expected (/.of_hsb [eH eS eB])
                                   palette (<palette> spread variations expected)]
                               (and (n.= variations (list.size palette))
                                    (not (list.any? (# /.equivalence = expected) palette)))))]
                          [+1.0 /.analogous]
                          [+0.5 /.monochromatic]
                          ))
                    (~~ (template [<palette>]
                          [(_.coverage [<palette>]
                             (let [expected (/.of_hsb [eH eS +0.5])
                                   [c0 c1 c2] (<palette> expected)]
                               (and (# /.equivalence = expected c0)
                                    (not (# /.equivalence = expected c1))
                                    (not (# /.equivalence = expected c2)))))]

                          [/.triad]
                          [/.clash]
                          [/.split_complement]))
                    (~~ (template [<palette>]
                          [(_.coverage [<palette>]
                             (let [expected (/.of_hsb [eH eS +0.5])
                                   [c0 c1 c2 c3] (<palette> expected)]
                               (and (# /.equivalence = expected c0)
                                    (not (# /.equivalence = expected c1))
                                    (not (# /.equivalence = expected c2))
                                    (not (# /.equivalence = expected c3)))))]

                          [/.square]
                          [/.tetradic]))
                    )))))

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Color])
      (do [! random.monad]
        [expected ..random]
        (all _.and
             (_.for [/.equivalence]
                    ($equivalence.spec /.equivalence ..random))
             (_.for [/.hash]
                    ($hash.spec /.hash ..random))
             (_.for [/.addition]
                    ($monoid.spec /.equivalence /.addition ..random))
             (_.for [/.subtraction]
                    ($monoid.spec /.equivalence /.addition ..random))
             
             (..encoding expected)
             (_.coverage [/.complement]
               (let [~expected (/.complement expected)
                     (open "/#[0]") /.equivalence]
                 (and (not (/#= expected ~expected))
                      (/#= expected (/.complement ~expected)))))
             (_.coverage [/.black /.white]
               (and (# /.equivalence = /.white (/.complement /.black))
                    (# /.equivalence = /.black (/.complement /.white))))
             ..transformation
             ..palette
             (_.for [/.Alpha /.Pigment]
                    (all _.and
                         (_.coverage [/.transparent /.opaque]
                           (and (r.= /.opaque (-- /.transparent))
                                (r.= /.transparent (++ /.opaque))))
                         (_.coverage [/.translucent]
                           (r.= /.transparent (r.+ /.translucent /.translucent)))
                         ))
             ))))
