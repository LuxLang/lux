(.require
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]
    [\\specification
     ["$[0]" equivalence]
     ["$[0]" hash]
     ["$[0]" monoid]]]
   [data
    [collection
     ["[0]" list]]]
   [math
    ["[0]" random (.only Random) (.use "[1]#[0]" functor)]
    [number
     ["n" nat]
     ["f" frac]
     ["r" rev]
     ["[0]" int]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" / (.only)
   ["[0]" rgb]
   ["[0]" hsl]]]
 ["[0]" /
  ["[1][0]" rgb]
  ["[1][0]" cmyk]
  ["[1][0]" hsl]
  ["[1][0]" hsb]
  ["[1][0]" pigment]
  ["[1][0]" named]
  ["[1][0]" terminal]])

(def .public random
  (Random /.Color)
  (random#each /.of_rgb /rgb.random))

(def scale
  (-> Nat Frac)
  (|>> .int int.frac))

(def square
  (-> Frac Frac)
  (f.pow +2.0))

(def square_root
  (-> Frac Frac)
  (f.pow +0.5))

(def (distance/1 from to)
  (-> Frac Frac Frac)
  (square_root
   (square
    (f.- from to))))

(def (distance/3 from to)
  (-> /.Color /.Color Frac)
  (let [from (/.rgb from)
        to (/.rgb to)]
    (square_root
     (all f.+
          (|> (scale (rgb.red to)) (f.- (scale (rgb.red from))) square)
          (|> (scale (rgb.green to)) (f.- (scale (rgb.green from))) square)
          (|> (scale (rgb.blue to)) (f.- (scale (rgb.blue from))) square)))))

(def rgb_error_margin
  +1.8)

(with_template [<name> <field>]
  [(def <name>
     (-> /.Color Frac)
     (|>> /.rgb
          hsl.of_rgb
          <field>))]

  [saturation hsl.saturation]
  [luminance hsl.luminance]
  )

(def (encoding expected)
  (-> /.Color Test)
  (all _.and
       (_.coverage [/.rgb /.of_rgb]
         (|> expected /.rgb /.of_rgb
             (of /.equivalence = expected)))
       ))

(def transformation
  Test
  (do random.monad
    [colorful (|> ..random
                  (random.only (function (_ color) (and (|> (distance/3 color /.black) (f.>= +100.0))
                                                        (|> (distance/3 color /.white) (f.>= +100.0))))))
     mediocre (|> ..random
                  (random.only (|>> saturation
                                    ((function (_ saturation)
                                       (and (f.>= +0.25 saturation)
                                            (f.<= +0.75 saturation)))))))
     ratio (|> random.safe_frac (random.only (f.>= +0.5)))]
    (all _.and
         (_.coverage [/.darker /.brighter]
           (and (f.<= (distance/3 colorful /.black)
                      (distance/3 (/.darker ratio colorful) /.black))
                (f.<= (distance/3 colorful /.white)
                      (distance/3 (/.brighter ratio colorful) /.white))))
         (_.coverage [/.interpolated]
           (and (f.<= (distance/3 colorful /.black)
                      (distance/3 (/.interpolated ratio /.black colorful) /.black))
                (f.<= (distance/3 colorful /.white)
                      (distance/3 (/.interpolated ratio /.white colorful) /.white))))
         (_.coverage [/.saturated]
           (f.> (saturation mediocre)
                (saturation (/.saturated ratio mediocre))))
         (_.coverage [/.un_saturated]
           (f.< (saturation mediocre)
                (saturation (/.un_saturated ratio mediocre))))
         (_.coverage [/.gray_scale]
           (let [gray'ed (/.gray_scale mediocre)]
             (and (f.= +0.0
                       (saturation gray'ed))
                  (|> (luminance gray'ed)
                      (f.- (luminance mediocre))
                      f.abs
                      (f.<= ..rgb_error_margin)))))
         )))

... (def palette
...   Test
...   (_.for [/.Spread /.Palette]
...          (do [! random.monad]
...            [eH (of ! each (|>> f.abs (f.% +0.9) (f.+ +0.05))
...                    random.safe_frac)
...             .let [eS +0.5]
...             variations (of ! each (|>> (n.% 3) (n.+ 2)) random.nat)
...             .let [max_spread (f./ (|> variations ++ .int int.frac)
...                                   +1.0)
...                   min_spread (f./ +2.0 max_spread)
...                   spread_space (f.- min_spread max_spread)]
...             spread (of ! each (|>> f.abs (f.% spread_space) (f.+ min_spread))
...                        random.safe_frac)]
...            (`` (all _.and
...                     (,, (with_template [<brightness> <palette>]
...                           [(_.coverage [<palette>]
...                              (let [eB <brightness>
...                                    expected (/.of_hsb [eH eS eB])
...                                    palette (<palette> spread variations expected)]
...                                (and (n.= variations (list.size palette))
...                                     (not (list.any? (of /.equivalence = expected) palette)))))]
...                           [+1.0 /.analogous]
...                           [+0.5 /.monochromatic]
...                           ))
...                     (,, (with_template [<palette>]
...                           [(_.coverage [<palette>]
...                              (let [expected (/.of_hsb [eH eS +0.5])
...                                    [c0 c1 c2] (<palette> expected)]
...                                (and (of /.equivalence = expected c0)
...                                     (not (of /.equivalence = expected c1))
...                                     (not (of /.equivalence = expected c2)))))]

...                           [/.triad]
...                           [/.clash]
...                           [/.split_complement]))
...                     (,, (with_template [<palette>]
...                           [(_.coverage [<palette>]
...                              (let [expected (/.of_hsb [eH eS +0.5])
...                                    [c0 c1 c2 c3] (<palette> expected)]
...                                (and (of /.equivalence = expected c0)
...                                     (not (of /.equivalence = expected c1))
...                                     (not (of /.equivalence = expected c2))
...                                     (not (of /.equivalence = expected c3)))))]

...                           [/.square]
...                           [/.tetradic]))
...                     )))))

(def .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Color])
      (do [! random.monad]
        [expected ..random]
        (all _.and
             (_.for [/.equivalence]
                    ($equivalence.spec /.equivalence ..random))
             (_.for [/.hash]
                    ($hash.spec /.hash ..random))
             (_.for [/.addition]
                    ($monoid.spec /.equivalence /.addition ..random))
             (_.for [/.subtraction]
                    ($monoid.spec /.equivalence /.addition ..random))
             
             (..encoding expected)
             (_.coverage [/.complement]
               (let [~expected (/.complement expected)
                     (open "/#[0]") /.equivalence]
                 (and (not (/#= expected ~expected))
                      (/#= expected (/.complement ~expected)))))
             (_.coverage [/.black /.white]
               (and (of /.equivalence = /.white (/.complement /.black))
                    (of /.equivalence = /.black (/.complement /.white))))
             ..transformation
             ... ..palette

             /rgb.test
             /cmyk.test
             /hsl.test
             /hsb.test
             /pigment.test
             /named.test
             /terminal.test
             ))))
