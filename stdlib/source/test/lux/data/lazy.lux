(.module:
  [lux #*
   ["_" test (#+ Test)]
   [control
    [monad (#+ do)]
    {[0 #test]
     [/
      [".T" functor (#+ Injection Comparison)]
      [".T" apply]
      [".T" monad]
      [".T" equivalence]]}]
   [data
    text/format
    [number
     ["." nat]]]
   [math
    ["r" random (#+ Random)]]]
  {1
   ["." / (#+ Lazy)]})

(def: injection
  (Injection Lazy)
  (|>> /.freeze))

(def: comparison
  (Comparison Lazy)
  (function (_ ==)
    (:: (/.equivalence ==) =)))

(def: #export lazy
  (All [a] (-> (Random a) (Random (Lazy a))))
  (:: r.functor map (|>> /.freeze)))

(def: #export test
  Test
  (<| (_.context (%name (name-of /.Lazy)))
      (do r.monad
        [left r.nat
         right r.nat
         #let [lazy (/.freeze (n/* left right))
               expected (n/* left right)]]
        ($_ _.and
            (_.test "Freezing does not alter the expected value."
                    (n/= expected
                         (/.thaw lazy)))
            (_.test "Lazy values only evaluate once."
                    (and (not (is? expected
                                   (/.thaw lazy)))
                         (is? (/.thaw lazy)
                              (/.thaw lazy))))
            (equivalenceT.test (/.equivalence nat.equivalence) (..lazy r.nat))
            (functorT.laws ..injection ..comparison /.functor)
            (applyT.laws ..injection ..comparison /.apply)
            (monadT.laws ..injection ..comparison /.monad)
            ))))
