(.require
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]
    [\\specification
     ["[0]S" equivalence]
     ["[0]S" hash]
     ["[0]S" monoid]]]
   [control
    ["[0]" try (.use "[1]#[0]" functor)]
    ["[0]" exception]]
   [math
    ["[0]" random (.only Random) (.use "[1]#[0]" functor)]
    [number
     ["n" nat]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" /]])

(def .public value
  (Random /.Value)
  (random#each (|>> (n.% /.limit) /.value)
               random.nat))

(def .public random
  (Random /.RGB)
  (do random.monad
    [red ..value
     green ..value
     blue ..value]
    (in (/.rgb red green blue))))

(def .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [expected_value ..value
         expected ..random

         expected_red ..value
         expected_green ..value
         expected_blue ..value])
      (all _.and
           (_.for [/.Value]
                  (all _.and
                       (_.coverage [/.least]
                         (n.>= /.least
                               expected_value))
                       (_.coverage [/.most]
                         (n.<= /.most
                               expected_value))
                       (_.coverage [/.value?]
                         (and (/.value? expected_value)
                              (not (/.value? (++ /.most)))
                              (not (/.value? (-- /.least)))))
                       (_.coverage [/.value]
                         (|> expected_value
                             /.value
                             (n.= expected_value)))
                       (_.coverage [/.limit]
                         (|> /.limit
                             /.value
                             (n.= /.limit)
                             not))
                       ))
           (_.for [/.RGB]
                  (all _.and
                       (_.for [/.equivalence]
                              (equivalenceS.spec /.equivalence ..random))
                       (_.for [/.hash]
                              (hashS.spec /.hash ..random))
                       (_.for [/.addition]
                              (monoidS.spec /.equivalence /.addition ..random))
                       (_.for [/.subtraction]
                              (monoidS.spec /.equivalence /.subtraction ..random))

                       (_.coverage [/.rgb
                                    /.red /.green /.blue]
                         (let [it (/.rgb expected_red expected_green expected_blue)]
                           (and (same? expected_red
                                       (/.red it))
                                (same? expected_green
                                       (/.green it))
                                (same? expected_blue
                                       (/.blue it)))))
                       (_.coverage [/.complement]
                         (let [~expected (/.complement expected)
                               (open "/#[0]") /.equivalence]
                           (and (not (/#= expected ~expected))
                                (/#= expected (/.complement ~expected)))))
                       (_.coverage [/.black /.white]
                         (and (of /.equivalence = /.white (/.complement /.black))
                              (of /.equivalence = /.black (/.complement /.white))))
                       ))
           )))
