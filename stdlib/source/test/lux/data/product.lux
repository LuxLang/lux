(.require
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]
    ["[0]" equivalence
     ["[1]T" \\test]]]
   [math
    ["[0]" random]
    [number
     ["n" nat]
     ["i" int]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" /]])

(def .public test
  Test
  (<| (_.covering /._)
      (_.for [.Tuple .And])
      (do random.monad
        [expected random.nat
         shift random.nat
         dummy (random.only (|>> (n.= expected) not)
                            random.nat)]
        (all _.and
             (_.for [/.equivalence]
                    (equivalenceT.spec (/.equivalence n.equivalence i.equivalence)
                                       (random.and random.nat random.int)))
             (do random.monad
               [left random.int
                right random.nat]
               (_.coverage [/.hash]
                 (let [hash (/.hash i.hash n.hash)]
                   (n.= (n.+ (of i.hash hash left)
                             (of n.hash hash right))
                        (of hash hash [left right])))))
             
             (<| (_.coverage [/.left])
                 (n.= expected (/.left [expected dummy])))
             (<| (_.coverage [/.right])
                 (n.= expected (/.right [dummy expected])))
             (<| (_.coverage [/.forked])
                 (let [[left right] ((/.forked (n.+ shift) (n.- shift)) expected)]
                   (and (n.= (n.+ shift expected)
                             left)
                        (n.= (n.- shift expected)
                             right))))
             (do random.monad
               [left random.nat
                right random.nat]
               (all _.and
                    (<| (_.coverage [/.swapped])
                        (let [pair [left right]]
                          (and (n.= (/.left pair)
                                    (/.right (/.swapped pair)))
                               (n.= (/.right pair)
                                    (/.left (/.swapped pair))))))
                    (<| (_.coverage [/.uncurried])
                        (n.= (n.+ left right)
                             ((/.uncurried n.+) [left right])))
                    (<| (_.coverage [/.curried])
                        (n.= (n.+ left right)
                             ((/.curried (/.uncurried n.+)) left right)))
                    (<| (_.coverage [/.then])
                        (let [[left' right'] (/.then (n.+ shift) (n.- shift) [left right])]
                          (and (n.= (n.+ shift left) left')
                               (n.= (n.- shift right) right'))))))
             ))))
