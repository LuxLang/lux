(.module:
  [library
   [lux #*
    ["_" test (#+ Test)]
    [abstract
     [monad (#+ do)]
     [\\specification
      ["$." equivalence]]]
    [math
     ["." random]
     [number
      ["n" nat]
      ["i" int]]]]]
  [\\library
   ["." /]])

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [.Tuple .And])
      (do random.monad
        [expected random.nat
         shift random.nat
         dummy (random.only (|>> (n.= expected) not)
                            random.nat)]
        ($_ _.and
            (_.for [/.equivalence]
                   ($equivalence.spec (/.equivalence n.equivalence i.equivalence)
                                      (random.and random.nat random.int)))
            (do random.monad
              [left random.int
               right random.nat]
              (_.cover [/.hash]
                       (let [hash (/.hash i.hash n.hash)]
                         (n.= (n.+ (\ i.hash hash left)
                                   (\ n.hash hash right))
                              (\ hash hash [left right])))))
            
            (<| (_.cover [/.left])
                (n.= expected (/.left [expected dummy])))
            (<| (_.cover [/.right])
                (n.= expected (/.right [dummy expected])))
            (<| (_.cover [/.fork])
                (let [[left right] ((/.fork (n.+ shift) (n.- shift)) expected)]
                  (and (n.= (n.+ shift expected)
                            left)
                       (n.= (n.- shift expected)
                            right))))
            (do random.monad
              [left random.nat
               right random.nat]
              ($_ _.and
                  (<| (_.cover [/.swapped])
                      (let [pair [left right]]
                        (and (n.= (/.left pair)
                                  (/.right (/.swapped pair)))
                             (n.= (/.right pair)
                                  (/.left (/.swapped pair))))))
                  (<| (_.cover [/.uncurried])
                      (n.= (n.+ left right)
                           ((/.uncurried n.+) [left right])))
                  (<| (_.cover [/.curried])
                      (n.= (n.+ left right)
                           ((/.curried (/.uncurried n.+)) left right)))
                  (<| (_.cover [/.apply])
                      (let [[left' right'] (/.apply (n.+ shift) (n.- shift) [left right])]
                        (and (n.= (n.+ shift left) left')
                             (n.= (n.- shift right) right'))))))
            ))))
