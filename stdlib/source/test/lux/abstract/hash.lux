(.require
 [library
  [lux (.except)
   ["_" test (.only Test)]
   [abstract
    [monad (.only do)]
    [\\specification
     [functor
      ["$[0]" contravariant]]]]
   [data
    ["[0]" bit (.use "[1]#[0]" equivalence)]]
   [math
    ["[0]" random]
    [number
     ["[0]" nat]]]]]
 [\\library
  ["[0]" / (.only Hash)
   [//
    [equivalence (.only Equivalence)]]]])

(def .public test
  Test
  (do random.monad
    [leftN random.nat
     rightN random.nat
     .let [hash (is (Equivalence (/.Hash Nat))
                    (implementation
                     (def (= (open "left#[0]") (open "right#[0]"))
                       (and (bit#= (left#= (left#hash leftN) (left#hash leftN))
                                   (right#= (right#hash leftN) (right#hash leftN)))
                            (bit#= (left#= (left#hash rightN) (left#hash rightN))
                                   (right#= (right#hash rightN) (right#hash rightN)))
                            (bit#= (left#= (left#hash leftN) (left#hash rightN))
                                   (right#= (right#hash leftN) (right#hash rightN)))))))]]
    (<| (_.covering /._)
        (all _.and
             (_.for [/.functor]
                    ($contravariant.spec hash nat.hash /.functor))
             ))))
