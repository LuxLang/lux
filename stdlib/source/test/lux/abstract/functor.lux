(.require
 [library
  [lux (.except)
   ["_" test (.only Test)]
   ["@" target]
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" maybe]
    ["[0]" state]]
   [data
    ["[0]" identity]
    [collection
     ["[0]" list]]]
   [math
    ["[0]" random]
    [number
     ["n" nat]]]]]
 ["[0]" \\polytypic]
 [\\library
  ["[0]" / (.only Functor)]])

(for @.old (these)
     (these (def maybe_functor
              (Functor .Maybe)
              (\\polytypic.functor .Maybe))

            (def list_functor
              (Functor .List)
              (\\polytypic.functor .List))

            (def state_functor
              (All (_ s) (Functor (state.State s)))
              (\\polytypic.functor state.State))

            (def identity_functor
              (Functor identity.Identity)
              (\\polytypic.functor identity.Identity))))

(def \\polytypic
  Test
  (<| (_.covering \\polytypic._)
      (_.coverage [\\polytypic.functor]
        true)))

(def .public test
  Test
  (do random.monad
    [left random.nat
     right random.nat
     shift random.nat]
    (<| (_.covering /._)
        (all _.and
             (_.coverage [/.Or /.sum]
               (and (case (at (/.sum maybe.functor list.functor) each
                              (n.+ shift)
                              {.#Left {.#Some left}})
                      {.#Left {.#Some actual}}
                      (n.= (n.+ shift left) actual)

                      _
                      false)
                    (case (at (/.sum maybe.functor list.functor) each
                              (n.+ shift)
                              {.#Right (list right)})
                      (pattern {.#Right (list actual)})
                      (n.= (n.+ shift right) actual)

                      _
                      false)))
             (_.coverage [/.And /.product]
               (case (at (/.product maybe.functor list.functor) each
                         (n.+ shift)
                         [{.#Some left} (list right)])
                 (pattern [{.#Some actualL} (list actualR)])
                 (and (n.= (n.+ shift left) actualL)
                      (n.= (n.+ shift right) actualR))

                 _
                 false))
             (_.coverage [/.Then /.composite]
               (case (at (/.composite maybe.functor list.functor) each
                         (n.+ shift)
                         {.#Some (list left)})
                 (pattern {.#Some (list actual)})
                 (n.= (n.+ shift left) actual)

                 _
                 false))

             ..\\polytypic
             ))))
