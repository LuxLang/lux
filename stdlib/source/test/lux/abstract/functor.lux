(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    [abstract
     [monad {"+" [do]}]]
    [control
     ["[0]" maybe]]
    [data
     [collection
      ["[0]" list]]]
    [math
     ["[0]" random]
     [number
      ["n" nat]]]]]
  [\\library
   ["[0]" / {"+" [Functor]}]])

(def: .public test
  Test
  (do random.monad
    [left random.nat
     right random.nat
     shift random.nat]
    (<| (_.covering /._)
        ($_ _.and
            (_.cover [/.Or /.sum]
                     (and (case (\ (/.sum maybe.functor list.functor) each
                                   (n.+ shift)
                                   (#.Left (#.Some left)))
                            (#.Left (#.Some actual))
                            (n.= (n.+ shift left) actual)

                            _
                            false)
                          (case (\ (/.sum maybe.functor list.functor) each
                                   (n.+ shift)
                                   (#.Right (list right)))
                            (^ (#.Right (list actual)))
                            (n.= (n.+ shift right) actual)

                            _
                            false)))
            (_.cover [/.And /.product]
                     (case (\ (/.product maybe.functor list.functor) each
                              (n.+ shift)
                              [(#.Some left) (list right)])
                       (^ [(#.Some actualL) (list actualR)])
                       (and (n.= (n.+ shift left) actualL)
                            (n.= (n.+ shift right) actualR))

                       _
                       false))
            (_.cover [/.Then /.composite]
                     (case (\ (/.composite maybe.functor list.functor) each
                              (n.+ shift)
                              (#.Some (list left)))
                       (^ (#.Some (list actual)))
                       (n.= (n.+ shift left) actual)

                       _
                       false))
            ))))
