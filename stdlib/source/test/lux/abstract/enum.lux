(.module:
  [library
   [lux #*
    ["_" test (#+ Test)]
    [abstract
     [monad (#+ do)]]
    [data
     ["." product]
     ["." maybe ("#\." functor)]
     [collection
      ["." list ("#\." fold)]]]
    [math
     ["." random (#+ Random)]
     [number
      ["n" nat]]]]]
  [\\library
   ["." /]])

(def: #export test
  Test
  (let [limit (: (Random Nat)
                 (\ random.monad map (n.% 20) random.nat))]
    (do random.monad
      [start limit
       end limit
       #let [[start end] (if (n.< end start)
                           [start end]
                           [end start])
             range (/.range n.enum start end)]]
      (<| (_.covering /._)
          ($_ _.and
              (_.cover [/.range]
                       (let [expected_size (|> end (n.- start) inc)
                             expected_start? (|> range list.head (maybe\map (n.= start)) (maybe.default false))
                             expected_end? (|> range list.last (maybe\map (n.= end)) (maybe.default false))
                             can_be_backwards? (\ (list.equivalence n.equivalence) =
                                                  (/.range n.enum start end)
                                                  (list.reverse (/.range n.enum end start)))
                             every_element_is_a_successor? (case range
                                                             (#.Cons head tail)
                                                             (|> (list\fold (function (_ next [verdict prev])
                                                                              [(and verdict
                                                                                    (n.= next (\ n.enum succ prev)))
                                                                               next])
                                                                            [true head]
                                                                            tail)
                                                                 product.left)
                                                             
                                                             #.Nil
                                                             false)]
                         (and (n.= expected_size (list.size range))
                              expected_start?
                              expected_end?
                              can_be_backwards?
                              every_element_is_a_successor?)))
              )))))
