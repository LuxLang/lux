(.module:
  [lux #*
   [data
    ["." product]
    ["." maybe ("#@." functor)]
    [number
     ["n" nat]]
    [collection
     ["." list ("#@." fold)]]]
   ["_" test (#+ Test)]
   [abstract/monad (#+ do)]
   [math
    ["r" random (#+ Random)]]]
  {1
   ["." / (#+ Enum)]})

(def: #export test
  Test
  (let [limit (: (Random Nat)
                 (:: r.monad map (n.% 20) r.nat))]
    (do r.monad
      [start limit
       end limit
       #let [[start end] (if (n.< end start)
                           [start end]
                           [end start])
             range (/.range n.enum start end)]]
      (<| (_.covering /._)
          ($_ _.and
              (_.cover [/.range]
                       (let [expected-size (|> end (n.- start) inc)
                             expected-start? (|> range list.head (maybe@map (n.= start)) (maybe.default false))
                             expected-end? (|> range list.last (maybe@map (n.= end)) (maybe.default false))
                             every-element-is-a-successor? (case range
                                                             (#.Cons head tail)
                                                             (|> (list@fold (function (_ next [verdict prev])
                                                                              [(and verdict
                                                                                    (n.= next (:: n.enum succ prev)))
                                                                               next])
                                                                            [true head]
                                                                            tail)
                                                                 product.left)
                                                             
                                                             #.Nil
                                                             false)]
                         (and (n.= expected-size (list.size range))
                              expected-start?
                              expected-end?
                              every-element-is-a-successor?)))
              )))))

(def: #export (spec (^open "/@.") gen-sample)
  (All [a] (-> (Enum a) (Random a) Test))
  (do r.monad
    [sample gen-sample]
    (<| (_.with-cover [/.Enum])
        ($_ _.and
            (_.test "Successor and predecessor are inverse functions."
                    (and (/@= (|> sample /@succ /@pred)
                              sample)
                         (/@= (|> sample /@pred /@succ)
                              sample)
                         (not (/@= (/@succ sample)
                                   sample))
                         (not (/@= (/@pred sample)
                                   sample))))
            ))))
