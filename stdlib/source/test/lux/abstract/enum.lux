(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]]
   [control
    ["[0]" maybe ("[1]#[0]" functor)]]
   [data
    ["[0]" product]
    [collection
     ["[0]" list ("[1]#[0]" mix)]]]
   [math
    ["[0]" random {"+" Random}]
    [number
     ["n" nat]]]]]
 [\\library
  ["[0]" /]])

(def: .public test
  Test
  (let [limit (is (Random Nat)
                  (# random.monad each (n.% 20) random.nat))]
    (do random.monad
      [start limit
       end limit
       .let [[start end] (if (n.< end start)
                           [start end]
                           [end start])
             range (/.range n.enum start end)]]
      (<| (_.covering /._)
          (all _.and
               (_.coverage [/.range]
                 (let [expected_size (|> end (n.- start) ++)
                       expected_start? (|> range list.head (maybe#each (n.= start)) (maybe.else false))
                       expected_end? (|> range list.last (maybe#each (n.= end)) (maybe.else false))
                       can_be_backwards? (# (list.equivalence n.equivalence) =
                                            (/.range n.enum start end)
                                            (list.reversed (/.range n.enum end start)))
                       every_element_is_a_successor? (case range
                                                       {.#Item head tail}
                                                       (|> (list#mix (function (_ next [verdict prev])
                                                                       [(and verdict
                                                                             (n.= next (# n.enum succ prev)))
                                                                        next])
                                                                     [true head]
                                                                     tail)
                                                           product.left)
                                                       
                                                       {.#End}
                                                       false)]
                   (and (n.= expected_size (list.size range))
                        expected_start?
                        expected_end?
                        can_be_backwards?
                        every_element_is_a_successor?)))
               )))))
