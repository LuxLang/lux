(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   [data
    ["[0]" identity {"+" Identity}]
    [collection
     ["[0]" list ("[1]#[0]" functor mix)]]]
   [math
    ["[0]" random]
    [number
     ["n" nat]]]]]
 [\\library
  ["[0]" / {"+" Monad do}]])

(def: .public test
  Test
  (do random.monad
    [mono random.nat
     poly (random.list 10 random.nat)]
    (<| (_.covering /._)
        ($_ _.and
            (_.cover [/.do]
                     (n.= (++ mono)
                          (is (Identity Nat)
                              (/.do identity.monad
                                [sample (in mono)]
                                (in (++ sample))))))
            (_.cover [/.then]
                     (n.= (++ mono)
                          (is (Identity Nat)
                              (/.then identity.monad
                                      (|>> ++ (# identity.monad in))
                                      (# identity.monad in mono)))))
            (_.cover [/.all]
                     (# (list.equivalence n.equivalence) =
                        (list#each ++ poly)
                        (|> poly
                            (list#each (|>> ++ (# identity.monad in)))
                            (is (List (Identity Nat)))
                            (/.all identity.monad)
                            (is (Identity (List Nat))))))
            (_.cover [/.each]
                     (# (list.equivalence n.equivalence) =
                        (list#each ++ poly)
                        (|> poly
                            (/.each identity.monad (|>> ++ (# identity.monad in)))
                            (is (Identity (List Nat))))))
            (_.cover [/.only]
                     (# (list.equivalence n.equivalence) =
                        (list.only n.even? poly)
                        (|> poly
                            (/.only identity.monad (|>> n.even? (# identity.monad in)))
                            (is (Identity (List Nat))))))
            (_.cover [/.mix]
                     (n.= (list#mix n.+ 0 poly)
                          (|> poly
                              (/.mix identity.monad
                                     (function (_ part whole)
                                       (# identity.monad in
                                          (n.+ part whole)))
                                     0)
                              (is (Identity Nat)))))
            ))))
