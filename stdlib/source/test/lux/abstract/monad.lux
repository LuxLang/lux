(.module:
  [library
   [lux #*
    ["_" test (#+ Test)]
    [data
     ["." identity (#+ Identity)]
     [collection
      ["." list ("#\." functor fold)]]]
    [math
     ["." random]
     [number
      ["n" nat]]]]]
  [\\library
   ["." / (#+ Monad do)]])

(def: .public test
  Test
  (do random.monad
    [mono random.nat
     poly (random.list 10 random.nat)]
    (<| (_.covering /._)
        ($_ _.and
            (_.cover [/.do]
                     (n.= (++ mono)
                          (: (Identity Nat)
                             (/.do identity.monad
                               [sample (in mono)]
                               (in (++ sample))))))
            (_.cover [/.then]
                     (n.= (++ mono)
                          (: (Identity Nat)
                             (/.then identity.monad
                                     (|>> ++ (\ identity.monad in))
                                     (\ identity.monad in mono)))))
            (_.cover [/.all]
                     (\ (list.equivalence n.equivalence) =
                        (list\map ++ poly)
                        (|> poly
                            (list\map (|>> ++ (\ identity.monad in)))
                            (: (List (Identity Nat)))
                            (/.all identity.monad)
                            (: (Identity (List Nat))))))
            (_.cover [/.map]
                     (\ (list.equivalence n.equivalence) =
                        (list\map ++ poly)
                        (|> poly
                            (/.map identity.monad (|>> ++ (\ identity.monad in)))
                            (: (Identity (List Nat))))))
            (_.cover [/.only]
                     (\ (list.equivalence n.equivalence) =
                        (list.only n.even? poly)
                        (|> poly
                            (/.only identity.monad (|>> n.even? (\ identity.monad in)))
                            (: (Identity (List Nat))))))
            (_.cover [/.fold]
                     (n.= (list\fold n.+ 0 poly)
                          (|> poly
                              (/.fold identity.monad
                                      (function (_ part whole)
                                        (\ identity.monad in
                                           (n.+ part whole)))
                                      0)
                              (: (Identity Nat)))))
            ))))
