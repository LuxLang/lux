(.using
 [library
  [lux "*"
   ["_" test (.only Test)]
   [abstract
    [monad (.only do)]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["[0]" nat]
     ["[0]" int]]]]]
 [\\library
  ["[0]" /
   [//
    [equivalence (.only Equivalence)]]]])

(def: .public test
  Test
  (do random.monad
    [natL random.nat
     natR random.nat
     intL random.int
     intR random.int]
    (<| (_.covering /._)
        (all _.and
             (_.coverage [/.and]
               (let [[natLR intLR] (# (/.and nat.addition int.multiplication) composite
                                      [natL intL] [natR intR])]
                 (and (nat.= (# nat.addition composite natL natR)
                             natLR)
                      (int.= (# int.multiplication composite intL intR)
                             intLR))))
             ))))
