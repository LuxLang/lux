(.module:
  [lux #*
   ["_" test (#+ Test)]
   [abstract
    [monad (#+ do)]]
   [control
    ["." function]]
   [data
    [number
     ["." nat]
     ["." int]]]
   [math
    ["." random (#+ Random)]]]
  {1
   ["." /
    [//
     [equivalence (#+ Equivalence)]]]})

(def: #export (spec (^open "/@.") (^open "/@.") gen-sample)
  (All [a] (-> (Equivalence a) (/.Monoid a) (Random a) Test))
  (do random.monad
    [sample gen-sample
     left gen-sample
     mid gen-sample
     right gen-sample]
    (<| (_.with-cover [/.Monoid])
        ($_ _.and
            (_.test "Left identity."
                    (/@= sample
                         (/@compose /@identity sample)))
            (_.test "Right identity."
                    (/@= sample
                         (/@compose sample /@identity)))
            (_.test "Associativity."
                    (/@= (/@compose left (/@compose mid right))
                         (/@compose (/@compose left mid) right)))
            ))))

(def: #export test
  Test
  (do random.monad
    [natL random.nat
     natR random.nat
     intL random.int
     intR random.int]
    (<| (_.covering /._)
        ($_ _.and
            (_.cover [/.compose]
                     (let [[natLR intLR] (:: (/.compose nat.addition int.multiplication) compose
                                             [natL intL] [natR intR])]
                       (and (nat.= (:: nat.addition compose natL natR)
                                   natLR)
                            (int.= (:: int.multiplication compose intL intR)
                                   intLR))))
            ))))
