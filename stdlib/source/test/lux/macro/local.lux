(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    ["." meta]
    [abstract
     [monad {"+" [do]}]]
    [control
     ["." try]
     ["." exception]
     ["<>" parser
      ["<.>" code]]]
    [data
     [text
      ["%" format]]
     [collection
      ["." list]
      [dictionary
       ["." plist]]]]
    ["." macro
     [syntax {"+" [syntax:]}]
     ["." code]]
    [math
     ["." random {"+" [Random]}]
     [number
      ["n" nat]]]]]
  [\\library
   ["." /]])

(syntax: (macro_error [macro <code>.any])
  (function (_ compiler)
    (case ((macro.expansion macro) compiler)
      (#try.Failure error)
      (#try.Success [compiler (list (code.text error))])
      
      (#try.Success _)
      (#try.Failure "OOPS!"))))

(def: (constant output)
  (-> Code Macro)
  ("lux macro"
   (function (_ inputs lux)
     (#try.Success [lux (list output)]))))

(syntax: (with [name (<code>.tuple (<>.and <code>.text <code>.text))
                constant <code>.any
                pre_remove <code>.bit
                body <code>.any])
  (macro.with_identifiers [g!output]
    (do meta.monad
      [pop! (/.push (list [name (..constant constant)]))
       [module short] (meta.normal name)
       _ (if pre_remove
           (let [remove_macro! (: (-> .Module .Module)
                                  (revised@ #.definitions (plist.lacks short)))]
             (function (_ lux)
               (#try.Success [(revised@ #.modules (plist.revised module remove_macro!) lux)
                              []])))
           (in []))]
      (let [pre_expansion (` (let [(~ g!output) (~ body)]
                               (exec (~ pop!)
                                 (~ g!output))))]
        (if pre_remove
          (macro.full_expansion pre_expansion)
          (in (list pre_expansion)))))))

(def: .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [expected random.nat]
        ($_ _.and
            (_.cover [/.push]
                     (..with ["" "actual"] expected #0
                       (n.= expected (..actual))))
            (_.cover [/.unknown_module]
                     (exception.match? /.unknown_module
                                       (..macro_error
                                        (..with ["123yolo456" "actual"] expected #0
                                          (n.= expected (..actual))))))
            (_.cover [/.cannot_shadow_definition]
                     (exception.match? /.cannot_shadow_definition
                                       (..macro_error
                                        (..with ["" "with"] expected #0
                                          (n.= expected (..actual))))))
            (_.cover [/.unknown_definition]
                     (exception.match? /.unknown_definition
                                       (<| ..macro_error
                                           (..with ["" "actual"] expected #1)
                                           (n.= expected (..actual)))))
            ))))
