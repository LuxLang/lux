(.module:
  [lux #*
   data/text/format
   [control/monad (#+ do)]
   ["r" math/random (#+ Random)]
   ["_" test (#+ Test)]
   [control
    [equivalence (#+ Equivalence)]
    ["p" parser]]
   [data
    ["." bit]
    ["." name]
    ["." error (#+ Error)]
    ["." text]
    [number
     ["." nat]
     ["." int]
     ["." rev]
     ["." frac]]]
   ["." macro
    ["." code]]]
  {1
   ["." / (#+ syntax: Syntax)]})

(def: (enforced? parser input)
  (-> (Syntax []) (List Code) Bit)
  (case (p.run input parser)
    (#.Right [_ []])
    #1

    _
    #0))

(def: (found? parser input)
  (-> (Syntax Bit) (List Code) Bit)
  (case (p.run input parser)
    (#.Right [_ #1])
    #1

    _
    #0))

(def: (equals? Equivalence<a> reference parser input)
  (All [a] (-> (Equivalence a) a (Syntax a) (List Code) Bit))
  (case (p.run input parser)
    (#.Right [_ output])
    (:: Equivalence<a> = reference output)

    _
    #0))

(def: (fails? input)
  (All [a] (-> (Error a) Bit))
  (case input
    (#.Left _)
    #1

    _
    #0))

(syntax: (match pattern input)
  (wrap (list (` (case (~ input)
                   (^ (#.Right [(~' _) (~ pattern)]))
                   #1

                   (~' _)
                   #0)))))

(def: simple-values
  Test
  (`` ($_ _.and
          (~~ (template [<assertion> <value> <ctor> <Equivalence> <get>]
                [(_.test <assertion>
                         (and (equals? <Equivalence> <value> <get> (list (<ctor> <value>)))
                              (found? (/.this? (<ctor> <value>)) (list (<ctor> <value>)))
                              (enforced? (/.this (<ctor> <value>)) (list (<ctor> <value>)))))]

                ["Can parse Bit syntax."        #1             code.bit        bit.equivalence  /.bit]
                ["Can parse Nat syntax."        123            code.nat        nat.equivalence  /.nat]
                ["Can parse Int syntax."        +123           code.int        int.equivalence  /.int]
                ["Can parse Rev syntax."       .123            code.rev        rev.equivalence  /.rev]
                ["Can parse Frac syntax."       +123.0         code.frac       frac.equivalence /.frac]
                ["Can parse Text syntax."       text.new-line  code.text       text.equivalence /.text]
                ["Can parse Identifier syntax." ["yolo" "lol"] code.identifier name.equivalence /.identifier]
                ["Can parse Tag syntax."        ["yolo" "lol"] code.tag        name.equivalence /.tag]
                ))
          (_.test "Can parse identifiers belonging to the current namespace."
                  (and (match "yolo"
                              (p.run (list (code.local-identifier "yolo"))
                                     /.local-identifier))
                       (fails? (p.run (list (code.identifier ["yolo" "lol"]))
                                      /.local-identifier))))
          (_.test "Can parse tags belonging to the current namespace."
                  (and (match "yolo"
                              (p.run (list (code.local-tag "yolo"))
                                     /.local-tag))
                       (fails? (p.run (list (code.tag ["yolo" "lol"]))
                                      /.local-tag))))
          )))

(def: complex-values
  Test
  (`` ($_ _.and
          (~~ (template [<type> <parser> <ctor>]
                [(_.test (format "Can parse " <type> " syntax.")
                         (and (match [#1 +123]
                                     (p.run (list (<ctor> (list (code.bit #1) (code.int +123))))
                                            (<parser> (p.and /.bit /.int))))
                              (match #1
                                     (p.run (list (<ctor> (list (code.bit #1))))
                                            (<parser> /.bit)))
                              (fails? (p.run (list (<ctor> (list (code.bit #1) (code.int +123))))
                                             (<parser> /.bit)))
                              (match (#.Left #1)
                                     (p.run (list (<ctor> (list (code.bit #1))))
                                            (<parser> (p.or /.bit /.int))))
                              (match (#.Right +123)
                                     (p.run (list (<ctor> (list (code.int +123))))
                                            (<parser> (p.or /.bit /.int))))
                              (fails? (p.run (list (<ctor> (list (code.frac +123.0))))
                                             (<parser> (p.or /.bit /.int))))))]

                ["form"  /.form  code.form]
                ["tuple" /.tuple code.tuple]))
          (_.test "Can parse record syntax."
                  (match [#1 +123]
                         (p.run (list (code.record (list [(code.bit #1) (code.int +123)])))
                                (/.record (p.and /.bit /.int)))))
          )))

(def: #export test
  Test
  (<| (_.context (%name (name-of /._)))
      ($_ _.and
          ..simple-values
          ..complex-values
          ($_ _.and
              (_.test "Can parse any Code."
                      (match [_ (#.Bit #1)]
                             (p.run (list (code.bit #1) (code.int +123))
                                    /.any)))
              (_.test "Can check whether the end has been reached."
                      (and (match #1
                                  (p.run (list)
                                         /.end?))
                           (match #0
                                  (p.run (list (code.bit #1))
                                         /.end?))))
              (_.test "Can ensure the end has been reached."
                      (and (match []
                                  (p.run (list)
                                         /.end!))
                           (fails? (p.run (list (code.bit #1))
                                          /.end!))))
              ))))
