(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    [abstract
     [monad {"+" [do]}]]
    [control
     ["[0]" try]
     ["[0]" exception]
     [parser
      ["<[0]>" code]]]
    [data
     [collection
      ["[0]" list]]]
    ["[0]" macro
     [syntax {"+" [syntax:]}]
     ["[0]" code]]
    [math
     ["[0]" random {"+" [Random]}]
     [number
      ["[0]" nat]]]]]
  [\\library
   ["[0]" /]])

(/.let [(!pow/2 <scalar>)
        [(nat.* <scalar> <scalar>)]]
  (def: pow/2
    (-> Nat Nat)
    (|>> !pow/2)))

(syntax: (macro_error [macro <code>.any])
  (function (_ compiler)
    (case ((macro.expansion macro) compiler)
      {try.#Failure error}
      {try.#Success [compiler (list (code.text error))]}
      
      {try.#Success _}
      {try.#Failure "OOPS!"})))

(def: .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [left random.nat
         mid random.nat
         right random.nat]
        (with_expansions [<module> (as_is [.5 -4 +3 2 #1 #0 c b "a"])
                          <module>' ".5-4+32#1#0cba"
                          <short> (as_is ["a" b c #0 #1 2 +3 -4 .5])
                          <short>' "abc#0#12+3-4.5"]
          ($_ _.and
              (_.cover [/.spliced]
                       (\ (list.equivalence nat.equivalence) =
                          (list left mid right)
                          (`` (list (~~ (/.spliced [left mid right]))))))
              (_.cover [/.amount]
                       (case (/.amount [left mid right])
                         3 true
                         _ false))
              (_.cover [/.text]
                       (case (/.text <short>)
                         <short>' true
                         _ false))
              (_.cover [/.identifier]
                       (and (case (`` (name_of (~~ (/.identifier <short>))))
                              ["" <short>'] true
                              _ false)
                            (case (`` (name_of (~~ (/.identifier <module> <short>))))
                              [<module>' <short>'] true
                              _ false)
                            ))
              (_.cover [/.with_locals]
                       (/.with_locals [var0 var1]
                         (let [var0 left
                               var1 right]
                           (and (nat.= left var0)
                                (nat.= right var1)))))
              (do !
                [scalar random.nat]
                (_.cover [/.let]
                         (let [can_use_with_statements!
                               (nat.= ($_ nat.* scalar scalar)
                                      (..pow/2 scalar))]
                           (and can_use_with_statements!
                                (/.let [(pow/3 <scalar>)
                                        [($_ nat.* <scalar> <scalar> <scalar>)]

                                        (pow/9 <scalar>)
                                        [(pow/3 (pow/3 <scalar>))]]
                                  (let [can_use_with_expressions!
                                        (nat.= ($_ nat.* scalar scalar scalar)
                                               (pow/3 scalar))

                                        can_refer!
                                        (nat.= ($_ nat.*
                                                   scalar scalar scalar
                                                   scalar scalar scalar
                                                   scalar scalar scalar)
                                               (pow/9 scalar))

                                        can_shadow!
                                        (let [pow/3 (function (_ scalar)
                                                      ($_ nat.+ scalar scalar scalar))]
                                          (nat.= ($_ nat.+ scalar scalar scalar)
                                                 (pow/3 scalar)))]
                                    (and can_use_with_expressions!
                                         can_refer!
                                         can_shadow!)))
                                ))))
              (_.cover [/.irregular_arguments]
                       (/.let [(arity/3 <0> <1> <2>)
                               [""]]
                         (exception.match? /.irregular_arguments
                                           (macro_error (arity/3 "a" "b")))))
              )))
      ))
