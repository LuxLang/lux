(.module:
  [lux #*
   ["_" test (#+ Test)]
   [abstract
    [monad (#+ do)]
    [equivalence (#+ Equivalence)]]
   [control
    [pipe (#+ case>)]
    ["." try]
    ["<>" parser
     ["<c>" code]]]
   [data
    ["." product]
    ["." bit ("#\." equivalence)]
    ["." name]
    ["." text]
    [collection
     ["." list]]]
   [macro
    ["." code]]
   [math
    ["." random (#+ Random)]
    [number
     ["n" nat]]]]
  {1
   ["." /
    ["#." reader]
    ["#." writer]]}
  ["." /// #_
   ["#." code]]
  ["." / #_
   ["#." annotations]
   ["#." check]
   ["#." declaration]
   ["#." definition]
   ["#." export]
   ["#." type #_
    ["#/." variable]]])

(def: random_text
  (Random Text)
  (random.ascii/alpha 10))

(def: #export test
  Test
  (<| (_.covering /._)
      (_.covering /reader._)
      (_.covering /writer._)
      ($_ _.and
          (do {! random.monad}
            [expected (: (Random /.Typed_Input)
                         (random.and ///code.random
                                     ///code.random))]
            (_.cover [/.Typed_Input /reader.typed_input /writer.typed_input]
                     (|> expected
                         /writer.typed_input list
                         (<c>.run /reader.typed_input)
                         (case> (#try.Success actual)
                                (let [equivalence (product.equivalence code.equivalence code.equivalence)]
                                  (\ equivalence = expected actual))
                                
                                (#try.Failure error)
                                false))))

          /annotations.test
          /check.test
          /declaration.test
          /definition.test
          /export.test
          /type/variable.test
          )))
