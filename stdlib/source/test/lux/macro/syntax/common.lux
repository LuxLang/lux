(.module:
  [lux #*
   ["_" test (#+ Test)]
   [math
    ["." random (#+ Random)]]
   [abstract
    [monad (#+ do)]
    [equivalence (#+ Equivalence)]]
   [control
    [pipe (#+ case>)]
    ["." try]
    ["<>" parser
     ["<c>" code]]]
   [data
    ["." product]
    ["." bit ("#\." equivalence)]
    ["." name]
    ["." text]
    [number
     ["n" nat]]
    [collection
     ["." list]]]
   [macro
    ["." code]]]
  {1
   ["." /
    ["#." reader]
    ["#." writer]]}
  ["." /// #_
   ["#." code]]
  ["." / #_
   ["#." check]
   ["#." definition]
   ["#." export]])

(def: annotations_equivalence
  (Equivalence /.Annotations)
  (list.equivalence
   (product.equivalence name.equivalence
                        code.equivalence)))

(def: random_text
  (Random Text)
  (random.ascii/alpha 10))

(def: random_name
  (Random Name)
  (random.and ..random_text ..random_text))

(def: random_annotations
  (Random /.Annotations)
  (do {! random.monad}
    [size (\ ! map (|>> (n.% 3)) random.nat)]
    (random.list size (random.and random_name
                                  ///code.random))))

(def: #export test
  Test
  (<| (_.covering /._)
      (_.covering /reader._)
      (_.covering /writer._)
      ($_ _.and
          (_.for [/.Annotations]
                 ($_ _.and
                     (do random.monad
                       [expected ..random_annotations]
                       (_.cover [/reader.annotations /writer.annotations]
                                (|> expected
                                    /writer.annotations list
                                    (<c>.run /reader.annotations)
                                    (case> (#try.Success actual)
                                           (\ ..annotations_equivalence = expected actual)
                                           
                                           (#try.Failure error)
                                           false))))
                     (_.cover [/.empty_annotations]
                              (|> /.empty_annotations
                                  /writer.annotations list
                                  (<c>.run /reader.annotations)
                                  (case> (#try.Success actual)
                                         (\ ..annotations_equivalence = /.empty_annotations actual)
                                         
                                         (#try.Failure error)
                                         false)))
                     ))
          (do {! random.monad}
            [size (\ ! map (|>> (n.% 3)) random.nat)
             expected (random.list size ..random_text)]
            (_.cover [/.Type_Var /reader.type_variables /writer.type_variables]
                     (|> expected
                         /writer.type_variables
                         (<c>.run /reader.type_variables)
                         (case> (#try.Success actual)
                                (\ (list.equivalence text.equivalence) = expected actual)
                                
                                (#try.Failure error)
                                false))))
          (do {! random.monad}
            [size (\ ! map (|>> (n.% 3)) random.nat)
             expected (: (Random /.Declaration)
                         (random.and ..random_text
                                     (random.list size ..random_text)))]
            (_.cover [/.Declaration /reader.declaration /writer.declaration]
                     (|> expected
                         /writer.declaration list
                         (<c>.run /reader.declaration)
                         (case> (#try.Success actual)
                                (let [equivalence (product.equivalence text.equivalence
                                                                       (list.equivalence text.equivalence))]
                                  (\ equivalence = expected actual))
                                
                                (#try.Failure error)
                                false))))
          (do {! random.monad}
            [expected (: (Random /.Typed_Input)
                         (random.and ///code.random
                                     ///code.random))]
            (_.cover [/.Typed_Input /reader.typed_input /writer.typed_input]
                     (|> expected
                         /writer.typed_input list
                         (<c>.run /reader.typed_input)
                         (case> (#try.Success actual)
                                (let [equivalence (product.equivalence code.equivalence code.equivalence)]
                                  (\ equivalence = expected actual))
                                
                                (#try.Failure error)
                                false))))

          /check.test
          /definition.test
          /export.test
          )))
