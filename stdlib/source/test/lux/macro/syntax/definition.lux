(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]
    [\\specification
     ["$[0]" equivalence]]]
   [control
    ["[0]" try]
    ["[0]" exception]
    ["<>" parser
     ["<[0]>" code]]]
   [macro
    ["[0]" code ("[1]#[0]" equivalence)]]
   [math
    ["[0]" random {"+" Random}]]
   [meta
    ["[0]" location]]]]
 [\\library
  ["[0]" /]]
 ["$[0]"// "_"
  ["[1][0]" check]
  ["[1]/" // "_"
   ["[1][0]" code]]])

(def: .public random
  (Random /.Definition)
  (all random.and
       (random.alphabetic 5)
       (random.or $//check.random
                  $///code.random)
       random.bit
       ))

(def: compiler
  [.#info            [.#target "FAKE"
                      .#version "0.0.0"
                      .#mode {.#Build}
                      .#configuration (list)]
   .#source          [location.dummy 0 ""]
   .#location        location.dummy
   .#current_module  {.#None}
   .#modules         (list)
   .#scopes          (list)
   .#type_context    [.#ex_counter 0
                      .#var_counter 0
                      .#var_bindings (list)]
   .#expected        {.#None}
   .#seed            0
   .#scope_type_vars (list)
   .#extensions      []
   .#eval            (as (-> Type Code (Meta Any)) [])
   .#host            []])

(def: .public test
  Test
  (<| (_.covering /._)
      (_.for [/.Definition])
      (all _.and
           (_.for [/.equivalence]
                  ($equivalence.spec /.equivalence ..random))

           (do random.monad
             [expected ..random
              
              type $///code.random
              untyped_value $///code.random]
             (all _.and
                  (_.cover [/.format /.parser]
                           (case (<code>.result (/.parser compiler)
                                                (list (/.format expected)))
                             {try.#Failure error}
                             false
                             
                             {try.#Success actual}
                             (# /.equivalence = expected actual)))
                  (_.cover [/.typed]
                           (let [expected (has /.#value {.#Left [type untyped_value]} expected)]
                             (case (<code>.result (/.typed compiler)
                                                  (list (/.format expected)))
                               {try.#Failure error}
                               false
                               
                               {try.#Success actual}
                               (# /.equivalence = expected actual))))
                  (_.cover [/.lacks_type]
                           (let [expected (has /.#value {.#Right untyped_value} expected)]
                             (case (<code>.result (/.typed compiler)
                                                  (list (/.format expected)))
                               {try.#Failure error}
                               (exception.match? /.lacks_type error)
                               
                               {try.#Success actual}
                               false)))
                  )))
      ))
