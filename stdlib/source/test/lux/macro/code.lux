(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]
    [\\specification
     ["$[0]" equivalence]]]
   [control
    ["[0]" try {"+" Try}]]
   [data
    ["[0]" product]
    ["[0]" text]
    [collection
     ["[0]" list ("[1]#[0]" functor)]]]
   [math
    ["[0]" random {"+" Random} ("[1]#[0]" monad)]
    [number
     ["n" nat]]]
   [meta
    ["[0]" location]]
   [tool
    [compiler
     [language
      [lux
       ["[0]" syntax]]]]]]]
 [\\library
  ["[0]" /]])

(def: random_text
  (Random Text)
  (random.ascii/alpha 10))

(def: random_symbol
  (Random Symbol)
  (random.and ..random_text ..random_text))

(def: (random_sequence random)
  (All (_ a) (-> (Random a) (Random (List a))))
  (do [! random.monad]
    [size (|> random.nat (# ! each (n.% 3)))]
    (random.list size random)))

(def: .public random
  (Random Code)
  (random.rec
   (function (_ random)
     ($_ random.either
         (random#each /.bit random.bit)
         (random#each /.nat random.nat)
         (random#each /.int random.int)
         (random#each /.rev random.rev)
         (random#each /.frac random.safe_frac)
         (random#each /.text ..random_text)
         (random#each /.symbol ..random_symbol)
         (random#each /.form (..random_sequence random))
         (random#each /.variant (..random_sequence random))
         (random#each /.tuple (..random_sequence random))
         ))))

(def: (read source_code)
  (-> Text (Try Code))
  (let [parse (syntax.parse ""
                            syntax.no_aliases
                            (text.size source_code))
        start (is Source
                  [location.dummy 0 source_code])]
    (case (parse start)
      {.#Left [end error]}
      {try.#Failure error}
      
      {.#Right [end lux_code]}
      {try.#Success lux_code})))

(def: (replacement_simulation [original substitute])
  (-> [Code Code] (Random [Code Code]))
  (random.rec
   (function (_ replacement_simulation)
     (let [for_sequence (is (-> (-> (List Code) Code) (Random [Code Code]))
                            (function (_ to_code)
                              (random.only (|>> product.left (# /.equivalence = original) not)
                                           (do [! random.monad]
                                             [parts (..random_sequence replacement_simulation)]
                                             (in [(to_code (list#each product.left parts))
                                                  (to_code (list#each product.right parts))])))))]
       ($_ random.either
           (random#in [original substitute])
           (do [! random.monad]
             [sample (random.only (|>> (# /.equivalence = original) not)
                                  ($_ random.either
                                      (random#each /.bit random.bit)
                                      (random#each /.nat random.nat)
                                      (random#each /.int random.int)
                                      (random#each /.rev random.rev)
                                      (random#each /.frac random.safe_frac)
                                      (random#each /.text ..random_text)
                                      (random#each /.symbol ..random_symbol)))]
             (in [sample sample]))
           (for_sequence /.form)
           (for_sequence /.variant)
           (for_sequence /.tuple)
           )))))

(def: for_format
  Test
  (`` ($_ _.and
          (~~ (template [<coverage> <random> <tag>]
                [(do [! random.monad]
                   [expected <random>]
                   (_.cover [<coverage>]
                            (and (case (..read (/.format (<coverage> expected)))
                                   {try.#Success actual}
                                   (# /.equivalence =
                                      actual
                                      (<coverage> expected))
                                   
                                   {try.#Failure error}
                                   false)
                                 (# /.equivalence =
                                    [location.dummy {<tag> expected}]
                                    (<coverage> expected)))))]

                [/.bit random.bit .#Bit]
                [/.nat random.nat .#Nat]
                [/.int random.int .#Int]
                [/.rev random.rev .#Rev]
                [/.frac random.safe_frac .#Frac]
                [/.text ..random_text .#Text]
                [/.symbol ..random_symbol .#Symbol]
                [/.form (..random_sequence ..random) .#Form]
                [/.variant (..random_sequence ..random) .#Variant]
                [/.tuple (..random_sequence ..random) .#Tuple]))
          (~~ (template [<coverage> <random> <tag>]
                [(do [! random.monad]
                   [expected <random>]
                   (_.cover [<coverage>]
                            (and (case (..read (/.format (<coverage> expected)))
                                   {try.#Success actual}
                                   (# /.equivalence =
                                      actual
                                      (<coverage> expected))
                                   
                                   {try.#Failure error}
                                   false)
                                 (# /.equivalence =
                                    [location.dummy {<tag> ["" expected]}]
                                    (<coverage> expected)))
                            ))]

                [/.local_symbol ..random_text .#Symbol]
                )))))

(def: .public test
  Test
  (<| (_.covering /._)
      ($_ _.and
          (_.for [/.equivalence]
                 ($equivalence.spec /.equivalence ..random))
          
          (_.for [/.format]
                 ..for_format)
          
          (do [! random.monad]
            [[original substitute] (random.only (function (_ [original substitute])
                                                  (not (# /.equivalence = original substitute)))
                                                (random.and ..random ..random))
             [sample expected] (random.only (function (_ [sample expected])
                                              (not (# /.equivalence = sample expected)))
                                            (..replacement_simulation [original substitute]))]
            (_.cover [/.replaced]
                     (# /.equivalence =
                        expected
                        (/.replaced original substitute sample))))
          )))
