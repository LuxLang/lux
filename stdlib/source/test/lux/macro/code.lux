(.module:
  [library
   [lux #*
    ["_" test (#+ Test)]
    [abstract
     [monad (#+ do)]
     [\\specification
      ["$." equivalence]]]
    [control
     ["." try (#+ Try)]]
    [data
     ["." product]
     ["." text]
     [collection
      ["." list ("#\." functor)]]]
    [math
     ["." random (#+ Random) ("#\." monad)]
     [number
      ["n" nat]]]
    [meta
     ["." location]]
    [tool
     [compiler
      [language
       [lux
        ["." syntax]]]]]]]
  [\\library
   ["." /]])

(def: random_text
  (Random Text)
  (random.ascii/alpha 10))

(def: random_name
  (Random Name)
  (random.and ..random_text ..random_text))

(def: (random_sequence random)
  (All (_ a) (-> (Random a) (Random (List a))))
  (do {! random.monad}
    [size (|> random.nat (\ ! each (n.% 3)))]
    (random.list size random)))

(def: (random_record random)
  (All (_ a) (-> (Random a) (Random (List [a a]))))
  (do {! random.monad}
    [size (|> random.nat (\ ! each (n.% 3)))]
    (random.list size (random.and random random))))

(def: .public random
  (Random Code)
  (random.rec
   (function (_ random)
     ($_ random.either
         (random\each /.bit random.bit)
         (random\each /.nat random.nat)
         (random\each /.int random.int)
         (random\each /.rev random.rev)
         (random\each /.frac random.safe_frac)
         (random\each /.text ..random_text)
         (random\each /.identifier ..random_name)
         (random\each /.tag ..random_name)
         (random\each /.form (..random_sequence random))
         (random\each /.tuple (..random_sequence random))
         (random\each /.record (..random_record random))
         ))))

(def: (read source_code)
  (-> Text (Try Code))
  (let [parse (syntax.parse ""
                            syntax.no_aliases
                            (text.size source_code))
        start (: Source
                 [location.dummy 0 source_code])]
    (case (parse start)
      (#.Left [end error])
      (#try.Failure error)
      
      (#.Right [end lux_code])
      (#try.Success lux_code))))

(def: (replacement_simulation [original substitute])
  (-> [Code Code] (Random [Code Code]))
  (random.rec
   (function (_ replacement_simulation)
     (let [for_sequence (: (-> (-> (List Code) Code) (Random [Code Code]))
                           (function (_ to_code)
                             (do {! random.monad}
                               [parts (..random_sequence replacement_simulation)]
                               (in [(to_code (list\each product.left parts))
                                    (to_code (list\each product.right parts))]))))]
       ($_ random.either
           (random\in [original substitute])
           (do {! random.monad}
             [sample (random.only (|>> (\ /.equivalence = original) not)
                                  ($_ random.either
                                      (random\each /.bit random.bit)
                                      (random\each /.nat random.nat)
                                      (random\each /.int random.int)
                                      (random\each /.rev random.rev)
                                      (random\each /.frac random.safe_frac)
                                      (random\each /.text ..random_text)
                                      (random\each /.identifier ..random_name)
                                      (random\each /.tag ..random_name)))]
             (in [sample sample]))
           (for_sequence /.form)
           (for_sequence /.tuple)
           (do {! random.monad}
             [parts (..random_sequence replacement_simulation)]
             (in [(/.record (let [parts' (list\each product.left parts)]
                              (list.zipped/2 parts' parts')))
                  (/.record (let [parts' (list\each product.right parts)]
                              (list.zipped/2 parts' parts')))]))
           )))))

(def: for_format
  Test
  (`` ($_ _.and
          (~~ (template [<coverage> <random> <tag>]
                [(do {! random.monad}
                   [expected <random>]
                   (_.cover [<coverage>]
                            (and (case (..read (/.format (<coverage> expected)))
                                   (#try.Success actual)
                                   (\ /.equivalence =
                                      actual
                                      (<coverage> expected))
                                   
                                   (#try.Failure error)
                                   false)
                                 (\ /.equivalence =
                                    [location.dummy (<tag> expected)]
                                    (<coverage> expected)))))]

                [/.bit random.bit #.Bit]
                [/.nat random.nat #.Nat]
                [/.int random.int #.Int]
                [/.rev random.rev #.Rev]
                [/.frac random.safe_frac #.Frac]
                [/.text ..random_text #.Text]
                [/.tag ..random_name #.Tag]
                [/.identifier ..random_name #.Identifier]
                [/.form (..random_sequence ..random) #.Form]
                [/.tuple (..random_sequence ..random) #.Tuple]
                [/.record (..random_record ..random) #.Record]))
          (~~ (template [<coverage> <random> <tag>]
                [(do {! random.monad}
                   [expected <random>]
                   (_.cover [<coverage>]
                            (and (case (..read (/.format (<coverage> expected)))
                                   (#try.Success actual)
                                   (\ /.equivalence =
                                      actual
                                      (<coverage> expected))
                                   
                                   (#try.Failure error)
                                   false)
                                 (\ /.equivalence =
                                    [location.dummy (<tag> ["" expected])]
                                    (<coverage> expected)))
                            ))]

                [/.local_tag        ..random_text #.Tag]
                [/.local_identifier ..random_text #.Identifier]
                )))))

(def: .public test
  Test
  (<| (_.covering /._)
      ($_ _.and
          (_.for [/.equivalence]
                 ($equivalence.spec /.equivalence ..random))
          
          (_.for [/.format]
                 ..for_format)
          
          (do {! random.monad}
            [[original substitute] (random.only (function (_ [original substitute])
                                                  (not (\ /.equivalence = original substitute)))
                                                (random.and ..random ..random))
             [sample expected] (random.only (function (_ [sample expected])
                                              (not (\ /.equivalence = sample expected)))
                                            (..replacement_simulation [original substitute]))]
            (_.cover [/.replaced]
                     (\ /.equivalence =
                        expected
                        (/.replaced original substitute sample))))
          )))
