... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]
    [equivalence (.only Equivalence)]]
   ["[0]" function]
   [data
    ["[0]" bit]
    ["[0]" product]
    [collection
     ["[0]" list]
     ["[0]" stack]]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["[0]" natural]
     ["[0]" integer]
     ["[0]" decimal]]]
   [test
    ["_" property (.only Test)]]]]
 [\\library
  ["[0]" /]])

(the .public (lens_specification it
                                 equivalence_of_context equivalence_of_focus
                                 random_context random_focus)
  (for_any (_ context focus)
    (-> (/.Lens context focus)
        (Equivalence context) (Equivalence focus)
        (Random context) (Random focus)
        Test))
  (do [! random.monad]
    [expected_context random_context
     expected_focus random_focus
     other_focus random_focus]
    (<| (_.for [/.Lens /.lens])
        (all _.and
             (_.coverage [/.#has /.has]
               (let [later_writes_overwrite_earlier_writes!
                     (by equivalence_of_context =
                         (/.has it expected_focus expected_context)
                         (/.has it expected_focus (/.has it other_focus expected_context)))]
                 later_writes_overwrite_earlier_writes!))
             (_.coverage [/.#its /.its]
               (let [can_focus!
                     (by equivalence_of_focus =
                         expected_focus
                         (/.its it (/.has it expected_focus expected_context)))

                     can_only_change_the_focus!
                     (by equivalence_of_context =
                         expected_context
                         (/.has it (/.its it expected_context) expected_context))]
                 (and can_focus!
                      can_only_change_the_focus!)))
             ))))

(the sign
  (/.Lens Integer Bit)
  (/.lens (integer.>= +0)
          (function (has [sign mantissa])
            ((is (Change Integer)
                 (if sign
                     function.identity
                     integer.opposite))
             (integer.absolute mantissa)))))

(the left
  (for_any (_ left right)
    (/.Lens [left right] left))
  (/.lens product.left
          (function (has [left [_ right]])
            [left right])))

(the .public (view_specification view
                                 equivalence_of_it equivalence_of_alternative
                                 random_it random_alternative)
  (for_any (_ it alternative)
    (-> (/.View it alternative)
        (Equivalence it) (Equivalence alternative)
        (Random it) (Random alternative)
        Test))
  (do [! random.monad]
    [it_0 random_it
     it_1 random_it
     
     alternative_0 random_alternative
     alternative_1 random_alternative]
    (<| (_.for [/.View /.view])
        (all _.and
             (_.coverage [/.#as /.as]
               (and (bit.= (by equivalence_of_it = it_0 it_1)
                           (by equivalence_of_alternative = (/.as view it_0) (/.as view it_1)))
                    (|> it_0
                        (/.as view)
                        (/.of view)
                        (by equivalence_of_it = it_0))))
             (_.coverage [/.#of /.of]
               (and (bit.= (by equivalence_of_alternative = alternative_0 alternative_1)
                           (by equivalence_of_it = (/.of view alternative_0) (/.of view alternative_1)))
                    (|> alternative_0
                        (/.of view)
                        (/.as view)
                        (by equivalence_of_alternative = alternative_0))))
             ))))

(the list_as_stack
  (for_any (_ it)
    (/.View (List it) (Stack it)))
  (/.view list.as_stack
          list.of_stack))

(the .public (prism_specification prism
                                  equivalence_of_context equivalence_of_case
                                  random_context random_case)
  (for_any (_ context case)
    (-> (/.Prism context case)
        (Equivalence context) (Equivalence case)
        (Random context) (Random case)
        Test))
  (do [! random.monad]
    [expected_context random_context
     expected_case random_case]
    (<| (_.for [/.Prism /.prism])
        (all _.and
             (_.coverage [/.#when /.when]
               (when (/.when prism expected_context)
                 {.#Left actual_context}
                 (same? expected_context actual_context)

                 {.#Right actual_case}
                 (by equivalence_of_context = expected_context (/.some prism actual_case))))
             (_.coverage [/.#some /.some]
               (let [expected_context (/.some prism expected_case)]
                 (when (/.when prism expected_context)
                   {.#Right actual_case}
                   (by equivalence_of_case = expected_case actual_case)

                   {.#Left actual_context}
                   false)))
             ))))

(the whole
  (/.Prism Decimal Integer)
  (/.prism (function (_ it)
             (let [case (decimal.whole it)]
               (if (decimal.= it case)
                   {.#Right (decimal.integer it)}
                   {.#Left it})))
           integer.decimal))

(every (Tree it)
  (Variant
   {#Leaf}
   {#Branch (Tree it) it (Tree it)}))

(the (in_order it)
  (for_any (_ it)
    (/.Member (Tree it) it))
  (<| (with /.membership_apply)
      (when it
        {#Leaf}
        (pure {#Leaf})
        
        {#Branch left it right}
        (left_associative with
                          (pure (function (_ left it right)
                                  {#Branch left it right}))
                          (in_order left)
                          (/.one it)
                          (in_order right)))))

(the .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [expected random.integer
         other random.natural])
      (all _.and
           (..lens_specification sign
                                 integer.equivalence bit.equivalence
                                 random.integer random.bit)
           (do [! random.monad]
             [size (by ! each (natural.% 10) random.natural)]
             (..view_specification ..list_as_stack
                                   (list.equivalence natural.equivalence)
                                   (stack.equivalence natural.equivalence)
                                   
                                   (random.list size random.natural)
                                   (random.stack size random.natural)))
           (prism_specification ..whole
                                decimal.equivalence integer.equivalence
                                (by ! each (decimal.* +1,000,000.0) random.unit_decimal)
                                (by ! each (integer.% +1,000,000) random.integer))

           (_.coverage [/.revised]
             (let [is_exception! (or (integer.= +0 expected)
                                     (integer.= (by integer.interval minimum) expected))
                   
                   opposite (/.revised ..sign not)]
               (or is_exception!
                   (and (not (integer.= expected (opposite expected)))
                        (integer.= expected (opposite (opposite expected)))))))
           (_.coverage [/.composite]
             (bit.= (/.its ..sign expected)
                    (/.its (/.composite ..left ..sign) [expected other])))
           )))
