... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]
    ["[0]" equivalence
     ["[1]T" \\test]]]
   [math
    ["[0]" random (.only Random)]
    [number
     [/64
      ["[0]" integer]
      ["[0]" decimal]]]]
   [test
    ["_" property (.only Test)]]
   [meta
    ["[0]" static]]
   [logic
    ["[0]" bit]]
   ["[0]" type
    ["[1]" check]]]]
 [\\library
  ["[0]" /]])

(the (random_scalar range)
  (-> Natural
      (Random /.Scalar))
  (with random.monad
    (|> random.integer
        (each (|>> (integer.% (.integer range))
                   integer.decimal)))))

(the (random_vector range)
  (-> Natural
      (Random /.Vector))
  (random.and (..random_scalar range)
              (..random_scalar range)))

(the .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [.let [range 1,000,000
               random_scalar (..random_scalar range)
               random_vector (..random_vector 1,000)]
         initial_time random_scalar
         final_time random_scalar

         initial_position random_scalar
         final_position random_scalar

         origin random_vector
         destination random_vector
         scale random_scalar

         proximity random_scalar])
      (all _.and
           (<| (_.for [/.Scalar])
               (all _.and
                    (_.coverage [/.Dimension]
                      (type.< /.Scalar /.Dimension))
                    (_.coverage [/.Time]
                      (type.< /.Dimension /.Time))
                    (_.coverage [/.Position]
                      (type.< /.Dimension /.Position))
                    ))
           (<| (_.for [/.Change])
               (all _.and
                    (_.coverage [/.stasis]
                      (and (decimal.= final_time
                                      (/.stasis final_time))
                           (decimal.= decimal.zero
                                      (/.value /.stasis))))
                    (_.coverage [/.change]
                      (decimal.= final_position
                                 ((/.change initial_position final_position) initial_position)))
                    (_.coverage [/.value]
                      (let [difference (/.value (/.change initial_position final_position))]
                        (decimal.= final_position
                                   (decimal.+ difference initial_position))))
                    (<| (_.for [/.Interval])
                        (all _.and
                             (_.coverage [/.interval]
                               (decimal.= (decimal.opposite (/.value (/.interval initial_time final_time)))
                                          (/.value (/.interval final_time initial_time))))
                             ))
                    (<| (_.for [/.Displacement])
                        (all _.and
                             (_.coverage [/.displacement]
                               (decimal.= (decimal.opposite (/.value (/.displacement initial_position final_position)))
                                          (/.value (/.displacement final_position initial_position))))
                             ))
                    ))
           (<| (_.for [/.Vector
                       /.#forward/backward /.#left/right])
               (all _.and
                    (_.for [/.equivalence /.=]
                           (static.when (same? /.equivalence /.=)
                             (equivalenceT.spec /.equivalence (..random_vector 1,000))))

                    (_.coverage [/.+]
                      (/.= (/.+ origin destination)
                           (/.+ destination origin)))
                    (_.coverage [/.opposite]
                      (/.= /.origin
                           (/.+ destination
                                (/.opposite destination))))
                    (_.coverage [/.-]
                      (/.= (/.+ (/.opposite origin) destination)
                           (/.- origin destination)))
                    (_.coverage [/.x /./]
                      (|> destination
                          (/.x scale)
                          (/./ scale)
                          (/.= destination)))
                    (_.coverage [/.origin]
                      (and (/.= destination
                                (/.+ /.origin destination))
                           (/.= /.origin
                                (/.x decimal.zero destination))))
                    (_.coverage [/.Orientation
                                 /.magnitude /.orientation
                                 /.polar]
                      (/.approximately? +0.000,000,000,1
                                        destination
                                        (/.polar (/.magnitude destination)
                                                 (/.orientation destination))))
                    (_.coverage [/.distance]
                      (and (decimal.= decimal.zero
                                      (/.distance destination destination))
                           (decimal.= (/.distance origin destination)
                                      (/.distance destination origin))))
                    (_.coverage [/.approximately?]
                      (let [limit (/.distance origin destination)]
                        (and (/.approximately? limit origin destination)
                             (bit.= (decimal.< limit proximity)
                                    (not (/.approximately? proximity origin destination))))))
                    ))
           )))
