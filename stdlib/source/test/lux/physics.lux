... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]
    ["[0]" equivalence
     ["[1]T" \\test]]]
   [math
    ["[0]" random (.only Random)]
    [number
     [/64
      ["[0]" integer]
      ["[0]" decimal]]]]
   [test
    ["_" property (.only Test)]]
   [meta
    ["[0]" static]]
   [logic
    ["[0]" bit]]
   ["[0]" type
    ["[1]" check]]]]
 [\\library
  ["[0]" / (.only)
   ["[0]" /1 (.only)
    ["[1]T" \\test]]]])

(the (random_vector range)
  (-> Natural
      (Random /.Vector))
  (random.and (/1.random range)
              (/1.random range)))

(the .public test
  Test
  (<| (_.covering /._)
      (do [! random.monad]
        [.let [range 1,000,000
               random_scalar (/1.random range)
               random_vector (..random_vector 1,000)]
         origin random_vector
         destination random_vector
         scale random_scalar

         proximity random_scalar])
      (all _.and
           (<| (_.for [/.Vector
                       /.#forward/backward /.#left/right])
               (all _.and
                    (_.for [/.equivalence /.=]
                           (static.when (same? /.equivalence /.=)
                             (equivalenceT.spec /.equivalence (..random_vector 1,000))))

                    (_.coverage [/.+]
                      (/.= (/.+ origin destination)
                           (/.+ destination origin)))
                    (_.coverage [/.opposite]
                      (/.= /.origin
                           (/.+ destination
                                (/.opposite destination))))
                    (_.coverage [/.-]
                      (/.= (/.+ (/.opposite origin) destination)
                           (/.- origin destination)))
                    (_.coverage [/.x /./]
                      (|> destination
                          (/.x scale)
                          (/./ scale)
                          (/.= destination)))
                    (_.coverage [/.origin]
                      (and (/.= destination
                                (/.+ /.origin destination))
                           (/.= /.origin
                                (/.x decimal.zero destination))))
                    (_.coverage [/.Orientation
                                 /.magnitude /.orientation
                                 /.polar]
                      (/.approximately? +0.000,000,000,1
                                        destination
                                        (/.polar (/.magnitude destination)
                                                 (/.orientation destination))))
                    (_.coverage [/.distance]
                      (and (decimal.= decimal.zero
                                      (/.distance destination destination))
                           (decimal.= (/.distance origin destination)
                                      (/.distance destination origin))))
                    (_.coverage [/.approximately?]
                      (let [limit (/.distance origin destination)]
                        (and (/.approximately? limit origin destination)
                             (bit.= (decimal.< limit proximity)
                                    (not (/.approximately? proximity origin destination))))))
                    ))

           /1T.test
           )))
