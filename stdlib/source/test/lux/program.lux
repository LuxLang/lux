(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    [abstract
     [monad {"+" [do]}]]
    [control
     ["[0]" io]
     ["[0]" try]
     ["<>" parser
      ["<[0]>" code]
      ["<[0]>" cli]]]
    [data
     ["[0]" text]
     [collection
      ["[0]" list]]]
    [macro
     [syntax {"+" [syntax:]}]]
    [math
     ["[0]" random]]]]
  [\\library
   ["[0]" /]])

(syntax: (actual_program [actual_program (<| <code>.form
                                             (<>.after (<code>.text! "lux def program"))
                                             <code>.any)])
  (in (list actual_program)))

(def: .public test
  Test
  (<| (_.covering /._)
      (do random.monad
        [inputs (random.list 5 (random.ascii/upper 5))]
        (_.cover [/.program:]
                 (let [(^open "list\[0]") (list.equivalence text.equivalence)]
                   (and (with_expansions [<program> (/.program: all_arguments
                                                      (io.io all_arguments))]
                          (let [outcome ((: (-> (List Text) (io.IO Any))
                                            (..actual_program <program>))
                                         inputs)]
                            (same? (: Any inputs)
                                   (io.run! outcome))))
                        (with_expansions [<program> (/.program: [arg/0 <cli>.any
                                                                 arg/1 <cli>.any
                                                                 arg/2 <cli>.any
                                                                 arg/3 <cli>.any
                                                                 arg/4 <cli>.any]
                                                      (io.io (list arg/4 arg/3 arg/2 arg/1 arg/0)))]
                          (let [outcome ((: (-> (List Text) (io.IO Any))
                                            (..actual_program <program>))
                                         inputs)]
                            (list\= (list.reversed inputs)
                                    (:as (List Text) (io.run! outcome)))))
                        (with_expansions [<program> (/.program: [all_arguments (<>.many <cli>.any)]
                                                      (io.io all_arguments))]
                          (let [outcome ((: (-> (List Text) (io.IO Any))
                                            (..actual_program <program>))
                                         inputs)]
                            (list\= inputs
                                    (:as (List Text) (io.run! outcome)))))
                        (with_expansions [<program> (/.program: [arg/0 <cli>.any
                                                                 arg/1 <cli>.any
                                                                 arg/2 <cli>.any
                                                                 arg/3 <cli>.any]
                                                      (io.io []))]
                          (case (try ((: (-> (List Text) (io.IO Any))
                                         (..actual_program <program>))
                                      inputs))
                            (#try.Success _)
                            false
                            
                            (#try.Failure _)
                            true))))))))
