(.using
 [library
  [lux "*"
   ["_" test {"+" Test}]
   ["[0]" static]
   [abstract
    [monad {"+" do}]]
   [control
    ["[0]" try ("[1]#[0]" functor)]
    [parser
     ["<[0]>" code]]]
   [data
    ["[0]" bit ("[1]#[0]" equivalence)]
    ["[0]" text
     ["%" format {"+" format}]]
    [collection
     ["[0]" list]]]
   [math
    ["[0]" random {"+" Random} ("[1]#[0]" functor)]
    [number
     ["n" nat]]]
   ["[0]" meta
    ["[0]" location]
    ["[0]" symbol]]]]
 [\\library
  ["[0]" /
   [syntax {"+" syntax:}]
   ["[0]" code ("[1]#[0]" equivalence)]
   ["[0]" template]]]
 ["[0]" / "_"
  ["[1][0]" code]
  ["[1][0]" local]
  ["[1][0]" syntax]
  ["[1][0]" template]])

(template: (!expect <pattern> <value>)
  [(case <value>
     <pattern> true
     _ false)])

(template: (!global <definition>)
  [(: [Text .Global]
      [(template.text [<definition>]) {.#Definition [true .Macro <definition>]}])])

(syntax: (pow/2 [number <code>.any])
  (in (list (` (n.* (~ number) (~ number))))))

(syntax: (pow/4 [number <code>.any])
  (in (list (` (..pow/2 (..pow/2 (~ number)))))))

(syntax: (repeated [times <code>.nat
                    token <code>.any])
  (in (list.repeated times token)))

(syntax: (fresh_symbol [])
  (do meta.monad
    [g!fresh (/.symbol "fresh")]
    (in (list g!fresh))))

(def: random_lux
  (Random [Nat Text .Lux])
  (do [! random.monad]
    [seed random.nat
     symbol_prefix (random.ascii/upper 1)
     .let [macro_module (symbol.module (symbol /._))
           current_module (symbol.module (symbol .._))]]
    (in [seed
         symbol_prefix
         [.#info            [.#target  ""
                             .#version ""
                             .#mode    {.#Build}]
          .#source          [location.dummy 0 ""]
          .#location         location.dummy
          .#current_module  {.#Some current_module}
          .#modules         (list [macro_module
                                   [.#module_hash        0
                                    .#module_aliases     (list)
                                    .#definitions        (: (List [Text .Global])
                                                            (list (!global /.log_single_expansion!)
                                                                  (!global /.log_expansion!)
                                                                  (!global /.log_full_expansion!)))
                                    .#imports            (list)
                                    .#module_state       {.#Active}]]
                                  [current_module
                                   [.#module_hash        0
                                    .#module_aliases     (list)
                                    .#definitions        (: (List [Text .Global])
                                                            (list (!global ..pow/2)
                                                                  (!global ..pow/4)
                                                                  (!global ..repeated)))
                                    .#imports            (list)
                                    .#module_state       {.#Active}]])
          .#scopes          (list)
          .#type_context    [.#ex_counter 0
                             .#var_counter 0
                             .#var_bindings (list)]
          .#expected        {.#None}
          .#seed            seed
          .#scope_type_vars (list)
          .#extensions      []
          .#eval            (:as (-> Type Code (Meta Any)) [])
          .#host            []]])))

(syntax: (iterated [cycle <code>.nat
                    it <code>.any])
  (in (list (case cycle
              0 it
              _ (` (..iterated (~ (code.nat (-- cycle))) (~ it)))))))

(def: test|expansion
  Test
  (do [! random.monad]
    [[seed symbol_prefix lux] ..random_lux

     pow/1 (# ! each code.nat random.nat)

     repetitions (# ! each (n.% 10) random.nat)
     .let [single_expansion (` (..pow/2 (..pow/2 (~ pow/1))))
           expansion (` (n.* (..pow/2 (~ pow/1))
                             (..pow/2 (~ pow/1))))
           full_expansion (` (n.* (n.* (~ pow/1) (~ pow/1))
                                  (n.* (~ pow/1) (~ pow/1))))]]
    (`` ($_ _.and
            (~~ (template [<expander> <logger> <expansion>]
                  [(_.cover [<expander>]
                            (|> (<expander> (` (..pow/4 (~ pow/1))))
                                (meta.result lux)
                                (try#each (# (list.equivalence code.equivalence) =
                                             (list <expansion>)))
                                (try.else false)))

                   (_.cover [<logger>]
                            (and (|> (/.single_expansion (` (<logger> "omit" (..pow/4 (~ pow/1)))))
                                     (meta.result lux)
                                     (try#each (# (list.equivalence code.equivalence) = (list)))
                                     (try.else false))
                                 (|> (/.single_expansion (` (<logger> (..pow/4 (~ pow/1)))))
                                     (meta.result lux)
                                     (try#each (# (list.equivalence code.equivalence) = (list <expansion>)))
                                     (try.else false))))]

                  [/.single_expansion /.log_single_expansion! single_expansion]
                  [/.expansion        /.log_expansion!        expansion]
                  [/.full_expansion   /.log_full_expansion!   full_expansion]
                  ))
            (_.cover [/.one_expansion]
                     (bit#= (not (n.= 1 repetitions))
                            (|> (/.one_expansion (` (..repeated (~ (code.nat repetitions)) (~ pow/1))))
                                (meta.result lux)
                                (!expect {try.#Failure _}))))
            (_.cover [/.final]
                     (with_expansions [<expected> (static.random_nat)
                                       <cycles> (static.random code.nat
                                                               (random#each (|>> (n.% 5) ++) random.nat))
                                       <actual> (/.final (..iterated <cycles> <expected>))]
                       (case (' <actual>)
                         [_ {.#Nat actual}]
                         (n.= <expected> actual)

                         _
                         false)))
            (_.cover [/.times]
                     (with_expansions [<expected> (static.random_nat)
                                       <max> (static.random code.nat
                                                            (random#each (|>> (n.% 10) (n.+ 2)) random.nat))
                                       <cycles> (static.random code.nat
                                                               (random#each (|>> (n.% <max>) ++) random.nat))
                                       <actual> (/.times <cycles> (..iterated <max> <expected>))]
                       (let [expected_remaining (n.- <cycles> <max>)]
                         (case (` <actual>)
                           (^code (..iterated (~ [_ {.#Nat actual_remaining}]) (~ [_ {.#Nat actual}])))
                           (and (n.= expected_remaining actual_remaining)
                                (n.= <expected> actual))

                           _
                           false))))
            ))))

(def: .public test
  Test
  (<| (_.covering /._)
      ($_ _.and
          (do [! random.monad]
            [[seed symbol_prefix lux] ..random_lux]
            ($_ _.and
                (_.cover [/.symbol]
                         (|> (/.symbol symbol_prefix)
                             (# meta.monad each %.code)
                             (meta.result lux)
                             (!expect (^multi {try.#Success actual_symbol}
                                              (and (text.contains? symbol_prefix actual_symbol)
                                                   (text.contains? (%.nat seed) actual_symbol))))))
                (_.cover [/.wrong_syntax_error]
                         (|> (/.single_expansion (` (/.log_single_expansion!)))
                             (meta.result lux)
                             (!expect (^multi {try.#Failure error}
                                              (text.contains? (/.wrong_syntax_error (symbol /.log_single_expansion!))
                                                              error)))))
                (_.cover [/.with_symbols]
                         (with_expansions [<expected> (fresh_symbol)]
                           (|> (/.with_symbols [<expected>]
                                 (# meta.monad in <expected>))
                               (meta.result lux)
                               (!expect (^multi {try.#Success [_ {.#Symbol ["" actual]}]}
                                                (text.contains? (template.text [<expected>])
                                                                actual))))))
                ))

          ..test|expansion
          
          /code.test
          /local.test
          /syntax.test
          /template.test
          )))
