(.module:
  [library
   [lux #*
    ["_" test (#+ Test)]
    [abstract
     [monad (#+ do)]]
    [control
     ["." try ("#\." functor)]
     [parser
      ["<.>" code]]]
    [data
     ["." bit ("#\." equivalence)]
     ["." name]
     ["." text
      ["%" format (#+ format)]]
     [collection
      ["." list]]]
    [math
     ["." random (#+ Random)]
     [number
      ["." nat]]]
    ["." meta
     ["." location]]]]
  [\\library
   ["." /
    [syntax (#+ syntax:)]
    ["." code ("#\." equivalence)]
    ["." template]]]
  ["." / #_
   ["#." code]
   ["#." local]
   ["#." syntax]
   ["#." template]])

(template: (!expect <pattern> <value>)
  [(case <value>
     <pattern> true
     _ false)])

(template: (!global <definition>)
  [(: [Text .Global]
      [(template.text [<definition>]) (#.Definition [true .Macro (' []) <definition>])])])

(syntax: (pow/2 [number <code>.any])
  (in (list (` (nat.* (~ number) (~ number))))))

(syntax: (pow/4 [number <code>.any])
  (in (list (` (..pow/2 (..pow/2 (~ number)))))))

(syntax: (repeated [times <code>.nat
                    token <code>.any])
  (in (list.repeated times token)))

(syntax: (fresh_identifier [])
  (do meta.monad
    [g!fresh (/.identifier "fresh")]
    (in (list g!fresh))))

(def: random_lux
  (Random [Nat Text .Lux])
  (do {! random.monad}
    [seed random.nat
     identifier_prefix (random.ascii/upper 1)
     .let [macro_module (name.module (name_of /._))
           current_module (name.module (name_of .._))]]
    (in [seed
         identifier_prefix
         [#.info            [#.target  ""
                             #.version ""
                             #.mode    #.Build]
          #.source          [location.dummy 0 ""]
          #.location         location.dummy
          #.current_module  (#.Some current_module)
          #.modules         (list [macro_module
                                   [#.module_hash        0
                                    #.module_aliases     (list)
                                    #.definitions        (: (List [Text .Global])
                                                            (list (!global /.log_single_expansion!)
                                                                  (!global /.log_expansion!)
                                                                  (!global /.log_full_expansion!)))
                                    #.imports            (list)
                                    #.module_annotations #.None
                                    #.module_state       #.Active]]
                                  [current_module
                                   [#.module_hash        0
                                    #.module_aliases     (list)
                                    #.definitions        (: (List [Text .Global])
                                                            (list (!global ..pow/2)
                                                                  (!global ..pow/4)
                                                                  (!global ..repeated)))
                                    #.imports            (list)
                                    #.module_annotations #.None
                                    #.module_state       #.Active]])
          #.scopes          (list)
          #.type_context    [#.ex_counter 0
                             #.var_counter 0
                             #.var_bindings (list)]
          #.expected        #.None
          #.seed            seed
          #.scope_type_vars (list)
          #.extensions      []
          #.eval            (:as (-> Type Code (Meta Any)) [])
          #.host            []]])))

(def: expander
  Test
  (do {! random.monad}
    [[seed identifier_prefix lux] ..random_lux

     pow/1 (\ ! each code.nat random.nat)

     repetitions (\ ! each (nat.% 10) random.nat)
     .let [single_expansion (` (..pow/2 (..pow/2 (~ pow/1))))
           expansion (` (nat.* (..pow/2 (~ pow/1))
                               (..pow/2 (~ pow/1))))
           full_expansion (` (nat.* (nat.* (~ pow/1) (~ pow/1))
                                    (nat.* (~ pow/1) (~ pow/1))))]]
    (`` ($_ _.and
            (~~ (template [<expander> <logger> <expansion>]
                  [(_.cover [<expander>]
                            (|> (<expander> (` (..pow/4 (~ pow/1))))
                                (meta.result lux)
                                (try\each (\ (list.equivalence code.equivalence) =
                                             (list <expansion>)))
                                (try.else false)))

                   (_.cover [<logger>]
                            (and (|> (/.single_expansion (` (<logger> "omit" (..pow/4 (~ pow/1)))))
                                     (meta.result lux)
                                     (try\each (\ (list.equivalence code.equivalence) = (list)))
                                     (try.else false))
                                 (|> (/.single_expansion (` (<logger> (..pow/4 (~ pow/1)))))
                                     (meta.result lux)
                                     (try\each (\ (list.equivalence code.equivalence) = (list <expansion>)))
                                     (try.else false))))]

                  [/.single_expansion /.log_single_expansion! single_expansion]
                  [/.expansion        /.log_expansion!        expansion]
                  [/.full_expansion   /.log_full_expansion!   full_expansion]
                  ))
            (_.cover [/.one_expansion]
                     (bit\= (not (nat.= 1 repetitions))
                            (|> (/.one_expansion (` (..repeated (~ (code.nat repetitions)) (~ pow/1))))
                                (meta.result lux)
                                (!expect (#try.Failure _)))))
            ))))

(def: .public test
  Test
  (<| (_.covering /._)
      ($_ _.and
          (do {! random.monad}
            [[seed identifier_prefix lux] ..random_lux]
            ($_ _.and
                (_.cover [/.identifier]
                         (|> (/.identifier identifier_prefix)
                             (\ meta.monad each %.code)
                             (meta.result lux)
                             (!expect (^multi (#try.Success actual_identifier)
                                              (and (text.contains? identifier_prefix actual_identifier)
                                                   (text.contains? (%.nat seed) actual_identifier))))))
                (_.cover [/.wrong_syntax_error]
                         (|> (/.single_expansion (` (/.log_single_expansion!)))
                             (meta.result lux)
                             (!expect (^multi (#try.Failure error)
                                              (text.contains? (/.wrong_syntax_error (name_of /.log_single_expansion!))
                                                              error)))))
                (_.cover [/.with_identifiers]
                         (with_expansions [<expected> (fresh_identifier)]
                           (|> (/.with_identifiers [<expected>]
                                 (\ meta.monad in <expected>))
                               (meta.result lux)
                               (!expect (^multi (#try.Success [_ (#.Identifier ["" actual])])
                                                (text.contains? (template.text [<expected>])
                                                                actual))))))
                ))

          ..expander
          
          /code.test
          /local.test
          /syntax.test
          /template.test
          )))
