(.module:
  [lux #*
   ["_" test (#+ Test)]
   [abstract
    [monad (#+ do)]]
   [control
    ["." try]
    [security
     ["!" capability]]
    [concurrency
     ["." promise (#+ Promise)]]
    [parser
     ["." environment]]]
   [data
    ["." product]
    ["." text ("#\." equivalence)
     ["%" format (#+ format)]]
    [number
     ["n" nat]
     ["i" int]]]
   [math
    ["." random]]]
  {1
   ["." /
    [//
     [environment (#+ Environment)]
     [file (#+ Path)]]]})

(template [<name> <command> <type> <prep>]
  [(def: <name>
     (-> <type> [Environment Path /.Command (List /.Argument)])
     (|>> <prep> list [environment.empty "~" <command>]))]

  [echo! "echo" Text (|>)]
  [sleep! "sleep" Nat %.nat]
  )

(def: (read-test expected process)
  (-> Text (/.Process Promise) _.Assertion)
  (do promise.monad
    [?read (!.use (:: process read) [])
     ?await (!.use (:: process await) [])]
    ($_ _.and'
        (_.cover' [/.Can-Read]
                  (case ?read
                    (#try.Success actual)
                    (text\= expected actual)
                    
                    (#try.Failure error)
                    false))
        (_.cover' [/.Can-Wait /.Exit /.normal]
                  (case ?await
                    (#try.Success exit)
                    (i.= /.normal exit)
                    
                    (#try.Failure error)
                    false))
        )))

(def: (destroy-test process)
  (-> (/.Process Promise) _.Assertion)
  (do promise.monad
    [?destroy (!.use (:: process destroy) [])
     ?await (!.use (:: process await) [])]
    (_.cover' [/.Can-Destroy]
              (and (case ?destroy
                     (#try.Success _)
                     true
                     
                     (#try.Failure error)
                     false)
                   (case ?await
                     (#try.Success _)
                     false
                     
                     (#try.Failure error)
                     true)))))

(with-expansions [<shell-coverage> (as-is [/.Can-Execute /.Command /.Argument])]
  (def: #export (spec shell)
    (-> (/.Shell Promise) Test)
    (<| (_.with-cover [/.Shell /.Process])
        (do {! random.monad}
          [message (random.ascii/alpha 10)
           seconds (:: ! map (|>> (n.% 5) (n.+ 5)) random.nat)]
          (wrap (do promise.monad
                  [?echo (!.use (:: shell execute) (..echo! message))
                   ?sleep (!.use (:: shell execute) (..sleep! seconds))]
                  (case [?echo ?sleep]
                    [(#try.Success echo) (#try.Success sleep)]
                    ($_ _.and'
                        (_.cover' <shell-coverage>
                                  true)
                        (..read-test message echo)
                        (..destroy-test sleep))
                    
                    _
                    (_.cover' <shell-coverage>
                              false))))))))
