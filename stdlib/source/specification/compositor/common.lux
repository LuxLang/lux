(.module:
  [lux #*
   [abstract
    [monad (#+ do)]]
   [control
    ["." io (#+ IO)]
    ["." try (#+ Try)]]
   [tool
    [compiler
     ["." reference]
     ["." analysis]
     ["." synthesis (#+ Synthesis)]
     ["." directive]
     ["." phase
      ["." macro (#+ Expander)]
      ["." generation (#+ Operation)]
      [extension (#+ Extender)
       ["." bundle]]]
     [default
      ["." platform (#+ Platform)]]]]])

(type: #export Runner
  (-> Text Synthesis (Try Any)))

(type: #export Definer
  (-> Name Synthesis (Try Any)))

(type: #export (Instancer what)
  (All [anchor expression directive]
    (-> (Platform IO anchor expression directive)
        (generation.State+ anchor expression directive)
        what)))

(def: (runner (^slots [#platform.runtime #platform.phase #platform.host]) state)
  (Instancer Runner)
  (function (_ evaluation_name expressionS)
    (do try.monad
      [expressionG (<| (phase.run state)
                       generation.with_buffer
                       (do phase.monad
                         [_ runtime]
                         (phase expressionS)))]
      (\ host evaluate! evaluation_name expressionG))))

(def: (definer (^slots [#platform.runtime #platform.phase #platform.host])
               state)
  (Instancer Definer)
  (function (_ lux_name expressionS)
    (do try.monad
      [definitionG (<| (phase.run state)
                       generation.with_buffer
                       (do phase.monad
                         [_ runtime
                          expressionG (phase expressionS)
                          [host_name host_value host_directive] (generation.define! lux_name expressionG)
                          _ (generation.learn lux_name host_name)]
                         (phase (synthesis.constant lux_name))))]
      (\ host evaluate! "definer" definitionG))))

(def: #export (executors target expander platform
                         analysis_bundle generation_bundle directive_bundle
                         program extender)
  (All [anchor expression directive]
    (-> Text Expander (Platform IO anchor expression directive)
        analysis.Bundle
        (generation.Bundle anchor expression directive)
        (directive.Bundle anchor expression directive)
        (-> expression directive) Extender
        (IO (Try [(directive.State+ anchor expression directive)
                  Runner
                  Definer]))))
  (do io.monad
    [?state (platform.initialize target expander analysis_bundle platform generation_bundle directive_bundle program extender)]
    (in (do try.monad
          [[directive_bundle directive_state] ?state
           .let [generation_state (get@ [#directive.generation
                                         #directive.state]
                                        directive_state)]]
          (in [[directive_bundle directive_state]
               (..runner platform generation_state)
               (..definer platform generation_state)])))))
