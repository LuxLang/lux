(.module:
  [lux "*"
   [abstract
    [monad {"+" do}]]
   [control
    ["[0]" io {"+" IO}]
    ["[0]" try {"+" Try}]]
   [tool
    [compiler
     ["[0]" reference]
     ["[0]" analysis]
     ["[0]" synthesis {"+" Synthesis}]
     ["[0]" directive]
     ["[0]" phase
      ["[0]" macro {"+" Expander}]
      ["[0]" generation {"+" Operation}]
      [extension {"+" Extender}
       ["[0]" bundle]]]
     [default
      ["[0]" platform {"+" Platform}]]]]])

(type: .public Runner
  (-> Text Synthesis (Try Any)))

(type: .public Definer
  (-> Name Synthesis (Try Any)))

(type: .public (Instancer what)
  (All (_ anchor expression directive)
    (-> (Platform IO anchor expression directive)
        (generation.State+ anchor expression directive)
        what)))

(def: (runner (^slots [platform.#runtime platform.#phase platform.#host]) state)
  (Instancer Runner)
  (function (_ evaluation_name expressionS)
    (do try.monad
      [expressionG (<| (phase.result state)
                       generation.with_buffer
                       (do phase.monad
                         [_ runtime]
                         (phase expressionS)))]
      (# host evaluate! evaluation_name expressionG))))

(def: (definer (^slots [platform.#runtime platform.#phase platform.#host])
               state)
  (Instancer Definer)
  (function (_ lux_name expressionS)
    (do try.monad
      [definitionG (<| (phase.result state)
                       generation.with_buffer
                       (do phase.monad
                         [_ runtime
                          expressionG (phase expressionS)
                          [host_name host_value host_directive] (generation.define! lux_name expressionG)
                          _ (generation.learn lux_name host_name)]
                         (phase (synthesis.constant lux_name))))]
      (# host evaluate! "definer" definitionG))))

(def: .public (executors target expander platform
                         analysis_bundle generation_bundle directive_bundle
                         program extender)
  (All (_ anchor expression directive)
    (-> Text Expander (Platform IO anchor expression directive)
        analysis.Bundle
        (generation.Bundle anchor expression directive)
        (directive.Bundle anchor expression directive)
        (-> expression directive) Extender
        (IO (Try [(directive.State+ anchor expression directive)
                  Runner
                  Definer]))))
  (do io.monad
    [?state (platform.initialize target expander analysis_bundle platform generation_bundle directive_bundle program extender)]
    (in (do try.monad
          [[directive_bundle directive_state] ?state
           .let [generation_state (value@ [directive.#generation
                                           directive.#state]
                                          directive_state)]]
          (in [[directive_bundle directive_state]
               (..runner platform generation_state)
               (..definer platform generation_state)])))))
