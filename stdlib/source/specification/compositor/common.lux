(.require
 [lux (.except)
  [abstract
   [monad (.only do)]]
  [control
   ["[0]" io (.only IO)]
   ["[0]" try (.only Try)]]
  [meta
   [compiler
    ["[0]" reference]
    ["[0]" analysis]
    ["[0]" synthesis (.only Synthesis)]
    ["[0]" declaration]
    ["[0]" phase
     ["[0]" macro (.only Expander)]
     ["[0]" generation (.only Operation)]
     [extension (.only Extender)
      ["[0]" bundle]]]
    [default
     ["[0]" platform (.only Platform)]]]]])

(type .public Runner
  (-> Text Synthesis (Try Any)))

(type .public Definer
  (-> Symbol Synthesis (Try Any)))

(type .public (Instancer what)
  (All (_ anchor expression declaration)
    (-> (Platform IO anchor expression declaration)
        (generation.State anchor expression declaration)
        what)))

(def (runner (open "[0]") state)
  (Instancer Runner)
  (function (_ evaluation_name expressionS)
    (do try.monad
      [expressionG (<| (phase.result state)
                       generation.with_buffer
                       (do phase.monad
                         [_ runtime]
                         (phase expressionS)))]
      (at host evaluate! evaluation_name expressionG))))

(def (definer (open "[0]") state)
  (Instancer Definer)
  (function (_ lux_name expressionS)
    (do try.monad
      [definitionG (<| (phase.result state)
                       generation.with_buffer
                       (do phase.monad
                         [_ runtime
                          expressionG (phase expressionS)
                          [host_name host_value host_declaration] (generation.define! lux_name expressionG)
                          _ (generation.learn lux_name host_name)]
                         (phase (synthesis.constant lux_name))))]
      (at host evaluate! "definer" definitionG))))

(def .public (executors target expander platform
                        analysis_bundle generation_bundle declaration_bundle
                        program extender)
  (All (_ anchor expression declaration)
    (-> Text Expander (Platform IO anchor expression declaration)
        analysis.Bundle
        (generation.Bundle anchor expression declaration)
        (declaration.Bundle anchor expression declaration)
        (-> expression declaration) Extender
        (IO (Try [(declaration.State anchor expression declaration)
                  Runner
                  Definer]))))
  (do io.monad
    [?state (platform.initialize target expander analysis_bundle platform generation_bundle declaration_bundle program extender)]
    (in (do try.monad
          [[declaration_bundle declaration_state] ?state
           .let [generation_state (the [declaration.#generation
                                        declaration.#state]
                                       declaration_state)]]
          (in [[declaration_bundle declaration_state]
               (..runner platform generation_state)
               (..definer platform generation_state)])))))
