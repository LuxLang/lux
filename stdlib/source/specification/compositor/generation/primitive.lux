(.require
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" pipe]
    ["[0]" try]]
   [data
    ["[0]" bit (.use "[1]#[0]" equivalence)]
    [number
     ["f" frac]]
    ["[0]" text (.use "[1]#[0]" equivalence)
     ["%" \\format (.only format)]]]
   [math
    ["r" random]]
   [meta
    [compiler
     ["[0]" synthesis]]]
   [test
    ["_" property (.only Test)]]]]
 [///
  [common (.only Runner)]])

(def (f/=' reference subject)
  (-> Frac Frac Bit)
  (or (f.= reference subject)
      (and (f.not_a_number? reference)
           (f.not_a_number? subject))))

(def .public (spec run)
  (-> Runner Test)
  (`` (all _.and
           (,, (with_template [<evaluation_name> <synthesis> <gen> <test>]
                 [(do r.monad
                    [expected <gen>]
                    (_.test (%.symbol (symbol <synthesis>))
                      (|> (run <evaluation_name> (<synthesis> expected))
                          (pipe.case
                            {try.#Success actual}
                            (<test> expected (as_expected actual))

                            {try.#Failure _}
                            false))))]

                 ["bit" synthesis.bit  r.bit  bit#=]
                 ["i64" synthesis.i64  r.i64  "lux i64 ="]
                 ["f64" synthesis.f64  r.frac  f.=']
                 ["text" synthesis.text (r.ascii 5) text#=]
                 ))
           )))
