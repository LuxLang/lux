(.module:
  [lux "*"
   ["_" test {"+" Test}]
   [abstract
    [monad {"+" do}]]
   [control
    ["[0]" io {"+" IO}]
    ["[0]" try]]
   [math
    ["r" random]]
   [tool
    [compiler
     ["[0]" analysis]
     ["[0]" directive]
     [phase
      [macro {"+" Expander}]
      [generation {"+" Bundle}]]
     [default
      [platform {"+" Platform}]]]]]
  ["[0]" / "_"
   ["[1][0]" common {"+" Runner Definer}]
   ["[1]./" analysis "_"
    ["[1][0]" type]]
   ["[1]./" generation "_"
    ["[1][0]" primitive]
    ["[1][0]" structure]
    ["[1][0]" reference]
    ["[1][0]" case]
    ["[1][0]" function]
    ["[1][0]" common]]])

(def: (test runner definer state expander)
  (-> Runner Definer analysis.State+ Expander Test)
  ($_ _.and
      (/analysis/type.spec expander state)
      (/generation/primitive.spec runner)
      (/generation/structure.spec runner)
      (/generation/reference.spec runner definer)
      (/generation/case.spec runner)
      (/generation/function.spec runner)
      (/generation/common.spec runner)
      ))

(def: .public (spec platform bundle expander program)
  (All (_ anchor expression directive)
    (-> (IO (Platform IO anchor expression directive))
        (Bundle anchor expression directive)
        Expander
        (-> expression directive)
        Test))
  (do r.monad
    [_ (in [])
     .let [?state,runner,definer (<| io.run!
                                     (do io.monad
                                       [platform platform])
                                     (/common.executors platform
                                                        bundle
                                                        expander
                                                        program))]]
    (case ?state,runner,definer
      {try.#Success [[directive_bundle directive_state] runner definer]}
      (..test runner definer
              (value@ [directive.#analysis directive.#state] directive_state)
              expander)

      {try.#Failure error}
      (_.failure error))))
