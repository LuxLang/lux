(.using
 [library
  [lux (.full)
   ["_" test (.only Test)]
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" try ("[1]#[0]" functor)]
    [concurrency
     ["[0]" async (.only Async) ("[1]#[0]" monad)]]
    [parser
     ["[0]" environment (.only Environment)]]]
   [data
    ["[0]" product]
    ["[0]" text ("[1]#[0]" equivalence)
     ["%" format (.only format)]]]
   [math
    ["[0]" random]
    [number
     ["n" nat]
     ["i" int]]]]]
 [\\library
  ["[0]" /
   [//
    [file (.only Path)]]]])

(template [<name> <command> <type> <prep>]
  [(def: <name>
     (-> <type> [Environment Path /.Command (List /.Argument)])
     (|>> <prep> list [environment.empty "~" <command>]))]

  [echo! "echo" Text (|>)]
  [sleep! "sleep" Nat %.nat]
  )

(def: (can_wait! process)
  (-> (/.Process Async) _.Assertion)
  (|> (# process await [])
      (async#each (|>> (try#each (i.= /.normal))
                       (try.else false)
                       (_.coverage' [/.Exit /.normal])))
      async#conjoint))

(def: (can_read! expected process)
  (-> Text (/.Process Async) (Async Bit))
  (|> (# process read [])
      (async#each (|>> (try#each (text#= expected))
                       (try.else false)))))

(def: (can_destroy! process)
  (-> (/.Process Async) (Async Bit))
  (do async.monad
    [?destroy (# process destroy [])
     ?await (# process await [])]
    (in (and (case ?destroy
               {try.#Success _}
               true
               
               {try.#Failure error}
               false)
             (case ?await
               {try.#Success _}
               false
               
               {try.#Failure error}
               true)))))

(with_expansions [<shell_coverage> (these [/.Command /.Argument])]
  (def: .public (spec shell)
    (-> (/.Shell Async) Test)
    (<| (_.for [/.Shell /.Process])
        (do [! random.monad]
          [message (random.alphabetic 10)
           seconds (# ! each (|>> (n.% 5) (n.+ 5)) random.nat)]
          (in (do [! async.monad]
                [?echo (# shell execute (..echo! message))
                 ?sleep (# shell execute (..sleep! seconds))]
                (case [?echo ?sleep]
                  [{try.#Success echo} {try.#Success sleep}]
                  (do !
                    [can_read! (..can_read! message echo)
                     can_destroy! (..can_destroy! sleep)]
                    (all _.and'
                         (_.coverage' <shell_coverage>
                           (and can_read!
                                can_destroy!))
                         (..can_wait! echo)
                         ))
                  
                  _
                  (_.coverage' <shell_coverage>
                    false))))))))
