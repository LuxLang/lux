(.using
 [library
  [lux (.except)
   ["_" test (.only Test)]
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" try (.only Try)]
    [concurrency
     ["[0]" async (.only Async)]]]
   [data
    ["[0]" binary (.only)
     ["_[1]" \\test]]]
   [math
    ["[0]" random]]]]
 [\\program
  ["[0]" / (.only)
   ["[1][0]" remote]
   ["/[1]" //
    ["[1][0]" artifact (.only Artifact)
     ["[1]/[0]" extension]]]]]
 [\\test
  ["_[0]" //
   ["[1][0]" artifact]]])

(def .public (spec valid_artifact invalid_artifact subject)
  (-> Artifact Artifact (/.Repository Async) Test)
  (do random.monad
    [expected (_binary.random 100)]
    (in (all _.and'
             (do async.monad
               [.let [good_uri (/remote.uri (the //artifact.#version valid_artifact) valid_artifact //artifact/extension.lux_library)]
                good_upload! (at subject upload good_uri expected)
                good_download! (at subject download good_uri)

                .let [bad_uri (/remote.uri (the //artifact.#version invalid_artifact) invalid_artifact //artifact/extension.lux_library)]
                bad_upload! (at subject upload bad_uri expected)
                bad_download! (at subject download bad_uri)]
               (_.coverage' [/.Repository]
                 (let [successfull_flow!
                       (case [good_upload! good_download!]
                         [{try.#Success _} {try.#Success actual}]
                         (at binary.equivalence = expected actual)

                         _
                         false)

                       failed_flow!
                       (case [bad_upload! bad_download!]
                         [{try.#Failure _} {try.#Failure _}]
                         true

                         _
                         false)]
                   (and successfull_flow!
                        failed_flow!))))
             ))))
