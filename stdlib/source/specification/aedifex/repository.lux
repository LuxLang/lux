(.module:
  [library
   [lux "*"
    ["_" test {"+" [Test]}]
    [abstract
     [monad {"+" [do]}]]
    [control
     ["[0]" try {"+" [Try]}]
     [concurrency
      ["[0]" async {"+" [Async]}]]]
    [data
     ["[0]" binary
      ["_[1]" \\test]]]
    [math
     ["[0]" random]]]]
  [\\program
   ["[0]" /
    ["[1][0]" remote]
    ["/[1]" // "_"
     ["[1][0]" artifact {"+" [Artifact]}
      ["[1]/[0]" extension]]]]]
  [\\test
   ["_[0]" // "_"
    ["[1][0]" artifact]]])

(def: .public (spec valid_artifact invalid_artifact subject)
  (-> Artifact Artifact (/.Repository Async) Test)
  (do random.monad
    [expected (_binary.random 100)]
    (in ($_ _.and'
            (do async.monad
              [.let [good_uri (/remote.uri (value@ //artifact.#version valid_artifact) valid_artifact //artifact/extension.lux_library)]
               good_upload! (\ subject upload good_uri expected)
               good_download! (\ subject download good_uri)

               .let [bad_uri (/remote.uri (value@ //artifact.#version invalid_artifact) invalid_artifact //artifact/extension.lux_library)]
               bad_upload! (\ subject upload bad_uri expected)
               bad_download! (\ subject download bad_uri)]
              (_.cover' [/.Repository]
                        (let [successfull_flow!
                              (case [good_upload! good_download!]
                                [{try.#Success _} {try.#Success actual}]
                                (\ binary.equivalence = expected actual)

                                _
                                false)

                              failed_flow!
                              (case [bad_upload! bad_download!]
                                [{try.#Failure _} {try.#Failure _}]
                                true

                                _
                                false)]
                          (and successfull_flow!
                               failed_flow!))))
            ))))
