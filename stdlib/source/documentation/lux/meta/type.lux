(.require
 [library
  [lux (.except)
   ["$" documentation]
   [data
    ["[0]" text (.only \n)
     ["%" \\format (.only format)]]]
   [meta
    [macro
     ["[0]" template]]]]]
 ["[0]" \\parser]
 [\\library
  ["[0]" /]]
 ["[0]" /
  ["[1][0]" primitive]
  ["[1][0]" check]
  ["[1][0]" dynamic]
  ["[1][0]" implicit]
  ["[1][0]" poly]
  ["[1][0]" quotient]
  ["[1][0]" refinement]
  ["[1][0]" resource]
  ["[1][0]" unit]
  ["[1][0]" variance]])

(`` (.def \\parser
      (.List $.Module)
      ($.module \\parser._
                (format "Parsing of Lux types."
                        \n "Used mostly for polytypic programming.")
                [($.default \\parser.not_existential)
                 ($.default \\parser.not_recursive)
                 ($.default \\parser.not_named)
                 ($.default \\parser.not_parameter)
                 ($.default \\parser.unknown_parameter)
                 ($.default \\parser.not_function)
                 ($.default \\parser.not_application)
                 ($.default \\parser.not_polymorphic)
                 ($.default \\parser.not_variant)
                 ($.default \\parser.not_tuple)
                 ($.default \\parser.types_do_not_match)
                 ($.default \\parser.wrong_parameter)
                 ($.default \\parser.empty_input)
                 ($.default \\parser.unconsumed_input)
                 ($.default \\parser.parameter)
                 ($.default \\parser.recursive_self)
                 ($.default \\parser.recursive_call)

                 ($.documentation \\parser.Env
                   "An environment for type parsing.")

                 ($.documentation (\\parser.Parser it)
                   "A parser of Lux types.")

                 ($.documentation \\parser.fresh
                   "An empty parsing environment.")

                 ($.documentation \\parser.result
                   (format "Applies a parser against a type."
                           \n "Verifies that the parser fully consumes the type's information.")
                   [(result poly type)])

                 ($.documentation \\parser.env
                   "Yields the current parsing environment.")

                 ($.documentation \\parser.next
                   "Inspect a type in the input stream without consuming it.")

                 ($.documentation \\parser.any
                   "Yields a type, without examination.")

                 ($.documentation \\parser.local
                   "Apply a parser to the given inputs."
                   [(local types poly)])

                 ($.documentation \\parser.with_extension
                   ""
                   [(with_extension type poly)])

                 (,, (with_template [<name>]
                       [(`` ($.documentation <name>
                              (format "Parses the contents of a " (,, (template.text [<name>])) " type.")))]

                       [\\parser.variant]
                       [\\parser.tuple]
                       ))

                 ($.documentation \\parser.polymorphic
                   ""
                   [(polymorphic poly)])

                 ($.documentation \\parser.function
                   "Parses a function's inputs and output."
                   [(function in_poly out_poly)])

                 ($.documentation \\parser.applied
                   "Parses a type application."
                   [(applied poly)])

                 (,, (with_template [<name> <doc>]
                       [($.documentation <name>
                          <doc>)]

                       [\\parser.exactly "Parses a type exactly."]
                       [\\parser.sub "Parses a sub type."]
                       [\\parser.super "Parses a super type."]
                       ))

                 ($.documentation \\parser.argument
                   ""
                   [(argument env idx)])

                 ($.documentation \\parser.this_parameter
                   ""
                   [(this_parameter id)])

                 ($.documentation \\parser.existential
                   "Yields an existential type.")

                 ($.documentation \\parser.named
                   "Yields a named type.")

                 ($.documentation \\parser.recursive
                   ""
                   [(recursive poly)])]
                [])))

(`` (.def .public documentation
      (.List $.Module)
      ($.module /._
                "Basic functionality for working with types."
                [($.default /.equivalence)

                 (,, (with_template [<name>]
                       [($.documentation <name>
                          "The number of parameters, and the body, of a quantified type.")]

                       [/.flat_univ_q]
                       [/.flat_ex_q]
                       ))

                 ($.documentation /.flat_function
                   "The input, and the output of a function type."
                   [(flat_function type)])

                 ($.documentation /.flat_application
                   "The quantified type, and its parameters, for a type-application."
                   [(flat_application type)])

                 (,, (with_template [<name>]
                       [($.documentation <name>
                          "The members of a composite type.")]

                       [/.flat_variant]
                       [/.flat_tuple]
                       ))

                 ($.documentation /.format
                   "A (readable) textual representable of a type."
                   [(format type)])

                 ($.documentation /.applied
                   "To the extend possible, applies a quantified type to the given parameters."
                   [(applied params func)])

                 ($.documentation /.code
                   (%.format "A representation of a type as code."
                             \n "The code is such that evaluating it would yield the type value.")
                   [(code type)])

                 ($.documentation /.de_aliased
                   "A (potentially named) type that does not have its name shadowed by other names."
                   [(de_aliased type)])

                 ($.documentation /.anonymous
                   "A type without any names covering it."
                   [(anonymous type)])

                 (,, (with_template [<name>]
                       [($.documentation <name>
                          "A composite type, constituted by the given member types.")]

                       [/.variant]
                       [/.tuple]
                       ))

                 ($.documentation /.function
                   "A function type, with the given inputs and output."
                   [(function inputs output)])

                 ($.documentation /.application
                   "An un-evaluated type application, with the given quantified type, and parameters."
                   [(application params quant)])

                 (,, (with_template [<name>]
                       [($.documentation <name>
                          "A quantified type, with the given number of parameters, and body.")]

                       [/.univ_q]
                       [/.ex_q]
                       ))

                 ($.documentation /.quantified?
                   "Only yields #1 for universally or existentially quantified types."
                   [(quantified? type)])

                 ($.documentation /.array
                   "An array type, with the given level of nesting/depth, and the given element type."
                   [(array depth element_type)])

                 ($.documentation /.flat_array
                   "The level of nesting/depth and element type for an array type."
                   [(flat_array type)])

                 ($.documentation /.array?
                   "Is a type an array type?")

                 ($.documentation /.log!
                   "Logs to the console/terminal the type of an expression."
                   [(log! (is Foo (foo expression)))
                    "=>"
                    "Expression: (foo expression)"
                    "      Type: Foo"
                    (foo expression)])

                 ($.documentation /.as
                   (%.format "Casts a value to a specific type."
                             \n "The specified type can depend on type variables of the original type of the value."
                             \n "NOTE: Careless use of type-casts is an easy way to introduce bugs. USE WITH CAUTION.")
                   [(is (Bar Bit Nat Text)
                        (as [a b c]
                            (Foo a [b c])
                            (Bar a b c)
                            (is (Foo Bit [Nat Text])
                                (foo expression))))])

                 ($.documentation /.sharing
                   "Allows specifing the type of an expression as sharing type-variables with the type of another expression."
                   [(is (Bar Bit Nat Text)
                        (sharing [a b c]
                          (is (Foo a [b c])
                              (is (Foo Bit [Nat Text])
                                  (foo expression)))
                          (is (Bar a b c)
                              (bar expression))))])

                 ($.documentation /.by_example
                   "Constructs a type that shares type-variables with an expression of some other type."
                   [(is Type
                        (by_example [a b c]
                          (is (Foo a [b c])
                              (is (Foo Bit [Nat Text])
                                  (foo expression)))
                          (Bar a b c)))
                    "=>"
                    (.type_literal (Bar Bit Nat Text))])

                 ($.documentation /.let
                   "Local bindings for types."
                   [(let [side (Either Int Frac)]
                      (List [side side]))])]
                [..\\parser

                 /primitive.documentation
                 /check.documentation
                 /dynamic.documentation
                 /implicit.documentation
                 /poly.documentation
                 /quotient.documentation
                 /refinement.documentation
                 /resource.documentation
                 /unit.documentation
                 /variance.documentation])))
