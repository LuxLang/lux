(.require
 [library
  [lux (.except)
   ["$" documentation]
   [data
    [text (.only \n)
     ["%" \\format (.only format)]]
    [collection
     ["[0]" list]]]
   [meta
    [macro
     ["[0]" template]]]]]
 ["[0]" \\parser]
 [\\library
  ["[0]" /]])

(`` (.def \\parser
      (.List $.Module)
      ($.module \\parser._
                ""
                [($.documentation (\\parser.Parser it)
                   "A Lux code parser.")

                 ($.documentation \\parser.any
                   "Yields the next input without applying any logic.")

                 (,, (with_template [<query> <check>]
                       [(`` ($.documentation <query>
                              (format "Parses the next " (,, (template.text [<query>])) " input.")))
                        (`` ($.documentation <check>
                              (format "Checks for a specific " (,, (template.text [<query>])) " input.")))]

                       [\\parser.bit    \\parser.this_bit]
                       [\\parser.nat    \\parser.this_nat]
                       [\\parser.int    \\parser.this_int]
                       [\\parser.rev    \\parser.this_rev]
                       [\\parser.frac   \\parser.this_frac]
                       [\\parser.text   \\parser.this_text]
                       [\\parser.symbol \\parser.this_symbol]
                       ))

                 ($.documentation \\parser.this
                   "Ensures the given Code is the next input."
                   [(this code)])

                 (,, (with_template [<query> <check> <desc>]
                       [($.documentation <query>
                          (format "Parse a local " <desc> " (a " <desc> " that has no module prefix)."))
                        ($.documentation <check>
                          (format "Checks for a specific local " <desc> " (a " <desc> " that has no module prefix)."))]

                       [\\parser.local \\parser.this_local "local symbol"]
                       ))

                 (,, (with_template [<name>]
                       [(`` ($.documentation <name>
                              (format "Parses the contents of a " (,, (template.text [<name>])) ".")))]

                       [\\parser.form]
                       [\\parser.variant]
                       [\\parser.tuple]
                       ))

                 ($.documentation \\parser.end
                   "Verifies there are no more inputs.")

                 ($.documentation \\parser.end?
                   "Checks whether there are no more inputs.")

                 ($.documentation \\parser.result
                   "Executes a parser against a stream of code, and verifies all the inputs are consumed."
                   [(result parser inputs)])

                 ($.documentation \\parser.locally
                   "Runs parser against the given list of inputs."
                   [(locally inputs parser)])

                 ($.documentation \\parser.not
                   "Yields the next Code token if the parser fails."
                   [(not expected_to_fail)])

                 ($.documentation \\parser.next
                   "Yields the next Code token without consuming it from the input stream.")]
                [])))

(.def .public documentation
  (.List $.Module)
  ($.module /._
            ""
            [($.default /.bit)
             ($.default /.nat)
             ($.default /.int)
             ($.default /.rev)
             ($.default /.frac)
             ($.default /.text)
             ($.default /.symbol)
             ($.default /.form)
             ($.default /.variant)
             ($.default /.tuple)
             
             ($.default /.equivalence)
             ($.default /.format)

             ($.documentation /.local
               "Produces a local symbol (an symbol with no module prefix).")

             ($.documentation /.replaced
               ""
               [(replaced original substitute ast)])]
            [..\\parser]))
