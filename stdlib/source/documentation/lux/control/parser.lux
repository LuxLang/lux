(.require
 [library
  [lux (.except or and not)
   ["$" documentation]
   [data
    [text (.only \n)
     ["%" \\format (.only format)]]]]]
 [\\library
  ["[0]" /]])

(.def .public documentation
  (.List $.Module)
  ($.module /._
            ""
            [($.definition /.functor)
             ($.definition /.apply)
             ($.definition /.monad)

             ($.definition (/.Parser state it)
               "A generic parser.")

             ($.definition /.assertion
               "Fails with the given message if the test is #0."
               [(assertion message test)])

             ($.definition /.maybe
               "Optionality combinator."
               [(maybe parser)])

             ($.definition /.result
               (format "Executes the parser on the input."
                       \n "Does not verify that all of the input has been consumed by the parser."
                       \n "Returns both the parser's output, and a value that represents the remaining input.")
               [(result parser input)])

             ($.definition /.and
               "Sequencing combinator."
               [(and first second)])

             ($.definition /.or
               "Heterogeneous alternative combinator."
               [(or left right)])

             ($.definition /.either
               "Homogeneous alternative combinator."
               [(either this that)])

             ($.definition /.some
               "0-or-more combinator."
               [(some parser)])

             ($.definition /.many
               "1-or-more combinator."
               [(many parser)])

             ($.definition /.exactly
               "Parse exactly N times."
               [(exactly amount parser)])

             ($.definition /.at_least
               "Parse at least N times."
               [(at_least amount parser)])

             ($.definition /.at_most
               "Parse at most N times."
               [(at_most amount parser)])

             ($.definition /.between
               ""
               [(between minimum additional parser)])

             ($.definition /.separated_by
               "Parses instances of 'parser' that are separated by instances of 'separator'."
               [(separated_by separator parser)])

             ($.definition /.not
               "Only succeeds when the underlying parser fails."
               [(not parser)])

             ($.definition /.failure
               "Always fail with this 'message'."
               [(failure message)])

             ($.definition /.lifted
               "Lift a potentially failed computation into a parser."
               [(lifted operation)])

             ($.definition /.else
               "If the given parser fails, returns the default value."
               [(else value parser)])

             ($.definition /.remaining
               "Yield the remaining input (without consuming it).")

             ($.definition /.rec
               "Combinator for recursive parsers."
               [(rec parser)])

             ($.definition /.after
               "Run the parser after another one (whose output is ignored)."
               [(after param subject)])

             ($.definition /.before
               "Run the parser before another one (whose output is ignored)."
               [(before param subject)])

             ($.definition /.only
               "Only succeed when the parser's output passes a test."
               [(only test parser)])

             ($.definition /.parses?
               "Ignore a parser's output and just verify that it succeeds."
               [(parses? parser)])

             ($.definition /.parses
               "Ignore a parser's output and just execute it."
               [(parses parser)])

             ($.definition /.speculative
               (format "Executes a parser, without actually consuming the input."
                       \n "That way, the same input can be consumed again by another parser.")
               [(speculative parser)])

             ($.definition /.codec
               "Decode the output of a parser using a codec."
               [(codec codec parser)])]
            []))
