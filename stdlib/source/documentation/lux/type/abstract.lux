(.module:
  [library
   [lux (#- and)
    ["$" documentation (#+ documentation:)]
    [control
     ["<>" parser
      ["<.>" code]]]
    [data
     ["." text (#+ \n)
      ["%" format (#+ format)]]]
    [macro
     ["." template]]]]
  [\\library
   ["." /]])

(documentation: /.Frame
  "Meta-data about an abstract/nominal type in a stack of them.")

(documentation: /.current
  "The currently-being-defined abstract/nominal type.")

(documentation: /.specific
  "A specific abstract/nominal type still being defined somewhere in the scope."
  [(specific name)])

(template [<name> <from> <to>]
  [(documentation: <name>
     "Type-casting macro for abstract/nominal types."
     [(: <to>
         (<name> (: <from> value)))])]

  [/.:abstraction representation abstraction]
  [/.:representation abstraction representation]
  )

(documentation: /.abstract:
  (format "Define abstract/nominal types which hide their representation details."
          \n "You can convert between the abstraction and its representation selectively to access the value, while hiding it from others.")
  [(abstract: String
     {}

     Text

     (def: (string value)
       (-> Text String)
       (:abstraction value))

     (def: (text value)
       (-> String Text)
       (:representation value)))]
  ["Type-parameters are optional."
   (abstract: (Duplicate a)
     {}

     [a a]

     (def: (duplicate value)
       (All [a] (-> a (Duplicate a)))
       (:abstraction [value value])))]
  ["Definitions can be nested."
   (abstract: (Single a)
     {}

     a

     (def: (single value)
       (All [a] (-> a (Single a)))
       (:abstraction value))

     (abstract: (Double a)
       {}

       [a a]

       (def: (double value)
         (All [a] (-> a (Double a)))
         (:abstraction [value value]))

       (def: (single' value)
         (All [a] (-> a (Single a)))
         (:abstraction Single [value value]))

       (let [value 0123]
         (same? value
                (|> value
                    single'
                    (:representation Single)
                    double
                    :representation)))))]
  ["Type-parameters do not necessarily have to be used in the representation type."
   "If they are not used, they become phantom types and can be used to customize types without changing the representation."
   (abstract: (JavaScript a)
     {}

     Text

     (abstract: Expression {} Any)
     (abstract: Statement {} Any)

     (def: (+ x y)
       (-> (JavaScript Expression) (JavaScript Expression) (JavaScript Expression))
       (:abstraction
        (format "(" (:representation x) "+" (:representation y) ")")))

     (def: (while test body)
       (-> (JavaScript Expression) (JavaScript Statement) (JavaScript Statement))
       (:abstraction
        (format "while(" (:representation test) ") {"
                (:representation body)
                "}"))))])

(documentation: /.:transmutation
  "Transmutes an abstract/nominal type's phantom types."
  [(abstract: (JavaScript a)
     {}

     Text

     (abstract: Expression {} Any)
     (abstract: Statement {} Any)

     (def: (statement expression)
       (-> (JavaScript Expression) (JavaScript Statement))
       (:transmutation expression))

     (def: (statement' expression)
       (-> (JavaScript Expression) (JavaScript Statement))
       (:transmutation JavaScript expression)))])

(documentation: /.^:representation
  "Pattern-matching macro to easily extract a representation."
  [(def: (computation abstraction)
     (All [a] (-> (Abstract a) ???))
     (let [(^:representation value) abstraction]
       (foo (bar (baz value)))))])

(.def: .public documentation
  (.List $.Module)
  ($.module /._
            ""
            [..Frame
             ..current
             ..specific
             ..:abstraction
             ..:representation
             ..abstract:
             ..:transmutation
             ..^:representation
             ($.default /.no_active_frames)]
            []))
