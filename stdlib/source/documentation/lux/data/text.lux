(.require
 [library
  [lux (.except)
   ["$" documentation]
   [meta
    [macro
     ["[0]" template]]]]]
 ["[0]" /
  ["[1][0]" buffer]
  ["[1][0]" encoding]
  ["[1][0]" escape]
  ["[1][0]" regex]
  ["[1][0]" unicode]]
 ["[0]" \\format (.only format)]
 ["[0]" \\parser]
 [\\library
  ["[0]" / (.only \n)]])

(.def \\format
  (.List $.Module)
  ($.module \\format._
            ""
            [($.default \\format.functor)

             ($.default \\format.bit)
             ($.default \\format.nat)
             ($.default \\format.int)
             ($.default \\format.rev)
             ($.default \\format.frac)
             ($.default \\format.text)
             
             ($.default \\format.ratio)
             ($.default \\format.symbol)
             ($.default \\format.location)
             ($.default \\format.code)
             ($.default \\format.type)
             
             ($.default \\format.instant)
             ($.default \\format.duration)
             ($.default \\format.date)
             ($.default \\format.time)
             ($.default \\format.day)
             ($.default \\format.month)
             
             ($.default \\format.xml)
             ($.default \\format.json)

             ($.default \\format.nat_2)
             ($.default \\format.nat_8)
             ($.default \\format.nat_10)
             ($.default \\format.nat_16)
             ($.default \\format.int_2)
             ($.default \\format.int_8)
             ($.default \\format.int_10)
             ($.default \\format.int_16)
             ($.default \\format.rev_2)
             ($.default \\format.rev_8)
             ($.default \\format.rev_10)
             ($.default \\format.rev_16)
             ($.default \\format.frac_2)
             ($.default \\format.frac_8)
             ($.default \\format.frac_10)
             ($.default \\format.frac_16)
             
             ($.default \\format.mod)
             ($.default \\format.list)
             ($.default \\format.maybe)

             ($.definition (\\format.Format it)
               "A way to produce readable text from values.")

             ($.definition \\format.format
               "Text interpolation."
               [(format "Static part " (text static) " does not match URI: " uri)])]
            []))

(`` (.def \\parser
      (.List $.Module)
      ($.module \\parser._
                ""
                [($.default \\parser.unconsumed_input)
                 ($.default \\parser.expected_to_fail)
                 ($.default \\parser.cannot_parse)
                 ($.default \\parser.cannot_slice)
                 ($.default \\parser.cannot_match)
                 ($.default \\parser.character_should_be)
                 ($.default \\parser.character_should_not_be)
                 ($.default \\parser.character_does_not_satisfy_predicate)

                 ($.definition \\parser.Offset
                   "An offset into a block of text.")

                 ($.definition (\\parser.Parser it)
                   "A parser for text.")

                 ($.definition \\parser.Slice
                   "A slice of a block of text.")

                 ($.definition \\parser.result
                   (format "Executes a parser against a block of text."
                           \n "Verifies that the entire input has been processed.")
                   [(result parser input)])

                 ($.definition \\parser.offset
                   "Yields the current offset into the input.")

                 ($.definition \\parser.any
                   "Yields the next character without applying any logic.")

                 ($.definition \\parser.any!
                   "Yields the next character (as a slice) without applying any logic.")

                 (,, (with_template [<name> <caveat>]
                       [(`` ($.definition <name>
                              (format "Produce a character" (,, (template.text [<caveat>])) " if the parser fails.")))]

                       [\\parser.not  ""]
                       [\\parser.not! " (as a slice)"]
                       ))

                 ($.definition \\parser.this
                   "Checks that a specific text shows up in the input."
                   [(this reference)])

                 ($.definition \\parser.end
                   "Ensure the parser's input is empty.")

                 ($.definition \\parser.next
                   "Yields the next character (without consuming it from the input).")

                 ($.definition \\parser.remaining
                   "Get all of the remaining input (without consuming it).")

                 ($.definition \\parser.range
                   "Only yields characters within a range."
                   [(range bottom top)])

                 (,, (with_template [<name> <desc>]
                       [($.definition <name>
                          (format "Only yields " <desc> " characters."))]

                       [\\parser.upper "uppercase"]
                       [\\parser.lower "lowercase"]
                       [\\parser.decimal "decimal"]
                       [\\parser.octal "octal"]
                       ))

                 ($.definition \\parser.alpha
                   "Yields alphabetic characters.")

                 ($.definition \\parser.alpha_num
                   "Yields alphanumeric characters.")

                 ($.definition \\parser.hexadecimal
                   "Yields hexadecimal digits.")

                 (,, (with_template [<name> <description_modifier>]
                       [($.definition <name>
                          (format "Yields characters that are" <description_modifier> " part of a piece of text."))]

                       [\\parser.one_of ""]
                       [\\parser.none_of " not"]
                       ))

                 (,, (with_template [<name> <description_modifier>]
                       [($.definition <name>
                          (format "Yields characters (as a slice) that are" <description_modifier> " part of a piece of text."))]

                       [\\parser.one_of! ""]
                       [\\parser.none_of! " not"]
                       ))

                 ($.definition \\parser.satisfies
                   "Yields characters that satisfy a predicate."
                   [(satisfies parser)])

                 ($.definition \\parser.space
                   "Yields white-space.")

                 ($.definition \\parser.and
                   "Yields the outputs of both parsers composed together."
                   [(and left right)])

                 ($.definition \\parser.and!
                   "Yields the outputs of both parsers composed together (as a slice)."
                   [(and! left right)])

                 (,, (with_template [<text> <slice>]
                       [(`` ($.definition <text>
                              (format "Yields " (,, (template.text [<name>])) " characters as a single continuous text.")))
                        (`` ($.definition <slice>
                              (format "Yields " (,, (template.text [<name>])) " characters as a single continuous text (as a slice).")))]

                       [\\parser.some \\parser.some!]
                       [\\parser.many \\parser.many!]
                       ))

                 (,, (with_template [<text> <slice> <doc_modifier>]
                       [(`` ($.definition <text>
                              (format "Yields " <doc_modifier> " N characters.")))
                        (`` ($.definition <slice>
                              (format "Yields " <doc_modifier> " N characters (as a slice).")))]

                       [\\parser.exactly  \\parser.exactly!  "exactly"]
                       [\\parser.at_most  \\parser.at_most!  "at most"]
                       [\\parser.at_least \\parser.at_least! "at least"]
                       ))

                 ($.definition \\parser.between
                   ""
                   [(between minimum additional parser)])

                 ($.definition \\parser.between!
                   ""
                   [(between! minimum additional parser)])

                 ($.definition \\parser.enclosed
                   ""
                   [(enclosed [start end] parser)])

                 ($.definition \\parser.local
                   "Applies a parser against the given input."
                   [(local local_input parser)])

                 ($.definition \\parser.slice
                   "Converts a slice to a block of text."
                   [(slice parser)])

                 ($.definition \\parser.then
                   "Embeds a text parser into an arbitrary parser that yields text."
                   [(then structured text)])]
                [])))

(.def .public documentation
  (.List $.Module)
  ($.module /._
            ""
            [($.default /.of_char)

             ($.default /.\0)
             ($.default /.null)
             ($.default /.\a)
             ($.default /.alarm)
             ($.default /.\b)
             ($.default /.back_space)
             ($.default /.\t)
             ($.default /.tab)
             ($.default /.\n)
             ($.default /.new_line)
             ($.default /.\v)
             ($.default /.vertical_tab)
             ($.default /.\f)
             ($.default /.form_feed)
             ($.default /.\r)
             ($.default /.carriage_return)
             ($.default /.\'')
             ($.default /.double_quote)
             
             ($.default /.size)
             ($.default /.format)
             ($.default /.equivalence)
             ($.default /.order)
             ($.default /.monoid)
             ($.default /.hash)
             ($.default /.together)
             ($.default /.empty?)
             ($.default /.space)
             ($.default /.lower_cased)
             ($.default /.upper_cased)

             ($.definition /.Char
               "A character code number.")

             ($.definition /.line_feed
               "Same as 'new_line'.")

             ($.definition /.char
               "Yields the character at the specified index."
               [(char index input)])

             ($.definition /.index_since
               ""
               [(index_since from pattern input)])

             ($.definition /.index
               ""
               [(index pattern input)])

             ($.definition /.last_index
               ""
               [(last_index part text)])

             ($.definition /.starts_with?
               ""
               [(starts_with? prefix x)])

             ($.definition /.ends_with?
               ""
               [(ends_with? postfix x)])

             ($.definition /.enclosed_by?
               ""
               [(enclosed_by? boundary value)])

             ($.definition /.contains?
               ""
               [(contains? sub text)])

             ($.definition /.prefix
               ""
               [(prefix param subject)])

             ($.definition /.suffix
               ""
               [(suffix param subject)])

             ($.definition /.enclosed
               "Surrounds the given content text with left and right side additions."
               [(enclosed [left right] content)])

             ($.definition /.enclosed'
               "Surrounds the given content text with the same boundary text."
               [(enclosed' boundary content)])

             ($.definition /.clip
               "Clips a chunk of text from the input at the specified offset and of the specified size."
               [(clip offset size input)])

             ($.definition /.clip_since
               "Clips the remaining text from the input at the specified offset."
               [(clip_since offset input)])

             ($.definition /.split_at
               ""
               [(split_at at x)])

             ($.definition /.split_by
               ""
               [(split_by token sample)])

             ($.definition /.all_split_by
               ""
               [(all_split_by token sample)])

             ($.definition /.replaced_once
               ""
               [(replaced_once pattern replacement template)])

             ($.definition /.replaced
               ""
               [(replaced pattern replacement template)])

             ($.definition /.interposed
               ""
               [(interposed separator texts)])

             ($.definition /.space?
               "Checks whether the character is white-space."
               [(space? char)])]
            [..\\format
             ..\\parser
             
             /buffer.documentation
             /encoding.documentation
             /escape.documentation
             /regex.documentation
             /unicode.documentation]))
