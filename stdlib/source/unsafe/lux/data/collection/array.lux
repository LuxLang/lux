... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except macro)
   [abstract
    ["[0]" equivalence]
    ["[0]" functor]]
   [error (.only error)
    ["[0]" try]]
   [data
    [collection
     ["[0]" stack]]]
   [function
    ["[0]" predicate]]]])

(the expansion#let (.in_module# .prelude .expansion#let))
(the with_template (.in_module# .prelude .with_template))
(the macro (.in_module# .prelude .template#macro))

(the name_of_type
  (.type_name# "array"))

(`` (every .public (Array' read write)
      {.#Nominal (,, (static ..name_of_type))
                 (list [(,, (static ..contra_variant)) write]
                       [(,, (static ..co_variant)) read])}))

(every .public (Array it)
  (Array' it it))

(every .public Index
  Natural)

(the .public empty
  (macro (_ ,size)
    [((.is (.for_any (_ it)
             (.-> ..Index
                  (..Array it)))
           (.function (_ size)
             (.array# size)))
      ,size)]))

(the .public size
  (macro (_ ,it)
    [(.array_size# ,it)]))

(the n#<
  (macro (_ ,reference ,it)
    [(.int_<# (.integer ,reference) (.integer ,it))]))

(`` (the .public has?
      (macro (_ ,index ,it)
        [((.is (.for_any (_ read write)
                 (.-> ..Index
                      (predicate.Predicate (..Array' read write))))
               (.function (_ index it)
                 (.and (,, (n#< (..size it) index))
                       (.array_has?# index it))))
          ,index ,it)])))

(the .public lacks?
  (macro (_ ,index ,it)
    [(.not (..has? ,index ,it))]))

(the .public item
  (macro (_ ,index ,it)
    [(.array_its# ,index ,it)]))

(the .public has!
  (macro (_ ,index ,value ,it)
    [(.array_has# ,index ,value ,it)]))

(the .public lacks!
  (macro (_ ,index ,it)
    [(.array_lacks# ,index ,it)]))

(the .public revised!
  (macro (revised! <index> <$> <array>)
    [((.is (.for_any (_ read write)
             (.-> ..Index (.-> read write) (..Array' read write)
                  (..Array' read write)))
           (.function (revised! index $ array)
             (.if (..has? index array)
                  (..has! index ($ (..item index array)) array)
                  array)))
      <index> <$> <array>)]))

(the .public upsert!
  (macro (upsert! <index> <default> <$> <array>)
    [((.is (.for_any (_ read write)
             (.-> ..Index read (.-> read write) (..Array' read write)
                  (..Array' read write)))
           (.function (upsert! index default $ array)
             (..has! index
                     ($ (.if (..has? index array)
                             (..item index array)
                             default))
                     array)))
      <index> <default> <$> <array>)]))

(`` (the .public copy!
      (macro (copy! <length> <src_start> <src_array> <dest_start> <dest_array>)
        [((.is (.for_any (_ read write any)
                 (.-> ..Index ..Index (..Array' write any) ..Index (..Array' read write)
                      (..Array' read write)))
               (.function (copy! length src_start src_array dest_start dest_array)
                 (.loop (again [offset 0])
                   (.if (,, (n#< length offset))
                        (.exec
                          (.if (..has? (.i64_+# offset src_start) src_array)
                               (..has! (.i64_+# offset dest_start)
                                       (..item (.i64_+# offset src_start) src_array)
                                       dest_array)
                               (..lacks! (.i64_+# offset dest_start) dest_array))
                          (again (.i64_+# 1 offset)))
                        dest_array))))
          <length> <src_start> <src_array> <dest_start> <dest_array>)])))

(with_template [<name> <when_lacks> <when_has>]
  [(`` (the .public <name>
         (macro (<name> <array>)
           [((.is (.for_any (_ read write)
                    (.-> (..Array' read write)
                         ..Index))
                  (.function (occupancy array)
                    (.let [size (..size array)]
                      (.loop (again [index 0
                                     it 0])
                        (.if (,, (n#< size index))
                             (again (.i64_+# 1 index) (.if (..has? index array)
                                                           <when_has>
                                                           <when_lacks>))
                             it)))))
             <array>)])))]

  [occupancy it (.i64_+# 1 it)]
  [vacancy (.i64_+# 1 it) it]
  )

(`` (the .public only!
      (macro (only! <?> <it>)
        [((.is (.for_any (_ read write)
                 (.-> (.-> read .Bit) (..Array' read write)
                      (..Array' read write)))
               (.function (only! ? it)
                 (.let [size (..size it)]
                   (.loop (again [index 0])
                     (.if (,, (n#< size index))
                          (.exec
                            (.if (..has? index it)
                                 (.if (? (..item index it))
                                      it
                                      (..lacks! index it))
                                 it)
                            (again (.i64_+# 1 index)))
                          it)))))
          <?> <it>)])))

(the .public no_example
  (error "No example to be found."))

(with_template [<name> <predicate> <test> <type> <term>]
  [(`` (the .public <name>
         (macro (<name> <?> <it>)
           [((.is (.for_any (_ read write)
                    (.-> <predicate> (..Array' read write)
                         (try.Try <type>)))
                  (.function (<name> ? it)
                    (.let [size (..size it)]
                      (.loop (again [index 0])
                        (.if (,, (n#< size index))
                             (.if (..has? index it)
                                  (.let [it (..item index it)]
                                    (.if <test>
                                         {try.#Success <term>}
                                         (again (.i64_+# 1 index))))
                                  (again (.i64_+# 1 index)))
                             {try.#Failure ..no_example})))))
             <?> <it>)])))]

  [example (.-> read .Bit) (? it) read it]
  [example' (.-> ..Index read .Bit) (? index it) [..Index read] [index it]]
  )

(the .public clone
  (macro (clone <it>)
    [((.is (.for_any (_ it)
             (.-> (..Array it)
                  (..Array it)))
           (.function (clone it)
             (.let [size (..size it)]
               (..copy! size 0 it 0 (..empty size)))))
      <it>)]))

(`` (the .public =
      (macro (= <//#=> <left/*> <right/*>)
        [((.is (.for_any (_ read write_left write_right)
                 (.-> (equivalence.Equivalence read)
                      (.-> (..Array' read write_left) (..Array' read write_right)
                           .Bit)))
               (.function (= //#= left/* right/*)
                 (.let [size (..size left/*)]
                   (.and (.i64_=# (..size right/*) size)
                         (.loop (again [index 0])
                           (.if (,, (n#< size index))
                                (.if (..has? index left/*)
                                     (.if (..has? index right/*)
                                          (.and (//#= (..item index left/*)
                                                      (..item index right/*))
                                                (again (.i64_+# 1 index)))
                                          .false)
                                     (..lacks? index right/*))
                                true))))))
          <//#=> <left/*> <right/*>)])))

(the .public composite
  (macro (composite <left/*> <right/*>)
    [((.is (.for_any (_ it)
             (.-> (..Array' it .Nothing) (..Array' it .Nothing)
                  (..Array it)))
           (.function (composite left/* right/*)
             (.let [|left| (..size left/*)
                    |right| (..size right/*)]
               (.|> (..empty (.i64_+# |left| |right|))
                    (..copy! |left| 0 left/* 0)
                    (..copy! |right| 0 right/* |left|)))))
      <left/*> <right/*>)]))

(`` (the .public mix
      (macro (mix <$> <init> <it>)
        [((.is (.for_any (_ read write state)
                 (.-> (.-> ..Index read state state) state (..Array' read write)
                      state))
               (.function (mix $ init it)
                 (.let [size (..size it)]
                   (.loop (again [index 0
                                  so_far init])
                     (.if (,, (n#< size index))
                          (again (.i64_+# 1 index) (.if (..has? index it)
                                                        ($ index (..item index it) so_far)
                                                        so_far))
                          so_far)))))
          <$> <init> <it>)])))

(the .public each
  (macro (each <$> <input>)
    [((.is (functor.Functor ..Array)
           (.function (each $ input)
             (..mix (.function (_ index item output)
                      (..has! index ($ item) output))
                    (..empty (..size input))
                    input)))
      <$> <input>)]))

(with_template [<name> <init> <op>]
  [(`` (the .public <name>
         (macro (<name> <?> <it>)
           [((.is (.for_any (_ read write)
                    (.-> (predicate.Predicate read)
                         (predicate.Predicate (..Array' read write))))
                  (.function (<name> ? it)
                    (.let [size (..size it)]
                      (.loop (again [index 0])
                        (.if (,, (n#< size index))
                             (.if (..has? index it)
                                  (<op> (? (..item index it))
                                        (again (.i64_+# 1 index)))
                                  (again (.i64_+# 1 index)))
                             <init>)))))
             <?> <it>)])))]

  [every? .true  and]
  [any?   .false or]
  )

(the .public no_one
  (error "No one value to be found."))

(`` (the .public one
      (macro (one <?> <it>)
        [((.is (.for_any (_ read read' write)
                 (.-> (.-> read (.Maybe read')) (..Array' read write)
                      (try.Try read')))
               (.function (one ? it)
                 (.let [size (..size it)]
                   (.loop (again [index 0])
                     (.if (,, (n#< size index))
                          (<| (..expansion#let [<again> (again (.i64_+# 1 index))])
                              (.if (..has? index it)
                                   (.when (? (..item index it))
                                     {.#None}
                                     <again>

                                     {.#Some output}
                                     {try.#Success output})
                                   <again>))
                          {try.#Failure ..no_one})))))
          <?> <it>)])))

(the .public of_stack
  (macro (of_stack <input>)
    [((.is (.for_any (_ it)
             (.-> (.Stack it)
                  (..Array it)))
           (.function (of_stack input)
             (.let [size (stack.size input)
                    output (..empty size)]
               (.loop (again [index 0
                              input input])
                 (.when input
                   {.#Empty}
                   output
                   
                   {.#Top head tail}
                   (.exec
                     (..has! index head output)
                     (again (.i64_+# 1 index) tail)))))))
      <input>)]))

(the underflow
  ..Index
  (-- 0))

(`` (the as_stack|-default
      (macro (_ <empty> <array>)
        [((.is (.for_any (_ read write)
                 (.-> (.Stack read) (..Array' read write)
                      (.Stack read)))
               (.function (_ empty array)
                 (.loop (again [index (.i64_-# 1 (..size array))
                                output empty])
                   (.if (.i64_=# (,, (.static ..underflow)) index)
                        output
                        (again (.i64_-# 1 index)
                               (.if (..lacks? index array)
                                    output
                                    {.#Top (..item index array) output}))))))
          <empty> <array>)])))

(`` (the as_stack|+default
      (macro (_ <default> <array>)
        [((.is (.for_any (_ read write)
                 (.-> read (..Array' read write)
                      (.Stack read)))
               (.function (_ default array)
                 (.loop (again [index (.i64_-# 1 (..size array))
                                output (`` (.is (.Stack (,, (.these (,, (.type_of default)))))
                                                {.#Empty}))])
                   (.if (.i64_=# (,, (.static ..underflow)) index)
                        output
                        (again (.i64_-# 1 index)
                               {.#Top (.if (..lacks? index array)
                                           default
                                           (..item index array))
                                      output})))))
          <default> <array>)])))

(`` (the .public as_stack
      (macro (_ <default> <array>)
        [((.is (.for_any (_ read write)
                 (.-> (.Maybe read) (..Array' read write)
                      (.Stack read)))
               (.function (_ default array)
                 (.when default
                   {.#Some default}
                   (,, (..as_stack|+default default array))

                   {.#None}
                   (,, (..as_stack|-default {.#Empty} array)))))
          <default> <array>)])))
