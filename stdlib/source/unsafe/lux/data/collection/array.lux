... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except macro)
   [abstract
    ["[0]" equivalence]
    ["[0]" functor]]
   [error (.only error)
    ["[0]" try]]
   [data
    [collection
     ["[0]" stack]]]
   [function
    ["[0]" predicate]]]])

(the expansion#let (.in_module# .prelude .expansion#let))
(the with_template (.in_module# .prelude .with_template))
(the macro (.in_module# .prelude .template#macro))

(the name_of_type
  (.type_name# "array"))

(every .public Index
  Natural)

(the .public empty
  (macro (_ ,size)
    [((.is (.-> ..Index
                .Array)
           (.|>> .array#))
      ,size)]))

(the .public size
  (macro (_ ,it)
    [(.array_size# ,it)]))

(the n#<
  (macro (_ ,reference ,it)
    [(.int_<# (.integer ,reference) (.integer ,it))]))

(the n#after
  (macro (_ ,offset ,it)
    [(.i64_+# ,offset ,it)]))

(`` (the n#next
      (macro (_ ,it)
        [(,, (n#after 1 ,it))])))

(the n#previous
  (macro (_ ,it)
    [(.i64_-# 1 ,it)]))

(`` (the .public has?
      (macro (_ ,index ,it)
        [((.is (.for_any (_ to_write to_read)
                 (.-> ..Index
                      (predicate.Predicate (.Array' to_write to_read))))
               (.function (_ index it)
                 (.and (,, (n#< (..size it) index))
                       (.array_has?# index it))))
          ,index ,it)])))

(the .public lacks?
  (macro (_ ,index ,it)
    [(.not (..has? ,index ,it))]))

(the .public item
  (macro (_ ,index ,it)
    [(.array_its# ,index ,it)]))

(the .public has!
  (macro (_ ,index ,value ,it)
    [(.array_has# ,index ,value ,it)]))

(the .public lacks!
  (macro (_ ,index ,it)
    [(.array_lacks# ,index ,it)]))

(the .public revised!
  (macro (revised! <index> <$> <array>)
    [((.is (.for_any (_ to_write to_read)
             (.-> ..Index (.-> to_read to_write)
                  (.Change (.Array' to_write to_read))))
           (.function (revised! index $ array)
             (.if (..has? index array)
                  (..has! index ($ (..item index array)) array)
                  array)))
      <index> <$> <array>)]))

(the .public upsert!
  (macro (upsert! <index> <default> <$> <array>)
    [((.is (.for_any (_ to_write to_read)
             (.-> ..Index to_read (.-> to_read to_write)
                  (.Change (.Array' to_write to_read))))
           (.function (upsert! index default $ array)
             (..has! index
                     ($ (.if (..has? index array)
                             (..item index array)
                             default))
                     array)))
      <index> <default> <$> <array>)]))

(`` (the .public copy!
      (macro (copy! <length> <src_start> <src_array> <dest_start> <dest_array>)
        [((.is (.for_any (_ to_write to_read any)
                 (.-> ..Index ..Index (.Array' any to_write) ..Index
                      (.Change (.Array' to_write to_read))))
               (.function (copy! length src_start src_array dest_start dest_array)
                 (.loop (again [offset 0])
                   (.if (,, (n#< length offset))
                        (.exec
                          (.if (..has? (,, (n#after offset src_start)) src_array)
                               (..has! (,, (n#after offset dest_start))
                                       (..item (,, (n#after offset src_start)) src_array)
                                       dest_array)
                               (..lacks! (,, (n#after offset dest_start)) dest_array))
                          (again (,, (n#next offset))))
                        dest_array))))
          <length> <src_start> <src_array> <dest_start> <dest_array>)])))

(with_template [<name> <when_lacks> <when_has>]
  [(`` (the .public <name>
         (macro (<name> <array>)
           [((.is (.for_any (_ to_write to_read)
                    (.-> (.Array' to_write to_read)
                         ..Index))
                  (.function (occupancy array)
                    (.let [size (..size array)]
                      (.loop (again [index 0
                                     it 0])
                        (.if (,, (n#< size index))
                             (again (,, (n#next index)) (.if (..has? index array)
                                                             <when_has>
                                                             <when_lacks>))
                             it)))))
             <array>)])))]

  [occupancy it (,, (n#next it))]
  [vacancy (,, (n#next it)) it]
  )

(`` (the .public only!
      (macro (only! <?> <it>)
        [((.is (.for_any (_ to_write to_read)
                 (.-> (predicate.Predicate to_read)
                      (.Change (.Array' to_write to_read))))
               (.function (only! ? it)
                 (.let [size (..size it)]
                   (.loop (again [index 0])
                     (.if (,, (n#< size index))
                          (.exec
                            (.if (..has? index it)
                                 (.if (? (..item index it))
                                      it
                                      (..lacks! index it))
                                 it)
                            (again (,, (n#next index))))
                          it)))))
          <?> <it>)])))

(the .public no_example
  (error "No example to be found."))

(with_template [<name> <predicate> <test> <type> <term>]
  [(`` (the .public <name>
         (macro (<name> <?> <it>)
           [((.is (.for_any (_ to_write to_read)
                    (.-> <predicate> (.Array' to_write to_read)
                         (try.Try <type>)))
                  (.function (<name> ? it)
                    (.let [size (..size it)]
                      (.loop (again [index 0])
                        (.if (,, (n#< size index))
                             (.if (..has? index it)
                                  (.let [it (..item index it)]
                                    (.if <test>
                                         {try.#Success <term>}
                                         (again (,, (n#next index)))))
                                  (again (,, (n#next index))))
                             {try.#Failure ..no_example})))))
             <?> <it>)])))]

  [example (predicate.Predicate to_read) (? it) to_read it]
  [example' (.-> ..Index (predicate.Predicate to_read)) (? index it) [..Index to_read] [index it]]
  )

(the .public clone
  (macro (clone <it>)
    [((.is (.for_any (_ it)
             (.Change (.Array it)))
           (.function (clone it)
             (.let [size (..size it)]
               (..copy! size 0 it 0 (..empty size)))))
      <it>)]))

(`` (the .public =
      (macro (= <//#=> <left/*> <right/*>)
        [((.is (.for_any (_ any_left any_right to_read)
                 (.-> (equivalence.Equivalence to_read)
                      (.-> (.Array' any_left to_read) (.Array' any_right to_read)
                           .Bit)))
               (.function (= //#= left/* right/*)
                 (.let [size (..size left/*)]
                   (.and (.i64_=# (..size right/*) size)
                         (.loop (again [index 0])
                           (.if (,, (n#< size index))
                                (.if (..has? index left/*)
                                     (.if (..has? index right/*)
                                          (.and (//#= (..item index left/*)
                                                      (..item index right/*))
                                                (again (,, (n#next index))))
                                          .false)
                                     (..lacks? index right/*))
                                true))))))
          <//#=> <left/*> <right/*>)])))

(`` (the .public composite
      (macro (composite <left/*> <right/*>)
        [((.is (.for_any (_ any_left any_right to_read)
                 (.-> (.Array' any_left to_read) (.Array' any_right to_read)
                      (.Array to_read)))
               (.function (composite left/* right/*)
                 (.let [|left| (..size left/*)
                        |right| (..size right/*)]
                   (.|> (..empty (,, (n#after |left| |right|)))
                        (..copy! |left| 0 left/* 0)
                        (..copy! |right| 0 right/* |left|)))))
          <left/*> <right/*>)])))

(`` (the .public mix
      (macro (mix <$> <init> <it>)
        [((.is (.for_any (_ to_write to_read state)
                 (.-> (.-> ..Index to_read (.Change state)) state (.Array' to_write to_read)
                      state))
               (.function (mix $ init it)
                 (.let [size (..size it)]
                   (.loop (again [index 0
                                  so_far init])
                     (.if (,, (n#< size index))
                          (again (,, (n#next index)) (.if (..has? index it)
                                                          ($ index (..item index it) so_far)
                                                          so_far))
                          so_far)))))
          <$> <init> <it>)])))

(the .public each
  (macro (each <$> <input>)
    [((.is (functor.Functor .Array)
           (.function (each $ input)
             (..mix (.function (_ index item output)
                      (..has! index ($ item) output))
                    (..empty (..size input))
                    input)))
      <$> <input>)]))

(with_template [<name> <init> <op>]
  [(`` (the .public <name>
         (macro (<name> <?> <it>)
           [((.is (.for_any (_ to_write to_read)
                    (.-> (predicate.Predicate to_read)
                         (predicate.Predicate (.Array' to_write to_read))))
                  (.function (<name> ? it)
                    (.let [size (..size it)]
                      (.loop (again [index 0])
                        (.if (,, (n#< size index))
                             (.if (..has? index it)
                                  (<op> (? (..item index it))
                                        (again (,, (n#next index))))
                                  (again (,, (n#next index))))
                             <init>)))))
             <?> <it>)])))]

  [every? .true  and]
  [any?   .false or]
  )

(the .public no_one
  (error "No one value to be found."))

(`` (the .public one
      (macro (one <?> <it>)
        [((.is (.for_any (_ to_write to_read to_read')
                 (.-> (.-> to_read (.Maybe to_read')) (.Array' to_write to_read)
                      (try.Try to_read')))
               (.function (one ? it)
                 (.let [size (..size it)]
                   (.loop (again [index 0])
                     (.if (,, (n#< size index))
                          (<| (..expansion#let [<again> (again (,, (n#next index)))])
                              (.if (..has? index it)
                                   (.when (? (..item index it))
                                     {.#None}
                                     <again>

                                     {.#Some output}
                                     {try.#Success output})
                                   <again>))
                          {try.#Failure ..no_one})))))
          <?> <it>)])))

(`` (the .public of_stack
      (macro (of_stack <input>)
        [((.is (.for_any (_ it)
                 (.-> (.Stack it)
                      (.Array it)))
               (.function (of_stack input)
                 (.let [size (stack.size input)
                        output (..empty size)]
                   (.loop (again [index 0
                                  input input])
                     (.when input
                       {.#Empty}
                       output
                       
                       {.#Top head tail}
                       (.exec
                         (..has! index head output)
                         (again (,, (n#next index)) tail)))))))
          <input>)])))

(the underflow
  ..Index
  (-- 0))

(`` (the as_stack|-default
      (macro (_ <empty> <array>)
        [((.is (.for_any (_ to_write to_read)
                 (.-> (.Stack to_read) (.Array' to_write to_read)
                      (.Stack to_read)))
               (.function (_ empty array)
                 (.loop (again [index (,, (n#previous (..size array)))
                                output empty])
                   (.if (.i64_=# (,, (.static ..underflow)) index)
                        output
                        (again (,, (n#previous index))
                               (.if (..lacks? index array)
                                    output
                                    {.#Top (..item index array) output}))))))
          <empty> <array>)])))

(`` (the as_stack|+default
      (macro (_ <default> <array>)
        [((.is (.for_any (_ to_write to_read)
                 (.-> to_read (.Array' to_write to_read)
                      (.Stack to_read)))
               (.function (_ default array)
                 (.loop (again [index (,, (n#previous (..size array)))
                                output (`` (.is (.Stack (,, (.these (,, (.type_of default)))))
                                                {.#Empty}))])
                   (.if (.i64_=# (,, (.static ..underflow)) index)
                        output
                        (again (,, (n#previous index))
                               {.#Top (.if (..lacks? index array)
                                           default
                                           (..item index array))
                                      output})))))
          <default> <array>)])))

(`` (the .public as_stack
      (macro (_ <default> <array>)
        [((.is (.for_any (_ to_write to_read)
                 (.-> (.Maybe to_read) (.Array' to_write to_read)
                      (.Stack to_read)))
               (.function (_ default array)
                 (.when default
                   {.#Some default}
                   (,, (..as_stack|+default default array))

                   {.#None}
                   (,, (..as_stack|-default {.#Empty} array)))))
          <default> <array>)])))
