(.module:
  [lux #*
   [abstract
    [equivalence (#+ Equivalence)]
    [order (#+ Order)]
    [codec (#+ Codec)]
    [monad (#+ do)]]
   [control
    ["." try (#+ Try)]
    ["." exception (#+ exception:)]
    ["<>" parser
     ["<.>" text (#+ Parser)]
     ["<.>" code]]]
   [data
    [number
     ["i" int ("#\." decimal)]]
    ["." text ("#\." monoid)]]
   [type
    abstract]
   [macro
    ["." code]
    [syntax (#+ syntax:)]]]
  [//
   ["/" modulus (#+ Modulus)]])

(abstract: #export (Mod m)
  {#modulus (Modulus m)
   #remainder Int}

  {#.doc "A number under a modulus."}

  (def: #export (modular modulus value)
    (All [m] (-> (Modulus m) Int (Mod m)))
    (:abstraction {#modulus modulus
                   #remainder (i.mod (/.divisor modulus) value)}))

  (def: #export un-modular
    (All [m] (-> (Mod m) [(Modulus m) Int]))
    (|>> :representation))

  (exception: #export [m] (incorrect-modulus {modulus (Modulus m)}
                                             {parsed Int})
    (exception.report
     ["Expected" (i\encode (/.divisor modulus))]
     ["Actual" (i\encode parsed)]))

  (def: separator
    " mod ")

  (def: intL
    (Parser Int)
    (<>.codec i.decimal
              (<text>.and (<text>.one-of "-+") (<text>.many <text>.decimal))))

  (structure: #export (codec expected)
    (All [m] (-> (Modulus m) (Codec Text (Mod m))))

    (def: (encode modular)
      (let [[_ remainder] (:representation modular)]
        ($_ text\compose
            (i\encode remainder)
            ..separator
            (i\encode (/.divisor expected)))))

    (def: decode
      (<text>.run (do <>.monad
                    [[remainder _ actual] ($_ <>.and intL (<text>.this ..separator) intL)
                     _ (<>.assert (exception.construct ..incorrect-modulus [expected actual])
                                  (i.= (/.divisor expected) actual))]
                    (wrap (..modular expected remainder))))))

  (exception: #export [rm sm] (unequal-moduli {reference (Modulus rm)}
                                              {subject (Modulus sm)})
    (exception.report
     ["Reference" (i\encode (/.divisor reference))]
     ["Subject" (i\encode (/.divisor subject))]))

  (def: #export (equalize reference subject)
    (All [r s] (-> (Mod r) (Mod s) (Try (Mod r))))
    (let [[reference-modulus reference] (:representation reference)
          [subject-modulus subject] (:representation subject)]
      (if (i.= (/.divisor reference-modulus)
               (/.divisor subject-modulus))
        (#try.Success (:abstraction {#modulus reference-modulus
                                     #remainder subject}))
        (exception.throw ..unequal-moduli [reference-modulus subject-modulus]))))

  (template [<name> <op>]
    [(def: #export (<name> reference subject)
       (All [m] (-> (Mod m) (Mod m) Bit))
       (let [[_ reference] (:representation reference)
             [_ subject] (:representation subject)]
         (<op> reference subject)))]

    [= i.=]
    [< i.<]
    [<= i.<=]
    [> i.>]
    [>= i.>=]
    )

  (structure: #export equivalence
    (All [%] (Equivalence (Mod %)))

    (def: = ..=))

  (structure: #export order
    (All [%] (Order (Mod %)))

    (def: &equivalence ..equivalence)
    (def: < ..<))

  (template [<name> <op>]
    [(def: #export (<name> param subject)
       (All [m] (-> (Mod m) (Mod m) (Mod m)))
       (let [[modulus param] (:representation param)
             [_ subject] (:representation subject)]
         (:abstraction {#modulus modulus
                        #remainder (|> subject
                                       (<op> param)
                                       (i.mod (/.divisor modulus)))})))]

    [+ i.+]
    [- i.-]
    [* i.*]
    )
  
  (def: (gcd+ a b)
    (-> Int Int [Int Int Int])
    (if (i.= +0 a)
      [+0 +1 b]
      (let [[ak bk gcd] (gcd+ (i.mod a b) a)]
        [(i.- (i.* ak
                   (i./ a b))
              bk)
         ak
         gcd])))

  (def: #export (inverse modular)
    (All [m] (-> (Mod m) (Maybe (Mod m))))
    (let [[modulus value] (:representation modular)
          [vk mk gcd] (gcd+ value (/.divisor modulus))
          co-prime? (i.= +1 gcd)]
      (if co-prime?
        (#.Some (..modular modulus vk))
        #.None)))
  )
