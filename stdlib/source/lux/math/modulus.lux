(.module:
  [lux #*
   [abstract
    [monad (#+ do)]]
   [control
    ["." try (#+ Try)]
    ["." exception (#+ exception:)]
    [parser
     ["<.>" code]]]
   [data
    [number
     ["i" int]]]
   [type
    abstract]
   ["." meta]
   [macro
    [syntax (#+ syntax:)]
    ["." code]]])

(exception: #export zero-cannot-be-a-modulus)

(abstract: #export (Modulus m)
  Int

  {#.doc (doc "A number used as a modulus in modular arithmetic."
              "It cannot be 0.")}

  (def: #export (modulus value)
    (Ex [m] (-> Int (Try (Modulus m))))
    (if (i.= +0 value)
      (exception.throw ..zero-cannot-be-a-modulus [])
      (#try.Success (:abstraction value))))

  (def: #export divisor
    (All [m] (-> (Modulus m) Int))
    (|>> :representation))

  (def: #export (= reference subject)
    (All [r s] (-> (Modulus r) (Modulus s) Bit))
    (i.= (:representation reference)
         (:representation subject)))

  (def: #export (congruent? modulus reference subject)
    (All [m] (-> (Modulus m) Int Int Bit))
    (|> subject
        (i.- reference)
        (i.% (:representation modulus))
        (i.= +0)))
  )

(syntax: #export (literal {divisor <code>.int})
  (meta.lift
   (do try.monad
     [_ (..modulus divisor)]
     (wrap (list (` ((~! try.assume) (..modulus (~ (code.int divisor))))))))))
