(.module:
  [lux #*
   [abstract
    [monad (#+ do)]]
   [control
    ["." try (#+ Try)]
    ["." exception (#+ exception:)]]
   [data
    ["." name ("#\." equivalence codec)]
    ["." text
     ["%" format (#+ format)]]
    [collection
     ["." list]
     ["." dictionary]]
    [format
     ["/" xml (#+ Attribute Tag XML)]]]]
  ["." //])

(type: #export (Parser a)
  (//.Parser (List XML) a))

(exception: #export empty-input)
(exception: #export unexpected-input)

(exception: #export (wrong-tag {expected Tag} {actual Tag})
  (exception.report
   ["Expected" (%.text (/.tag expected))]
   ["Actual" (%.text (/.tag actual))]))

(exception: #export (unknown-attribute {expected Attribute} {available (List Attribute)})
  (exception.report
   ["Expected" (%.text (/.attribute expected))]
   ["Available" (exception.enumerate (|>> /.attribute %.text) available)]))

(exception: #export (unconsumed-inputs {inputs (List XML)})
  (exception.report
   ["Inputs" (exception.enumerate (\ /.codec encode) inputs)]))

(def: #export text
  (Parser Text)
  (function (_ docs)
    (case docs
      #.Nil
      (exception.throw ..empty-input [])
      
      (#.Cons head tail)
      (case head
        (#/.Text value)
        (#try.Success [tail value])
        
        (#/.Node _)
        (exception.throw ..unexpected-input [])))))

(def: #export (node expected)
  (-> Tag (Parser Any))
  (function (_ docs)
    (case docs
      #.Nil
      (exception.throw ..empty-input [])
      
      (#.Cons head _)
      (case head
        (#/.Text _)
        (exception.throw ..unexpected-input [])
        
        (#/.Node actual _attributes _children)
        (if (name\= expected actual)
          (#try.Success [docs []])
          (exception.throw ..wrong-tag [expected actual]))))))

(def: #export tag
  (Parser Tag)
  (function (_ docs)
    (case docs
      #.Nil
      (exception.throw ..empty-input [])
      
      (#.Cons head _)
      (case head
        (#/.Text _)
        (exception.throw ..unexpected-input [])
        
        (#/.Node tag _attributes _children)
        (#try.Success [docs tag])))))

(def: #export (attribute name)
  (-> Attribute (Parser Text))
  (function (_ docs)
    (case docs
      #.Nil
      (exception.throw ..empty-input [])
      
      (#.Cons head _)
      (case head
        (#/.Text _)
        (exception.throw ..unexpected-input [])
        
        (#/.Node tag attributes children)
        (case (dictionary.get name attributes)
          #.None
          (exception.throw ..unknown-attribute [name (dictionary.keys attributes)])
          
          (#.Some value)
          (#try.Success [docs value]))))))

(def: (run' parser docs)
  (All [a] (-> (Parser a) (List XML) (Try a)))
  (case (//.run parser docs)
    (#try.Success [remaining output])
    (if (list.empty? remaining)
      (#try.Success output)
      (exception.throw ..unconsumed-inputs remaining))
    
    (#try.Failure error)
    (#try.Failure error)))

(def: #export (children parser)
  (All [a] (-> (Parser a) (Parser a)))
  (function (_ docs)
    (case docs
      #.Nil
      (exception.throw ..empty-input [])
      
      (#.Cons head tail)
      (case head
        (#/.Text _)
        (exception.throw ..unexpected-input [])
        
        (#/.Node _tag _attributes children)
        (do try.monad
          [output (run' parser children)]
          (wrap [tail output]))))))

(def: #export ignore
  (Parser Any)
  (function (_ docs)
    (case docs
      #.Nil
      (exception.throw ..empty-input [])
      
      (#.Cons head tail)
      (#try.Success [tail []]))))

(def: #export (run parser document)
  (All [a] (-> (Parser a) XML (Try a)))
  (..run' parser (list document)))

(exception: #export nowhere)

(def: #export (somewhere parser)
  (All [a] (-> (Parser a) (Parser a)))
  (function (recur input)
    (case (//.run parser input)
      (#try.Success [remaining output])
      (#try.Success [remaining output])
      
      (#try.Failure error)
      (case input
        #.Nil
        (exception.throw ..nowhere [])
        
        (#.Cons head tail)
        (do try.monad
          [[tail' output] (recur tail)]
          (wrap [(#.Cons head tail')
                 output]))))))
