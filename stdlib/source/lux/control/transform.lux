(.module:
  lux
  (lux (control [eq #+ Eq]
                [hash #+ Hash])
       (data [maybe]
             (coll [set #+ Set]
                   [dict #+ Dict]))
       (math ["r" random #+ PRNG])))

## [Types]
(type: #export (Producer pv ps)
  [ps (-> ps (Maybe [pv ps]))])

(type: #export (Result r)
  (#Partial r)
  (#Total r))

(type: #export (Consumer cv cs)
  [cs (-> cv cs (Result cs))])

## TODO: Replace with Maybe once new-luxc becomes the standard compiler.
(type: #export (Step v t)
  (#Continue t (Maybe v))
  #Stop)

(type: #export (Transform pv cv)
  (-> pv (Step cv (Transform pv cv))))

## [Primitives]
(def: #export (compose prev next)
  (All [a b c]
    (-> (Transform a b) (Transform b c) (Transform a c)))
  (function [input]
    (case (prev input)
      (#Continue prev' (#.Some temp))
      (case (next temp)
        (#Continue next' ?output)
        (#Continue (compose prev' next') ?output)

        #Stop
        #Stop)

      (#Continue prev' #.None)
      (#Continue (compose prev' next) #.None)
      
      #Stop
      #Stop)))

(def: #export (each left right)
  (All [a l r]
    (-> (Transform a l) (Transform a r) (Transform a [l r])))
  (function [input]
    (case [(left input)
           (right input)]
      [(#Continue left' ?output|left)
       (#Continue right' ?output|right)]
      (case [?output|left ?output|right]
        [(#.Some output|left) (#.Some output|right)]
        (#Continue (each left' right')
                   (#.Some [output|left output|right]))

        _
        (#Continue (each left' right')
                   #.None))

      _
      #Stop)))

(def: #export (either left right)
  (All [a b]
    (-> (Transform a b) (Transform a b) (Transform a b)))
  (function [input]
    (case (left input)
      (#Continue left' (#.Some output))
      (#Continue (either left' right) (#.Some output))

      (^template [<case> <left-state> <done>]
        <case>
        (case (right input)
          (#Continue right' (#.Some output))
          (#Continue (either <left-state> right') (#.Some output))

          (#Continue right' #.None)
          (#Continue (either <left-state> right') #.None)
          
          #Stop
          <done>))
      ([(#Continue left' #.None) left' (#Continue (either left' right) #.None)]
       [#Stop left #Stop])
      )))

(def: #export (run transform producer consumer)
  (All [pv ps cv cs]
    (-> (Transform pv cv)
        (Producer pv ps)
        (Consumer cv cs)
        cs))
  (let [[init|producer produce] producer
        [init|consumer consume] consumer]
    (loop [transform transform
           state|producer init|producer
           state|consumer init|consumer]
      ## TODO: Delete 'output' let-binding once new-luxc is the
      ## standard compiler.
      (let [output (case (produce state|producer)
                     (#.Some [production state|producer'])
                     (case (transform production)
                       (#Continue transform' (#.Some temp))
                       (case (consume temp state|consumer)
                         (#Partial state|consumer')
                         (recur transform' state|producer' state|consumer')
                         
                         (#Total output)
                         output)
                       
                       (#Continue transform' #.None)
                       (recur transform' state|producer' state|consumer)
                       
                       #Stop
                       state|consumer)
                     
                     #.None
                     state|consumer)]
        output))))

## [Producers]
(def: #export (list-producer source)
  (All [a] (-> (List a) (Producer a (List a))))
  [source
   (function [full]
     (case full
       (#.Cons head tail)
       (#.Some head tail)

       #.Nil
       #.None))])

## [Consumers]
(def: #export (list-consumer sink)
  (All [a] (-> (List a) (Consumer a (List a))))
  [sink
   (function [head tail]
     (#Partial (#.Cons head tail)))])

## [Transforms]
(def: #export (map f)
  (All [a b] (-> (-> a b) (Transform a b)))
  (function self [input]
    (#Continue self (#.Some (f input)))))

(def: #export (map-indexed f)
  (All [a b] (-> (-> Nat a b) (Transform a b)))
  (loop [index +0]
    (function [input]
      (#Continue (recur (n/inc index)) (#.Some (f index input))))))

(def: #export (filter pred)
  (All [a] (-> (-> a Bool) (Transform a a)))
  (function self [input]
    (#Continue self (if (pred input)
                      (#.Some input)
                      #.None))))

(def: #export (keep f)
  (All [a b] (-> (-> a (Maybe b)) (Transform a b)))
  (function self [input]
    (#Continue self (f input))))

(def: #export (keep-indexed f)
  (All [a b] (-> (-> Nat a (Maybe b)) (Transform a b)))
  (loop [index +0]
    (function [input]
      (#Continue (recur (n/inc index)) (f index input)))))

(def: #export (take amount)
  (All [a] (-> Nat (Transform a a)))
  (loop [remaining amount]
    (function [input]
      (if (n/= +0 remaining)
        #Stop
        (#Continue (recur (n/dec remaining)) (#.Some input))))))

(def: #export (drop amount)
  (All [a] (-> Nat (Transform a a)))
  (loop [remaining amount]
    (function [input]
      (if (n/= +0 remaining)
        (#Continue (recur remaining) (#.Some input))
        (#Continue (recur (n/dec remaining)) #.None)))))

(def: #export (take-while pred)
  (All [a] (-> (-> a Bool) (Transform a a)))
  (function self [input]
    (if (pred input)
      (#Continue self (#.Some input))
      #Stop)))

(def: #export (drop-while pred)
  (All [a] (-> (-> a Bool) (Transform a a)))
  (loop [dropping? true]
    (function [input]
      (if (and dropping?
               (pred input))
        (#Continue (recur true) #.None)
        (#Continue (recur false) (#.Some input))))))

(def: #export (take-nth nth)
  (All [a] (-> Nat (Transform a a)))
  (loop [seen +0]
    (function [input]
      (let [mod (n/% nth (n/inc seen))]
        (if (n/= +0 mod)
          (#Continue (recur mod) (#.Some input))
          (#Continue (recur mod) #.None))))))

(def: #export (drop-nth nth)
  (All [a] (-> Nat (Transform a a)))
  (loop [seen +0]
    (function [input]
      (let [mod (n/% nth (n/inc seen))]
        (if (n/= +0 mod)
          (#Continue (recur mod) #.None)
          (#Continue (recur mod) (#.Some input)))))))

(def: #export (distinct Hash<a>)
  (All [a] (-> (Hash a) (Transform a a)))
  (loop [seen (set.new Hash<a>)]
    (function [input]
      (if (set.member? seen input)
        (#Continue (recur seen) #.None)
        (#Continue (recur (set.add input seen)) (#.Some input))))))

## TODO: Remove whenever feasible.
(def: helper|de-duplicate
  (All [a] (-> (Eq a) (Maybe a)))
  (function [_] #.None))
(def: #export (de-duplicate Eq<a>)
  (All [a] (-> (Eq a) (Transform a a)))
  (loop [last (helper|de-duplicate Eq<a>)]
    (function [input]
      (case last
        (^multi (#.Some last') (:: Eq<a> = last' input))
        (#Continue (recur last) #.None)

        _
        (#Continue (recur (#.Some input)) (#.Some input))))))

(def: #export (random probability prng)
  (All [a] (-> Deg PRNG (Transform a a)))
  (loop [prng prng]
    (function [input]
      (let [[prng' chance] (r.run prng r.deg)]
        (if (d/< probability chance)
          (#Continue (recur prng') (#.Some input))
          (#Continue (recur prng') #.None))))))

(def: #export (replace dict)
  (All [a] (-> (Dict a a) (Transform a a)))
  (function self [input]
    (|> dict
        (dict.get input)
        (maybe.default input)
        #.Some
        (#Continue self))))
