(.module:
  lux
  (lux (control [eq #+ Eq]
                [hash #+ Hash])
       (data [maybe]
             (coll [list]
                   [set #+ Set]
                   [dict #+ Dict]))
       (math ["r" random #+ PRNG])))

## [Types]
(type: #export (Producer pv ps)
  [ps (-> ps (Maybe [pv ps]))])

(type: #export (Result r)
  (#Partial r)
  (#Total r))

(type: #export (Consumer cv cs)
  [cs (-> cv cs (Result cs))])

(type: #export (Step v s)
  (#Continue s (Maybe v))
  #Stop)

(type: #export (Transform pv cv ts)
  [ts (-> pv ts (Step cv ts))])

## [Primitives]
(def: #export (compose prev next)
  (All [a b c ps ns]
    (-> (Transform a b ps) (Transform b c ns)
        (Transform a c [ps ns])))
  (let [[init|prev step|prev] prev
        [init|next step|next] next]
    [[init|prev init|next]
     (function [input [state|prev state|next]]
       (case (step|prev input state|prev)
         (#Continue state|prev' (#.Some temp))
         (case (step|next temp state|next)
           (#Continue state|next' ?output)
           (#Continue [state|prev' state|next'] ?output)

           #Stop
           #Stop)

         (#Continue state|prev' #.None)
         (#Continue [state|prev' state|next] #.None)
         
         #Stop
         #Stop))]))

(def: #export (each left right)
  (All [a l r ls rs]
    (-> (Transform a l ls) (Transform a r rs)
        (Transform a (& l r) [ls rs])))
  (let [[init|left step|left] left
        [init|right step|right] right]
    [[init|left init|right]
     (function [input [state|left state|right]]
       (case [(step|left input state|left)
              (step|right input state|right)]
         [(#Continue state|left' (#.Some output|left))
          (#Continue state|right' (#.Some output|right))]
         (#Continue [state|left' state|right']
                    (#.Some [output|left output|right]))

         (^or [#Stop _] [_ #Stop])
         #Stop

         [(#Continue state|left' #.None) _]
         (#Continue [state|left' state|right] #.None)

         [_ (#Continue state|right' #.None)]
         (#Continue [state|left state|right'] #.None)))]))

(def: #export (either left right)
  (All [a b ls rs]
    (-> (Transform a b ls) (Transform a b rs)
        (Transform a b [ls rs])))
  (let [[init|left step|left] left
        [init|right step|right] right]
    [[init|left init|right]
     (function [input [state|left state|right]]
       (case (step|left input state|left)
         (#Continue state|left' (#.Some output))
         (#Continue [state|left' state|right] (#.Some output))

         (^template [<case> <left-state> <done>]
           <case>
           (case (step|right input state|right)
             (#Continue state|right' (#.Some output))
             (#Continue [<left-state> state|right'] (#.Some output))

             (#Continue state|right' #.None)
             (#Continue [<left-state> state|right'] #.None)
             
             #Stop
             <done>))
         ([(#Continue state|left' #.None) state|left' (#Continue [state|left' state|right] #.None)]
          [#Stop state|left #Stop])
         ))]))

(def: #export (run transform producer consumer)
  (All [ts pv ps cv cs]
    (-> (Transform pv cv ts)
        (Producer pv ps)
        (Consumer cv cs)
        cs))
  (let [[init|transform step] transform
        [init|producer produce] producer
        [init|consumer consume] consumer]
    (loop [state|transform init|transform
           state|producer init|producer
           state|consumer init|consumer]
      ## TODO: Delete 'output' let-binding once new-luxc is the
      ## standard compiler.
      (let [output (case (produce state|producer)
                     (#.Some [production state|producer'])
                     (case (step production state|transform)
                       (#Continue state|transform' (#.Some temp))
                       (case (consume temp state|consumer)
                         (#Partial state|consumer')
                         (recur state|transform' state|producer' state|consumer')
                         
                         (#Total output)
                         output)
                       
                       (#Continue state|transform' #.None)
                       (recur state|transform' state|producer' state|consumer)
                       
                       #Stop
                       state|consumer)
                     
                     #.None
                     state|consumer)]
        output))))

## [Producers]
(def: #export (list-producer source)
  (All [a] (-> (List a) (Producer a (List a))))
  [source
   (function [full]
     (case full
       (#.Cons head tail)
       (#.Some head tail)

       #.Nil
       #.None))])

## [Consumers]
(def: #export (list-consumer sink)
  (All [a] (-> (List a) (Consumer a (List a))))
  [sink
   (function [head tail]
     (#Partial (#.Cons head tail)))])

## [Transforms]
(def: #export (map f)
  (All [a b] (-> (-> a b) (Transform a b Unit)))
  [[]
   (function [input state]
     (#Continue state (#.Some (f input))))])

(def: #export (map-indexed f)
  (All [a b] (-> (-> Nat a b) (Transform a b Nat)))
  [+0
   (function [input index]
     (#Continue (n/inc index) (#.Some (f index input))))])

(def: #export (filter pred)
  (All [a] (-> (-> a Bool) (Transform a a Unit)))
  [[]
   (function [input state]
     (#Continue state (if (pred input)
                        (#.Some input)
                        #.None)))])

(def: #export (keep f)
  (All [a b] (-> (-> a (Maybe b)) (Transform a b Unit)))
  [[]
   (function [input state]
     (#Continue state (f input)))])

(def: #export (keep-indexed f)
  (All [a b] (-> (-> Nat a (Maybe b)) (Transform a b Nat)))
  [+0
   (function [input index]
     (#Continue (n/inc index) (f index input)))])

(def: #export (take amount)
  (All [a] (-> Nat (Transform a a Nat)))
  [amount
   (function [input remaining]
     (if (n/= +0 remaining)
       #Stop
       (#Continue (n/dec remaining) (#.Some input))))])

(def: #export (drop amount)
  (All [a] (-> Nat (Transform a a Nat)))
  [amount
   (function [input remaining]
     (if (n/= +0 remaining)
       (#Continue remaining (#.Some input))
       (#Continue (n/dec remaining) #.None)))])

(def: #export (take-while pred)
  (All [a] (-> (-> a Bool) (Transform a a Unit)))
  [[]
   (function [input state]
     (if (pred input)
       (#Continue state (#.Some input))
       #Stop))])

(def: #export (drop-while pred)
  (All [a] (-> (-> a Bool) (Transform a a Bool)))
  [true
   (function [input dropping?]
     (if (and dropping?
              (pred input))
       (#Continue true #.None)
       (#Continue false (#.Some input))))])

(def: #export (take-nth nth)
  (All [a] (-> Nat (Transform a a Nat)))
  [+0
   (function [input seen]
     (let [mod (n/% nth (n/inc seen))]
       (if (n/= +0 mod)
         (#Continue mod (#.Some input))
         (#Continue mod #.None))))])

(def: #export (drop-nth nth)
  (All [a] (-> Nat (Transform a a Nat)))
  [+0
   (function [input seen]
     (let [mod (n/% nth (n/inc seen))]
       (if (n/= +0 mod)
         (#Continue mod #.None)
         (#Continue mod (#.Some input)))))])

(def: #export (distinct Hash<a>)
  (All [a] (-> (Hash a) (Transform a a (Set a))))
  [(set.new Hash<a>)
   (function [input seen]
     (if (set.member? seen input)
       (#Continue seen #.None)
       (#Continue (set.add input seen) (#.Some input))))])

(def: #export (de-duplicate Eq<a>)
  (All [a] (-> (Eq a) (Transform a a (Maybe a))))
  [#.None
   (function [input last]
     (case last
       (^multi (#.Some last') (:: Eq<a> = last' input))
       (#Continue last #.None)

       _
       (#Continue (#.Some input) (#.Some input))))])

(def: #export (random probability prng)
  (All [a] (-> Deg PRNG (Transform a a PRNG)))
  [prng
   (function [input prng]
     (let [[prng' chance] (r.run prng r.deg)]
       (if (d/< probability chance)
         (#Continue prng' (#.Some input))
         (#Continue prng' #.None))))])

(def: #export (replace dict)
  (All [a] (-> (Dict a a) (Transform a a Unit)))
  [[]
   (function [input state]
     (|> dict
         (dict.get input)
         (maybe.default input)
         #.Some
         (#Continue state)))])
