(.module:
  lux
  (// [functor #+ Functor]
      [monad #+ Monad]))

(sig: #export (Applicative f)
  {#.doc "Applicative functors."}
  (: (Functor f)
     functor)
  (: (All [a b]
       (-> (f (-> a b)) (f a) (f b)))
     apply))

(struct: #export (compose Monad<F> Applicative<F> Applicative<G>)
  {#.doc "Applicative functor composition."}
  (All [F G]
    (-> (Monad F) (Applicative F) (Applicative G)
        (Applicative (All [a] (F (G a))))))
  
  (def: functor (functor.compose (get@ #functor Applicative<F>)
                                 (get@ #functor Applicative<G>)))
  (def: (apply fgf fgx)
    ## TODO: Switch from this version to the one below (in comments) ASAP.
    (let [fgf' (:: Applicative<F> apply
                   (:: Monad<F> wrap (:: Applicative<G> apply))
                   fgf)]
      (:: Applicative<F> apply fgf' fgx))
    ## (let [applyF (:: Applicative<F> apply)
    ##       applyG (:: Applicative<G> apply)]
    ##   ($_ applyF
    ##       (:: Monad<F> wrap applyG)
    ##       fgf
    ##       fgx))
    ))
