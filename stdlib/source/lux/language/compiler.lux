(.module:
  lux
  (lux (control [state]
                ["ex" exception (#+ Exception exception:)]
                [monad (#+ do)])
       (data [product]
             [error (#+ Error)]
             [text]
             text/format)
       [function]
       (macro ["s" syntax (#+ syntax:)])))

(type: #export (Operation s o)
  (state.State' Error s o))

(def: #export Monad<Operation>
  (state.Monad<State'> error.Monad<Error>))

(type: #export (Compiler s i o)
  (-> i (Operation s o)))

(def: #export (run state operation)
  (All [s o]
    (-> s (Operation s o) (Error o)))
  (|> state
      operation
      (:: error.Monad<Error> map product.right)))

(def: #export fail
  (-> Text Operation)
  (|>> error.fail (state.lift error.Monad<Error>)))

(def: #export (throw exception parameters)
  (All [e] (-> (Exception e) e Operation))
  (state.lift error.Monad<Error>
              (ex.throw exception parameters)))

(syntax: #export (assert exception message test)
  (wrap (list (` (if (~ test)
                   (:: ..Monad<Operation> (~' wrap) [])
                   (..throw (~ exception) (~ message)))))))

(def: #export (localized transform)
  (All [s o]
    (-> (-> s s)
        (-> (Operation s o) (Operation s o))))
  (function (_ operation)
    (function (_ state)
      (case (operation (transform state))
        (#error.Error error)
        (#error.Error error)

        (#error.Success [state' output])
        (#error.Success [state output])))))

(def: #export (with-state state)
  (All [s o] (-> s (-> (Operation s o) (Operation s o))))
  (localized (function.constant state)))

(def: #export (with-stack exception message action)
  (All [e s o] (-> (Exception e) e (Operation s o) (Operation s o)))
  (<<| (ex.with-stack exception message)
       action))

(def: #export identity
  (All [s a] (Compiler s a a))
  (function (_ input state)
    (#error.Success [state input])))

(def: #export (compose pre post)
  (All [s0 s1 i t o]
    (-> (Compiler s0 i t)
        (Compiler s1 t o)
        (Compiler [s0 s1] i o)))
  (function (_ input [pre/state post/state])
    (do error.Monad<Error>
      [[pre/state' temp] (pre input pre/state)
       [post/state' output] (post temp post/state)]
      (wrap [[pre/state' post/state'] output]))))
