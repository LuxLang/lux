(.module:
  [lux #- nat int deg]
  (lux (control [equality #+ Equality]
                [hash #+ Hash])
       [function]
       (data (coll [list "list/" Fold<List>]))))

(type: #export #rec Primitive
  #Unit
  (#Bool Bool)
  (#Nat Nat)
  (#Int Int)
  (#Deg Deg)
  (#Frac Frac)
  (#Text Text))

(type: #export Tag Nat)

(type: #export (Composite a)
  (#Sum (Either a a))
  (#Product [a a]))

(type: #export Register Nat)

(type: #export #rec Pattern
  (#Simple Primitive)
  (#Complex (Composite Pattern))
  (#Bind Register))

(type: #export (Branch' e)
  {#when Pattern
   #then e})

(type: #export Variable
  (#Local Register)
  (#Foreign Register))

(type: #export Reference
  (#Variable Variable)
  (#Constant Ident))

(struct: #export _ (Equality Variable)
  (def: (= reference sample)
    (case [reference sample]
      (^template [<tag>]
        [(<tag> reference') (<tag> sample')]
        (n/= reference' sample'))
      ([#Local] [#Foreign])

      _
      false)))

(struct: #export _ (Hash Variable)
  (def: eq Equality<Variable>)
  (def: (hash var)
    (case var
      (#Local register)
      (n/* +1 register)
      
      (#Foreign register)
      (n/* +2 register))))

(type: #export (Match' e)
  [(Branch' e) (List (Branch' e))])

(type: #export Environment
  (List Variable))

(type: #export (Special e)
  {#extension Text
   #parameters (List e)})

(type: #export #rec Analysis
  (#Primitive Primitive)
  (#Structure (Composite Analysis))
  (#Reference Reference)
  (#Case Analysis (Match' Analysis))
  (#Function Environment Analysis)
  (#Apply Analysis Analysis)
  (#Special (Special Analysis)))

(type: #export Branch
  (Branch' Analysis))

(type: #export Match
  (Match' Analysis))

(do-template [<name> <tag>]
  [(template: #export (<name> content)
     (<tag> content))]

  [control/case #Case]
  )

(do-template [<name> <family> <tag>]
  [(template: #export (<name> content)
     (<| #Reference
         <family>
         <tag>
         content))]

  [variable/local   #..Variable #..Local]
  [variable/foreign #..Variable #..Foreign]
  )

(do-template [<name> <tag>]
  [(template: #export (<name> content)
     (<| #Reference
         <tag>
         content))]

  [reference/variable #..Variable]
  [reference/constant #..Constant]
  )

(do-template [<name> <type> <tag>]
  [(def: #export <name>
     (-> <type> Analysis)
     (|>> <tag> #Primitive))]

  [bool Bool #Bool]
  [nat  Nat  #Nat]
  [int  Int  #Int]
  [deg  Deg  #Deg]
  [frac Frac #Frac]
  [text Text #Text]
  )

(type: #export (Variant a)
  {#lefts Nat
   #right? Bool
   #value a})

(type: #export (Tuple a) (List a))

(type: #export Application [Analysis (List Analysis)])

(def: (last? size tag)
  (-> Nat Tag Bool)
  (n/= (dec size) tag))

(template: #export (no-op value)
  (#Apply value (#Function (list) (#Reference (#Variable (#Local +1))))))

(do-template [<name> <type> <structure> <prep-value>]
  [(def: #export (<name> size tag value)
     (-> Nat Tag <type> <type>)
     (let [left (function.constant (|>> #.Left #Sum <structure>))
           right (|>> #.Right #Sum <structure>)]
       (if (last? size tag)
         (if (n/= +1 tag)
           (right value)
           (list/fold left
                      (right value)
                      (list.n/range +0 (n/- +2 tag))))
         (list/fold left
                    (case value
                      (<structure> (#Sum _))
                      (<prep-value> value)

                      _
                      value)
                    (list.n/range +0 tag)))))]

  [sum-analysis Analysis #Structure no-op]
  [sum-pattern  Pattern  #Complex   id]
  )

(do-template [<name> <type> <primitive> <structure>]
  [(def: #export (<name> members)
     (-> (Tuple <type>) <type>)
     (case (list.reverse members)
       #.Nil
       (<primitive> #Unit)

       (#.Cons singleton #.Nil)
       singleton

       (#.Cons last prevs)
       (list/fold (function (_ left right) (<structure> (#Product left right)))
                  last prevs)))]

  [product-analysis Analysis #Primitive #Structure]
  [product-pattern  Pattern  #Simple    #Complex]
  )

(def: #export (apply [func args])
  (-> Application Analysis)
  (list/fold (function (_ arg func) (#Apply arg func)) func args))

(type: #export Analyser
  (-> Code (Meta Analysis)))

(do-template [<name> <type> <tag>]
  [(def: #export (<name> value)
     (-> <type> (Tuple <type>))
     (case value
       (<tag> (#Product left right))
       (#.Cons left (<name> right))

       _
       (list value)))]

  [tuple         Analysis #Structure]
  [tuple-pattern Pattern  #Complex]
  )

(do-template [<name> <type> <tag>]
  [(def: #export (<name> value)
     (-> <type> (Maybe (Variant <type>)))
     (loop [lefts +0
            variantA value]
       (case variantA
         (<tag> (#Sum (#.Left valueA)))
         (case valueA
           (<tag> (#Sum _))
           (recur (inc lefts) valueA)

           _
           (#.Some {#lefts lefts
                    #right? false
                    #value valueA}))
         
         (<tag> (#Sum (#.Right valueA)))
         (#.Some {#lefts lefts
                  #right? true
                  #value valueA})

         _
         #.None)))]

  [variant         Analysis #Structure]
  [variant-pattern Pattern  #Complex]
  )

(def: #export (application analysis)
  (-> Analysis Application)
  (case analysis
    (#Apply head func)
    (let [[func' tail] (application func)]
      [func' (#.Cons head tail)])

    _
    [analysis (list)]))

(def: #export (self? var)
  (-> Variable Bool)
  (case var
    (#Local +0)
    true
    
    _
    false))

(template: #export (pattern/unit)
  (#..Simple #..Unit))

(do-template [<name> <tag>]
  [(template: #export (<name> content)
     (#..Simple (<tag> content)))]
  
  [pattern/bool #..Bool]
  [pattern/nat  #..Nat]
  [pattern/int  #..Int]
  [pattern/deg  #..Deg]
  [pattern/frac #..Frac]
  [pattern/text #..Text]
  )
