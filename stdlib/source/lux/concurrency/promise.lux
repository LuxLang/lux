(.module:
  lux
  (lux (data (coll [list #* "" Functor<List>])
             number
             text/format)
       [io #- run]
       function
       (control ["F" functor]
                ["A" applicative]
                ["M" monad #+ do Monad]
                ["p" parser])
       [macro]
       (macro ["s" syntax #+ syntax: Syntax])
       (concurrency [atom #+ Atom atom])))

(def: #export concurrency-level
  Nat
  ("lux process concurrency-level"))

(type: (Promise-State a)
  {#value (Maybe a)
   #observers (List (-> a (IO Top)))})

(type: #export (Promise a)
  {#.doc "Represents values produced by asynchronous computations (unlike IO, which is synchronous)."}
  (Atom (Promise-State a)))

(def: #export (promise ?value)
  (All [a] (-> (Maybe a) (Promise a)))
  (atom {#value ?value
         #observers (list)}))

(def: #export (poll promise)
  {#.doc "Polls a Promise's value."}
  (All [a] (-> (Promise a) (Maybe a)))
  (|> (atom.read promise)
      io.run
      (get@ #value)))

(def: #export (resolved? promise)
  {#.doc "Checks whether a Promise's value has already been resolved."}
  (All [a] (-> (Promise a) Bool))
  (case (poll promise)
    #.None
    false

    (#.Some _)
    true))

(def: #export (resolve value promise)
  {#.doc "Sets an Promise's value if it has not been done yet."}
  (All [a] (-> a (Promise a) (IO Bool)))
  (do Monad<IO>
    [old (atom.read promise)]
    (case (get@ #value old)
      (#.Some _)
      (wrap false)

      #.None
      (do @
        [#let [new (set@ #value (#.Some value) old)]
         succeeded? (atom.compare-and-swap old new promise)]
        (if succeeded?
          (do @
            [_ (M.map @ (function [f] (f value))
                      (get@ #observers old))]
            (wrap true))
          (resolve value promise))))))

(def: #export (await f promise)
  (All [a] (-> (-> a (IO Top)) (Promise a) Top))
  (let [old (io.run (atom.read promise))]
    (case (get@ #value old)
      (#.Some value)
      (io.run (f value))

      #.None
      (let [new (update@ #observers (|>> (#.Cons f)) old)]
        (if (io.run (atom.compare-and-swap old new promise))
          []
          (await f promise))))))

(struct: #export _ (F.Functor Promise)
  (def: (map f fa)
    (let [fb (: (Promise ($ +1)) (promise #.None))
          ## fb (promise' #.None)
          ]
      (exec (await (function [a] (resolve (f a) fb))
                   fa)
        fb))))

(struct: #export _ (A.Applicative Promise)
  (def: functor Functor<Promise>)

  (def: (wrap a)
    (atom {#value (#.Some a)
           #observers (list)}))

  (def: (apply ff fa)
    (let [fb (: (Promise ($ +1)) (promise #.None))
          ## fb (promise' #.None)
          ]
      (exec (await (function [f]
                     (io (await (function [a] (resolve (f a) fb))
                                fa)))
                   ff)
        fb))
    ))

(struct: #export _ (Monad Promise)
  (def: applicative Applicative<Promise>)

  (def: (join mma)
    (let [ma (: (Promise ($ +0)) (promise #.None))
          ## ma (promise' #.None)
          ]
      (exec (await (function [ma']
                     (io (await (function [a'] (resolve a' ma))
                                ma')))
                   mma)
        ma))))

(def: #export (seq left right)
  {#.doc "Sequencing combinator."}
  (All [a b] (-> (Promise a) (Promise b) (Promise [a b])))
  (do Monad<Promise>
    [a left
     b right]
    (wrap [a b])))

(def: #export (alt left right)
  {#.doc "Heterogeneous alternative combinator."}
  (All [a b] (-> (Promise a) (Promise b) (Promise (| a b))))
  (let [a|b (: (Promise (| ($ +0) ($ +1))) (promise #.None))
        ## a|b (promise' #.None)
        ]
    (with-expansions
      [<sides> (do-template [<promise> <tag>]
                 [(await (function [value] (resolve (<tag> value) a|b))
                         <promise>)]

                 [left  #.Left]
                 [right #.Right]
                 )]
      (exec <sides>
        a|b))))

(def: #export (either left right)
  {#.doc "Homogeneous alternative combinator."}
  (All [a] (-> (Promise a) (Promise a) (Promise a)))
  (let [left||right (: (Promise ($ +0)) (promise #.None))
        ## left||right (promise' #.None)
        ]
    (`` (exec (~~ (do-template [<promise>]
                    [(await (function [value] (resolve value left||right))
                            <promise>)]

                    [left]
                    [right]))
          left||right))))

(def: #export (future computation)
  {#.doc "Runs an I/O computation on its own process and returns an Promise that will eventually host its result."}
  (All [a] (-> (IO a) (Promise a)))
  (let [!out (: (Promise ($ +0)) (promise #.None))
        ## !out (promise' #.None)
        ]
    (exec ("lux process future" (io (io.run (resolve (io.run computation)
                                                     !out))))
      !out)))

(def: #export (wait time)
  {#.doc "Returns a Promise that will be resolved after the specified amount of milliseconds."}
  (-> Nat (Promise Unit))
  (let [!out (: (Promise Unit) (promise #.None))]
    (exec ("lux process schedule" time (resolve [] !out))
      !out)))

(def: #export (time-out time promise)
  {#.doc "Wait for a Promise to be resolved within the specified amount of milliseconds."}
  (All [a] (-> Nat (Promise a) (Promise (Maybe a))))
  (alt (wait time) promise))

(def: #export (delay time value)
  {#.doc "Delivers a value after a certain period has passed."}
  (All [a] (-> Nat a (Promise a)))
  (:: Functor<Promise> map (const value) (wait time)))
