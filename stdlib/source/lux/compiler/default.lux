(.module:
  [lux (#- Source)
   [control
    [monad (#+ do)]
    ["ex" exception (#+ exception:)]]
   [data
    ["." product]
    ["." error (#+ Error)]
    [text ("text/." Hash<Text>)
     format
     ["." encoding]]
    [collection
     ["." dictionary]]]
   [type (#+ :share)]
   ["." macro]
   [world
    ["." file (#+ File)]]]
  ["." // (#+ Source)
   ["." cli (#+ Configuration)]
   [meta
    [io
     ["." context]]]]
  [/
   ["." init]
   ["." syntax (#+ Aliases)]
   ["." phase
    ["." analysis
     ["." module]
     [".A" expression]]
    ["." translation (#+ Host Bundle)]
    ["." statement
     [".S" total]]
    ["." extension]]]
  ## (luxc [cache]
  ##       [cache/description]
  ##       [cache/io])
  )

(type: Reader
  (-> .Source (Error [.Source Code])))

(def: (reader current-module aliases)
  (-> Text Aliases (analysis.Operation Reader))
  (function (_ [bundle state])
    (let [[cursor offset source-code] (get@ #.source state)]
      (#error.Success [[bundle state]
                       (syntax.parse current-module aliases ("lux text size" source-code))]))))

(def: (read reader)
  (-> Reader (analysis.Operation Code))
  (function (_ [bundle compiler])
    (case (reader (get@ #.source compiler))
      (#error.Error error)
      (#error.Error error)

      (#error.Success [source' output])
      (let [[cursor _] output]
        (#error.Success [[bundle (|> compiler
                                     (set@ #.source source')
                                     (set@ #.cursor cursor))]
                         output])))))

## ## (def: (write-module target-dir file-name module-name module outputs)
## ##   (-> File Text Text Module Outputs (Process Any))
## ##   (do io.Monad<Process>
## ##     [_ (monad.map @ (product.uncurry (&io.write target-dir))
## ##                   (dictionary.entries outputs))]
## ##     (&io.write target-dir
## ##                (format module-name "/" cache.descriptor-name)
## ##                (encoding.to-utf8 (%code (cache/description.write file-name module))))))

(type: #export (Platform ! anchor expression statement)
  {#host (Host expression statement)
   #phase (translation.Phase anchor expression statement)
   #runtime (translation.Operation anchor expression statement Any)
   #file-system (file.System !)})

(with-expansions [<Platform> (as-is (Platform ! anchor expression statement))
                  <Operation> (as-is (statement.Operation anchor expression statement Any))
                  <State+> (as-is (statement.State+ anchor expression statement))
                  <Bundle> (as-is (Bundle anchor expression statement))]
  
  (def: (begin-module-compilation module-name source)
    (All [anchor expression statement]
      (-> Text Source <Operation>))
    (statement.lift-analysis
     (do phase.Monad<Operation>
       [_ (module.create (text/hash (get@ #//.code source)) module-name)
        _ (analysis.set-current-module module-name)]
       (analysis.set-source-code (init.source (get@ #//.module source) (get@ #//.code source))))))

  (def: end-module-compilation
    (All [anchor expression statement]
      (-> Text <Operation>))
    (|>> module.set-compiled
         statement.lift-analysis))

  (def: (module-compilation-iteration reader)
    (-> Reader (All [anchor expression statement] <Operation>))
    (do phase.Monad<Operation>
      [code (statement.lift-analysis
             (..read reader))
       _ (totalS.phase code)]
      init.refresh))
  
  (def: (module-compilation-loop module-name)
    (All [anchor expression statement]
      (-> Text <Operation>))
    (do phase.Monad<Operation>
      [reader (statement.lift-analysis
               (..reader module-name syntax.no-aliases))]
      (function (_ state)
        (loop [state state]
          (case (module-compilation-iteration reader state)
            (#error.Success [state' output])
            (recur state')
            
            (#error.Error error)
            (if (ex.match? syntax.end-of-file error)
              (#error.Success [state []])
              (ex.with-stack //.cannot-compile module-name (#error.Error error))))))))

  (def: (perform-module-compilation module-name source)
    (All [anchor expression statement]
      (-> Text Source <Operation>))
    (do phase.Monad<Operation>
      [_ (begin-module-compilation module-name source)
       _ (module-compilation-loop module-name)]
      (end-module-compilation module-name)))

  (def: #export (compile-module platform configuration compiler)
    (All [! anchor expression statement]
      (-> <Platform> Configuration <State+> (! <State+>)))
    (do (:: (get@ #file-system platform) &monad)
      [source (context.read (get@ #file-system platform)
                            (get@ #cli.sources configuration)
                            (get@ #cli.module configuration))
       ## _ (&io.prepare-module target-dir (get@ #cli.module configuration))
       ## _ (write-module target-dir file-name (get@ #cli.module configuration) module outputs)
       ]
      (<| (:: @ map product.left)
          (:: (get@ #file-system platform) lift)
          (phase.run' compiler)
          (:share [! anchor expression statement]
                  {<Platform>
                   platform}
                  {<Operation>
                   (perform-module-compilation (get@ #cli.module configuration) source)}))))

  (def: #export (initialize platform configuration translation-bundle)
    (All [! anchor expression statement]
      (-> <Platform> Configuration <Bundle> (! <State+>)))
    (|> platform
        (get@ #runtime)
        statement.lift-translation
        (phase.run' (init.state (get@ #host platform)
                                (get@ #phase platform)
                                translation-bundle))
        (:: error.Functor<Error> map product.left)
        (:: (get@ #file-system platform) lift))
    
    ## (case (runtimeT.translate ## (initL.compiler (io.run js.init))
    ##        (initL.compiler (io.run hostL.init-host))
    ##        )
    ##   ## (#error.Success [compiler disk-write])
    ##   ## (do @
    ##   ##   [_ (&io.prepare-target target)
    ##   ##    _ disk-write
    ##   ##    ## _ (cache/io.pre-load sources target (commonT.load-definition compiler))
    ##   ##    ]
    ##   ##   (wrap (|> compiler
    ##   ##             (set@ [#.info #.mode] #.Build))))

    ##   (#error.Success [compiler [runtime-bc function-bc]])
    ##   (do @
    ##     [_ (&io.prepare-target target)
    ##      ## _ (&io.write target (format hostL.runtime-class ".class") runtime-bc)
    ##      ## _ (&io.write target (format hostL.function-class ".class") function-bc)
    ##      ## _ (cache/io.pre-load sources target (commonT.load-definition compiler))
    ##      ]
    ##     (wrap (|> compiler
    ##               (set@ [#.info #.mode] #.Build))))

    ##   (#error.Error error)
    ##   (io.fail error))
    )

  (def: #export (compile platform configuration translation-bundle)
    (All [! anchor expression statement]
      (-> <Platform> Configuration <Bundle> (! Any)))
    (do (:: (get@ #file-system platform) &monad)
      [compiler (initialize platform configuration translation-bundle)
       _ (compile-module platform (set@ #cli.module syntax.prelude configuration) compiler)
       _ (compile-module platform configuration compiler)
       ## _ (cache/io.clean target ...)
       ]
      (wrap (log! "Compilation complete!"))))
  )
