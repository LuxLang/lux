(.module:
  lux
  [//
   [phase (#+ Eval)
    [analysis
     [".A" expression]]
    ["." synthesis
     [".S" expression]]
    ["." translation (#+ Host)]
    ["." statement]
    ["." extension
     [".E" analysis]
     [".E" synthesis]
     [".E" translation]
     [".E" statement]]]
   [//
    ["." host]]])

(type: #export Version Text)

(def: #export version Version "0.6.0")

(def: #export (cursor file)
  (-> Text Cursor)
  [file 1 0])

(def: #export (source file code)
  (-> Text Text Source)
  [(cursor file) 0 code])

(def: dummy-source
  Source
  [.dummy-cursor 0 ""])

(def: #export type-context
  Type-Context
  {#.ex-counter 0
   #.var-counter 0
   #.var-bindings (list)})

(def: #export info
  Info
  {#.target  (`` (for {(~~ (static host.common-lisp)) host.common-lisp
                       (~~ (static host.js))          host.js
                       (~~ (static host.jvm))         host.jvm
                       (~~ (static host.lua))         host.lua
                       (~~ (static host.php))         host.php
                       (~~ (static host.python))      host.python
                       (~~ (static host.r))           host.r
                       (~~ (static host.ruby))        host.ruby
                       (~~ (static host.scheme))      host.scheme}))
   #.version ..version
   #.mode    #.Build})

(def: #export (compiler host)
  (-> Any Lux)
  {#.info            ..info
   #.source          dummy-source
   #.cursor          .dummy-cursor
   #.current-module  #.None
   #.modules         (list)
   #.scopes          (list)
   #.type-context    ..type-context
   #.expected        #.None
   #.seed            0
   #.scope-type-vars (list)
   #.extensions      []
   #.host            host})

(def: #export (state eval translate host)
  (All [anchor expression statement]
    (-> Eval
        (translation.Phase anchor expression statement)
        (Host expression statement)
        (statement.State+ anchor expression statement)))
  [statementE.bundle
   {#statement.analysis {#statement.state [analysisE.bundle (..compiler [])]
                         #statement.phase (expressionA.analyser eval)}
    #statement.synthesis {#statement.state [synthesisE.bundle synthesis.init]
                          #statement.phase expressionS.synthesize}
    #statement.translation {#statement.state [translationE.bundle (translation.state host)]
                            #statement.phase translate}}])
