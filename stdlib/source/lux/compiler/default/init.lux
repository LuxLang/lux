(.module:
  [lux #*
   [control
    [monad (#+ do)]]
   [data
    ["." product]]]
  [//
   ["." evaluation]
   ["." phase
    ["." analysis
     [".A" expression]]
    ["." synthesis
     [".S" expression]]
    ["." translation (#+ Host)]
    ["." statement]
    ["." extension
     [".E" analysis]
     [".E" synthesis]
     [".E" translation]
     [".E" statement]]]
   [//
    ["." host]]])

(type: #export Version Text)

(def: #export version Version "0.6.0")

(def: #export (cursor file)
  (-> Text Cursor)
  [file 1 0])

(def: #export (source file code)
  (-> Text Text Source)
  [(cursor file) 0 code])

(def: dummy-source
  Source
  [.dummy-cursor 0 ""])

(def: #export type-context
  Type-Context
  {#.ex-counter 0
   #.var-counter 0
   #.var-bindings (list)})

(def: #export info
  Info
  {#.target  (`` (for {(~~ (static host.common-lisp)) host.common-lisp
                       (~~ (static host.js))          host.js
                       (~~ (static host.jvm))         host.jvm
                       (~~ (static host.lua))         host.lua
                       (~~ (static host.php))         host.php
                       (~~ (static host.python))      host.python
                       (~~ (static host.r))           host.r
                       (~~ (static host.ruby))        host.ruby
                       (~~ (static host.scheme))      host.scheme}))
   #.version ..version
   #.mode    #.Build})

(def: #export (compiler host)
  (-> Any Lux)
  {#.info            ..info
   #.source          dummy-source
   #.cursor          .dummy-cursor
   #.current-module  #.None
   #.modules         (list)
   #.scopes          (list)
   #.type-context    ..type-context
   #.expected        #.None
   #.seed            0
   #.scope-type-vars (list)
   #.extensions      []
   #.host            host})

(def: #export (state host translate)
  (All [anchor expression statement]
    (-> (Host expression statement)
        (translation.Phase anchor expression statement)
        (statement.State+ anchor expression statement)))
  (let [synthesis-state [synthesisE.bundle synthesis.init]
        translation-state [translationE.bundle (translation.state host)]
        eval (evaluation.evaluator synthesis-state translation-state translate)
        analysis-state [(analysisE.bundle eval) (..compiler host)]]
    [statementE.bundle
     {#statement.analysis {#statement.state analysis-state
                           #statement.phase expressionA.compile}
      #statement.synthesis {#statement.state synthesis-state
                            #statement.phase expressionS.synthesize}
      #statement.translation {#statement.state translation-state
                              #statement.phase translate}}]))

(def: #export refresh
  (All [anchor expression statement]
    (statement.Operation anchor expression statement Any))
  (do phase.Monad<Operation>
    [[bundle state] phase.get-state
     #let [eval (evaluation.evaluator (get@ [#statement.synthesis #statement.state] state)
                                      (get@ [#statement.translation #statement.state] state)
                                      (get@ [#statement.translation #statement.phase] state))]]
    (phase.set-state [statementE.bundle
                      (update@ [#statement.analysis #statement.state]
                               (: (-> analysis.State+ analysis.State+)
                                  (|>> product.right
                                       [(analysisE.bundle eval)]))
                               state)])))
