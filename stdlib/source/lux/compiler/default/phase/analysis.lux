(.module:
  [lux (#- nat int rev)
   [data
    ["." product]
    ["." error]
    ["." maybe]
    ["." text ("text/." Equivalence<Text>)
     format]
    [collection
     ["." list ("list/." Functor<List> Fold<List>)]]]
   ["." function]]
  [//
   ["." extension (#+ Extension)]
   [//
    ["." reference (#+ Register Variable Reference)]]])

(type: #export #rec Primitive
  #Unit
  (#Bit Bit)
  (#Nat Nat)
  (#Int Int)
  (#Rev Rev)
  (#Frac Frac)
  (#Text Text))

(type: #export Tag Nat)

(type: #export (Composite a)
  (#Sum (Either a a))
  (#Product [a a]))

(type: #export #rec Pattern
  (#Simple Primitive)
  (#Complex (Composite Pattern))
  (#Bind Register))

(type: #export (Branch' e)
  {#when Pattern
   #then e})

(type: #export (Match' e)
  [(Branch' e) (List (Branch' e))])

(type: #export Environment
  (List Variable))

(type: #export #rec Analysis
  (#Primitive Primitive)
  (#Structure (Composite Analysis))
  (#Reference Reference)
  (#Case Analysis (Match' Analysis))
  (#Function Environment Analysis)
  (#Apply Analysis Analysis)
  (#Extension (Extension Analysis)))

(do-template [<special> <general>]
  [(type: #export <special>
     (<general> .Lux Code Analysis))]

  [State+    extension.State]
  [Operation extension.Operation]
  [Phase     extension.Phase]
  [Handler   extension.Handler]
  [Bundle    extension.Bundle]
  )

(type: #export Branch
  (Branch' Analysis))

(type: #export Match
  (Match' Analysis))

(do-template [<name> <tag>]
  [(template: #export (<name> content)
     (<tag> content))]

  [control/case #Case]
  )

(do-template [<name> <type> <tag>]
  [(def: #export <name>
     (-> <type> Analysis)
     (|>> <tag> #Primitive))]

  [bit  Bit  #Bit]
  [nat  Nat  #Nat]
  [int  Int  #Int]
  [rev  Rev  #Rev]
  [frac Frac #Frac]
  [text Text #Text]
  )

(type: #export (Variant a)
  {#lefts Nat
   #right? Bit
   #value a})

(type: #export (Tuple a) (List a))

(type: #export Arity Nat)

(type: #export (Abstraction c) [Environment Arity c])

(type: #export (Application c) [c (List c)])

(def: (last? size tag)
  (-> Nat Tag Bit)
  (n/= (dec size) tag))

(template: #export (no-op value)
  (|> 1 #reference.Local #reference.Variable #..Reference
      (#..Function (list))
      (#..Apply value)))

(do-template [<name> <type> <structure> <prep-value>]
  [(def: #export (<name> size tag value)
     (-> Nat Tag <type> <type>)
     (let [left (function.constant (|>> #.Left #Sum <structure>))
           right (|>> #.Right #Sum <structure>)]
       (if (last? size tag)
         (list/fold left
                    (right value)
                    (list.indices (dec tag)))
         (list/fold left
                    (case value
                      (<structure> (#Sum _))
                      (<prep-value> value)

                      _
                      value)
                    (list.indices (inc tag))))))]

  [sum-analysis Analysis #Structure ..no-op]
  [sum-pattern  Pattern  #Complex   id]
  )

(do-template [<name> <type> <primitive> <structure>]
  [(def: #export (<name> members)
     (-> (Tuple <type>) <type>)
     (case (list.reverse members)
       #.Nil
       (<primitive> #Unit)

       (#.Cons singleton #.Nil)
       singleton

       (#.Cons last prevs)
       (list/fold (function (_ left right) (<structure> (#Product left right)))
                  last prevs)))]

  [product-analysis Analysis #Primitive #Structure]
  [product-pattern  Pattern  #Simple    #Complex]
  )

(def: #export (apply [func args])
  (-> (Application Analysis) Analysis)
  (list/fold (function (_ arg func) (#Apply arg func)) func args))

(do-template [<name> <type> <tag>]
  [(def: #export (<name> value)
     (-> <type> (Tuple <type>))
     (case value
       (<tag> (#Product left right))
       (#.Cons left (<name> right))

       _
       (list value)))]

  [tuple         Analysis #Structure]
  [tuple-pattern Pattern  #Complex]
  )

(do-template [<name> <type> <tag>]
  [(def: #export (<name> value)
     (-> <type> (Maybe (Variant <type>)))
     (loop [lefts 0
            variantA value]
       (case variantA
         (<tag> (#Sum (#.Left valueA)))
         (case valueA
           (<tag> (#Sum _))
           (recur (inc lefts) valueA)

           _
           (#.Some {#lefts lefts
                    #right? #0
                    #value valueA}))
         
         (<tag> (#Sum (#.Right valueA)))
         (#.Some {#lefts lefts
                  #right? #1
                  #value valueA})

         _
         #.None)))]

  [variant         Analysis #Structure]
  [variant-pattern Pattern  #Complex]
  )

(def: #export (application analysis)
  (-> Analysis (Application Analysis))
  (case analysis
    (#Apply head func)
    (let [[func' tail] (application func)]
      [func' (#.Cons head tail)])

    _
    [analysis (list)]))

(template: #export (pattern/unit)
  (#..Simple #..Unit))

(do-template [<name> <tag>]
  [(template: #export (<name> content)
     (#..Simple (<tag> content)))]
  
  [pattern/bit  #..Bit]
  [pattern/nat  #..Nat]
  [pattern/int  #..Int]
  [pattern/rev  #..Rev]
  [pattern/frac #..Frac]
  [pattern/text #..Text]
  )

(def: #export (with-source-code source action)
  (All [a] (-> Source (Operation a) (Operation a)))
  (function (_ [bundle state])
    (let [old-source (get@ #.source state)]
      (case (action [bundle (set@ #.source source state)])
        (#error.Error error)
        (#error.Error error)

        (#error.Success [[bundle' state'] output])
        (#error.Success [[bundle' (set@ #.source old-source state')]
                         output])))))

(def: fresh-bindings
  (All [k v] (Bindings k v))
  {#.counter 0
   #.mappings (list)})

(def: fresh-scope
  Scope
  {#.name     (list)
   #.inner    0
   #.locals   fresh-bindings
   #.captured fresh-bindings})

(def: #export (with-scope action)
  (All [a] (-> (Operation a) (Operation [Scope a])))
  (function (_ [bundle state])
    (case (action [bundle (update@ #.scopes (|>> (#.Cons fresh-scope)) state)])
      (#error.Success [[bundle' state'] output])
      (case (get@ #.scopes state')
        #.Nil
        (#error.Error "Impossible error: Drained scopes!")

        (#.Cons head tail)
        (#error.Success [[bundle' (set@ #.scopes tail state')]
                         [head output]]))

      (#error.Error error)
      (#error.Error error))))

(def: #export (with-current-module name)
  (All [a] (-> Text (Operation a) (Operation a)))
  (extension.localized (get@ #.current-module)
                       (set@ #.current-module)
                       (function.constant (#.Some name))))

(def: #export (with-cursor cursor action)
  (All [a] (-> Cursor (Operation a) (Operation a)))
  (if (text/= "" (product.left cursor))
    action
    (function (_ [bundle state])
      (let [old-cursor (get@ #.cursor state)]
        (case (action [bundle (set@ #.cursor cursor state)])
          (#error.Success [[bundle' state'] output])
          (#error.Success [[bundle' (set@ #.cursor old-cursor state')]
                           output])

          (#error.Error error)
          (#error.Error (format "@ " (%cursor cursor) "\n"
                                error)))))))

(do-template [<name> <type> <field> <value>]
  [(def: #export (<name> value)
     (-> <type> (Operation Any))
     (extension.update (set@ <field> <value>)))]

  [set-source-code    Source #.source         value]
  [set-current-module Text   #.current-module (#.Some value)]
  [set-cursor         Cursor #.cursor         value]
  )

(def: #export (%analysis analysis)
  (Format Analysis)
  (case analysis
    (#Primitive primitive)
    (case primitive
      #Unit
      "[]"

      (^template [<tag> <format>]
        (<tag> value)
        (<format> value))
      ([#Bit %b]
       [#Nat %n]
       [#Int %i]
       [#Rev %r]
       [#Frac %f]
       [#Text %t]))
    
    (#Structure structure)
    (case structure
      (#Sum _)
      (let [[lefts right? value] (maybe.assume (..variant analysis))]
        (format "(" (%n lefts) " " (%b right?) " " (%analysis value) ")"))
      
      (#Product _)
      (|> analysis
          ..tuple
          (list/map %analysis)
          (text.join-with " ")
          (text.enclose ["[" "]"])))
    
    (#Reference reference)
    (case reference
      (#reference.Variable variable)
      (reference.%variable variable)
      
      (#reference.Constant constant)
      (%name constant))
    
    (#Case analysis match)
    "{?}"
    
    (#Function environment body)
    (|> (%analysis body)
        (format " ")
        (format (|> environment
                    (list/map reference.%variable)
                    (text.join-with " ")
                    (text.enclose ["[" "]"])))
        (text.enclose ["(" ")"]))
    
    (#Apply _)
    (|> analysis
        ..application
        #.Cons
        (list/map %analysis)
        (text.join-with " ")
        (text.enclose ["(" ")"]))
    
    (#Extension name parameters)
    (|> parameters
        (list/map %analysis)
        (text.join-with " ")
        (format (%t name) " ")
        (text.enclose ["(" ")"]))))
