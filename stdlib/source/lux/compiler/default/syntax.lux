## This is LuxC's parser.
## It takes the source code of a Lux file in raw text form and
## extracts the syntactic structure of the code from it.
## It only produces Lux Code nodes, and thus removes any white-space
## and comments while processing its inputs.

## Another important aspect of the parser is that it keeps track of
## its position within the input data.
## That is, the parser takes into account the line and column
## information in the input text (it doesn't really touch the
## file-name aspect of the cursor, leaving it intact in whatever
## base-line cursor it is given).

## This particular piece of functionality is not located in one
## function, but it is instead scattered throughout several parsers,
## since the logic for how to update the cursor varies, depending on
## what is being parsed, and the rules involved.

## You will notice that several parsers have a "where" parameter, that
## tells them the cursor position prior to the parser being run.
## They are supposed to produce some parsed output, alongside an
## updated cursor pointing to the end position, after the parser was run.

## Lux Code nodes/tokens are annotated with cursor meta-data
## [file-name, line, column] to keep track of their provenance and
## location, which is helpful for documentation and debugging.
(.module:
  [lux (#- int rev)
   [control
    monad
    ["p" parser ("parser/." Monad<Parser>)]
    ["ex" exception (#+ exception:)]]
   [data
    ["." error (#+ Error)]
    ["." number]
    ["." maybe]
    ["." text
     ["l" lexer (#+ Offset Lexer)]
     format]
    [collection
     ["." list]
     ["." dictionary (#+ Dictionary)]]]])

(type: #export Syntax
  (-> Cursor (Lexer [Cursor Code])))

(type: #export Aliases (Dictionary Text Text))
(def: #export no-aliases Aliases (dictionary.new text.Hash<Text>))

(def: #export prelude "lux")

(def: #export space " ")

(def: #export text-delimiter text.double-quote)

(def: #export open-form "(")
(def: #export close-form ")")

(def: #export open-tuple "[")
(def: #export close-tuple "]")

(def: #export open-record "{")
(def: #export close-record "}")

(def: #export sigil "#")

(def: #export digit-separator "_")

(def: #export positive-sign "+")
(def: #export negative-sign "-")

## These are very simple parsers that just cut chunks of text in
## specific shapes and then use decoders already present in the
## standard library to actually produce the values from the literals.
(def: rich-digit
  (Lexer Text)
  (p.either l.decimal
            (p.after (l.this "_") (parser/wrap ""))))

(def: rich-digits^
  (Lexer Text)
  (l.and l.decimal
         (l.some rich-digit)))

(def: sign^ (l.one-of "+-"))

(do-template [<name> <tag> <lexer> <codec>]
  [(def: #export (<name> where)
     Syntax
     (do p.Monad<Parser>
       [chunk <lexer>]
       (case (:: <codec> decode chunk)
         (#.Left error)
         (p.fail error)

         (#.Right value)
         (wrap [(update@ #.column (n/+ (text.size chunk)) where)
                [where (<tag> value)]]))))]

  [int #.Int
   (l.and sign^ rich-digits^)
   number.Codec<Text,Int>]
  
  [rev #.Rev
   (l.and (l.one-of ".")
          rich-digits^)
   number.Codec<Text,Rev>]
  )

(def: #export (frac where)
  Syntax
  (do p.Monad<Parser>
    [chunk ($_ l.and
               sign^
               rich-digits^
               (l.one-of ".")
               rich-digits^
               (p.default ""
                          ($_ l.and
                              (l.one-of "eE")
                              sign^
                              rich-digits^)))]
    (case (:: number.Codec<Text,Frac> decode chunk)
      (#.Left error)
      (p.fail error)

      (#.Right value)
      (wrap [(update@ #.column (n/+ (text.size chunk)) where)
             [where (#.Frac value)]]))))

## The parts of an name are separated by a single mark.
## E.g. module.short.
## Only one such mark may be used in an name, since there
## can only be 2 parts to an name (the module [before the
## mark], and the short [after the mark]).
## There are also some extra rules regarding name syntax,
## encoded on the parser.
(def: name-separator ".")

(exception: #export (end-of-file {module Text})
  (ex.report ["Module" (%t module)]))

(exception: #export (unrecognized-input {[file line column] Cursor})
  (ex.report ["File" (%t file)]
             ["Line" (%n line)]
             ["Column" (%n column)]))

(exception: #export (text-cannot-contain-new-lines {text Text})
  (ex.report ["Text" (%t text)]))

(exception: #export (invalid-escape-syntax)
  "")

(def: (ast current-module aliases)
  (-> Text Aliases Syntax)
  (function (ast' where)
    ($_ p.either
        (..frac where)
        (..rev where)
        )))

(type: (Simple a)
  (-> Source (Error [Source a])))

(type: (Parser a)
  (-> Text Aliases (Simple a)))

(do-template [<name> <extension> <diff>]
  [(template: (<name> value)
     (<extension> value <diff>))]

  [!inc   "lux i64 +" 1]
  [!inc/2 "lux i64 +" 2]
  [!dec   "lux i64 -" 1]
  )

(do-template [<name> <close> <tag>]
  [(def: (<name> parse source)
     (-> (Simple Code) (Simple Code))
     (loop [source source
            stack (: (List Code) #.Nil)]
       (case (parse source)
         (#error.Success [source' top])
         (recur source' (#.Cons top stack))
         
         (#error.Error error)
         (let [[where offset source-code] source]
           (case ("lux text char" source-code offset)
             (#.Some char)
             (`` (case char
                   (^ (char (~~ (static <close>))))
                   (#error.Success [[(update@ #.column inc where)
                                     (!inc offset)
                                     source-code]
                                    [where (<tag> (list.reverse stack))]])

                   _
                   (ex.throw unrecognized-input where)))
             
             _
             (#error.Error error))))))]

  ## Form and tuple syntax is mostly the same, differing only in the
  ## delimiters involved.
  ## They may have an arbitrary number of arbitrary Code nodes as elements.
  [parse-form  ..close-form  #.Form]
  [parse-tuple ..close-tuple #.Tuple]
  )

(def: (parse-record parse source)
  (-> (Simple Code) (Simple Code))
  (loop [source source
         stack (: (List [Code Code]) #.Nil)]
    (case (parse source)
      (#error.Success [sourceF field])
      (case (parse sourceF)
        (#error.Success [sourceFV value])
        (recur sourceFV (#.Cons [field value] stack))

        (#error.Error error)
        (let [[where offset source-code] source]
          (case ("lux text char" source-code offset)
            (#.Some char)
            (`` (case char
                  (^ (char (~~ (static ..close-record))))
                  (#error.Success [[(update@ #.column inc where)
                                    (!inc offset)
                                    source-code]
                                   [where (#.Record (list.reverse stack))]])

                  _
                  (ex.throw unrecognized-input where)))
            
            _
            (#error.Error error))))

      (#error.Error error)
      (#error.Error error))))

(template: (!clip from to text)
  ## TODO: Optimize-away "maybe.assume"
  (maybe.assume ("lux text clip" text from to)))

(template: (!i/< reference subject)
  ("lux int <" subject reference))

(do-template [<name> <extension>]
  [(template: (<name> param subject)
     (<extension> subject param))]

  [!n/+ "lux i64 +"]
  [!n/- "lux i64 -"]
  )

(template: (!guarantee-no-new-lines content body)
  (case ("lux text index" content (static text.new-line) 0)
    (#.Some g!_)
    (ex.throw ..text-cannot-contain-new-lines content)

    g!_
    body))

(def: digit-bottom Nat (!dec (char "0")))
(def: digit-top Nat (!inc (char "9")))

(template: (!digit? char)
  (and (!i/< (:coerce Int char) (:coerce Int (static ..digit-bottom)))
       (!i/< (:coerce Int (static ..digit-top)) (:coerce Int char))))

(`` (template: (!digit?+ char)
      (or (!digit? char)
          ("lux i64 =" (.char (~~ (static ..digit-separator))) char))))

(`` (template: (!strict-name-char? char)
      (not (or ("lux i64 =" (.char (~~ (static ..space))) char)
               ("lux i64 =" (.char (~~ (static text.new-line))) char)

               ("lux i64 =" (.char (~~ (static ..name-separator))) char)

               ("lux i64 =" (.char (~~ (static ..open-form))) char)
               ("lux i64 =" (.char (~~ (static ..close-form))) char)

               ("lux i64 =" (.char (~~ (static ..open-tuple))) char)
               ("lux i64 =" (.char (~~ (static ..close-tuple))) char)

               ("lux i64 =" (.char (~~ (static ..open-record))) char)
               ("lux i64 =" (.char (~~ (static ..close-record))) char)

               ("lux i64 =" (.char (~~ (static ..text-delimiter))) char)
               ("lux i64 =" (.char (~~ (static ..sigil))) char)))))

(template: (!name-char?|head char)
  (and (!strict-name-char? char)
       (not (!digit? char))))

(template: (!name-char? char)
  (or (!strict-name-char? char)
      (!digit? char)))

(template: (!discrete-output <codec> <tag>)
  (case (:: <codec> decode (!clip start end source-code))
    (#error.Success output)
    (#error.Success [[(update@ #.column (n/+ (!n/- start end)) where)
                      end
                      source-code]
                     [where (<tag> output)]])

    (#error.Error error)
    (#error.Error error)))

(def: (parse-nat start [where offset source-code])
  (-> Offset (Simple Code))
  (loop [end offset]
    (case ("lux text char" source-code end)
      (#.Some char)
      (if (!digit?+ char)
        (recur (!inc end))
        (!discrete-output number.Codec<Text,Nat> #.Nat))
      
      _
      (!discrete-output number.Codec<Text,Nat> #.Nat))))

(def: (parse-int start [where offset source-code])
  (-> Offset (Simple Code))
  (loop [end offset]
    (case ("lux text char" source-code end)
      (#.Some char)
      (if (!digit?+ char)
        (recur (!inc end))
        (!discrete-output number.Codec<Text,Int> #.Int))
      
      _
      (!discrete-output number.Codec<Text,Int> #.Int))))

(template: (!parse-int offset where source-code)
  (let [g!offset/1 (!inc offset)]
    (<| (!with-char source-code g!offset/1 g!char/1)
        (if (!digit? g!char/1)
          (parse-int offset [where (!inc/2 offset) source-code])
          (!parse-full-name offset [where (!inc offset) source-code] where #.Identifier)))))

(with-expansions [<output> (#error.Success [[(update@ #.column (n/+ (!n/- start end)) where)
                                             end
                                             source-code]
                                            (!clip start end source-code)])]
  (def: (parse-name-part start [where offset source-code])
    (-> Offset Source (Error [Source Text]))
    (loop [end offset]
      (case ("lux text char" source-code end)
        (#.Some char)
        (cond (!name-char? char)
              (recur (!inc end))

              ## else
              <output>)
        
        _
        <output>))))

(template: (!leap-bit value)
  ("lux i64 +" value 2))

(template: (!new-line where)
  (let [[where::file where::line where::column] where]
    [where::file (!inc where::line) 0]))

(with-expansions [<end> (ex.throw end-of-file current-module)
                  <failure> (ex.throw unrecognized-input where)
                  <consume-1> (as-is [where (!inc offset) source-code])
                  <consume-2> (as-is [where (!inc/2 offset) source-code])]

  (template: (!with-char @source-code @offset @char @body)
    (case ("lux text char" @source-code @offset)
      (#.Some @char)
      @body
      
      _
      <end>))

  (template: (!parse-half-name @offset//pre @offset//post @char @module)
    (let [@offset//post (!inc @offset//pre)]
      (cond (!name-char?|head @char)
            (case (..parse-name-part @offset//post [where @offset//post source-code])
              (#error.Success [source' name])
              (#error.Success [source' [@module name]])
              
              (#error.Error error)
              (#error.Error error))

            ## else
            <failure>)))

  (`` (def: (parse-short-name current-module [where offset/0 source-code])
        (-> Text Source (Error [Source Name]))
        (<| (!with-char source-code offset/0 char/0)
            (case char/0
              (^ (char (~~ (static ..name-separator))))
              (let [offset/1 (!inc offset/0)]
                (<| (!with-char source-code offset/1 char/1)
                    (!parse-half-name offset/1 offset/2 char/1 current-module)))

              _
              (!parse-half-name offset/0 offset/1 char/0 ..prelude)))))

  (template: (!parse-short-name @current-module @source @where @tag)
    (case (..parse-short-name @current-module @source)
      (#error.Success [source' name])
      (#error.Success [source' [@where (@tag name)]])
      
      (#error.Error error)
      (#error.Error error)))

  (with-expansions [<simple> (as-is (#error.Success [source' ["" simple]]))]
    (`` (def: (parse-full-name start source)
          (-> Offset Source (Error [Source Name]))
          (case (..parse-name-part start source)
            (#error.Success [source' simple])
            (let [[where' offset' source-code'] source']
              (case ("lux text char" source-code' offset')
                (#.Some char/separator)
                (case char/separator
                  (^ (char (~~ (static ..name-separator))))
                  (let [offset'' (!inc offset')]
                    (case (..parse-name-part offset'' [where' offset'' source-code'])
                      (#error.Success [source'' complex])
                      (#error.Success [source'' [simple complex]])
                      
                      (#error.Error error)
                      (#error.Error error)))

                  _
                  <simple>)
                
                _
                <simple>))
            
            (#error.Error error)
            (#error.Error error)))))

  (template: (!parse-full-name @offset @source @where @tag)
    (case (..parse-full-name @offset @source)
      (#error.Success [source' full-name])
      (#error.Success [source' [@where (@tag full-name)]])
      
      (#error.Error error)
      (#error.Error error)))
  
  (def: #export (parse current-module aliases source)
    (-> Text Aliases Source (Error [Source Code]))
    (let [parse' (parse current-module aliases)]
      (loop [[where offset source-code] source]
        (<| (!with-char source-code offset char/0)
            (`` (case char/0
                  ## White-space
                  (^template [<char> <direction>]
                    (^ (char <char>))
                    (recur [(update@ <direction> inc where)
                            (!inc offset)
                            source-code]))
                  ([(~~ (static ..space))              #.column]
                   [(~~ (static text.carriage-return)) #.column])

                  (^ (char (~~ (static text.new-line))))
                  (recur [(!new-line where) (!inc offset) source-code])

                  ## Form
                  (^ (char (~~ (static ..open-form))))
                  (parse-form parse' <consume-1>)

                  ## Tuple
                  (^ (char (~~ (static ..open-tuple))))
                  (parse-tuple parse' <consume-1>)

                  ## Record
                  (^ (char (~~ (static ..open-record))))
                  (parse-record parse' <consume-1>)

                  ## Text
                  (^ (char (~~ (static ..text-delimiter))))
                  (let [offset/1 (!inc offset)]
                    (case ("lux text index" source-code (static ..text-delimiter) offset/1)
                      (#.Some end)
                      (let [content (!clip offset/1 end source-code)]
                        (<| (!guarantee-no-new-lines content)
                            (#error.Success [[(update@ #.column (n/+ (!n/- offset/1 end)) where)
                                              (!inc end)
                                              source-code]
                                             [where
                                              (#.Text content)]])))
                      
                      _
                      (ex.throw unrecognized-input where)))

                  ## Special code
                  (^ (char (~~ (static ..sigil))))
                  (let [offset/1 (!inc offset)]
                    (<| (!with-char source-code offset/1 char/1)
                        (case char/1
                          (^template [<char> <bit>]
                            (^ (char <char>))
                            (#error.Success [[(update@ #.column (|>> !leap-bit) where)
                                              (!leap-bit offset)
                                              source-code]
                                             [where (#.Bit <bit>)]]))
                          (["0" #0]
                           ["1" #1])

                          ## Single-line comment
                          (^ (char (~~ (static ..sigil))))
                          (case ("lux text index" source-code (static text.new-line) offset/1)
                            (#.Some end)
                            (recur [(!new-line where) (!inc end) source-code])
                            
                            _
                            <end>)

                          (^ (char (~~ (static ..name-separator))))
                          (!parse-short-name current-module <consume-2> where #.Identifier)

                          _
                          (cond (!name-char?|head char/1) ## Tag
                                (!parse-full-name offset <consume-2> where #.Tag)

                                ## else
                                <failure>))))

                  (^ (char (~~ (static ..name-separator))))
                  (!parse-short-name current-module <consume-1> where #.Identifier)

                  (^template [<sign>]
                    (^ (char <sign>))
                    (!parse-int offset where source-code))
                  ([(~~ (static ..positive-sign))]
                   [(~~ (static ..negative-sign))])

                  _
                  (cond (!digit? char/0) ## Natural number
                        (parse-nat offset <consume-1>)

                        ## Identifier
                        (!name-char?|head char/0)
                        (!parse-full-name offset <consume-1> where #.Identifier)
                        
                        ## else
                        <failure>))))))))
