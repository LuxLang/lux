(.module:
  [lux (#- Module Code)
   [control
    monad
    ["ex" exception (#+ Exception exception:)]]
   [data
    ["." error]
    [text
     format
     ["." encoding]]]
   [world
    ["." file (#+ File)]
    [binary (#+ Binary)]]]
  ["." // (#+ Context Module)
   [///
    ["." host]]])

(type: #export Extension Text)

(def: #export (file System<m> context module)
  (All [m] (-> (file.System m) Context Module File))
  (|> module
      (//.sanitize System<m>)
      (format context (:: System<m> separator))))

(def: host-extension
  Extension
  (`` (for {(~~ (static host.common-lisp)) ".cl"
            (~~ (static host.js))          ".js"
            (~~ (static host.jvm))         ".jvm"
            (~~ (static host.lua))         ".lua"
            (~~ (static host.php))         ".php"
            (~~ (static host.python))      ".py"
            (~~ (static host.r))           ".r"
            (~~ (static host.ruby))        ".rb"
            (~~ (static host.scheme))      ".scm"})))

(def: lux-extension Extension ".lux")

(def: full-extension Extension (format host-extension lux-extension))

(do-template [<name>]
  [(exception: #export (<name> {module Module})
     (ex.report ["Module" module]))]

  [module-not-found]
  [cannot-read-module]
  )

(def: (find-source System<m> contexts module extension)
  (All [fs]
    (-> (file.System fs) (List Context) Module Extension
        (fs (Maybe [Module File]))))
  (case contexts
    #.Nil
    (:: (:: System<m> &monad) wrap #.None)

    (#.Cons context contexts')
    (do (:: System<m> &monad)
      [#let [file (format (..file System<m> context module) extension)]
       ? (file.exists? System<m> file)]
      (if ?
        (wrap (#.Some [module file]))
        (find-source System<m> contexts' module extension)))))

(def: (try System<m> computations exception message)
  (All [m a e] (-> (file.System m) (List (m (Maybe a))) (Exception e) e (m a)))
  (case computations
    #.Nil
    (:: System<m> throw exception message)

    (#.Cons computation computations')
    (do (:: System<m> &monad)
      [outcome computation]
      (case outcome
        (#.Some output)
        (wrap output)

        #.None
        (try System<m> computations' exception message)))))

(type: #export Code Text)

(def: #export (read System<m> contexts module)
  (All [fs]
    (-> (file.System fs) (List Context) Module
        (fs [Text Code])))
  (let [find-source' (find-source System<m> contexts module)]
    (do (:: System<m> &monad)
      [[path file] (try System<m>
                        (list (find-source' ..full-extension)
                              (find-source' ..lux-extension))
                        ..module-not-found [module])
       binary (:: System<m> read file)]
      (case (encoding.from-utf8 binary)
        (#error.Success code)
        (wrap [path code])
        
        (#error.Error _)
        (:: System<m> throw ..cannot-read-module [module])))))
