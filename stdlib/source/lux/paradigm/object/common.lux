(;module:
  lux
  (lux (control monad
                ["p" parser "p/" Monad<Parser>])
       (data [text]
             text/format
             [product]
             (coll [list "L/" Functor<List> Fold<List>]
                   ["S" set]))
       [macro]
       (macro [code]
              ["s" syntax #+ syntax:]
              (syntax ["cs" common]
                      (common ["csr" reader]
                              ["csw" writer])))))

(type: #export Declaration
  [Text (List Text)])

(type: #export Alias Text)

(def: #export default-alias Alias "@")

(def: #export (var-set vars)
  (-> (List Text) (S;Set Text))
  (S;from-list text;Hash<Text> vars))

(def: #export (unique-type-vars parser)
  (-> (s;Syntax (List Text)) (s;Syntax (List Text)))
  (do p;Monad<Parser>
    [raw parser
     _ (p;assert "Cannot repeat the names of type variables/parameters."
                 (n.= (S;size (var-set raw))
                      (list;size raw)))]
    (wrap raw)))

(def: #export (safe-type-vars exclusions)
  (-> (S;Set Text) (s;Syntax Text))
  (do p;Monad<Parser>
    [raw s;local-symbol
     _ (p;assert "Cannot re-use names between method type-variables and interface type-parameters."
                 (|> raw (S;member? exclusions) not))]
    (wrap raw)))

(def: #export declaration
  (s;Syntax Declaration)
  (p;either (s;form (p;seq s;local-symbol
                           (unique-type-vars (p;some s;local-symbol))))
            (p;seq s;local-symbol
                   (p/wrap (list)))))

(def: #export alias
  (s;Syntax Alias)
  (|> s;local-symbol
      (p;after (s;this (' #as)))
      (p;default default-alias)))

(def: #export (ancestor-inputs ancestors)
  (-> (List Ident) (List Code))
  (if (list;empty? ancestors)
    (list)
    (|> (list;size ancestors)
        n.dec
        (list;n.range +0)
        (L/map (|>. %n (format "ancestor") code;local-symbol)))))
