(;module:
  lux
  (lux (control monad
                ["p" parser "p/" Monad<Parser>])
       (data [text]
             text/format
             [product]
             maybe
             (coll [list "L/" Functor<List> Fold<List> Monoid<List>]
                   [set #+ Set]))
       [macro #+ Monad<Lux> "Lux/" Monad<Lux>]
       (macro [code]
              ["s" syntax #+ syntax:]
              (syntax ["cs" common]
                      (common ["csr" reader]
                              ["csw" writer])))
       [type])
  (. ["./c" common]
     ["./n" notation]
     ["./i" inheritance]
     ["./m" method]))

(def: (type-to-code type)
  (-> Type (Lux Code))
  (case type
    (#;Host name params)
    (do Monad<Lux>
      [paramsC+ (mapM @ type-to-code params)]
      (wrap (` (;host (~ (code;symbol ["" name]))
                      (~@ paramsC+)))))

    #;Void
    (Lux/wrap (` (;|)))
    
    #;Unit
    (Lux/wrap (` (;&)))

    (^template [<tag> <macro> <flatten>]
      (<tag> _)
      (do Monad<Lux>
        [partsC+ (mapM @ type-to-code (<flatten> type))]
        (wrap (` (<macro> (~@ partsC+))))))
    ([#;Sum     ;| type;flatten-variant]
     [#;Product ;& type;flatten-tuple])

    (#;Function input output)
    (do Monad<Lux>
      [#let [[insT+ outT] (type;flatten-function type)]
       insC+ (mapM @ type-to-code insT+)
       outC (type-to-code outT)]
      (wrap (` (;-> (~@ insC+) (~ outC)))))

    (^template [<tag>]
      (<tag> idx)
      (Lux/wrap (` (<tag> (~ (code;nat idx))))))
    ([#;Bound]
     [#;Var]
     [#;Ex])

    (#;Apply param fun)
    (do Monad<Lux>
      [#let [[funcT argsT+] (type;flatten-application type)]
       funcC (type-to-code funcT)
       argsC+ (mapM @ type-to-code argsT+)]
      (wrap (` ((~ funcC) (~@ argsC+)))))

    (#;Named name unnamedT)
    (Lux/wrap (code;symbol name))

    _
    (macro;fail (format "Cannot convert type to code: " (type;to-text type)))))

(syntax: #export (interface: [export csr;export]
                   [(^@ decl [interface parameters]) ./c;declaration]
                   [?extends (p;opt ./i;extension)]
                   [alias ./c;alias]
                   [annotations (p;default cs;empty-annotations csr;annotations)]
                   [methods (p;many (./m;method (./c;var-set parameters)))])
  (macro;with-gensyms [g!self-class g!child g!ext]
    (do @
      [module macro;current-module-name
       [parent ancestors mappings] (: (Lux [Ident (List Ident) (List Code)])
                                      (case ?extends
                                        #;None
                                        (wrap [./i;no-parent (list) (list)])

                                        (#;Some [super mappings])
                                        (do @
                                          [[parent ancestors] (./i;interface super)]
                                          (wrap [parent (list& parent ancestors) mappings]))))
       #let [g!signature (code;local-symbol (./n;signature interface))
             g!interface (code;local-symbol interface)
             g!parameters (L/map code;local-symbol parameters)
             g!self-ref (if (list;empty? g!parameters)
                          (list g!interface)
                          (list))
             g!interface-def (if (./i;no-parent? parent)
                               (let [g!recur (` ((~ g!interface) (~@ g!parameters) (~ g!ext) (~ g!child)))]
                                 (` (Ex (~@ g!self-ref) [(~ g!ext) (~ g!child)]
                                      [((~ g!signature) (~@ g!parameters) (~ g!recur))
                                       (~ g!child)
                                       (~ g!ext)])))
                               (let [g!parent (code;symbol parent)
                                     g!ancestors (./c;ancestor-inputs ancestors)
                                     g!recur (` ((~ g!interface) (~@ g!parameters) (~ g!ext) (~@ g!ancestors) (~ g!child)))]
                                 (` (Ex (~@ g!self-ref) [(~ g!ext) (~@ g!ancestors) (~ g!child)]
                                      ((~ g!parent) (~@ mappings)
                                       [((~ g!signature) (~@ g!parameters) (~ g!recur))
                                        (~ g!child)
                                        (~ g!ext)]
                                       (~@ g!ancestors))))))]]
      (wrap (list& (` (sig: (~@ (csw;export export))
                        ((~ g!signature) (~@ g!parameters) (~ g!self-class))
                        (~@ (let [de-alias (code;replace (code;local-symbol alias) g!self-class)]
                              (L/map (|>. (update@ #./m;inputs (L/map de-alias))
                                          (update@ #./m;output de-alias)
                                          (./m;declaration g!self-class))
                                     methods)))))
                   
                   (` (type: (~@ (csw;export export)) ((~ g!interface) (~@ g!parameters))
                        (~ (|> annotations
                               (./i;with-interface parent [module interface])
                               csw;annotations))
                        (~ g!interface-def)))
                   
                   (./n;getter export interface g!parameters g!ext g!child ancestors)
                   (./n;setter export interface g!parameters g!ext g!child ancestors)
                   (./n;updater export interface g!parameters g!ext g!child ancestors)

                   (let [g!ancestors (./c;ancestor-inputs ancestors)
                         g!states (L/append g!ancestors (list g!child))
                         g!self-object (` ((~ g!interface) (~@ g!parameters) (~ g!ext) (~@ g!ancestors) (~ g!child)))
                         de-alias (code;replace (code;symbol ["" alias]) g!self-object)]
                     (L/map (|>. (update@ #./m;inputs (L/map de-alias))
                                 (update@ #./m;output de-alias)
                                 (./m;definition export decl g!self-object g!ext g!states))
                            methods))))
      )))

(syntax: #export (class: [export csr;export]
                   [[instance parameters] ./c;declaration]
                   [annotations (p;default cs;empty-annotations csr;annotations)]
                   [[interface interface-mappings] ./i;reference]
                   [super (p;opt ./i;inheritance)]
                   state-type
                   [impls (p;many s;any)])
  (macro;with-gensyms [g!init g!extension]
    (do @
      [module macro;current-module-name
       [interface _] (./i;interface interface)
       [parent ancestors parent-mappings] (: (Lux [Ident (List Ident) (List Code)])
                                             (case super
                                               (#;Some [super-class super-mappings])
                                               (do @
                                                 [[parent ancestors] (./i;class super-class)]
                                                 (wrap [parent ancestors super-mappings]))
                                               
                                               #;None
                                               (wrap [./i;no-parent (list) (list)])))
       g!inheritance (: (Lux (List Code))
                        (if (./i;no-parent? parent)
                          (wrap (list))
                          (do @
                            [newT (macro;find-def-type (product;both id ./n;new parent))
                             [depth rawT+] (./i;extract newT)
                             codeT+ (mapM @ type-to-code rawT+)]
                            (wrap (L/map (./i;specialize parent-mappings) codeT+)))))
       #let [g!parameters (L/map code;local-symbol parameters)
             
             g!state (code;local-symbol (./n;state instance))
             g!struct (code;local-symbol (./n;struct instance))
             g!class (code;local-symbol instance)

             g!signature (code;symbol (product;both id ./n;signature interface))
             g!interface (code;symbol interface)

             g!parent-structs (if (./i;no-parent? parent)
                                (list)
                                (L/map (|>. (product;both id ./n;struct) code;symbol) (list& parent ancestors)))]
       g!parent-inits (mapM @ (function [_] (macro;gensym "parent-init"))
                            g!parent-structs)
       #let [g!full-init (L/fold (function [[parent-struct parent-state] child]
                                   (` [(~ parent-struct) (~ parent-state) (~ child)]))
                                 (` [(~ g!struct) (~ g!init) []])
                                 (list;zip2 g!parent-structs g!parent-inits))
             g!new (code;local-symbol (./n;new instance))
             g!recur (` ((~ g!class) (~@ g!parameters) (~ g!extension)))
             g!rec (if (list;empty? g!parameters)
                     (list (' #rec))
                     (list))]]
      (wrap (list (` (type: (~@ (csw;export export))
                       ((~ g!state) (~@ g!parameters))
                       (~ state-type)))

                  (` (type: (~@ (csw;export export)) (~@ g!rec) ((~ g!class) (~@ g!parameters))
                       (~ (|> annotations
                              (./i;with-class interface parent [module instance])
                              csw;annotations))
                       (Ex [(~ g!extension)]
                         (~ (if (./i;no-parent? parent)
                              (` ((~ g!interface) (~@ interface-mappings)
                                  (~ g!extension)
                                  ((~ g!state) (~@ g!parameters))))
                              (let [g!parent (code;symbol parent)]
                                (` ((~ g!parent) (~@ parent-mappings)
                                    [((~ g!signature) (~@ interface-mappings) (~ g!recur))
                                     ((~ g!state) (~@ g!parameters))
                                     (~ g!extension)]))))))))

                  (` (struct: (~@ (csw;export export)) (~ g!struct)
                       (All [(~@ g!parameters) (~ g!extension)]
                         ((~ g!signature) (~@ interface-mappings)
                          ((~ g!interface) (~@ interface-mappings)
                           (~ g!extension)
                           (~@ g!inheritance)
                           ((~ g!state) (~@ g!parameters)))))
                       (~@ impls)))
                  
                  (` (def: (~@ (csw;export export)) ((~ g!new) (~@ g!parent-inits) (~ g!init))
                       (All [(~@ g!parameters)]
                         (-> (~@ g!inheritance)
                             ((~ g!state) (~@ g!parameters))
                             ((~ g!class) (~@ g!parameters))))
                       (~ g!full-init)))
                  ))
      )))
