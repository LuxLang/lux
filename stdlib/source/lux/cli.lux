(;module:
  lux
  (lux (control monad
                ["p" parser])
       (data (coll [list "L/" Monoid<List> Monad<List>])
             [text "T/" Monoid<Text>]
             text/format
             ["E" error]
             [sum])
       [io]
       [meta #+ with-gensyms]
       (meta [code]
             ["s" syntax #+ syntax: Syntax])))

## [Types]
(type: #export (CLI a)
  {#;doc "A command-line interface parser."}
  (p;Parser (List Text) a))

## [Combinators]
(def: #export (run inputs parser)
  (All [a] (-> (List Text) (CLI a) (E;Error a)))
  (case (p;run inputs parser)
    (#E;Success [remaining output])
    (case remaining
      #;Nil
      (#E;Success output)

      _
      (#E;Error (format "Remaining CLI inputs: " (text;join-with " " remaining))))

    (#E;Error error)
    (#E;Error error)))

(def: #export any
  {#;doc "Just returns the next input without applying any logic."}
  (CLI Text)
  (function [inputs]
    (case inputs
      (#;Cons arg inputs')
      (#E;Success [inputs' arg])
      
      _
      (#E;Error "Cannot parse empty arguments."))))

(def: #export (parse parser)
  {#;doc "Parses the next input with a parsing function."}
  (All [a] (-> (-> Text (E;Error a)) (CLI a)))
  (function [inputs]
    (case inputs
      (#;Cons arg inputs')
      (case (parser arg)
        (#E;Success value)
        (#E;Success [inputs' value])

        (#E;Error parser-error)
        (#E;Error parser-error))
      
      _
      (#E;Error "Cannot parse empty arguments."))))

(def: #export (option names)
  {#;doc "Checks that a given option (with multiple possible names) has a value."}
  (-> (List Text) (CLI Text))
  (function [inputs]
    (let [[pre post] (list;split-with (. ;not (list;member? text;Eq<Text> names)) inputs)]
      (case post
        #;Nil
        (#E;Error ($_ T/compose "Missing option (" (text;join-with " " names) ")"))

        (^ (list& _ value post'))
        (#E;Success [(L/compose pre post') value])

        _
        (#E;Error ($_ T/compose "Option lacks value (" (text;join-with " " names) ")"))
        ))))

(def: #export (flag names)
  {#;doc "Checks that a given flag (with multiple possible names) is set."}
  (-> (List Text) (CLI Bool))
  (function [inputs]
    (let [[pre post] (list;split-with (. ;not (list;member? text;Eq<Text> names)) inputs)]
      (case post
        #;Nil
        (#E;Success [pre false])

        (#;Cons _ post')
        (#E;Success [(L/compose pre post') true])))))

(def: #export end
  {#;doc "Ensures there are no more inputs."}
  (CLI Unit)
  (function [inputs]
    (case inputs
      #;Nil (#E;Success [inputs []])
      _     (#E;Error (T/compose "Unknown parameters: " (text;join-with " " inputs))))))

## [Syntax]
(type: Program-Args
  (#Raw Text)
  (#Parsed (List [Code Code])))

(def: program-args^
  (Syntax Program-Args)
  (p;alt s;local-symbol
         (s;form (p;some (p;either (do p;Monad<Parser>
                                     [name s;local-symbol]
                                     (wrap [(code;symbol ["" name]) (` any)]))
                                   (s;tuple (p;seq s;any s;any)))))))

(syntax: #export (program: [args program-args^] body)
  {#;doc (doc "Defines the entry-point to a program (similar to the \"main\" function/method in other programming languages)."
              "Can take a list of all the input parameters to the program, or can destructure them using CLI-option combinators from the lux/cli module."
              (program: all-args
                (do Monad<IO>
                  [foo init-program
                   bar (do-something all-args)]
                  (wrap [])))

              (program: (name)
                (io (log! (T/compose "Hello, " name))))

              (program: ([config config^])
                (do Monad<IO>
                  [data (init-program config)]
                  (do-something data))))}
  (case args
    (#Raw args)
    (wrap (list (` (;_lux_program (~ (code;symbol ["" args]))
                                  (do io;Monad<IO>
                                    []
                                    (~ body))))))
    
    (#Parsed args)
    (with-gensyms [g!args g!_ g!output g!message]
      (wrap (list (` (;_lux_program (~ g!args)
                                    (case ((: (;;CLI (io;IO Unit))
                                              (do ;;Monad<CLI>
                                                [(~@ (|> args
                                                         (L/map (function [[binding parser]]
                                                                  (list binding parser)))
                                                         L/join))
                                                 (~ g!_) ;;end]
                                                ((~' wrap) (do io;Monad<IO>
                                                             []
                                                             (~ body)))))
                                           (~ g!args))
                                      (#E;Success [(~ g!_) (~ g!output)])
                                      (~ g!output)

                                      (#E;Error (~ g!message))
                                      (error! (~ g!message))
                                      )))
                  )))
    ))
