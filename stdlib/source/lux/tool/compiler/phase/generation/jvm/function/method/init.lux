(.module:
  [lux (#- Type type)
   [abstract
    ["." monad]]
   [control
    [state (#+ State)]]
   [data
    [number
     ["n" nat]]
    [collection
     ["." list ("#@." monoid functor)]]]
   [target
    [jvm
     ["_" instruction (#+ Instruction)]
     ["." method (#+ Method)]
     [encoding
      ["." unsigned]]
     [constant
      [pool (#+ Pool)]]
     ["." type (#+ Type)
      ["." category (#+ Class Value)]]]]]
  ["." //
   ["#." implementation]
   ["/#" // #_
    ["#." abstract]
    [field
     [constant
      ["#." arity]]
     [variable
      ["#." foreign]
      ["#." partial]]]
    ["/#" // #_
     ["#." value]
     ["#." reference]
     [////
      [reference (#+ Register)]
      [analysis (#+ Environment)]
      ["." arity (#+ Arity)]]]]])

(def: #export name "<init>")

(def: (partials arity)
  (-> Arity (List (Type Value)))
  (list.repeat arity ////value.type))

(def: #export (type environment arity)
  (-> Environment Arity (Type category.Method))
  (type.method [(list@compose (///foreign.closure environment)
                              (if (arity.multiary? arity)
                                (list& ///arity.type (..partials arity))
                                (list)))
                type.void
                (list)]))

(def: super-type
  (Type category.Method)
  (type.method [(list ///arity.type) type.void (list)]))

(def: #export (super environment-size arity)
  (-> Nat Arity (Instruction Any))
  (let [arity-register (inc environment-size)]
    ($_ _.compose
        (if (arity.unary? arity)
          (_.bipush (unsigned.u1 0))
          (_.iload (unsigned.u1 arity-register)))
        (_.invokespecial ///abstract.class ..name ..super-type))))

(def: (store-all amount put offset)
  (-> Nat
      (-> Register (Instruction Any) (Instruction Any))
      (-> Register Register)
      (Instruction Any))
  (|> (list.indices amount)
      (list@map (function (_ register)
                  (put register
                       (_.aload (unsigned.u1 (offset register))))))
      (monad.seq _.monad)))

(def: #export (method class environment arity)
  (-> (Type Class) Environment Arity (State Pool Method))
  (let [environment-size (list.size environment)
        offset-foreign (: (-> Register Register)
                          (n.+ 1))
        offset-arity (: (-> Register Register)
                        (|>> offset-foreign (n.+ environment-size)))
        offset-partial (: (-> Register Register)
                          (|>> offset-arity (n.+ 1)))]
    (method.method //.modifier ..name
                   (..type environment arity)
                   (list)
                   ($_ _.compose
                       ////reference.this
                       (..super environment-size arity)
                       (store-all environment-size (///foreign.put class) offset-foreign)
                       (store-all (dec arity) (///partial.put class) offset-partial)
                       _.return))))
