(.module:
  [lux (#- Type Definition case)
   [data
    [binary (#+ Binary)]
    [number
     ["." i32]
     ["." i64]
     ["n" nat]]]
   [target
    [jvm
     ["_" instruction (#+ Label Instruction)]
     ["." constant]
     ["." type (#+ Type)
      ["." category (#+ Method)]]]]]
  ["." // #_
   ["#." value]
   ["#." function #_
    ["#" abstract]]
   ["/#" //
    ["/#" //
     [//
      [reference (#+ Register)]
      ["." synthesis]]]]]
  )

(type: #export Byte-Code Binary)

(type: #export Definition [Text Byte-Code])

(type: #export Anchor [Label Register])

(template [<name> <base>]
  [(type: #export <name>
     (<base> Anchor (Instruction Any) Definition))]

  [Operation ///.Operation]
  [Phase ///.Phase]
  [Handler ///.Handler]
  [Bundle ///.Bundle]
  )

(type: #export (Generator i)
  (-> Phase i (Operation (Instruction Any))))

(def: #export class (type.class "LuxRuntime" (list)))

(def: $Text (type.class "java.lang.String" (list)))

(def: #export $Tag type.int)
(def: #export $Flag //value.type)
(def: #export $Variant (type.array //value.type))

(def: #export $Offset type.int)
(def: #export $Tuple (type.array //value.type))

(def: #export $Stack (type.array //value.type))

(def: procedure
  (-> Text (Type Method) (Instruction Any))
  (_.invokestatic ..class))

(def: failure-type
  (type.method [(list) type.void (list)]))

(def: #export apply-failure
  (..procedure "apply_failure" ..failure-type))

(def: #export pm-failure
  (..procedure "pm_failure" ..failure-type))

(def: push-name
  "push")

(def: push-type
  (type.method [(list ..$Stack //value.type) ..$Stack (list)]))

(def: #export push
  (..procedure ..push-name ..push-type))

(def: case-name
  "case")

(def: case-type
  (type.method [(list ..$Variant ..$Tag ..$Flag) //value.type (list)]))

(def: #export case
  (..procedure ..case-name ..case-type))

(def: projection-type
  (type.method [(list ..$Tuple $Offset) //value.type (list)]))

(def: #export left-projection
  (..procedure "left" ..projection-type))

(def: #export right-projection
  (..procedure "right" ..projection-type))

(def: try-name
  "try")

(def: try-type
  (type.method [(list //function.class) ..$Variant (list)]))

(def: #export try
  (_.invokestatic ..class ..try-name ..try-type))

(def: #export decode-frac
  (..procedure "decode_frac" (type.method [(list ..$Text) ..$Variant (list)])))

(def: #export variant
  (..procedure "variant" (type.method [(list ..$Tag ..$Flag //value.type) ..$Variant (list)])))

(def: ldc/integer
  (-> (I64 Any) (Instruction Any))
  (|>> .i64 i32.i32 constant.integer _.ldc/integer))

(def: #export left-flag _.aconst-null)
(def: #export right-flag (_.ldc/string ""))

(def: #export left-injection
  (Instruction Any)
  ($_ _.compose
      (..ldc/integer +0)
      ..left-flag
      _.dup2-x1
      _.pop2
      ..variant))

(def: #export right-injection
  (Instruction Any)
  ($_ _.compose
      (..ldc/integer +1)
      ..right-flag
      _.dup2-x1
      _.pop2
      ..variant))

(def: #export some-injection right-injection)

(def: #export none-injection
  (Instruction Any)
  ($_ _.compose
      (..ldc/integer +0)
      _.aconst-null
      (_.ldc/string synthesis.unit)
      ..variant))

(def: #export forge-label
  (Operation Label)
  (let [shift (n./ 2 i64.width)]
    ## This shift is done to avoid the possibility of forged labels
    ## to be in the range of the labels that are generated automatically
    ## during the evaluation of Instruction expressions.
    (:: ////.monad map (i64.left-shift shift) ///.next)))
