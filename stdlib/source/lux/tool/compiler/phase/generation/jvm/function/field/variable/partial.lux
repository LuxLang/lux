(.module:
  [lux (#- Type)
   [abstract
    ["." monad]]
   [control
    [state (#+ State)]]
   [data
    [number
     ["n" nat]]
    [collection
     ["." list ("#@." functor)]
     ["." row]]]
   [target
    [jvm
     ["." field (#+ Field)]
     ["_" instruction (#+ Label Instruction) ("#@." monad)]
     [type (#+ Type)
      [category (#+ Class)]]
     [constant
      [pool (#+ Pool)]]]]]
  ["." / #_
   ["#." count]
   ["/#" //
    ["/#" // #_
     [constant
      ["#." arity]]
     ["//#" /// #_
      ["#." reference]
      [////
       [reference (#+ Register)]
       ["." arity (#+ Arity)]]]]]])

(def: #export (initial amount)
  (-> Nat (Instruction Any))
  ($_ _.compose
      (|> _.aconst-null
          (list.repeat amount)
          (monad.seq _.monad))
      (_@wrap [])))

(def: #export (get class register)
  (-> (Type Class) Register (Instruction Any))
  (//.get class (/////reference.partial-name register)))

(def: #export (put class register value)
  (-> (Type Class) Register (Instruction Any) (Instruction Any))
  (//.put /////reference.partial-name class register value))

(def: #export variables
  (-> Arity (List (State Pool Field)))
  (|>> (n.- ///arity.minimum) (//.variables /////reference.partial-name)))

(def: #export (new arity)
  (-> Arity (Instruction Any))
  (if (arity.multiary? arity)
    ($_ _.compose
        /count.initial
        (initial (n.- ///arity.minimum arity)))
    (_@wrap [])))
