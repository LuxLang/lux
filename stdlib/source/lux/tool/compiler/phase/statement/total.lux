(.module:
  [lux #*
   [control
    ["." monad (#+ do)]
    ["ex" exception (#+ exception:)]]
   [data
    [text
     format]]
   ["." macro]]
  ["." // (#+ Phase)
   ["/." //
    ["." analysis
     ["." expression]
     ["." type]
     ["///." macro (#+ Expander)]]
    ["." extension]]])

(exception: #export (not-a-statement {code Code})
  (ex.report ["Statement" (%code code)]))

(exception: #export (not-a-macro-call {code Code})
  (ex.report ["Code" (%code code)]))

(exception: #export (macro-was-not-found {name Name})
  (ex.report ["Name" (%name name)]))

(def: #export (phase expander)
  (-> Expander Phase)
  (let [analyze (expression.phase expander)]
    (function (compile code)
      (case code
        (^ [_ (#.Form (list& [_ (#.Text name)] inputs))])
        (extension.apply compile [name inputs])

        (^ [_ (#.Form (list& macro inputs))])
        (do ///.monad
          [expansion (//.lift-analysis
                      (do @
                        [macroA (type.with-type Macro
                                  (analyze macro))]
                        (case macroA
                          (^ (analysis.constant macro-name))
                          (do @
                            [?macro (extension.lift (macro.find-macro macro-name))
                             macro (case ?macro
                                     (#.Some macro)
                                     (wrap macro)
                                     
                                     #.None
                                     (///.throw macro-was-not-found macro-name))]
                            (extension.lift (///macro.expand expander macro-name macro inputs)))
                          
                          _
                          (///.throw not-a-macro-call code))))]
          (monad.map @ compile expansion))

        _
        (///.throw not-a-statement code)))))
