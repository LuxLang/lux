(.module:
  [lux (#- case let if)
   [control
    [monad (#+ do)]
    ["ex" exception (#+ exception:)]]
   [data
    ["." number]
    ["." text
     format]
    [collection
     ["." list ("#/." functor fold)]]]
   [host
    ["_" scheme (#+ Expression Computation Var)]]]
  [//
   ["." runtime (#+ Operation Phase)]
   ["//." primitive]
   ["." reference]
   [//
    ["common-." reference]
    ["//." // ("#/." monad)
     ["." synthesis (#+ Synthesis Path)]
     [//
      [reference (#+ Register)]]]]])

(def: #export register
  (common-reference.local _.var))

(def: #export (let translate [valueS register bodyS])
  (-> Phase [Synthesis Register Synthesis]
      (Operation Computation))
  (do ////.monad
    [valueO (translate valueS)
     bodyO (translate bodyS)]
    (wrap (_.let (list [(..register register) valueO])
            bodyO))))

(def: #export (record-get translate valueS pathP)
  (-> Phase Synthesis (List [Nat Bit])
      (Operation Expression))
  (do ////.monad
    [valueO (translate valueS)]
    (wrap (list/fold (function (_ [idx tail?] source)
                       (.let [method (.if tail?
                                       runtime.product//right
                                       runtime.product//left)]
                         (method source (_.int (.int idx)))))
                     valueO
                     pathP))))

(def: #export (if translate [testS thenS elseS])
  (-> Phase [Synthesis Synthesis Synthesis]
      (Operation Computation))
  (do ////.monad
    [testO (translate testS)
     thenO (translate thenS)
     elseO (translate elseS)]
    (wrap (_.if testO thenO elseO))))

(def: @savepoint (_.var "lux_pm_cursor_savepoint"))
(def: @cursor (_.var "lux_pm_cursor"))
(def: @temp (_.var "lux_pm_temp"))
(def: @alt-error (_.var "alt_error"))

(def: (push! value var)
  (-> Expression Var Computation)
  (_.set! var (_.cons/2 value var)))

(def: (push-cursor! value)
  (-> Expression Computation)
  (push! value @cursor))

(def: (pop! var)
  (-> Var Computation)
  (_.set! var var))

(def: save-cursor!
  Computation
  (push! @cursor @savepoint))

(def: restore-cursor!
  Computation
  (_.set! @cursor (_.car/1 @savepoint)))

(def: cursor-top
  Computation
  (_.car/1 @cursor))

(def: pop-cursor!
  Computation
  (pop! @cursor))

(def: pm-error (_.string "PM-ERROR"))

(def: fail-pm! (_.raise/1 pm-error))

(exception: #export unrecognized-path)

(def: (pm-catch handler)
  (-> Expression Computation)
  (_.lambda [(list @alt-error) #.None]
       (_.if (|> @alt-error (_.eqv?/2 pm-error))
         handler
         (_.raise/1 @alt-error))))

(def: (pattern-matching' translate pathP)
  (-> Phase Path (Operation Expression))
  (.case pathP
    (^ (synthesis.path/then bodyS))
    (translate bodyS)

    #synthesis.Pop
    (/////wrap pop-cursor!)

    (#synthesis.Bind register)
    (/////wrap (_.define (..register register) [(list) #.None]
                         cursor-top))

    (^template [<tag> <format> <=>]
      (^ (<tag> value))
      (/////wrap (_.when (|> value <format> (<=> cursor-top) _.not/1)
                         fail-pm!)))
    ([synthesis.path/bit  //primitive.bit           _.eqv?/2]
     [synthesis.path/i64  (<| //primitive.i64 .int) _.=/2]
     [synthesis.path/f64  //primitive.f64           _.=/2]
     [synthesis.path/text //primitive.text          _.eqv?/2])

    (^template [<pm> <flag> <prep>]
      (^ (<pm> idx))
      (/////wrap (_.let (list [@temp (|> idx <prep> .int _.int (runtime.sum//get cursor-top <flag>))])
                   (_.if (_.null?/1 @temp)
                     fail-pm!
                     (push-cursor! @temp)))))
    ([synthesis.side/left  _.nil         (<|)]
     [synthesis.side/right (_.string "") inc])

    (^template [<pm> <getter> <prep>]
      (^ (<pm> idx))
      (/////wrap (|> idx <prep> .int _.int (<getter> cursor-top) push-cursor!)))
    ([synthesis.member/left  runtime.product//left  (<|)]
     [synthesis.member/right runtime.product//right inc])

    (^template [<tag> <computation>]
      (^ (<tag> leftP rightP))
      (do ////.monad
        [leftO (pattern-matching' translate leftP)
         rightO (pattern-matching' translate rightP)]
        (wrap <computation>)))
    ([synthesis.path/seq (_.begin (list leftO
                                        rightO))]
     [synthesis.path/alt (_.with-exception-handler
                           (pm-catch (_.begin (list restore-cursor!
                                                    rightO)))
                           (_.lambda [(list) #.None]
                                (_.begin (list save-cursor!
                                               leftO))))])
    
    _
    (////.throw unrecognized-path [])))

(def: (pattern-matching translate pathP)
  (-> Phase Path (Operation Computation))
  (do ////.monad
    [pattern-matching! (pattern-matching' translate pathP)]
    (wrap (_.with-exception-handler
            (pm-catch (_.raise/1 (_.string "Invalid expression for pattern-matching.")))
            (_.lambda [(list) #.None]
                 pattern-matching!)))))

(def: #export (case translate [valueS pathP])
  (-> Phase [Synthesis Path] (Operation Computation))
  (do ////.monad
    [valueO (translate valueS)]
    (<| (:: @ map (_.let (list [@cursor (_.list/* (list valueO))]
                               [@savepoint (_.list/* (list))])))
        (pattern-matching translate pathP))))
