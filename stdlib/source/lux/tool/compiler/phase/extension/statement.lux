(.module:
  [lux #*
   [control
    [monad (#+ do)]
    pipe]
   [data
    [text
     format]
    [collection
     ["." list ("#/." functor)]
     ["." dictionary]]]
   ["." macro]
   [type (#+ :share :by-example)
    ["." check]]]
  ["." //
   ["#." bundle]
   ["#/" //
    [analysis
     ["." module]
     ["." type]]
    ["#." generation]
    ["#/" // #_
     ["#." analysis]
     ["#." synthesis (#+ Synthesis)]
     ["#." statement (#+ Operation Handler Bundle)]]]])

## TODO: Inline "evaluate!'" into "evaluate!" ASAP
(def: (evaluate!' generate code//type codeS)
  (All [anchor expression statement]
    (-> (///generation.Phase anchor expression statement)
        Type
        Synthesis
        (Operation anchor expression statement [Type expression Any])))
  (////statement.lift-generation
   (///generation.with-buffer
     (do ///.monad
       [codeT (generate codeS)
        count ///generation.next
        codeV (///generation.evaluate! (format "evaluate" (%n count)) codeT)]
       (wrap [code//type codeT codeV])))))

(def: (evaluate! type codeC)
  (All [anchor expression statement]
    (-> Type Code (Operation anchor expression statement [Type expression Any])))
  (do ///.monad
    [state (//.lift ///.get-state)
     #let [analyse (get@ [#////statement.analysis #////statement.phase] state)
           synthesize (get@ [#////statement.synthesis #////statement.phase] state)
           generate (get@ [#////statement.generation #////statement.phase] state)]
     [_ code//type codeA] (////statement.lift-analysis
                           (////analysis.with-scope
                             (type.with-fresh-env
                               (type.with-type type
                                 (do @
                                   [codeA (analyse codeC)]
                                   (wrap [type codeA]))))))
     codeS (////statement.lift-synthesis
            (synthesize codeA))]
    (evaluate!' generate code//type codeS)))

## TODO: Inline "definition'" into "definition" ASAP
(def: (definition' generate name code//type codeS)
  (All [anchor expression statement]
    (-> (///generation.Phase anchor expression statement)
        Name
        Type
        Synthesis
        (Operation anchor expression statement [Type expression Text Any])))
  (////statement.lift-generation
   (///generation.with-buffer
     (do ///.monad
       [codeT (generate codeS)
        codeN+V (///generation.define! name codeT)]
       (wrap [code//type codeT codeN+V])))))

(def: (definition name ?type codeC)
  (All [anchor expression statement]
    (-> Name (Maybe Type) Code
        (Operation anchor expression statement [Type expression Text Any])))
  (do ///.monad
    [state (//.lift ///.get-state)
     #let [analyse (get@ [#////statement.analysis #////statement.phase] state)
           synthesize (get@ [#////statement.synthesis #////statement.phase] state)
           generate (get@ [#////statement.generation #////statement.phase] state)]
     [_ code//type codeA] (////statement.lift-analysis
                           (////analysis.with-scope
                             (type.with-fresh-env
                               (case ?type
                                 (#.Some type)
                                 (type.with-type type
                                   (do @
                                     [codeA (analyse codeC)]
                                     (wrap [type codeA])))

                                 #.None
                                 (do @
                                   [[code//type codeA] (type.with-inference (analyse codeC))
                                    code//type (type.with-env
                                                 (check.clean code//type))]
                                   (wrap [code//type codeA]))))))
     codeS (////statement.lift-synthesis
            (synthesize codeA))]
    (definition' generate name code//type codeS)))

(def: (define short-name type annotations value)
  (All [anchor expression statement]
    (-> Text Type Code Any
        (Operation anchor expression statement Any)))
  (////statement.lift-analysis
   (do ///.monad
     [_ (module.define short-name [type annotations value])]
     (if (macro.type? annotations)
       (case (macro.declared-tags annotations)
         #.Nil
         (wrap [])

         tags
         (module.declare-tags tags (macro.export? annotations) (:coerce Type value)))
       (wrap [])))))

(def: lux::def
  Handler
  (function (_ extension-name phase inputsC+)
    (case inputsC+
      (^ (list [_ (#.Identifier ["" short-name])] valueC annotationsC))
      (do ///.monad
        [current-module (////statement.lift-analysis
                         (//.lift macro.current-module-name))
         #let [full-name [current-module short-name]]
         [_ annotationsT annotationsV] (evaluate! Code annotationsC)
         #let [annotationsV (:coerce Code annotationsV)]
         [value//type valueT valueN valueV] (..definition full-name
                                                          (if (macro.type? annotationsV)
                                                            (#.Some Type)
                                                            #.None)
                                                          valueC)
         _ (..define short-name value//type annotationsV valueV)
         #let [_ (log! (format "Definition " (%name full-name)))]]
        (////statement.lift-generation
         (///generation.learn full-name valueN)))

      _
      (///.throw //.invalid-syntax [extension-name]))))

(def: (alias! alias def-name)
  (-> Text Name (////analysis.Operation Any))
  (do ///.monad
    [definition (//.lift (macro.find-def def-name))]
    (module.define alias definition)))

(def: def::module
  Handler
  (function (_ extension-name phase inputsC+)
    (case inputsC+
      (^ (list annotationsC))
      (do ///.monad
        [[_ annotationsT annotationsV] (evaluate! Code annotationsC)
         _ (////statement.lift-analysis
            (module.set-annotations (:coerce Code annotationsV)))]
        (wrap []))

      _
      (///.throw //.invalid-syntax [extension-name]))))

(def: def::alias
  Handler
  (function (_ extension-name phase inputsC+)
    (case inputsC+
      (^ (list [_ (#.Identifier ["" alias])] [_ (#.Identifier def-name)]))
      (//.lift
       (///.sub [(get@ [#////statement.analysis #////statement.state])
                 (set@ [#////statement.analysis #////statement.state])]
                (alias! alias def-name)))

      _
      (///.throw //.invalid-syntax [extension-name]))))

(do-template [<mame> <type> <scope>]
  [(def: <mame>
     (All [anchor expression statement]
       (Handler anchor expression statement))
     (function (handler extension-name phase inputsC+)
       (case inputsC+
         (^ (list [_ (#.Text name)] valueC))
         (do ///.monad
           [[_ handlerT handlerV] (evaluate! (:by-example [anchor expression statement]
                                                          {(Handler anchor expression statement)
                                                           handler}
                                                          <type>)
                                             valueC)]
           (<| <scope>
               (//.install name)
               (:share [anchor expression statement]
                       {(Handler anchor expression statement)
                        handler}
                       {<type>
                        (:assume handlerV)})))

         _
         (///.throw //.invalid-syntax [extension-name]))))]

  [def::analysis   ////analysis.Handler                                 ////statement.lift-analysis]
  [def::synthesis  ////synthesis.Handler                                ////statement.lift-synthesis]
  [def::generation (///generation.Handler anchor expression statement) ////statement.lift-generation]
  [def::statement  (////statement.Handler anchor expression statement)  (<|)]
  )

(def: bundle::def
  Bundle
  (<| (//bundle.prefix "def")
      (|> //bundle.empty
          (dictionary.put "module"      def::module)
          (dictionary.put "alias"       def::alias)
          (dictionary.put "analysis"    def::analysis)
          (dictionary.put "synthesis"   def::synthesis)
          (dictionary.put "generation" def::generation)
          (dictionary.put "statement"   def::statement)
          )))

(def: #export bundle
  Bundle
  (<| (//bundle.prefix "lux")
      (|> //bundle.empty
          (dictionary.put "def" lux::def)
          (dictionary.merge ..bundle::def))))
