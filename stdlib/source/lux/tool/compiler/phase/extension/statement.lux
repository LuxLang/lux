(.module:
  [lux #*
   [io (#+ IO)]
   [control
    ["." monad (#+ do)]
    ["p" parser]]
   [data
    ["." error]
    [text
     format]
    [collection
     ["." list ("#;." functor)]
     ["." dictionary]]]
   ["." macro
    ["." code]
    ["s" syntax (#+ Syntax)]]
   [type (#+ :share :by-example)
    ["." check]]]
  ["." //
   ["#." bundle]
   ["#/" //
    ["#." generation]
    [analysis
     ["." module]
     ["." type]]
    ["#/" // #_
     ["#." analysis]
     ["#." synthesis (#+ Synthesis)]
     ["#." statement (#+ Import Operation Handler Bundle)]]]])

## TODO: Inline "evaluate!'" into "evaluate!" ASAP
(def: (evaluate!' generate code//type codeS)
  (All [anchor expression statement]
    (-> (///generation.Phase anchor expression statement)
        Type
        Synthesis
        (Operation anchor expression statement [Type expression Any])))
  (////statement.lift-generation
   (///generation.with-buffer
     (do ///.monad
       [codeT (generate codeS)
        count ///generation.next
        codeV (///generation.evaluate! (format "evaluate" (%n count)) codeT)]
       (wrap [code//type codeT codeV])))))

(def: (evaluate! type codeC)
  (All [anchor expression statement]
    (-> Type Code (Operation anchor expression statement [Type expression Any])))
  (do ///.monad
    [state (//.lift ///.get-state)
     #let [analyse (get@ [#////statement.analysis #////statement.phase] state)
           synthesize (get@ [#////statement.synthesis #////statement.phase] state)
           generate (get@ [#////statement.generation #////statement.phase] state)]
     [_ code//type codeA] (////statement.lift-analysis
                           (////analysis.with-scope
                             (type.with-fresh-env
                               (type.with-type type
                                 (do @
                                   [codeA (analyse codeC)]
                                   (wrap [type codeA]))))))
     codeS (////statement.lift-synthesis
            (synthesize codeA))]
    (evaluate!' generate code//type codeS)))

## TODO: Inline "definition'" into "definition" ASAP
(def: (definition' generate name code//type codeS)
  (All [anchor expression statement]
    (-> (///generation.Phase anchor expression statement)
        Name
        Type
        Synthesis
        (Operation anchor expression statement [Type expression Text Any])))
  (////statement.lift-generation
   (///generation.with-buffer
     (do ///.monad
       [codeT (generate codeS)
        codeN+V (///generation.define! name codeT)]
       (wrap [code//type codeT codeN+V])))))

(def: (definition name ?type codeC)
  (All [anchor expression statement]
    (-> Name (Maybe Type) Code
        (Operation anchor expression statement [Type expression Text Any])))
  (do ///.monad
    [state (//.lift ///.get-state)
     #let [analyse (get@ [#////statement.analysis #////statement.phase] state)
           synthesize (get@ [#////statement.synthesis #////statement.phase] state)
           generate (get@ [#////statement.generation #////statement.phase] state)]
     [_ code//type codeA] (////statement.lift-analysis
                           (////analysis.with-scope
                             (type.with-fresh-env
                               (case ?type
                                 (#.Some type)
                                 (type.with-type type
                                   (do @
                                     [codeA (analyse codeC)]
                                     (wrap [type codeA])))

                                 #.None
                                 (do @
                                   [[code//type codeA] (type.with-inference (analyse codeC))
                                    code//type (type.with-env
                                                 (check.clean code//type))]
                                   (wrap [code//type codeA]))))))
     codeS (////statement.lift-synthesis
            (synthesize codeA))]
    (definition' generate name code//type codeS)))

(def: (define short-name type annotations value)
  (All [anchor expression statement]
    (-> Text Type Code Any
        (Operation anchor expression statement Any)))
  (////statement.lift-analysis
   (do ///.monad
     [_ (module.define short-name [type annotations value])]
     (if (macro.type? annotations)
       (case (macro.declared-tags annotations)
         #.Nil
         (wrap [])

         tags
         (module.declare-tags tags (macro.export? annotations) (:coerce Type value)))
       (wrap [])))))

(def: lux::def
  Handler
  (function (_ extension-name phase inputsC+)
    (case inputsC+
      (^ (list [_ (#.Identifier ["" short-name])] valueC annotationsC))
      (do ///.monad
        [current-module (////statement.lift-analysis
                         (//.lift macro.current-module-name))
         #let [full-name [current-module short-name]]
         [_ annotationsT annotationsV] (evaluate! Code annotationsC)
         #let [annotationsV (:coerce Code annotationsV)]
         [value//type valueT valueN valueV] (..definition full-name
                                                          (if (macro.type? annotationsV)
                                                            (#.Some Type)
                                                            #.None)
                                                          valueC)
         _ (..define short-name value//type annotationsV valueV)
         #let [_ (log! (format "Definition " (%name full-name)))]
         _ (////statement.lift-generation
            (///generation.learn full-name valueN))]
        (wrap ////statement.no-requirements))

      _
      (///.throw //.invalid-syntax [extension-name]))))

(def: imports
  (Syntax (List Import))
  (|> (s.tuple (p.and s.text s.text))
      p.some
      s.tuple
      (p.after (s.this (' #.imports)))
      s.record))

(def: def::module
  Handler
  (function (_ extension-name phase inputsC+)
    (case inputsC+
      (^ (list annotationsC))
      (do ///.monad
        [[_ annotationsT annotationsV] (evaluate! Code annotationsC)
         imports (case (s.run (list (:coerce Code annotationsV))
                              ..imports)
                   (#error.Success imports)
                   (wrap imports)
                   
                   (#error.Failure error)
                   (///.throw //.invalid-syntax [extension-name]))
         _ (////statement.lift-analysis
            (do @
              [_ (monad.map @ (function (_ [module alias])
                                (do @
                                  [_ (module.import module)]
                                  (case alias
                                    "" (wrap [])
                                    _ (module.alias alias module))))
                            imports)]
              (module.set-annotations (:coerce Code annotationsV))))]
        (wrap {#////statement.imports imports
               #////statement.referrals (list)}))

      _
      (///.throw //.invalid-syntax [extension-name]))))

## TODO: Reify aliasing as a feature of the compiler, instead of
## manifesting it implicitly through definition annotations.
(def: (alias-annotations original)
  (-> Name Code)
  (` {#.alias (~ (code.identifier original))}))

(def: (define-alias alias original)
  (-> Text Name (////analysis.Operation Any))
  (do ///.monad
    [[original-type original-annotations original-value]
     (//.lift (macro.find-def original))]
    (module.define alias [original-type
                          (alias-annotations original)
                          original-value])))

(def: def::alias
  Handler
  (function (_ extension-name phase inputsC+)
    (case inputsC+
      (^ (list [_ (#.Identifier ["" alias])] [_ (#.Identifier def-name)]))
      (do ///.monad
        [_ (//.lift
            (///.sub [(get@ [#////statement.analysis #////statement.state])
                      (set@ [#////statement.analysis #////statement.state])]
                     (define-alias alias def-name)))]
        (wrap ////statement.no-requirements))

      _
      (///.throw //.invalid-syntax [extension-name]))))

(do-template [<mame> <type> <scope>]
  [(def: <mame>
     (All [anchor expression statement]
       (Handler anchor expression statement))
     (function (handler extension-name phase inputsC+)
       (case inputsC+
         (^ (list [_ (#.Text name)] valueC))
         (do ///.monad
           [[_ handlerT handlerV] (evaluate! (:by-example [anchor expression statement]
                                                          {(Handler anchor expression statement)
                                                           handler}
                                                          <type>)
                                             valueC)
            _ (<| <scope>
                  (//.install name)
                  (:share [anchor expression statement]
                          {(Handler anchor expression statement)
                           handler}
                          {<type>
                           (:assume handlerV)}))]
           (wrap ////statement.no-requirements))

         _
         (///.throw //.invalid-syntax [extension-name]))))]

  [def::analysis   ////analysis.Handler                                ////statement.lift-analysis]
  [def::synthesis  ////synthesis.Handler                               ////statement.lift-synthesis]
  [def::generation (///generation.Handler anchor expression statement) ////statement.lift-generation]
  [def::statement  (////statement.Handler anchor expression statement) (<|)]
  )

## TODO; Both "prepare-program" and "define-program" exist only
## because the old compiler couldn"t handle a fully-inlined definition
## for "def::program". Inline them ASAP.
(def: (prepare-program analyse synthesize programC)
  (All [anchor expression statement output]
    (-> ////analysis.Phase
        ////synthesis.Phase
        Code
        (Operation anchor expression statement Synthesis)))
  (do ///.monad
    [[_ programA] (////statement.lift-analysis
                   (////analysis.with-scope
                     (type.with-fresh-env
                       (type.with-type (type (-> (List Text) (IO Any)))
                         (analyse programC)))))]
    (////statement.lift-synthesis
     (synthesize programA))))

(def: (define-program generate program programS)
  (All [anchor expression statement output]
    (-> (///generation.Phase anchor expression statement)
        (-> expression statement)
        Synthesis
        (///generation.Operation anchor expression statement Any)))
  (///generation.with-buffer
    (do ///.monad
      [programG (generate programS)]
      (///generation.save! ["" ""] (program programG)))))

(def: (def::program program)
  (All [anchor expression statement]
    (-> (-> expression statement) (Handler anchor expression statement)))
  (function (handler extension-name phase inputsC+)
    (case inputsC+
      (^ (list programC))
      (do ///.monad
        [state (//.lift ///.get-state)
         #let [analyse (get@ [#////statement.analysis #////statement.phase] state)
               synthesize (get@ [#////statement.synthesis #////statement.phase] state)
               generate (get@ [#////statement.generation #////statement.phase] state)]
         programS (prepare-program analyse synthesize programC)
         _ (////statement.lift-generation
            (define-program generate program programS))]
        (wrap ////statement.no-requirements))

      _
      (///.throw //.invalid-syntax [extension-name]))))

(def: (bundle::def program)
  (All [anchor expression statement]
    (-> (-> expression statement) (Bundle anchor expression statement)))
  (<| (//bundle.prefix "def")
      (|> //bundle.empty
          (dictionary.put "module"     def::module)
          (dictionary.put "alias"      def::alias)
          (dictionary.put "analysis"   def::analysis)
          (dictionary.put "synthesis"  def::synthesis)
          (dictionary.put "generation" def::generation)
          (dictionary.put "statement"  def::statement)
          (dictionary.put "program"    (def::program program))
          )))

(def: #export (bundle program)
  (All [anchor expression statement]
    (-> (-> expression statement) (Bundle anchor expression statement)))
  (<| (//bundle.prefix "lux")
      (|> //bundle.empty
          (dictionary.put "def" lux::def)
          (dictionary.merge (..bundle::def program)))))
