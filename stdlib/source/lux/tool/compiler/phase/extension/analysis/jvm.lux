(.module:
  [lux (#- Type primitive type char int)
   ["." host (#+ import:)]
   ["." macro]
   [abstract
    ["." monad (#+ do)]]
   [control
    ["." try (#+ Try) ("#@." monad)]
    ["<>" parser
     ["<c>" code (#+ Parser)]
     ["<t>" text]]
    ["." exception (#+ exception:)]
    pipe]
   [data
    ["." maybe]
    ["." product]
    [number
     ["n" nat]]
    ["." text ("#@." equivalence)
     ["%" format (#+ format)]]
    [collection
     ["." list ("#@." fold monad monoid)]
     ["." array (#+ Array)]
     ["." dictionary (#+ Dictionary)]]]
   ["." type
    ["." check (#+ Check) ("#@." monad)]]
   [target
    ["." jvm #_
     [".!" reflection]
     ["#" type (#+ Var Bound Primitive Generic Class Type Argument Return Method Typed)
      ("method@." method-equivalence)
      ["." box]
      ["." reflection]
      [".T" lux (#+ Mapping)]]]]]
  ["." // #_
   ["#." lux (#+ custom)]
   ["/#" //
    ["#." bundle]
    ["/#" // ("#@." monad)
     [analysis
      [".A" type]
      [".A" inference]
      ["." scope]]
     ["/#" // #_
      [reference (#+)]
      ["#." analysis (#+ Analysis Operation Phase Handler Bundle)]
      ["#." synthesis]]]]])

(def: inheritance-relationship-type-name "_jvm_inheritance")
(def: #export (inheritance-relationship-type class super-class super-interfaces)
  (-> .Type .Type (List .Type) .Type)
  (#.Primitive ..inheritance-relationship-type-name
               (list& class super-class super-interfaces)))

## TODO: Get rid of this template block and use the definition in
## lux/host.jvm.lux ASAP
(template [<name> <class>]
  [(def: #export <name> .Type (#.Primitive <class> #.Nil))]

  ## Boxes
  [Boolean   box.boolean]
  [Byte      box.byte]
  [Short     box.short]
  [Integer   box.int]
  [Long      box.long]
  [Float     box.float]
  [Double    box.double]
  [Character box.char]
  [String    "java.lang.String"]

  ## Primitives
  [boolean   reflection.boolean]
  [byte      reflection.byte]
  [short     reflection.short]
  [int       reflection.int]
  [long      reflection.long]
  [float     reflection.float]
  [double    reflection.double]
  [char      reflection.char]
  )

(type: Member
  {#class Text
   #member Text})

(def: member
  (Parser Member)
  ($_ <>.and <c>.text <c>.text))

(type: Method-Signature
  {#method .Type
   #exceptions (List .Type)})

(template [<name>]
  [(exception: #export (<name> {type .Type})
     (exception.report
      ["Type" (%.type type)]))]

  [non-object]
  [non-array]
  )

(template [<name>]
  [(exception: #export (<name> {class Text})
     (exception.report
      ["Class/type" (%.text class)]))]

  [non-interface]
  [non-throwable]
  [primitives-are-not-objects]
  )

(exception: #export (cannot-set-a-final-field {field Text} {class Text})
  (exception.report
   ["Field" (%.text field)]
   ["Class" (%.text class)]))

(template [<name>]
  [(exception: #export (<name> {class Text}
                               {method Text}
                               {arg-classes (List Text)}
                               {hints (List Method-Signature)})
     (exception.report
      ["Class" class]
      ["Method" method]
      ["Arguments" (exception.enumerate %.text arg-classes)]
      ["Hints" (exception.enumerate %.type (list@map product.left hints))]))]

  [no-candidates]
  [too-many-candidates]
  )

(exception: #export (cannot-cast {from .Type} {to .Type} {value Code})
  (exception.report
   ["From" (%.type from)]
   ["To" (%.type to)]
   ["Value" (%.code value)]))

(template [<name>]
  [(exception: #export (<name> {message Text})
     message)]

  [primitives-cannot-have-type-parameters]

  [cannot-possibly-be-an-instance]

  [unknown-type-var]
  )

(def: bundle::conversion
  Bundle
  (<| (///bundle.prefix "conversion")
      (|> ///bundle.empty
          (///bundle.install "double-to-float" (//lux.unary ..double ..float))
          (///bundle.install "double-to-int" (//lux.unary ..double ..int))
          (///bundle.install "double-to-long" (//lux.unary ..double ..long))
          (///bundle.install "float-to-double" (//lux.unary ..float ..double))
          (///bundle.install "float-to-int" (//lux.unary ..float ..int))
          (///bundle.install "float-to-long" (//lux.unary ..float ..long))
          (///bundle.install "int-to-byte" (//lux.unary ..int ..byte))
          (///bundle.install "int-to-char" (//lux.unary ..int ..char))
          (///bundle.install "int-to-double" (//lux.unary ..int ..double))
          (///bundle.install "int-to-float" (//lux.unary ..int ..float))
          (///bundle.install "int-to-long" (//lux.unary ..int ..long))
          (///bundle.install "int-to-short" (//lux.unary ..int ..short))
          (///bundle.install "long-to-double" (//lux.unary ..long ..double))
          (///bundle.install "long-to-float" (//lux.unary ..long ..float))
          (///bundle.install "long-to-int" (//lux.unary ..long ..int))
          (///bundle.install "long-to-short" (//lux.unary ..long ..short))
          (///bundle.install "long-to-byte" (//lux.unary ..long ..byte))
          (///bundle.install "char-to-byte" (//lux.unary ..char ..byte))
          (///bundle.install "char-to-short" (//lux.unary ..char ..short))
          (///bundle.install "char-to-int" (//lux.unary ..char ..int))
          (///bundle.install "char-to-long" (//lux.unary ..char ..long))
          (///bundle.install "byte-to-long" (//lux.unary ..byte ..long))
          (///bundle.install "short-to-long" (//lux.unary ..short ..long))
          )))

(template [<name> <prefix> <type>]
  [(def: <name>
     Bundle
     (<| (///bundle.prefix <prefix>)
         (|> ///bundle.empty
             (///bundle.install "+" (//lux.binary <type> <type> <type>))
             (///bundle.install "-" (//lux.binary <type> <type> <type>))
             (///bundle.install "*" (//lux.binary <type> <type> <type>))
             (///bundle.install "/" (//lux.binary <type> <type> <type>))
             (///bundle.install "%" (//lux.binary <type> <type> <type>))
             (///bundle.install "=" (//lux.binary <type> <type> Bit))
             (///bundle.install "<" (//lux.binary <type> <type> Bit))
             (///bundle.install "and" (//lux.binary <type> <type> <type>))
             (///bundle.install "or" (//lux.binary <type> <type> <type>))
             (///bundle.install "xor" (//lux.binary <type> <type> <type>))
             (///bundle.install "shl" (//lux.binary <type> Integer <type>))
             (///bundle.install "shr" (//lux.binary <type> Integer <type>))
             (///bundle.install "ushr" (//lux.binary <type> Integer <type>))
             )))]

  [bundle::int  reflection.int  ..long]
  [bundle::long reflection.long ..long]
  )

(template [<name> <prefix> <type>]
  [(def: <name>
     Bundle
     (<| (///bundle.prefix <prefix>)
         (|> ///bundle.empty
             (///bundle.install "+" (//lux.binary <type> <type> <type>))
             (///bundle.install "-" (//lux.binary <type> <type> <type>))
             (///bundle.install "*" (//lux.binary <type> <type> <type>))
             (///bundle.install "/" (//lux.binary <type> <type> <type>))
             (///bundle.install "%" (//lux.binary <type> <type> <type>))
             (///bundle.install "=" (//lux.binary <type> <type> Bit))
             (///bundle.install "<" (//lux.binary <type> <type> Bit))
             )))]

  [bundle::float  reflection.float  ..float]
  [bundle::double reflection.double ..double]
  )

(def: bundle::char
  Bundle
  (<| (///bundle.prefix reflection.char)
      (|> ///bundle.empty
          (///bundle.install "=" (//lux.binary ..char ..char Bit))
          (///bundle.install "<" (//lux.binary ..char ..char Bit))
          )))

(def: #export boxes
  (Dictionary Text Text)
  (|> (list [reflection.boolean box.boolean]
            [reflection.byte    box.byte]
            [reflection.short   box.short]
            [reflection.int     box.int]
            [reflection.long    box.long]
            [reflection.float   box.float]
            [reflection.double  box.double]
            [reflection.char    box.char])
      (dictionary.from-list text.hash)))

(def: (array-type-info allow-primitives? arrayT)
  (-> Bit .Type (Operation [Nat Text]))
  (loop [level 0
         currentT arrayT]
    (case currentT
      (#.Named name anonymous)
      (recur level anonymous)
      
      (#.Apply inputT abstractionT)
      (case (type.apply (list inputT) abstractionT)
        (#.Some outputT)
        (recur level outputT)

        #.None
        (/////analysis.throw ..non-array arrayT))

      (^ (#.Primitive (static array.type-name) (list elemT)))
      (recur (inc level) elemT)

      (#.Primitive class #.Nil)
      (if (and (dictionary.contains? class boxes)
               (not allow-primitives?))
        (/////analysis.throw ..primitives-are-not-objects [class])
        (////@wrap [level class]))

      (#.Primitive class _)
      (if (dictionary.contains? class boxes)
        (/////analysis.throw ..primitives-cannot-have-type-parameters class)
        (////@wrap [level class]))

      (#.Ex _)
      (////@wrap [level "java.lang.Object"])
      
      _
      (/////analysis.throw ..non-array arrayT))))

(def: (primitive-array-length-handler primitive-type)
  (-> Type Handler)
  (function (_ extension-name analyse args)
    (case args
      (^ (list arrayC))
      (do ////.monad
        [_ (typeA.infer ..int)
         arrayA (typeA.with-type (#.Primitive (jvm.descriptor (jvm.array 1 primitive-type)) (list))
                  (analyse arrayC))]
        (wrap (#/////analysis.Extension extension-name (list arrayA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: array::length::object
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list arrayC))
      (do ////.monad
        [_ (typeA.infer ..int)
         [var-id varT] (typeA.with-env check.var)
         arrayA (typeA.with-type (.type (Array varT))
                  (analyse arrayC))
         varT (typeA.with-env (check.clean varT))
         [array-nesting elem-class] (array-type-info true (.type (Array varT)))]
        (wrap (#/////analysis.Extension extension-name (list (/////analysis.nat array-nesting)
                                                             (/////analysis.text elem-class)
                                                             arrayA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: (new-primitive-array-handler primitive-type)
  (-> Type Handler)
  (function (_ extension-name analyse args)
    (case args
      (^ (list lengthC))
      (do ////.monad
        [lengthA (typeA.with-type ..int
                   (analyse lengthC))
         _ (typeA.infer (#.Primitive (jvm.descriptor (jvm.array 1 primitive-type)) (list)))]
        (wrap (#/////analysis.Extension extension-name (list lengthA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: array::new::object
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list lengthC))
      (do ////.monad
        [lengthA (typeA.with-type ..int
                   (analyse lengthC))
         expectedT (///.lift macro.expected-type)
         [level elem-class] (array-type-info false expectedT)
         _ (if (n.> 0 level)
             (wrap [])
             (/////analysis.throw ..non-array expectedT))]
        (wrap (#/////analysis.Extension extension-name (list (/////analysis.nat (dec level))
                                                             (/////analysis.text elem-class)
                                                             lengthA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: (check-jvm objectT)
  (-> .Type (Operation Type))
  (case objectT
    (#.Primitive name #.Nil)
    (case name
      (^ (static reflection.boolean)) (////@wrap jvm.boolean)
      (^ (static reflection.byte)) (////@wrap jvm.byte)
      (^ (static reflection.short)) (////@wrap jvm.short)
      (^ (static reflection.int)) (////@wrap jvm.int)
      (^ (static reflection.long)) (////@wrap jvm.long)
      (^ (static reflection.float)) (////@wrap jvm.float)
      (^ (static reflection.double)) (////@wrap jvm.double)
      (^ (static reflection.char)) (////@wrap jvm.char)
      _ (if (text.starts-with? jvm.array-prefix name)
          (////.lift (<t>.run jvm.parse-signature name))
          (////@wrap (jvm.class name (list)))))

    (^ (#.Primitive (static array.type-name)
                    (list elementT)))
    (|> elementT
        check-jvm
        (////@map (jvm.array 1)))
    
    (#.Primitive name parameters)
    (do ////.monad
      [parameters (monad.map @ check-jvm parameters)
       parameters (monad.map @ (function (_ parameter)
                                 (case parameter
                                   (#jvm.Generic generic)
                                   (wrap generic)

                                   _
                                   (/////analysis.throw ..primitives-cannot-have-type-parameters name)))
                             parameters)]
      (////@wrap (jvm.class name parameters)))

    (#.Named name anonymous)
    (check-jvm anonymous)

    (^template [<tag>]
      (<tag> id)
      (////@wrap (jvm.class "java.lang.Object" (list))))
    ([#.Var]
     [#.Ex])

    (^template [<tag>]
      (<tag> env unquantified)
      (check-jvm unquantified))
    ([#.UnivQ]
     [#.ExQ])

    (#.Apply inputT abstractionT)
    (case (type.apply (list inputT) abstractionT)
      (#.Some outputT)
      (check-jvm outputT)

      #.None
      (/////analysis.throw ..non-object objectT))

    _
    (/////analysis.throw ..non-object objectT)))

(def: (check-object objectT)
  (-> .Type (Operation Text))
  (do ////.monad
    [name (:: @ map reflection.class (check-jvm objectT))]
    (if (dictionary.contains? name ..boxes)
      (/////analysis.throw ..primitives-are-not-objects [name])
      (////@wrap name))))

(def: (check-return type)
  (-> .Type (Operation Text))
  (if (is? .Any type)
    (////@wrap jvm.void-descriptor)
    (////@map jvm.descriptor (check-jvm type))))

(def: (read-primitive-array-handler lux-type jvm-type)
  (-> .Type Type Handler)
  (function (_ extension-name analyse args)
    (case args
      (^ (list idxC arrayC))
      (do ////.monad
        [_ (typeA.infer lux-type)
         idxA (typeA.with-type ..int
                (analyse idxC))
         arrayA (typeA.with-type (#.Primitive (jvm.descriptor (jvm.array 1 jvm-type)) (list))
                  (analyse arrayC))]
        (wrap (#/////analysis.Extension extension-name (list idxA arrayA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 2 (list.size args)]))))

(def: array::read::object
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list idxC arrayC))
      (do ////.monad
        [[var-id varT] (typeA.with-env check.var)
         _ (typeA.infer varT)
         arrayA (typeA.with-type (.type (Array varT))
                  (analyse arrayC))
         varT (typeA.with-env
                (check.clean varT))
         [nesting elem-class] (array-type-info false (.type (Array varT)))
         idxA (typeA.with-type ..int
                (analyse idxC))]
        (wrap (#/////analysis.Extension extension-name (list (/////analysis.nat nesting)
                                                             (/////analysis.text elem-class)
                                                             idxA
                                                             arrayA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 2 (list.size args)]))))

(def: (write-primitive-array-handler lux-type jvm-type)
  (-> .Type Type Handler)
  (let [array-type (#.Primitive (jvm.descriptor (jvm.array 1 jvm-type)) (list))]
    (function (_ extension-name analyse args)
      (case args
        (^ (list idxC valueC arrayC))
        (do ////.monad
          [_ (typeA.infer array-type)
           idxA (typeA.with-type ..int
                  (analyse idxC))
           valueA (typeA.with-type lux-type
                    (analyse valueC))
           arrayA (typeA.with-type array-type
                    (analyse arrayC))]
          (wrap (#/////analysis.Extension extension-name (list idxA
                                                               valueA
                                                               arrayA))))

        _
        (/////analysis.throw ///.incorrect-arity [extension-name 3 (list.size args)])))))

(def: array::write::object
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list idxC valueC arrayC))
      (do ////.monad
        [[var-id varT] (typeA.with-env check.var)
         _ (typeA.infer (.type (Array varT)))
         arrayA (typeA.with-type (.type (Array varT))
                  (analyse arrayC))
         varT (typeA.with-env
                (check.clean varT))
         [nesting elem-class] (array-type-info false (.type (Array varT)))
         idxA (typeA.with-type ..int
                (analyse idxC))
         valueA (typeA.with-type varT
                  (analyse valueC))]
        (wrap (#/////analysis.Extension extension-name (list (/////analysis.nat nesting)
                                                             (/////analysis.text elem-class)
                                                             idxA
                                                             valueA
                                                             arrayA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 3 (list.size args)]))))

(def: bundle::array
  Bundle
  (<| (///bundle.prefix "array")
      (|> ///bundle.empty
          (dictionary.merge (<| (///bundle.prefix "length")
                                (|> ///bundle.empty
                                    (///bundle.install reflection.boolean (primitive-array-length-handler jvm.boolean))
                                    (///bundle.install reflection.byte (primitive-array-length-handler jvm.byte))
                                    (///bundle.install reflection.short (primitive-array-length-handler jvm.short))
                                    (///bundle.install reflection.int (primitive-array-length-handler jvm.int))
                                    (///bundle.install reflection.long (primitive-array-length-handler jvm.long))
                                    (///bundle.install reflection.float (primitive-array-length-handler jvm.float))
                                    (///bundle.install reflection.double (primitive-array-length-handler jvm.double))
                                    (///bundle.install reflection.char (primitive-array-length-handler jvm.char))
                                    (///bundle.install "object" array::length::object))))
          (dictionary.merge (<| (///bundle.prefix "new")
                                (|> ///bundle.empty
                                    (///bundle.install reflection.boolean (new-primitive-array-handler jvm.boolean))
                                    (///bundle.install reflection.byte (new-primitive-array-handler jvm.byte))
                                    (///bundle.install reflection.short (new-primitive-array-handler jvm.short))
                                    (///bundle.install reflection.int (new-primitive-array-handler jvm.int))
                                    (///bundle.install reflection.long (new-primitive-array-handler jvm.long))
                                    (///bundle.install reflection.float (new-primitive-array-handler jvm.float))
                                    (///bundle.install reflection.double (new-primitive-array-handler jvm.double))
                                    (///bundle.install reflection.char (new-primitive-array-handler jvm.char))
                                    (///bundle.install "object" array::new::object))))
          (dictionary.merge (<| (///bundle.prefix "read")
                                (|> ///bundle.empty
                                    (///bundle.install reflection.boolean (read-primitive-array-handler ..boolean jvm.boolean))
                                    (///bundle.install reflection.byte (read-primitive-array-handler ..byte jvm.byte))
                                    (///bundle.install reflection.short (read-primitive-array-handler ..short jvm.short))
                                    (///bundle.install reflection.int (read-primitive-array-handler ..int jvm.int))
                                    (///bundle.install reflection.long (read-primitive-array-handler ..long jvm.long))
                                    (///bundle.install reflection.float (read-primitive-array-handler ..float jvm.float))
                                    (///bundle.install reflection.double (read-primitive-array-handler ..double jvm.double))
                                    (///bundle.install reflection.char (read-primitive-array-handler ..char jvm.char))
                                    (///bundle.install "object" array::read::object))))
          (dictionary.merge (<| (///bundle.prefix "write")
                                (|> ///bundle.empty
                                    (///bundle.install reflection.boolean (write-primitive-array-handler ..boolean jvm.boolean))
                                    (///bundle.install reflection.byte (write-primitive-array-handler ..byte jvm.byte))
                                    (///bundle.install reflection.short (write-primitive-array-handler ..short jvm.short))
                                    (///bundle.install reflection.int (write-primitive-array-handler ..int jvm.int))
                                    (///bundle.install reflection.long (write-primitive-array-handler ..long jvm.long))
                                    (///bundle.install reflection.float (write-primitive-array-handler ..float jvm.float))
                                    (///bundle.install reflection.double (write-primitive-array-handler ..double jvm.double))
                                    (///bundle.install reflection.char (write-primitive-array-handler ..char jvm.char))
                                    (///bundle.install "object" array::write::object))))
          )))

(def: object::null
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list))
      (do ////.monad
        [expectedT (///.lift macro.expected-type)
         _ (check-object expectedT)]
        (wrap (#/////analysis.Extension extension-name (list))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 0 (list.size args)]))))

(def: object::null?
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list objectC))
      (do ////.monad
        [_ (typeA.infer Bit)
         [objectT objectA] (typeA.with-inference
                             (analyse objectC))
         _ (check-object objectT)]
        (wrap (#/////analysis.Extension extension-name (list objectA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: object::synchronized
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list monitorC exprC))
      (do ////.monad
        [[monitorT monitorA] (typeA.with-inference
                               (analyse monitorC))
         _ (check-object monitorT)
         exprA (analyse exprC)]
        (wrap (#/////analysis.Extension extension-name (list monitorA exprA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 2 (list.size args)]))))

(def: object::throw
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list exceptionC))
      (do ////.monad
        [_ (typeA.infer Nothing)
         [exceptionT exceptionA] (typeA.with-inference
                                   (analyse exceptionC))
         exception-class (check-object exceptionT)
         ? (////.lift (reflection!.sub? "java.lang.Throwable" exception-class))
         _ (: (Operation Any)
              (if ?
                (wrap [])
                (/////analysis.throw non-throwable exception-class)))]
        (wrap (#/////analysis.Extension extension-name (list exceptionA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: object::class
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list classC))
      (case classC
        [_ (#.Text class)]
        (do ////.monad
          [_ (typeA.infer (#.Primitive "java.lang.Class" (list (#.Primitive class (list)))))
           _ (////.lift (reflection!.load class))]
          (wrap (#/////analysis.Extension extension-name (list (/////analysis.text class)))))

        _
        (/////analysis.throw ///.invalid-syntax [extension-name %.code args]))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: object::instance?
  Handler
  (..custom
   [($_ <>.and <c>.text <c>.any)
    (function (_ extension-name analyse [sub-class objectC])
      (do ////.monad
        [_ (typeA.infer Bit)
         [objectT objectA] (typeA.with-inference
                             (analyse objectC))
         object-class (check-object objectT)
         ? (////.lift (reflection!.sub? object-class sub-class))]
        (if ?
          (wrap (#/////analysis.Extension extension-name (list (/////analysis.text sub-class) objectA)))
          (/////analysis.throw cannot-possibly-be-an-instance (format sub-class " !<= "  object-class)))))]))

(import: #long java/lang/Object
  (equals [java/lang/Object] boolean))

(import: #long java/lang/reflect/Type)

(import: #long (java/lang/reflect/TypeVariable d)
  (getName [] java/lang/String)
  (getBounds [] [java/lang/reflect/Type]))

(import: #long java/lang/reflect/Modifier
  (#static isStatic [int] boolean)
  (#static isFinal [int] boolean)
  (#static isInterface [int] boolean)
  (#static isAbstract [int] boolean))

(import: #long java/lang/reflect/Method
  (getName [] java/lang/String)
  (getModifiers [] int)
  (getDeclaringClass [] (java/lang/Class java/lang/Object))
  (getTypeParameters [] [(java/lang/reflect/TypeVariable java/lang/reflect/Method)])
  (getGenericParameterTypes [] [java/lang/reflect/Type])
  (getGenericReturnType [] java/lang/reflect/Type)
  (getGenericExceptionTypes [] [java/lang/reflect/Type]))

(import: #long (java/lang/reflect/Constructor c)
  (getModifiers [] int)
  (getDeclaringClass [] (java/lang/Class c))
  (getTypeParameters [] [(java/lang/reflect/TypeVariable (java/lang/reflect/Constructor c))])
  (getGenericParameterTypes [] [java/lang/reflect/Type])
  (getGenericExceptionTypes [] [java/lang/reflect/Type]))

(import: #long (java/lang/Class c)
  (#static forName [java/lang/String] #try (java/lang/Class java/lang/Object))
  (getName [] java/lang/String)
  (getModifiers [] int)
  (isAssignableFrom [(java/lang/Class java/lang/Object)] boolean)
  (getTypeParameters [] [(java/lang/reflect/TypeVariable (java/lang/Class c))])
  (getGenericInterfaces [] [java/lang/reflect/Type])
  (getGenericSuperclass [] #? java/lang/reflect/Type)
  (getDeclaredField [java/lang/String] #try java/lang/reflect/Field)
  (getConstructors [] [(java/lang/reflect/Constructor java/lang/Object)])
  (getDeclaredMethods [] [java/lang/reflect/Method]))

(def: (reflection-type mapping typeJ)
  (-> Mapping Type (Operation .Type))
  (typeA.with-env
    (luxT.type mapping typeJ)))

(def: (reflection-return mapping return)
  (-> Mapping Return (Operation .Type))
  (case return
    #.None
    (////@wrap .Any)

    (#.Some return)
    (..reflection-type mapping return)))

(def: (class-candidate-parents from-name fromT to-name to-class)
  (-> Text .Type Text (java/lang/Class java/lang/Object) (Operation (List [[Text .Type] Bit])))
  (do ////.monad
    [from-class (////.lift (reflection!.load from-name))
     mapping (////.lift (reflection!.correspond from-class fromT))]
    (monad.map @
               (function (_ superJT)
                 (do @
                   [superJT (////.lift (reflection!.type superJT))
                    #let [super-name (reflection.class superJT)]
                    super-class (////.lift (reflection!.load super-name))
                    superT (typeA.with-env (luxT.type mapping superJT))]
                   (wrap [[super-name superT] (java/lang/Class::isAssignableFrom super-class to-class)])))
               (case (java/lang/Class::getGenericSuperclass from-class)
                 (#.Some super)
                 (list& super (array.to-list (java/lang/Class::getGenericInterfaces from-class)))

                 #.None
                 (if (java/lang/reflect/Modifier::isInterface (java/lang/Class::getModifiers from-class))
                   (#.Cons (:coerce java/lang/reflect/Type (host.class-for java/lang/Object))
                           (array.to-list (java/lang/Class::getGenericInterfaces from-class)))
                   (array.to-list (java/lang/Class::getGenericInterfaces from-class)))))))

(def: (inheritance-candidate-parents fromT to-class toT fromC)
  (-> .Type (java/lang/Class java/lang/Object) .Type Code (Operation (List [[Text .Type] Bit])))
  (case fromT
    (^ (#.Primitive _ (list& self-classT super-classT super-interfacesT+)))
    (monad.map ////.monad
               (function (_ superT)
                 (do ////.monad
                   [super-name (:: @ map reflection.class (check-jvm superT))
                    super-class (////.lift (reflection!.load super-name))]
                   (wrap [[super-name superT]
                          (java/lang/Class::isAssignableFrom super-class to-class)])))
               (list& super-classT super-interfacesT+))

    _
    (/////analysis.throw cannot-cast [fromT toT fromC])))

(def: object::cast
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list fromC))
      (do ////.monad
        [toT (///.lift macro.expected-type)
         to-name (:: @ map reflection.class (check-jvm toT))
         [fromT fromA] (typeA.with-inference
                         (analyse fromC))
         from-name (:: @ map reflection.class (check-jvm fromT))
         can-cast? (: (Operation Bit)
                      (case [from-name to-name]
                        (^template [<primitive> <object>]
                          (^or (^ [(static <primitive>) (static <object>)])
                               (^ [(static <object>) (static <primitive>)])
                               (^ [(static <primitive>) (static <primitive>)]))
                          (wrap #1))
                        ([reflection.boolean box.boolean]
                         [reflection.byte    box.byte]
                         [reflection.short   box.short]
                         [reflection.int     box.int]
                         [reflection.long    box.long]
                         [reflection.float   box.float]
                         [reflection.double  box.double]
                         [reflection.char    box.char])

                        _
                        (do @
                          [_ (////.assert ..primitives-are-not-objects [from-name]
                                          (not (dictionary.contains? from-name boxes)))
                           _ (////.assert ..primitives-are-not-objects [to-name]
                                          (not (dictionary.contains? to-name boxes)))
                           to-class (////.lift (reflection!.load to-name))
                           _ (if (text@= ..inheritance-relationship-type-name from-name)
                               (wrap [])
                               (do @
                                 [from-class (////.lift (reflection!.load from-name))]
                                 (////.assert cannot-cast [fromT toT fromC]
                                              (java/lang/Class::isAssignableFrom from-class to-class))))]
                          (loop [[current-name currentT] [from-name fromT]]
                            (if (text@= to-name current-name)
                              (wrap #1)
                              (do @
                                [candidate-parents (: (Operation (List [[Text .Type] Bit]))
                                                      (if (text@= ..inheritance-relationship-type-name current-name)
                                                        (inheritance-candidate-parents currentT to-class toT fromC)
                                                        (class-candidate-parents current-name currentT to-name to-class)))]
                                (case (|> candidate-parents
                                          (list.filter product.right)
                                          (list@map product.left))
                                  (#.Cons [next-name nextT] _)
                                  (recur [next-name nextT])

                                  #.Nil
                                  (/////analysis.throw cannot-cast [fromT toT fromC]))
                                ))))))]
        (if can-cast?
          (wrap (#/////analysis.Extension extension-name (list (/////analysis.text from-name)
                                                               (/////analysis.text to-name)
                                                               fromA)))
          (/////analysis.throw cannot-cast [fromT toT fromC])))

      _
      (/////analysis.throw ///.invalid-syntax [extension-name %.code args]))))

(def: bundle::object
  Bundle
  (<| (///bundle.prefix "object")
      (|> ///bundle.empty
          (///bundle.install "null" object::null)
          (///bundle.install "null?" object::null?)
          (///bundle.install "synchronized" object::synchronized)
          (///bundle.install "throw" object::throw)
          (///bundle.install "class" object::class)
          (///bundle.install "instance?" object::instance?)
          (///bundle.install "cast" object::cast)
          )))

(def: static::get
  Handler
  (..custom
   [..member
    (function (_ extension-name analyse [class field])
      (do ////.monad
        [[final? fieldJT] (////.lift
                           (do try.monad
                             [class (reflection!.load class)]
                             (reflection!.static-field field class)))
         fieldT (reflection-type luxT.fresh fieldJT)
         _ (typeA.infer fieldT)]
        (wrap (<| (#/////analysis.Extension extension-name)
                  (list (/////analysis.text class)
                        (/////analysis.text field)
                        (/////analysis.text (reflection.class fieldJT)))))))]))

(def: static::put
  Handler
  (..custom
   [($_ <>.and ..member <c>.any)
    (function (_ extension-name analyse [[class field] valueC])
      (do ////.monad
        [_ (typeA.infer Any)
         [final? fieldJT] (////.lift
                           (do try.monad
                             [class (reflection!.load class)]
                             (reflection!.static-field field class)))
         fieldT (reflection-type luxT.fresh fieldJT)
         _ (////.assert ..cannot-set-a-final-field [class field]
                        (not final?))
         valueA (typeA.with-type fieldT
                  (analyse valueC))]
        (wrap (<| (#/////analysis.Extension extension-name)
                  (list (/////analysis.text class)
                        (/////analysis.text field)
                        valueA)))))]))

(def: virtual::get
  Handler
  (..custom
   [($_ <>.and ..member <c>.any)
    (function (_ extension-name analyse [[class field] objectC])
      (do ////.monad
        [[objectT objectA] (typeA.with-inference
                             (analyse objectC))
         [mapping fieldJT] (////.lift
                            (do try.monad
                              [class (reflection!.load class)
                               [final? fieldJT] (reflection!.virtual-field field class)
                               mapping (reflection!.correspond class objectT)]
                              (wrap [mapping fieldJT])))
         fieldT (typeA.with-env
                  (luxT.type mapping fieldJT))
         _ (typeA.infer fieldT)]
        (wrap (<| (#/////analysis.Extension extension-name)
                  (list (/////analysis.text class)
                        (/////analysis.text field)
                        objectA)))))]))

(def: virtual::put
  Handler
  (..custom
   [($_ <>.and ..member <c>.any <c>.any)
    (function (_ extension-name analyse [[class field] valueC objectC])
      (do ////.monad
        [[objectT objectA] (typeA.with-inference
                             (analyse objectC))
         _ (typeA.infer objectT)
         [final? mapping fieldJT] (////.lift
                                   (do try.monad
                                     [class (reflection!.load class)
                                      [final? fieldJT] (reflection!.virtual-field field class)
                                      mapping (reflection!.correspond class objectT)]
                                     (wrap [final? mapping fieldJT])))
         fieldT (typeA.with-env
                  (luxT.type mapping fieldJT))
         _ (////.assert cannot-set-a-final-field [class field]
                        (not final?))
         valueA (typeA.with-type fieldT
                  (analyse valueC))]
        (wrap (<| (#/////analysis.Extension extension-name)
                  (list (/////analysis.text class)
                        (/////analysis.text field)
                        valueA
                        objectA)))))]))

(type: Method-Style
  #Static
  #Abstract
  #Virtual
  #Special
  #Interface)

(def: (check-method class method-name method-style arg-classes method)
  (-> (java/lang/Class java/lang/Object) Text Method-Style (List Text) java/lang/reflect/Method (Operation Bit))
  (do ////.monad
    [parameters (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                    array.to-list
                    (monad.map try.monad reflection!.type)
                    (:: try.monad map (list@map jvm.descriptor))
                    ////.lift)
     #let [modifiers (java/lang/reflect/Method::getModifiers method)
           correct-class? (java/lang/Object::equals class (java/lang/reflect/Method::getDeclaringClass method))
           correct-method? (text@= method-name (java/lang/reflect/Method::getName method))
           static-matches? (case method-style
                             #Static
                             (java/lang/reflect/Modifier::isStatic modifiers)

                             _
                             #1)
           special-matches? (case method-style
                              #Special
                              (not (or (java/lang/reflect/Modifier::isInterface (java/lang/Class::getModifiers class))
                                       (java/lang/reflect/Modifier::isAbstract modifiers)))

                              _
                              #1)
           arity-matches? (n.= (list.size arg-classes) (list.size parameters))
           inputs-match? (list@fold (function (_ [expectedJC actualJC] prev)
                                      (and prev
                                           (text@= expectedJC actualJC)))
                                    #1
                                    (list.zip2 arg-classes parameters))]]
    (wrap (and correct-class?
               correct-method?
               static-matches?
               special-matches?
               arity-matches?
               inputs-match?))))

(def: (check-constructor class arg-classes constructor)
  (-> (java/lang/Class java/lang/Object) (List Text) (java/lang/reflect/Constructor java/lang/Object) (Operation Bit))
  (do ////.monad
    [parameters (|> (java/lang/reflect/Constructor::getGenericParameterTypes constructor)
                    array.to-list
                    (monad.map try.monad reflection!.type)
                    (:: try.monad map (list@map jvm.descriptor))
                    ////.lift)]
    (wrap (and (java/lang/Object::equals class (java/lang/reflect/Constructor::getDeclaringClass constructor))
               (n.= (list.size arg-classes) (list.size parameters))
               (list@fold (function (_ [expectedJC actualJC] prev)
                            (and prev
                                 (text@= expectedJC actualJC)))
                          #1
                          (list.zip2 arg-classes parameters))))))

(def: idx-to-parameter
  (-> Nat .Type)
  (|>> (n.* 2) inc #.Parameter))

(def: (jvm-type-var-mapping owner-tvars method-tvars)
  (-> (List Text) (List Text) [(List .Type) Mapping])
  (let [jvm-tvars (list@compose owner-tvars method-tvars)
        lux-tvars (|> jvm-tvars
                      list.reverse
                      list.enumerate
                      (list@map (function (_ [idx name])
                                  [name (idx-to-parameter idx)]))
                      list.reverse)
        num-owner-tvars (list.size owner-tvars)
        owner-tvarsT (|> lux-tvars (list.take num-owner-tvars) (list@map product.right))
        mapping (dictionary.from-list text.hash lux-tvars)]
    [owner-tvarsT mapping]))

(def: (method-signature method-style method)
  (-> Method-Style java/lang/reflect/Method (Operation Method-Signature))
  (let [owner (java/lang/reflect/Method::getDeclaringClass method)
        owner-tvars (case method-style
                      #Static
                      (list)

                      _
                      (|> (java/lang/Class::getTypeParameters owner)
                          array.to-list
                          (list@map (|>> java/lang/reflect/TypeVariable::getName))))
        method-tvars (|> (java/lang/reflect/Method::getTypeParameters method)
                         array.to-list
                         (list@map (|>> java/lang/reflect/TypeVariable::getName)))
        [owner-tvarsT mapping] (jvm-type-var-mapping owner-tvars method-tvars)]
    (do ////.monad
      [inputsT (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                   array.to-list
                   (monad.map @ (|>> reflection!.type ////.lift))
                   (////@map (monad.map @ (reflection-type mapping)))
                   ////@join)
       outputT (|> method
                   java/lang/reflect/Method::getGenericReturnType
                   reflection!.return
                   ////.lift
                   (////@map (..reflection-return mapping))
                   ////@join)
       exceptionsT (|> (java/lang/reflect/Method::getGenericExceptionTypes method)
                       array.to-list
                       (monad.map @ (|>> reflection!.type ////.lift))
                       (////@map (monad.map @ (reflection-type mapping)))
                       ////@join)
       #let [methodT (<| (type.univ-q (dictionary.size mapping))
                         (type.function (case method-style
                                          #Static
                                          inputsT

                                          _
                                          (list& (#.Primitive (java/lang/Class::getName owner) owner-tvarsT)
                                                 inputsT)))
                         outputT)]]
      (wrap [methodT exceptionsT]))))

(def: (constructor-signature constructor)
  (-> (java/lang/reflect/Constructor java/lang/Object) (Operation Method-Signature))
  (let [owner (java/lang/reflect/Constructor::getDeclaringClass constructor)
        owner-tvars (|> (java/lang/Class::getTypeParameters owner)
                        array.to-list
                        (list@map (|>> java/lang/reflect/TypeVariable::getName)))
        method-tvars (|> (java/lang/reflect/Constructor::getTypeParameters constructor)
                         array.to-list
                         (list@map (|>> java/lang/reflect/TypeVariable::getName)))
        [owner-tvarsT mapping] (jvm-type-var-mapping owner-tvars method-tvars)]
    (do ////.monad
      [inputsT (|> (java/lang/reflect/Constructor::getGenericParameterTypes constructor)
                   array.to-list
                   (monad.map @ (|>> reflection!.type ////.lift))
                   (////@map (monad.map @ (reflection-type mapping)))
                   ////@join)
       exceptionsT (|> (java/lang/reflect/Constructor::getGenericExceptionTypes constructor)
                       array.to-list
                       (monad.map @ (|>> reflection!.type ////.lift))
                       (////@map (monad.map @ (reflection-type mapping)))
                       ////@join)
       #let [objectT (#.Primitive (java/lang/Class::getName owner) owner-tvarsT)
             constructorT (<| (type.univ-q (dictionary.size mapping))
                              (type.function inputsT)
                              objectT)]]
      (wrap [constructorT exceptionsT]))))

(type: Evaluation
  (#Pass Method-Signature)
  (#Hint Method-Signature))

(template [<name> <tag>]
  [(def: <name>
     (-> Evaluation (Maybe Method-Signature))
     (|>> (case> (<tag> output)
                 (#.Some output)

                 _
                 #.None)))]

  [pass! #Pass]
  [hint! #Hint]
  )

(def: (method-candidate class-name method-name method-style arg-classes)
  (-> Text Text Method-Style (List Text) (Operation Method-Signature))
  (do ////.monad
    [class (////.lift (reflection!.load class-name))
     candidates (|> class
                    java/lang/Class::getDeclaredMethods
                    array.to-list
                    (list.filter (|>> java/lang/reflect/Method::getName (text@= method-name)))
                    (monad.map @ (: (-> java/lang/reflect/Method (Operation Evaluation))
                                    (function (_ method)
                                      (do @
                                        [passes? (check-method class method-name method-style arg-classes method)]
                                        (:: @ map (if passes?
                                                    (|>> #Pass)
                                                    (|>> #Hint))
                                            (method-signature method-style method)))))))]
    (case (list.search-all pass! candidates)
      (#.Cons method #.Nil)
      (wrap method)

      #.Nil
      (/////analysis.throw ..no-candidates [class-name method-name arg-classes (list.search-all hint! candidates)])
      
      candidates
      (/////analysis.throw ..too-many-candidates [class-name method-name arg-classes candidates]))))

(def: constructor-method "<init>")

(def: (constructor-candidate class-name arg-classes)
  (-> Text (List Text) (Operation Method-Signature))
  (do ////.monad
    [class (////.lift (reflection!.load class-name))
     candidates (|> class
                    java/lang/Class::getConstructors
                    array.to-list
                    (monad.map @ (function (_ constructor)
                                   (do @
                                     [passes? (check-constructor class arg-classes constructor)]
                                     (:: @ map
                                         (if passes? (|>> #Pass) (|>> #Hint))
                                         (constructor-signature constructor))))))]
    (case (list.search-all pass! candidates)
      (#.Cons constructor #.Nil)
      (wrap constructor)

      #.Nil
      (/////analysis.throw ..no-candidates [class-name ..constructor-method arg-classes (list.search-all hint! candidates)])
      
      candidates
      (/////analysis.throw ..too-many-candidates [class-name ..constructor-method arg-classes candidates]))))

(def: typed-input
  (Parser [Text Code])
  (<c>.tuple (<>.and <c>.text <c>.any)))

(def: (decorate-inputs typesT inputsA)
  (-> (List Text) (List Analysis) (List Analysis))
  (|> inputsA
      (list.zip2 (list@map (|>> /////analysis.text) typesT))
      (list@map (function (_ [type value])
                  (/////analysis.tuple (list type value))))))

(def: invoke::static
  Handler
  (..custom
   [($_ <>.and ..member (<>.some ..typed-input))
    (function (_ extension-name analyse [[class method] argsTC])
      (do ////.monad
        [#let [argsT (list@map product.left argsTC)]
         [methodT exceptionsT] (method-candidate class method #Static argsT)
         [outputT argsA] (inferenceA.general analyse methodT (list@map product.right argsTC))
         outputJC (check-return outputT)]
        (wrap (#/////analysis.Extension extension-name (list& (/////analysis.text class)
                                                              (/////analysis.text method)
                                                              (/////analysis.text outputJC)
                                                              (decorate-inputs argsT argsA))))))]))

(def: invoke::virtual
  Handler
  (..custom
   [($_ <>.and ..member <c>.any (<>.some ..typed-input))
    (function (_ extension-name analyse [[class method] objectC argsTC])
      (do ////.monad
        [#let [argsT (list@map product.left argsTC)]
         [methodT exceptionsT] (method-candidate class method #Virtual argsT)
         [outputT allA] (inferenceA.general analyse methodT (list& objectC (list@map product.right argsTC)))
         #let [[objectA argsA] (case allA
                                 (#.Cons objectA argsA)
                                 [objectA argsA]

                                 _
                                 (undefined))]
         outputJC (check-return outputT)]
        (wrap (#/////analysis.Extension extension-name (list& (/////analysis.text class)
                                                              (/////analysis.text method)
                                                              (/////analysis.text outputJC)
                                                              objectA
                                                              (decorate-inputs argsT argsA))))))]))

(def: invoke::special
  Handler
  (..custom
   [($_ <>.and ..member <c>.any (<>.some ..typed-input))
    (function (_ extension-name analyse [[class method] objectC argsTC])
      (do ////.monad
        [#let [argsT (list@map product.left argsTC)]
         [methodT exceptionsT] (method-candidate class method #Special argsT)
         [outputT argsA] (inferenceA.general analyse methodT (list& objectC (list@map product.right argsTC)))
         outputJC (check-return outputT)]
        (wrap (#/////analysis.Extension extension-name (list& (/////analysis.text class)
                                                              (/////analysis.text method)
                                                              (/////analysis.text outputJC)
                                                              (decorate-inputs argsT argsA))))))]))

(def: invoke::interface
  Handler
  (..custom
   [($_ <>.and ..member <c>.any (<>.some ..typed-input))
    (function (_ extension-name analyse [[class-name method] objectC argsTC])
      (do ////.monad
        [#let [argsT (list@map product.left argsTC)]
         class (////.lift (reflection!.load class-name))
         _ (////.assert non-interface class-name
                        (java/lang/reflect/Modifier::isInterface (java/lang/Class::getModifiers class)))
         [methodT exceptionsT] (method-candidate class-name method #Interface argsT)
         [outputT allA] (inferenceA.general analyse methodT (list& objectC (list@map product.right argsTC)))
         #let [[objectA argsA] (case allA
                                 (#.Cons objectA argsA)
                                 [objectA argsA]

                                 _
                                 (undefined))]
         outputJC (check-return outputT)]
        (wrap (#/////analysis.Extension extension-name
                                        (list& (/////analysis.text class-name)
                                               (/////analysis.text method)
                                               (/////analysis.text outputJC)
                                               objectA
                                               (decorate-inputs argsT argsA))))))]))

(def: invoke::constructor
  (..custom
   [($_ <>.and <c>.text (<>.some ..typed-input))
    (function (_ extension-name analyse [class argsTC])
      (do ////.monad
        [#let [argsT (list@map product.left argsTC)]
         [methodT exceptionsT] (constructor-candidate class argsT)
         [outputT argsA] (inferenceA.general analyse methodT (list@map product.right argsTC))]
        (wrap (#/////analysis.Extension extension-name (list& (/////analysis.text class)
                                                              (decorate-inputs argsT argsA))))))]))

(def: bundle::member
  Bundle
  (<| (///bundle.prefix "member")
      (|> ///bundle.empty
          (dictionary.merge (<| (///bundle.prefix "static")
                                (|> ///bundle.empty
                                    (///bundle.install "get" static::get)
                                    (///bundle.install "put" static::put))))
          (dictionary.merge (<| (///bundle.prefix "virtual")
                                (|> ///bundle.empty
                                    (///bundle.install "get" virtual::get)
                                    (///bundle.install "put" virtual::put))))
          (dictionary.merge (<| (///bundle.prefix "invoke")
                                (|> ///bundle.empty
                                    (///bundle.install "static" invoke::static)
                                    (///bundle.install "virtual" invoke::virtual)
                                    (///bundle.install "special" invoke::special)
                                    (///bundle.install "interface" invoke::interface)
                                    (///bundle.install "constructor" invoke::constructor)
                                    )))
          )))

(def: #export var
  (Parser Var)
  <c>.text)

(def: bound
  (Parser Bound)
  (<>.or (<c>.identifier! ["" ">"])
         (<c>.identifier! ["" "<"])))

(def: generic
  (Parser Generic)
  (<>.rec
   (function (_ generic)
     (let [wildcard (: (Parser (Maybe [Bound Generic]))
                       (<>.or (<c>.identifier! ["" "?"])
                              (<c>.form (<>.and ..bound generic))))
           class (: (Parser Class)
                    (<c>.form (<>.and <c>.text (<>.some generic))))]
       ($_ <>.or
           ..var
           wildcard
           class)))))

(def: #export class
  (Parser Class)
  (<c>.form (<>.and <c>.text (<>.some ..generic))))

(def: primitive
  (Parser Primitive)
  ($_ <>.or
      (<c>.identifier! ["" reflection.boolean])
      (<c>.identifier! ["" reflection.byte])
      (<c>.identifier! ["" reflection.short])
      (<c>.identifier! ["" reflection.int])
      (<c>.identifier! ["" reflection.long])
      (<c>.identifier! ["" reflection.float])
      (<c>.identifier! ["" reflection.double])
      (<c>.identifier! ["" reflection.char])
      ))

(def: #export type
  (Parser Type)
  (<>.rec
   (function (_ type)
     ($_ <>.or
         ..primitive
         ..generic
         (<c>.tuple type)))))

(def: #export typed
  (Parser (Typed Code))
  (<c>.tuple (<>.and ..type <c>.any)))

(type: #export (Annotation-Parameter a)
  [Text a])

(def: annotation-parameter
  (Parser (Annotation-Parameter Code))
  (<c>.tuple (<>.and <c>.text <c>.any)))

(type: #export (Annotation a)
  [Text (List (Annotation-Parameter a))])

(def: #export annotation
  (Parser (Annotation Code))
  (<c>.form (<>.and <c>.text (<>.some ..annotation-parameter))))

(def: #export argument
  (Parser Argument)
  (<c>.tuple (<>.and <c>.text ..type)))

(def: #export return
  (Parser Return)
  (<>.or (<c>.identifier! ["" reflection.void])
         ..type))

(def: (generic-analysis generic)
  (-> Generic Analysis)
  (case generic
    (#jvm.Var var)
    (/////analysis.text var)
    
    (#jvm.Wildcard wildcard)
    (case wildcard
      #.None
      (/////analysis.constant ["" "?"])
      
      (#.Some [bound limit])
      (/////analysis.tuple (list (case bound
                                   #jvm.Lower
                                   (/////analysis.constant ["" ">"])
                                   
                                   #jvm.Upper
                                   (/////analysis.constant ["" "<"]))
                                 (generic-analysis limit))))
    
    (#jvm.Class name parameters)
    (/////analysis.tuple (list& (/////analysis.text name)
                                (list@map generic-analysis parameters)))))

(def: (class-analysis [name parameters])
  (-> Class Analysis)
  (/////analysis.tuple (list& (/////analysis.text name)
                              (list@map generic-analysis parameters))))

(def: (annotation-parameter-analysis [name value])
  (-> (Annotation-Parameter Analysis) Analysis)
  (/////analysis.tuple (list (/////analysis.text name) value)))

(def: (annotation-analysis [name parameters])
  (-> (Annotation Analysis) Analysis)
  (/////analysis.tuple (list& (/////analysis.text name)
                              (list@map annotation-parameter-analysis parameters))))

(def: var-analysis
  (-> Var Analysis)
  (|>> /////analysis.text))

(def: (type-analysis type)
  (-> Type Analysis)
  (case type
    (#jvm.Primitive primitive)
    (case primitive
      #jvm.Boolean (/////analysis.constant ["" reflection.boolean])
      #jvm.Byte (/////analysis.constant ["" reflection.byte])
      #jvm.Short (/////analysis.constant ["" reflection.short])
      #jvm.Int (/////analysis.constant ["" reflection.int])
      #jvm.Long (/////analysis.constant ["" reflection.long])
      #jvm.Float (/////analysis.constant ["" reflection.float])
      #jvm.Double (/////analysis.constant ["" reflection.double])
      #jvm.Char (/////analysis.constant ["" reflection.char]))
    
    (#jvm.Generic generic)
    (generic-analysis generic)
    
    (#jvm.Array type)
    (/////analysis.tuple (list (type-analysis type)))))

(def: (return-analysis return)
  (-> Return Analysis)
  (case return
    #.None
    (/////analysis.constant ["" jvm.void-descriptor])
    
    (#.Some type)
    (type-analysis type)))

(def: (typed-analysis [type term])
  (-> (Typed Analysis) Analysis)
  (/////analysis.tuple (list (type-analysis type) term)))

(template [<name> <filter>]
  [(def: <name>
     (-> (java/lang/Class java/lang/Object)
         (Try (List [Text Method])))
     (|>> java/lang/Class::getDeclaredMethods
          array.to-list
          <filter>
          (monad.map try.monad
                     (function (_ method)
                       (do try.monad
                         [inputs (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                                     array.to-list
                                     (monad.map @ reflection!.type))
                          return (|> method
                                     java/lang/reflect/Method::getGenericReturnType
                                     reflection!.return)
                          exceptions (|> (java/lang/reflect/Method::getGenericExceptionTypes method)
                                         array.to-list
                                         (monad.map @ reflection!.generic))]
                         (wrap [(java/lang/reflect/Method::getName method)
                                (jvm.method inputs return exceptions)]))))))]

  [abstract-methods (list.filter (|>> java/lang/reflect/Method::getModifiers java/lang/reflect/Modifier::isAbstract))]
  [methods (<|)]
  )

(def: jvm-package-separator ".")

(template [<name> <methods>]
  [(def: <name>
     (-> (List Class) (Try (List [Text Method])))
     (|>> (monad.map try.monad (|>> product.left reflection!.load))
          (try@map (monad.map try.monad <methods>))
          try@join
          (try@map list@join)))]

  [all-abstract-methods ..abstract-methods]
  [all-methods ..methods]
  )

(template [<name>]
  [(exception: #export (<name> {methods (List [Text Method])})
     (exception.report
      ["Methods" (exception.enumerate
                  (function (_ [name method])
                    (format (%.text name) " " (jvm.method-signature method)))
                  methods)]))]

  [missing-abstract-methods]
  [invalid-overriden-methods]
  )

(type: #export Visibility
  #PublicV
  #PrivateV
  #ProtectedV
  #DefaultV)

(type: #export Finality Bit)
(type: #export Strictness Bit)

(def: #export public-tag "public")
(def: #export private-tag "private")
(def: #export protected-tag "protected")
(def: #export default-tag "default")

(def: #export visibility
  (Parser Visibility)
  ($_ <>.or
      (<c>.text! ..public-tag)
      (<c>.text! ..private-tag)
      (<c>.text! ..protected-tag)
      (<c>.text! ..default-tag)))

(type: #export (Constructor a)
  [Visibility
   Strictness
   (List (Annotation a))
   (List Var)
   (List Class) ## Exceptions
   Text
   (List Argument)
   (List (Typed a))
   a])

(def: #export constructor-tag "init")

(def: #export constructor-definition
  (Parser (Constructor Code))
  (<| <c>.form
      (<>.after (<c>.text! ..constructor-tag))
      ($_ <>.and
          ..visibility
          <c>.bit
          (<c>.tuple (<>.some ..annotation))
          (<c>.tuple (<>.some ..var))
          (<c>.tuple (<>.some ..class))
          <c>.text
          (<c>.tuple (<>.some ..argument))
          (<c>.tuple (<>.some ..typed))
          <c>.any)))

(def: #export (analyse-constructor-method analyse selfT mapping method)
  (-> Phase .Type Mapping (Constructor Code) (Operation Analysis))
  (let [[visibility strict-fp?
         annotations vars exceptions
         self-name arguments super-arguments body] method]
    (do ////.monad
      [annotationsA (monad.map @ (function (_ [name parameters])
                                   (do @
                                     [parametersA (monad.map @ (function (_ [name value])
                                                                 (do @
                                                                   [valueA (analyse value)]
                                                                   (wrap [name valueA])))
                                                             parameters)]
                                     (wrap [name parametersA])))
                               annotations)
       super-arguments (monad.map @ (function (_ [jvmT super-argC])
                                      (do @
                                        [luxT (typeA.with-env
                                                (luxT.type mapping jvmT))
                                         super-argA (typeA.with-type luxT
                                                      (analyse super-argC))]
                                        (wrap [jvmT super-argA])))
                                  super-arguments)
       arguments' (typeA.with-env
                    (monad.map check.monad
                               (function (_ [name jvmT])
                                 (do check.monad
                                   [luxT (luxT.type mapping jvmT)]
                                   (wrap [name luxT])))
                               arguments))
       [scope bodyA] (|> arguments'
                         (#.Cons [self-name selfT])
                         list.reverse
                         (list@fold scope.with-local (analyse body))
                         (typeA.with-type .Any)
                         /////analysis.with-scope)]
      (wrap (/////analysis.tuple (list (/////analysis.text ..constructor-tag)
                                       (/////analysis.text (case visibility
                                                             #PublicV ..public-tag
                                                             #PrivateV ..private-tag
                                                             #ProtectedV ..protected-tag
                                                             #DefaultV ..default-tag))
                                       (/////analysis.bit strict-fp?)
                                       (/////analysis.tuple (list@map annotation-analysis annotationsA))
                                       (/////analysis.tuple (list@map var-analysis vars))
                                       (/////analysis.text self-name)
                                       (/////analysis.tuple (list@map (function (_ [argument argumentJT])
                                                                        (/////analysis.tuple
                                                                         (list (/////analysis.text argument)
                                                                               (type-analysis argumentJT))))
                                                                      arguments))
                                       (/////analysis.tuple (list@map class-analysis
                                                                      exceptions))
                                       (/////analysis.tuple (list@map typed-analysis
                                                                      super-arguments))
                                       (#/////analysis.Function
                                        (scope.environment scope)
                                        (/////analysis.tuple (list bodyA)))
                                       ))))))

(type: #export (Virtual-Method a)
  [Text
   Visibility
   Finality
   Strictness
   (List (Annotation a))
   (List Var)
   Text
   (List Argument)
   Return
   (List Class) ## Exceptions
   a])

(def: virtual-tag "virtual")

(def: #export virtual-method-definition
  (Parser (Virtual-Method Code))
  (<| <c>.form
      (<>.after (<c>.text! ..virtual-tag))
      ($_ <>.and
          <c>.text
          ..visibility
          <c>.bit
          <c>.bit
          (<c>.tuple (<>.some ..annotation))
          (<c>.tuple (<>.some ..var))
          <c>.text
          (<c>.tuple (<>.some ..argument))
          ..return
          (<c>.tuple (<>.some ..class))
          <c>.any)))

(def: #export (analyse-virtual-method analyse selfT mapping method)
  (-> Phase .Type Mapping (Virtual-Method Code) (Operation Analysis))
  (let [[method-name visibility
         final? strict-fp? annotations vars
         self-name arguments return exceptions
         body] method]
    (do ////.monad
      [annotationsA (monad.map @ (function (_ [name parameters])
                                   (do @
                                     [parametersA (monad.map @ (function (_ [name value])
                                                                 (do @
                                                                   [valueA (analyse value)]
                                                                   (wrap [name valueA])))
                                                             parameters)]
                                     (wrap [name parametersA])))
                               annotations)
       returnT (typeA.with-env
                 (luxT.return mapping return))
       arguments' (typeA.with-env
                    (monad.map check.monad
                               (function (_ [name jvmT])
                                 (do check.monad
                                   [luxT (luxT.type mapping jvmT)]
                                   (wrap [name luxT])))
                               arguments))
       [scope bodyA] (|> arguments'
                         (#.Cons [self-name selfT])
                         list.reverse
                         (list@fold scope.with-local (analyse body))
                         (typeA.with-type returnT)
                         /////analysis.with-scope)]
      (wrap (/////analysis.tuple (list (/////analysis.text ..virtual-tag)
                                       (/////analysis.text method-name)
                                       (/////analysis.text (case visibility
                                                             #PublicV ..public-tag
                                                             #PrivateV ..private-tag
                                                             #ProtectedV ..protected-tag
                                                             #DefaultV ..default-tag))
                                       (/////analysis.bit final?)
                                       (/////analysis.bit strict-fp?)
                                       (/////analysis.tuple (list@map annotation-analysis annotationsA))
                                       (/////analysis.tuple (list@map var-analysis vars))
                                       (/////analysis.text self-name)
                                       (/////analysis.tuple (list@map (function (_ [argument argumentJT])
                                                                        (/////analysis.tuple
                                                                         (list (/////analysis.text argument)
                                                                               (type-analysis argumentJT))))
                                                                      arguments))
                                       (return-analysis return)
                                       (/////analysis.tuple (list@map class-analysis
                                                                      exceptions))
                                       (#/////analysis.Function
                                        (scope.environment scope)
                                        (/////analysis.tuple (list bodyA)))
                                       ))))))

(type: #export (Static-Method a)
  [Text
   Visibility
   Strictness
   (List (Annotation a))
   (List Var)
   (List Class) ## Exceptions
   (List Argument)
   Return
   a])

(def: #export static-tag "static")

(def: #export static-method-definition
  (Parser (Static-Method Code))
  (<| <c>.form
      (<>.after (<c>.text! ..static-tag))
      ($_ <>.and
          <c>.text
          ..visibility
          <c>.bit
          (<c>.tuple (<>.some ..annotation))
          (<c>.tuple (<>.some ..var))
          (<c>.tuple (<>.some ..class))
          (<c>.tuple (<>.some ..argument))
          ..return
          <c>.any)))

(def: #export (analyse-static-method analyse mapping method)
  (-> Phase Mapping (Static-Method Code) (Operation Analysis))
  (let [[method-name visibility
         strict-fp? annotations vars exceptions
         arguments return
         body] method]
    (do ////.monad
      [annotationsA (monad.map @ (function (_ [name parameters])
                                   (do @
                                     [parametersA (monad.map @ (function (_ [name value])
                                                                 (do @
                                                                   [valueA (analyse value)]
                                                                   (wrap [name valueA])))
                                                             parameters)]
                                     (wrap [name parametersA])))
                               annotations)
       returnT (typeA.with-env
                 (luxT.return mapping return))
       arguments' (typeA.with-env
                    (monad.map check.monad
                               (function (_ [name jvmT])
                                 (do check.monad
                                   [luxT (luxT.type mapping jvmT)]
                                   (wrap [name luxT])))
                               arguments))
       [scope bodyA] (|> arguments'
                         list.reverse
                         (list@fold scope.with-local (analyse body))
                         (typeA.with-type returnT)
                         /////analysis.with-scope)]
      (wrap (/////analysis.tuple (list (/////analysis.text ..static-tag)
                                       (/////analysis.text method-name)
                                       (/////analysis.text (case visibility
                                                             #PublicV ..public-tag
                                                             #PrivateV ..private-tag
                                                             #ProtectedV ..protected-tag
                                                             #DefaultV ..default-tag))
                                       (/////analysis.bit strict-fp?)
                                       (/////analysis.tuple (list@map annotation-analysis annotationsA))
                                       (/////analysis.tuple (list@map var-analysis vars))
                                       (/////analysis.tuple (list@map (function (_ [argument argumentJT])
                                                                        (/////analysis.tuple
                                                                         (list (/////analysis.text argument)
                                                                               (type-analysis argumentJT))))
                                                                      arguments))
                                       (return-analysis return)
                                       (/////analysis.tuple (list@map class-analysis
                                                                      exceptions))
                                       (#/////analysis.Function
                                        (scope.environment scope)
                                        (/////analysis.tuple (list bodyA)))
                                       ))))))

(type: #export (Overriden-Method a)
  [Class
   Text
   Bit
   (List (Annotation a))
   (List Var)
   Text
   (List Argument)
   Return
   (List Class)
   a])

(def: #export overriden-tag "override")

(def: #export overriden-method-definition
  (Parser (Overriden-Method Code))
  (<| <c>.form
      (<>.after (<c>.text! ..overriden-tag))
      ($_ <>.and
          ..class
          <c>.text
          <c>.bit
          (<c>.tuple (<>.some ..annotation))
          (<c>.tuple (<>.some ..var))
          <c>.text
          (<c>.tuple (<>.some ..argument))
          ..return
          (<c>.tuple (<>.some ..class))
          <c>.any
          )))

(def: #export (analyse-overriden-method analyse selfT mapping method)
  (-> Phase .Type Mapping (Overriden-Method Code) (Operation Analysis))
  (let [[parent-type method-name
         strict-fp? annotations vars
         self-name arguments return exceptions
         body] method]
    (do ////.monad
      [annotationsA (monad.map @ (function (_ [name parameters])
                                   (do @
                                     [parametersA (monad.map @ (function (_ [name value])
                                                                 (do @
                                                                   [valueA (analyse value)]
                                                                   (wrap [name valueA])))
                                                             parameters)]
                                     (wrap [name parametersA])))
                               annotations)
       returnT (typeA.with-env
                 (luxT.return mapping return))
       arguments' (typeA.with-env
                    (monad.map check.monad
                               (function (_ [name jvmT])
                                 (do check.monad
                                   [luxT (luxT.type mapping jvmT)]
                                   (wrap [name luxT])))
                               arguments))
       [scope bodyA] (|> arguments'
                         (#.Cons [self-name selfT])
                         list.reverse
                         (list@fold scope.with-local (analyse body))
                         (typeA.with-type returnT)
                         /////analysis.with-scope)]
      (wrap (/////analysis.tuple (list (/////analysis.text ..overriden-tag)
                                       (class-analysis parent-type)
                                       (/////analysis.text method-name)
                                       (/////analysis.bit strict-fp?)
                                       (/////analysis.tuple (list@map annotation-analysis annotationsA))
                                       (/////analysis.tuple (list@map var-analysis vars))
                                       (/////analysis.text self-name)
                                       (/////analysis.tuple (list@map (function (_ [argument argumentJT])
                                                                        (/////analysis.tuple
                                                                         (list (/////analysis.text argument)
                                                                               (type-analysis argumentJT))))
                                                                      arguments))
                                       (return-analysis return)
                                       (/////analysis.tuple (list@map class-analysis
                                                                      exceptions))
                                       (#/////analysis.Function
                                        (scope.environment scope)
                                        (/////analysis.tuple (list bodyA)))
                                       ))))))

(type: #export (Method-Definition a)
  (#Overriden-Method (Overriden-Method a)))

(def: #export parameter-types
  (-> (List Var) (Check (List [Var .Type])))
  (monad.map check.monad
             (function (_ parameterJ)
               (do check.monad
                 [[_ parameterT] check.existential]
                 (wrap [parameterJ parameterT])))))

(def: (mismatched-methods super-set sub-set)
  (-> (List [Text Method]) (List [Text Method]) (List [Text Method]))
  (list.filter (function (_ [sub-name subJT])
                 (|> super-set
                     (list.filter (function (_ [super-name superJT])
                                    (and (text@= super-name sub-name)
                                         (method@= superJT subJT))))
                     list.size
                     (n.= 1)
                     not))
               sub-set))

(exception: #export (class-parameter-mismatch {expected (List Text)}
                                              {actual (List jvm.Generic)})
  (exception.report
   ["Expected (amount)" (%.nat (list.size expected))]
   ["Expected (parameters)" (exception.enumerate %.text expected)]
   ["Actual (amount)" (%.nat (list.size actual))]
   ["Actual (parameters)" (exception.enumerate (|>> #jvm.Generic jvm.signature) actual)]))

(type: Renamer (Dictionary Text Text))

(def: (re-map-super [name actual-parameters])
  (-> Class (Operation Renamer))
  (do ////.monad
    [class (////.lift (reflection!.load name))
     #let [expected-parameters (|> (java/lang/Class::getTypeParameters class)
                                   array.to-list
                                   (list@map (|>> java/lang/reflect/TypeVariable::getName)))]
     _ (////.assert ..class-parameter-mismatch [expected-parameters actual-parameters]
                    (n.= (list.size expected-parameters)
                         (list.size actual-parameters)))]
    (wrap (|> (list.zip2 expected-parameters actual-parameters)
              (list@fold (function (_ [expected actual] mapping)
                           (case actual
                             (#jvm.Var actual)
                             (dictionary.put actual expected mapping)
                             
                             _
                             mapping))
                         (dictionary.new text.hash))))))

(def: (re-map-generic mapping generic)
  (-> Renamer jvm.Generic jvm.Generic)
  (case generic
    (#jvm.Var var)
    (#jvm.Var (|> mapping (dictionary.get var) (maybe.default var)))
    
    (#jvm.Wildcard wildcard)
    (case wildcard
      #.None
      generic
      
      (#.Some [bound limit])
      (#jvm.Wildcard (#.Some [bound (re-map-generic mapping limit)])))
    
    (#jvm.Class name parameters)
    (#jvm.Class name (list@map (re-map-generic mapping) parameters))))

(def: (re-map-type mapping type)
  (-> Renamer jvm.Type jvm.Type)
  (case type
    (#jvm.Primitive primitive)
    type
    
    (#jvm.Generic generic)
    (#jvm.Generic (re-map-generic mapping generic))
    
    (#jvm.Array type)
    (#jvm.Array (re-map-type mapping type))))

(def: (re-map-return mapping return)
  (-> Renamer jvm.Return jvm.Return)
  (case return
    #.None
    return

    (#.Some return)
    (#.Some (re-map-type mapping return))))

(def: (re-map-method mapping [inputs output exceptions])
  (-> Renamer jvm.Method jvm.Method)
  [(list@map (re-map-type mapping) inputs)
   (re-map-return mapping output)
   (list@map (re-map-generic mapping) exceptions)])

(def: class::anonymous
  Handler
  (..custom
   [($_ <>.and
        (<c>.tuple (<>.some ..var))
        ..class
        (<c>.tuple (<>.some ..class))
        (<c>.tuple (<>.some ..typed))
        (<c>.tuple (<>.some ..overriden-method-definition)))
    (function (_ extension-name analyse [parameters
                                         super-class
                                         super-interfaces
                                         constructor-args
                                         methods])
      (do ////.monad
        [parameters (typeA.with-env
                      (..parameter-types parameters))
         #let [mapping (list@fold (function (_ [parameterJ parameterT] mapping)
                                    (dictionary.put parameterJ parameterT mapping))
                                  luxT.fresh
                                  parameters)]
         name (///.lift (do macro.monad
                          [where macro.current-module-name
                           id macro.count]
                          (wrap (format (text.replace-all .module-separator ..jvm-package-separator where)
                                        ..jvm-package-separator
                                        "anonymous-class" (%.nat id)))))
         super-classT (typeA.with-env
                        (luxT.class mapping super-class))
         super-interfaceT+ (typeA.with-env
                             (monad.map check.monad
                                        (luxT.class mapping)
                                        super-interfaces))
         #let [selfT (inheritance-relationship-type (#.Primitive name (list))
                                                    super-classT
                                                    super-interfaceT+)]
         constructor-argsA+ (monad.map @ (function (_ [type term])
                                           (do @
                                             [argT (typeA.with-env
                                                     (luxT.type mapping type))
                                              termA (typeA.with-type argT
                                                      (analyse term))]
                                             (wrap [type termA])))
                                       constructor-args)
         methodsA (monad.map @ (analyse-overriden-method analyse selfT mapping) methods)
         required-abstract-methods (////.lift (all-abstract-methods (list& super-class super-interfaces)))
         available-methods (////.lift (all-methods (list& super-class super-interfaces)))
         overriden-methods (monad.map @ (function (_ [parent-type method-name
                                                      strict-fp? annotations vars
                                                      self-name arguments return exceptions
                                                      body])
                                          (do @
                                            [re-mapping (re-map-super parent-type)]
                                            (wrap [method-name (re-map-method re-mapping
                                                                              (jvm.method (list@map product.right arguments)
                                                                                          return
                                                                                          (list@map (|>> #jvm.Class) exceptions)))])))
                                      methods)
         #let [missing-abstract-methods (mismatched-methods overriden-methods required-abstract-methods)
               invalid-overriden-methods (mismatched-methods available-methods overriden-methods)]
         _ (typeA.infer selfT)
         _ (////.assert ..missing-abstract-methods missing-abstract-methods
                        (list.empty? missing-abstract-methods))
         _ (////.assert ..invalid-overriden-methods invalid-overriden-methods
                        (list.empty? invalid-overriden-methods))]
        (wrap (#/////analysis.Extension extension-name
                                        (list (/////analysis.text name)
                                              (class-analysis super-class)
                                              (/////analysis.tuple (list@map class-analysis super-interfaces))
                                              (/////analysis.tuple (list@map typed-analysis constructor-argsA+))
                                              (/////analysis.tuple methodsA))))
        ))]))

(def: bundle::class
  Bundle
  (<| (///bundle.prefix "class")
      (|> ///bundle.empty
          (///bundle.install "anonymous" class::anonymous)
          )))

(def: #export bundle
  Bundle
  (<| (///bundle.prefix "jvm")
      (|> ///bundle.empty
          (dictionary.merge bundle::conversion)
          (dictionary.merge bundle::int)
          (dictionary.merge bundle::long)
          (dictionary.merge bundle::float)
          (dictionary.merge bundle::double)
          (dictionary.merge bundle::char)
          (dictionary.merge bundle::array)
          (dictionary.merge bundle::object)
          (dictionary.merge bundle::member)
          (dictionary.merge bundle::class)
          )))
