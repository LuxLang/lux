(.module:
  [lux (#- Type primitive type char int)
   ["." host (#+ import:)]
   ["." macro]
   [abstract
    ["." monad (#+ do)]]
   [control
    pipe
    ["." try (#+ Try) ("#@." monad)]
    ["." exception (#+ exception:)]
    ["<>" parser
     ["<c>" code (#+ Parser)]
     ["<t>" text]]]
   [data
    ["." maybe]
    ["." product]
    [number
     ["n" nat]]
    ["." text ("#@." equivalence)
     ["%" format (#+ format)]]
    [collection
     ["." list ("#@." fold monad monoid)]
     ["." array]
     ["." dictionary (#+ Dictionary)]]]
   ["." type
    ["." check (#+ Check) ("#@." monad)]]
   [target
    ["." jvm #_
     [".!" reflection]
     [encoding
      [name (#+ External)]]
     ["#" type (#+ Type Argument Typed) ("#@." equivalence)
      ["." category (#+ Void Value Return Primitive Object Class Array Var Parameter Method)]
      ["." box]
      ["." reflection]
      ["." descriptor (#+ Descriptor)]
      ["." signature (#+ Signature) ("#@." equivalence)]
      ["#-." parser]
      ["#-." alias (#+ Aliasing)]
      [".T" lux (#+ Mapping)]]]]]
  ["." // #_
   ["#." lux (#+ custom)]
   ["/#" //
    ["#." bundle]
    ["/#" // ("#@." monad)
     [analysis
      [".A" type]
      [".A" inference]
      ["." scope]]
     ["/#" // #_
      [reference (#+)]
      ["#." analysis (#+ Analysis Operation Phase Handler Bundle)]
      ["#." synthesis]]]]])

(def: reflection (|>> jvm.reflection reflection.reflection))
(def: signature (|>> jvm.signature signature.signature))

(def: object-class "java.lang.Object")

(def: inheritance-relationship-type-name "_jvm_inheritance")
(def: #export (inheritance-relationship-type class super-class super-interfaces)
  (-> .Type .Type (List .Type) .Type)
  (#.Primitive ..inheritance-relationship-type-name
               (list& class super-class super-interfaces)))

## TODO: Get rid of this template block and use the definition in
## lux/host.jvm.lux ASAP
(template [<name> <class>]
  [(def: #export <name> .Type (#.Primitive <class> #.Nil))]

  ## Boxes
  [Boolean   box.boolean]
  [Byte      box.byte]
  [Short     box.short]
  [Integer   box.int]
  [Long      box.long]
  [Float     box.float]
  [Double    box.double]
  [Character box.char]
  [String    "java.lang.String"]

  ## Primitives
  [boolean   (reflection.reflection reflection.boolean)]
  [byte      (reflection.reflection reflection.byte)]
  [short     (reflection.reflection reflection.short)]
  [int       (reflection.reflection reflection.int)]
  [long      (reflection.reflection reflection.long)]
  [float     (reflection.reflection reflection.float)]
  [double    (reflection.reflection reflection.double)]
  [char      (reflection.reflection reflection.char)]
  )

(type: Member
  {#class External
   #member Text})

(def: member
  (Parser Member)
  ($_ <>.and <c>.text <c>.text))

(type: Method-Signature
  {#method .Type
   #exceptions (List .Type)})

(template [<name>]
  [(exception: #export (<name> {type .Type})
     (exception.report
      ["Type" (%.type type)]))]

  [non-object]
  [non-array]
  [non-parameter]
  [non-jvm-type]
  )

(template [<name>]
  [(exception: #export (<name> {class External})
     (exception.report
      ["Class/type" (%.text class)]))]

  [non-interface]
  [non-throwable]
  [primitives-are-not-objects]
  )

(exception: #export (cannot-set-a-final-field {field Text} {class External})
  (exception.report
   ["Field" (%.text field)]
   ["Class" (%.text class)]))

(template [<name>]
  [(exception: #export (<name> {class External}
                               {method Text}
                               {inputsJT (List (Type Value))}
                               {hints (List Method-Signature)})
     (exception.report
      ["Class" class]
      ["Method" method]
      ["Arguments" (exception.enumerate ..signature inputsJT)]
      ["Hints" (exception.enumerate %.type (list@map product.left hints))]))]

  [no-candidates]
  [too-many-candidates]
  )

(exception: #export (cannot-cast {from .Type} {to .Type} {value Code})
  (exception.report
   ["From" (%.type from)]
   ["To" (%.type to)]
   ["Value" (%.code value)]))

(template [<name>]
  [(exception: #export (<name> {message Text})
     message)]

  [primitives-cannot-have-type-parameters]

  [cannot-possibly-be-an-instance]

  [unknown-type-var]
  )

(def: bundle::conversion
  Bundle
  (<| (///bundle.prefix "conversion")
      (|> ///bundle.empty
          (///bundle.install "double-to-float" (//lux.unary ..double ..float))
          (///bundle.install "double-to-int" (//lux.unary ..double ..int))
          (///bundle.install "double-to-long" (//lux.unary ..double ..long))
          (///bundle.install "float-to-double" (//lux.unary ..float ..double))
          (///bundle.install "float-to-int" (//lux.unary ..float ..int))
          (///bundle.install "float-to-long" (//lux.unary ..float ..long))
          (///bundle.install "int-to-byte" (//lux.unary ..int ..byte))
          (///bundle.install "int-to-char" (//lux.unary ..int ..char))
          (///bundle.install "int-to-double" (//lux.unary ..int ..double))
          (///bundle.install "int-to-float" (//lux.unary ..int ..float))
          (///bundle.install "int-to-long" (//lux.unary ..int ..long))
          (///bundle.install "int-to-short" (//lux.unary ..int ..short))
          (///bundle.install "long-to-double" (//lux.unary ..long ..double))
          (///bundle.install "long-to-float" (//lux.unary ..long ..float))
          (///bundle.install "long-to-int" (//lux.unary ..long ..int))
          (///bundle.install "long-to-short" (//lux.unary ..long ..short))
          (///bundle.install "long-to-byte" (//lux.unary ..long ..byte))
          (///bundle.install "char-to-byte" (//lux.unary ..char ..byte))
          (///bundle.install "char-to-short" (//lux.unary ..char ..short))
          (///bundle.install "char-to-int" (//lux.unary ..char ..int))
          (///bundle.install "char-to-long" (//lux.unary ..char ..long))
          (///bundle.install "byte-to-long" (//lux.unary ..byte ..long))
          (///bundle.install "short-to-long" (//lux.unary ..short ..long))
          )))

(template [<name> <prefix> <type>]
  [(def: <name>
     Bundle
     (<| (///bundle.prefix (reflection.reflection <prefix>))
         (|> ///bundle.empty
             (///bundle.install "+" (//lux.binary <type> <type> <type>))
             (///bundle.install "-" (//lux.binary <type> <type> <type>))
             (///bundle.install "*" (//lux.binary <type> <type> <type>))
             (///bundle.install "/" (//lux.binary <type> <type> <type>))
             (///bundle.install "%" (//lux.binary <type> <type> <type>))
             (///bundle.install "=" (//lux.binary <type> <type> Bit))
             (///bundle.install "<" (//lux.binary <type> <type> Bit))
             (///bundle.install "and" (//lux.binary <type> <type> <type>))
             (///bundle.install "or" (//lux.binary <type> <type> <type>))
             (///bundle.install "xor" (//lux.binary <type> <type> <type>))
             (///bundle.install "shl" (//lux.binary <type> Integer <type>))
             (///bundle.install "shr" (//lux.binary <type> Integer <type>))
             (///bundle.install "ushr" (//lux.binary <type> Integer <type>))
             )))]

  [bundle::int  reflection.int  ..long]
  [bundle::long reflection.long ..long]
  )

(template [<name> <prefix> <type>]
  [(def: <name>
     Bundle
     (<| (///bundle.prefix (reflection.reflection <prefix>))
         (|> ///bundle.empty
             (///bundle.install "+" (//lux.binary <type> <type> <type>))
             (///bundle.install "-" (//lux.binary <type> <type> <type>))
             (///bundle.install "*" (//lux.binary <type> <type> <type>))
             (///bundle.install "/" (//lux.binary <type> <type> <type>))
             (///bundle.install "%" (//lux.binary <type> <type> <type>))
             (///bundle.install "=" (//lux.binary <type> <type> Bit))
             (///bundle.install "<" (//lux.binary <type> <type> Bit))
             )))]

  [bundle::float  reflection.float  ..float]
  [bundle::double reflection.double ..double]
  )

(def: bundle::char
  Bundle
  (<| (///bundle.prefix (reflection.reflection reflection.char))
      (|> ///bundle.empty
          (///bundle.install "=" (//lux.binary ..char ..char Bit))
          (///bundle.install "<" (//lux.binary ..char ..char Bit))
          )))

(def: #export boxes
  (Dictionary External [External (Type Primitive)])
  (|> (list [(reflection.reflection reflection.boolean) [box.boolean jvm.boolean]]
            [(reflection.reflection reflection.byte)    [box.byte jvm.byte]]
            [(reflection.reflection reflection.short)   [box.short jvm.short]]
            [(reflection.reflection reflection.int)     [box.int jvm.int]]
            [(reflection.reflection reflection.long)    [box.long jvm.long]]
            [(reflection.reflection reflection.float)   [box.float jvm.float]]
            [(reflection.reflection reflection.double)  [box.double jvm.double]]
            [(reflection.reflection reflection.char)    [box.char jvm.char]])
      (dictionary.from-list text.hash)))

(def: (jvm-type luxT)
  (-> .Type (Operation (Type Value)))
  (case luxT
    (#.Named name anonymousT)
    (jvm-type anonymousT)
    
    (#.Apply inputT abstractionT)
    (case (type.apply (list inputT) abstractionT)
      (#.Some outputT)
      (jvm-type outputT)

      #.None
      (/////analysis.throw ..non-jvm-type luxT))

    (^ (#.Primitive (static array.type-name) (list elemT)))
    (////@map jvm.array (jvm-type elemT))

    (#.Primitive class parametersT)
    (case (dictionary.get class ..boxes)
      (#.Some [_ primitive-type])
      (case parametersT
        #.Nil
        (////@wrap primitive-type)

        _
        (/////analysis.throw ..primitives-cannot-have-type-parameters class))

      #.None
      (do ////.monad
        [parametersJT (: (Operation (List (Type Parameter)))
                         (monad.map @
                                    (function (_ parameterT)
                                      (do ////.monad
                                        [parameterJT (jvm-type parameterT)]
                                        (case (jvm-parser.parameter? parameterJT)
                                          (#.Some parameterJT)
                                          (wrap parameterJT)
                                          
                                          #.None
                                          (/////analysis.throw ..non-parameter parameterT))))
                                    parametersT))]
        (wrap (jvm.class class parametersJT))))

    (#.Ex _)
    (////@wrap (jvm.class ..object-class (list)))
    
    _
    (/////analysis.throw ..non-jvm-type luxT)))

(def: (jvm-array-type objectT)
  (-> .Type (Operation (Type Array)))
  (do ////.monad
    [objectJ (jvm-type objectT)]
    (|> objectJ
        ..signature
        (<t>.run jvm-parser.array)
        ////.lift)))

(def: (primitive-array-length-handler primitive-type)
  (-> (Type Primitive) Handler)
  (function (_ extension-name analyse args)
    (case args
      (^ (list arrayC))
      (do ////.monad
        [_ (typeA.infer ..int)
         arrayA (typeA.with-type (#.Primitive (|> (jvm.array primitive-type) ..reflection)
                                              (list))
                  (analyse arrayC))]
        (wrap (#/////analysis.Extension extension-name (list arrayA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: array::length::object
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list arrayC))
      (do ////.monad
        [_ (typeA.infer ..int)
         [var-id varT] (typeA.with-env check.var)
         arrayA (typeA.with-type (.type (array.Array varT))
                  (analyse arrayC))
         varT (typeA.with-env (check.clean varT))
         arrayJT (jvm-array-type (.type (array.Array varT)))]
        (wrap (#/////analysis.Extension extension-name (list (/////analysis.text (..signature arrayJT))
                                                             arrayA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: (new-primitive-array-handler primitive-type)
  (-> (Type Primitive) Handler)
  (function (_ extension-name analyse args)
    (case args
      (^ (list lengthC))
      (do ////.monad
        [lengthA (typeA.with-type ..int
                   (analyse lengthC))
         _ (typeA.infer (#.Primitive (|> (jvm.array primitive-type) ..reflection)
                                     (list)))]
        (wrap (#/////analysis.Extension extension-name (list lengthA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: array::new::object
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list lengthC))
      (do ////.monad
        [lengthA (typeA.with-type ..int
                   (analyse lengthC))
         expectedT (///.lift macro.expected-type)
         expectedJT (jvm-array-type expectedT)
         elementJT (case (jvm-parser.array? expectedJT)
                     (#.Some elementJT)
                     (wrap elementJT)
                     
                     #.None
                     (/////analysis.throw ..non-array expectedT))]
        (wrap (#/////analysis.Extension extension-name (list (/////analysis.text (..signature elementJT))
                                                             lengthA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: (check-parameter objectT)
  (-> .Type (Operation (Type Parameter)))
  (case objectT
    (^ (#.Primitive (static array.type-name)
                    (list elementT)))
    (/////analysis.throw ..non-parameter objectT)
    
    (#.Primitive name parameters)
    (`` (cond (or (~~ (template [<type>]
                        [(text@= (..reflection <type>) name)]

                        [jvm.boolean]
                        [jvm.byte]
                        [jvm.short]
                        [jvm.int]
                        [jvm.long]
                        [jvm.float]
                        [jvm.double]
                        [jvm.char]))
                  (text.starts-with? descriptor.array-prefix name))
              (/////analysis.throw ..non-parameter objectT)

              ## else
              (////@wrap (jvm.class name (list)))))

    (#.Named name anonymous)
    (check-parameter anonymous)

    (^template [<tag>]
      (<tag> id)
      (////@wrap (jvm.class ..object-class (list))))
    ([#.Var]
     [#.Ex])

    (^template [<tag>]
      (<tag> env unquantified)
      (check-parameter unquantified))
    ([#.UnivQ]
     [#.ExQ])

    (#.Apply inputT abstractionT)
    (case (type.apply (list inputT) abstractionT)
      (#.Some outputT)
      (check-parameter outputT)

      #.None
      (/////analysis.throw ..non-parameter objectT))

    _
    (/////analysis.throw ..non-parameter objectT)))

(def: (check-jvm objectT)
  (-> .Type (Operation (Type Value)))
  (case objectT
    (#.Primitive name #.Nil)
    (`` (cond (~~ (template [<type>]
                    [(text@= (..reflection <type>) name)
                     (////@wrap <type>)]

                    [jvm.boolean]
                    [jvm.byte]
                    [jvm.short]
                    [jvm.int]
                    [jvm.long]
                    [jvm.float]
                    [jvm.double]
                    [jvm.char]))

              (~~ (template [<type>]
                    [(text@= (..reflection (jvm.array <type>)) name)
                     (////@wrap (jvm.array <type>))]

                    [jvm.boolean]
                    [jvm.byte]
                    [jvm.short]
                    [jvm.int]
                    [jvm.long]
                    [jvm.float]
                    [jvm.double]
                    [jvm.char]))

              (text.starts-with? descriptor.array-prefix name)
              (let [[_ unprefixed] (maybe.assume (text.split-with descriptor.array-prefix name))]
                (:: ////.monad map jvm.array
                    (check-jvm (#.Primitive unprefixed (list)))))

              ## else
              (////@wrap (jvm.class name (list)))))
    
    (^ (#.Primitive (static array.type-name)
                    (list elementT)))
    (|> elementT
        check-jvm
        (////@map jvm.array))
    
    (#.Primitive name parameters)
    (do ////.monad
      [parameters (monad.map @ check-parameter parameters)]
      (////@wrap (jvm.class name parameters)))

    (#.Named name anonymous)
    (check-jvm anonymous)

    (^template [<tag>]
      (<tag> env unquantified)
      (check-jvm unquantified))
    ([#.UnivQ]
     [#.ExQ])

    (#.Apply inputT abstractionT)
    (case (type.apply (list inputT) abstractionT)
      (#.Some outputT)
      (check-jvm outputT)

      #.None
      (/////analysis.throw ..non-object objectT))

    _
    (check-parameter objectT)))

(def: (check-object objectT)
  (-> .Type (Operation External))
  (do ////.monad
    [name (:: @ map ..reflection (check-jvm objectT))]
    (if (dictionary.contains? name ..boxes)
      (/////analysis.throw ..primitives-are-not-objects [name])
      (////@wrap name))))

(def: (check-return type)
  (-> .Type (Operation (Type Return)))
  (if (is? .Any type)
    (////@wrap jvm.void)
    (check-jvm type)))

(def: (read-primitive-array-handler lux-type jvm-type)
  (-> .Type (Type Primitive) Handler)
  (function (_ extension-name analyse args)
    (case args
      (^ (list idxC arrayC))
      (do ////.monad
        [_ (typeA.infer lux-type)
         idxA (typeA.with-type ..int
                (analyse idxC))
         arrayA (typeA.with-type (#.Primitive (|> (jvm.array jvm-type) ..reflection)
                                              (list))
                  (analyse arrayC))]
        (wrap (#/////analysis.Extension extension-name (list idxA arrayA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 2 (list.size args)]))))

(def: array::read::object
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list idxC arrayC))
      (do ////.monad
        [[var-id varT] (typeA.with-env check.var)
         _ (typeA.infer varT)
         arrayA (typeA.with-type (.type (array.Array varT))
                  (analyse arrayC))
         varT (typeA.with-env
                (check.clean varT))
         arrayJT (jvm-array-type (.type (array.Array varT)))
         idxA (typeA.with-type ..int
                (analyse idxC))]
        (wrap (#/////analysis.Extension extension-name (list (/////analysis.text (..signature arrayJT))
                                                             idxA
                                                             arrayA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 2 (list.size args)]))))

(def: (write-primitive-array-handler lux-type jvm-type)
  (-> .Type (Type Primitive) Handler)
  (let [array-type (#.Primitive (|> (jvm.array jvm-type) ..reflection)
                                (list))]
    (function (_ extension-name analyse args)
      (case args
        (^ (list idxC valueC arrayC))
        (do ////.monad
          [_ (typeA.infer array-type)
           idxA (typeA.with-type ..int
                  (analyse idxC))
           valueA (typeA.with-type lux-type
                    (analyse valueC))
           arrayA (typeA.with-type array-type
                    (analyse arrayC))]
          (wrap (#/////analysis.Extension extension-name (list idxA
                                                               valueA
                                                               arrayA))))

        _
        (/////analysis.throw ///.incorrect-arity [extension-name 3 (list.size args)])))))

(def: array::write::object
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list idxC valueC arrayC))
      (do ////.monad
        [[var-id varT] (typeA.with-env check.var)
         _ (typeA.infer (.type (array.Array varT)))
         arrayA (typeA.with-type (.type (array.Array varT))
                  (analyse arrayC))
         varT (typeA.with-env
                (check.clean varT))
         arrayJT (jvm-array-type (.type (array.Array varT)))
         idxA (typeA.with-type ..int
                (analyse idxC))
         valueA (typeA.with-type varT
                  (analyse valueC))]
        (wrap (#/////analysis.Extension extension-name (list (/////analysis.text (..signature arrayJT))
                                                             idxA
                                                             valueA
                                                             arrayA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 3 (list.size args)]))))

(def: bundle::array
  Bundle
  (<| (///bundle.prefix "array")
      (|> ///bundle.empty
          (dictionary.merge (<| (///bundle.prefix "length")
                                (|> ///bundle.empty
                                    (///bundle.install (reflection.reflection reflection.boolean) (primitive-array-length-handler jvm.boolean))
                                    (///bundle.install (reflection.reflection reflection.byte) (primitive-array-length-handler jvm.byte))
                                    (///bundle.install (reflection.reflection reflection.short) (primitive-array-length-handler jvm.short))
                                    (///bundle.install (reflection.reflection reflection.int) (primitive-array-length-handler jvm.int))
                                    (///bundle.install (reflection.reflection reflection.long) (primitive-array-length-handler jvm.long))
                                    (///bundle.install (reflection.reflection reflection.float) (primitive-array-length-handler jvm.float))
                                    (///bundle.install (reflection.reflection reflection.double) (primitive-array-length-handler jvm.double))
                                    (///bundle.install (reflection.reflection reflection.char) (primitive-array-length-handler jvm.char))
                                    (///bundle.install "object" array::length::object))))
          (dictionary.merge (<| (///bundle.prefix "new")
                                (|> ///bundle.empty
                                    (///bundle.install (reflection.reflection reflection.boolean) (new-primitive-array-handler jvm.boolean))
                                    (///bundle.install (reflection.reflection reflection.byte) (new-primitive-array-handler jvm.byte))
                                    (///bundle.install (reflection.reflection reflection.short) (new-primitive-array-handler jvm.short))
                                    (///bundle.install (reflection.reflection reflection.int) (new-primitive-array-handler jvm.int))
                                    (///bundle.install (reflection.reflection reflection.long) (new-primitive-array-handler jvm.long))
                                    (///bundle.install (reflection.reflection reflection.float) (new-primitive-array-handler jvm.float))
                                    (///bundle.install (reflection.reflection reflection.double) (new-primitive-array-handler jvm.double))
                                    (///bundle.install (reflection.reflection reflection.char) (new-primitive-array-handler jvm.char))
                                    (///bundle.install "object" array::new::object))))
          (dictionary.merge (<| (///bundle.prefix "read")
                                (|> ///bundle.empty
                                    (///bundle.install (reflection.reflection reflection.boolean) (read-primitive-array-handler ..boolean jvm.boolean))
                                    (///bundle.install (reflection.reflection reflection.byte) (read-primitive-array-handler ..byte jvm.byte))
                                    (///bundle.install (reflection.reflection reflection.short) (read-primitive-array-handler ..short jvm.short))
                                    (///bundle.install (reflection.reflection reflection.int) (read-primitive-array-handler ..int jvm.int))
                                    (///bundle.install (reflection.reflection reflection.long) (read-primitive-array-handler ..long jvm.long))
                                    (///bundle.install (reflection.reflection reflection.float) (read-primitive-array-handler ..float jvm.float))
                                    (///bundle.install (reflection.reflection reflection.double) (read-primitive-array-handler ..double jvm.double))
                                    (///bundle.install (reflection.reflection reflection.char) (read-primitive-array-handler ..char jvm.char))
                                    (///bundle.install "object" array::read::object))))
          (dictionary.merge (<| (///bundle.prefix "write")
                                (|> ///bundle.empty
                                    (///bundle.install (reflection.reflection reflection.boolean) (write-primitive-array-handler ..boolean jvm.boolean))
                                    (///bundle.install (reflection.reflection reflection.byte) (write-primitive-array-handler ..byte jvm.byte))
                                    (///bundle.install (reflection.reflection reflection.short) (write-primitive-array-handler ..short jvm.short))
                                    (///bundle.install (reflection.reflection reflection.int) (write-primitive-array-handler ..int jvm.int))
                                    (///bundle.install (reflection.reflection reflection.long) (write-primitive-array-handler ..long jvm.long))
                                    (///bundle.install (reflection.reflection reflection.float) (write-primitive-array-handler ..float jvm.float))
                                    (///bundle.install (reflection.reflection reflection.double) (write-primitive-array-handler ..double jvm.double))
                                    (///bundle.install (reflection.reflection reflection.char) (write-primitive-array-handler ..char jvm.char))
                                    (///bundle.install "object" array::write::object))))
          )))

(def: object::null
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list))
      (do ////.monad
        [expectedT (///.lift macro.expected-type)
         _ (check-object expectedT)]
        (wrap (#/////analysis.Extension extension-name (list))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 0 (list.size args)]))))

(def: object::null?
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list objectC))
      (do ////.monad
        [_ (typeA.infer Bit)
         [objectT objectA] (typeA.with-inference
                             (analyse objectC))
         _ (check-object objectT)]
        (wrap (#/////analysis.Extension extension-name (list objectA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: object::synchronized
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list monitorC exprC))
      (do ////.monad
        [[monitorT monitorA] (typeA.with-inference
                               (analyse monitorC))
         _ (check-object monitorT)
         exprA (analyse exprC)]
        (wrap (#/////analysis.Extension extension-name (list monitorA exprA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 2 (list.size args)]))))

(def: object::throw
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list exceptionC))
      (do ////.monad
        [_ (typeA.infer Nothing)
         [exceptionT exceptionA] (typeA.with-inference
                                   (analyse exceptionC))
         exception-class (check-object exceptionT)
         ? (////.lift (reflection!.sub? "java.lang.Throwable" exception-class))
         _ (: (Operation Any)
              (if ?
                (wrap [])
                (/////analysis.throw non-throwable exception-class)))]
        (wrap (#/////analysis.Extension extension-name (list exceptionA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: object::class
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list classC))
      (case classC
        [_ (#.Text class)]
        (do ////.monad
          [_ (typeA.infer (#.Primitive "java.lang.Class" (list (#.Primitive class (list)))))
           _ (////.lift (reflection!.load class))]
          (wrap (#/////analysis.Extension extension-name (list (/////analysis.text class)))))

        _
        (/////analysis.throw ///.invalid-syntax [extension-name %.code args]))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: object::instance?
  Handler
  (..custom
   [($_ <>.and <c>.text <c>.any)
    (function (_ extension-name analyse [sub-class objectC])
      (do ////.monad
        [_ (typeA.infer Bit)
         [objectT objectA] (typeA.with-inference
                             (analyse objectC))
         object-class (check-object objectT)
         ? (////.lift (reflection!.sub? object-class sub-class))]
        (if ?
          (wrap (#/////analysis.Extension extension-name (list (/////analysis.text sub-class) objectA)))
          (/////analysis.throw cannot-possibly-be-an-instance (format sub-class " !<= "  object-class)))))]))

(import: #long java/lang/Object
  (equals [java/lang/Object] boolean))

(import: #long java/lang/reflect/Type)

(import: #long (java/lang/reflect/TypeVariable d)
  (getName [] java/lang/String)
  (getBounds [] [java/lang/reflect/Type]))

(import: #long java/lang/reflect/Modifier
  (#static isStatic [int] boolean)
  (#static isFinal [int] boolean)
  (#static isInterface [int] boolean)
  (#static isAbstract [int] boolean))

(import: #long java/lang/reflect/Method
  (getName [] java/lang/String)
  (getModifiers [] int)
  (getDeclaringClass [] (java/lang/Class java/lang/Object))
  (getTypeParameters [] [(java/lang/reflect/TypeVariable java/lang/reflect/Method)])
  (getGenericParameterTypes [] [java/lang/reflect/Type])
  (getGenericReturnType [] java/lang/reflect/Type)
  (getGenericExceptionTypes [] [java/lang/reflect/Type]))

(import: #long (java/lang/reflect/Constructor c)
  (getModifiers [] int)
  (getDeclaringClass [] (java/lang/Class c))
  (getTypeParameters [] [(java/lang/reflect/TypeVariable (java/lang/reflect/Constructor c))])
  (getGenericParameterTypes [] [java/lang/reflect/Type])
  (getGenericExceptionTypes [] [java/lang/reflect/Type]))

(import: #long (java/lang/Class c)
  (#static forName [java/lang/String] #try (java/lang/Class java/lang/Object))
  (getName [] java/lang/String)
  (getModifiers [] int)
  (isAssignableFrom [(java/lang/Class java/lang/Object)] boolean)
  (getTypeParameters [] [(java/lang/reflect/TypeVariable (java/lang/Class c))])
  (getGenericInterfaces [] [java/lang/reflect/Type])
  (getGenericSuperclass [] #? java/lang/reflect/Type)
  (getDeclaredField [java/lang/String] #try java/lang/reflect/Field)
  (getConstructors [] [(java/lang/reflect/Constructor java/lang/Object)])
  (getDeclaredMethods [] [java/lang/reflect/Method]))

(def: (reflection-type mapping typeJ)
  (-> Mapping (Type Value) (Operation .Type))
  (case (|> typeJ jvm.signature signature.signature
            (<t>.run (luxT.type mapping)))
    (#try.Success check)
    (typeA.with-env
      check)
    
    (#try.Failure error)
    (////.fail error)))

(def: (reflection-return mapping typeJ)
  (-> Mapping (Type Return) (Operation .Type))
  (case (|> typeJ ..signature (<t>.run (luxT.return mapping)))
    (#try.Success check)
    (typeA.with-env
      check)
    
    (#try.Failure error)
    (////.fail error)))

(def: (class-candidate-parents from-name fromT to-name to-class)
  (-> External .Type External (java/lang/Class java/lang/Object) (Operation (List [[Text .Type] Bit])))
  (do ////.monad
    [from-class (////.lift (reflection!.load from-name))
     mapping (////.lift (reflection!.correspond from-class fromT))]
    (monad.map @
               (function (_ superJT)
                 (do @
                   [superJT (////.lift (reflection!.type superJT))
                    #let [super-name (|> superJT ..reflection)]
                    super-class (////.lift (reflection!.load super-name))
                    superT (reflection-type mapping superJT)]
                   (wrap [[super-name superT] (java/lang/Class::isAssignableFrom super-class to-class)])))
               (case (java/lang/Class::getGenericSuperclass from-class)
                 (#.Some super)
                 (list& super (array.to-list (java/lang/Class::getGenericInterfaces from-class)))

                 #.None
                 (if (java/lang/reflect/Modifier::isInterface (java/lang/Class::getModifiers from-class))
                   (#.Cons (:coerce java/lang/reflect/Type (host.class-for java/lang/Object))
                           (array.to-list (java/lang/Class::getGenericInterfaces from-class)))
                   (array.to-list (java/lang/Class::getGenericInterfaces from-class)))))))

(def: (inheritance-candidate-parents fromT to-class toT fromC)
  (-> .Type (java/lang/Class java/lang/Object) .Type Code (Operation (List [[Text .Type] Bit])))
  (case fromT
    (^ (#.Primitive _ (list& self-classT super-classT super-interfacesT+)))
    (monad.map ////.monad
               (function (_ superT)
                 (do ////.monad
                   [super-name (:: @ map ..reflection (check-jvm superT))
                    super-class (////.lift (reflection!.load super-name))]
                   (wrap [[super-name superT]
                          (java/lang/Class::isAssignableFrom super-class to-class)])))
               (list& super-classT super-interfacesT+))

    _
    (/////analysis.throw cannot-cast [fromT toT fromC])))

(def: object::cast
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list fromC))
      (do ////.monad
        [toT (///.lift macro.expected-type)
         to-name (:: @ map ..reflection (check-jvm toT))
         [fromT fromA] (typeA.with-inference
                         (analyse fromC))
         from-name (:: @ map ..reflection (check-jvm fromT))
         can-cast? (: (Operation Bit)
                      (`` (cond (~~ (template [<primitive> <object>]
                                      [(let [=primitive (reflection.reflection <primitive>)]
                                         (or (and (text@= =primitive from-name)
                                                  (or (text@= <object> to-name)
                                                      (text@= =primitive to-name)))
                                             (and (text@= <object> from-name)
                                                  (text@= =primitive to-name))))
                                       (wrap true)]

                                      [reflection.boolean box.boolean]
                                      [reflection.byte    box.byte]
                                      [reflection.short   box.short]
                                      [reflection.int     box.int]
                                      [reflection.long    box.long]
                                      [reflection.float   box.float]
                                      [reflection.double  box.double]
                                      [reflection.char    box.char]))

                                ## else
                                (do @
                                  [_ (////.assert ..primitives-are-not-objects [from-name]
                                                  (not (dictionary.contains? from-name ..boxes)))
                                   _ (////.assert ..primitives-are-not-objects [to-name]
                                                  (not (dictionary.contains? to-name ..boxes)))
                                   to-class (////.lift (reflection!.load to-name))
                                   _ (if (text@= ..inheritance-relationship-type-name from-name)
                                       (wrap [])
                                       (do @
                                         [from-class (////.lift (reflection!.load from-name))]
                                         (////.assert cannot-cast [fromT toT fromC]
                                                      (java/lang/Class::isAssignableFrom from-class to-class))))]
                                  (loop [[current-name currentT] [from-name fromT]]
                                    (if (text@= to-name current-name)
                                      (wrap true)
                                      (do @
                                        [candidate-parents (: (Operation (List [[Text .Type] Bit]))
                                                              (if (text@= ..inheritance-relationship-type-name current-name)
                                                                (inheritance-candidate-parents currentT to-class toT fromC)
                                                                (class-candidate-parents current-name currentT to-name to-class)))]
                                        (case (|> candidate-parents
                                                  (list.filter product.right)
                                                  (list@map product.left))
                                          (#.Cons [next-name nextT] _)
                                          (recur [next-name nextT])

                                          #.Nil
                                          (/////analysis.throw cannot-cast [fromT toT fromC]))
                                        )))))))]
        (if can-cast?
          (wrap (#/////analysis.Extension extension-name (list (/////analysis.text from-name)
                                                               (/////analysis.text to-name)
                                                               fromA)))
          (/////analysis.throw cannot-cast [fromT toT fromC])))

      _
      (/////analysis.throw ///.invalid-syntax [extension-name %.code args]))))

(def: bundle::object
  Bundle
  (<| (///bundle.prefix "object")
      (|> ///bundle.empty
          (///bundle.install "null" object::null)
          (///bundle.install "null?" object::null?)
          (///bundle.install "synchronized" object::synchronized)
          (///bundle.install "throw" object::throw)
          (///bundle.install "class" object::class)
          (///bundle.install "instance?" object::instance?)
          (///bundle.install "cast" object::cast)
          )))

(def: get::static
  Handler
  (..custom
   [..member
    (function (_ extension-name analyse [class field])
      (do ////.monad
        [[final? fieldJT] (////.lift
                           (do try.monad
                             [class (reflection!.load class)]
                             (reflection!.static-field field class)))
         fieldT (reflection-type luxT.fresh fieldJT)
         _ (typeA.infer fieldT)]
        (wrap (<| (#/////analysis.Extension extension-name)
                  (list (/////analysis.text class)
                        (/////analysis.text field)
                        (/////analysis.text (|> fieldJT ..reflection)))))))]))

(def: put::static
  Handler
  (..custom
   [($_ <>.and ..member <c>.any)
    (function (_ extension-name analyse [[class field] valueC])
      (do ////.monad
        [_ (typeA.infer Any)
         [final? fieldJT] (////.lift
                           (do try.monad
                             [class (reflection!.load class)]
                             (reflection!.static-field field class)))
         fieldT (reflection-type luxT.fresh fieldJT)
         _ (////.assert ..cannot-set-a-final-field [class field]
                        (not final?))
         valueA (typeA.with-type fieldT
                  (analyse valueC))]
        (wrap (<| (#/////analysis.Extension extension-name)
                  (list (/////analysis.text class)
                        (/////analysis.text field)
                        valueA)))))]))

(def: get::virtual
  Handler
  (..custom
   [($_ <>.and ..member <c>.any)
    (function (_ extension-name analyse [[class field] objectC])
      (do ////.monad
        [[objectT objectA] (typeA.with-inference
                             (analyse objectC))
         [mapping fieldJT] (////.lift
                            (do try.monad
                              [class (reflection!.load class)
                               [final? fieldJT] (reflection!.virtual-field field class)
                               mapping (reflection!.correspond class objectT)]
                              (wrap [mapping fieldJT])))
         fieldT (reflection-type mapping fieldJT)
         _ (typeA.infer fieldT)]
        (wrap (<| (#/////analysis.Extension extension-name)
                  (list (/////analysis.text class)
                        (/////analysis.text field)
                        objectA)))))]))

(def: put::virtual
  Handler
  (..custom
   [($_ <>.and ..member <c>.any <c>.any)
    (function (_ extension-name analyse [[class field] valueC objectC])
      (do ////.monad
        [[objectT objectA] (typeA.with-inference
                             (analyse objectC))
         _ (typeA.infer objectT)
         [final? mapping fieldJT] (////.lift
                                   (do try.monad
                                     [class (reflection!.load class)
                                      [final? fieldJT] (reflection!.virtual-field field class)
                                      mapping (reflection!.correspond class objectT)]
                                     (wrap [final? mapping fieldJT])))
         fieldT (reflection-type mapping fieldJT)
         _ (////.assert cannot-set-a-final-field [class field]
                        (not final?))
         valueA (typeA.with-type fieldT
                  (analyse valueC))]
        (wrap (<| (#/////analysis.Extension extension-name)
                  (list (/////analysis.text class)
                        (/////analysis.text field)
                        valueA
                        objectA)))))]))

(type: Method-Style
  #Static
  #Abstract
  #Virtual
  #Special
  #Interface)

(def: (check-method aliasing class method-name method-style inputsJT method)
  (-> Aliasing (java/lang/Class java/lang/Object) Text Method-Style (List (Type Value)) java/lang/reflect/Method (Operation Bit))
  (do ////.monad
    [parameters (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                    array.to-list
                    (monad.map try.monad reflection!.type)
                    ////.lift)
     #let [modifiers (java/lang/reflect/Method::getModifiers method)
           correct-class? (java/lang/Object::equals class (java/lang/reflect/Method::getDeclaringClass method))
           correct-method? (text@= method-name (java/lang/reflect/Method::getName method))
           static-matches? (case method-style
                             #Static
                             (java/lang/reflect/Modifier::isStatic modifiers)

                             _
                             true)
           special-matches? (case method-style
                              #Special
                              (not (or (java/lang/reflect/Modifier::isInterface (java/lang/Class::getModifiers class))
                                       (java/lang/reflect/Modifier::isAbstract modifiers)))

                              _
                              true)
           arity-matches? (n.= (list.size inputsJT) (list.size parameters))
           inputs-match? (list@fold (function (_ [expectedJC actualJC] prev)
                                      (and prev
                                           (jvm@= expectedJC (: (Type Value)
                                                                (case (jvm-parser.var? actualJC)
                                                                  (#.Some name)
                                                                  (|> aliasing
                                                                      (dictionary.get name)
                                                                      (maybe.default name)
                                                                      jvm.var)

                                                                  #.None
                                                                  actualJC)))))
                                    true
                                    (list.zip2 parameters inputsJT))]]
    (wrap (and correct-class?
               correct-method?
               static-matches?
               special-matches?
               arity-matches?
               inputs-match?))))

(def: (check-constructor aliasing class inputsJT constructor)
  (-> Aliasing (java/lang/Class java/lang/Object) (List (Type Value)) (java/lang/reflect/Constructor java/lang/Object) (Operation Bit))
  (do ////.monad
    [parameters (|> (java/lang/reflect/Constructor::getGenericParameterTypes constructor)
                    array.to-list
                    (monad.map try.monad reflection!.type)
                    ////.lift)]
    (wrap (and (java/lang/Object::equals class (java/lang/reflect/Constructor::getDeclaringClass constructor))
               (n.= (list.size inputsJT) (list.size parameters))
               (list@fold (function (_ [expectedJC actualJC] prev)
                            (and prev
                                 (jvm@= expectedJC (: (Type Value)
                                                      (case (jvm-parser.var? actualJC)
                                                        (#.Some name)
                                                        (|> aliasing
                                                            (dictionary.get name)
                                                            (maybe.default name)
                                                            jvm.var)

                                                        #.None
                                                        actualJC)))))
                          true
                          (list.zip2 parameters inputsJT))))))

(def: idx-to-parameter
  (-> Nat .Type)
  (|>> (n.* 2) inc #.Parameter))

(def: (jvm-type-var-mapping owner-tvars method-tvars)
  (-> (List Text) (List Text) [(List .Type) Mapping])
  (let [jvm-tvars (list@compose owner-tvars method-tvars)
        lux-tvars (|> jvm-tvars
                      list.reverse
                      list.enumerate
                      (list@map (function (_ [idx name])
                                  [name (idx-to-parameter idx)]))
                      list.reverse)
        num-owner-tvars (list.size owner-tvars)
        owner-tvarsT (|> lux-tvars (list.take num-owner-tvars) (list@map product.right))
        mapping (dictionary.from-list text.hash lux-tvars)]
    [owner-tvarsT mapping]))

(def: (method-signature method-style method)
  (-> Method-Style java/lang/reflect/Method (Operation Method-Signature))
  (let [owner (java/lang/reflect/Method::getDeclaringClass method)
        owner-tvars (case method-style
                      #Static
                      (list)

                      _
                      (|> (java/lang/Class::getTypeParameters owner)
                          array.to-list
                          (list@map (|>> java/lang/reflect/TypeVariable::getName))))
        method-tvars (|> (java/lang/reflect/Method::getTypeParameters method)
                         array.to-list
                         (list@map (|>> java/lang/reflect/TypeVariable::getName)))
        [owner-tvarsT mapping] (jvm-type-var-mapping owner-tvars method-tvars)]
    (do ////.monad
      [inputsT (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                   array.to-list
                   (monad.map @ (|>> reflection!.type ////.lift))
                   (////@map (monad.map @ (reflection-type mapping)))
                   ////@join)
       outputT (|> method
                   java/lang/reflect/Method::getGenericReturnType
                   reflection!.return
                   ////.lift
                   (////@map (..reflection-return mapping))
                   ////@join)
       exceptionsT (|> (java/lang/reflect/Method::getGenericExceptionTypes method)
                       array.to-list
                       (monad.map @ (|>> reflection!.type ////.lift))
                       (////@map (monad.map @ (reflection-type mapping)))
                       ////@join)
       #let [methodT (<| (type.univ-q (dictionary.size mapping))
                         (type.function (case method-style
                                          #Static
                                          inputsT

                                          _
                                          (list& (#.Primitive (java/lang/Class::getName owner) owner-tvarsT)
                                                 inputsT)))
                         outputT)]]
      (wrap [methodT exceptionsT]))))

(def: (constructor-signature constructor)
  (-> (java/lang/reflect/Constructor java/lang/Object) (Operation Method-Signature))
  (let [owner (java/lang/reflect/Constructor::getDeclaringClass constructor)
        owner-tvars (|> (java/lang/Class::getTypeParameters owner)
                        array.to-list
                        (list@map (|>> java/lang/reflect/TypeVariable::getName)))
        method-tvars (|> (java/lang/reflect/Constructor::getTypeParameters constructor)
                         array.to-list
                         (list@map (|>> java/lang/reflect/TypeVariable::getName)))
        [owner-tvarsT mapping] (jvm-type-var-mapping owner-tvars method-tvars)]
    (do ////.monad
      [inputsT (|> (java/lang/reflect/Constructor::getGenericParameterTypes constructor)
                   array.to-list
                   (monad.map @ (|>> reflection!.type ////.lift))
                   (////@map (monad.map @ (reflection-type mapping)))
                   ////@join)
       exceptionsT (|> (java/lang/reflect/Constructor::getGenericExceptionTypes constructor)
                       array.to-list
                       (monad.map @ (|>> reflection!.type ////.lift))
                       (////@map (monad.map @ (reflection-type mapping)))
                       ////@join)
       #let [objectT (#.Primitive (java/lang/Class::getName owner) owner-tvarsT)
             constructorT (<| (type.univ-q (dictionary.size mapping))
                              (type.function inputsT)
                              objectT)]]
      (wrap [constructorT exceptionsT]))))

(type: Evaluation
  (#Pass Method-Signature)
  (#Hint Method-Signature))

(template [<name> <tag>]
  [(def: <name>
     (-> Evaluation (Maybe Method-Signature))
     (|>> (case> (<tag> output)
                 (#.Some output)

                 _
                 #.None)))]

  [pass! #Pass]
  [hint! #Hint]
  )

(template [<name> <type> <method>]
  [(def: <name>
     (-> <type> (List (Type Var)))
     (|>> <method>
          array.to-list
          (list@map (|>> java/lang/reflect/TypeVariable::getName jvm.var))))]

  [class-type-variables (java/lang/Class java/lang/Object) java/lang/Class::getTypeParameters]
  [constructor-type-variables (java/lang/reflect/Constructor java/lang/Object) java/lang/reflect/Constructor::getTypeParameters]
  [method-type-variables java/lang/reflect/Method java/lang/reflect/Method::getTypeParameters]
  )

(def: (aliasing expected actual)
  (-> (List (Type Var)) (List (Type Var)) Aliasing)
  (|> (list.zip2 (list@map jvm-parser.name actual)
                 (list@map jvm-parser.name expected))
      (dictionary.from-list text.hash)))

(def: (method-candidate actual-class-tvars class-name actual-method-tvars method-name method-style inputsJT)
  (-> (List (Type Var)) External (List (Type Var)) Text Method-Style (List (Type Value)) (Operation Method-Signature))
  (do ////.monad
    [class (////.lift (reflection!.load class-name))
     #let [expected-class-tvars (class-type-variables class)]
     candidates (|> class
                    java/lang/Class::getDeclaredMethods
                    array.to-list
                    (list.filter (|>> java/lang/reflect/Method::getName (text@= method-name)))
                    (monad.map @ (: (-> java/lang/reflect/Method (Operation Evaluation))
                                    (function (_ method)
                                      (do @
                                        [#let [expected-method-tvars (method-type-variables method)
                                               aliasing (dictionary.merge (..aliasing expected-class-tvars actual-class-tvars)
                                                                          (..aliasing expected-method-tvars actual-method-tvars))]
                                         passes? (check-method aliasing class method-name method-style inputsJT method)]
                                        (:: @ map (if passes?
                                                    (|>> #Pass)
                                                    (|>> #Hint))
                                            (method-signature method-style method)))))))]
    (case (list.search-all pass! candidates)
      (#.Cons method #.Nil)
      (wrap method)

      #.Nil
      (/////analysis.throw ..no-candidates [class-name method-name inputsJT (list.search-all hint! candidates)])
      
      candidates
      (/////analysis.throw ..too-many-candidates [class-name method-name inputsJT candidates]))))

(def: constructor-method "<init>")

(def: (constructor-candidate actual-class-tvars class-name actual-method-tvars inputsJT)
  (-> (List (Type Var)) External (List (Type Var)) (List (Type Value)) (Operation Method-Signature))
  (do ////.monad
    [class (////.lift (reflection!.load class-name))
     #let [expected-class-tvars (class-type-variables class)]
     candidates (|> class
                    java/lang/Class::getConstructors
                    array.to-list
                    (monad.map @ (function (_ constructor)
                                   (do @
                                     [#let [expected-method-tvars (constructor-type-variables constructor)
                                            aliasing (dictionary.merge (..aliasing expected-class-tvars actual-class-tvars)
                                                                       (..aliasing expected-method-tvars actual-method-tvars))]
                                      passes? (check-constructor aliasing class inputsJT constructor)]
                                     (:: @ map
                                         (if passes? (|>> #Pass) (|>> #Hint))
                                         (constructor-signature constructor))))))]
    (case (list.search-all pass! candidates)
      (#.Cons constructor #.Nil)
      (wrap constructor)

      #.Nil
      (/////analysis.throw ..no-candidates [class-name ..constructor-method inputsJT (list.search-all hint! candidates)])
      
      candidates
      (/////analysis.throw ..too-many-candidates [class-name ..constructor-method inputsJT candidates]))))

(template [<name> <category> <parser>]
  [(def: #export <name>
     (Parser (Type <category>))
     (<t>.embed <parser> <c>.text))]

  [var Var jvm-parser.var]
  [class Class jvm-parser.class]
  [type Value jvm-parser.value]
  [return Return jvm-parser.return]
  )

(def: input
  (Parser (Typed Code))
  (<c>.tuple (<>.and ..type <c>.any)))

(def: (decorate-inputs typesT inputsA)
  (-> (List (Type Value)) (List Analysis) (List Analysis))
  (|> inputsA
      (list.zip2 (list@map (|>> ..signature /////analysis.text) typesT))
      (list@map (function (_ [type value])
                  (/////analysis.tuple (list type value))))))

(def: type-vars (<c>.tuple (<>.some ..var)))

(def: invoke::static
  Handler
  (..custom
   [($_ <>.and ..type-vars ..member ..type-vars (<>.some ..input))
    (function (_ extension-name analyse [class-tvars [class method] method-tvars argsTC])
      (do ////.monad
        [#let [argsT (list@map product.left argsTC)]
         [methodT exceptionsT] (method-candidate class-tvars class method-tvars method #Static argsT)
         [outputT argsA] (inferenceA.general analyse methodT (list@map product.right argsTC))
         outputJT (check-return outputT)]
        (wrap (#/////analysis.Extension extension-name (list& (/////analysis.text (..signature (jvm.class class (list))))
                                                              (/////analysis.text method)
                                                              (/////analysis.text (..signature outputJT))
                                                              (decorate-inputs argsT argsA))))))]))

(def: invoke::virtual
  Handler
  (..custom
   [($_ <>.and ..type-vars ..member ..type-vars <c>.any (<>.some ..input))
    (function (_ extension-name analyse [class-tvars [class method] method-tvars objectC argsTC])
      (do ////.monad
        [#let [argsT (list@map product.left argsTC)]
         [methodT exceptionsT] (method-candidate class-tvars class method-tvars method #Virtual argsT)
         [outputT allA] (inferenceA.general analyse methodT (list& objectC (list@map product.right argsTC)))
         #let [[objectA argsA] (case allA
                                 (#.Cons objectA argsA)
                                 [objectA argsA]

                                 _
                                 (undefined))]
         outputJT (check-return outputT)]
        (wrap (#/////analysis.Extension extension-name (list& (/////analysis.text (..signature (jvm.class class (list))))
                                                              (/////analysis.text method)
                                                              (/////analysis.text (..signature outputJT))
                                                              objectA
                                                              (decorate-inputs argsT argsA))))))]))

(def: invoke::special
  Handler
  (..custom
   [($_ <>.and ..type-vars ..member ..type-vars <c>.any (<>.some ..input))
    (function (_ extension-name analyse [class-tvars [class method] method-tvars objectC argsTC])
      (do ////.monad
        [#let [argsT (list@map product.left argsTC)]
         [methodT exceptionsT] (method-candidate class-tvars class method-tvars method #Special argsT)
         [outputT argsA] (inferenceA.general analyse methodT (list& objectC (list@map product.right argsTC)))
         outputJT (check-return outputT)]
        (wrap (#/////analysis.Extension extension-name (list& (/////analysis.text (..signature (jvm.class class (list))))
                                                              (/////analysis.text method)
                                                              (/////analysis.text (..signature outputJT))
                                                              (decorate-inputs argsT argsA))))))]))

(def: invoke::interface
  Handler
  (..custom
   [($_ <>.and ..type-vars ..member ..type-vars <c>.any (<>.some ..input))
    (function (_ extension-name analyse [class-tvars [class-name method] method-tvars objectC argsTC])
      (do ////.monad
        [#let [argsT (list@map product.left argsTC)]
         class (////.lift (reflection!.load class-name))
         _ (////.assert non-interface class-name
                        (java/lang/reflect/Modifier::isInterface (java/lang/Class::getModifiers class)))
         [methodT exceptionsT] (method-candidate class-tvars class-name method-tvars method #Interface argsT)
         [outputT allA] (inferenceA.general analyse methodT (list& objectC (list@map product.right argsTC)))
         #let [[objectA argsA] (case allA
                                 (#.Cons objectA argsA)
                                 [objectA argsA]

                                 _
                                 (undefined))]
         outputJT (check-return outputT)]
        (wrap (#/////analysis.Extension extension-name
                                        (list& (/////analysis.text (..signature (jvm.class class-name (list))))
                                               (/////analysis.text method)
                                               (/////analysis.text (..signature outputJT))
                                               objectA
                                               (decorate-inputs argsT argsA))))))]))

(def: invoke::constructor
  (..custom
   [($_ <>.and ..type-vars <c>.text ..type-vars (<>.some ..input))
    (function (_ extension-name analyse [class-tvars class method-tvars argsTC])
      (do ////.monad
        [#let [argsT (list@map product.left argsTC)]
         [methodT exceptionsT] (constructor-candidate class-tvars class method-tvars argsT)
         [outputT argsA] (inferenceA.general analyse methodT (list@map product.right argsTC))]
        (wrap (#/////analysis.Extension extension-name (list& (/////analysis.text (..signature (jvm.class class (list))))
                                                              (decorate-inputs argsT argsA))))))]))

(def: bundle::member
  Bundle
  (<| (///bundle.prefix "member")
      (|> ///bundle.empty
          (dictionary.merge (<| (///bundle.prefix "get")
                                (|> ///bundle.empty
                                    (///bundle.install "static" get::static)
                                    (///bundle.install "virtual" get::virtual))))
          (dictionary.merge (<| (///bundle.prefix "put")
                                (|> ///bundle.empty
                                    (///bundle.install "static" put::static)
                                    (///bundle.install "virtual" put::virtual))))
          (dictionary.merge (<| (///bundle.prefix "invoke")
                                (|> ///bundle.empty
                                    (///bundle.install "static" invoke::static)
                                    (///bundle.install "virtual" invoke::virtual)
                                    (///bundle.install "special" invoke::special)
                                    (///bundle.install "interface" invoke::interface)
                                    (///bundle.install "constructor" invoke::constructor)
                                    )))
          )))

(type: #export (Annotation-Parameter a)
  [Text a])

(def: annotation-parameter
  (Parser (Annotation-Parameter Code))
  (<c>.tuple (<>.and <c>.text <c>.any)))

(type: #export (Annotation a)
  [Text (List (Annotation-Parameter a))])

(def: #export annotation
  (Parser (Annotation Code))
  (<c>.form (<>.and <c>.text (<>.some ..annotation-parameter))))

(def: #export argument
  (Parser Argument)
  (<c>.tuple (<>.and <c>.text ..type)))

(def: (annotation-parameter-analysis [name value])
  (-> (Annotation-Parameter Analysis) Analysis)
  (/////analysis.tuple (list (/////analysis.text name) value)))

(def: (annotation-analysis [name parameters])
  (-> (Annotation Analysis) Analysis)
  (/////analysis.tuple (list& (/////analysis.text name)
                              (list@map annotation-parameter-analysis parameters))))

(template [<name> <category>]
  [(def: <name>
     (-> (Type <category>) Analysis)
     (|>> ..signature /////analysis.text))]

  [var-analysis Var]
  [class-analysis Class]
  [value-analysis Value]
  [return-analysis Return]
  )

(def: (typed-analysis [type term])
  (-> (Typed Analysis) Analysis)
  (/////analysis.tuple (list (value-analysis type) term)))

(def: (argument-analysis [argument argumentJT])
  (-> Argument Analysis)
  (/////analysis.tuple
   (list (/////analysis.text argument)
         (value-analysis argumentJT))))

(template [<name> <filter>]
  [(def: <name>
     (-> (java/lang/Class java/lang/Object)
         (Try (List [Text (Signature Method)])))
     (|>> java/lang/Class::getDeclaredMethods
          array.to-list
          <filter>
          (monad.map try.monad
                     (function (_ method)
                       (do try.monad
                         [inputs (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                                     array.to-list
                                     (monad.map @ reflection!.type))
                          return (|> method
                                     java/lang/reflect/Method::getGenericReturnType
                                     reflection!.return)
                          exceptions (|> (java/lang/reflect/Method::getGenericExceptionTypes method)
                                         array.to-list
                                         (monad.map @ reflection!.class))]
                         (wrap [(java/lang/reflect/Method::getName method)
                                (product.left (jvm.method [inputs return exceptions]))]))))))]

  [abstract-methods (list.filter (|>> java/lang/reflect/Method::getModifiers java/lang/reflect/Modifier::isAbstract))]
  [methods (<|)]
  )

(def: jvm-package-separator ".")

(template [<name> <methods>]
  [(def: <name>
     (-> (List (Type Class)) (Try (List [Text (Signature Method)])))
     (|>> (monad.map try.monad (|>> ..reflection reflection!.load))
          (try@map (monad.map try.monad <methods>))
          try@join
          (try@map list@join)))]

  [all-abstract-methods ..abstract-methods]
  [all-methods ..methods]
  )

(template [<name>]
  [(exception: #export (<name> {methods (List [Text (Signature Method)])})
     (exception.report
      ["Methods" (exception.enumerate
                  (function (_ [name signature])
                    (format (%.text name) " " (signature.signature signature)))
                  methods)]))]

  [missing-abstract-methods]
  [invalid-overriden-methods]
  )

(type: #export Visibility
  #Public
  #Private
  #Protected
  #Default)

(type: #export Finality Bit)
(type: #export Strictness Bit)

(def: #export public-tag "public")
(def: #export private-tag "private")
(def: #export protected-tag "protected")
(def: #export default-tag "default")

(def: #export visibility
  (Parser Visibility)
  ($_ <>.or
      (<c>.text! ..public-tag)
      (<c>.text! ..private-tag)
      (<c>.text! ..protected-tag)
      (<c>.text! ..default-tag)))

(def: #export (visibility-analysis visibility)
  (-> Visibility Analysis)
  (/////analysis.text (case visibility
                        #Public ..public-tag
                        #Private ..private-tag
                        #Protected ..protected-tag
                        #Default ..default-tag)))

(type: #export (Constructor a)
  [Visibility
   Strictness
   (List (Annotation a))
   (List (Type Var))
   (List (Type Class)) ## Exceptions
   Text
   (List Argument)
   (List (Typed a))
   a])

(def: #export constructor-tag "init")

(def: #export constructor-definition
  (Parser (Constructor Code))
  (<| <c>.form
      (<>.after (<c>.text! ..constructor-tag))
      ($_ <>.and
          ..visibility
          <c>.bit
          (<c>.tuple (<>.some ..annotation))
          (<c>.tuple (<>.some ..var))
          (<c>.tuple (<>.some ..class))
          <c>.text
          (<c>.tuple (<>.some ..argument))
          (<c>.tuple (<>.some ..input))
          <c>.any)))

(def: #export (analyse-constructor-method analyse selfT mapping method)
  (-> Phase .Type Mapping (Constructor Code) (Operation Analysis))
  (let [[visibility strict-fp?
         annotations vars exceptions
         self-name arguments super-arguments body] method]
    (do ////.monad
      [annotationsA (monad.map @ (function (_ [name parameters])
                                   (do @
                                     [parametersA (monad.map @ (function (_ [name value])
                                                                 (do @
                                                                   [valueA (analyse value)]
                                                                   (wrap [name valueA])))
                                                             parameters)]
                                     (wrap [name parametersA])))
                               annotations)
       super-arguments (monad.map @ (function (_ [jvmT super-argC])
                                      (do @
                                        [luxT (reflection-type mapping jvmT)
                                         super-argA (typeA.with-type luxT
                                                      (analyse super-argC))]
                                        (wrap [jvmT super-argA])))
                                  super-arguments)
       arguments' (monad.map @
                             (function (_ [name jvmT])
                               (do @
                                 [luxT (reflection-type mapping jvmT)]
                                 (wrap [name luxT])))
                             arguments)
       [scope bodyA] (|> arguments'
                         (#.Cons [self-name selfT])
                         list.reverse
                         (list@fold scope.with-local (analyse body))
                         (typeA.with-type .Any)
                         /////analysis.with-scope)]
      (wrap (/////analysis.tuple (list (/////analysis.text ..constructor-tag)
                                       (visibility-analysis visibility)
                                       (/////analysis.bit strict-fp?)
                                       (/////analysis.tuple (list@map annotation-analysis annotationsA))
                                       (/////analysis.tuple (list@map var-analysis vars))
                                       (/////analysis.text self-name)
                                       (/////analysis.tuple (list@map ..argument-analysis arguments))
                                       (/////analysis.tuple (list@map class-analysis exceptions))
                                       (/////analysis.tuple (list@map typed-analysis super-arguments))
                                       (#/////analysis.Function
                                        (scope.environment scope)
                                        (/////analysis.tuple (list bodyA)))
                                       ))))))

(type: #export (Virtual-Method a)
  [Text
   Visibility
   Finality
   Strictness
   (List (Annotation a))
   (List (Type Var))
   Text
   (List Argument)
   (Type Return)
   (List (Type Class)) ## Exceptions
   a])

(def: virtual-tag "virtual")

(def: #export virtual-method-definition
  (Parser (Virtual-Method Code))
  (<| <c>.form
      (<>.after (<c>.text! ..virtual-tag))
      ($_ <>.and
          <c>.text
          ..visibility
          <c>.bit
          <c>.bit
          (<c>.tuple (<>.some ..annotation))
          (<c>.tuple (<>.some ..var))
          <c>.text
          (<c>.tuple (<>.some ..argument))
          ..return
          (<c>.tuple (<>.some ..class))
          <c>.any)))

(def: #export (analyse-virtual-method analyse selfT mapping method)
  (-> Phase .Type Mapping (Virtual-Method Code) (Operation Analysis))
  (let [[method-name visibility
         final? strict-fp? annotations vars
         self-name arguments return exceptions
         body] method]
    (do ////.monad
      [annotationsA (monad.map @ (function (_ [name parameters])
                                   (do @
                                     [parametersA (monad.map @ (function (_ [name value])
                                                                 (do @
                                                                   [valueA (analyse value)]
                                                                   (wrap [name valueA])))
                                                             parameters)]
                                     (wrap [name parametersA])))
                               annotations)
       returnT (reflection-return mapping return)
       arguments' (monad.map @
                             (function (_ [name jvmT])
                               (do @
                                 [luxT (reflection-type mapping jvmT)]
                                 (wrap [name luxT])))
                             arguments)
       [scope bodyA] (|> arguments'
                         (#.Cons [self-name selfT])
                         list.reverse
                         (list@fold scope.with-local (analyse body))
                         (typeA.with-type returnT)
                         /////analysis.with-scope)]
      (wrap (/////analysis.tuple (list (/////analysis.text ..virtual-tag)
                                       (/////analysis.text method-name)
                                       (visibility-analysis visibility)
                                       (/////analysis.bit final?)
                                       (/////analysis.bit strict-fp?)
                                       (/////analysis.tuple (list@map annotation-analysis annotationsA))
                                       (/////analysis.tuple (list@map var-analysis vars))
                                       (/////analysis.text self-name)
                                       (/////analysis.tuple (list@map ..argument-analysis arguments))
                                       (return-analysis return)
                                       (/////analysis.tuple (list@map class-analysis exceptions))
                                       (#/////analysis.Function
                                        (scope.environment scope)
                                        (/////analysis.tuple (list bodyA)))
                                       ))))))

(type: #export (Static-Method a)
  [Text
   Visibility
   Strictness
   (List (Annotation a))
   (List (Type Var))
   (List (Type Class)) ## Exceptions
   (List Argument)
   (Type Return)
   a])

(def: #export static-tag "static")

(def: #export static-method-definition
  (Parser (Static-Method Code))
  (<| <c>.form
      (<>.after (<c>.text! ..static-tag))
      ($_ <>.and
          <c>.text
          ..visibility
          <c>.bit
          (<c>.tuple (<>.some ..annotation))
          (<c>.tuple (<>.some ..var))
          (<c>.tuple (<>.some ..class))
          (<c>.tuple (<>.some ..argument))
          ..return
          <c>.any)))

(def: #export (analyse-static-method analyse mapping method)
  (-> Phase Mapping (Static-Method Code) (Operation Analysis))
  (let [[method-name visibility
         strict-fp? annotations vars exceptions
         arguments return
         body] method]
    (do ////.monad
      [annotationsA (monad.map @ (function (_ [name parameters])
                                   (do @
                                     [parametersA (monad.map @ (function (_ [name value])
                                                                 (do @
                                                                   [valueA (analyse value)]
                                                                   (wrap [name valueA])))
                                                             parameters)]
                                     (wrap [name parametersA])))
                               annotations)
       returnT (reflection-return mapping return)
       arguments' (monad.map @
                             (function (_ [name jvmT])
                               (do @
                                 [luxT (reflection-type mapping jvmT)]
                                 (wrap [name luxT])))
                             arguments)
       [scope bodyA] (|> arguments'
                         list.reverse
                         (list@fold scope.with-local (analyse body))
                         (typeA.with-type returnT)
                         /////analysis.with-scope)]
      (wrap (/////analysis.tuple (list (/////analysis.text ..static-tag)
                                       (/////analysis.text method-name)
                                       (visibility-analysis visibility)
                                       (/////analysis.bit strict-fp?)
                                       (/////analysis.tuple (list@map annotation-analysis annotationsA))
                                       (/////analysis.tuple (list@map var-analysis vars))
                                       (/////analysis.tuple (list@map ..argument-analysis arguments))
                                       (return-analysis return)
                                       (/////analysis.tuple (list@map class-analysis
                                                                      exceptions))
                                       (#/////analysis.Function
                                        (scope.environment scope)
                                        (/////analysis.tuple (list bodyA)))
                                       ))))))

(type: #export (Overriden-Method a)
  [(Type Class)
   Text
   Bit
   (List (Annotation a))
   (List (Type Var))
   Text
   (List Argument)
   (Type Return)
   (List (Type Class))
   a])

(def: #export overriden-tag "override")

(def: #export overriden-method-definition
  (Parser (Overriden-Method Code))
  (<| <c>.form
      (<>.after (<c>.text! ..overriden-tag))
      ($_ <>.and
          ..class
          <c>.text
          <c>.bit
          (<c>.tuple (<>.some ..annotation))
          (<c>.tuple (<>.some ..var))
          <c>.text
          (<c>.tuple (<>.some ..argument))
          ..return
          (<c>.tuple (<>.some ..class))
          <c>.any
          )))

(def: #export (analyse-overriden-method analyse selfT mapping method)
  (-> Phase .Type Mapping (Overriden-Method Code) (Operation Analysis))
  (let [[parent-type method-name
         strict-fp? annotations vars
         self-name arguments return exceptions
         body] method]
    (do ////.monad
      [annotationsA (monad.map @ (function (_ [name parameters])
                                   (do @
                                     [parametersA (monad.map @ (function (_ [name value])
                                                                 (do @
                                                                   [valueA (analyse value)]
                                                                   (wrap [name valueA])))
                                                             parameters)]
                                     (wrap [name parametersA])))
                               annotations)
       returnT (reflection-return mapping return)
       arguments' (monad.map @
                             (function (_ [name jvmT])
                               (do @
                                 [luxT (reflection-type mapping jvmT)]
                                 (wrap [name luxT])))
                             arguments)
       [scope bodyA] (|> arguments'
                         (#.Cons [self-name selfT])
                         list.reverse
                         (list@fold scope.with-local (analyse body))
                         (typeA.with-type returnT)
                         /////analysis.with-scope)]
      (wrap (/////analysis.tuple (list (/////analysis.text ..overriden-tag)
                                       (class-analysis parent-type)
                                       (/////analysis.text method-name)
                                       (/////analysis.bit strict-fp?)
                                       (/////analysis.tuple (list@map annotation-analysis annotationsA))
                                       (/////analysis.tuple (list@map var-analysis vars))
                                       (/////analysis.text self-name)
                                       (/////analysis.tuple (list@map ..argument-analysis arguments))
                                       (return-analysis return)
                                       (/////analysis.tuple (list@map class-analysis
                                                                      exceptions))
                                       (#/////analysis.Function
                                        (scope.environment scope)
                                        (/////analysis.tuple (list bodyA)))
                                       ))))))

(type: #export (Method-Definition a)
  (#Overriden-Method (Overriden-Method a)))

(def: #export parameter-types
  (-> (List (Type Var)) (Check (List [(Type Var) .Type])))
  (monad.map check.monad
             (function (_ parameterJ)
               (do check.monad
                 [[_ parameterT] check.existential]
                 (wrap [parameterJ parameterT])))))

(def: (mismatched-methods super-set sub-set)
  (-> (List [Text (Signature Method)]) (List [Text (Signature Method)]) (List [Text (Signature Method)]))
  (list.filter (function (_ [sub-name subJT])
                 (|> super-set
                     (list.filter (function (_ [super-name superJT])
                                    (and (text@= super-name sub-name)
                                         (signature@= superJT subJT))))
                     list.size
                     (n.= 1)
                     not))
               sub-set))

(exception: #export (class-parameter-mismatch {expected (List Text)}
                                              {actual (List (Type Parameter))})
  (exception.report
   ["Expected (amount)" (%.nat (list.size expected))]
   ["Expected (parameters)" (exception.enumerate %.text expected)]
   ["Actual (amount)" (%.nat (list.size actual))]
   ["Actual (parameters)" (exception.enumerate ..signature actual)]))

(def: (super-aliasing class)
  (-> (Type Class) (Operation Aliasing))
  (do ////.monad
    [#let [[name actual-parameters] (jvm-parser.read-class class)]
     class (////.lift (reflection!.load name))
     #let [expected-parameters (|> (java/lang/Class::getTypeParameters class)
                                   array.to-list
                                   (list@map (|>> java/lang/reflect/TypeVariable::getName)))]
     _ (////.assert ..class-parameter-mismatch [expected-parameters actual-parameters]
                    (n.= (list.size expected-parameters)
                         (list.size actual-parameters)))]
    (wrap (|> (list.zip2 expected-parameters actual-parameters)
              (list@fold (function (_ [expected actual] mapping)
                           (case (jvm-parser.var? actual)
                             (#.Some actual)
                             (dictionary.put actual expected mapping)
                             
                             #.None
                             mapping))
                         jvm-alias.fresh)))))

(def: class::anonymous
  Handler
  (..custom
   [($_ <>.and
        (<c>.tuple (<>.some ..var))
        ..class
        (<c>.tuple (<>.some ..class))
        (<c>.tuple (<>.some ..input))
        (<c>.tuple (<>.some ..overriden-method-definition)))
    (function (_ extension-name analyse [parameters
                                         super-class
                                         super-interfaces
                                         constructor-args
                                         methods])
      (do ////.monad
        [parameters (typeA.with-env
                      (..parameter-types parameters))
         #let [mapping (list@fold (function (_ [parameterJ parameterT] mapping)
                                    (dictionary.put (jvm-parser.name parameterJ)
                                                    parameterT
                                                    mapping))
                                  luxT.fresh
                                  parameters)]
         name (///.lift (do macro.monad
                          [where macro.current-module-name
                           id macro.count]
                          (wrap (format (text.replace-all .module-separator ..jvm-package-separator where)
                                        ..jvm-package-separator
                                        "anonymous-class" (%.nat id)))))
         super-classT (typeA.with-env
                        (luxT.check (luxT.class mapping) (..signature super-class)))
         super-interfaceT+ (typeA.with-env
                             (monad.map check.monad
                                        (|>> ..signature (luxT.check (luxT.class mapping)))
                                        super-interfaces))
         #let [selfT (inheritance-relationship-type (#.Primitive name (list))
                                                    super-classT
                                                    super-interfaceT+)]
         constructor-argsA+ (monad.map @ (function (_ [type term])
                                           (do @
                                             [argT (reflection-type mapping type)
                                              termA (typeA.with-type argT
                                                      (analyse term))]
                                             (wrap [type termA])))
                                       constructor-args)
         methodsA (monad.map @ (analyse-overriden-method analyse selfT mapping) methods)
         required-abstract-methods (////.lift (all-abstract-methods (list& super-class super-interfaces)))
         available-methods (////.lift (all-methods (list& super-class super-interfaces)))
         overriden-methods (monad.map @ (function (_ [parent-type method-name
                                                      strict-fp? annotations vars
                                                      self-name arguments return exceptions
                                                      body])
                                          (do @
                                            [aliasing (super-aliasing parent-type)]
                                            (wrap [method-name (|> (jvm.method [(list@map product.right arguments)
                                                                                return
                                                                                exceptions])
                                                                   product.left
                                                                   (jvm-alias.method aliasing))])))
                                      methods)
         #let [missing-abstract-methods (mismatched-methods overriden-methods required-abstract-methods)
               invalid-overriden-methods (mismatched-methods available-methods overriden-methods)]
         _ (typeA.infer selfT)
         _ (////.assert ..missing-abstract-methods missing-abstract-methods
                        (list.empty? missing-abstract-methods))
         _ (////.assert ..invalid-overriden-methods invalid-overriden-methods
                        (list.empty? invalid-overriden-methods))]
        (wrap (#/////analysis.Extension extension-name
                                        (list (/////analysis.text name)
                                              (class-analysis super-class)
                                              (/////analysis.tuple (list@map class-analysis super-interfaces))
                                              (/////analysis.tuple (list@map typed-analysis constructor-argsA+))
                                              (/////analysis.tuple methodsA))))))]))

(def: bundle::class
  Bundle
  (<| (///bundle.prefix "class")
      (|> ///bundle.empty
          (///bundle.install "anonymous" class::anonymous)
          )))

(def: #export bundle
  Bundle
  (<| (///bundle.prefix "jvm")
      (|> ///bundle.empty
          (dictionary.merge bundle::conversion)
          (dictionary.merge bundle::int)
          (dictionary.merge bundle::long)
          (dictionary.merge bundle::float)
          (dictionary.merge bundle::double)
          (dictionary.merge bundle::char)
          (dictionary.merge bundle::array)
          (dictionary.merge bundle::object)
          (dictionary.merge bundle::member)
          (dictionary.merge bundle::class)
          )))
