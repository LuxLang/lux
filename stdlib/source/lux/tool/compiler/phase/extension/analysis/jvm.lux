(.module:
  [lux (#- Type primitive type char int)
   ["." host (#+ import:)]
   ["." macro]
   [abstract
    ["." monad (#+ do)]]
   [control
    ["p" parser
     ["s" code (#+ Parser)]
     ["<t>" text]]
    ["." exception (#+ exception:)]
    pipe]
   [data
    ["." error (#+ Error) ("#@." monad)]
    ["." maybe]
    ["." product]
    ["." text ("#@." equivalence)
     format]
    [collection
     ["." list ("#@." fold monad monoid)]
     ["." array (#+ Array)]
     ["." dictionary (#+ Dictionary)]]]
   ["." type
    ["." check (#+ Check) ("#@." monad)]]
   [target
    ["." jvm #_
     [".!" reflection]
     ["#" type (#+ Var Bound Primitive Generic Class Type Argument Return Method Typed)
      ("method@." method-equivalence)
      ["." box]
      ["." reflection]
      [".T" lux (#+ Mapping)]]]]]
  ["." // #_
   ["#." common]
   ["/#" //
    ["#." bundle]
    ["/#" // ("#@." monad)
     [analysis
      [".A" type]
      [".A" inference]
      ["." scope]]
     ["/#" // #_
      ["#." analysis (#+ Analysis Operation Phase Handler Bundle)]
      ["#." synthesis]]]]])

(def: inheritance-relationship-type-name "_jvm_inheritance")
(def: (inheritance-relationship-type class super-class super-interfaces)
  (-> .Type .Type (List .Type) .Type)
  (#.Primitive ..inheritance-relationship-type-name
               (list& class super-class super-interfaces)))

## TODO: Get rid of this template block and use the definition in
## lux/host.jvm.lux ASAP
(template [<name> <class>]
  [(def: #export <name> .Type (#.Primitive <class> #.Nil))]

  ## Boxes
  [Boolean   box.boolean]
  [Byte      box.byte]
  [Short     box.short]
  [Integer   box.int]
  [Long      box.long]
  [Float     box.float]
  [Double    box.double]
  [Character box.char]
  [String    "java.lang.String"]

  ## Primitives
  [boolean   reflection.boolean]
  [byte      reflection.byte]
  [short     reflection.short]
  [int       reflection.int]
  [long      reflection.long]
  [float     reflection.float]
  [double    reflection.double]
  [char      reflection.char]
  )

(def: (custom [syntax handler])
  (All [s]
    (-> [(Parser s)
         (-> Text Phase s (Operation Analysis))]
        Handler))
  (function (_ extension-name analyse args)
    (case (s.run args syntax)
      (#error.Success inputs)
      (handler extension-name analyse inputs)

      (#error.Failure error)
      (/////analysis.throw ///.invalid-syntax [extension-name %code args]))))

(type: Member
  {#class Text
   #member Text})

(def: member
  (Parser Member)
  ($_ p.and s.text s.text))

(type: Method-Signature
  {#method .Type
   #exceptions (List .Type)})

(template [<name>]
  [(exception: #export (<name> {type .Type})
     (exception.report
      ["Type" (%type type)]))]

  [non-object]
  [non-array]
  )

(template [<name>]
  [(exception: #export (<name> {class Text})
     (exception.report
      ["Class/type" (%t class)]))]

  [non-interface]
  [non-throwable]
  [primitives-are-not-objects]
  )

(exception: #export (cannot-set-a-final-field {field Text} {class Text})
  (exception.report
   ["Field" (%t field)]
   ["Class" (%t class)]))

(template [<name>]
  [(exception: #export (<name> {class Text}
                               {method Text}
                               {arg-classes (List Text)}
                               {hints (List Method-Signature)})
     (exception.report
      ["Class" class]
      ["Method" method]
      ["Arguments" (exception.enumerate %t arg-classes)]
      ["Hints" (exception.enumerate %type (list@map product.left hints))]))]

  [no-candidates]
  [too-many-candidates]
  )

(exception: #export (cannot-cast {from .Type} {to .Type} {value Code})
  (exception.report
   ["From" (%type from)]
   ["To" (%type to)]
   ["Value" (%code value)]))

(template [<name>]
  [(exception: #export (<name> {message Text})
     message)]

  [primitives-cannot-have-type-parameters]

  [cannot-possibly-be-an-instance]

  [unknown-type-var]
  )

(def: bundle::conversion
  Bundle
  (<| (///bundle.prefix "conversion")
      (|> ///bundle.empty
          (///bundle.install "double-to-float" (//common.unary ..double ..float))
          (///bundle.install "double-to-int" (//common.unary ..double ..int))
          (///bundle.install "double-to-long" (//common.unary ..double ..long))
          (///bundle.install "float-to-double" (//common.unary ..float ..double))
          (///bundle.install "float-to-int" (//common.unary ..float ..int))
          (///bundle.install "float-to-long" (//common.unary ..float ..long))
          (///bundle.install "int-to-byte" (//common.unary ..int ..byte))
          (///bundle.install "int-to-char" (//common.unary ..int ..char))
          (///bundle.install "int-to-double" (//common.unary ..int ..double))
          (///bundle.install "int-to-float" (//common.unary ..int ..float))
          (///bundle.install "int-to-long" (//common.unary ..int ..long))
          (///bundle.install "int-to-short" (//common.unary ..int ..short))
          (///bundle.install "long-to-double" (//common.unary ..long ..double))
          (///bundle.install "long-to-float" (//common.unary ..long ..float))
          (///bundle.install "long-to-int" (//common.unary ..long ..int))
          (///bundle.install "long-to-short" (//common.unary ..long ..short))
          (///bundle.install "long-to-byte" (//common.unary ..long ..byte))
          (///bundle.install "char-to-byte" (//common.unary ..char ..byte))
          (///bundle.install "char-to-short" (//common.unary ..char ..short))
          (///bundle.install "char-to-int" (//common.unary ..char ..int))
          (///bundle.install "char-to-long" (//common.unary ..char ..long))
          (///bundle.install "byte-to-long" (//common.unary ..byte ..long))
          (///bundle.install "short-to-long" (//common.unary ..short ..long))
          )))

(template [<name> <prefix> <type>]
  [(def: <name>
     Bundle
     (<| (///bundle.prefix <prefix>)
         (|> ///bundle.empty
             (///bundle.install "+" (//common.binary <type> <type> <type>))
             (///bundle.install "-" (//common.binary <type> <type> <type>))
             (///bundle.install "*" (//common.binary <type> <type> <type>))
             (///bundle.install "/" (//common.binary <type> <type> <type>))
             (///bundle.install "%" (//common.binary <type> <type> <type>))
             (///bundle.install "=" (//common.binary <type> <type> Bit))
             (///bundle.install "<" (//common.binary <type> <type> Bit))
             (///bundle.install "and" (//common.binary <type> <type> <type>))
             (///bundle.install "or" (//common.binary <type> <type> <type>))
             (///bundle.install "xor" (//common.binary <type> <type> <type>))
             (///bundle.install "shl" (//common.binary <type> Integer <type>))
             (///bundle.install "shr" (//common.binary <type> Integer <type>))
             (///bundle.install "ushr" (//common.binary <type> Integer <type>))
             )))]

  [bundle::int  reflection.int  ..long]
  [bundle::long reflection.long ..long]
  )

(template [<name> <prefix> <type>]
  [(def: <name>
     Bundle
     (<| (///bundle.prefix <prefix>)
         (|> ///bundle.empty
             (///bundle.install "+" (//common.binary <type> <type> <type>))
             (///bundle.install "-" (//common.binary <type> <type> <type>))
             (///bundle.install "*" (//common.binary <type> <type> <type>))
             (///bundle.install "/" (//common.binary <type> <type> <type>))
             (///bundle.install "%" (//common.binary <type> <type> <type>))
             (///bundle.install "=" (//common.binary <type> <type> Bit))
             (///bundle.install "<" (//common.binary <type> <type> Bit))
             )))]

  [bundle::float  reflection.float  ..float]
  [bundle::double reflection.double ..double]
  )

(def: bundle::char
  Bundle
  (<| (///bundle.prefix reflection.char)
      (|> ///bundle.empty
          (///bundle.install "=" (//common.binary ..char ..char Bit))
          (///bundle.install "<" (//common.binary ..char ..char Bit))
          )))

(def: #export boxes
  (Dictionary Text Text)
  (|> (list [reflection.boolean box.boolean]
            [reflection.byte    box.byte]
            [reflection.short   box.short]
            [reflection.int     box.int]
            [reflection.long    box.long]
            [reflection.float   box.float]
            [reflection.double  box.double]
            [reflection.char    box.char])
      (dictionary.from-list text.hash)))

(def: (array-type-info allow-primitives? arrayT)
  (-> Bit .Type (Operation [Nat Text]))
  (loop [level 0
         currentT arrayT]
    (case currentT
      (#.Apply inputT abstractionT)
      (case (type.apply (list inputT) abstractionT)
        (#.Some outputT)
        (recur level outputT)

        #.None
        (/////analysis.throw non-array arrayT))

      (^ (#.Primitive (static array.type-name) (list elemT)))
      (recur (inc level) elemT)

      (#.Primitive class #.Nil)
      (if (and (dictionary.contains? class boxes)
               (not allow-primitives?))
        (/////analysis.throw ..primitives-are-not-objects [class])
        (////@wrap [level class]))

      (#.Primitive class _)
      (if (dictionary.contains? class boxes)
        (/////analysis.throw ..primitives-cannot-have-type-parameters class)
        (////@wrap [level class]))
      
      _
      (/////analysis.throw non-array arrayT))))

(def: (primitive-array-length-handler primitive-type)
  (-> Type Handler)
  (function (_ extension-name analyse args)
    (case args
      (^ (list arrayC))
      (do ////.monad
        [_ (typeA.infer ..int)
         arrayA (typeA.with-type (#.Primitive (jvm.descriptor (jvm.array 1 primitive-type)) (list))
                  (analyse arrayC))]
        (wrap (#/////analysis.Extension extension-name (list arrayA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: array::length::object
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list arrayC))
      (do ////.monad
        [_ (typeA.infer ..int)
         [var-id varT] (typeA.with-env check.var)
         arrayA (typeA.with-type (.type (Array varT))
                  (analyse arrayC))
         varT (typeA.with-env (check.clean varT))
         [array-nesting elem-class] (array-type-info true (.type (Array varT)))]
        (wrap (#/////analysis.Extension extension-name (list (/////analysis.nat array-nesting)
                                                             (/////analysis.text elem-class)
                                                             arrayA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: (new-primitive-array-handler primitive-type)
  (-> Type Handler)
  (function (_ extension-name analyse args)
    (case args
      (^ (list lengthC))
      (do ////.monad
        [lengthA (typeA.with-type ..int
                   (analyse lengthC))
         _ (typeA.infer (#.Primitive (jvm.descriptor (jvm.array 1 primitive-type)) (list)))]
        (wrap (#/////analysis.Extension extension-name (list lengthA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: array::new::object
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list lengthC))
      (do ////.monad
        [lengthA (typeA.with-type ..int
                   (analyse lengthC))
         expectedT (///.lift macro.expected-type)
         [level elem-class] (array-type-info false expectedT)
         _ (if (n/> 0 level)
             (wrap [])
             (/////analysis.throw non-array expectedT))]
        (wrap (#/////analysis.Extension extension-name (list (/////analysis.nat (dec level))
                                                             (/////analysis.text elem-class)
                                                             lengthA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: (check-jvm objectT)
  (-> .Type (Operation Type))
  (case objectT
    (#.Primitive name #.Nil)
    (case name
      (^ (static reflection.boolean)) (////@wrap jvm.boolean)
      (^ (static reflection.byte)) (////@wrap jvm.byte)
      (^ (static reflection.short)) (////@wrap jvm.short)
      (^ (static reflection.int)) (////@wrap jvm.int)
      (^ (static reflection.long)) (////@wrap jvm.long)
      (^ (static reflection.float)) (////@wrap jvm.float)
      (^ (static reflection.double)) (////@wrap jvm.double)
      (^ (static reflection.char)) (////@wrap jvm.char)
      _ (if (text.starts-with? jvm.array-prefix name)
          (////.lift (<t>.run jvm.parse-signature name))
          (////@wrap (jvm.class name (list)))))

    (^ (#.Primitive (static array.type-name)
                    (list elementT)))
    (|> elementT
        check-jvm
        (////@map (jvm.array 1)))
    
    (#.Primitive name parameters)
    (do ////.monad
      [parameters (monad.map @ check-jvm parameters)
       parameters (monad.map @ (function (_ parameter)
                                 (case parameter
                                   (#jvm.Generic generic)
                                   (wrap generic)

                                   _
                                   (/////analysis.throw ..primitives-cannot-have-type-parameters name)))
                             parameters)]
      (////@wrap (jvm.class name parameters)))

    (#.Named name anonymous)
    (check-jvm anonymous)

    (^template [<tag>]
      (<tag> id)
      (////@wrap (jvm.class "java.lang.Object" (list))))
    ([#.Var]
     [#.Ex])

    (^template [<tag>]
      (<tag> env unquantified)
      (check-jvm unquantified))
    ([#.UnivQ]
     [#.ExQ])

    (#.Apply inputT abstractionT)
    (case (type.apply (list inputT) abstractionT)
      (#.Some outputT)
      (check-jvm outputT)

      #.None
      (/////analysis.throw ..non-object objectT))

    _
    (/////analysis.throw ..non-object objectT)))

(def: (check-object objectT)
  (-> .Type (Operation Text))
  (do ////.monad
    [name (:: @ map reflection.class (check-jvm objectT))]
    (if (dictionary.contains? name ..boxes)
      (/////analysis.throw ..primitives-are-not-objects [name])
      (////@wrap name))))

(def: (check-return type)
  (-> .Type (Operation Text))
  (if (is? .Any type)
    (////@wrap jvm.void-descriptor)
    (////@map jvm.descriptor (check-jvm type))))

(def: (read-primitive-array-handler lux-type jvm-type)
  (-> .Type Type Handler)
  (function (_ extension-name analyse args)
    (case args
      (^ (list idxC arrayC))
      (do ////.monad
        [_ (typeA.infer lux-type)
         idxA (typeA.with-type ..int
                (analyse idxC))
         arrayA (typeA.with-type (#.Primitive (jvm.descriptor (jvm.array 1 jvm-type)) (list))
                  (analyse arrayC))]
        (wrap (#/////analysis.Extension extension-name (list idxA arrayA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 2 (list.size args)]))))

(def: array::read::object
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list idxC arrayC))
      (do ////.monad
        [[var-id varT] (typeA.with-env check.var)
         _ (typeA.infer varT)
         arrayA (typeA.with-type (.type (Array varT))
                  (analyse arrayC))
         varT (typeA.with-env
                (check.clean varT))
         [nesting elem-class] (array-type-info false varT)
         idxA (typeA.with-type ..int
                (analyse idxC))]
        (wrap (#/////analysis.Extension extension-name (list (/////analysis.nat (inc nesting))
                                                             (/////analysis.text elem-class)
                                                             idxA
                                                             arrayA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 2 (list.size args)]))))

(def: (write-primitive-array-handler lux-type jvm-type)
  (-> .Type Type Handler)
  (let [array-type (#.Primitive (jvm.descriptor (jvm.array 1 jvm-type)) (list))]
    (function (_ extension-name analyse args)
      (case args
        (^ (list idxC valueC arrayC))
        (do ////.monad
          [_ (typeA.infer array-type)
           idxA (typeA.with-type ..int
                  (analyse idxC))
           valueA (typeA.with-type lux-type
                    (analyse valueC))
           arrayA (typeA.with-type array-type
                    (analyse arrayC))]
          (wrap (#/////analysis.Extension extension-name (list idxA
                                                               valueA
                                                               arrayA))))

        _
        (/////analysis.throw ///.incorrect-arity [extension-name 3 (list.size args)])))))

(def: array::write::object
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list idxC valueC arrayC))
      (do ////.monad
        [[var-id varT] (typeA.with-env check.var)
         _ (typeA.infer (.type (Array varT)))
         arrayA (typeA.with-type (.type (Array varT))
                  (analyse arrayC))
         varT (typeA.with-env
                (check.clean varT))
         [nesting elem-class] (array-type-info false varT)
         idxA (typeA.with-type ..int
                (analyse idxC))
         valueA (typeA.with-type varT
                  (analyse valueC))]
        (wrap (#/////analysis.Extension extension-name (list (/////analysis.nat (inc nesting))
                                                             (/////analysis.text elem-class)
                                                             idxA
                                                             valueA
                                                             arrayA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 3 (list.size args)]))))

(def: bundle::array
  Bundle
  (<| (///bundle.prefix "array")
      (|> ///bundle.empty
          (dictionary.merge (<| (///bundle.prefix "length")
                                (|> ///bundle.empty
                                    (///bundle.install reflection.boolean (primitive-array-length-handler jvm.boolean))
                                    (///bundle.install reflection.byte (primitive-array-length-handler jvm.byte))
                                    (///bundle.install reflection.short (primitive-array-length-handler jvm.short))
                                    (///bundle.install reflection.int (primitive-array-length-handler jvm.int))
                                    (///bundle.install reflection.long (primitive-array-length-handler jvm.long))
                                    (///bundle.install reflection.float (primitive-array-length-handler jvm.float))
                                    (///bundle.install reflection.double (primitive-array-length-handler jvm.double))
                                    (///bundle.install reflection.char (primitive-array-length-handler jvm.char))
                                    (///bundle.install "object" array::length::object))))
          (dictionary.merge (<| (///bundle.prefix "new")
                                (|> ///bundle.empty
                                    (///bundle.install reflection.boolean (new-primitive-array-handler jvm.boolean))
                                    (///bundle.install reflection.byte (new-primitive-array-handler jvm.byte))
                                    (///bundle.install reflection.short (new-primitive-array-handler jvm.short))
                                    (///bundle.install reflection.int (new-primitive-array-handler jvm.int))
                                    (///bundle.install reflection.long (new-primitive-array-handler jvm.long))
                                    (///bundle.install reflection.float (new-primitive-array-handler jvm.float))
                                    (///bundle.install reflection.double (new-primitive-array-handler jvm.double))
                                    (///bundle.install reflection.char (new-primitive-array-handler jvm.char))
                                    (///bundle.install "object" array::new::object))))
          (dictionary.merge (<| (///bundle.prefix "read")
                                (|> ///bundle.empty
                                    (///bundle.install reflection.boolean (read-primitive-array-handler ..boolean jvm.boolean))
                                    (///bundle.install reflection.byte (read-primitive-array-handler ..byte jvm.byte))
                                    (///bundle.install reflection.short (read-primitive-array-handler ..short jvm.short))
                                    (///bundle.install reflection.int (read-primitive-array-handler ..int jvm.int))
                                    (///bundle.install reflection.long (read-primitive-array-handler ..long jvm.long))
                                    (///bundle.install reflection.float (read-primitive-array-handler ..float jvm.float))
                                    (///bundle.install reflection.double (read-primitive-array-handler ..double jvm.double))
                                    (///bundle.install reflection.char (read-primitive-array-handler ..char jvm.char))
                                    (///bundle.install "object" array::read::object))))
          (dictionary.merge (<| (///bundle.prefix "write")
                                (|> ///bundle.empty
                                    (///bundle.install reflection.boolean (write-primitive-array-handler ..boolean jvm.boolean))
                                    (///bundle.install reflection.byte (write-primitive-array-handler ..byte jvm.byte))
                                    (///bundle.install reflection.short (write-primitive-array-handler ..short jvm.short))
                                    (///bundle.install reflection.int (write-primitive-array-handler ..int jvm.int))
                                    (///bundle.install reflection.long (write-primitive-array-handler ..long jvm.long))
                                    (///bundle.install reflection.float (write-primitive-array-handler ..float jvm.float))
                                    (///bundle.install reflection.double (write-primitive-array-handler ..double jvm.double))
                                    (///bundle.install reflection.char (write-primitive-array-handler ..char jvm.char))
                                    (///bundle.install "object" array::write::object))))
          )))

(def: object::null
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list))
      (do ////.monad
        [expectedT (///.lift macro.expected-type)
         _ (check-object expectedT)]
        (wrap (#/////analysis.Extension extension-name (list))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 0 (list.size args)]))))

(def: object::null?
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list objectC))
      (do ////.monad
        [_ (typeA.infer Bit)
         [objectT objectA] (typeA.with-inference
                             (analyse objectC))
         _ (check-object objectT)]
        (wrap (#/////analysis.Extension extension-name (list objectA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: object::synchronized
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list monitorC exprC))
      (do ////.monad
        [[monitorT monitorA] (typeA.with-inference
                               (analyse monitorC))
         _ (check-object monitorT)
         exprA (analyse exprC)]
        (wrap (#/////analysis.Extension extension-name (list monitorA exprA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 2 (list.size args)]))))

(def: object::throw
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list exceptionC))
      (do ////.monad
        [_ (typeA.infer Nothing)
         [exceptionT exceptionA] (typeA.with-inference
                                   (analyse exceptionC))
         exception-class (check-object exceptionT)
         ? (////.lift (reflection!.sub? "java.lang.Throwable" exception-class))
         _ (: (Operation Any)
              (if ?
                (wrap [])
                (/////analysis.throw non-throwable exception-class)))]
        (wrap (#/////analysis.Extension extension-name (list exceptionA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: object::class
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list classC))
      (case classC
        [_ (#.Text class)]
        (do ////.monad
          [_ (typeA.infer (#.Primitive "java.lang.Class" (list (#.Primitive class (list)))))
           _ (////.lift (reflection!.load class))]
          (wrap (#/////analysis.Extension extension-name (list (/////analysis.text class)))))

        _
        (/////analysis.throw ///.invalid-syntax [extension-name %code args]))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: object::instance?
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list classC objectC))
      (case classC
        [_ (#.Text class)]
        (do ////.monad
          [_ (typeA.infer Bit)
           [objectT objectA] (typeA.with-inference
                               (analyse objectC))
           object-class (check-object objectT)
           ? (////.lift (reflection!.sub? class object-class))]
          (if ?
            (wrap (#/////analysis.Extension extension-name (list (/////analysis.text class))))
            (/////analysis.throw cannot-possibly-be-an-instance (format object-class " !<= "  class))))

        _
        (/////analysis.throw ///.invalid-syntax [extension-name %code args]))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 2 (list.size args)]))))

(import: #long java/lang/Object
  (equals [java/lang/Object] boolean))

(import: #long java/lang/reflect/Type)

(import: #long (java/lang/reflect/TypeVariable d)
  (getName [] java/lang/String)
  (getBounds [] (Array java/lang/reflect/Type)))

(import: #long java/lang/reflect/Modifier
  (#static isStatic [int] boolean)
  (#static isFinal [int] boolean)
  (#static isInterface [int] boolean)
  (#static isAbstract [int] boolean))

(import: #long java/lang/reflect/Method
  (getName [] java/lang/String)
  (getModifiers [] int)
  (getDeclaringClass [] (java/lang/Class java/lang/Object))
  (getTypeParameters [] (Array (java/lang/reflect/TypeVariable java/lang/reflect/Method)))
  (getGenericParameterTypes [] (Array java/lang/reflect/Type))
  (getGenericReturnType [] java/lang/reflect/Type)
  (getGenericExceptionTypes [] (Array java/lang/reflect/Type)))

(import: #long (java/lang/reflect/Constructor c)
  (getModifiers [] int)
  (getDeclaringClass [] (java/lang/Class c))
  (getTypeParameters [] (Array (java/lang/reflect/TypeVariable (java/lang/reflect/Constructor c))))
  (getGenericParameterTypes [] (Array java/lang/reflect/Type))
  (getGenericExceptionTypes [] (Array java/lang/reflect/Type)))

(import: #long (java/lang/Class c)
  (#static forName [java/lang/String] #try (java/lang/Class java/lang/Object))
  (getName [] java/lang/String)
  (getModifiers [] int)
  (isAssignableFrom [(java/lang/Class java/lang/Object)] boolean)
  (getTypeParameters [] (Array (java/lang/reflect/TypeVariable (java/lang/Class c))))
  (getGenericInterfaces [] (Array java/lang/reflect/Type))
  (getGenericSuperclass [] #? java/lang/reflect/Type)
  (getDeclaredField [java/lang/String] #try java/lang/reflect/Field)
  (getConstructors [] (Array (java/lang/reflect/Constructor java/lang/Object)))
  (getDeclaredMethods [] (Array java/lang/reflect/Method)))

(def: (reflection-type mapping typeJ)
  (-> Mapping Type (Operation .Type))
  (typeA.with-env
    (luxT.type mapping typeJ)))

(def: (reflection-return mapping return)
  (-> Mapping Return (Operation .Type))
  (case return
    #.None
    (////@wrap .Any)

    (#.Some return)
    (..reflection-type mapping return)))

(def: (class-candidate-parents from-name fromT to-name to-class)
  (-> Text .Type Text (java/lang/Class java/lang/Object) (Operation (List [[Text .Type] Bit])))
  (do ////.monad
    [from-class (////.lift (reflection!.load from-name))
     mapping (////.lift (reflection!.correspond from-class fromT))]
    (monad.map @
               (function (_ superJT)
                 (do @
                   [superJT (////.lift (reflection!.type superJT))
                    #let [super-name (reflection.class superJT)]
                    super-class (////.lift (reflection!.load super-name))
                    superT (typeA.with-env (luxT.type mapping superJT))]
                   (wrap [[super-name superT] (java/lang/Class::isAssignableFrom super-class to-class)])))
               (case (java/lang/Class::getGenericSuperclass from-class)
                 (#.Some super)
                 (list& super (array.to-list (java/lang/Class::getGenericInterfaces from-class)))

                 #.None
                 (array.to-list (java/lang/Class::getGenericInterfaces from-class))))))

(def: (inheritance-candidate-parents fromT to-class toT fromC)
  (-> .Type (java/lang/Class java/lang/Object) .Type Code (Operation (List [[Text .Type] Bit])))
  (case fromT
    (^ (#.Primitive _ (list& self-classT super-classT super-interfacesT+)))
    (monad.map ////.monad
               (function (_ superT)
                 (do ////.monad
                   [super-name (:: @ map reflection.class (check-jvm superT))
                    super-class (////.lift (reflection!.load super-name))]
                   (wrap [[super-name superT]
                          (java/lang/Class::isAssignableFrom super-class to-class)])))
               (list& super-classT super-interfacesT+))

    _
    (/////analysis.throw cannot-cast [fromT toT fromC])))

(def: object::cast
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list fromC))
      (do ////.monad
        [toT (///.lift macro.expected-type)
         to-name (:: @ map reflection.class (check-jvm toT))
         [fromT fromA] (typeA.with-inference
                         (analyse fromC))
         from-name (:: @ map reflection.class (check-jvm fromT))
         can-cast? (: (Operation Bit)
                      (case [from-name to-name]
                        (^template [<primitive> <object>]
                          (^or (^ [(static <primitive>) (static <object>)])
                               (^ [(static <object>) (static <primitive>)])
                               (^ [(static <primitive>) (static <primitive>)]))
                          (wrap #1))
                        ([reflection.boolean box.boolean]
                         [reflection.byte    box.byte]
                         [reflection.short   box.short]
                         [reflection.int     box.int]
                         [reflection.long    box.long]
                         [reflection.float   box.float]
                         [reflection.double  box.double]
                         [reflection.char    box.char])

                        _
                        (do @
                          [_ (////.assert ..primitives-are-not-objects [from-name]
                                          (not (dictionary.contains? from-name boxes)))
                           _ (////.assert ..primitives-are-not-objects [to-name]
                                          (not (dictionary.contains? to-name boxes)))
                           to-class (////.lift (reflection!.load to-name))
                           _ (if (text@= ..inheritance-relationship-type-name from-name)
                               (wrap [])
                               (do @
                                 [from-class (////.lift (reflection!.load from-name))]
                                 (////.assert cannot-cast [fromT toT fromC]
                                              (java/lang/Class::isAssignableFrom from-class to-class))))]
                          (loop [[current-name currentT] [from-name fromT]]
                            (if (text@= to-name current-name)
                              (wrap #1)
                              (do @
                                [candidate-parents (: (Operation (List [[Text .Type] Bit]))
                                                      (if (text@= ..inheritance-relationship-type-name current-name)
                                                        (inheritance-candidate-parents currentT to-class toT fromC)
                                                        (class-candidate-parents current-name currentT to-name to-class)))]
                                (case (|> candidate-parents
                                          (list.filter product.right)
                                          (list@map product.left))
                                  (#.Cons [next-name nextT] _)
                                  (recur [next-name nextT])

                                  #.Nil
                                  (/////analysis.throw cannot-cast [fromT toT fromC]))
                                ))))))]
        (if can-cast?
          (wrap (#/////analysis.Extension extension-name (list (/////analysis.text from-name)
                                                               (/////analysis.text to-name)
                                                               fromA)))
          (/////analysis.throw cannot-cast [fromT toT fromC])))

      _
      (/////analysis.throw ///.invalid-syntax [extension-name %code args]))))

(def: bundle::object
  Bundle
  (<| (///bundle.prefix "object")
      (|> ///bundle.empty
          (///bundle.install "null" object::null)
          (///bundle.install "null?" object::null?)
          (///bundle.install "synchronized" object::synchronized)
          (///bundle.install "throw" object::throw)
          (///bundle.install "class" object::class)
          (///bundle.install "instance?" object::instance?)
          (///bundle.install "cast" object::cast)
          )))

(def: static::get
  Handler
  (..custom [..member
             (function (_ extension-name analyse [class field])
               (do ////.monad
                 [[final? fieldJT] (////.lift
                                    (do error.monad
                                      [class (reflection!.load class)]
                                      (reflection!.static-field field class)))
                  fieldT (reflection-type luxT.fresh fieldJT)
                  _ (typeA.infer fieldT)]
                 (wrap (<| (#/////analysis.Extension extension-name)
                           (list (/////analysis.text class)
                                 (/////analysis.text field)
                                 (/////analysis.text (reflection.class fieldJT)))))))]))

(def: static::put
  Handler
  (..custom [($_ p.and ..member s.any)
             (function (_ extension-name analyse [[class field] valueC])
               (do ////.monad
                 [_ (typeA.infer Any)
                  [final? fieldJT] (////.lift
                                    (do error.monad
                                      [class (reflection!.load class)]
                                      (reflection!.static-field field class)))
                  fieldT (reflection-type luxT.fresh fieldJT)
                  _ (////.assert ..cannot-set-a-final-field [class field]
                                 (not final?))
                  valueA (typeA.with-type fieldT
                           (analyse valueC))]
                 (wrap (<| (#/////analysis.Extension extension-name)
                           (list (/////analysis.text class)
                                 (/////analysis.text field)
                                 valueA)))))]))

(def: virtual::get
  Handler
  (..custom [($_ p.and ..member s.any)
             (function (_ extension-name analyse [[class field] objectC])
               (do ////.monad
                 [[objectT objectA] (typeA.with-inference
                                      (analyse objectC))
                  [mapping fieldJT] (////.lift
                                     (do error.monad
                                       [class (reflection!.load class)
                                        [final? fieldJT] (reflection!.virtual-field field class)
                                        mapping (reflection!.correspond class objectT)]
                                       (wrap [mapping fieldJT])))
                  fieldT (typeA.with-env
                           (luxT.type mapping fieldJT))
                  _ (typeA.infer fieldT)]
                 (wrap (<| (#/////analysis.Extension extension-name)
                           (list (/////analysis.text class)
                                 (/////analysis.text field)
                                 objectA)))))]))

(def: virtual::put
  Handler
  (..custom [($_ p.and ..member s.any s.any)
             (function (_ extension-name analyse [[class field] valueC objectC])
               (do ////.monad
                 [[objectT objectA] (typeA.with-inference
                                      (analyse objectC))
                  _ (typeA.infer objectT)
                  [final? mapping fieldJT] (////.lift
                                            (do error.monad
                                              [class (reflection!.load class)
                                               [final? fieldJT] (reflection!.virtual-field field class)
                                               mapping (reflection!.correspond class objectT)]
                                              (wrap [final? mapping fieldJT])))
                  fieldT (typeA.with-env
                           (luxT.type mapping fieldJT))
                  _ (////.assert cannot-set-a-final-field [class field]
                                 (not final?))
                  valueA (typeA.with-type fieldT
                           (analyse valueC))]
                 (wrap (<| (#/////analysis.Extension extension-name)
                           (list (/////analysis.text class)
                                 (/////analysis.text field)
                                 valueA
                                 objectA)))))]))

(type: Method-Style
  #Static
  #Abstract
  #Virtual
  #Special
  #Interface)

(def: (check-method class method-name method-style arg-classes method)
  (-> (java/lang/Class java/lang/Object) Text Method-Style (List Text) java/lang/reflect/Method (Operation Bit))
  (do ////.monad
    [parameters (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                    array.to-list
                    (monad.map error.monad reflection!.type)
                    (:: error.monad map (list@map jvm.descriptor))
                    ////.lift)
     #let [modifiers (java/lang/reflect/Method::getModifiers method)
           correct-class? (java/lang/Object::equals class (java/lang/reflect/Method::getDeclaringClass method))
           correct-method? (text@= method-name (java/lang/reflect/Method::getName method))
           static-matches? (case method-style
                             #Static
                             (java/lang/reflect/Modifier::isStatic modifiers)

                             _
                             #1)
           special-matches? (case method-style
                              #Special
                              (not (or (java/lang/reflect/Modifier::isInterface (java/lang/Class::getModifiers class))
                                       (java/lang/reflect/Modifier::isAbstract modifiers)))

                              _
                              #1)
           arity-matches? (n/= (list.size arg-classes) (list.size parameters))
           inputs-match? (list@fold (function (_ [expectedJC actualJC] prev)
                                      (and prev
                                           (text@= expectedJC actualJC)))
                                    #1
                                    (list.zip2 arg-classes parameters))]]
    (wrap (and correct-class?
               correct-method?
               static-matches?
               special-matches?
               arity-matches?
               inputs-match?))))

(def: (check-constructor class arg-classes constructor)
  (-> (java/lang/Class java/lang/Object) (List Text) (java/lang/reflect/Constructor java/lang/Object) (Operation Bit))
  (do ////.monad
    [parameters (|> (java/lang/reflect/Constructor::getGenericParameterTypes constructor)
                    array.to-list
                    (monad.map error.monad reflection!.type)
                    (:: error.monad map (list@map jvm.descriptor))
                    ////.lift)]
    (wrap (and (java/lang/Object::equals class (java/lang/reflect/Constructor::getDeclaringClass constructor))
               (n/= (list.size arg-classes) (list.size parameters))
               (list@fold (function (_ [expectedJC actualJC] prev)
                            (and prev
                                 (text@= expectedJC actualJC)))
                          #1
                          (list.zip2 arg-classes parameters))))))

(def: idx-to-parameter
  (-> Nat .Type)
  (|>> (n/* 2) inc #.Parameter))

(def: (jvm-type-var-mapping owner-tvars method-tvars)
  (-> (List Text) (List Text) [(List .Type) Mapping])
  (let [jvm-tvars (list@compose owner-tvars method-tvars)
        lux-tvars (|> jvm-tvars
                      list.reverse
                      list.enumerate
                      (list@map (function (_ [idx name])
                                  [name (idx-to-parameter idx)]))
                      list.reverse)
        num-owner-tvars (list.size owner-tvars)
        owner-tvarsT (|> lux-tvars (list.take num-owner-tvars) (list@map product.right))
        mapping (dictionary.from-list text.hash lux-tvars)]
    [owner-tvarsT mapping]))

(def: (method-signature method-style method)
  (-> Method-Style java/lang/reflect/Method (Operation Method-Signature))
  (let [owner (java/lang/reflect/Method::getDeclaringClass method)
        owner-tvars (case method-style
                      #Static
                      (list)

                      _
                      (|> (java/lang/Class::getTypeParameters owner)
                          array.to-list
                          (list@map (|>> java/lang/reflect/TypeVariable::getName))))
        method-tvars (|> (java/lang/reflect/Method::getTypeParameters method)
                         array.to-list
                         (list@map (|>> java/lang/reflect/TypeVariable::getName)))
        [owner-tvarsT mapping] (jvm-type-var-mapping owner-tvars method-tvars)]
    (do ////.monad
      [inputsT (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                   array.to-list
                   (monad.map @ (|>> reflection!.type ////.lift))
                   (////@map (monad.map @ (reflection-type mapping)))
                   ////@join)
       outputT (|> method
                   java/lang/reflect/Method::getGenericReturnType
                   reflection!.type
                   ////.lift
                   (////@map (reflection-type mapping))
                   ////@join)
       exceptionsT (|> (java/lang/reflect/Method::getGenericExceptionTypes method)
                       array.to-list
                       (monad.map @ (|>> reflection!.type ////.lift))
                       (////@map (monad.map @ (reflection-type mapping)))
                       ////@join)
       #let [methodT (<| (type.univ-q (dictionary.size mapping))
                         (type.function (case method-style
                                          #Static
                                          inputsT

                                          _
                                          (list& (#.Primitive (java/lang/Class::getName owner) owner-tvarsT)
                                                 inputsT)))
                         outputT)]]
      (wrap [methodT exceptionsT]))))

(def: (constructor-signature constructor)
  (-> (java/lang/reflect/Constructor java/lang/Object) (Operation Method-Signature))
  (let [owner (java/lang/reflect/Constructor::getDeclaringClass constructor)
        owner-tvars (|> (java/lang/Class::getTypeParameters owner)
                        array.to-list
                        (list@map (|>> java/lang/reflect/TypeVariable::getName)))
        method-tvars (|> (java/lang/reflect/Constructor::getTypeParameters constructor)
                         array.to-list
                         (list@map (|>> java/lang/reflect/TypeVariable::getName)))
        [owner-tvarsT mapping] (jvm-type-var-mapping owner-tvars method-tvars)]
    (do ////.monad
      [inputsT (|> (java/lang/reflect/Constructor::getGenericParameterTypes constructor)
                   array.to-list
                   (monad.map @ (|>> reflection!.type ////.lift))
                   (////@map (monad.map @ (reflection-type mapping)))
                   ////@join)
       exceptionsT (|> (java/lang/reflect/Constructor::getGenericExceptionTypes constructor)
                       array.to-list
                       (monad.map @ (|>> reflection!.type ////.lift))
                       (////@map (monad.map @ (reflection-type mapping)))
                       ////@join)
       #let [objectT (#.Primitive (java/lang/Class::getName owner) owner-tvarsT)
             constructorT (<| (type.univ-q (dictionary.size mapping))
                              (type.function inputsT)
                              objectT)]]
      (wrap [constructorT exceptionsT]))))

(type: Evaluation
  (#Pass Method-Signature)
  (#Hint Method-Signature))

(template [<name> <tag>]
  [(def: <name>
     (-> Evaluation (Maybe Method-Signature))
     (|>> (case> (<tag> output)
                 (#.Some output)

                 _
                 #.None)))]

  [pass! #Pass]
  [hint! #Hint]
  )

(def: (method-candidate class-name method-name method-style arg-classes)
  (-> Text Text Method-Style (List Text) (Operation Method-Signature))
  (do ////.monad
    [class (////.lift (reflection!.load class-name))
     candidates (|> class
                    java/lang/Class::getDeclaredMethods
                    array.to-list
                    (list.filter (|>> java/lang/reflect/Method::getName (text@= method-name)))
                    (monad.map @ (: (-> java/lang/reflect/Method (Operation Evaluation))
                                    (function (_ method)
                                      (do @
                                        [passes? (check-method class method-name method-style arg-classes method)]
                                        (:: @ map (if passes?
                                                    (|>> #Pass)
                                                    (|>> #Hint))
                                            (method-signature method-style method)))))))]
    (case (list.search-all pass! candidates)
      (#.Cons method #.Nil)
      (wrap method)

      #.Nil
      (/////analysis.throw ..no-candidates [class-name method-name arg-classes (list.search-all hint! candidates)])
      
      candidates
      (/////analysis.throw ..too-many-candidates [class-name method-name arg-classes candidates]))))

(def: constructor-method "<init>")

(def: (constructor-candidate class-name arg-classes)
  (-> Text (List Text) (Operation Method-Signature))
  (do ////.monad
    [class (////.lift (reflection!.load class-name))
     candidates (|> class
                    java/lang/Class::getConstructors
                    array.to-list
                    (monad.map @ (function (_ constructor)
                                   (do @
                                     [passes? (check-constructor class arg-classes constructor)]
                                     (:: @ map
                                         (if passes? (|>> #Pass) (|>> #Hint))
                                         (constructor-signature constructor))))))]
    (case (list.search-all pass! candidates)
      (#.Cons constructor #.Nil)
      (wrap constructor)

      #.Nil
      (/////analysis.throw ..no-candidates [class-name ..constructor-method arg-classes (list.search-all hint! candidates)])
      
      candidates
      (/////analysis.throw ..too-many-candidates [class-name ..constructor-method arg-classes candidates]))))

(def: typed-input
  (Parser [Text Code])
  (s.tuple (p.and s.text s.any)))

(def: (decorate-inputs typesT inputsA)
  (-> (List Text) (List Analysis) (List Analysis))
  (|> inputsA
      (list.zip2 (list@map /////analysis.text typesT))
      (list@map (function (_ [type value])
                  (/////analysis.tuple (list type value))))))

(def: invoke::static
  Handler
  (..custom [($_ p.and ..member (p.some ..typed-input))
             (function (_ extension-name analyse [[class method] argsTC])
               (do ////.monad
                 [#let [argsT (list@map product.left argsTC)]
                  [methodT exceptionsT] (method-candidate class method #Static argsT)
                  [outputT argsA] (inferenceA.general analyse methodT (list@map product.right argsTC))
                  outputJC (check-return outputT)]
                 (wrap (#/////analysis.Extension extension-name (list& (/////analysis.text class)
                                                                       (/////analysis.text method)
                                                                       (/////analysis.text outputJC)
                                                                       (decorate-inputs argsT argsA))))))]))

(def: invoke::virtual
  Handler
  (..custom [($_ p.and ..member s.any (p.some ..typed-input))
             (function (_ extension-name analyse [[class method] objectC argsTC])
               (do ////.monad
                 [#let [argsT (list@map product.left argsTC)]
                  [methodT exceptionsT] (method-candidate class method #Virtual argsT)
                  [outputT allA] (inferenceA.general analyse methodT (list& objectC (list@map product.right argsTC)))
                  #let [[objectA argsA] (case allA
                                          (#.Cons objectA argsA)
                                          [objectA argsA]

                                          _
                                          (undefined))]
                  outputJC (check-return outputT)]
                 (wrap (#/////analysis.Extension extension-name (list& (/////analysis.text class)
                                                                       (/////analysis.text method)
                                                                       (/////analysis.text outputJC)
                                                                       objectA
                                                                       (decorate-inputs argsT argsA))))))]))

(def: invoke::special
  Handler
  (..custom [($_ p.and ..member s.any (p.some ..typed-input))
             (function (_ extension-name analyse [[class method] objectC argsTC])
               (do ////.monad
                 [#let [argsT (list@map product.left argsTC)]
                  [methodT exceptionsT] (method-candidate class method #Special argsT)
                  [outputT argsA] (inferenceA.general analyse methodT (list& objectC (list@map product.right argsTC)))
                  outputJC (check-return outputT)]
                 (wrap (#/////analysis.Extension extension-name (list& (/////analysis.text class)
                                                                       (/////analysis.text method)
                                                                       (/////analysis.text outputJC)
                                                                       (decorate-inputs argsT argsA))))))]))

(def: invoke::interface
  Handler
  (..custom [($_ p.and ..member s.any (p.some ..typed-input))
             (function (_ extension-name analyse [[class-name method] objectC argsTC])
               (do ////.monad
                 [#let [argsT (list@map product.left argsTC)]
                  class (////.lift (reflection!.load class-name))
                  _ (////.assert non-interface class-name
                                 (java/lang/reflect/Modifier::isInterface (java/lang/Class::getModifiers class)))
                  [methodT exceptionsT] (method-candidate class-name method #Interface argsT)
                  [outputT allA] (inferenceA.general analyse methodT (list& objectC (list@map product.right argsTC)))
                  #let [[objectA argsA] (case allA
                                          (#.Cons objectA argsA)
                                          [objectA argsA]

                                          _
                                          (undefined))]
                  outputJC (check-return outputT)]
                 (wrap (#/////analysis.Extension extension-name
                                                 (list& (/////analysis.text class-name)
                                                        (/////analysis.text method)
                                                        (/////analysis.text outputJC)
                                                        objectA
                                                        (decorate-inputs argsT argsA))))))]))

(def: invoke::constructor
  (..custom [($_ p.and s.text (p.some ..typed-input))
             (function (_ extension-name analyse [class argsTC])
               (do ////.monad
                 [#let [argsT (list@map product.left argsTC)]
                  [methodT exceptionsT] (constructor-candidate class argsT)
                  [outputT argsA] (inferenceA.general analyse methodT (list@map product.right argsTC))]
                 (wrap (#/////analysis.Extension extension-name (list& (/////analysis.text class)
                                                                       (decorate-inputs argsT argsA))))))]))

(def: bundle::member
  Bundle
  (<| (///bundle.prefix "member")
      (|> ///bundle.empty
          (dictionary.merge (<| (///bundle.prefix "static")
                                (|> ///bundle.empty
                                    (///bundle.install "get" static::get)
                                    (///bundle.install "put" static::put))))
          (dictionary.merge (<| (///bundle.prefix "virtual")
                                (|> ///bundle.empty
                                    (///bundle.install "get" virtual::get)
                                    (///bundle.install "put" virtual::put))))
          (dictionary.merge (<| (///bundle.prefix "invoke")
                                (|> ///bundle.empty
                                    (///bundle.install "static" invoke::static)
                                    (///bundle.install "virtual" invoke::virtual)
                                    (///bundle.install "special" invoke::special)
                                    (///bundle.install "interface" invoke::interface)
                                    (///bundle.install "constructor" invoke::constructor)
                                    )))
          )))

(def: var
  (Parser Var)
  s.text)

(def: bound
  (Parser Bound)
  (p.or (s.identifier! ["" ">"])
        (s.identifier! ["" "<"])))

(def: generic
  (Parser Generic)
  (p.rec
   (function (_ generic)
     (let [wildcard (: (Parser (Maybe [Bound Generic]))
                       (p.or (s.identifier! ["" "?"])
                             (s.form (p.and ..bound generic))))
           class (: (Parser Class)
                    (s.form (p.and s.text (p.some generic))))]
       ($_ p.or
           ..var
           wildcard
           class)))))

(def: class
  (Parser Class)
  (s.form (p.and s.text (p.some ..generic))))

(def: primitive
  (Parser Primitive)
  ($_ p.or
      (s.identifier! ["" reflection.boolean])
      (s.identifier! ["" reflection.byte])
      (s.identifier! ["" reflection.short])
      (s.identifier! ["" reflection.int])
      (s.identifier! ["" reflection.long])
      (s.identifier! ["" reflection.float])
      (s.identifier! ["" reflection.double])
      (s.identifier! ["" reflection.char])
      ))

(def: type
  (Parser Type)
  (p.rec
   (function (_ type)
     ($_ p.or
         ..primitive
         ..generic
         (s.tuple type)))))

(def: typed
  (Parser (Typed Code))
  (s.tuple (p.and ..type s.any)))

(type: #export (Annotation-Parameter a)
  [Text a])

(def: annotation-parameter
  (Parser (Annotation-Parameter Code))
  (s.tuple (p.and s.text s.any)))

(type: #export (Annotation a)
  [Text (List (Annotation-Parameter a))])

(def: annotation
  (Parser (Annotation Code))
  (s.form (p.and s.text (p.some ..annotation-parameter))))

(def: argument
  (Parser Argument)
  (s.tuple (p.and s.text ..type)))

(def: return
  (Parser Return)
  (p.or (s.identifier! ["" reflection.void])
        ..type))

(type: #export (Overriden-Method a)
  [Class
   Text
   Bit
   (List (Annotation a))
   (List Var)
   Text
   (List Argument)
   Return
   (List Class)
   a])

(type: #export (Method-Definition a)
  (#Overriden-Method (Overriden-Method a)))

(def: overriden-method-definition
  (Parser (Overriden-Method Code))
  (<| s.form
      (p.after (s.text! "override"))
      ($_ p.and
          ..class
          s.text
          s.bit
          (s.tuple (p.some ..annotation))
          (s.tuple (p.some ..var))
          s.text
          (s.tuple (p.some ..argument))
          ..return
          (s.tuple (p.some ..class))
          s.any
          )))

(def: (generic-analysis generic)
  (-> Generic Analysis)
  (case generic
    (#jvm.Var var)
    (/////analysis.text var)
    
    (#jvm.Wildcard wildcard)
    (case wildcard
      #.None
      (/////analysis.constant ["" "?"])
      
      (#.Some [bound limit])
      (/////analysis.tuple (list (case bound
                                   #jvm.Lower
                                   (/////analysis.constant ["" ">"])
                                   
                                   #jvm.Upper
                                   (/////analysis.constant ["" "<"]))
                                 (generic-analysis limit))))
    
    (#jvm.Class name parameters)
    (/////analysis.tuple (list& (/////analysis.text name)
                                (list@map generic-analysis parameters)))))

(def: (class-analysis [name parameters])
  (-> Class Analysis)
  (/////analysis.tuple (list& (/////analysis.text name)
                              (list@map generic-analysis parameters))))

(def: (annotation-parameter-analysis [name value])
  (-> (Annotation-Parameter Analysis) Analysis)
  (/////analysis.tuple (list (/////analysis.text name) value)))

(def: (annotation-analysis [name parameters])
  (-> (Annotation Analysis) Analysis)
  (/////analysis.tuple (list& (/////analysis.text name)
                              (list@map annotation-parameter-analysis parameters))))

(def: var-analysis
  (-> Var Analysis)
  /////analysis.text)

(def: (type-analysis type)
  (-> Type Analysis)
  (case type
    (#jvm.Primitive primitive)
    (case primitive
      #jvm.Boolean (/////analysis.constant ["" reflection.boolean])
      #jvm.Byte (/////analysis.constant ["" reflection.byte])
      #jvm.Short (/////analysis.constant ["" reflection.short])
      #jvm.Int (/////analysis.constant ["" reflection.int])
      #jvm.Long (/////analysis.constant ["" reflection.long])
      #jvm.Float (/////analysis.constant ["" reflection.float])
      #jvm.Double (/////analysis.constant ["" reflection.double])
      #jvm.Char (/////analysis.constant ["" reflection.char]))
    
    (#jvm.Generic generic)
    (generic-analysis generic)
    
    (#jvm.Array type)
    (/////analysis.tuple (list (type-analysis type)))))

(def: (return-analysis return)
  (-> Return Analysis)
  (case return
    #.None
    (/////analysis.constant ["" jvm.void-descriptor])
    
    (#.Some type)
    (type-analysis type)))

(def: (typed-analysis [type term])
  (-> (Typed Analysis) Analysis)
  (/////analysis.tuple (list (type-analysis type) term)))

(template [<name> <filter>]
  [(def: <name>
     (-> (java/lang/Class java/lang/Object)
         (Error (List [Text Method])))
     (|>> java/lang/Class::getDeclaredMethods
          array.to-list
          <filter>
          (monad.map error.monad
                     (function (_ method)
                       (do error.monad
                         [inputs (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                                     array.to-list
                                     (monad.map @ reflection!.type))
                          return (|> method
                                     java/lang/reflect/Method::getGenericReturnType
                                     reflection!.return)
                          exceptions (|> (java/lang/reflect/Method::getGenericExceptionTypes method)
                                         array.to-list
                                         (monad.map @ reflection!.generic))]
                         (wrap [(java/lang/reflect/Method::getName method)
                                (jvm.method inputs return exceptions)]))))))]

  [abstract-methods (list.filter (|>> java/lang/reflect/Method::getModifiers java/lang/reflect/Modifier::isAbstract))]
  [methods (<|)]
  )

(def: jvm-package-separator ".")

(template [<name> <methods>]
  [(def: <name>
     (-> (List Class) (Error (List [Text Method])))
     (|>> (monad.map error.monad (|>> product.left reflection!.load))
          (error@map (monad.map error.monad <methods>))
          error@join
          (error@map list@join)))]

  [all-abstract-methods ..abstract-methods]
  [all-methods ..methods]
  )

(template [<name>]
  [(exception: #export (<name> {methods (List Text)})
     (exception.report
      ["Methods" (exception.enumerate %t methods)]))]

  [missing-abstract-methods]
  [invalid-overriden-methods]
  )

(def: class::anonymous
  Handler
  (..custom [($_ p.and
                 ..class
                 (s.tuple (p.some ..class))
                 (s.tuple (p.some ..typed))
                 (s.tuple (p.some ..overriden-method-definition)))
             (function (_ extension-name analyse [super-class
                                                  super-interfaces
                                                  constructor-args
                                                  methods])
               (do ////.monad
                 [name (///.lift (do macro.monad
                                   [where macro.current-module-name
                                    id macro.count]
                                   (wrap (format (text.replace-all .module-separator ..jvm-package-separator where)
                                                 ..jvm-package-separator
                                                 "anonymous-class" (%n id)))))
                  super-classT (typeA.with-env
                                 (luxT.class luxT.fresh super-class))
                  super-interfaceT+ (typeA.with-env
                                      (monad.map check.monad
                                                 (luxT.class luxT.fresh)
                                                 super-interfaces))
                  #let [selfT (inheritance-relationship-type (#.Primitive name (list))
                                                             super-classT
                                                             super-interfaceT+)]
                  constructor-argsA+ (monad.map @ (function (_ [type term])
                                                    (do @
                                                      [argT (typeA.with-env
                                                              (luxT.type luxT.fresh type))
                                                       termA (typeA.with-type argT
                                                               (analyse term))]
                                                      (wrap [type termA])))
                                                constructor-args)
                  methodsA (monad.map @ (function (_ [parent-type method-name
                                                      strict-fp? annotations vars
                                                      self-name arguments return exceptions
                                                      body])

                                          (do @
                                            [annotationsA (monad.map @ (function (_ [name parameters])
                                                                         (do @
                                                                           [parametersA (monad.map @ (function (_ [name value])
                                                                                                       (do @
                                                                                                         [valueA (analyse value)]
                                                                                                         (wrap [name valueA])))
                                                                                                   parameters)]
                                                                           (wrap [name parametersA])))
                                                                     annotations)
                                             returnT (typeA.with-env
                                                       (luxT.return luxT.fresh return))
                                             arguments' (typeA.with-env
                                                          (monad.map check.monad
                                                                     (function (_ [name jvmT])
                                                                       (do check.monad
                                                                         [luxT (luxT.type luxT.fresh jvmT)]
                                                                         (wrap [name luxT])))
                                                                     arguments))
                                             [scope bodyA] (|> arguments'
                                                               (#.Cons [self-name selfT])
                                                               list.reverse
                                                               (list@fold scope.with-local (analyse body))
                                                               (typeA.with-type returnT)
                                                               /////analysis.with-scope)]
                                            (wrap (/////analysis.tuple (list (class-analysis parent-type)
                                                                             (/////analysis.text method-name)
                                                                             (/////analysis.bit strict-fp?)
                                                                             (/////analysis.tuple (list@map annotation-analysis annotationsA))
                                                                             (/////analysis.tuple (list@map var-analysis vars))
                                                                             (/////analysis.text self-name)
                                                                             (/////analysis.tuple (list@map (function (_ [argument argumentJT])
                                                                                                              (/////analysis.tuple
                                                                                                               (list (/////analysis.text argument)
                                                                                                                     (type-analysis argumentJT))))
                                                                                                            arguments))
                                                                             (return-analysis return)
                                                                             (/////analysis.tuple (list@map class-analysis
                                                                                                            exceptions))
                                                                             (#/////analysis.Function
                                                                              (scope.environment scope)
                                                                              (/////analysis.tuple (list bodyA)))
                                                                             )))))
                                      methods)
                  required-abstract-methods (////.lift (all-abstract-methods (list& super-class super-interfaces)))
                  available-methods (////.lift (all-methods (list& super-class super-interfaces)))
                  #let [overriden-methods (list@map (function (_ [parent-type method-name
                                                                  strict-fp? annotations vars
                                                                  self-name arguments return exceptions
                                                                  body])
                                                      [method-name (jvm.method (list@map product.right arguments)
                                                                               return
                                                                               (list@map (|>> #jvm.Class) exceptions))])
                                                    methods)
                        missing-abstract-methods (list.filter (function (_ [abstract-method-name abstract-methodJT])
                                                                (|> overriden-methods
                                                                    (list.filter (function (_ [method-name methodJT])
                                                                                   (and (text@= method-name abstract-method-name)
                                                                                        (method@= abstract-methodJT methodJT))))
                                                                    list.size
                                                                    (n/= 1)
                                                                    not))
                                                              required-abstract-methods)
                        invalid-overriden-methods (list.filter (function (_ [method-name methodJT])
                                                                 (|> available-methods
                                                                     (list.filter (function (_ [abstract-method-name abstract-methodJT])
                                                                                    (and (text@= method-name abstract-method-name)
                                                                                         (method@= abstract-methodJT methodJT))))
                                                                     list.size
                                                                     (n/= 1)
                                                                     not))
                                                               overriden-methods)]
                  _ (typeA.infer selfT)
                  _ (////.assert ..missing-abstract-methods (list@map product.left missing-abstract-methods)
                                 (list.empty? missing-abstract-methods))
                  _ (////.assert ..invalid-overriden-methods (list@map product.left invalid-overriden-methods)
                                 (list.empty? invalid-overriden-methods))]
                 (wrap (#/////analysis.Extension extension-name
                                                 (list (/////analysis.text name)
                                                       (class-analysis super-class)
                                                       (/////analysis.tuple (list@map class-analysis super-interfaces))
                                                       (/////analysis.tuple (list@map typed-analysis constructor-argsA+))
                                                       (/////analysis.tuple methodsA))))
                 ))]))

(def: bundle::class
  Bundle
  (<| (///bundle.prefix "class")
      (|> ///bundle.empty
          (///bundle.install "anonymous" class::anonymous)
          )))

(def: #export bundle
  Bundle
  (<| (///bundle.prefix "jvm")
      (|> ///bundle.empty
          (dictionary.merge bundle::conversion)
          (dictionary.merge bundle::int)
          (dictionary.merge bundle::long)
          (dictionary.merge bundle::float)
          (dictionary.merge bundle::double)
          (dictionary.merge bundle::char)
          (dictionary.merge bundle::array)
          (dictionary.merge bundle::object)
          (dictionary.merge bundle::member)
          (dictionary.merge bundle::class)
          )))
