(.module:
  [lux (#- Type primitive type char int)
   ["." host (#+ import:)]
   ["." macro]
   [abstract
    ["." monad (#+ do)]]
   [control
    ["p" parser
     ["s" code (#+ Parser)]
     ["<t>" text]]
    ["." exception (#+ exception:)]
    pipe]
   [data
    ["." error (#+ Error)]
    ["." maybe]
    ["." product]
    ["." text ("#@." equivalence)
     format]
    [collection
     ["." list ("#@." fold functor monoid)]
     ["." array (#+ Array)]
     ["." dictionary (#+ Dictionary)]]]
   ["." type
    ["." check (#+ Check) ("#@." monad)]]
   [target
    ["." jvm #_
     ["#" type (#+ Var Bound Primitive Generic Class Type Argument Return Typed)]]]]
  ["." // #_
   ["#." common]
   ["/#" //
    ["#." bundle]
    ["/#" // ("#@." monad)
     [analysis
      [".A" type]
      [".A" inference]
      ["." scope]]
     ["/#" // #_
      ["#." analysis (#+ Analysis Operation Phase Handler Bundle)]
      ["#." synthesis]]]]])

(def: inheritance-relationship-type-name "_jvm_inheritance")
(def: (inheritance-relationship-type class super-class super-interfaces)
  (-> .Type .Type (List .Type) .Type)
  (#.Primitive ..inheritance-relationship-type-name
               (list& class super-class super-interfaces)))

(template [<label> <constant> <function>]
  [(def: <constant> <label>)
   (def: (<function> class)
     (-> .Type .Type)
     (#.Primitive <constant> (list class)))]

  ["_jvm_lower" lower-relationship-name lower-relationship-type]
  ["_jvm_upper" upper-relationship-name upper-relationship-type]
  )

## TODO: Get rid of this template block and use the definition in
## lux/host.jvm.lux ASAP
(template [<name> <class>]
  [(def: #export <name> .Type (#.Primitive <class> #.Nil))]

  ## Boxes
  [Boolean   jvm.boolean-box]
  [Byte      jvm.byte-box]
  [Short     jvm.short-box]
  [Integer   jvm.int-box]
  [Long      jvm.long-box]
  [Float     jvm.float-box]
  [Double    jvm.double-box]
  [Character jvm.char-box]
  [String    "java.lang.String"]

  ## Primitives
  [boolean   jvm.boolean-reflection]
  [byte      jvm.byte-reflection]
  [short     jvm.short-reflection]
  [int       jvm.int-reflection]
  [long      jvm.long-reflection]
  [float     jvm.float-reflection]
  [double    jvm.double-reflection]
  [char      jvm.char-reflection]
  )

(type: Mapping
  (Dictionary Var .Type))

(def: fresh-mapping Mapping (dictionary.new text.hash))

(exception: #export (unknown-jvm-type-var {var Var})
  (exception.report
   ["Var" (%t var)]))

(def: (generic-type mapping generic)
  (-> Mapping Generic (Check .Type))
  (case generic
    (#jvm.Var var)
    (case (dictionary.get var mapping)
      #.None
      (check.throw ..unknown-jvm-type-var var)
      
      (#.Some type)
      (check@wrap type))
    
    (#jvm.Wildcard wildcard)
    (case wildcard
      #.None
      (do check.monad
        [[id type] check.existential]
        (wrap type))
      
      (#.Some [bound limit])
      (do check.monad
        [limitT (generic-type mapping limit)]
        (case bound
          #jvm.Lower
          (wrap (lower-relationship-type limitT))
          
          #jvm.Upper
          (wrap (upper-relationship-type limitT)))))
    
    (#jvm.Class name parameters)
    (do check.monad
      [parametersT+ (monad.map @ (generic-type mapping) parameters)]
      (wrap (#.Primitive name parametersT+)))))

(def: (class-type mapping [name parameters])
  (-> Mapping Class (Check .Type))
  (do check.monad
    [parametersT+ (monad.map @ (generic-type mapping) parameters)]
    (wrap (#.Primitive name parametersT+))))

(def: (jvm-type mapping type)
  (-> Mapping Type (Check .Type))
  (case type
    (#jvm.Primitive primitive)
    (check@wrap (case primitive
                  #jvm.Boolean ..boolean
                  #jvm.Byte ..byte
                  #jvm.Short ..short
                  #jvm.Int ..int
                  #jvm.Long ..long
                  #jvm.Float ..float
                  #jvm.Double ..double
                  #jvm.Char ..char))
    
    (#jvm.Generic generic)
    (generic-type mapping generic)
    
    (#jvm.Array type)
    (case type
      (#jvm.Primitive primitive)
      (check@wrap (#.Primitive (jvm.descriptor (jvm.array 1 type)) (list)))

      _
      (do check.monad
        [elementT (jvm-type mapping type)]
        (wrap (.type (Array elementT)))))))

(def: (return-type mapping type)
  (-> Mapping Return (Check .Type))
  (case type
    #.None
    (check@wrap Any)

    (#.Some type)
    (jvm-type mapping type)))

(def: (custom [syntax handler])
  (All [s]
    (-> [(Parser s)
         (-> Text Phase s (Operation Analysis))]
        Handler))
  (function (_ extension-name analyse args)
    (case (s.run args syntax)
      (#error.Success inputs)
      (handler extension-name analyse inputs)

      (#error.Failure error)
      (/////analysis.throw ///.invalid-syntax [extension-name %code args]))))

(type: Member
  {#class Text
   #member Text})

(def: member
  (Parser Member)
  ($_ p.and s.text s.text))

(type: Method-Signature
  {#method .Type
   #exceptions (List .Type)})

(import: #long java/lang/reflect/Type
  (getTypeName [] String))

(template [<name>]
  [(exception: #export (<name> {jvm-type java/lang/reflect/Type})
     (exception.report
      ["JVM Type" (java/lang/reflect/Type::getTypeName jvm-type)]))]

  [jvm-type-is-not-a-class]
  [cannot-convert-to-a-class]
  [cannot-convert-to-a-parameter]
  [cannot-convert-to-a-lux-type]
  )

(template [<name>]
  [(exception: #export (<name> {type .Type})
     (exception.report
      ["Type" (%type type)]))]

  [non-object]
  [non-array]
  [non-jvm-type]
  )

(template [<name>]
  [(exception: #export (<name> {class Text})
     (exception.report
      ["Class/type" (%t class)]))]

  [unknown-class]
  [non-interface]
  [non-throwable]
  [primitives-are-not-objects]
  )

(template [<name>]
  [(exception: #export (<name> {class Text} {field Text})
     (exception.report
      ["Class" (%t class)]
      ["Field" (%t field)]))]

  [unknown-field]
  [not-a-static-field]
  [not-a-virtual-field]
  [cannot-set-a-final-field]
  )

(template [<name>]
  [(exception: #export (<name> {class Text}
                               {method Text}
                               {arg-classes (List Text)}
                               {hints (List Method-Signature)})
     (exception.report
      ["Class" class]
      ["Method" method]
      ["Arguments" (exception.enumerate %t arg-classes)]
      ["Hints" (exception.enumerate %type (list@map product.left hints))]))]

  [no-candidates]
  [too-many-candidates]
  )

(exception: #export (cannot-cast {from .Type} {to .Type} {value Code})
  (exception.report
   ["From" (%type from)]
   ["To" (%type to)]
   ["Value" (%code value)]))

(template [<name>]
  [(exception: #export (<name> {message Text})
     message)]

  [primitives-cannot-have-type-parameters]

  [mistaken-field-owner]

  [cannot-possibly-be-an-instance]

  [unknown-type-var]
  [type-parameter-mismatch]
  [cannot-correspond-type-with-a-class]
  )

(def: bundle::conversion
  Bundle
  (<| (///bundle.prefix "conversion")
      (|> ///bundle.empty
          (///bundle.install "double-to-float" (//common.unary ..double ..float))
          (///bundle.install "double-to-int" (//common.unary ..double ..int))
          (///bundle.install "double-to-long" (//common.unary ..double ..long))
          (///bundle.install "float-to-double" (//common.unary ..float ..double))
          (///bundle.install "float-to-int" (//common.unary ..float ..int))
          (///bundle.install "float-to-long" (//common.unary ..float ..long))
          (///bundle.install "int-to-byte" (//common.unary ..int ..byte))
          (///bundle.install "int-to-char" (//common.unary ..int ..char))
          (///bundle.install "int-to-double" (//common.unary ..int ..double))
          (///bundle.install "int-to-float" (//common.unary ..int ..float))
          (///bundle.install "int-to-long" (//common.unary ..int ..long))
          (///bundle.install "int-to-short" (//common.unary ..int ..short))
          (///bundle.install "long-to-double" (//common.unary ..long ..double))
          (///bundle.install "long-to-float" (//common.unary ..long ..float))
          (///bundle.install "long-to-int" (//common.unary ..long ..int))
          (///bundle.install "long-to-short" (//common.unary ..long ..short))
          (///bundle.install "long-to-byte" (//common.unary ..long ..byte))
          (///bundle.install "char-to-byte" (//common.unary ..char ..byte))
          (///bundle.install "char-to-short" (//common.unary ..char ..short))
          (///bundle.install "char-to-int" (//common.unary ..char ..int))
          (///bundle.install "char-to-long" (//common.unary ..char ..long))
          (///bundle.install "byte-to-long" (//common.unary ..byte ..long))
          (///bundle.install "short-to-long" (//common.unary ..short ..long))
          )))

(template [<name> <prefix> <type>]
  [(def: <name>
     Bundle
     (<| (///bundle.prefix <prefix>)
         (|> ///bundle.empty
             (///bundle.install "+" (//common.binary <type> <type> <type>))
             (///bundle.install "-" (//common.binary <type> <type> <type>))
             (///bundle.install "*" (//common.binary <type> <type> <type>))
             (///bundle.install "/" (//common.binary <type> <type> <type>))
             (///bundle.install "%" (//common.binary <type> <type> <type>))
             (///bundle.install "=" (//common.binary <type> <type> Bit))
             (///bundle.install "<" (//common.binary <type> <type> Bit))
             (///bundle.install "and" (//common.binary <type> <type> <type>))
             (///bundle.install "or" (//common.binary <type> <type> <type>))
             (///bundle.install "xor" (//common.binary <type> <type> <type>))
             (///bundle.install "shl" (//common.binary <type> Integer <type>))
             (///bundle.install "shr" (//common.binary <type> Integer <type>))
             (///bundle.install "ushr" (//common.binary <type> Integer <type>))
             )))]

  [bundle::int  jvm.int-reflection  ..long]
  [bundle::long jvm.long-reflection ..long]
  )

(template [<name> <prefix> <type>]
  [(def: <name>
     Bundle
     (<| (///bundle.prefix <prefix>)
         (|> ///bundle.empty
             (///bundle.install "+" (//common.binary <type> <type> <type>))
             (///bundle.install "-" (//common.binary <type> <type> <type>))
             (///bundle.install "*" (//common.binary <type> <type> <type>))
             (///bundle.install "/" (//common.binary <type> <type> <type>))
             (///bundle.install "%" (//common.binary <type> <type> <type>))
             (///bundle.install "=" (//common.binary <type> <type> Bit))
             (///bundle.install "<" (//common.binary <type> <type> Bit))
             )))]

  [bundle::float  jvm.float-reflection  ..float]
  [bundle::double jvm.double-reflection ..double]
  )

(def: bundle::char
  Bundle
  (<| (///bundle.prefix jvm.char-reflection)
      (|> ///bundle.empty
          (///bundle.install "=" (//common.binary ..char ..char Bit))
          (///bundle.install "<" (//common.binary ..char ..char Bit))
          )))

(def: #export boxes
  (Dictionary Text Text)
  (|> (list [jvm.boolean-reflection jvm.boolean-box]
            [jvm.byte-reflection    jvm.byte-box]
            [jvm.short-reflection   jvm.short-box]
            [jvm.int-reflection     jvm.int-box]
            [jvm.long-reflection    jvm.long-box]
            [jvm.float-reflection   jvm.float-box]
            [jvm.double-reflection  jvm.double-box]
            [jvm.char-reflection    jvm.char-box])
      (dictionary.from-list text.hash)))

(def: (array-type-info allow-primitives? arrayT)
  (-> Bit .Type (Operation [Nat Text]))
  (loop [level 0
         currentT arrayT]
    (case currentT
      (#.Apply inputT abstractionT)
      (case (type.apply (list inputT) abstractionT)
        (#.Some outputT)
        (recur level outputT)

        #.None
        (/////analysis.throw non-array arrayT))

      (^ (#.Primitive (static array.type-name) (list elemT)))
      (recur (inc level) elemT)

      (#.Primitive class #.Nil)
      (if (and (dictionary.contains? class boxes)
               (not allow-primitives?))
        (/////analysis.throw ..primitives-are-not-objects [class])
        (////@wrap [level class]))

      (#.Primitive class _)
      (if (dictionary.contains? class boxes)
        (/////analysis.throw ..primitives-cannot-have-type-parameters class)
        (////@wrap [level class]))
      
      _
      (/////analysis.throw non-array arrayT))))

(def: (primitive-array-length-handler primitive-type)
  (-> Type Handler)
  (function (_ extension-name analyse args)
    (case args
      (^ (list arrayC))
      (do ////.monad
        [_ (typeA.infer ..int)
         arrayA (typeA.with-type (#.Primitive (jvm.descriptor (jvm.array 1 primitive-type)) (list))
                  (analyse arrayC))]
        (wrap (#/////analysis.Extension extension-name (list arrayA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: array::length::object
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list arrayC))
      (do ////.monad
        [_ (typeA.infer ..int)
         [var-id varT] (typeA.with-env check.var)
         arrayA (typeA.with-type (.type (Array varT))
                  (analyse arrayC))
         varT (typeA.with-env (check.clean varT))
         [array-nesting elem-class] (array-type-info true (.type (Array varT)))]
        (wrap (#/////analysis.Extension extension-name (list (/////analysis.nat array-nesting)
                                                             (/////analysis.text elem-class)
                                                             arrayA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: (new-primitive-array-handler primitive-type)
  (-> Type Handler)
  (function (_ extension-name analyse args)
    (case args
      (^ (list lengthC))
      (do ////.monad
        [lengthA (typeA.with-type ..int
                   (analyse lengthC))
         _ (typeA.infer (#.Primitive (jvm.descriptor (jvm.array 1 primitive-type)) (list)))]
        (wrap (#/////analysis.Extension extension-name (list lengthA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: array::new::object
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list lengthC))
      (do ////.monad
        [lengthA (typeA.with-type ..int
                   (analyse lengthC))
         expectedT (///.lift macro.expected-type)
         [level elem-class] (array-type-info false expectedT)
         _ (if (n/> 0 level)
             (wrap [])
             (/////analysis.throw non-array expectedT))]
        (wrap (#/////analysis.Extension extension-name (list (/////analysis.nat (dec level))
                                                             (/////analysis.text elem-class)
                                                             lengthA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: (check-jvm objectT)
  (-> .Type (Operation Type))
  (case objectT
    (#.Primitive name #.Nil)
    (case name
      (^ (static jvm.boolean-reflection)) (////@wrap jvm.boolean)
      (^ (static jvm.byte-reflection)) (////@wrap jvm.byte)
      (^ (static jvm.short-reflection)) (////@wrap jvm.short)
      (^ (static jvm.int-reflection)) (////@wrap jvm.int)
      (^ (static jvm.long-reflection)) (////@wrap jvm.long)
      (^ (static jvm.float-reflection)) (////@wrap jvm.float)
      (^ (static jvm.double-reflection)) (////@wrap jvm.double)
      (^ (static jvm.char-reflection)) (////@wrap jvm.char)
      _ (if (text.starts-with? jvm.array-prefix name)
          (////.lift (<t>.run jvm.parse-signature name))
          (////@wrap (jvm.class name (list)))))

    (^ (#.Primitive (static array.type-name)
                    (list elementT)))
    (|> elementT
        check-jvm
        (////@map (jvm.array 1)))
    
    (#.Primitive name parameters)
    (do ////.monad
      [parameters (monad.map @ check-jvm parameters)
       parameters (monad.map @ (function (_ parameter)
                                 (case parameter
                                   (#jvm.Generic generic)
                                   (wrap generic)

                                   _
                                   (/////analysis.throw ..primitives-cannot-have-type-parameters name)))
                             parameters)]
      (////@wrap (jvm.class name parameters)))

    (#.Named name anonymous)
    (check-jvm anonymous)

    (^template [<tag>]
      (<tag> id)
      (////@wrap (jvm.class "java.lang.Object" (list))))
    ([#.Var]
     [#.Ex])

    (^template [<tag>]
      (<tag> env unquantified)
      (check-jvm unquantified))
    ([#.UnivQ]
     [#.ExQ])

    (#.Apply inputT abstractionT)
    (case (type.apply (list inputT) abstractionT)
      (#.Some outputT)
      (check-jvm outputT)

      #.None
      (/////analysis.throw ..non-object objectT))

    _
    (/////analysis.throw ..non-object objectT)))

(def: (check-object objectT)
  (-> .Type (Operation Text))
  (do ////.monad
    [name (:: @ map jvm.reflection-class (check-jvm objectT))]
    (if (dictionary.contains? name ..boxes)
      (/////analysis.throw ..primitives-are-not-objects [name])
      (////@wrap name))))

(def: (check-return type)
  (-> .Type (Operation Text))
  (if (is? .Any type)
    (////@wrap jvm.void-descriptor)
    (////@map jvm.signature (check-jvm type))))

(def: (read-primitive-array-handler lux-type jvm-type)
  (-> .Type Type Handler)
  (function (_ extension-name analyse args)
    (case args
      (^ (list idxC arrayC))
      (do ////.monad
        [_ (typeA.infer lux-type)
         idxA (typeA.with-type ..int
                (analyse idxC))
         arrayA (typeA.with-type (#.Primitive (jvm.descriptor (jvm.array 1 jvm-type)) (list))
                  (analyse arrayC))]
        (wrap (#/////analysis.Extension extension-name (list idxA arrayA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 2 (list.size args)]))))

(def: array::read::object
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list idxC arrayC))
      (do ////.monad
        [[var-id varT] (typeA.with-env check.var)
         _ (typeA.infer varT)
         arrayA (typeA.with-type (.type (Array varT))
                  (analyse arrayC))
         varT (typeA.with-env
                (check.clean varT))
         [nesting elem-class] (array-type-info false varT)
         idxA (typeA.with-type ..int
                (analyse idxC))]
        (wrap (#/////analysis.Extension extension-name (list (/////analysis.nat (inc nesting))
                                                             (/////analysis.text elem-class)
                                                             idxA
                                                             arrayA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 2 (list.size args)]))))

(def: (write-primitive-array-handler lux-type jvm-type)
  (-> .Type Type Handler)
  (let [array-type (#.Primitive (jvm.descriptor (jvm.array 1 jvm-type)) (list))]
    (function (_ extension-name analyse args)
      (case args
        (^ (list idxC valueC arrayC))
        (do ////.monad
          [_ (typeA.infer array-type)
           idxA (typeA.with-type ..int
                  (analyse idxC))
           valueA (typeA.with-type lux-type
                    (analyse valueC))
           arrayA (typeA.with-type array-type
                    (analyse arrayC))]
          (wrap (#/////analysis.Extension extension-name (list idxA
                                                               valueA
                                                               arrayA))))

        _
        (/////analysis.throw ///.incorrect-arity [extension-name 3 (list.size args)])))))

(def: array::write::object
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list idxC valueC arrayC))
      (do ////.monad
        [[var-id varT] (typeA.with-env check.var)
         _ (typeA.infer (.type (Array varT)))
         arrayA (typeA.with-type (.type (Array varT))
                  (analyse arrayC))
         varT (typeA.with-env
                (check.clean varT))
         [nesting elem-class] (array-type-info false varT)
         idxA (typeA.with-type ..int
                (analyse idxC))
         valueA (typeA.with-type varT
                  (analyse valueC))]
        (wrap (#/////analysis.Extension extension-name (list (/////analysis.nat (inc nesting))
                                                             (/////analysis.text elem-class)
                                                             idxA
                                                             valueA
                                                             arrayA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 3 (list.size args)]))))

(def: bundle::array
  Bundle
  (<| (///bundle.prefix "array")
      (|> ///bundle.empty
          (dictionary.merge (<| (///bundle.prefix "length")
                                (|> ///bundle.empty
                                    (///bundle.install jvm.boolean-reflection (primitive-array-length-handler jvm.boolean))
                                    (///bundle.install jvm.byte-reflection (primitive-array-length-handler jvm.byte))
                                    (///bundle.install jvm.short-reflection (primitive-array-length-handler jvm.short))
                                    (///bundle.install jvm.int-reflection (primitive-array-length-handler jvm.int))
                                    (///bundle.install jvm.long-reflection (primitive-array-length-handler jvm.long))
                                    (///bundle.install jvm.float-reflection (primitive-array-length-handler jvm.float))
                                    (///bundle.install jvm.double-reflection (primitive-array-length-handler jvm.double))
                                    (///bundle.install jvm.char-reflection (primitive-array-length-handler jvm.char))
                                    (///bundle.install "object" array::length::object))))
          (dictionary.merge (<| (///bundle.prefix "new")
                                (|> ///bundle.empty
                                    (///bundle.install jvm.boolean-reflection (new-primitive-array-handler jvm.boolean))
                                    (///bundle.install jvm.byte-reflection (new-primitive-array-handler jvm.byte))
                                    (///bundle.install jvm.short-reflection (new-primitive-array-handler jvm.short))
                                    (///bundle.install jvm.int-reflection (new-primitive-array-handler jvm.int))
                                    (///bundle.install jvm.long-reflection (new-primitive-array-handler jvm.long))
                                    (///bundle.install jvm.float-reflection (new-primitive-array-handler jvm.float))
                                    (///bundle.install jvm.double-reflection (new-primitive-array-handler jvm.double))
                                    (///bundle.install jvm.char-reflection (new-primitive-array-handler jvm.char))
                                    (///bundle.install "object" array::new::object))))
          (dictionary.merge (<| (///bundle.prefix "read")
                                (|> ///bundle.empty
                                    (///bundle.install jvm.boolean-reflection (read-primitive-array-handler ..boolean jvm.boolean))
                                    (///bundle.install jvm.byte-reflection (read-primitive-array-handler ..byte jvm.byte))
                                    (///bundle.install jvm.short-reflection (read-primitive-array-handler ..short jvm.short))
                                    (///bundle.install jvm.int-reflection (read-primitive-array-handler ..int jvm.int))
                                    (///bundle.install jvm.long-reflection (read-primitive-array-handler ..long jvm.long))
                                    (///bundle.install jvm.float-reflection (read-primitive-array-handler ..float jvm.float))
                                    (///bundle.install jvm.double-reflection (read-primitive-array-handler ..double jvm.double))
                                    (///bundle.install jvm.char-reflection (read-primitive-array-handler ..char jvm.char))
                                    (///bundle.install "object" array::read::object))))
          (dictionary.merge (<| (///bundle.prefix "write")
                                (|> ///bundle.empty
                                    (///bundle.install jvm.boolean-reflection (write-primitive-array-handler ..boolean jvm.boolean))
                                    (///bundle.install jvm.byte-reflection (write-primitive-array-handler ..byte jvm.byte))
                                    (///bundle.install jvm.short-reflection (write-primitive-array-handler ..short jvm.short))
                                    (///bundle.install jvm.int-reflection (write-primitive-array-handler ..int jvm.int))
                                    (///bundle.install jvm.long-reflection (write-primitive-array-handler ..long jvm.long))
                                    (///bundle.install jvm.float-reflection (write-primitive-array-handler ..float jvm.float))
                                    (///bundle.install jvm.double-reflection (write-primitive-array-handler ..double jvm.double))
                                    (///bundle.install jvm.char-reflection (write-primitive-array-handler ..char jvm.char))
                                    (///bundle.install "object" array::write::object))))
          )))

(def: object::null
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list))
      (do ////.monad
        [expectedT (///.lift macro.expected-type)
         _ (check-object expectedT)]
        (wrap (#/////analysis.Extension extension-name (list))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 0 (list.size args)]))))

(def: object::null?
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list objectC))
      (do ////.monad
        [_ (typeA.infer Bit)
         [objectT objectA] (typeA.with-inference
                             (analyse objectC))
         _ (check-object objectT)]
        (wrap (#/////analysis.Extension extension-name (list objectA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: object::synchronized
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list monitorC exprC))
      (do ////.monad
        [[monitorT monitorA] (typeA.with-inference
                               (analyse monitorC))
         _ (check-object monitorT)
         exprA (analyse exprC)]
        (wrap (#/////analysis.Extension extension-name (list monitorA exprA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 2 (list.size args)]))))

(import: #long java/lang/Object
  (equals [java/lang/Object] boolean))

(import: java/lang/ClassLoader)

(import: java/lang/reflect/GenericArrayType
  (getGenericComponentType [] java/lang/reflect/Type))

(import: java/lang/reflect/ParameterizedType
  (getRawType [] java/lang/reflect/Type)
  (getActualTypeArguments [] (Array java/lang/reflect/Type)))

(import: (java/lang/reflect/TypeVariable d)
  (getName [] String)
  (getBounds [] (Array java/lang/reflect/Type)))

(import: (java/lang/reflect/WildcardType d)
  (getLowerBounds [] (Array java/lang/reflect/Type))
  (getUpperBounds [] (Array java/lang/reflect/Type)))

(import: java/lang/reflect/Modifier
  (#static isStatic [int] boolean)
  (#static isFinal [int] boolean)
  (#static isInterface [int] boolean)
  (#static isAbstract [int] boolean))

(import: java/lang/reflect/Field
  (getDeclaringClass [] (java/lang/Class java/lang/Object))
  (getModifiers [] int)
  (getGenericType [] java/lang/reflect/Type))

(import: java/lang/reflect/Method
  (getName [] String)
  (getModifiers [] int)
  (getDeclaringClass [] (java/lang/Class java/lang/Object))
  (getTypeParameters [] (Array (TypeVariable Method)))
  (getGenericParameterTypes [] (Array java/lang/reflect/Type))
  (getGenericReturnType [] java/lang/reflect/Type)
  (getGenericExceptionTypes [] (Array java/lang/reflect/Type)))

(import: (java/lang/reflect/Constructor c)
  (getModifiers [] int)
  (getDeclaringClass [] (java/lang/Class c))
  (getTypeParameters [] (Array (TypeVariable (Constructor c))))
  (getGenericParameterTypes [] (Array java/lang/reflect/Type))
  (getGenericExceptionTypes [] (Array java/lang/reflect/Type)))

(import: #long (java/lang/Class c)
  (getName [] String)
  (getModifiers [] int)
  (#static forName [String] #try (java/lang/Class java/lang/Object))
  (isAssignableFrom [(java/lang/Class java/lang/Object)] boolean)
  (getTypeParameters [] (Array (TypeVariable (java/lang/Class c))))
  (getGenericInterfaces [] (Array java/lang/reflect/Type))
  (getGenericSuperclass [] #? java/lang/reflect/Type)
  (getDeclaredField [String] #try Field)
  (getConstructors [] (Array (Constructor java/lang/Object)))
  (getDeclaredMethods [] (Array Method)))

(def: (load-class name)
  (-> Text (Operation (java/lang/Class java/lang/Object)))
  (do ////.monad
    []
    (case (java/lang/Class::forName name)
      (#error.Success [class])
      (wrap class)

      (#error.Failure error)
      (/////analysis.throw unknown-class name))))

(def: (sub-class? super sub)
  (-> Text Text (Operation Bit))
  (do ////.monad
    [super (load-class super)
     sub (load-class sub)]
    (wrap (java/lang/Class::isAssignableFrom sub super))))

(def: object::throw
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list exceptionC))
      (do ////.monad
        [_ (typeA.infer Nothing)
         [exceptionT exceptionA] (typeA.with-inference
                                   (analyse exceptionC))
         exception-class (check-object exceptionT)
         ? (sub-class? "java.lang.Throwable" exception-class)
         _ (: (Operation Any)
              (if ?
                (wrap [])
                (/////analysis.throw non-throwable exception-class)))]
        (wrap (#/////analysis.Extension extension-name (list exceptionA))))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: object::class
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list classC))
      (case classC
        [_ (#.Text class)]
        (do ////.monad
          [_ (typeA.infer (#.Primitive "java.lang.Class" (list (#.Primitive class (list)))))
           _ (load-class class)]
          (wrap (#/////analysis.Extension extension-name (list (/////analysis.text class)))))

        _
        (/////analysis.throw ///.invalid-syntax [extension-name %code args]))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 1 (list.size args)]))))

(def: object::instance?
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list classC objectC))
      (case classC
        [_ (#.Text class)]
        (do ////.monad
          [_ (typeA.infer Bit)
           [objectT objectA] (typeA.with-inference
                               (analyse objectC))
           object-class (check-object objectT)
           ? (sub-class? class object-class)]
          (if ?
            (wrap (#/////analysis.Extension extension-name (list (/////analysis.text class))))
            (/////analysis.throw cannot-possibly-be-an-instance (format object-class " !<= "  class))))

        _
        (/////analysis.throw ///.invalid-syntax [extension-name %code args]))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 2 (list.size args)]))))

(def: (java-type-to-class jvm-type)
  (-> java/lang/reflect/Type (Operation Text))
  (<| (case (host.check java/lang/Class jvm-type)
        (#.Some jvm-type)
        (////@wrap (java/lang/Class::getName jvm-type))

        _)
      (case (host.check ParameterizedType jvm-type)
        (#.Some jvm-type)
        (java-type-to-class (ParameterizedType::getRawType jvm-type))

        _)
      ## else
      (/////analysis.throw cannot-convert-to-a-class jvm-type)))

(def: (java-type-to-lux-type mapping java-type)
  (-> Mapping java/lang/reflect/Type (Operation .Type))
  (<| (case (host.check TypeVariable java-type)
        (#.Some java-type)
        (let [var-name (TypeVariable::getName java-type)]
          (case (dictionary.get var-name mapping)
            (#.Some var-type)
            (////@wrap var-type)
            
            #.None
            (/////analysis.throw unknown-type-var var-name)))

        _)
      (case (host.check WildcardType java-type)
        (#.Some java-type)
        (case [(array.read 0 (WildcardType::getUpperBounds java-type))
               (array.read 0 (WildcardType::getLowerBounds java-type))]
          (^or [(#.Some bound) _] [_ (#.Some bound)])
          (java-type-to-lux-type mapping bound)
          
          _
          (////@wrap Any))
        
        _)
      (case (host.check java/lang/Class java-type)
        (#.Some java-type)
        (let [java-type (:coerce (java/lang/Class java/lang/Object) java-type)
              class-name (java/lang/Class::getName java-type)]
          (case (array.size (java/lang/Class::getTypeParameters java-type))
            0
            (case class-name
              (^ (static jvm.void-reflection))
              (////@wrap Any)

              _
              (if (text.starts-with? jvm.array-prefix class-name)
                (case (<t>.run jvm.parse-signature (jvm.binary-name class-name))
                  (#error.Success jtype)
                  (typeA.with-env
                    (jvm-type fresh-mapping jtype))
                  
                  (#error.Failure error)
                  (/////analysis.fail error))
                (////@wrap (#.Primitive class-name (list)))))
            
            arity
            (////@wrap (|> (list.indices arity)
                           list.reverse
                           (list@map (|>> (n/* 2) inc #.Parameter))
                           (#.Primitive class-name)
                           (type.univ-q arity)))))
        
        _)
      (case (host.check ParameterizedType java-type)
        (#.Some java-type)
        (let [raw (ParameterizedType::getRawType java-type)]
          (case (host.check java/lang/Class raw)
            (#.Some raw)
            (do ////.monad
              [paramsT (|> java-type
                           ParameterizedType::getActualTypeArguments
                           array.to-list
                           (monad.map @ (java-type-to-lux-type mapping)))]
              (////@wrap (#.Primitive (java/lang/Class::getName (:coerce (java/lang/Class java/lang/Object) raw))
                                      paramsT)))

            _
            (/////analysis.throw jvm-type-is-not-a-class raw)))
        
        _)
      (case (host.check GenericArrayType java-type)
        (#.Some java-type)
        (do ////.monad
          [innerT (|> java-type
                      GenericArrayType::getGenericComponentType
                      (java-type-to-lux-type mapping))]
          (wrap (#.Primitive array.type-name (list innerT))))
        
        _)
      ## else
      (/////analysis.throw ..cannot-convert-to-a-lux-type java-type)))

(def: (correspond-type-params class type)
  (-> (java/lang/Class java/lang/Object) .Type (Operation Mapping))
  (case type
    (#.Primitive name params)
    (let [class-name (java/lang/Class::getName class)
          class-params (array.to-list (java/lang/Class::getTypeParameters class))
          num-class-params (list.size class-params)
          num-type-params (list.size params)]
      (cond (not (text@= class-name name))
            (/////analysis.throw cannot-correspond-type-with-a-class
                                 (format "Class = " class-name text.new-line
                                         "Type = " (%type type)))

            (not (n/= num-class-params num-type-params))
            (/////analysis.throw type-parameter-mismatch
                                 (format "Expected: " (%i (.int num-class-params)) text.new-line
                                         "  Actual: " (%i (.int num-type-params)) text.new-line
                                         "   Class: " class-name text.new-line
                                         "    Type: " (%type type)))

            ## else
            (////@wrap (|> params
                           (list.zip2 (list@map (|>> TypeVariable::getName) class-params))
                           (dictionary.from-list text.hash)))
            ))

    (#.Named name anonymousT)
    (correspond-type-params class anonymousT)

    _
    (/////analysis.throw ..non-jvm-type type)))

(def: (class-candiate-parents from-name fromT to-name to-class)
  (-> Text .Type Text (java/lang/Class java/lang/Object) (Operation (List [[Text .Type] Bit])))
  (do ////.monad
    [from-class (load-class from-name)
     mapping (correspond-type-params from-class fromT)]
    (monad.map @
               (function (_ superJT)
                 (do @
                   [super-name (java-type-to-class superJT)
                    super-class (load-class super-name)
                    superT (java-type-to-lux-type mapping superJT)]
                   (wrap [[super-name superT] (java/lang/Class::isAssignableFrom super-class to-class)])))
               (case (java/lang/Class::getGenericSuperclass from-class)
                 (#.Some super)
                 (list& super (array.to-list (java/lang/Class::getGenericInterfaces from-class)))

                 #.None
                 (array.to-list (java/lang/Class::getGenericInterfaces from-class))))))

(def: (inheritance-candiate-parents fromT to-class toT fromC)
  (-> .Type (java/lang/Class java/lang/Object) .Type Code (Operation (List [[Text .Type] Bit])))
  (case fromT
    (^ (#.Primitive _ (list& self-classT super-classT super-interfacesT+)))
    (monad.map ////.monad
               (function (_ superT)
                 (do ////.monad
                   [super-name (:: @ map jvm.reflection-class (check-jvm superT))
                    super-class (load-class super-name)]
                   (wrap [[super-name superT]
                          (java/lang/Class::isAssignableFrom super-class to-class)])))
               (list& super-classT super-interfacesT+))

    _
    (/////analysis.throw cannot-cast [fromT toT fromC])))

(def: object::cast
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list fromC))
      (do ////.monad
        [toT (///.lift macro.expected-type)
         to-name (:: @ map jvm.reflection-class (check-jvm toT))
         [fromT fromA] (typeA.with-inference
                         (analyse fromC))
         from-name (:: @ map jvm.reflection-class (check-jvm fromT))
         can-cast? (: (Operation Bit)
                      (case [from-name to-name]
                        (^template [<primitive> <object>]
                          (^or (^ [(static <primitive>) (static <object>)])
                               (^ [(static <object>) (static <primitive>)])
                               (^ [(static <primitive>) (static <primitive>)]))
                          (wrap #1))
                        ([jvm.boolean-reflection jvm.boolean-box]
                         [jvm.byte-reflection    jvm.byte-box]
                         [jvm.short-reflection   jvm.short-box]
                         [jvm.int-reflection     jvm.int-box]
                         [jvm.long-reflection    jvm.long-box]
                         [jvm.float-reflection   jvm.float-box]
                         [jvm.double-reflection  jvm.double-box]
                         [jvm.char-reflection    jvm.char-box])

                        _
                        (do @
                          [_ (////.assert ..primitives-are-not-objects [from-name]
                                          (not (dictionary.contains? from-name boxes)))
                           _ (////.assert ..primitives-are-not-objects [to-name]
                                          (not (dictionary.contains? to-name boxes)))
                           to-class (load-class to-name)
                           _ (if (text@= ..inheritance-relationship-type-name from-name)
                               (wrap [])
                               (do @
                                 [from-class (load-class from-name)]
                                 (////.assert cannot-cast [fromT toT fromC]
                                              (java/lang/Class::isAssignableFrom from-class to-class))))]
                          (loop [[current-name currentT] [from-name fromT]]
                            (if (text@= to-name current-name)
                              (wrap #1)
                              (do @
                                [candiate-parents (: (Operation (List [[Text .Type] Bit]))
                                                     (if (text@= ..inheritance-relationship-type-name current-name)
                                                       (inheritance-candiate-parents currentT to-class toT fromC)
                                                       (class-candiate-parents current-name currentT to-name to-class)))]
                                (case (|> candiate-parents
                                          (list.filter product.right)
                                          (list@map product.left))
                                  (#.Cons [next-name nextT] _)
                                  (recur [next-name nextT])

                                  #.Nil
                                  (/////analysis.throw cannot-cast [fromT toT fromC]))
                                ))))))]
        (if can-cast?
          (wrap (#/////analysis.Extension extension-name (list (/////analysis.text from-name)
                                                               (/////analysis.text to-name)
                                                               fromA)))
          (/////analysis.throw cannot-cast [fromT toT fromC])))

      _
      (/////analysis.throw ///.invalid-syntax [extension-name %code args]))))

(def: bundle::object
  Bundle
  (<| (///bundle.prefix "object")
      (|> ///bundle.empty
          (///bundle.install "null" object::null)
          (///bundle.install "null?" object::null?)
          (///bundle.install "synchronized" object::synchronized)
          (///bundle.install "throw" object::throw)
          (///bundle.install "class" object::class)
          (///bundle.install "instance?" object::instance?)
          (///bundle.install "cast" object::cast)
          )))

(def: (find-field class-name field-name)
  (-> Text Text (Operation [(java/lang/Class java/lang/Object) Field]))
  (do ////.monad
    [class (load-class class-name)]
    (case (java/lang/Class::getDeclaredField field-name class)
      (#error.Success field)
      (let [owner (Field::getDeclaringClass field)]
        (if (is? owner class)
          (wrap [class field])
          (/////analysis.throw mistaken-field-owner
                               (format "       Field: " field-name text.new-line
                                       " Owner Class: " (java/lang/Class::getName owner) text.new-line
                                       "Target Class: " class-name text.new-line))))

      (#error.Failure _)
      (/////analysis.throw unknown-field [class-name field-name]))))

(def: (static-field class-name field-name)
  (-> Text Text (Operation [.Type Text Bit]))
  (do ////.monad
    [[class fieldJ] (find-field class-name field-name)
     #let [modifiers (Field::getModifiers fieldJ)]]
    (if (Modifier::isStatic modifiers)
      (let [fieldJT (Field::getGenericType fieldJ)]
        (do @
          [fieldT (java-type-to-lux-type fresh-mapping fieldJT)
           unboxed (java-type-to-class fieldJT)]
          (wrap [fieldT unboxed (Modifier::isFinal modifiers)])))
      (/////analysis.throw ..not-a-static-field [class-name field-name]))))

(def: static::get
  Handler
  (..custom [..member
             (function (_ extension-name analyse [class field])
               (do ////.monad
                 [[fieldT unboxed final?] (static-field class field)
                  _ (typeA.infer fieldT)]
                 (wrap (<| (#/////analysis.Extension extension-name)
                           (list (/////analysis.text class)
                                 (/////analysis.text field)
                                 (/////analysis.text unboxed))))))]))

(def: static::put
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list classC fieldC valueC))
      (case [classC fieldC]
        [[_ (#.Text class)] [_ (#.Text field)]]
        (do ////.monad
          [_ (typeA.infer Any)
           [fieldT unboxed final?] (static-field class field)
           _ (////.assert cannot-set-a-final-field [class field]
                          (not final?))
           valueA (typeA.with-type fieldT
                    (analyse valueC))]
          (wrap (#/////analysis.Extension extension-name (list (/////analysis.text class) (/////analysis.text field) valueA))))

        _
        (/////analysis.throw ///.invalid-syntax [extension-name %code args]))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 3 (list.size args)]))))

(def: (virtual-field class-name field-name objectT)
  (-> Text Text .Type (Operation [.Type Bit]))
  (do ////.monad
    [[class fieldJ] (find-field class-name field-name)
     #let [modifiers (Field::getModifiers fieldJ)]]
    (if (not (Modifier::isStatic modifiers))
      (do @
        [#let [fieldJT (Field::getGenericType fieldJ)
               var-names (|> class
                             java/lang/Class::getTypeParameters
                             array.to-list
                             (list@map (|>> TypeVariable::getName)))]
         mapping (: (Operation Mapping)
                    (case objectT
                      (#.Primitive _class-name _class-params)
                      (do @
                        [#let [num-params (list.size _class-params)
                               num-vars (list.size var-names)]
                         _ (////.assert type-parameter-mismatch
                                        (format "Expected: " (%i (.int num-params)) text.new-line
                                                "  Actual: " (%i (.int num-vars)) text.new-line
                                                "   Class: " _class-name text.new-line
                                                "    Type: " (%type objectT))
                                        (n/= num-params num-vars))]
                        (wrap (|> (list.zip2 var-names _class-params)
                                  (dictionary.from-list text.hash))))

                      _
                      (/////analysis.throw ..non-object objectT)))
         fieldT (java-type-to-lux-type mapping fieldJT)]
        (wrap [fieldT (Modifier::isFinal modifiers)]))
      (/////analysis.throw not-a-virtual-field [class-name field-name]))))

(def: virtual::get
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list classC fieldC objectC))
      (case [classC fieldC]
        [[_ (#.Text class)] [_ (#.Text field)]]
        (do ////.monad
          [[objectT objectA] (typeA.with-inference
                               (analyse objectC))
           [fieldT final?] (virtual-field class field objectT)
           _ (typeA.infer fieldT)]
          (wrap (#/////analysis.Extension extension-name (list (/////analysis.text class) (/////analysis.text field) objectA))))

        _
        (/////analysis.throw ///.invalid-syntax [extension-name %code args]))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 3 (list.size args)]))))

(def: virtual::put
  Handler
  (function (_ extension-name analyse args)
    (case args
      (^ (list classC fieldC valueC objectC))
      (case [classC fieldC]
        [[_ (#.Text class)] [_ (#.Text field)]]
        (do ////.monad
          [[objectT objectA] (typeA.with-inference
                               (analyse objectC))
           _ (typeA.infer objectT)
           [fieldT final?] (virtual-field class field objectT)
           _ (////.assert cannot-set-a-final-field [class field]
                          (not final?))
           valueA (typeA.with-type fieldT
                    (analyse valueC))]
          (wrap (#/////analysis.Extension extension-name (list (/////analysis.text class) (/////analysis.text field) valueA objectA))))

        _
        (/////analysis.throw ///.invalid-syntax [extension-name %code args]))

      _
      (/////analysis.throw ///.incorrect-arity [extension-name 4 (list.size args)]))))

(def: (java-type-to-parameter type)
  (-> java/lang/reflect/Type (Operation Text))
  (<| (case (host.check java/lang/Class type)
        (#.Some type)
        (////@wrap (java/lang/Class::getName type))
        
        _)
      (case (host.check ParameterizedType type)
        (#.Some type)
        (java-type-to-parameter (ParameterizedType::getRawType type))
        
        _)
      (case (host.check TypeVariable type)
        (#.Some type)
        (////@wrap "java.lang.Object")
        
        _)
      (case (host.check WildcardType type)
        (#.Some type)
        (////@wrap "java.lang.Object")
        
        _)
      (case (host.check GenericArrayType type)
        (#.Some type)
        (do ////.monad
          [componentP (java-type-to-parameter (GenericArrayType::getGenericComponentType type))]
          (wrap (format componentP "[]")))
        
        _)
      
      ## else
      (/////analysis.throw cannot-convert-to-a-parameter type)))

(type: Method-Style
  #Static
  #Abstract
  #Virtual
  #Special
  #Interface)

(def: reflection-arguments
  (-> (List Text) (Operation (List Text)))
  (|>> (monad.map error.monad (<t>.run jvm.parse-signature))
       (:: error.monad map (list@map jvm.reflection-class))
       ////.lift))

(def: (check-method class method-name method-style arg-classes method)
  (-> (java/lang/Class java/lang/Object) Text Method-Style (List Text) Method (Operation Bit))
  (do ////.monad
    [arg-classes (reflection-arguments arg-classes)
     parameters (|> (Method::getGenericParameterTypes method)
                    array.to-list
                    (monad.map @ java-type-to-parameter))
     #let [modifiers (Method::getModifiers method)]
     #let [correct-class? (java/lang/Object::equals class (Method::getDeclaringClass method))
           correct-method? (text@= method-name (Method::getName method))
           static-matches? (case method-style
                             #Static
                             (Modifier::isStatic modifiers)

                             _
                             #1)
           special-matches? (case method-style
                              #Special
                              (not (or (Modifier::isInterface (java/lang/Class::getModifiers class))
                                       (Modifier::isAbstract modifiers)))

                              _
                              #1)
           arity-matches? (n/= (list.size arg-classes) (list.size parameters))
           inputs-match? (list@fold (function (_ [expectedJC actualJC] prev)
                                      (and prev
                                           (text@= expectedJC actualJC)))
                                    #1
                                    (list.zip2 arg-classes parameters))]]
    (wrap (and correct-class?
               correct-method?
               static-matches?
               special-matches?
               arity-matches?
               inputs-match?))))

(def: (check-constructor class arg-classes constructor)
  (-> (java/lang/Class java/lang/Object) (List Text) (Constructor java/lang/Object) (Operation Bit))
  (do ////.monad
    [arg-classes (reflection-arguments arg-classes)
     parameters (|> (Constructor::getGenericParameterTypes constructor)
                    array.to-list
                    (monad.map @ java-type-to-parameter))]
    (wrap (and (java/lang/Object::equals class (Constructor::getDeclaringClass constructor))
               (n/= (list.size arg-classes) (list.size parameters))
               (list@fold (function (_ [expectedJC actualJC] prev)
                            (and prev
                                 (text@= expectedJC actualJC)))
                          #1
                          (list.zip2 arg-classes parameters))))))

(def: idx-to-parameter
  (-> Nat .Type)
  (|>> (n/* 2) inc #.Parameter))

(def: (jvm-type-var-mapping owner-tvars method-tvars)
  (-> (List Text) (List Text) [(List .Type) Mapping])
  (let [jvm-tvars (list@compose owner-tvars method-tvars)
        lux-tvars (|> jvm-tvars
                      list.reverse
                      list.enumerate
                      (list@map (function (_ [idx name])
                                  [name (idx-to-parameter idx)]))
                      list.reverse)
        num-owner-tvars (list.size owner-tvars)
        owner-tvarsT (|> lux-tvars (list.take num-owner-tvars) (list@map product.right))
        mapping (dictionary.from-list text.hash lux-tvars)]
    [owner-tvarsT mapping]))

(def: (method-signature method-style method)
  (-> Method-Style Method (Operation Method-Signature))
  (let [owner (Method::getDeclaringClass method)
        owner-tvars (case method-style
                      #Static
                      (list)

                      _
                      (|> (java/lang/Class::getTypeParameters owner)
                          array.to-list
                          (list@map (|>> TypeVariable::getName))))
        method-tvars (|> (Method::getTypeParameters method)
                         array.to-list
                         (list@map (|>> TypeVariable::getName)))
        [owner-tvarsT mapping] (jvm-type-var-mapping owner-tvars method-tvars)]
    (do ////.monad
      [inputsT (|> (Method::getGenericParameterTypes method)
                   array.to-list
                   (monad.map @ (java-type-to-lux-type mapping)))
       outputT (java-type-to-lux-type mapping (Method::getGenericReturnType method))
       exceptionsT (|> (Method::getGenericExceptionTypes method)
                       array.to-list
                       (monad.map @ (java-type-to-lux-type mapping)))
       #let [methodT (<| (type.univ-q (dictionary.size mapping))
                         (type.function (case method-style
                                          #Static
                                          inputsT

                                          _
                                          (list& (#.Primitive (java/lang/Class::getName owner) owner-tvarsT)
                                                 inputsT)))
                         outputT)]]
      (wrap [methodT exceptionsT]))))

(def: (constructor-signature constructor)
  (-> (Constructor java/lang/Object) (Operation Method-Signature))
  (let [owner (Constructor::getDeclaringClass constructor)
        owner-tvars (|> (java/lang/Class::getTypeParameters owner)
                        array.to-list
                        (list@map (|>> TypeVariable::getName)))
        method-tvars (|> (Constructor::getTypeParameters constructor)
                         array.to-list
                         (list@map (|>> TypeVariable::getName)))
        [owner-tvarsT mapping] (jvm-type-var-mapping owner-tvars method-tvars)]
    (do ////.monad
      [inputsT (|> (Constructor::getGenericParameterTypes constructor)
                   array.to-list
                   (monad.map @ (java-type-to-lux-type mapping)))
       exceptionsT (|> (Constructor::getGenericExceptionTypes constructor)
                       array.to-list
                       (monad.map @ (java-type-to-lux-type mapping)))
       #let [objectT (#.Primitive (java/lang/Class::getName owner) owner-tvarsT)
             constructorT (<| (type.univ-q (dictionary.size mapping))
                              (type.function inputsT)
                              objectT)]]
      (wrap [constructorT exceptionsT]))))

(type: Evaluation
  (#Pass Method-Signature)
  (#Hint Method-Signature)
  #Fail)

(template [<name> <tag>]
  [(def: <name>
     (-> Evaluation (Maybe Method-Signature))
     (|>> (case> (<tag> output)
                 (#.Some output)

                 _
                 #.None)))]

  [pass! #Pass]
  [hint! #Hint]
  )

(def: (method-candidate class-name method-name method-style arg-classes)
  (-> Text Text Method-Style (List Text) (Operation Method-Signature))
  (do ////.monad
    [class (load-class class-name)
     candidates (|> class
                    java/lang/Class::getDeclaredMethods
                    array.to-list
                    (monad.map @ (: (-> Method (Operation Evaluation))
                                    (function (_ method)
                                      (do @
                                        [passes? (check-method class method-name method-style arg-classes method)]
                                        (cond passes?
                                              (:: @ map (|>> #Pass) (method-signature method-style method))

                                              (text@= method-name (Method::getName method))
                                              (:: @ map (|>> #Hint) (method-signature method-style method))

                                              ## else
                                              (wrap #Fail)))))))]
    (case (list.search-all pass! candidates)
      (#.Cons method #.Nil)
      (wrap method)

      #.Nil
      (/////analysis.throw ..no-candidates [class-name method-name arg-classes (list.search-all hint! candidates)])
      
      candidates
      (/////analysis.throw ..too-many-candidates [class-name method-name arg-classes candidates]))))

(def: constructor-method "<init>")

(def: (constructor-candidate class-name arg-classes)
  (-> Text (List Text) (Operation Method-Signature))
  (do ////.monad
    [class (load-class class-name)
     candidates (|> class
                    java/lang/Class::getConstructors
                    array.to-list
                    (monad.map @ (function (_ constructor)
                                   (do @
                                     [passes? (check-constructor class arg-classes constructor)]
                                     (:: @ map
                                         (if passes? (|>> #Pass) (|>> #Hint))
                                         (constructor-signature constructor))))))]
    (case (list.search-all pass! candidates)
      (#.Cons constructor #.Nil)
      (wrap constructor)

      #.Nil
      (/////analysis.throw ..no-candidates [class-name ..constructor-method arg-classes (list.search-all hint! candidates)])
      
      candidates
      (/////analysis.throw ..too-many-candidates [class-name ..constructor-method arg-classes candidates]))))

(def: typed-input
  (Parser [Text Code])
  (s.tuple (p.and s.text s.any)))

(def: (decorate-inputs typesT inputsA)
  (-> (List Text) (List Analysis) (List Analysis))
  (|> inputsA
      (list.zip2 (list@map /////analysis.text typesT))
      (list@map (function (_ [type value])
                  (/////analysis.tuple (list type value))))))

(def: invoke::static
  Handler
  (..custom [($_ p.and ..member (p.some ..typed-input))
             (function (_ extension-name analyse [[class method] argsTC])
               (do ////.monad
                 [#let [argsT (list@map product.left argsTC)]
                  [methodT exceptionsT] (method-candidate class method #Static argsT)
                  [outputT argsA] (inferenceA.general analyse methodT (list@map product.right argsTC))
                  outputJC (check-return outputT)]
                 (wrap (#/////analysis.Extension extension-name (list& (/////analysis.text class)
                                                                       (/////analysis.text method)
                                                                       (/////analysis.text outputJC)
                                                                       (decorate-inputs argsT argsA))))))]))

(def: invoke::virtual
  Handler
  (..custom [($_ p.and ..member s.any (p.some ..typed-input))
             (function (_ extension-name analyse [[class method] objectC argsTC])
               (do ////.monad
                 [#let [argsT (list@map product.left argsTC)]
                  [methodT exceptionsT] (method-candidate class method #Virtual argsT)
                  [outputT allA] (inferenceA.general analyse methodT (list& objectC (list@map product.right argsTC)))
                  #let [[objectA argsA] (case allA
                                          (#.Cons objectA argsA)
                                          [objectA argsA]

                                          _
                                          (undefined))]
                  outputJC (check-return outputT)]
                 (wrap (#/////analysis.Extension extension-name (list& (/////analysis.text class)
                                                                       (/////analysis.text method)
                                                                       (/////analysis.text outputJC)
                                                                       objectA
                                                                       (decorate-inputs argsT argsA))))))]))

(def: invoke::special
  Handler
  (..custom [($_ p.and ..member s.any (p.some ..typed-input))
             (function (_ extension-name analyse [[class method] objectC argsTC])
               (do ////.monad
                 [#let [argsT (list@map product.left argsTC)]
                  [methodT exceptionsT] (method-candidate class method #Special argsT)
                  [outputT argsA] (inferenceA.general analyse methodT (list& objectC (list@map product.right argsTC)))
                  outputJC (check-return outputT)]
                 (wrap (#/////analysis.Extension extension-name (list& (/////analysis.text class)
                                                                       (/////analysis.text method)
                                                                       (/////analysis.text outputJC)
                                                                       (decorate-inputs argsT argsA))))))]))

(def: invoke::interface
  Handler
  (..custom [($_ p.and ..member s.any (p.some ..typed-input))
             (function (_ extension-name analyse [[class-name method] objectC argsTC])
               (do ////.monad
                 [#let [argsT (list@map product.left argsTC)]
                  class (load-class class-name)
                  _ (////.assert non-interface class-name
                                 (Modifier::isInterface (java/lang/Class::getModifiers class)))
                  [methodT exceptionsT] (method-candidate class-name method #Interface argsT)
                  [outputT allA] (inferenceA.general analyse methodT (list& objectC (list@map product.right argsTC)))
                  #let [[objectA argsA] (case allA
                                          (#.Cons objectA argsA)
                                          [objectA argsA]

                                          _
                                          (undefined))]
                  outputJC (check-return outputT)]
                 (wrap (#/////analysis.Extension extension-name
                                                 (list& (/////analysis.text class-name)
                                                        (/////analysis.text method)
                                                        (/////analysis.text outputJC)
                                                        objectA
                                                        (decorate-inputs argsT argsA))))))]))

(def: invoke::constructor
  (..custom [($_ p.and s.text (p.some ..typed-input))
             (function (_ extension-name analyse [class argsTC])
               (do ////.monad
                 [#let [argsT (list@map product.left argsTC)]
                  [methodT exceptionsT] (constructor-candidate class argsT)
                  [outputT argsA] (inferenceA.general analyse methodT (list@map product.right argsTC))]
                 (wrap (#/////analysis.Extension extension-name (list& (/////analysis.text class)
                                                                       (decorate-inputs argsT argsA))))))]))

(def: bundle::member
  Bundle
  (<| (///bundle.prefix "member")
      (|> ///bundle.empty
          (dictionary.merge (<| (///bundle.prefix "static")
                                (|> ///bundle.empty
                                    (///bundle.install "get" static::get)
                                    (///bundle.install "put" static::put))))
          (dictionary.merge (<| (///bundle.prefix "virtual")
                                (|> ///bundle.empty
                                    (///bundle.install "get" virtual::get)
                                    (///bundle.install "put" virtual::put))))
          (dictionary.merge (<| (///bundle.prefix "invoke")
                                (|> ///bundle.empty
                                    (///bundle.install "static" invoke::static)
                                    (///bundle.install "virtual" invoke::virtual)
                                    (///bundle.install "special" invoke::special)
                                    (///bundle.install "interface" invoke::interface)
                                    (///bundle.install "constructor" invoke::constructor)
                                    )))
          )))

(def: var
  (Parser Var)
  s.text)

(def: bound
  (Parser Bound)
  (p.or (s.identifier! ["" ">"])
        (s.identifier! ["" "<"])))

(def: generic
  (Parser Generic)
  (p.rec
   (function (_ generic)
     (let [wildcard (: (Parser (Maybe [Bound Generic]))
                       (p.or (s.identifier! ["" "?"])
                             (s.form (p.and ..bound generic))))
           class (: (Parser Class)
                    (s.form (p.and s.text (p.some generic))))]
       ($_ p.or
           ..var
           wildcard
           class)))))

(def: class
  (Parser Class)
  (s.form (p.and s.text (p.some ..generic))))

(def: primitive
  (Parser Primitive)
  ($_ p.or
      (s.identifier! ["" jvm.boolean-reflection])
      (s.identifier! ["" jvm.byte-reflection])
      (s.identifier! ["" jvm.short-reflection])
      (s.identifier! ["" jvm.int-reflection])
      (s.identifier! ["" jvm.long-reflection])
      (s.identifier! ["" jvm.float-reflection])
      (s.identifier! ["" jvm.double-reflection])
      (s.identifier! ["" jvm.char-reflection])
      ))

(def: type
  (Parser Type)
  (p.rec
   (function (_ type)
     ($_ p.or
         ..primitive
         ..generic
         (s.tuple type)))))

(def: typed
  (Parser (Typed Code))
  (s.tuple (p.and ..type s.any)))

(type: #export (Annotation-Parameter a)
  [Text a])

(def: annotation-parameter
  (Parser (Annotation-Parameter Code))
  (s.tuple (p.and s.text s.any)))

(type: #export (Annotation a)
  [Text (List (Annotation-Parameter a))])

(def: annotation
  (Parser (Annotation Code))
  (s.form (p.and s.text (p.some ..annotation-parameter))))

(def: argument
  (Parser Argument)
  (s.tuple (p.and s.text ..type)))

(def: return
  (Parser Return)
  (p.or (s.identifier! ["" jvm.void-reflection])
        ..type))

(type: #export (Overriden-Method a)
  [Class
   Text
   Bit
   (List (Annotation a))
   (List Var)
   Text
   (List Argument)
   Return
   (List Class)
   a])

(type: #export (Method-Definition a)
  (#Overriden-Method (Overriden-Method a)))

(def: overriden-method-definition
  (Parser (Overriden-Method Code))
  (<| s.form
      (p.after (s.text! "override"))
      ($_ p.and
          ..class
          s.text
          s.bit
          (s.tuple (p.some ..annotation))
          (s.tuple (p.some ..var))
          s.text
          (s.tuple (p.some ..argument))
          ..return
          (s.tuple (p.some ..class))
          s.any
          )))

(def: (generic-analysis generic)
  (-> Generic Analysis)
  (case generic
    (#jvm.Var var)
    (/////analysis.text var)
    
    (#jvm.Wildcard wildcard)
    (case wildcard
      #.None
      (/////analysis.constant ["" "?"])
      
      (#.Some [bound limit])
      (/////analysis.tuple (list (case bound
                                   #jvm.Lower
                                   (/////analysis.constant ["" ">"])
                                   
                                   #jvm.Upper
                                   (/////analysis.constant ["" "<"]))
                                 (generic-analysis limit))))
    
    (#jvm.Class name parameters)
    (/////analysis.tuple (list& (/////analysis.text name)
                                (list@map generic-analysis parameters)))))

(def: (class-analysis [name parameters])
  (-> Class Analysis)
  (/////analysis.tuple (list& (/////analysis.text name)
                              (list@map generic-analysis parameters))))

(def: (annotation-parameter-analysis [name value])
  (-> (Annotation-Parameter Analysis) Analysis)
  (/////analysis.tuple (list (/////analysis.text name) value)))

(def: (annotation-analysis [name parameters])
  (-> (Annotation Analysis) Analysis)
  (/////analysis.tuple (list& (/////analysis.text name)
                              (list@map annotation-parameter-analysis parameters))))

(def: var-analysis
  (-> Var Analysis)
  /////analysis.text)

(def: (type-analysis type)
  (-> Type Analysis)
  (case type
    (#jvm.Primitive primitive)
    (case primitive
      #jvm.Boolean (/////analysis.constant ["" jvm.boolean-reflection])
      #jvm.Byte (/////analysis.constant ["" jvm.byte-reflection])
      #jvm.Short (/////analysis.constant ["" jvm.short-reflection])
      #jvm.Int (/////analysis.constant ["" jvm.int-reflection])
      #jvm.Long (/////analysis.constant ["" jvm.long-reflection])
      #jvm.Float (/////analysis.constant ["" jvm.float-reflection])
      #jvm.Double (/////analysis.constant ["" jvm.double-reflection])
      #jvm.Char (/////analysis.constant ["" jvm.char-reflection]))
    
    (#jvm.Generic generic)
    (generic-analysis generic)
    
    (#jvm.Array type)
    (/////analysis.tuple (list (type-analysis type)))))

(def: (return-analysis return)
  (-> Return Analysis)
  (case return
    #.None
    (/////analysis.constant ["" jvm.void-descriptor])
    
    (#.Some type)
    (type-analysis type)))

(def: (typed-analysis [type term])
  (-> (Typed Analysis) Analysis)
  (/////analysis.tuple (list (type-analysis type) term)))

(def: jvm-package-separator ".")

(def: class::anonymous
  Handler
  (..custom [($_ p.and
                 ..class
                 (s.tuple (p.some ..class))
                 (s.tuple (p.some ..typed))
                 (s.tuple (p.some ..overriden-method-definition)))
             (function (_ extension-name analyse [super-class
                                                  super-interfaces
                                                  constructor-args
                                                  methods])
               (do ////.monad
                 [name (///.lift (do macro.monad
                                   [where macro.current-module-name
                                    id macro.count]
                                   (wrap (format (text.replace-all .module-separator ..jvm-package-separator where)
                                                 ..jvm-package-separator
                                                 "anonymous-class" (%n id)))))
                  super-classT (typeA.with-env
                                 (class-type fresh-mapping super-class))
                  super-interfaceT+ (typeA.with-env
                                      (monad.map check.monad
                                                 (class-type fresh-mapping)
                                                 super-interfaces))
                  #let [selfT (inheritance-relationship-type (#.Primitive name (list))
                                                             super-classT
                                                             super-interfaceT+)]
                  constructor-argsA+ (monad.map @ (function (_ [type term])
                                                    (do @
                                                      [argT (typeA.with-env
                                                              (jvm-type fresh-mapping type))
                                                       termA (typeA.with-type argT
                                                               (analyse term))]
                                                      (wrap [type termA])))
                                                constructor-args)
                  methodsA (monad.map @ (function (_ [parent-type method-name
                                                      strict-fp? annotations vars
                                                      self-name arguments return exceptions
                                                      body])
                                          
                                          (do @
                                            [annotationsA (monad.map @ (function (_ [name parameters])
                                                                         (do @
                                                                           [parametersA (monad.map @ (function (_ [name value])
                                                                                                       (do @
                                                                                                         [valueA (analyse value)]
                                                                                                         (wrap [name valueA])))
                                                                                                   parameters)]
                                                                           (wrap [name parametersA])))
                                                                     annotations)
                                             returnT (typeA.with-env
                                                       (return-type fresh-mapping return))
                                             arguments' (typeA.with-env
                                                          (monad.map check.monad
                                                                     (function (_ [name jvmT])
                                                                       (do check.monad
                                                                         [luxT (jvm-type fresh-mapping jvmT)]
                                                                         (wrap [name luxT])))
                                                                     arguments))
                                             [scope bodyA] (|> arguments'
                                                               (#.Cons [self-name selfT])
                                                               list.reverse
                                                               (list@fold scope.with-local (analyse body))
                                                               (typeA.with-type returnT)
                                                               /////analysis.with-scope)]
                                            (wrap (/////analysis.tuple (list (class-analysis parent-type)
                                                                             (/////analysis.text method-name)
                                                                             (/////analysis.bit strict-fp?)
                                                                             (/////analysis.tuple (list@map annotation-analysis annotationsA))
                                                                             (/////analysis.tuple (list@map var-analysis vars))
                                                                             (/////analysis.text self-name)
                                                                             (/////analysis.tuple (list@map (function (_ [argument argumentJT])
                                                                                                              (/////analysis.tuple
                                                                                                               (list (/////analysis.text argument)
                                                                                                                     (type-analysis argumentJT))))
                                                                                                            arguments))
                                                                             (return-analysis return)
                                                                             (/////analysis.tuple (list@map class-analysis
                                                                                                            exceptions))
                                                                             (#/////analysis.Function
                                                                              (scope.environment scope)
                                                                              (/////analysis.tuple (list bodyA)))
                                                                             )))))
                                      methods)
                  _ (typeA.infer selfT)]
                 (wrap (#/////analysis.Extension extension-name
                                                 (list (/////analysis.text name)
                                                       (class-analysis super-class)
                                                       (/////analysis.tuple (list@map class-analysis super-interfaces))
                                                       (/////analysis.tuple (list@map typed-analysis constructor-argsA+))
                                                       (/////analysis.tuple methodsA))))))]))

(def: bundle::class
  Bundle
  (<| (///bundle.prefix "class")
      (|> ///bundle.empty
          (///bundle.install "anonymous" class::anonymous)
          )))

(def: #export bundle
  Bundle
  (<| (///bundle.prefix "jvm")
      (|> ///bundle.empty
          (dictionary.merge bundle::conversion)
          (dictionary.merge bundle::int)
          (dictionary.merge bundle::long)
          (dictionary.merge bundle::float)
          (dictionary.merge bundle::double)
          (dictionary.merge bundle::char)
          (dictionary.merge bundle::array)
          (dictionary.merge bundle::object)
          (dictionary.merge bundle::member)
          (dictionary.merge bundle::class)
          )))
