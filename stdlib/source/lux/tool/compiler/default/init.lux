(.module:
  [lux (#- Module)
   [control
    ["." monad (#+ do)]
    ["ex" exception (#+ exception:)]]
   [data
    ["." product]
    ["." error (#+ Error)]
    ["." text ("#;." hash)
     format]
    [collection
     ["." list ("#@." functor)]
     ["." dictionary]
     ["." set]]]
   ["." macro]
   [world
    ["." file]]]
  ["." //
   ["#." syntax (#+ Aliases)]
   ["#." evaluation]
   ["#/" // (#+ Instancer)
    ["#." analysis]
    ["#." synthesis]
    ["#." statement (#+ Requirements)]
    ["#." host]
    ["#." phase
     [macro (#+ Expander)]
     [".P" analysis
      ["." module]]
     [".P" synthesis]
     ["." generation]
     [".P" statement]
     ["." extension
      [".E" analysis]
      [".E" synthesis]
      [".E" statement]]]
    [meta
     [archive
      ["." signature]
      ["." key (#+ Key)]
      ["." descriptor (#+ Module)]
      ["." document]]]]])

(def: #export info
  Info
  {#.target (`` (for {(~~ (static ///host.common-lisp)) ///host.common-lisp
                      (~~ (static ///host.js))          ///host.js
                      (~~ (static ///host.jvm))         ///host.jvm
                      (~~ (static ///host.lua))         ///host.lua
                      (~~ (static ///host.php))         ///host.php
                      (~~ (static ///host.python))      ///host.python
                      (~~ (static ///host.r))           ///host.r
                      (~~ (static ///host.ruby))        ///host.ruby
                      (~~ (static ///host.scheme))      ///host.scheme}))
   #.version //.version
   #.mode #.Build})

(def: (refresh expander)
  (All [anchor expression statement]
    (-> Expander (///statement.Operation anchor expression statement Any)))
  (do ///phase.monad
    [[bundle state] ///phase.get-state
     #let [eval (//evaluation.evaluator expander
                                        (get@ [#///statement.synthesis #///statement.state] state)
                                        (get@ [#///statement.generation #///statement.state] state)
                                        (get@ [#///statement.generation #///statement.phase] state))]]
    (///phase.set-state [bundle
                         (update@ [#///statement.analysis #///statement.state]
                                  (: (-> ///analysis.State+ ///analysis.State+)
                                     (|>> product.right
                                          [(analysisE.bundle eval)]))
                                  state)])))

(def: #export (state expander host generate generation-bundle program)
  (All [anchor expression statement]
    (-> Expander
        (generation.Host expression statement)
        (generation.Phase anchor expression statement)
        (generation.Bundle anchor expression statement)
        (-> expression statement)
        (///statement.State+ anchor expression statement)))
  (let [synthesis-state [synthesisE.bundle ///synthesis.init]
        generation-state [generation-bundle (generation.state host)]
        eval (//evaluation.evaluator expander synthesis-state generation-state generate)
        analysis-state [(analysisE.bundle eval) (///analysis.state ..info host)]]
    [(statementE.bundle program)
     {#///statement.analysis {#///statement.state analysis-state
                              #///statement.phase (analysisP.phase expander)}
      #///statement.synthesis {#///statement.state synthesis-state
                               #///statement.phase synthesisP.phase}
      #///statement.generation {#///statement.state generation-state
                                #///statement.phase generate}}]))

(type: Reader
  (-> Source (Error [Source Code])))

(def: (reader current-module aliases [cursor offset source-code])
  (-> Module Aliases Source (///analysis.Operation Reader))
  (function (_ [bundle state])
    (#error.Success [[bundle state]
                     (//syntax.parse current-module aliases ("lux text size" source-code))])))

(def: (read source reader)
  (-> Source Reader (///analysis.Operation [Source Code]))
  (function (_ [bundle compiler])
    (case (reader source)
      (#error.Failure error)
      (#error.Failure error)

      (#error.Success [source' output])
      (let [[cursor _] output]
        (#error.Success [[bundle (|> compiler
                                     (set@ #.source source')
                                     (set@ #.cursor cursor))]
                         [source' output]])))))

(type: (Operation a)
  (All [anchor expression statement]
    (///statement.Operation anchor expression statement a)))

(def: (begin dependencies hash input)
  (-> (List Module) Nat ///.Input (Operation Source))
  (///statement.lift-analysis
   (do ///phase.monad
     [#let [module (get@ #///.module input)]
      _ (module.create hash module)
      _ (///analysis.set-current-module module)
      _ (monad.map @ module.import dependencies)
      #let [source (///analysis.source (get@ #///.module input) (get@ #///.code input))]
      _ (///analysis.set-source-code source)]
     (wrap source))))

(def: end
  (-> Module (Operation Any))
  (|>> module.set-compiled
       ///statement.lift-analysis))

(def: (iteration expander reader source)
  (-> Expander Reader Source (Operation [Source Requirements]))
  (let [execute! (statementP.phase expander)]
    (do ///phase.monad
      [[source code] (///statement.lift-analysis
                      (..read source reader))
       requirements (execute! code)
       _ (..refresh expander)]
      (wrap [source requirements]))))

(def: (iterate expander module source)
  (-> Expander Module Source (Operation (Maybe [Source Requirements])))
  (do ///phase.monad
    [reader (///statement.lift-analysis
             (..reader module //syntax.no-aliases source))]
    (function (_ state)
      (case (///phase.run' state (..iteration expander reader source))
        (#error.Success [state source&requirements])
        (#error.Success [state (#.Some source&requirements)])

        (#error.Failure error)
        (if (ex.match? //syntax.end-of-file error)
          (#error.Success [state #.None])
          (ex.with-stack ///.cannot-compile module (#error.Failure error)))))))

(def: (default-dependencies prelude input)
  (-> Module ///.Input (List Module))
  (if (text;= prelude (get@ #///.module input))
    (list)
    (list prelude)))

(def: #export (compiler expander prelude)
  (-> Expander Module
      (All [anchor expression statement]
        (Instancer (///statement.State+ anchor expression statement) .Module)))
  (let [execute! (statementP.phase expander)]
    (function (_ key parameters input)
      (let [dependencies (default-dependencies prelude input)]
        {#///.dependencies dependencies
         #///.process (function (_ state archive)
                        (do error.monad
                          [#let [hash (text;hash (get@ #///.code input))]
                           [state source] (<| (///phase.run' state)
                                              (..begin dependencies hash input))
                           #let [module (get@ #///.module input)]]
                          (loop [iteration (<| (///phase.run' state)
                                               (..iterate expander module source))]
                            (do @
                              [[state ?source&requirements] iteration]
                              (case ?source&requirements
                                #.None
                                (do @
                                  [[state analysis-module] (<| (///phase.run' state)
                                                               (do ///phase.monad
                                                                 [_ (..end module)]
                                                                 (<| (: (Operation .Module))
                                                                     ///statement.lift-analysis
                                                                     extension.lift
                                                                     macro.current-module)))
                                   #let [descriptor {#descriptor.hash hash
                                                     #descriptor.name module
                                                     #descriptor.file (get@ #///.file input)
                                                     #descriptor.references (set.from-list text.hash dependencies)
                                                     #descriptor.state #.Compiled}]]
                                  (wrap [state
                                         (#.Right [[descriptor (document.write key analysis-module)]
                                                   (dictionary.new text.hash)])]))
                                
                                (#.Some [source requirements])
                                (wrap [state
                                       (#.Left {#///.dependencies (|> requirements
                                                                      (get@ #///statement.imports)
                                                                      (list@map product.left))
                                                #///.process (function (_ state archive)
                                                               (recur (<| (///phase.run' state)
                                                                          (do ///phase.monad
                                                                            [_ (monad.map @ execute! (get@ #///statement.referrals requirements))
                                                                             _ (..refresh expander)]
                                                                            (..iterate expander module source)))))})])
                                )))))}))))

(def: #export key
  (Key .Module)
  (key.key {#signature.name (name-of ..compiler)
            #signature.version //.version}
           (module.new 0)))
