(.module:
  [lux (#- Module)
   [type (#+ :share)]
   [control
    ["." monad (#+ Monad do)]]
   [data
    ["." bit]
    ["." product]
    ["." error (#+ Error)]
    [collection
     ["." list]]]
   [world
    ["." file (#+ File)]]]
  [//
   ["." init]
   ["." syntax]
   ["/." //
    ["." analysis]
    ["." statement]
    ["." phase
     [macro (#+ Expander)]
     ## TODO: Get rid of this import ASAP
     [extension (#+)]
     ["." translation]
     [analysis
      ["." module]]]
    ["." cli (#+ Configuration)]
    [meta
     ["." archive (#+ Archive)
      [descriptor (#+ Module)]]
     [io
      ["." context]]]]])

(type: #export (Platform ! anchor expression statement)
  {#&monad (Monad !)
   #&file-system (file.System !)
   #host (translation.Host expression statement)
   #phase (translation.Phase anchor expression statement)
   #runtime (translation.Operation anchor expression statement Any)})

## (def: (write-module target-dir file-name module-name module outputs)
##   (-> File Text Text Module Outputs (Process Any))
##   (do (error.with io.monad)
##     [_ (monad.map @ (product.uncurry (&io.write target-dir))
##                   (dictionary.entries outputs))]
##     (&io.write target-dir
##                (format module-name "/" cache.descriptor-name)
##                (encoding.to-utf8 (%code (cache/description.write file-name module))))))

(with-expansions [<Platform> (as-is (Platform ! anchor expression statement))
                  <State+> (as-is (statement.State+ anchor expression statement))
                  <Bundle> (as-is (translation.Bundle anchor expression statement))]

  (def: #export (initialize expander platform translation-bundle)
    (All [! anchor expression statement]
      (-> Expander <Platform> <Bundle> (! (Error <State+>))))
    (|> platform
        (get@ #runtime)
        statement.lift-translation
        (phase.run' (init.state expander
                                (get@ #host platform)
                                (get@ #phase platform)
                                translation-bundle))
        (:: error.functor map product.left)
        (:: (get@ #&monad platform) wrap))

    ## (case (runtimeT.translate ## (initL.compiler (io.run js.init))
    ##        (initL.compiler (io.run hostL.init-host))
    ##        )
    ##   ## (#error.Success [state disk-write])
    ##   ## (do @
    ##   ##   [_ (&io.prepare-target target)
    ##   ##    _ disk-write
    ##   ##    ## _ (cache/io.pre-load sources target (commonT.load-definition state))
    ##   ##    ]
    ##   ##   (wrap (|> state
    ##   ##             (set@ [#.info #.mode] #.Build))))

    ##   (#error.Success [state [runtime-bc function-bc]])
    ##   (do @
    ##     [_ (&io.prepare-target target)
    ##      ## _ (&io.write target (format hostL.runtime-class ".class") runtime-bc)
    ##      ## _ (&io.write target (format hostL.function-class ".class") function-bc)
    ##      ## _ (cache/io.pre-load sources target (commonT.load-definition state))
    ##      ]
    ##     (wrap (|> state
    ##               (set@ [#.info #.mode] #.Build))))

    ##   (#error.Failure error)
    ##   (io.fail error))
    )

  (def: #export (compile expander platform configuration archive state)
    (All [! anchor expression statement]
      (-> Expander <Platform> Configuration Archive <State+> (! (Error [Archive <State+>]))))
    (let [monad (get@ #&monad platform)
          compiler (:share [anchor expression statement]
                           {<State+>
                            state}
                           {(///.Compiler <State+> .Module Any)
                            ((init.compiler expander syntax.prelude) init.key (list))})]
      (loop [module (get@ #cli.module configuration)
             [archive state] [archive state]]
        (let [## [state _] (|> (analysis.set-current-module module)
              ##               statement.lift-analysis
              ##               (phase.run' state)
              ##               error.assume)
              import! (:share [! anchor expression statement]
                              {<Platform>
                               platform}
                              {(-> Module [Archive <State+>]
                                   (! (Error [Archive <State+>])))
                               recur})]
          (do (error.with monad)
            [input (context.read monad
                                 (get@ #&file-system platform)
                                 (get@ #cli.sources configuration)
                                 module)
             ## _ (&io.prepare-module target-dir (get@ #cli.module configuration))
             ## _ (write-module target-dir file-name (get@ #cli.module configuration) module outputs)
             ]
            (loop [state state
                   compilation (compiler (:coerce ///.Input input))]
              (do @
                [archive+state' (monad.fold @
                                            (function (_ dependency archive+state')
                                              (do @
                                                [archive+state'' (import! dependency archive+state')
                                                 #let [[archive'' state''] (:share [! anchor expression statement]
                                                                                   {<Platform>
                                                                                    platform}
                                                                                   {[Archive <State+>]
                                                                                    archive+state''})]]
                                                (case (:share [! anchor expression statement]
                                                              {<State+>
                                                               state}
                                                              {(Error [<State+> Any])
                                                               ## TODO: Get rid of the 'let' below ASAP
                                                               (let [lifted (statement.lift-analysis
                                                                             (module.import dependency))]
                                                                 (phase.run' state'' lifted))})
                                                  (#error.Success [state''' _])
                                                  (wrap [archive'' state'''])
                                                  
                                                  (#error.Failure error)
                                                  (:: monad wrap (#error.Failure error)))))
                                            [archive state]
                                            (list.filter (bit.complement (archive.archived? archive))
                                                         (get@ #///.dependencies compilation)))
                 #let [[archive' state'] (:share [! anchor expression statement]
                                                 {<Platform>
                                                  platform}
                                                 {[Archive <State+>]
                                                  archive+state'})
                       continue! (:share [! anchor expression statement]
                                         {<Platform>
                                          platform}
                                         {(-> <State+> (///.Compilation <State+> .Module Any)
                                              (! (Error [Archive <State+>])))
                                          recur})]]
                (case ((get@ #///.process compilation) state' archive')
                  (#error.Success more|done)
                  (case more|done
                    (#.Left [state'' more])
                    (continue! state'' more)

                    (#.Right [state'' descriptor+document output])
                    (wrap [(archive.add module descriptor+document archive') state'']))

                  (#error.Failure error)
                  (:: monad wrap (#error.Failure error))))))))))
  )
