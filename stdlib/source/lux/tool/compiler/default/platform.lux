(.module:
  [lux (#- Module)
   [type (#+ :share)]
   ["@" target (#+ Host)]
   [abstract
    ["." monad (#+ Monad do)]]
   [control
    ["." try (#+ Try)]
    [concurrency
     ["." promise (#+ Promise) ("#@." monad)]]]
   [data
    [binary (#+ Binary)]
    ["." bit]
    ["." product]
    ["." text
     ["%" format (#+ format)]]
    [collection
     ["." list]
     ["." row ("#@." functor)]]]
   [world
    ["." file (#+ Path)]]]
  ["." // #_
   ["#." init]
   ["/#" // (#+ Output)
    ["#." phase]
    [language
     [lux
      ["." syntax]
      ["#." analysis
       [macro (#+ Expander)]]
      ["#." generation (#+ Buffer)]
      ["#." directive]
      [phase
       ## TODO: Get rid of this import ASAP
       ["." extension (#+ Extender)]
       [analysis
        ["." module]]]]]
    [meta
     ["." archive (#+ Archive)
      [descriptor (#+ Module)]]
     [io
      ["." context]
      ["ioW" archive]]]]]
  [program
   [compositor
    ["." cli (#+ Configuration)]]])

(type: #export (Platform anchor expression directive)
  {#&file-system (file.System Promise)
   #host (///generation.Host expression directive)
   #phase (///generation.Phase anchor expression directive)
   #runtime (///generation.Operation anchor expression directive Any)
   #write (-> directive Binary)})

(with-expansions [<type-vars> (as-is [anchor expression directive])
                  <Platform> (as-is (Platform anchor expression directive))
                  <State+> (as-is (///directive.State+ anchor expression directive))
                  <Bundle> (as-is (///generation.Bundle anchor expression directive))]

  (def: (cache-module platform host target-dir module-file-name module-name output ## module
                      )
    (All <type-vars>
      (-> <Platform> Host Path Path Text Output ## Module
          (Promise (Try Any))))
    (let [system (get@ #&file-system platform)
          write-artifact! (: (-> [Text Binary] (Promise (Try Any)))
                             (function (_ [name content])
                               (ioW.write system host target-dir module-name name content)))]
      (do (try.with promise.monad)
        [_ (ioW.prepare system host target-dir module-name)
         _ (|> output
               row.to-list
               (monad.map promise.monad
                          write-artifact!)
               (: (Promise (List (Try Any))))
               (promise@map (monad.seq try.monad))
               (: (Promise (Try (List Any)))))]
        (wrap [])
        ## (&io.write target-dir
        ##            (format module-name "/" cache.descriptor-name)
        ##            (encoding.to-utf8 (%.code (cache/description.write module-file-name module))))
        )))
  
  ## TODO: Inline ASAP
  (def: initialize-buffer!
    (All <type-vars>
      (///generation.Operation anchor expression directive Any))
    (///generation.set-buffer ///generation.empty-buffer))

  ## TODO: Inline ASAP
  (def: compile-runtime!
    (All <type-vars>
      (-> <Platform> (///generation.Operation anchor expression directive Any)))
    (get@ #runtime))

  (def: (ensure-target! platform target host)
    (All <type-vars>
      (-> <Platform> Path Host (Promise (Try Any))))
    (let [system (get@ #&file-system platform)
          mkdir (: (-> Path (Promise (Try Any)))
                   (file.get-directory promise.monad system))]
      (do (try.with promise.monad)
        [_ (mkdir target)]
        (mkdir (ioW.archive system host target)))))
  
  (def: #export (initialize target host module expander host-analysis platform generation-bundle host-directive-bundle program extender)
    (All <type-vars>
      (-> Path
          Host
          Module
          Expander
          ///analysis.Bundle
          <Platform>
          <Bundle>
          (///directive.Bundle anchor expression directive)
          (-> expression directive)
          Extender
          (Promise (Try [<State+> (Buffer directive)]))))
    (let [state (//init.state host
                              module
                              expander
                              host-analysis
                              (get@ #host platform)
                              (get@ #phase platform)
                              generation-bundle
                              host-directive-bundle
                              program
                              extender)]
      (do (try.with promise.monad)
        [_ (..ensure-target! platform target host)]
        (|> (do ///phase.monad
              [_ ..initialize-buffer!
               _ (..compile-runtime! platform)]
              ///generation.buffer)
            ///directive.lift-generation
            (///phase.run' state)
            promise@wrap)))

    ## (case (runtimeT.generate ## (initL.compiler (io.run js.init))
    ##        (initL.compiler (io.run hostL.init-host))
    ##        )
    ##   ## (#try.Success [state disk-write])
    ##   ## (do @
    ##   ##   [_ (&io.prepare-target target)
    ##   ##    _ disk-write
    ##   ##    ## _ (cache/io.pre-load sources target (commonT.load-definition state))
    ##   ##    ]
    ##   ##   (wrap (|> state
    ##   ##             (set@ [#.info #.mode] #.Build))))

    ##   (#try.Success [state [runtime-bc function-bc]])
    ##   (do @
    ##     [_ (&io.prepare-target target)
    ##      ## _ (&io.write target (format hostL.runtime-class ".class") runtime-bc)
    ##      ## _ (&io.write target (format hostL.function-class ".class") function-bc)
    ##      ## _ (cache/io.pre-load sources target (commonT.load-definition state))
    ##      ]
    ##     (wrap (|> state
    ##               (set@ [#.info #.mode] #.Build))))

    ##   (#try.Failure error)
    ##   (io.fail error))
    )

  (def: #export (compile target partial-host-extension expander platform host configuration archive state)
    (All <type-vars>
      (-> Text Text Expander <Platform> Host Configuration Archive <State+> (Promise (Try [Archive <State+>]))))
    (let [source-module (get@ #cli.module configuration)
          compiler (:share <type-vars>
                           {<State+>
                            state}
                           {(///.Compiler <State+> .Module Any)
                            ((//init.compiler expander syntax.prelude (get@ #write platform)) //init.key (list))})]
      (loop [module source-module
             [archive state] [archive state]]
        (if (archive.archived? archive module)
          (promise@wrap (#try.Success [archive state]))
          (let [import! (:share <type-vars>
                                {<Platform>
                                 platform}
                                {(-> Module [Archive <State+>]
                                     (Promise (Try [Archive <State+>])))
                                 recur})]
            (do (try.with promise.monad)
              [input (context.read (get@ #&file-system platform)
                                   (get@ #cli.sources configuration)
                                   partial-host-extension
                                   module)]
              (loop [archive archive
                     state state
                     compilation (compiler (:coerce ///.Input input))]
                (do @
                  [#let [dependencies (get@ #///.dependencies compilation)]
                   archive+state (monad.fold @
                                             import!
                                             [archive state]
                                             (list.filter (bit.complement (archive.archived? archive))
                                                          dependencies))
                   #let [## TODO: Inline ASAP
                         [archive state] (:share <type-vars>
                                                 {<Platform>
                                                  platform}
                                                 {[Archive <State+>]
                                                  archive+state})
                         continue! (:share <type-vars>
                                           {<Platform>
                                            platform}
                                           {(-> Archive <State+> (///.Compilation <State+> .Module Any)
                                                (Promise (Try [Archive <State+>])))
                                            recur})]]
                  (case ((get@ #///.process compilation)
                         (case dependencies
                           #.Nil
                           state

                           _
                           ## TODO: The "///analysis.set-current-module" below shouldn't be necessary. Remove it ASAP.
                           ## TODO: The context shouldn't need to be re-set either.
                           (|> (///directive.set-current-module module)
                               (///phase.run' state)
                               try.assume
                               product.left))
                         archive)
                    (#try.Success [state more|done])
                    (case more|done
                      (#.Left more)
                      (continue! archive state more)

                      (#.Right [descriptor+document output])
                      (do (try.with promise.monad)
                        [_ (..cache-module platform
                                           host
                                           target
                                           (get@ #///.file input)
                                           module
                                           output
                                           ## module
                                           )]
                        (case (archive.add module descriptor+document archive)
                          (#try.Success archive)
                          (wrap [archive state])
                          
                          (#try.Failure error)
                          (promise@wrap (#try.Failure error)))))

                    (#try.Failure error)
                    (promise@wrap (#try.Failure error)))))))))))
  )
