(.module:
  [lux (#- Location inc)
   ["." meta]
   [abstract
    ["." monad (#+ do)]]
   [control
    ["." function]
    ["<>" parser
     ["<.>" code]]]
   [data
    ["." product]
    ["." text ("#\." hash)
     ["%" format (#+ format)]
     ["." encoding]]
    [collection
     ["." list ("#\." functor)]
     ["." row]]]
   ["." macro
    [syntax (#+ syntax:)]
    ["." code]]
   [math
    [number (#+ hex)
     ["." i64]]]
   ["@" target
    ["_" php (#+ Expression Location Constant Var Computation Literal Statement)]]]
  ["." /// #_
   ["#." reference]
   ["//#" /// #_
    ["#." synthesis (#+ Synthesis)]
    ["#." generation]
    ["//#" ///
     ["#." phase]
     [reference
      [variable (#+ Register)]]
     [meta
      [archive (#+ Output Archive)
       ["." artifact (#+ Registry)]]]]]])

(template [<name> <base>]
  [(type: #export <name>
     (<base> Location Expression Statement))]

  [Operation /////generation.Operation]
  [Phase /////generation.Phase]
  [Handler /////generation.Handler]
  [Bundle /////generation.Bundle]
  )

(type: #export (Generator i)
  (-> Phase Archive i (Operation Expression)))

(type: #export Phase!
  (-> Phase Archive Synthesis (Operation Statement)))

(type: #export (Generator! i)
  (-> Phase! Phase Archive i (Operation Statement)))

(def: prefix
  "LuxRuntime")

(def: #export unit
  (_.string /////synthesis.unit))

(def: (flag value)
  (-> Bit Literal)
  (if value
    ..unit
    _.null))

(def: (feature name definition)
  (-> Constant (-> Constant Statement) Statement)
  (definition name))

(syntax: #export (with_vars {vars (<code>.tuple (<>.some <code>.local_identifier))}
                   body)
  (do {! meta.monad}
    [ids (monad.seq ! (list.repeat (list.size vars) meta.count))]
    (wrap (list (` (let [(~+ (|> vars
                                 (list.zip/2 ids)
                                 (list\map (function (_ [id var])
                                             (list (code.local_identifier var)
                                                   (` (_.var (~ (code.text (format "v" (%.nat id)))))))))
                                 list.concat))]
                     (~ body)))))))

(def: module_id
  0)

(syntax: (runtime: {declaration (<>.or <code>.local_identifier
                                       (<code>.form (<>.and <code>.local_identifier
                                                            (<>.some <code>.local_identifier))))}
           code)
  (do meta.monad
    [runtime_id meta.count]
    (macro.with_gensyms [g!_]
      (let [runtime (code.local_identifier (///reference.artifact [..module_id runtime_id]))
            runtime_name (` (_.constant (~ (code.text (%.code runtime)))))]
        (case declaration
          (#.Left name)
          (macro.with_gensyms [g!_]
            (let [g!name (code.local_identifier name)]
              (wrap (list (` (def: #export (~ g!name)
                               Var
                               (~ runtime_name)))
                          
                          (` (def: (~ (code.local_identifier (format "@" name)))
                               Statement
                               (..feature (~ runtime_name)
                                          (function ((~ g!_) (~ g!name))
                                            (_.define (~ g!name) (~ code))))))))))
          
          (#.Right [name inputs])
          (macro.with_gensyms [g!_]
            (let [g!name (code.local_identifier name)
                  inputsC (list\map code.local_identifier inputs)
                  inputs_typesC (list\map (function.constant (` _.Expression))
                                          inputs)]
              (wrap (list (` (def: #export ((~ g!name) (~+ inputsC))
                               (-> (~+ inputs_typesC) Computation)
                               (_.apply/* (list (~+ inputsC)) (~ runtime_name))))
                          
                          (` (def: (~ (code.local_identifier (format "@" name)))
                               Statement
                               (..feature (~ runtime_name)
                                          (function ((~ g!_) (~ g!_))
                                            (..with_vars [(~+ inputsC)]
                                              (_.define_function (~ g!_)
                                                                 (list (~+ (list\map (|>> (~) [false] (`)) inputsC)))
                                                                 (~ code))))))))))))))))

(runtime: (io//throw! message)
  ($_ _.then
      (_.throw (_.new (_.constant "Exception") (list message)))
      (_.return ..unit)))

(def: runtime//io
  Statement
  ($_ _.then
      @io//throw!
      ))

(def: #export tuple_size_field
  "_lux_size")

(def: tuple_size
  (_.nth (_.string ..tuple_size_field)))

(def: last_index
  (|>> ..tuple_size (_.- (_.int +1))))

(with_expansions [<recur> (as_is ($_ _.then
                                     (_.; (_.set lefts (_.- last_index_right lefts)))
                                     (_.; (_.set tuple (_.nth last_index_right tuple)))))]
  (runtime: (tuple//make size values)
    ($_ _.then
        (_.; (_.set (..tuple_size values) size))
        (_.return values)))

  (runtime: (tuple//left lefts tuple)
    (with_vars [last_index_right]
      (<| (_.while (_.bool true))
          ($_ _.then
              (_.; (_.set last_index_right (..last_index tuple)))
              (_.if (_.> lefts last_index_right)
                ## No need for recursion
                (_.return (_.nth lefts tuple))
                ## Needs recursion
                <recur>)))))

  (runtime: (tuple//right lefts tuple)
    (with_vars [last_index_right right_index]
      (<| (_.while (_.bool true))
          ($_ _.then
              (_.; (_.set last_index_right (..last_index tuple)))
              (_.; (_.set right_index (_.+ (_.int +1) lefts)))
              (_.cond (list [(_.= last_index_right right_index)
                             (_.return (_.nth right_index tuple))]
                            [(_.> last_index_right right_index)
                             ## Needs recursion.
                             <recur>])
                      ($_ _.then
                          (_.echo (_.string (format "[tuple//right] _.array_slice/2" text.new_line)))
                          (_.return (_.array_slice/2 [tuple right_index]))))
              )))))

(def: #export variant_tag_field "_lux_tag")
(def: #export variant_flag_field "_lux_flag")
(def: #export variant_value_field "_lux_value")

(runtime: (sum//make tag last? value)
  (_.return (_.array/** (list [(_.string ..variant_tag_field) tag]
                              [(_.string ..variant_flag_field) last?]
                              [(_.string ..variant_value_field) value]))))

(def: #export (variant tag last? value)
  (-> Nat Bit Expression Computation)
  (sum//make (_.int (.int tag))
             (..flag last?)
             value))

(def: #export none
  Computation
  (..variant 0 #0 ..unit))

(def: #export some
  (-> Expression Computation)
  (..variant 1 #1))

(def: #export left
  (-> Expression Computation)
  (..variant 0 #0))

(def: #export right
  (-> Expression Computation)
  (..variant 1 #1))

(runtime: (sum//get sum wantsLast wantedTag)
  (let [no_match! (_.return _.null)
        sum_tag (_.nth (_.string ..variant_tag_field) sum)
        ## sum_tag (_.nth (_.int +0) sum)
        sum_flag (_.nth (_.string ..variant_flag_field) sum)
        ## sum_flag (_.nth (_.int +1) sum)
        sum_value (_.nth (_.string ..variant_value_field) sum)
        ## sum_value (_.nth (_.int +2) sum)
        is_last? (_.= ..unit sum_flag)
        test_recursion! (_.if is_last?
                          ## Must recurse.
                          ($_ _.then
                              (_.; (_.set wantedTag (_.- sum_tag wantedTag)))
                              (_.; (_.set sum sum_value)))
                          no_match!)]
    (<| (_.while (_.bool true))
        (_.cond (list [(_.= sum_tag wantedTag)
                       (_.if (_.= wantsLast sum_flag)
                         (_.return sum_value)
                         test_recursion!)]

                      [(_.< wantedTag sum_tag)
                       test_recursion!]

                      [(_.= ..unit wantsLast)
                       (_.return (sum//make (_.- wantedTag sum_tag) sum_flag sum_value))])
                no_match!))))

(def: runtime//adt
  Statement
  ($_ _.then
      @tuple//make
      @tuple//left
      @tuple//right
      @sum//make
      @sum//get
      ))

(runtime: (lux//try op)
  (with_vars [value]
    (_.try ($_ _.then
               (_.; (_.set value (_.apply/1 op [..unit])))
               (_.return (..right value)))
           (list (with_vars [error]
                   {#_.class (_.constant "Exception")
                    #_.exception error
                    #_.handler (_.return (..left (_.do "getMessage" (list) error)))})))))

(runtime: (lux//program_args inputs)
  (with_vars [head tail]
    ($_ _.then
        (_.; (_.set tail ..none))
        (<| (_.for_each (_.array_reverse/1 inputs) head)
            (_.; (_.set tail (..some (_.array/* (list head tail))))))
        (_.return tail))))

(def: runtime//lux
  Statement
  ($_ _.then
      @lux//try
      @lux//program_args
      ))

(runtime: (i64//right_shift param subject)
  (let [mask (|> (_.int +1)
                 (_.bit_shl (_.- param (_.int +64)))
                 (_.- (_.int +1)))]
    (_.return (|> subject
                  (_.bit_and mask)
                  (_.bit_shr param)))))

(def: jphp?
  (_.= (_.string "5.6.99") (_.phpversion/0 [])))

(runtime: (i64//char code)
  (_.if ..jphp?
    (_.return (_.chr/1 [code]))
    (_.return (|> code
                  [(_.string "V")]
                  _.pack/2
                  [(_.string "UTF-32LE") (_.string "UTF-8")]
                  _.iconv/3))))

(def: runtime//i64
  Statement
  ($_ _.then
      @i64//right_shift
      @i64//char
      ))

(runtime: (text//size value)
  (_.if ..jphp?
    (_.return (_.strlen/1 [value]))
    (_.return (_.iconv_strlen/1 [value]))))

(runtime: (text//index subject param start)
  (with_vars [idx]
    (_.if ..jphp?
      ($_ _.then
          (_.; (_.set idx (_.strpos/3 [subject param start])))
          (_.if (_.= (_.bool false) idx)
            (_.return ..none)
            (_.return (..some idx))))
      ($_ _.then
          (_.; (_.set idx (_.iconv_strpos/3 [subject param start])))
          (_.if (_.= (_.bool false) idx)
            (_.return ..none)
            (_.return (..some idx)))))))

(def: (within? top value)
  (-> Expression Expression Computation)
  (_.and (|> value (_.>= (_.int +0)))
         (|> value (_.< top))))

(runtime: (text//clip offset length text)
  (_.if ..jphp?
    (_.return (_.substr/3 [text offset length]))
    (_.return (_.iconv_substr/3 [text offset length]))))

(runtime: (text//char idx text)
  (_.if (|> idx (within? (text//size text)))
    (let [code_point (: (-> Expression Computation)
                        (|>> [(_.string "UTF-8") (_.string "UTF-32LE")]
                             _.iconv/3
                             [(_.string "V")]
                             _.unpack/2
                             (_.nth (_.int +1))))]
      (_.if ..jphp?
        (_.return (code_point (_.substr/3 [text idx (_.int +1)])))
        (_.return (code_point (_.iconv_substr/3 [text idx (_.int +1)])))))
    (_.throw (_.new (_.constant "Exception") (list (_.string "[Lux Error] Cannot get char from text."))))))

(def: runtime//text
  Statement
  ($_ _.then
      @text//size
      @text//index
      @text//clip
      @text//char
      ))

(runtime: (f64//decode value)
  (with_vars [output]
    ($_ _.then
        (_.; (_.set output (_.floatval/1 value)))
        (_.if (_.= (_.float +0.0) output)
          (_.if ($_ _.or
                    (_.= (_.string "0.0") output)
                    (_.= (_.string "+0.0") output)
                    (_.= (_.string "-0.0") output)
                    (_.= (_.string "0") output)
                    (_.= (_.string "+0") output)
                    (_.= (_.string "-0") output))
            (_.return (..some output))
            (_.return ..none))
          (_.return (..some output)))
        )))

(def: runtime//f64
  Statement
  ($_ _.then
      @f64//decode
      ))

(def: check_necessary_conditions!
  Statement
  (let [i64_support? (_.= (_.int +8) (_.constant "PHP_INT_SIZE"))
        i64_error (_.string (format "Cannot run program!" text.new_line
                                    "Lux/PHP programs require 64-bit PHP builds!"))]
    (_.when (_.not i64_support?)
            (_.throw (_.new (_.constant "Exception") (list i64_error))))))

(def: runtime
  Statement
  ($_ _.then
      check_necessary_conditions!
      runtime//adt
      runtime//lux
      runtime//i64
      runtime//f64
      runtime//text
      runtime//io
      ))

(def: #export artifact ..prefix)

(def: #export generate
  (Operation [Registry Output])
  (do ///////phase.monad
    [_ (/////generation.execute! ..runtime)
     _ (/////generation.save! (%.nat ..module_id) ..runtime)]
    (wrap [(|> artifact.empty
               artifact.resource
               product.right)
           (row.row [(%.nat ..module_id)
                     (|> ..runtime
                         _.code
                         (\ encoding.utf8 encode))])])))
