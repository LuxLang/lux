(.module:
  [lux (#- primitive)
   [abstract
    ["." monad (#+ do)]]
   [control
    [pipe (#+ case>)]
    ["." try]]
   [data
    ["." maybe]
    [collection
     ["." list ("#@." functor)]
     ["." dictionary (#+ Dictionary)]]]]
  ["." / #_
   ["#." function]
   ["#." case]
   ["/#" // #_
    ["#." extension]
    ["/#" // #_
     ["#." analysis (#+ Analysis)]
     ["/" synthesis (#+ Synthesis Phase)]
     [///
      [reference (#+)]
      ["." phase ("#@." monad)]]]]])

(def: (primitive analysis)
  (-> ///analysis.Primitive /.Primitive)
  (case analysis
    #///analysis.Unit
    (#/.Text /.unit)
    
    (^template [<analysis> <synthesis>]
      (<analysis> value)
      (<synthesis> value))
    ([#///analysis.Bit  #/.Bit]
     [#///analysis.Frac #/.F64]
     [#///analysis.Text #/.Text])

    (^template [<analysis> <synthesis>]
      (<analysis> value)
      (<synthesis> (.i64 value)))
    ([#///analysis.Nat #/.I64]
     [#///analysis.Int #/.I64]
     [#///analysis.Rev #/.I64])))

(def: #export (phase archive)
  Phase
  (function (phase' analysis)
    (case analysis
      (#///analysis.Primitive analysis')
      (phase@wrap (#/.Primitive (..primitive analysis')))

      (#///analysis.Structure structure)
      (case structure
        (#///analysis.Variant variant)
        (do phase.monad
          [valueS (phase' (get@ #///analysis.value variant))]
          (wrap (/.variant (set@ #///analysis.value valueS variant))))

        (#///analysis.Tuple tuple)
        (|> tuple
            (monad.map phase.monad phase')
            (phase@map (|>> /.tuple))))
      
      (#///analysis.Reference reference)
      (phase@wrap (#/.Reference reference))

      (#///analysis.Case inputA branchesAB+)
      (/case.synthesize phase branchesAB+ archive inputA)

      (^ (///analysis.no-op value))
      (phase' value)

      (#///analysis.Apply _)
      (/function.apply phase archive analysis)

      (#///analysis.Function environmentA bodyA)
      (/function.abstraction phase environmentA archive bodyA)

      (#///analysis.Extension name args)
      (function (_ state)
        (|> (//extension.apply archive phase [name args])
            (phase.run' state)
            (case> (#try.Success output)
                   (#try.Success output)
                   
                   (#try.Failure _)
                   (<| (phase.run' state)
                       (do phase.monad
                         [argsS+ (monad.map @ phase' args)]
                         (wrap (#/.Extension [name argsS+])))))))
      )))
