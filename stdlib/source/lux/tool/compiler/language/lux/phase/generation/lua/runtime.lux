(.module:
  [lux (#- Location inc)
   ["." meta]
   [abstract
    ["." monad (#+ do)]]
   [control
    ["." function]
    ["<>" parser
     ["<.>" code]]]
   [data
    ["." product]
    ["." text ("#\." hash)
     ["%" format (#+ format)]
     ["." encoding]]
    [collection
     ["." list ("#\." functor)]
     ["." row]]]
   ["." macro
    [syntax (#+ syntax:)]
    ["." code]]
   [math
    [number (#+ hex)
     ["." i64]]]
   [target
    ["_" lua (#+ Expression Location Var Computation Literal Label Statement)]]]
  ["." /// #_
   ["#." reference]
   ["//#" /// #_
    ["#." synthesis (#+ Synthesis)]
    ["#." generation]
    ["//#" /// (#+ Output)
     ["#." phase]
     [reference
      [variable (#+ Register)]]
     [meta
      [archive (#+ Archive)
       ["." artifact (#+ Registry)]]]]]])

(template [<name> <base>]
  [(type: #export <name>
     (<base> [Register Label] Expression Statement))]

  [Operation /////generation.Operation]
  [Phase /////generation.Phase]
  [Handler /////generation.Handler]
  [Bundle /////generation.Bundle]
  )

(type: #export (Generator i)
  (-> Phase Archive i (Operation Expression)))

(type: #export Phase!
  (-> Phase Archive Synthesis (Operation Statement)))

(type: #export (Generator! i)
  (-> Phase! Phase Archive i (Operation Statement)))

(def: prefix
  "LuxRuntime")

(def: #export unit
  (_.string /////synthesis.unit))

(def: (flag value)
  (-> Bit Literal)
  (if value
    (_.string "")
    _.nil))

(def: #export variant_tag_field "_lux_tag")
(def: #export variant_flag_field "_lux_flag")
(def: #export variant_value_field "_lux_value")

(def: (variant' tag last? value)
  (-> Expression Expression Expression Literal)
  (_.table (list [..variant_tag_field tag]
                 [..variant_flag_field last?]
                 [..variant_value_field value])))

(def: #export (variant tag last? value)
  (-> Nat Bit Expression Literal)
  (variant' (_.int (.int tag))
            (flag last?)
            value))

(def: #export none
  Literal
  (..variant 0 #0 ..unit))

(def: #export some
  (-> Expression Literal)
  (..variant 1 #1))

(def: #export left
  (-> Expression Literal)
  (..variant 0 #0))

(def: #export right
  (-> Expression Literal)
  (..variant 1 #1))

(def: (feature name definition)
  (-> Var (-> Var Statement) Statement)
  (definition name))

(syntax: #export (with_vars {vars (<code>.tuple (<>.some <code>.local_identifier))}
                   body)
  (do {! meta.monad}
    [ids (monad.seq ! (list.repeat (list.size vars) meta.count))]
    (wrap (list (` (let [(~+ (|> vars
                                 (list.zip/2 ids)
                                 (list\map (function (_ [id var])
                                             (list (code.local_identifier var)
                                                   (` (_.var (~ (code.text (format "v" (%.nat id)))))))))
                                 list.concat))]
                     (~ body)))))))

(syntax: (runtime: {declaration (<>.or <code>.local_identifier
                                       (<code>.form (<>.and <code>.local_identifier
                                                            (<>.some <code>.local_identifier))))}
           code)
  (macro.with_gensyms [g!_ runtime]
    (let [runtime_name (` (_.var (~ (code.text (%.code runtime)))))]
      (case declaration
        (#.Left name)
        (macro.with_gensyms [g!_]
          (let [g!name (code.local_identifier name)]
            (wrap (list (` (def: #export (~ g!name)
                             Var
                             (~ runtime_name)))
                        
                        (` (def: (~ (code.local_identifier (format "@" name)))
                             Statement
                             (..feature (~ runtime_name)
                                        (function ((~ g!_) (~ g!name))
                                          (_.set (~ g!name) (~ code))))))))))
        
        (#.Right [name inputs])
        (macro.with_gensyms [g!_]
          (let [g!name (code.local_identifier name)
                inputsC (list\map code.local_identifier inputs)
                inputs_typesC (list\map (function.constant (` _.Expression))
                                        inputs)]
            (wrap (list (` (def: #export ((~ g!name) (~+ inputsC))
                             (-> (~+ inputs_typesC) Computation)
                             (_.apply/* (list (~+ inputsC)) (~ runtime_name))))
                        
                        (` (def: (~ (code.local_identifier (format "@" name)))
                             Statement
                             (..feature (~ runtime_name)
                                        (function ((~ g!_) (~ g!_))
                                          (..with_vars [(~+ inputsC)]
                                            (_.function (~ g!_) (list (~+ inputsC))
                                              (~ code)))))))))))))))

(def: (nth index table)
  (-> Expression Expression Location)
  (_.nth (_.+ (_.int +1) index) table))

(def: last_index
  (|>> _.length (_.- (_.int +1))))

## No need to turn tuple//left and tuple//right into loops, as Lua
## does tail-call optimization.
## https://www.lua.org/pil/6.3.html
(runtime: (tuple//left lefts tuple)
  (with_vars [last_right]
    ($_ _.then
        (_.let (list last_right) (..last_index tuple))
        (_.if (_.> lefts last_right)
          ## No need for recursion
          (_.return (..nth lefts tuple))
          ## Needs recursion
          (_.return (tuple//left (_.- last_right lefts)
                                 (..nth last_right tuple)))))))

(runtime: (array//sub from to array)
  (with_vars [temp idx]
    ($_ _.then
        (_.let (list temp) (_.array (list)))
        (_.for_step idx from (_.- (_.int +1) to) (_.int +1)
                    (|> (_.var "table.insert")
                        (_.apply/* (list temp (..nth idx array)))
                        _.statement))
        (_.return temp))))

(runtime: (tuple//right lefts tuple)
  (with_vars [last_right right_index]
    ($_ _.then
        (_.let (list last_right) (..last_index tuple))
        (_.let (list right_index) (_.+ (_.int +1) lefts))
        (_.cond (list [(_.= last_right right_index)
                       (_.return (..nth right_index tuple))]
                      [(_.> last_right right_index)
                       ## Needs recursion.
                       (_.return (tuple//right (_.- last_right lefts)
                                               (..nth last_right tuple)))])
                (_.return (array//sub right_index (_.length tuple) tuple)))
        )))

(runtime: (sum//get sum wantsLast wantedTag)
  (let [no_match! (_.return _.nil)
        sum_tag (_.the ..variant_tag_field sum)
        sum_flag (_.the ..variant_flag_field sum)
        sum_value (_.the ..variant_value_field sum)
        is_last? (_.= (_.string "") sum_flag)
        test_recursion! (_.if is_last?
                          ## Must recurse.
                          (_.return (sum//get sum_value wantsLast (_.- sum_tag wantedTag)))
                          no_match!)]
    (_.cond (list [(_.= sum_tag wantedTag)
                   (_.if (_.= wantsLast sum_flag)
                     (_.return sum_value)
                     test_recursion!)]

                  [(_.> sum_tag wantedTag)
                   test_recursion!]

                  [(_.and (_.< sum_tag wantedTag)
                          (_.= (_.string "") wantsLast))
                   (_.return (variant' (_.- wantedTag sum_tag) sum_flag sum_value))])

            no_match!)))

(runtime: (array//copy array)
  (with_vars [temp idx]
    ($_ _.then
        (_.let (list temp) (_.array (list)))
        (<| (_.for_step idx (_.int +1) (_.length array) (_.int +1))
            (_.statement (|> (_.var "table.insert") (_.apply/* (list temp (_.nth idx array))))))
        (_.return temp))))

(runtime: (array//concat left right)
  (with_vars [temp idx]
    (let [copy! (function (_ input output)
                  (<| (_.for_step idx (_.int +1) (_.length input) (_.int +1))
                      (_.statement (|> (_.var "table.insert") (_.apply/* (list output (_.nth idx input)))))))]
      ($_ _.then
          (_.let (list temp) (_.array (list)))
          (copy! left temp)
          (copy! right temp)
          (_.return temp)))))

(def: runtime//adt
  Statement
  ($_ _.then
      @tuple//left
      @array//sub
      @tuple//right
      @sum//get
      @array//copy
      @array//concat
      ))

(runtime: (lux//try risky)
  (with_vars [success value]
    ($_ _.then
        (_.let (list success value) (|> risky (_.apply/* (list ..unit))
                                        _.return (_.closure (list))
                                        list _.apply/* (|> (_.var "pcall"))))
        (_.if success
          (_.return (..right value))
          (_.return (..left value))))))

(runtime: (lux//program_args raw)
  (with_vars [tail head idx]
    ($_ _.then
        (_.let (list tail) ..none)
        (<| (_.for_step idx (_.length raw) (_.int +1) (_.int -1))
            (_.set (list tail) (..some (_.array (list (_.nth idx raw)
                                                      tail)))))
        (_.return tail))))

(def: runtime//lux
  Statement
  ($_ _.then
      @lux//try
      @lux//program_args
      ))

(runtime: (i64//right_shift param subject)
  (let [mask (|> (_.int +1)
                 (_.bit_shl (_.- param (_.int +64)))
                 (_.- (_.int +1)))]
    (_.return (|> subject
                  (_.bit_shr param)
                  (_.bit_and mask)))))

(def: runtime//i64
  Statement
  ($_ _.then
      @i64//right_shift
      ))

(runtime: (text//index subject param start)
  (with_vars [idx]
    ($_ _.then
        (_.local/1 idx (_.apply/* (list subject param start (_.bool #1))
                                  (_.var "string.find")))
        (_.if (_.= _.nil idx)
          (_.return ..none)
          (_.return (..some (_.- (_.int +1) idx)))))))

(runtime: (text//clip text offset length)
  (_.return (_.apply/* (list text (_.+ (_.int +1) offset) (_.+ offset length))
                       (_.var "string.sub"))))

(runtime: (text//char idx text)
  (with_vars [char]
    ($_ _.then
        (_.local/1 char (_.apply/* (list text idx)
                                   (_.var "string.byte")))
        (_.if (_.= _.nil char)
          (_.statement (_.error/1 (_.string "[Lux Error] Cannot get char from text.")))
          (_.return char)))))

(def: runtime//text
  Statement
  ($_ _.then
      @text//index
      @text//clip
      @text//char
      ))

(runtime: (array//write idx value array)
  ($_ _.then
      (_.set (list (..nth idx array)) value)
      (_.return array)))

(def: runtime//array
  Statement
  ($_ _.then
      @array//write
      ))

(def: runtime
  Statement
  ($_ _.then
      ..runtime//adt
      ..runtime//lux
      ..runtime//i64
      ..runtime//text
      ..runtime//array
      ))

(def: #export artifact ..prefix)

(def: #export generate
  (Operation [Registry Output])
  (do ///////phase.monad
    [_ (/////generation.execute! ..runtime)
     _ (/////generation.save! "0" ..runtime)]
    (wrap [(|> artifact.empty
               artifact.resource
               product.right)
           (row.row ["0"
                     (|> ..runtime
                         _.code
                         (\ encoding.utf8 encode))])])))
