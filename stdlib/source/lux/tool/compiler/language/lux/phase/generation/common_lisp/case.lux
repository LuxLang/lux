(.module:
  [lux (#- case let if)
   [abstract
    ["." monad (#+ do)]]
   [control
    ["." exception (#+ exception:)]]
   [data
    ["." text]
    [collection
     ["." list ("#\." functor fold)]
     ["." set]]]
   [math
    [number
     ["n" nat]]]
   [target
    ["_" common_lisp (#+ Expression Var/1)]]]
  ["." // #_
   ["#." runtime (#+ Operation Phase Generator)]
   ["#." reference]
   ["#." primitive]
   ["/#" // #_
    ["#." reference]
    ["/#" // #_
     ["#." synthesis #_
      ["#/." case]]
     ["/#" // #_
      ["#." synthesis (#+ Member Synthesis Path)]
      ["#." generation]
      ["//#" /// #_
       [reference
        ["#." variable (#+ Register)]]
       ["#." phase ("#\." monad)]
       [meta
        [archive (#+ Archive)]]]]]]])

(def: #export register
  (-> Register Var/1)
  (|>> (///reference.local //reference.system) :assume))

(def: #export capture
  (-> Register Var/1)
  (|>> (///reference.foreign //reference.system) :assume))

(def: #export (let expression archive [valueS register bodyS])
  (Generator [Synthesis Register Synthesis])
  (do ///////phase.monad
    [valueG (expression archive valueS)
     bodyG (expression archive bodyS)]
    (wrap (_.let (list [(..register register) valueG])
            bodyG))))

(def: #export (if expression archive [testS thenS elseS])
  (Generator [Synthesis Synthesis Synthesis])
  (do ///////phase.monad
    [testG (expression archive testS)
     thenG (expression archive thenS)
     elseG (expression archive elseS)]
    (wrap (_.if testG thenG elseG))))

(def: #export (get expression archive [pathP valueS])
  (Generator [(List Member) Synthesis])
  (do ///////phase.monad
    [valueG (expression archive valueS)]
    (wrap (list\fold (function (_ side source)
                       (.let [method (.case side
                                       (^template [<side> <accessor>]
                                         [(<side> lefts)
                                          (<accessor> (_.int (.int lefts)))])
                                       ([#.Left //runtime.tuple//left]
                                        [#.Right //runtime.tuple//right]))]
                         (method source)))
                     valueG
                     pathP))))

(def: @savepoint (_.var "lux_pm_savepoint"))
(def: @cursor (_.var "lux_pm_cursor"))
(def: @temp (_.var "lux_pm_temp"))
(def: @variant (_.var "lux_pm_variant"))

(def: (push! value)
  (-> (Expression Any) (Expression Any))
  (_.setq @cursor (_.cons/2 [value @cursor])))

(def: pop!
  (Expression Any)
  (_.setq @cursor (_.cdr/1 @cursor)))

(def: peek
  (Expression Any)
  (_.car/1 @cursor))

(def: save!
  (Expression Any)
  (_.setq @savepoint (_.cons/2 [@cursor @savepoint])))

(def: restore!
  (Expression Any)
  ($_ _.progn
      (_.setq @cursor (_.car/1 @savepoint))
      (_.setq @savepoint (_.cdr/1 @savepoint))))

(def: @fail (_.label "lux_pm_fail"))
(def: @done (_.label "lux_pm_done"))

(def: fail! (_.return-from ..@fail _.nil))

(def: (multi_pop! pops)
  (-> Nat (Expression Any))
  (_.setq @cursor (_.nthcdr/2 [(_.int (.int pops)) @cursor])))

(template [<name> <flag> <prep>]
  [(def: (<name> simple? idx)
     (-> Bit Nat (Expression Any))
     (.let [<failure_condition> (_.eq @variant @temp)]
       (_.let (list [@variant ..peek])
         ($_ _.progn
             (_.setq @temp (|> idx <prep> .int _.int (//runtime.sum//get @variant <flag>)))
             (.if simple?
               (_.when <failure_condition>
                       fail!)
               (_.if <failure_condition>
                 fail!
                 (..push! @temp))
               )))))]

  [left_choice  _.nil         (<|)]
  [right_choice (_.string "") inc]
  )

(def: (alternation pre! post!)
  (-> (Expression Any) (Expression Any) (Expression Any))
  (_.progn (<| (_.block ..@fail)
               (_.progn ..save!)
               pre!)
           ($_ _.progn
               ..restore!
               post!)))

(def: (pattern_matching' expression archive)
  (Generator Path)
  (function (recur pathP)
    (.case pathP
      (^ (/////synthesis.path/then bodyS))
      (\ ///////phase.monad map (_.return-from ..@done) (expression archive bodyS))

      #/////synthesis.Pop
      (///////phase\wrap ..pop!)

      (#/////synthesis.Bind register)
      (///////phase\wrap (_.setq (..register register) ..peek))

      (#/////synthesis.Bit_Fork when thenP elseP)
      (do {! ///////phase.monad}
        [then! (recur thenP)
         else! (.case elseP
                 (#.Some elseP)
                 (recur elseP)

                 #.None
                 (wrap ..fail!))]
        (wrap (.if when
                (_.if ..peek
                  then!
                  else!)
                (_.if ..peek
                  else!
                  then!))))

      (^template [<tag> <format> <=>]
        [(<tag> cons)
         (do {! ///////phase.monad}
           [clauses (monad.map ! (function (_ [match then])
                                   (do !
                                     [then! (recur then)]
                                     (wrap [(<=> (|> match <format>)
                                                 ..peek)
                                            then!])))
                               (#.Cons cons))]
           (wrap (list\fold (function (_ [when then] else)
                              (_.if when then else))
                            ..fail!
                            clauses)))])
      ([#/////synthesis.I64_Fork //primitive.i64 _.=]
       [#/////synthesis.F64_Fork //primitive.f64 _.=]
       [#/////synthesis.Text_Fork //primitive.text _.string=])

      (^template [<complex> <simple> <choice>]
        [(^ (<complex> idx))
         (///////phase\wrap (<choice> false idx))

         (^ (<simple> idx nextP))
         (|> nextP
             recur
             (\ ///////phase.monad map (_.progn (<choice> true idx))))])
      ([/////synthesis.side/left  /////synthesis.simple_left_side  ..left_choice]
       [/////synthesis.side/right /////synthesis.simple_right_side ..right_choice])

      (^ (/////synthesis.member/left 0))
      (///////phase\wrap (..push! (_.elt/2 [..peek (_.int +0)])))
      
      (^template [<pm> <getter>]
        [(^ (<pm> lefts))
         (///////phase\wrap (|> ..peek (<getter> (_.int (.int lefts))) ..push!))])
      ([/////synthesis.member/left  //runtime.tuple//left]
       [/////synthesis.member/right //runtime.tuple//right])

      (^ (/////synthesis.!multi_pop nextP))
      (.let [[extra_pops nextP'] (////synthesis/case.count_pops nextP)]
        (do ///////phase.monad
          [next! (recur nextP')]
          (///////phase\wrap ($_ _.progn
                                 (..multi_pop! (n.+ 2 extra_pops))
                                 next!))))

      (^template [<tag> <combinator>]
        [(^ (<tag> preP postP))
         (do ///////phase.monad
           [pre! (recur preP)
            post! (recur postP)]
           (wrap (<combinator> pre! post!)))])
      ([/////synthesis.path/alt ..alternation]
       [/////synthesis.path/seq _.progn]))))

(def: (pattern_matching expression archive pathP)
  (Generator Path)
  (do ///////phase.monad
    [pattern_matching! (pattern_matching' expression archive pathP)]
    (wrap (_.block ..@done
                   (_.progn (_.block ..@fail
                                     pattern_matching!)
                            (_.error/1 (_.string ////synthesis/case.pattern_matching_error)))))))

(def: #export (case expression archive [valueS pathP])
  (Generator [Synthesis Path])
  (do ///////phase.monad
    [initG (expression archive valueS)
     pattern_matching! (pattern_matching expression archive pathP)]
    (wrap (_.let (list [@cursor (_.list/* (list initG))]
                       [@savepoint (_.list/* (list))]
                       [@temp _.nil])
            pattern_matching!))))
