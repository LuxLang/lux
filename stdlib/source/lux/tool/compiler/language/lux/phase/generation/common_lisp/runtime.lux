(.module:
  [lux (#- Location inc)
   ["." meta]
   [abstract
    ["." monad (#+ do)]]
   [control
    ["." function]
    ["<>" parser
     ["<.>" code]]]
   [data
    ["." product]
    ["." text ("#\." hash)
     ["%" format (#+ format)]
     ["." encoding]]
    [collection
     ["." list ("#\." functor)]
     ["." row]]]
   ["." macro
    [syntax (#+ syntax:)]
    ["." code]]
   [math
    [number (#+ hex)
     ["." i64]]]
   ["@" target
    ["_" common_lisp (#+ Expression Var/1 Computation Literal)]]]
  ["." /// #_
   ["#." reference]
   ["//#" /// #_
    [analysis (#+ Variant)]
    ["#." synthesis (#+ Synthesis)]
    ["#." generation]
    ["//#" ///
     ["#." phase]
     [reference
      [variable (#+ Register)]]
     [meta
      [archive (#+ Output Archive)
       ["." artifact (#+ Registry)]]]]]])

(def: module_id
  0)

(template [<name> <base>]
  [(type: #export <name>
     (<base> Var/1 (Expression Any) (Expression Any)))]

  [Operation /////generation.Operation]
  [Phase /////generation.Phase]
  [Handler /////generation.Handler]
  [Bundle /////generation.Bundle]
  )

(type: #export (Generator i)
  (-> Phase Archive i (Operation (Expression Any))))

(def: #export unit
  (_.string /////synthesis.unit))

(def: (flag value)
  (-> Bit Literal)
  (if value
    (_.string "")
    _.nil))

(def: (variant' tag last? value)
  (-> (Expression Any) (Expression Any) (Expression Any) (Computation Any))
  (_.list/* (list tag last? value)))

(def: #export (variant [lefts right? value])
  (-> (Variant (Expression Any)) (Computation Any))
  (variant' (_.int (.int lefts)) (flag right?) value))

(def: #export none
  (Computation Any)
  (|> ..unit [0 #0] ..variant))

(def: #export some
  (-> (Expression Any) (Computation Any))
  (|>> [1 #1] ..variant))

(def: #export left
  (-> (Expression Any) (Computation Any))
  (|>> [0 #0] ..variant))

(def: #export right
  (-> (Expression Any) (Computation Any))
  (|>> [1 #1] ..variant))

(syntax: #export (with_vars {vars (<code>.tuple (<>.some <code>.local_identifier))}
                   body)
  (do {! meta.monad}
    [ids (monad.seq ! (list.repeat (list.size vars) meta.count))]
    (wrap (list (` (let [(~+ (|> vars
                                 (list.zip/2 ids)
                                 (list\map (function (_ [id var])
                                             (list (code.local_identifier var)
                                                   (` (_.var (~ (code.text (format "v" (%.nat id)))))))))
                                 list.concat))]
                     (~ body)))))))

(syntax: (runtime: {declaration (<>.or <code>.local_identifier
                                       (<code>.form (<>.and <code>.local_identifier
                                                            (<>.some <code>.local_identifier))))}
           code)
  (do meta.monad
    [runtime_id meta.count]
    (macro.with_gensyms [g!_]
      (let [runtime (code.local_identifier (///reference.artifact [..module_id runtime_id]))
            runtime_name (` (_.var (~ (code.text (%.code runtime)))))]
        (case declaration
          (#.Left name)
          (let [g!name (code.local_identifier name)
                code_nameC (code.local_identifier (format "@" name))]
            (wrap (list (` (def: #export (~ g!name)
                             _.Var/1
                             (~ runtime_name)))
                        
                        (` (def: (~ code_nameC)
                             (_.Expression Any)
                             (_.defparameter (~ runtime_name) (~ code)))))))
          
          (#.Right [name inputs])
          (let [g!name (code.local_identifier name)
                code_nameC (code.local_identifier (format "@" name))
                
                inputsC (list\map code.local_identifier inputs)
                inputs_typesC (list\map (function.constant (` (_.Expression Any)))
                                        inputs)]
            (wrap (list (` (def: #export ((~ g!name) (~+ inputsC))
                             (-> (~+ inputs_typesC) (_.Computation Any))
                             (_.call/* (~ runtime_name) (list (~+ inputsC)))))
                        
                        (` (def: (~ code_nameC)
                             (_.Expression Any)
                             (..with_vars [(~+ inputsC)]
                               (_.defun (~ runtime_name) (_.args (list (~+ inputsC)))
                                        (~ code)))))))))))))

(runtime: (lux//try op)
  (with_vars [error]
    (_.handler-case
     (list [(_.bool true) error
            (..left (_.format/3 [_.nil (_.string "~A") error]))])
     (..right (_.funcall/+ [op (list ..unit)])))))

## TODO: Use Common Lisp's swiss-army loop macro instead.
(runtime: (lux//program_args inputs)
  (with_vars [loop input tail]
    (_.labels (list [loop [(_.args (list input tail))
                           (_.if (_.null/1 input)
                             tail
                             (_.funcall/+ [(_.function/1 loop)
                                           (list (_.cdr/1 input)
                                                 (..some (_.vector/* (list (_.car/1 input) tail))))]))]])
              (_.funcall/+ [(_.function/1 loop)
                            (list (_.reverse/1 inputs)
                                  ..none)]))))

(def: runtime//lux
  ($_ _.progn
      @lux//try
      @lux//program_args
      ))

(def: last_index
  (|>> _.length/1 (_.- (_.int +1))))

(with_expansions [<recur> (as_is ($_ _.then
                                     (_.; (_.set lefts (_.- last_index_right lefts)))
                                     (_.; (_.set tuple (_.nth last_index_right tuple)))))]
  (template: (!recur <side>)
    (<side> (|> lefts (_.- last_index_right))
            (_.elt/2 [tuple last_index_right])))
  
  (runtime: (tuple//left lefts tuple)
    (with_vars [last_index_right]
      (_.let (list [last_index_right (..last_index tuple)])
        (_.if (_.> lefts last_index_right)
          ## No need for recursion
          (_.elt/2 [tuple lefts])
          ## Needs recursion
          (!recur tuple//left)))))

  (runtime: (tuple//right lefts tuple)
    (with_vars [last_index_right right_index]
      (_.let (list [last_index_right (..last_index tuple)]
                   [right_index (_.+ (_.int +1) lefts)])
        (_.cond (list [(_.= last_index_right right_index)
                       (_.elt/2 [tuple right_index])]
                      [(_.> last_index_right right_index)
                       ## Needs recursion.
                       (!recur tuple//right)])
                (_.subseq/3 [tuple right_index (_.length/1 tuple)]))
        ))))

## TODO: Find a way to extract parts of the sum without "nth", which
## does a linear search, and is thus expensive.
(runtime: (sum//get sum wantsLast wantedTag)
  (with_vars [sum_tag sum_flag]
    (let [@exit (_.label "exit")
          return! (_.return-from @exit)
          no_match! (return! sum)
          sum_value (_.nth/2 [(_.int +2) sum])
          test_recursion! (_.if sum_flag
                            ## Must iterate.
                            ($_ _.progn
                                (_.setq wantedTag (_.- sum_tag wantedTag))
                                (_.setq sum sum_value))
                            no_match!)]
      (<| (_.progn (_.setq sum_tag (_.nth/2 [(_.int +0) sum])))
          (_.progn (_.setq sum_flag (_.nth/2 [(_.int +1) sum])))
          (_.block @exit)
          (_.while (_.bool true))
          (_.cond (list [(_.= sum_tag wantedTag)
                         (_.if (_.equal wantsLast sum_flag)
                           (return! sum_value)
                           test_recursion!)]

                        [(_.> sum_tag wantedTag)
                         test_recursion!]

                        [(_.and (_.< sum_tag wantedTag)
                                wantsLast)
                         (return! (variant' (_.- wantedTag sum_tag) sum_flag sum_value))])

                  no_match!)))))

(def: runtime//adt
  ($_ _.progn
      @tuple//left
      @tuple//right
      @sum//get
      ))

(runtime: (i64//logic_right_shift shift input)
  (_.if (_.= (_.int +0) shift)
    input
    (|> input
        (_.ash (_.* (_.int -1) shift))
        (_.logand (_.int (hex "+7FFFFFFFFFFFFFFF"))))))

(def: runtime//i64
  ($_ _.progn
      @i64//logic_right_shift
      ))

(runtime: (text//clip from to text)
  (_.subseq/3 [text from to]))

(runtime: (text//index reference start space)
  (with_vars [index]
    (_.let (list [index (_.search/3 [reference space start])])
      (_.if index
        (..some index)
        ..none))))

(def: runtime//text
  ($_ _.progn
      @text//index
      @text//clip
      ))

(runtime: (io//exit code)
  ($_ _.progn
      (_.conditional+ (list "sbcl")
                      (_.call/* (_.var "sb-ext:quit") (list code)))
      (_.conditional+ (list "clisp")
                      (_.call/* (_.var "ext:exit") (list code)))
      (_.conditional+ (list "ccl")
                      (_.call/* (_.var "ccl:quit") (list code)))
      (_.conditional+ (list "allegro")
                      (_.call/* (_.var "excl:exit") (list code)))
      (_.call/* (_.var "cl-user::quit") (list code))))

(runtime: (io//current_time _)
  (|> (_.get-universal-time/0 [])
      (_.* (_.int +1,000))))

(def: runtime//io
  ($_ _.progn
      @io//exit
      @io//current_time
      ))

(def: runtime
  ($_ _.progn
      runtime//adt
      runtime//lux
      runtime//i64
      runtime//text
      runtime//io
      ))

(def: #export generate
  (Operation [Registry Output])
  (do ///////phase.monad
    [_ (/////generation.execute! ..runtime)
     _ (/////generation.save! (%.nat ..module_id) ..runtime)]
    (wrap [(|> artifact.empty
               artifact.resource
               product.right)
           (row.row [(%.nat ..module_id)
                     (|> ..runtime
                         _.code
                         (\ encoding.utf8 encode))])])))
