(.module:
  [lux (#- Module Code)
   ["@" target]
   [abstract
    [predicate (#+ Predicate)]
    ["." monad (#+ Monad do)]]
   [control
    ["." try (#+ Try)]
    ["." exception (#+ exception:)]
    [security
     ["!" capability]]
    [concurrency
     ["." promise (#+ Promise) ("#\." monad)]]]
   [data
    [binary (#+ Binary)]
    ["." text ("#\." hash)
     ["%" format (#+ format)]
     [encoding
      ["." utf8]]]
    [collection
     ["." dictionary (#+ Dictionary)]]]
   [world
    ["." file (#+ Path File)]]]
  [program
   [compositor
    [import (#+ Import)]]]
  ["." // (#+ Context Code)
   ["/#" // #_
    [archive
     [descriptor (#+ Module)]]
    ["/#" // (#+ Input)]]])

(exception: #export (cannot_find_module {importer Module} {module Module})
  (exception.report
   ["Module" (%.text module)]
   ["Importer" (%.text importer)]))

(exception: #export (cannot_read_module {module Module})
  (exception.report
   ["Module" (%.text module)]))

(type: #export Extension
  Text)

(def: lux_extension
  Extension
  ".lux")

(def: #export (path system context module)
  (All [m] (-> (file.System m) Context Module Path))
  (|> module
      (//.sanitize system)
      (format context (\ system separator))))

(def: (find_source_file system importer contexts module extension)
  (-> (file.System Promise) Module (List Context) Module Extension
      (Promise (Try [Path (File Promise)])))
  (case contexts
    #.Nil
    (promise\wrap (exception.throw ..cannot_find_module [importer module]))

    (#.Cons context contexts')
    (do promise.monad
      [#let [path (format (..path system context module) extension)]
       file (!.use (\ system file) [path])]
      (case file
        (#try.Success file)
        (wrap (#try.Success [path file]))

        (#try.Failure _)
        (find_source_file system importer contexts' module extension)))))

(def: (full_host_extension partial_host_extension)
  (-> Extension Extension)
  (format partial_host_extension ..lux_extension))

(def: (find_local_source_file system importer import contexts partial_host_extension module)
  (-> (file.System Promise) Module Import (List Context) Extension Module
      (Promise (Try [Path Binary])))
  ## Preference is explicitly being given to Lux files that have a host extension.
  ## Normal Lux files (i.e. without a host extension) are then picked as fallback files.
  (do {! promise.monad}
    [outcome (..find_source_file system importer contexts module (..full_host_extension partial_host_extension))]
    (case outcome
      (#try.Success [path file])
      (do (try.with !)
        [data (!.use (\ file content) [])]
        (wrap [path data]))

      (#try.Failure _)
      (do (try.with !)
        [[path file] (..find_source_file system importer contexts module ..lux_extension)
         data (!.use (\ file content) [])]
        (wrap [path data])))))

(def: (find_library_source_file importer import partial_host_extension module)
  (-> Module Import Extension Module (Try [Path Binary]))
  (let [path (format module (..full_host_extension partial_host_extension))]
    (case (dictionary.get path import)
      (#.Some data)
      (#try.Success [path data])

      #.None
      (let [path (format module ..lux_extension)]
        (case (dictionary.get path import)
          (#.Some data)
          (#try.Success [path data])

          #.None
          (exception.throw ..cannot_find_module [importer module]))))))

(def: (find_any_source_file system importer import contexts partial_host_extension module)
  (-> (file.System Promise) Module Import (List Context) Extension Module
      (Promise (Try [Path Binary])))
  ## Preference is explicitly being given to Lux files that have a host extension.
  ## Normal Lux files (i.e. without a host extension) are then picked as fallback files.
  (do {! promise.monad}
    [outcome (find_local_source_file system importer import contexts partial_host_extension module)]
    (case outcome
      (#try.Success [path data])
      (wrap outcome)

      (#try.Failure _)
      (wrap (..find_library_source_file importer import partial_host_extension module)))))

(def: #export (read system importer import contexts partial_host_extension module)
  (-> (file.System Promise) Module Import (List Context) Extension Module
      (Promise (Try Input)))
  (do (try.with promise.monad)
    [[path binary] (..find_any_source_file system importer import contexts partial_host_extension module)]
    (case (\ utf8.codec decode binary)
      (#try.Success code)
      (wrap {#////.module module
             #////.file path
             #////.hash (text\hash code)
             #////.code code})
      
      (#try.Failure _)
      (promise\wrap (exception.throw ..cannot_read_module [module])))))

(type: #export Enumeration
  (Dictionary Path Binary))

(exception: #export (cannot_clean_path {prefix Path} {path Path})
  (exception.report
   ["Prefix" (%.text prefix)]
   ["Path" (%.text path)]))

(def: (clean_path system context path)
  (All [!] (-> (file.System !) Context Path (Try Path)))
  (let [prefix (format context (\ system separator))]
    (case (text.split_with prefix path)
      #.None
      (exception.throw ..cannot_clean_path [prefix path])
      
      (#.Some [_ path])
      (#try.Success path))))

(def: (enumerate_context system context enumeration)
  (-> (file.System Promise) Context Enumeration (Promise (Try Enumeration)))
  (do {! (try.with promise.monad)}
    [directory (!.use (\ system directory) [context])]
    (loop [directory directory
           enumeration enumeration]
      (do !
        [files (!.use (\ directory files) [])
         enumeration (monad.fold ! (function (_ file enumeration)
                                     (let [path (!.use (\ file path) [])]
                                       (if (text.ends_with? ..lux_extension path)
                                         (do !
                                           [path (promise\wrap (..clean_path system context path))
                                            source_code (!.use (\ file content) [])]
                                           (promise\wrap
                                            (dictionary.try_put path source_code enumeration)))
                                         (wrap enumeration))))
                                 enumeration
                                 files)
         directories (!.use (\ directory directories) [])]
        (monad.fold ! recur enumeration directories)))))

(def: Action
  (type (All [a] (Promise (Try a)))))

(def: #export (enumerate system contexts)
  (-> (file.System Promise) (List Context) (Action Enumeration))
  (monad.fold (: (Monad Action)
                 (try.with promise.monad))
              (enumerate_context system)
              (: Enumeration
                 (dictionary.new text.hash))
              contexts))
