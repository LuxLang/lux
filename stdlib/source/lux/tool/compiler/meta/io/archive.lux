(.module:
  [lux (#- Module)
   ["@" target (#+ Host)]
   [abstract
    [predicate (#+ Predicate)]
    ["." monad (#+ do)]]
   [control
    ["." try (#+ Try)]
    ["." exception (#+ exception:)]
    [concurrency
     ["." promise (#+ Promise) ("#\." monad)]]
    [security
     ["!" capability (#+ capability:)]]
    ["<>" parser
     ["<b>" binary (#+ Parser)]]]
   [data
    [binary (#+ Binary)]
    ["." product]
    ["." text ("#\." equivalence)
     ["%" format (#+ format)]]
    [collection
     ["." list ("#\." functor fold)]
     ["." dictionary (#+ Dictionary)]
     ["." row (#+ Row)]
     ["." set]]]
   [math
    [number
     ["n" nat]]]
   [world
    ["." file (#+ Path File Directory)]]]
  [program
   [compositor
    [import (#+ Import)]
    ["." static (#+ Static)]]]
  ["." // (#+ Context)
   ["#." context]
   ["/#" //
    ["." archive (#+ Archive)
     ["." artifact (#+ Artifact)]
     ["." descriptor (#+ Module Descriptor)]
     ["." document (#+ Document)]]
    [cache
     ["." dependency]]
    ["/#" // (#+ Input)
     [language
      ["$" lux
       ["." version]
       ["." analysis]
       ["." synthesis]
       ["." generation]
       ["." directive]
       ["#/." program]]]]]])

(exception: #export (cannot_prepare {archive Path}
                                    {module_id archive.ID}
                                    {error Text})
  (exception.report
   ["Archive" archive]
   ["Module ID" (%.nat module_id)]
   ["Error" error]))

(def: (archive system static)
  (All [!] (-> (file.System !) Static Path))
  (format (get@ #static.target static)
          (\ system separator)
          (get@ #static.host static)))

(def: (unversioned_lux_archive system static)
  (All [!] (-> (file.System !) Static Path))
  (format (..archive system static)
          (\ system separator)
          //.lux_context))

(def: (versioned_lux_archive system static)
  (All [!] (-> (file.System !) Static Path))
  (format (..unversioned_lux_archive system static)
          (\ system separator)
          (%.nat version.version)))

(def: (module system static module_id)
  (All [!] (-> (file.System !) Static archive.ID Path))
  (format (..versioned_lux_archive system static)
          (\ system separator)
          (%.nat module_id)))

(def: #export (artifact system static module_id name)
  (All [!] (-> (file.System !) Static archive.ID Text Path))
  (format (..module system static module_id)
          (\ system separator)
          name
          (get@ #static.artifact_extension static)))

(def: #export (prepare system static module_id)
  (-> (file.System Promise) Static archive.ID (Promise (Try Any)))
  (do {! promise.monad}
    [#let [module (..module system static module_id)]
     module_exists? (file.exists? promise.monad system module)]
    (if module_exists?
      (wrap (#try.Success []))
      (do !
        [_ (file.get_directory ! system (..unversioned_lux_archive system static))
         _ (file.get_directory ! system (..versioned_lux_archive system static))
         outcome (!.use (\ system create_directory) module)]
        (case outcome
          (#try.Success output)
          (wrap (#try.Success []))

          (#try.Failure error)
          (wrap (exception.throw ..cannot_prepare [(..archive system static)
                                                   module_id
                                                   error])))))))

(def: #export (write system static module_id name content)
  (-> (file.System Promise) Static archive.ID Text Binary (Promise (Try Any)))
  (do (try.with promise.monad)
    [artifact (: (Promise (Try (File Promise)))
                 (file.get_file promise.monad system
                                (..artifact system static module_id name)))]
    (!.use (\ artifact over_write) content)))

(def: #export (enable system static)
  (-> (file.System Promise) Static (Promise (Try Any)))
  (do (try.with promise.monad)
    [_ (: (Promise (Try (Directory Promise)))
          (file.get_directory promise.monad system (get@ #static.target static)))
     _ (: (Promise (Try (Directory Promise)))
          (file.get_directory promise.monad system (..archive system static)))]
    (wrap [])))

(def: (general_descriptor system static)
  (-> (file.System Promise) Static Path)
  (format (..archive system static)
          (\ system separator)
          "general_descriptor"))

(def: #export (freeze system static archive)
  (-> (file.System Promise) Static Archive (Promise (Try Any)))
  (do (try.with promise.monad)
    [file (: (Promise (Try (File Promise)))
             (file.get_file promise.monad system (..general_descriptor system static)))]
    (!.use (\ file over_write) (archive.export ///.version archive))))

(def: module_descriptor_file
  "module_descriptor")

(def: (module_descriptor system static module_id)
  (-> (file.System Promise) Static archive.ID Path)
  (format (..module system static module_id)
          (\ system separator)
          ..module_descriptor_file))

(def: #export (cache system static module_id content)
  (-> (file.System Promise) Static archive.ID Binary (Promise (Try Any)))
  (do (try.with promise.monad)
    [file (: (Promise (Try (File Promise)))
             (file.get_file promise.monad system
                            (..module_descriptor system static module_id)))]
    (!.use (\ file over_write) content)))

(def: (read_module_descriptor system static module_id)
  (-> (file.System Promise) Static archive.ID (Promise (Try Binary)))
  (do (try.with promise.monad)
    [file (: (Promise (Try (File Promise)))
             (file.get_file promise.monad system
                            (..module_descriptor system static module_id)))]
    (!.use (\ file content) [])))

(def: parser
  (Parser [Descriptor (Document .Module)])
  (<>.and descriptor.parser
          (document.parser $.parser)))

(def: (fresh_analysis_state host)
  (-> Host .Lux)
  (analysis.state (analysis.info version.version host)))

(def: (analysis_state host archive)
  (-> Host Archive (Try .Lux))
  (do {! try.monad}
    [modules (: (Try (List [Module .Module]))
                (monad.map ! (function (_ module)
                               (do !
                                 [[descriptor document] (archive.find module archive)
                                  content (document.read $.key document)]
                                 (wrap [module content])))
                           (archive.archived archive)))]
    (wrap (set@ #.modules modules (fresh_analysis_state host)))))

(def: (cached_artifacts system static module_id)
  (-> (file.System Promise) Static archive.ID (Promise (Try (Dictionary Text Binary))))
  (do {! (try.with promise.monad)}
    [module_dir (!.use (\ system directory) (..module system static module_id))
     cached_files (!.use (\ module_dir files) [])]
    (|> cached_files
        (list\map (function (_ file)
                    [(!.use (\ file name) [])
                     (!.use (\ file path) [])]))
        (list.filter (|>> product.left (text\= ..module_descriptor_file) not))
        (monad.map ! (function (_ [name path])
                       (do !
                         [file (: (Promise (Try (File Promise)))
                                  (!.use (\ system file) path))
                          data (: (Promise (Try Binary))
                                  (!.use (\ file content) []))]
                         (wrap [name data]))))
        (\ ! map (dictionary.from_list text.hash)))))

(type: Definitions (Dictionary Text Any))
(type: Analysers (Dictionary Text analysis.Handler))
(type: Synthesizers (Dictionary Text synthesis.Handler))
(type: Generators (Dictionary Text generation.Handler))
(type: Directives (Dictionary Text directive.Handler))

(type: Bundles
  [Analysers
   Synthesizers
   Generators
   Directives])

(def: empty_bundles
  Bundles
  [(dictionary.new text.hash)
   (dictionary.new text.hash)
   (dictionary.new text.hash)
   (dictionary.new text.hash)])

(def: (loaded_document extension host module_id expected actual document)
  (All [expression directive]
    (-> Text (generation.Host expression directive) archive.ID (Row Artifact) (Dictionary Text Binary) (Document .Module)
        (Try [(Document .Module) Bundles])))
  (do {! try.monad}
    [[definitions bundles] (: (Try [Definitions Bundles])
                              (loop [input (row.to_list expected)
                                     definitions (: Definitions
                                                    (dictionary.new text.hash))
                                     bundles ..empty_bundles]
                                (let [[analysers synthesizers generators directives] bundles]
                                  (case input
                                    (#.Cons [[artifact_id artifact_category] input'])
                                    (case (do !
                                            [data (try.from_maybe (dictionary.get (format (%.nat artifact_id) extension) actual))
                                             #let [context [module_id artifact_id]
                                                   directive (\ host ingest context data)]]
                                            (case artifact_category
                                              #artifact.Anonymous
                                              (do !
                                                [_ (\ host re_learn context directive)]
                                                (wrap [definitions
                                                       [analysers
                                                        synthesizers
                                                        generators
                                                        directives]]))
                                              
                                              (#artifact.Definition name)
                                              (if (text\= $/program.name name)
                                                (wrap [definitions
                                                       [analysers
                                                        synthesizers
                                                        generators
                                                        directives]])
                                                (do !
                                                  [value (\ host re_load context directive)]
                                                  (wrap [(dictionary.put name value definitions)
                                                         [analysers
                                                          synthesizers
                                                          generators
                                                          directives]])))

                                              (#artifact.Analyser extension)
                                              (do !
                                                [value (\ host re_load context directive)]
                                                (wrap [definitions
                                                       [(dictionary.put extension (:coerce analysis.Handler value) analysers)
                                                        synthesizers
                                                        generators
                                                        directives]]))

                                              (#artifact.Synthesizer extension)
                                              (do !
                                                [value (\ host re_load context directive)]
                                                (wrap [definitions
                                                       [analysers
                                                        (dictionary.put extension (:coerce synthesis.Handler value) synthesizers)
                                                        generators
                                                        directives]]))

                                              (#artifact.Generator extension)
                                              (do !
                                                [value (\ host re_load context directive)]
                                                (wrap [definitions
                                                       [analysers
                                                        synthesizers
                                                        (dictionary.put extension (:coerce generation.Handler value) generators)
                                                        directives]]))

                                              (#artifact.Directive extension)
                                              (do !
                                                [value (\ host re_load context directive)]
                                                (wrap [definitions
                                                       [analysers
                                                        synthesizers
                                                        generators
                                                        (dictionary.put extension (:coerce directive.Handler value) directives)]]))))
                                      (#try.Success [definitions' bundles'])
                                      (recur input' definitions' bundles')

                                      failure
                                      failure)
                                    
                                    #.None
                                    (#try.Success [definitions bundles])))))
     content (document.read $.key document)
     definitions (monad.map ! (function (_ [def_name def_global])
                                (case def_global
                                  (#.Alias alias)
                                  (wrap [def_name (#.Alias alias)])
                                  
                                  (#.Definition [exported? type annotations _])
                                  (do !
                                    [value (try.from_maybe (dictionary.get def_name definitions))]
                                    (wrap [def_name (#.Definition [exported? type annotations value])]))))
                            (get@ #.definitions content))]
    (wrap [(document.write $.key (set@ #.definitions definitions content))
           bundles])))

(def: (load_definitions system static module_id host_environment [descriptor document])
  (All [expression directive]
    (-> (file.System Promise) Static archive.ID (generation.Host expression directive)
        [Descriptor (Document .Module)]
        (Promise (Try [[Descriptor (Document .Module)]
                       Bundles]))))
  (do (try.with promise.monad)
    [actual (cached_artifacts system static module_id)
     #let [expected (|> descriptor (get@ #descriptor.registry) artifact.artifacts)]
     [document bundles] (promise\wrap (loaded_document (get@ #static.artifact_extension static) host_environment module_id expected actual document))]
    (wrap [[descriptor document] bundles])))

(def: (purge! system static [module_name module_id])
  (-> (file.System Promise) Static [Module archive.ID] (Promise (Try Any)))
  (do {! (try.with promise.monad)}
    [cache (!.use (\ system directory) [(..module system static module_id)])
     artifacts (!.use (\ cache files) [])
     _ (monad.map ! (function (_ artifact)
                      (!.use (\ artifact delete) []))
                  artifacts)]
    (!.use (\ cache discard) [])))

(def: (valid_cache? expected actual)
  (-> Descriptor Input Bit)
  (and (text\= (get@ #descriptor.name expected)
               (get@ #////.module actual))
       (text\= (get@ #descriptor.file expected)
               (get@ #////.file actual))
       (n.= (get@ #descriptor.hash expected)
            (get@ #////.hash actual))))

(type: Purge
  (Dictionary Module archive.ID))

(def: initial_purge
  (-> (List [Bit [Module [archive.ID [Descriptor (Document .Module)]]]])
      Purge)
  (|>> (list.all (function (_ [valid_cache? [module_name [module_id _]]])
                   (if valid_cache?
                     #.None
                     (#.Some [module_name module_id]))))
       (dictionary.from_list text.hash)))

(def: (full_purge caches load_order)
  (-> (List [Bit [Module [archive.ID [Descriptor (Document .Module)]]]])
      dependency.Order
      Purge)
  (list\fold (function (_ [module_name [module_id [descriptor document]]] purge)
               (let [purged? (: (Predicate Module)
                                (dictionary.key? purge))]
                 (if (purged? module_name)
                   purge
                   (if (|> descriptor
                           (get@ #descriptor.references)
                           set.to_list
                           (list.any? purged?))
                     (dictionary.put module_name module_id purge)
                     purge))))
             (..initial_purge caches)
             load_order))

(def: (load_every_reserved_module host_environment system static import contexts archive)
  (All [expression directive]
    (-> (generation.Host expression directive) (file.System Promise) Static Import (List Context) Archive
        (Promise (Try [Archive .Lux Bundles]))))
  (do {! (try.with promise.monad)}
    [pre_loaded_caches (|> archive
                           archive.reservations
                           (monad.map ! (function (_ [module_name module_id])
                                          (do !
                                            [data (..read_module_descriptor system static module_id)
                                             [descriptor document] (promise\wrap (<b>.run ..parser data))]
                                            (if (text\= archive.runtime_module module_name)
                                              (wrap [true
                                                     [module_name [module_id [descriptor document]]]])
                                              (do !
                                                [input (//context.read system import contexts (get@ #static.host_module_extension static) module_name)]
                                                (wrap [(..valid_cache? descriptor input)
                                                       [module_name [module_id [descriptor document]]]])))))))
     load_order (|> pre_loaded_caches
                    (list\map product.right)
                    (monad.fold try.monad
                                (function (_ [module [module_id descriptor,document]] archive)
                                  (archive.add module descriptor,document archive))
                                archive)
                    (\ try.monad map (dependency.load_order $.key))
                    (\ try.monad join)
                    promise\wrap)
     #let [purge (..full_purge pre_loaded_caches load_order)]
     _ (|> purge
           dictionary.entries
           (monad.map ! (..purge! system static)))
     loaded_caches (|> load_order
                       (list.filter (function (_ [module_name [module_id [descriptor document]]])
                                      (not (dictionary.key? purge module_name))))
                       (monad.map ! (function (_ [module_name [module_id descriptor,document]])
                                      (do !
                                        [[descriptor,document bundles] (..load_definitions system static module_id host_environment descriptor,document)]
                                        (wrap [[module_name descriptor,document]
                                               bundles])))))]
    (promise\wrap
     (do {! try.monad}
       [archive (monad.fold !
                            (function (_ [[module descriptor,document] _bundle] archive)
                              (archive.add module descriptor,document archive))
                            archive
                            loaded_caches)
        analysis_state (..analysis_state (get@ #static.host static) archive)]
       (wrap [archive
              analysis_state
              (list\fold (function (_ [_ [+analysers +synthesizers +generators +directives]]
                                      [analysers synthesizers generators directives])
                           [(dictionary.merge +analysers analysers)
                            (dictionary.merge +synthesizers synthesizers)
                            (dictionary.merge +generators generators)
                            (dictionary.merge +directives directives)])
                         ..empty_bundles
                         loaded_caches)])))))

(def: #export (thaw host_environment system static import contexts)
  (All [expression directive]
    (-> (generation.Host expression directive) (file.System Promise) Static Import (List Context)
        (Promise (Try [Archive .Lux Bundles]))))
  (do promise.monad
    [file (!.use (\ system file) (..general_descriptor system static))]
    (case file
      (#try.Success file)
      (do (try.with promise.monad)
        [binary (!.use (\ file content) [])
         archive (promise\wrap (archive.import ///.version binary))]
        (..load_every_reserved_module host_environment system static import contexts archive))
      
      (#try.Failure error)
      (wrap (#try.Success [archive.empty
                           (fresh_analysis_state (get@ #static.host static))
                           ..empty_bundles])))))
