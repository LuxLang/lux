(.module:
  [lux #*
   [abstract
    [monad (#+ do)]]
   [control
    ["<>" parser
     ["<b>" binary (#+ Parser)]]]
   [data
    ["." product]
    ["." text]
    [collection
     ["." list]
     ["." row (#+ Row) ("#@." functor fold)]
     ["." dictionary (#+ Dictionary)]]
    [format
     ["." binary (#+ Writer)]]]
   [type
    abstract]])

(type: #export ID Nat)

(type: Artifact
  {#id ID
   #name (Maybe Text)})

(abstract: #export Registry
  {}
  
  {#artifacts (Row Artifact)
   #resolver (Dictionary Text ID)}

  (def: #export empty
    Registry
    (:abstraction {#artifacts row.empty
                   #resolver (dictionary.new text.hash)}))

  (def: next
    (-> Registry ID)
    (|>> :representation (get@ #artifacts) row.size))

  (def: #export (resource registry)
    (-> Registry [ID Registry])
    (let [id (..next registry)]
      [id
       (|> registry
           :representation
           (update@ #artifacts (row.add {#id id
                                         #name #.None}))
           :abstraction)]))

  (def: #export (definition name registry)
    (-> Text Registry [ID Registry])
    (let [id (..next registry)]
      [id
       (|> registry
           :representation
           (update@ #artifacts (row.add {#id id
                                         #name (#.Some name)}))
           (update@ #resolver (dictionary.put name id))
           :abstraction)]))

  (def: #export (definitions registry)
    (-> Registry (List Text))
    (|> registry
        :representation
        (get@ #artifacts)
        row.to-list
        (list.search-all (get@ #name))))

  (def: #export (remember name registry)
    (-> Text Registry (Maybe ID))
    (|> (:representation registry)
        (get@ #resolver)
        (dictionary.get name)))

  (def: #export writer
    (Writer Registry)
    (let [writer|artifacts (binary.row/64 (binary.maybe binary.text))]
      (|>> :representation
           (get@ #artifacts)
           (row@map (get@ #name))
           writer|artifacts)))

  (def: #export parser
    (Parser Registry)
    (|> (<b>.row/64 (<b>.maybe <b>.text))
        (:: <>.monad map (row@fold (function (_ artifact registry)
                                     (product.right
                                      (case artifact
                                        #.None
                                        (..resource registry)
                                        
                                        (#.Some name)
                                        (..definition name registry))))
                                   ..empty))))
  )
