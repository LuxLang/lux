(;module:
  lux
  (lux (control monad)
       (data [char]
             [text]
             ["&" text/lexer #+ Lexer Monad<Lexer> "&/" Monad<Lexer>]
             text/format
             [number "Int/" Codec<Text,Int>]
             [product]
             (coll [list "" Fold<List> "List/" Monad<List>]))
       [macro #- run]
       (macro [code]
              ["s" syntax #+ syntax:])))

## [Utils]
(def: regex-char^
  (Lexer Text)
  (&;none-of "\\.|&()[]{}"))

(def: escaped-char^
  (Lexer Text)
  (do Monad<Lexer>
    [? (&;this? "\\")]
    (if ?
      &;any
      regex-char^)))

(def: (local^ state lexer)
  (All [a] (-> Text (Lexer a) (Lexer a)))
  (function [old-state]
    (case (lexer state)
      (#;Left error)
      (#;Left error)

      (#;Right [_ value])
      (#;Right [old-state value]))))

(def: #hidden (refine^ refinement^ base^)
  (All [a] (-> (Lexer a) (Lexer Text) (Lexer Text)))
  (do Monad<Lexer>
    [output base^
     _ (local^ output refinement^)]
    (wrap output)))

(def: #hidden word^
  (Lexer Text)
  (&;either &;alpha-num
            (&;one-of "_")))

(def: #hidden (copy reference)
  (-> Text (Lexer Text))
  (&;after (&;this reference) (&/wrap reference)))

(def: #hidden (join-text^ part^)
  (-> (Lexer (List Text)) (Lexer Text))
  (do Monad<Lexer>
    [parts part^]
    (wrap (text;join-with "" parts))))

(def: identifier-char^
  (Lexer Text)
  (&;none-of "[]{}()s\"#;<>"))

(def: identifier-part^
  (Lexer Text)
  (do Monad<Lexer>
    [head (refine^ (&;not &;digit)
                   identifier-char^)
     tail (&;some' identifier-char^)]
    (wrap (format head tail))))

(def: (identifier^ current-module)
  (-> Text (Lexer Ident))
  (do Monad<Lexer>
    []
    ($_ &;either
        (&;seq (wrap current-module) (&;after (&;this ";;") identifier-part^))
        (&;seq identifier-part^ (&;after (&;this ";") identifier-part^))
        (&;seq (wrap "lux") (&;after (&;this ";") identifier-part^))
        (&;seq (wrap "") identifier-part^))))

(def: (re-var^ current-module)
  (-> Text (Lexer Code))
  (do Monad<Lexer>
    [ident (&;enclosed ["\\@<" ">"] (identifier^ current-module))]
    (wrap (` (: (Lexer Text) (~ (code;symbol ident)))))))

(def: re-char-range^
  (Lexer Code)
  (do Monad<Lexer>
    [from (|> regex-char^ (:: @ map (|>. (text;nth +0) assume)))
     _ (&;this "-")
     to (|> regex-char^ (:: @ map (|>. (text;nth +0) assume)))]
    (wrap (` (&;char-range (~ (code;char from)) (~ (code;char to)))))))

(def: re-char^
  (Lexer Code)
  (do Monad<Lexer>
    [char escaped-char^]
    (wrap (` (;;copy (~ (code;text char)))))))

(def: re-char-options^
  (Lexer Code)
  (do Monad<Lexer>
    [options (&;many' escaped-char^)]
    (wrap (` (&;one-of (~ (code;text options)))))))

(def: re-user-class^'
  (Lexer Code)
  (do Monad<Lexer>
    [negate? (&;opt (&;this "^"))
     parts (&;many ($_ &;either
                       re-char-range^
                       re-char-options^))]
    (wrap (case negate?
            (#;Some _) (` (&;not ($_ &;either (~@ parts))))
            #;None     (` ($_ &;either (~@ parts)))))))

(def: re-user-class^
  (Lexer Code)
  (do Monad<Lexer>
    [_ (wrap [])
     init re-user-class^'
     rest (&;some (&;after (&;this "&&") (&;enclosed ["[" "]"] re-user-class^')))]
    (wrap (fold (function [refinement base]
                  (` (refine^ (~ refinement) (~ base))))
                init
                rest))))

(def: #hidden blank^
  (Lexer Text)
  (&;one-of " \t"))

(def: #hidden ascii^
  (Lexer Text)
  (&;char-range #"\u0000" #"\u007F"))

(def: #hidden control^
  (Lexer Text)
  (&;either (&;char-range #"\u0000" #"\u001F")
            (&;one-of "\u007F")))

(def: #hidden punct^
  (Lexer Text)
  (&;one-of "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"))

(def: #hidden graph^
  (Lexer Text)
  (&;either punct^ &;alpha-num))

(def: #hidden print^
  (Lexer Text)
  (&;either graph^
            (&;one-of "\u0020")))

(def: re-system-class^
  (Lexer Code)
  (do Monad<Lexer>
    []
    ($_ &;either
        (&;after (&;this ".") (wrap (` &;any)))
        (&;after (&;this "\\d") (wrap (` &;digit)))
        (&;after (&;this "\\D") (wrap (` (&;not &;digit))))
        (&;after (&;this "\\s") (wrap (` &;space)))
        (&;after (&;this "\\S") (wrap (` (&;not &;space))))
        (&;after (&;this "\\w") (wrap (` word^)))
        (&;after (&;this "\\W") (wrap (` (&;not word^))))

        (&;after (&;this "\\p{Lower}") (wrap (` &;lower)))
        (&;after (&;this "\\p{Upper}") (wrap (` &;upper)))
        (&;after (&;this "\\p{Alpha}") (wrap (` &;alpha)))
        (&;after (&;this "\\p{Digit}") (wrap (` &;digit)))
        (&;after (&;this "\\p{Alnum}") (wrap (` &;alpha-num)))
        (&;after (&;this "\\p{Space}") (wrap (` &;space)))
        (&;after (&;this "\\p{HexDigit}") (wrap (` &;hex-digit)))
        (&;after (&;this "\\p{OctDigit}") (wrap (` &;oct-digit)))
        (&;after (&;this "\\p{Blank}") (wrap (` blank^)))
        (&;after (&;this "\\p{ASCII}") (wrap (` ascii^)))
        (&;after (&;this "\\p{Contrl}") (wrap (` control^)))
        (&;after (&;this "\\p{Punct}") (wrap (` punct^)))
        (&;after (&;this "\\p{Graph}") (wrap (` graph^)))
        (&;after (&;this "\\p{Print}") (wrap (` print^)))
        )))

(def: re-class^
  (Lexer Code)
  (&;either re-system-class^
            (&;enclosed ["[" "]"] re-user-class^)))

(def: number^
  (Lexer Nat)
  (|> (&;many' &;digit)
      (&;codec number;Codec<Text,Int>)
      (&/map int-to-nat)))

(def: re-back-reference^
  (Lexer Code)
  (&;either (do Monad<Lexer>
              [_ (&;this "\\")
               id number^]
              (wrap (` (;;copy (~ (code;symbol ["" (Int/encode (nat-to-int id))]))))))
            (do Monad<Lexer>
              [_ (&;this "\\k<")
               captured-name identifier-part^
               _ (&;this ">")]
              (wrap (` (;;copy (~ (code;symbol ["" captured-name]))))))))

(def: (re-simple^ current-module)
  (-> Text (Lexer Code))
  ($_ &;either
      re-class^
      (re-var^ current-module)
      re-back-reference^
      re-char^
      ))

(def: (re-simple-quantified^ current-module)
  (-> Text (Lexer Code))
  (do Monad<Lexer>
    [base (re-simple^ current-module)
     quantifier (&;one-of "?*+")]
    (case quantifier
      "?"
      (wrap (` (&;default "" (~ base))))
      
      "*"
      (wrap (` (join-text^ (&;some (~ base)))))
      
      ## "+"
      _
      (wrap (` (join-text^ (&;many (~ base)))))
      )))

(def: (re-counted-quantified^ current-module)
  (-> Text (Lexer Code))
  (do Monad<Lexer>
    [base (re-simple^ current-module)]
    (&;enclosed ["{" "}"]
                ($_ &;either
                    (do @
                      [[from to] (&;seq number^ (&;after (&;this ",") number^))]
                      (wrap (` (join-text^ (&;between (~ (code;nat from))
                                                      (~ (code;nat to))
                                                      (~ base))))))
                    (do @
                      [limit (&;after (&;this ",") number^)]
                      (wrap (` (join-text^ (&;at-most (~ (code;nat limit)) (~ base))))))
                    (do @
                      [limit (&;before (&;this ",") number^)]
                      (wrap (` (join-text^ (&;at-least (~ (code;nat limit)) (~ base))))))
                    (do @
                      [limit number^]
                      (wrap (` (join-text^ (&;exactly (~ (code;nat limit)) (~ base))))))))))

(def: (re-quantified^ current-module)
  (-> Text (Lexer Code))
  (&;either (re-simple-quantified^ current-module)
            (re-counted-quantified^ current-module)))

(def: (re-complex^ current-module)
  (-> Text (Lexer Code))
  ($_ &;either
      (re-quantified^ current-module)
      (re-simple^ current-module)))

(def: #hidden _Text/append_
  (-> Text Text Text)
  (:: text;Monoid<Text> append))

(type: Re-Group
  #Non-Capturing
  (#Capturing [(Maybe Text) Nat]))

(def: (re-sequential^ capturing? re-scoped^ current-module)
  (-> Bool
      (-> Text (Lexer [Re-Group Code]))
      Text
      (Lexer [Nat Code]))
  (do Monad<Lexer>
    [parts (&;many (&;alt (re-complex^ current-module)
                          (re-scoped^ current-module)))
     #let [g!total (code;symbol ["" "0total"])
           g!temp (code;symbol ["" "0temp"])
           [_ names steps] (fold (: (-> (Either Code [Re-Group Code])
                                        [Int (List Code) (List (List Code))]
                                        [Int (List Code) (List (List Code))])
                                    (function [part [idx names steps]]
                                      (case part
                                        (^or (#;Left complex) (#;Right [#Non-Capturing complex]))
                                        [idx
                                         names
                                         (list& (list g!temp complex
                                                      (' #let) (` [(~ g!total) (_Text/append_ (~ g!total) (~ g!temp))]))
                                                steps)]
                                        
                                        (#;Right [(#Capturing [?name num-captures]) scoped])
                                        (let [[idx! name!] (case ?name
                                                             (#;Some _name)
                                                             [idx (code;symbol ["" _name])]

                                                             #;None
                                                             [(i.inc idx) (code;symbol ["" (Int/encode idx)])])
                                              access (if (n.> +0 num-captures)
                                                       (` (product;left (~ name!)))
                                                       name!)]
                                          [idx!
                                           (list& name! names)
                                           (list& (list name! scoped
                                                        (' #let) (` [(~ g!total) (_Text/append_ (~ g!total) (~ access))]))
                                                  steps)])
                                        )))
                                 [0
                                  (: (List Code) (list))
                                  (: (List (List Code)) (list))]
                                 parts)]]
    (wrap [(if capturing?
             (list;size names)
             +0)
           (` (do Monad<Lexer>
                [(~ (' #let)) [(~ g!total) ""]
                 (~@ (|> steps list;reverse List/join))]
                ((~ (' wrap)) [(~ g!total) (~@ (list;reverse names))])))])
    ))

(def: #hidden (unflatten^ lexer)
  (-> (Lexer Text) (Lexer [Text Unit]))
  (&;seq lexer (:: Monad<Lexer> wrap [])))

(def: #hidden (|||^ left right)
  (All [l r] (-> (Lexer [Text l]) (Lexer [Text r]) (Lexer [Text (| l r)])))
  (function [input]
    (case (left input)
      (#;Right [input' [lt lv]])
      (#;Right [input' [lt (+0 lv)]])

      (#;Left _)
      (case (right input)
        (#;Right [input' [rt rv]])
        (#;Right [input' [rt (+1 rv)]])

        (#;Left error)
        (#;Left error)))))

(def: #hidden (|||_^ left right)
  (All [l r] (-> (Lexer [Text l]) (Lexer [Text r]) (Lexer Text)))
  (function [input]
    (case (left input)
      (#;Right [input' [lt lv]])
      (#;Right [input' lt])

      (#;Left _)
      (case (right input)
        (#;Right [input' [rt rv]])
        (#;Right [input' rt])

        (#;Left error)
        (#;Left error)))))

(def: (prep-alternative [num-captures alt])
  (-> [Nat Code] Code)
  (if (n.> +0 num-captures)
    alt
    (` (unflatten^ (~ alt)))))

(def: (re-alternative^ capturing? re-scoped^ current-module)
  (-> Bool
      (-> Text (Lexer [Re-Group Code]))
      Text
      (Lexer [Nat Code]))
  (do Monad<Lexer>
    [#let [sub^ (re-sequential^ capturing? re-scoped^ current-module)]
     head sub^
     tail (&;some (&;after (&;this "|") sub^))
     #let [g!op (if capturing?
                  (` |||^)
                  (` |||_^))]]
    (if (list;empty? tail)
      (wrap head)
      (wrap [(fold n.max (product;left head) (List/map product;left tail))
             (` ($_ (~ g!op) (~ (prep-alternative head)) (~@ (List/map prep-alternative tail))))]))))

(def: (re-scoped^ current-module)
  (-> Text (Lexer [Re-Group Code]))
  ($_ &;either
      (do Monad<Lexer>
        [_ (&;this "(?:")
         [_ scoped] (re-alternative^ false re-scoped^ current-module)
         _ (&;this ")")]
        (wrap [#Non-Capturing scoped]))
      (do Monad<Lexer>
        [complex (re-complex^ current-module)]
        (wrap [#Non-Capturing complex]))
      (do Monad<Lexer>
        [_ (&;this "(?<")
         captured-name identifier-part^
         _ (&;this ">")
         [num-captures pattern] (re-alternative^ true re-scoped^ current-module)
         _ (&;this ")")]
        (wrap [(#Capturing [(#;Some captured-name) num-captures]) pattern]))
      (do Monad<Lexer>
        [_ (&;this "(")
         [num-captures pattern] (re-alternative^ true re-scoped^ current-module)
         _ (&;this ")")]
        (wrap [(#Capturing [#;None num-captures]) pattern]))))

(def: (regex^ current-module)
  (-> Text (Lexer Code))
  (:: Monad<Lexer> map product;right (re-alternative^ true re-scoped^ current-module)))

## [Syntax]
(syntax: #export (regex [pattern s;text])
  {#;doc (doc "Create lexers using regular-expression syntax."
              "For example:"
              
              "Literals"
              (regex "a")
              
              "Wildcards"
              (regex ".")
              
              "Escaping"
              (regex "\\.")
              
              "Character classes"
              (regex "\\d")
              (regex "\\p{Lower}")
              (regex "[abc]")
              (regex "[a-z]")
              (regex "[a-zA-Z]")
              (regex "[a-z&&[def]]")
              
              "Negation"
              (regex "[^abc]")
              (regex "[^a-z]")
              (regex "[^a-zA-Z]")
              (regex "[a-z&&[^bc]]")
              (regex "[a-z&&[^m-p]]")
              
              "Combinations"
              (regex "aa")
              (regex "a?")
              (regex "a*")
              (regex "a+")
              
              "Specific amounts"
              (regex "a{2}")
              
              "At least"
              (regex "a{1,}")
              
              "At most"
              (regex "a{,1}")
              
              "Between"
              (regex "a{1,2}")
              
              "Groups"
              (regex "a(.)c")
              (regex "a(b+)c")
              (regex "(\\d{3})-(\\d{3})-(\\d{4})")
              (regex "(\\d{3})-(?:\\d{3})-(\\d{4})")
              (regex "(?<code>\\d{3})-\\k<code>-(\\d{4})")
              (regex "(?<code>\\d{3})-\\k<code>-(\\d{4})-\\0")
              (regex "(\\d{3})-((\\d{3})-(\\d{4}))")
              
              "Alternation"
              (regex "a|b")
              (regex "a(.)(.)|b(.)(.)")
              )}
  (do @
    [current-module macro;current-module-name]
    (case (|> (regex^ current-module)
              (&;before &;end)
              (&;run pattern))
      (#;Left error)
      (macro;fail (format "Error while parsing regular-expression:\n"
                          error))

      (#;Right regex)
      (wrap (list regex))
      )))

(syntax: #export (^regex [[pattern bindings] (s;form (s;seq s;text (s;opt s;any)))]
                         body
                         [branches (s;many s;any)])
  {#;doc (doc "Allows you to test text against regular expressions."
              (case some-text
                (^regex "(\\d{3})-(\\d{3})-(\\d{4})"
                        [_ country-code area-code place-code])
                do-some-thing-when-number

                (^regex "\\w+")
                do-some-thing-when-word

                _
                do-something-else))}
  (do @
    [g!temp (macro;gensym "temp")]
    (wrap (list& (` (^multi (~ g!temp)
                            [(&;run (~ g!temp) (regex (~ (code;text pattern))))
                             (#;Right (~ (default g!temp
                                           bindings)))]))
                 body
                 branches))))
