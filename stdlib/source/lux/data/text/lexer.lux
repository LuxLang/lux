(;module:
  [lux #- not]
  (lux (control functor
                applicative
                monad
                codec
                ["p" parser])
       (data [text "T/" Eq<Text>]
             text/format
             [product]
             [char "C/" Order<Char> Codec<Text,Char>]
             maybe
             ["R" result]
             (coll [list "L/" Functor<List>]))))

(type: #export Lexer
  (p;Parser Text))

(def: #export (run input lexer)
  (All [a] (-> Text (Lexer a) (R;Result a)))
  (case (lexer input)
    (#R;Error msg)
    (#R;Error msg)
    
    (#R;Success [input' output])
    (if (T/= "" input')
      (#R;Success output)
      (#R;Error (format "Remaining lexer input: " input')))
    ))

(def: #export any
  {#;doc "Just returns the next character without applying any logic."}
  (Lexer Text)
  (function [input]
    (case [(text;nth +0 input) (text;split +1 input)]
      [(#;Some output) (#;Some [_ input'])]
      (#R;Success [input' (char;as-text output)])

      _
      (#R;Error "Cannot parse character from empty text."))
    ))

(def: #export (not p)
  {#;doc "Produce a character if the lexer fails."}
  (All [a] (-> (Lexer a) (Lexer Text)))
  (function [input]
    (case (p input)
      (#R;Error msg)
      (any input)
      
      _
      (#R;Error "Expected to fail; yet succeeded."))))

(def: #export (this reference)
  {#;doc "Lex a text if it matches the given sample."}
  (-> Text (Lexer Unit))
  (function [input]
    (if (text;starts-with? reference input)
      (case (text;split (text;size reference) input)
        #;None              (#R;Error "")
        (#;Some [_ input']) (#R;Success [input' []]))
      (#R;Error (format "Invalid match: " (text;encode reference) " @ " (text;encode input))))))

(def: #export (this? reference)
  {#;doc "Lex a text if it matches the given sample."}
  (-> Text (Lexer Bool))
  (function [input]
    (if (text;starts-with? reference input)
      (case (text;split (text;size reference) input)
        #;None              (#R;Success [input false])
        (#;Some [_ input']) (#R;Success [input' true]))
      (#R;Success [input false]))
    ))

(def: #export end
  {#;doc "Ensure the lexer's input is empty."}
  (Lexer Unit)
  (function [input]
    (case input
      "" (#R;Success [input []])
      _  (#R;Error (format "The text input has not been fully consumed @ " (text;encode input)))
      )))

(def: #export peek
  {#;doc "Lex the next character (without consuming it from the input)."}
  (Lexer Text)
  (function [input]
    (case (text;nth +0 input)
      (#;Some output)
      (#R;Success [input (char;as-text output)])

      _
      (#R;Error "Cannot peek character from empty text."))
    ))

(def: #export get-input
  {#;doc "Get all of the remaining input (without consuming it)."}
  (Lexer Text)
  (function [input]
    (#R;Success [input input])))

(def: #export (char-range bottom top)
  {#;doc "Only lex characters within a range."}
  (-> Char Char (Lexer Text))
  (do p;Monad<Parser>
    [input get-input
     char any
     #let [char' (|> char (text;nth +0) assume)]
     _ (p;assert (format "Character is not within range: " (C/encode bottom) "-" (C/encode top) " @ " (text;encode input))
                 (and (C/>= bottom char')
                      (C/<= top char')))]
    (wrap char)))

(do-template [<name> <bottom> <top> <desc>]
  [(def: #export <name>
     {#;doc (#;TextA (format "Only lex " <desc> " characters."))}
     (Lexer Text)
     (char-range <bottom> <top>))]

  [upper     #"A" #"Z" "uppercase"]
  [lower     #"a" #"z" "lowercase"]
  [digit     #"0" #"9" "decimal"]
  [oct-digit #"0" #"7" "octal"]
  )

(def: #export alpha
  {#;doc "Only lex alphabetic characters."}
  (Lexer Text)
  (p;either lower upper))

(def: #export alpha-num
  {#;doc "Only lex alphanumeric characters."}
  (Lexer Text)
  (p;either alpha digit))

(def: #export hex-digit
  {#;doc "Only lex hexadecimal digits."}
  (Lexer Text)
  ($_ p;either
      digit
      (char-range #"a" #"f")
      (char-range #"A" #"F")))

(def: #export (one-of options)
  {#;doc "Only lex characters that are part of a piece of text."}
  (-> Text (Lexer Text))
  (function [input]
    (case (text;split +1 input)
      (#;Some [init input'])
      (if (text;contains? init options)
        (case (text;nth +0 init)
          (#;Some output)
          (#R;Success [input' (char;as-text output)])

          _
          (#R;Error ""))
        (#R;Error (format "Character (" init ") is not one of: " options " @ " (text;encode input))))

      _
      (#R;Error "Cannot parse character from empty text."))))

(def: #export (none-of options)
  {#;doc "Only lex characters that are not part of a piece of text."}
  (-> Text (Lexer Text))
  (function [input]
    (case (text;split +1 input)
      (#;Some [init input'])
      (if (;not (text;contains? init options))
        (case (text;nth +0 init)
          (#;Some output)
          (#R;Success [input' (char;as-text output)])

          _
          (#R;Error ""))
        (#R;Error (format "Character (" init ") is one of: " options " @ " (text;encode input))))

      _
      (#R;Error "Cannot parse character from empty text."))))

(def: #export (satisfies p)
  {#;doc "Only lex characters that satisfy a predicate."}
  (-> (-> Char Bool) (Lexer Text))
  (function [input]
    (case (: (Maybe [Text Char])
             (do Monad<Maybe>
               [[init input'] (text;split +1 input)
                output (text;nth +0 init)]
               (wrap [input' output])))
      (#;Some [input' output])
      (if (p output)
        (#R;Success [input' (char;as-text output)])
        (#R;Error (format "Character does not satisfy predicate: " (text;encode input))))

      _
      (#R;Error "Cannot parse character from empty text."))))

(def: #export space
  {#;doc "Only lex white-space."}
  (Lexer Text)
  (satisfies char;space?))

(def: #export (seq left right)
  (-> (Lexer Text) (Lexer Text) (Lexer Text))
  (do p;Monad<Parser>
    [=left left
     =right right]
    (wrap (format =left =right))))

(do-template [<name> <base> <doc>]
  [(def: #export (<name> p)
     {#;doc <doc>}
     (-> (Lexer Text) (Lexer Text))
     (do p;Monad<Parser>
       []
       (|> p <base> (:: @ map text;concat))))]

  [some p;some "Lex some characters as a single continuous text."]
  [many p;many "Lex many characters as a single continuous text."]
  )

(do-template [<name> <base> <doc>]
  [(def: #export (<name> n p)
     {#;doc <doc>}
     (-> Nat (Lexer Text) (Lexer Text))
     (do p;Monad<Parser>
       []
       (|> p (<base> n) (:: @ map text;concat))))]

  [exactly  p;exactly  "Lex exactly N characters."]
  [at-most  p;at-most  "Lex at most N characters."]
  [at-least p;at-least "Lex at least N characters."]
  )

(def: #export (between from to p)
  {#;doc "Lex between N and M characters."}
  (-> Nat Nat (Lexer Text) (Lexer Text))
  (|> p (p;between from to) (:: p;Monad<Parser> map text;concat)))

(def: #export end?
  {#;doc "Ask if the lexer's input is empty."}
  (Lexer Bool)
  (function [input]
    (#R;Success [input (text;empty? input)])))

(def: #export (codec codec lexer)
  {#;doc "Lex a token by means of a codec."}
  (All [a] (-> (Codec Text a) (Lexer Text) (Lexer a)))
  (function [input]
    (case (lexer input)
      (#R;Error error)
      (#R;Error error)

      (#R;Success [input' to-decode])
      (case (:: codec decode to-decode)
        (#R;Error error)
        (#R;Error error)
        
        (#R;Success value)
        (#R;Success [input' value])))))

(def: #export (enclosed [start end] lexer)
  (All [a] (-> [Text Text] (Lexer a) (Lexer a)))
  (|> lexer
      (p;before (this end))
      (p;after (this start))))

(def: #export (local local-input lexer)
  {#;doc "Run a lexer with the given input, instead of the real one."}
  (All [a] (-> Text (Lexer a) (Lexer a)))
  (function [real-input]
    (case (p;run local-input lexer)
      (#R;Error error)
      (#R;Error error)

      (#R;Success [unconsumed value])
      (if (T/= "" unconsumed)
        (#R;Success [real-input value])
        (#R;Error (format "Unconsumed input: " unconsumed))))))
