(.module:
  [lux #*
   [control
    [monad (#+ do Monad)]
    ["p" parser]]
   [data
    ["." bit]
    ["." name]
    [number
     ["." nat]
     ["." int]
     ["." rev]
     ["." frac]]
    ["." text]
    [format
     ["." xml]
     ["." json]]
    [collection
     ["." list ("#/." monad)]]]
   [time
    ["." instant]
    ["." duration]
    ["." date]]
   [math
    ["." modular]]
   ["." macro
    ["." code]
    ["s" syntax (#+ syntax: Syntax)]]
   ["." type]])

## [Syntax]
(syntax: #export (format {fragments (p.many s.any)})
  {#.doc (doc "Text interpolation."
              (format "Static part " (%t static) " does not match URI: " uri))}
  (wrap (list (` ($_ "lux text concat" (~+ fragments))))))

## [Formats]
(type: #export (Format a)
  {#.doc "A way to produce readable text from values."}
  (-> a Text))

(do-template [<name> <type> <formatter>]
  [(def: #export <name>
     (Format <type>)
     <formatter>)]

  [%b        Bit               (:: bit.codec encode)]
  [%n        Nat               (:: nat.decimal encode)]
  [%i        Int               (:: int.decimal encode)]
  [%r        Rev               (:: rev.decimal encode)]
  [%f        Frac              (:: frac.decimal encode)]
  [%t        Text              text.encode]
  [%name     Name              (:: name.codec encode)]
  [%code     Code              code.to-text]
  [%type     Type              type.to-text]
  [%bin      Nat               (:: nat.binary encode)]
  [%oct      Nat               (:: nat.octal encode)]
  [%hex      Nat               (:: nat.hex encode)]
  [%xml      xml.XML           (:: xml.codec encode)]
  [%json     json.JSON         (:: json.codec encode)]
  [%instant  instant.Instant   instant.to-text]
  [%date     date.Date         (:: date.codec encode)]
  )

(def: #export %duration
  (Format duration.Duration)
  duration.encode)

(def: #export (%cursor [file line column])
  (Format Cursor)
  (|> (list (%t file) (%n line) (%n column))
      (text.join-with ", ")
      (text.enclose ["[" "]"])))

(def: #export (%mod modular)
  (All [m] (Format (modular.Mod m)))
  (let [[_ modulus] (modular.un-mod modular)]
    (:: (modular.codec modulus) encode modular)))

(def: #export (%list formatter)
  (All [a] (-> (Format a) (Format (List a))))
  (function (_ values)
    (case values
      #.Nil
      "(list)"

      _
      (format "(list " (text.join-with " " (list/map formatter values)) ")"))))
