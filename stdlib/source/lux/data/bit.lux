(.module: [lux #- and or not])

(def: #export width Nat +64)

## [Values]
(do-template [<short-name> <op> <doc> <type>]
  [(def: #export (<short-name> param subject)
     {#.doc <doc>}
     (-> Nat <type> <type>)
     (<op> subject param))]

  [and "lux bit and" "Bitwise and." Nat]
  [or "lux bit or" "Bitwise or." Nat]
  [xor "lux bit xor" "Bitwise xor." Nat]
  [left-shift "lux bit left-shift" "Bitwise left-shift." Nat]
  [logical-right-shift "lux bit logical-right-shift" "Unsigned bitwise logical-right-shift." Nat]
  [arithmetic-right-shift "lux bit arithmetic-right-shift" "Signed bitwise arithmetic-right-shift." Int]
  )

(def: #export (count subject)
  {#.doc "Count the number of 1s in a bit-map."}
  (-> Nat Nat)
  ("lux bit count" subject))

(def: #export not
  {#.doc "Bitwise negation."}
  (-> Nat Nat)
  (let [mask (int-to-nat -1)]
    (xor mask)))

(def: #export (clear idx input)
  {#.doc "Clear bit at given index."}
  (-> Nat Nat Nat)
  (..and (..not (left-shift idx +1))
         input))

(do-template [<name> <op> <doc>]
  [(def: #export (<name> idx input)
     {#.doc <doc>}
     (-> Nat Nat Nat)
     (<op> (left-shift idx +1) input))]

  [set  ..or  "Set bit at given index."]
  [flip ..xor "Flip bit at given index."]
  )

(def: #export (set? idx input)
  (-> Nat Nat Bool)
  (|> input (..and (left-shift idx +1)) (n/= +0) .not))

(do-template [<name> <main> <comp>]
  [(def: #export (<name> distance input)
     (-> Nat Nat Nat)
     (..or (<main> distance input)
           (<comp> (n/- (n/% width distance)
                        width)
                   input)))]

  [rotate-left  left-shift          logical-right-shift]
  [rotate-right logical-right-shift left-shift]
  )

(def: #export (region-mask size offset)
  (-> Nat Nat Nat)
  (let [pattern (|> +1 (left-shift size) n/dec)]
    (left-shift offset pattern)))
