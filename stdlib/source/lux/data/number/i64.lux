(.module:
  [lux (#- and or not false true)
   [abstract
    [equivalence (#+ Equivalence)]
    [hash (#+ Hash)]
    [monoid (#+ Monoid)]]
   [control
    ["." try]]
   [data
    [number
     ["n" nat]]]])

(def: #export bits_per_byte
  8)

(def: #export bytes_per_i64
  8)

(def: #export width
  Nat
  (n.* ..bits_per_byte
       ..bytes_per_i64))

(template [<parameter_type> <name> <op> <doc>]
  [(def: #export (<name> parameter subject)
     {#.doc <doc>}
     (All [s] (-> <parameter_type> (I64 s) (I64 s)))
     (<op> parameter subject))]

  [(I64 Any) or                     "lux i64 or"                     "Bitwise or."]
  [(I64 Any) xor                    "lux i64 xor"                    "Bitwise xor."]
  [(I64 Any) and                    "lux i64 and"                    "Bitwise and."]
  
  [Nat       left_shift             "lux i64 left-shift"             "Bitwise left-shift."]
  [Nat       logic_right_shift      "lux i64 logical-right-shift"    "Unsigned bitwise logic-right-shift."]
  [Nat       arithmetic_right_shift "lux i64 arithmetic-right-shift" "Signed bitwise arithmetic-right-shift."]
  )

(def: #export not
  {#.doc "Bitwise negation."}
  (All [s] (-> (I64 s) (I64 s)))
  (xor (.i64 (dec 0))))

(type: #export Mask
  I64)

(def: #export false
  Mask
  (.i64 0))

(def: #export true
  Mask
  (..not ..false))

(def: #export (mask amount_of_bits)
  (-> Nat Mask)
  (case amount_of_bits
    0 ..false
    bits (case (n.% ..width bits)
           0 ..true
           bits (|> 1 .i64 (..left_shift (n.% ..width bits)) .dec))))

(def: #export (bit position)
  (-> Nat Mask)
  (|> 1 .i64 (..left_shift (n.% ..width position))))

(def: #export sign
  Mask
  (..bit (dec ..width)))

(def: (add_shift shift value)
  (-> Nat Nat Nat)
  (|> value (logic_right_shift shift) (n.+ value)))

(def: #export (count subject)
  {#.doc "Count the number of 1s in a bit-map."}
  (-> (I64 Any) Nat)
  (let [count' (n.- (|> subject (logic_right_shift 1) (..and 6148914691236517205) i64)
                    (i64 subject))]
    (|> count'
        (logic_right_shift 2) (..and 3689348814741910323) (n.+ (..and 3689348814741910323 count'))
        (add_shift 4) (..and 1085102592571150095)
        (add_shift 8)
        (add_shift 16)
        (add_shift 32)
        (..and 127))))

(def: #export (clear idx input)
  {#.doc "Clear bit at given index."}
  (All [s] (-> Nat (I64 s) (I64 s)))
  (|> idx ..bit ..not (..and input)))

(template [<name> <op> <doc>]
  [(def: #export (<name> idx input)
     {#.doc <doc>}
     (All [s] (-> Nat (I64 s) (I64 s)))
     (|> idx ..bit (<op> input)))]

  [set  ..or  "Set bit at given index."]
  [flip ..xor "Flip bit at given index."]
  )

(def: #export (set? idx input)
  (-> Nat (I64 Any) Bit)
  (|> input (:coerce I64) (..and (..bit idx)) (n.= 0) .not))

(def: #export (clear? idx input)
  (-> Nat (I64 Any) Bit)
  (.not (..set? idx input)))

(template [<name> <main> <comp>]
  [(def: #export (<name> distance input)
     (All [s] (-> Nat (I64 s) (I64 s)))
     (let [backwards_distance (n.- (n.% width distance) width)]
       (|> input
           (<comp> backwards_distance)
           (..or (<main> distance input)))))]

  [rotate_left  left_shift        logic_right_shift]
  [rotate_right logic_right_shift left_shift]
  )

(def: #export (region size offset)
  (-> Nat Nat Mask)
  (..left_shift offset (..mask size)))

(structure: #export equivalence
  (All [a] (Equivalence (I64 a)))

  (def: (= reference sample)
    ("lux i64 =" reference sample)))

(structure: #export hash
  (All [a] (Hash (I64 a)))

  (def: &equivalence ..equivalence)

  (def: hash .nat))

(template [<monoid> <identity> <compose>]
  [(structure: #export <monoid>
     (All [a] (Monoid (I64 a)))

     (def: identity <identity>)
     (def: compose <compose>))]

  [disjunction ..false ..or]
  [conjunction ..true ..and]
  )

(template [<swap> <size> <pattern>]
  [(def: <swap>
     (All [a] (-> (I64 a) (I64 a)))
     (let [high (try.assume (\ n.binary decode <pattern>))
           low (..rotate_right <size> high)]
       (function (_ value)
         (..or (..logic_right_shift <size> (..and high value))
               (..left_shift <size> (..and low value))))))]

  [swap/32 32 "1111111111111111111111111111111100000000000000000000000000000000"]
  [swap/16 16 "1111111111111111000000000000000011111111111111110000000000000000"]
  [swap/08 08 "1111111100000000111111110000000011111111000000001111111100000000"]
  [swap/04 04 "1111000011110000111100001111000011110000111100001111000011110000"]
  [swap/02 02 "1100110011001100110011001100110011001100110011001100110011001100"]
  [swap/01 01 "1010101010101010101010101010101010101010101010101010101010101010"]
  )

(def: #export reverse
  (All [a] (-> (I64 a) (I64 a)))
  (|>> ..swap/32
       ..swap/16
       ..swap/08
       ..swap/04
       ..swap/02
       ..swap/01))

(signature: #export (Sub size)
  (: (Equivalence (I64 size))
     &equivalence)
  (: Nat
     width)
  (: (-> I64 (I64 size))
     narrow)
  (: (-> (I64 size) I64)
     widen))

(def: #export (sub width)
  (Ex [size] (-> Nat (Maybe (Sub size))))
  (if (.and (n.> 0 width)
            (n.< ..width width))
    (let [sign_shift (n.- width ..width)
          sign (..bit (dec width))
          mantissa (..mask (dec width))
          co_mantissa (..xor (.i64 -1) mantissa)]
      (#.Some (: Sub
                 (structure
                  (def: &equivalence ..equivalence)
                  (def: width width)
                  (def: (narrow value)
                    (..or (|> value (..and ..sign) (..logic_right_shift sign_shift))
                          (|> value (..and mantissa))))
                  (def: (widen value)
                    (.i64 (case (.nat (..and sign value))
                            0 value
                            _ (..or co_mantissa value))))))))
    #.None))
