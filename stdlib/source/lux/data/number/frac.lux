(.module:
  [lux (#- nat int rev)
   [abstract
    [hash (#+ Hash)]
    [monoid (#+ Monoid)]
    [equivalence (#+ Equivalence)]
    [codec (#+ Codec)]
    [predicate (#+ Predicate)]
    [order (#+ Order)]
    [monad (#+ do)]]
   [control
    ["." try (#+ Try)]]
   [data
    ["." maybe]
    ["." text]]
   ["." math]]
  ["." // #_
   ["#." i64]
   ["#." nat]
   ["#." int]
   ["#." rev]])

(def: #export (= reference sample)
  {#.doc "Frac(tion) equivalence."}
  (-> Frac Frac Bit)
  ("lux f64 =" reference sample))

(def: #export (< reference sample)
  {#.doc "Frac(tion) less-than."}
  (-> Frac Frac Bit)
  ("lux f64 <" reference sample))

(def: #export (<= reference sample)
  {#.doc "Frac(tion) less-than or equal."}
  (-> Frac Frac Bit)
  (or ("lux f64 <" reference sample)
      ("lux f64 =" reference sample)))

(def: #export (> reference sample)
  {#.doc "Frac(tion) greater-than."}
  (-> Frac Frac Bit)
  ("lux f64 <" sample reference))

(def: #export (>= reference sample)
  {#.doc "Frac(tion) greater-than or equal."}
  (-> Frac Frac Bit)
  (or ("lux f64 <" sample reference)
      ("lux f64 =" sample reference)))

(template [<comparison> <name>]
  [(def: #export <name>
     (Predicate Frac)
     (<comparison> +0.0))]

  [..> positive?]
  [..< negative?]
  [..= zero?]
  )

(template [<name> <op> <doc>]
  [(def: #export (<name> param subject)
     {#.doc <doc>}
     (-> Frac Frac Frac)
     (<op> param subject))]

  [+ "lux f64 +" "Frac(tion) addition."]
  [- "lux f64 -" "Frac(tion) substraction."]
  [* "lux f64 *" "Frac(tion) multiplication."]
  [/ "lux f64 /" "Frac(tion) division."]
  [% "lux f64 %" "Frac(tion) remainder."]
  )

(def: #export (/% param subject)
  (-> Frac Frac [Frac Frac])
  [(../ param subject)
   (..% param subject)])

(def: #export negate
  (-> Frac Frac)
  (..* -1.0))

(def: #export (abs x)
  (-> Frac Frac)
  (if (..< +0.0 x)
    (..* -1.0 x)
    x))

(def: #export (signum x)
  (-> Frac Frac)
  (cond (..= +0.0 x) +0.0
        (..< +0.0 x) -1.0
        ## else
        +1.0))

(def: min-exponent -1022)
(def: max-exponent (//int.frac +1023))

(template [<name> <test> <doc>]
  [(def: #export (<name> left right)
     {#.doc <doc>}
     (-> Frac Frac Frac)
     (if (<test> right left)
       left
       right))]

  [min ..< "Frac(tion) minimum."]
  [max ..> "Frac(tion) minimum."]
  )

(def: #export nat
  (-> Frac Nat)
  (|>> "lux f64 i64" .nat))

(def: #export int
  (-> Frac Int)
  (|>> "lux f64 i64"))

(def: mantissa-size Nat 52)
(def: exponent-size Nat 11)

(def: frac-denominator
  (|> -1
      ("lux i64 logical-right-shift" ..exponent-size)
      "lux i64 f64"))

(def: #export rev
  (-> Frac Rev)
  (|>> ..abs
       (..% +1.0)
       (..* ..frac-denominator)
       "lux f64 i64"
       ("lux i64 left-shift" ..exponent-size)))

(structure: #export equivalence
  (Equivalence Frac)
  
  (def: = ..=))

(structure: #export order
  (Order Frac)
  
  (def: &equivalence ..equivalence)
  (def: < ..<))

(def: #export smallest
  Frac
  (math.pow (//int.frac (//int.- (.int ..mantissa-size) ..min-exponent))
            +2.0))

(def: #export biggest
  Frac
  (let [f2^-52 (math.pow (//nat.frac (//nat.- ..mantissa-size 0)) +2.0)
        f2^+1023 (math.pow ..max-exponent +2.0)]
    (|> +2.0
        (..- f2^-52)
        (..* f2^+1023))))

(template [<name> <compose> <identity>]
  [(structure: #export <name>
     (Monoid Frac)
     
     (def: identity <identity>)
     (def: compose <compose>))]

  [addition       ..+   +0.0]
  [multiplication ..*   +1.0]
  [minimum        ..min ..biggest]
  [maximum        ..max (..* -1.0 ..biggest)]
  )

(template [<name> <numerator> <doc>]
  [(def: #export <name>
     {#.doc <doc>}
     Frac
     (../ +0.0 <numerator>))]

  [not-a-number      +0.0 "Not a number."]
  [positive-infinity +1.0 "Positive infinity."]
  [negative-infinity -1.0 "Negative infinity."]
  )

(def: #export (not-a-number? number)
  {#.doc "Tests whether a frac is actually not-a-number."}
  (-> Frac Bit)
  (not (..= number number)))

(def: #export (number? value)
  (-> Frac Bit)
  (not (or (..not-a-number? value)
           (..= ..positive-infinity value)
           (..= ..negative-infinity value))))

(structure: #export decimal
  (Codec Text Frac)
  
  (def: (encode x)
    (case x
      -0.0 (let [output ("lux f64 encode" x)]
             (if (text.starts-with? "-" output)
               output
               ("lux text concat" "+" output)))
      _ (if (..< +0.0 x)
          ("lux f64 encode" x)
          ("lux text concat" "+" ("lux f64 encode" x)))))

  (def: (decode input)
    (case ("lux f64 decode" [input])
      (#.Some value)
      (#try.Success value)

      #.None
      (#try.Failure "Could not decode Frac"))))

(def: log/2
  (-> Frac Frac)
  (|>> math.log
       (../ (math.log +2.0))))

(def: double-bias Nat 1023)

(def: exponent-mask (//i64.mask ..exponent-size))

(def: exponent-offset ..mantissa-size)
(def: sign-offset (//nat.+ ..exponent-size ..exponent-offset))

(template [<cast> <hex> <name>]
  [(def: <name> (|> <hex> (\ //nat.hex decode) try.assume <cast>))]

  [.i64 "FFF8000000000000" not-a-number-bits]
  [.i64 "7FF0000000000000" positive-infinity-bits]
  [.i64 "FFF0000000000000" negative-infinity-bits]
  [.i64 "0000000000000000" positive-zero-bits]
  [.i64 "8000000000000000" negative-zero-bits]
  [.nat "7FF"              special-exponent-bits]
  )

(def: smallest-exponent
  (..log/2 ..smallest))

(def: #export (to-bits input)
  (-> Frac I64)
  (.i64 (cond (..not-a-number? input)
              ..not-a-number-bits

              (..= positive-infinity input)
              ..positive-infinity-bits

              (..= negative-infinity input)
              ..negative-infinity-bits

              (..= +0.0 input)
              (let [reciprocal (../ input +1.0)]
                (if (..= positive-infinity reciprocal)
                  ## Positive zero
                  ..positive-zero-bits
                  ## Negative zero
                  ..negative-zero-bits))

              ## else
              (let [sign-bit (if (..< -0.0 input)
                               1
                               0)
                    input (..abs input)
                    exponent (|> input
                                 ..log/2
                                 math.floor
                                 (..min ..max-exponent))
                    min-gap (..- (//int.frac ..min-exponent) exponent)
                    power (|> (//nat.frac ..mantissa-size)
                              (..+ (..min +0.0 min-gap))
                              (..- exponent))
                    max-gap (..- ..max-exponent power)
                    mantissa (|> input
                                 (..* (math.pow (..min ..max-exponent power) +2.0))
                                 (..* (if (..> +0.0 max-gap)
                                        (math.pow max-gap +2.0)
                                        +1.0)))
                    exponent-bits (|> (if (..< +0.0 min-gap)
                                        (|> (..int exponent)
                                            (//int.- (..int min-gap))
                                            dec)
                                        (..int exponent))
                                      (//int.+ (.int ..double-bias))
                                      (//i64.and ..exponent-mask))
                    mantissa-bits (..int mantissa)]
                ($_ //i64.or
                    (//i64.left-shift ..sign-offset sign-bit)
                    (//i64.left-shift ..exponent-offset exponent-bits)
                    (//i64.clear ..mantissa-size mantissa-bits)))
              )))

(template [<getter> <size> <offset>]
  [(def: <getter>
     (-> (I64 Any) I64)
     (let [mask (|> 1 (//i64.left-shift <size>) dec (//i64.left-shift <offset>))]
       (|>> (//i64.and mask) (//i64.logic-right-shift <offset>) .i64)))]

  [mantissa ..mantissa-size 0]
  [exponent ..exponent-size ..mantissa-size]
  [sign     1               ..sign-offset]
  )

(def: #export (from-bits input)
  (-> I64 Frac)
  (case [(: Nat (..exponent input))
         (: Nat (..mantissa input))
         (: Nat (..sign input))]
    (^ [(static ..special-exponent-bits) 0 0])
    ..positive-infinity

    (^ [(static ..special-exponent-bits) 0 1])
    ..negative-infinity

    (^ [(static ..special-exponent-bits) _ _])
    ..not-a-number

    ## Positive zero
    [0 0 0] +0.0
    ## Negative zero
    [0 0 1] (..* -1.0 +0.0)

    [E M S]
    (let [sign (if (//nat.= 0 S)
                 +1.0
                 -1.0)
          [mantissa power] (if (//nat.< ..mantissa-size E)
                             [(if (//nat.= 0 E)
                                M
                                (//i64.set ..mantissa-size M))
                              (|> E
                                  (//nat.- ..double-bias)
                                  .int
                                  (//int.max ..min-exponent)
                                  (//int.- (.int ..mantissa-size)))]
                             [(//i64.set ..mantissa-size M)
                              (|> E (//nat.- ..double-bias) (//nat.- ..mantissa-size) .int)])
          exponent (math.pow (//int.frac power) +2.0)]
      (|> (//nat.frac mantissa)
          (..* exponent)
          (..* sign)))))

(def: (split-exponent codec representation)
  (-> (Codec Text Nat) Text (Try [Text Int]))
  (case [("lux text index" 0 "e+" representation)
         ("lux text index" 0 "E+" representation)
         ("lux text index" 0 "e-" representation)
         ("lux text index" 0 "E-" representation)]
    (^template [<factor> <patterns>]
      [<patterns>
       (do try.monad
         [exponent (|> representation
                       ("lux text clip" (//nat.+ 2 split-index) ("lux text size" representation))
                       (\ codec decode))]
         (wrap [("lux text clip" 0 split-index representation)
                (//int.* <factor> (.int exponent))]))])
    ([+1 (^or [(#.Some split-index) #.None #.None #.None]
              [#.None (#.Some split-index) #.None #.None])]
     [-1 (^or [#.None #.None (#.Some split-index) #.None]
              [#.None #.None #.None (#.Some split-index)])])
    
    _
    (#try.Success [representation +0])))

(template [<struct> <nat> <int> <error>]
  [(structure: #export <struct>
     (Codec Text Frac)
     
     (def: (encode value)
       (let [bits (..to-bits value)
             mantissa (..mantissa bits)
             exponent (//int.- (.int ..double-bias) (..exponent bits))
             sign (..sign bits)]
         ($_ "lux text concat"
             (case (.nat sign)
               1 "-"
               0 "+"
               _ (undefined))
             (\ <nat> encode (.nat mantissa))
             ".0E"
             (\ <int> encode exponent))))

     (def: (decode representation)
       (let [negative? (text.starts-with? "-" representation)
             positive? (text.starts-with? "+" representation)]
         (if (or negative? positive?)
           (do {! try.monad}
             [[mantissa exponent] (..split-exponent <nat> representation)
              [whole decimal] (case ("lux text index" 0 "." mantissa)
                                (#.Some split-index)
                                (do !
                                  [decimal (|> mantissa
                                               ("lux text clip" (inc split-index) ("lux text size" mantissa))
                                               (\ <nat> decode))]
                                  (wrap [("lux text clip" 0 split-index mantissa)
                                         decimal]))

                                #.None
                                (#try.Failure ("lux text concat" <error> representation)))
              #let [whole ("lux text clip" 1 ("lux text size" whole) whole)]
              mantissa (\ <nat> decode (case decimal
                                         0 whole
                                         _ ("lux text concat" whole (\ <nat> encode decimal))))
              #let [sign (if negative? 1 0)]]
             (wrap (..from-bits
                    ($_ //i64.or
                        (//i64.left-shift ..sign-offset (.i64 sign))
                        (//i64.left-shift ..mantissa-size (.i64 (//int.+ (.int ..double-bias) exponent)))
                        (//i64.clear ..mantissa-size (.i64 mantissa))))))
           (#try.Failure ("lux text concat" <error> representation))))))]

  [binary //nat.binary //int.binary "Invalid binary syntax: "]
  [octal //nat.octal //int.octal "Invalid octaladecimal syntax: "]
  [hex //nat.hex //int.hex "Invalid hexadecimal syntax: "]
  )

(structure: #export hash
  (Hash Frac)
  
  (def: &equivalence ..equivalence)
  (def: hash ..to-bits))

(def: #export (within? margin-of-error standard value)
  (-> Frac Frac Frac Bit)
  (|> value
      (..- standard)
      ..abs
      (..< margin-of-error)))

(def: #export (mod divisor dividend)
  (All [m] (-> Frac Frac Frac))
  (let [remainder (..% divisor dividend)]
    (if (or (and (..< +0.0 divisor)
                 (..> +0.0 remainder))
            (and (..> +0.0 divisor)
                 (..< +0.0 remainder)))
      (..+ divisor remainder)
      remainder)))
