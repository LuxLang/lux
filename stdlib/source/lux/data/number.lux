(;module: {#;doc "Implementations of common structures for Lux's primitive number types."}
  lux
  (lux (control number
                monoid
                eq
                hash
                [order]
                enum
                interval
                codec)
       (data error)))

## [Structures]
(do-template [<type> <test>]
  [(struct: #export _ (Eq <type>)
     (def: = <test>))]

  [ Nat n.=]
  [ Int i.=]
  [ Deg d.=]
  [Real r.=]
  )

(do-template [<type> <eq> <lt> <lte> <gt> <gte>]
  [(struct: #export _ (order;Order <type>)
     (def: eq <eq>)
     (def: < <lt>)
     (def: <= <lte>)
     (def: > <gt>)
     (def: >= <gte>))]

  [ Nat Eq<Nat>  n.< n.<= n.> n.>=]
  [ Int Eq<Int>  i.< i.<= i.> i.>=]
  [Deg  Eq<Deg>  d.< d.<= d.> d.>=]
  [Real Eq<Real> r.< r.<= r.> r.>=]
  )

(struct: #export _ (Number Nat)
  (def: + n.+)
  (def: - n.-)
  (def: * n.*)
  (def: / n./)
  (def: % n.%)
  (def: negate id)
  (def: abs id)
  (def: (signum x)
    (case x
      +0 +0
      _  +1))
  )

(do-template [<type> <order> <+> <-> <*> </> <%> <=> <<> <0> <1> <-1>]
  [(struct: #export _ (Number <type>)
     (def: + <+>)
     (def: - <->)
     (def: * <*>)
     (def: / </>)
     (def: % <%>)
     (def: negate (<*> <-1>))
     (def: (abs x)
       (if (<<> <0> x)
         (<*> <-1> x)
         x))
     (def: (signum x)
       (cond (<=> <0> x) <0>
             (<<> <0> x) <-1>
             ## else
             <1>))
     )]

  [ Int  Order<Int> i.+ i.- i.* i./ i.% i.= i.<   0   1   -1]
  [Real Order<Real> r.+ r.- r.* r./ r.% r.= r.< 0.0 1.0 -1.0]
  )

(struct: #export _ (Number Deg)
  (def: + d.+)
  (def: - d.-)
  (def: * d.*)
  (def: / d./)
  (def: % d.%)
  (def: (negate x) (d.- x (_lux_proc ["deg" "max-value"] [])))
  (def: abs id)
  (def: (signum x)
    (_lux_proc ["deg" "max-value"] []))
  )

(do-template [<type> <order> <succ> <pred>]
  [(struct: #export _ (Enum <type>)
     (def: order <order>)
     (def: succ <succ>)
     (def: pred <pred>))]

  [Nat Order<Nat> n.inc n.dec]
  [Int Order<Int> i.inc i.dec]
  [Real Order<Real> (r.+ (_lux_proc [ "real" "smallest-value"] [])) (r.- (_lux_proc [ "real" "smallest-value"] []))]
  [Deg Order<Deg> (d.+ (_lux_proc [ "deg" "min-value"] [])) (d.- (_lux_proc [ "deg" "min-value"] []))]
  )

(do-template [<type> <enum> <top> <bottom>]
  [(struct: #export _ (Interval <type>)
     (def: enum <enum>)
     (def: top <top>)
     (def: bottom <bottom>))]

  [ Nat Enum<Nat>  (_lux_proc [ "nat" "max-value"] []) (_lux_proc [ "nat" "min-value"] [])]
  [ Int Enum<Int>  (_lux_proc [ "int" "max-value"] []) (_lux_proc [ "int" "min-value"] [])]
  [Real Enum<Real> (_lux_proc ["real" "max-value"] []) (_lux_proc ["real" "min-value"] [])]
  [ Deg Enum<Deg>  (_lux_proc [ "deg" "max-value"] []) (_lux_proc [ "deg" "min-value"] [])]
  )

(do-template [<name> <type> <unit> <append>]
  [(struct: #export <name> (Monoid <type>)
     (def: unit <unit>)
     (def: append <append>))]

  [ Add@Monoid<Nat>  Nat +0                         n.+]
  [ Mul@Monoid<Nat>  Nat +1                         n.*]
  [ Max@Monoid<Nat>  Nat (:: Interval<Nat> bottom)  n.max]
  [ Min@Monoid<Nat>  Nat (:: Interval<Nat> top)     n.min]
  [ Add@Monoid<Int>  Int 0                          i.+]
  [ Mul@Monoid<Int>  Int 1                          i.*]
  [ Max@Monoid<Int>  Int (:: Interval<Int> bottom)  i.max]
  [ Min@Monoid<Int>  Int (:: Interval<Int> top)     i.min]
  [Add@Monoid<Real> Real 0.0                        r.+]
  [Mul@Monoid<Real> Real 1.0                        r.*]
  [Max@Monoid<Real> Real (:: Interval<Real> bottom) r.max]
  [Min@Monoid<Real> Real (:: Interval<Real> top)    r.min]
  [ Add@Monoid<Deg>  Deg (:: Interval<Deg> bottom)  d.+]
  [ Mul@Monoid<Deg>  Deg (:: Interval<Deg> top)     d.*]
  [ Max@Monoid<Deg>  Deg (:: Interval<Deg> bottom)  d.max]
  [ Min@Monoid<Deg>  Deg (:: Interval<Deg> top)     d.min]
  )

(do-template [<name> <const> <doc>]
  [(def: #export <name>
     {#;doc <doc>}
     Real
     (_lux_proc ["real" <const>] []))]

  [not-a-number      "not-a-number"      "Not-a-number."]
  [positive-infinity "positive-infinity" "Positive infinity."]
  [negative-infinity "negative-infinity" "Negative infinity."]
  )

(def: #export (not-a-number? number)
  {#;doc "Tests whether a real is actually not-a-number."}
  (-> Real Bool)
  (not (r.= number number)))

(do-template [<type> <encoder> <decoder> <error>]
  [(struct: #export _ (Codec Text <type>)
     (def: (encode x)
       (_lux_proc <encoder> [x]))

     (def: (decode input)
       (case (_lux_proc <decoder> [input])
         (#;Some value)
         (#;Right value)

         #;None
         (#;Left <error>))))]

  [Real ["real" "encode"] ["real" "decode"] "Couldn't decode Real"]
  [ Deg [ "deg" "encode"] [ "deg" "decode"] "Couldn't decode Deg"]
  )

(struct: #export _ (Hash Nat)
  (def: eq Eq<Nat>)
  (def: hash id))

(struct: #export _ (Hash Int)
  (def: eq Eq<Int>)
  (def: hash int-to-nat))

(struct: #export _ (Hash Real)
  (def: eq Eq<Real>)
  
  (def: (hash value)
    (_lux_proc ["real" "hash"] [value])))

## [Values & Syntax]
(do-template [<struct> <base> <char-set> <error>]
  [(struct: #export <struct> (Codec Text Nat)
     (def: (encode value)
       (loop [input value
              output ""]
         (let [digit (assume (_lux_proc ["text" "char"] [<char-set> (n.% <base> input)]))
               output' (_lux_proc ["text" "append"] [(_lux_proc ["char" "to-text"] [digit])
                                                     output])
               input' (n./ <base> input)]
           (if (n.= +0 input')
             (_lux_proc ["text" "append"] ["+" output'])
             (recur input' output')))))

     (def: (decode repr)
       (let [input-size (_lux_proc ["text" "size"] [repr])]
         (if (n.>= +2 input-size)
           (case (_lux_proc ["text" "char"] [repr +0])
             (#;Some #"+")
             (let [input (_lux_proc ["text" "upper-case"] [repr])]
               (loop [idx +1
                      output +0]
                 (if (n.< input-size idx)
                   (let [digit (assume (_lux_proc ["text" "char"] [input idx]))]
                     (case (_lux_proc ["text" "index"]
                                      [<char-set>
                                       (_lux_proc ["char" "to-text"] [digit])
                                       +0])
                       #;None
                       (#;Left (_lux_proc ["text" "append"] [<error> repr]))

                       (#;Some index)
                       (recur (n.inc idx)
                              (|> output (n.* <base>) (n.+ index)))))
                   (#;Right output))))

             _
             (#;Left (_lux_proc ["text" "append"] [<error> repr])))
           (#;Left (_lux_proc ["text" "append"] [<error> repr]))))))]

  [Binary@Codec<Text,Nat> +2  "01"               "Invalid binary syntax: "]
  [Octal@Codec<Text,Nat>  +8  "01234567"         "Invalid octal syntax: "]
  [_                      +10 "0123456789"       "Invalid syntax for Nat: "]
  [Hex@Codec<Text,Nat>    +16 "0123456789ABCDEF" "Invalid hexadecimal syntax: "]
  )

(do-template [<struct> <base> <char-set> <error>]
  [(struct: #export <struct> (Codec Text Int)
     (def: (encode value)
       (if (i.= 0 value)
         "0"
         (let [sign (if (i.< 0 value)
                      "-"
                      "")]
           (loop [input (|> value (i./ <base>) (:: Number<Int> abs))
                  output (|> value (i.% <base>) (:: Number<Int> abs)
                             int-to-nat [<char-set>] (_lux_proc ["text" "char"])
                             assume
                             []
                             (_lux_proc ["char" "to-text"]))]
             (let [digit (assume (_lux_proc ["text" "char"] [<char-set> (int-to-nat (i.% <base> input))]))
                   output' (_lux_proc ["text" "append"] [(_lux_proc ["char" "to-text"] [digit])
                                                         output])
                   input' (i./ <base> input)]
               (if (i.= 0 input')
                 (_lux_proc ["text" "append"] [sign output'])
                 (recur input' output')))))))

     (def: (decode repr)
       (let [input-size (_lux_proc ["text" "size"] [repr])]
         (if (n.>= +1 input-size)
           (let [sign (case (_lux_proc ["text" "char"] [repr +0])
                        (#;Some #"-")
                        -1

                        _
                        1)
                 input (_lux_proc ["text" "upper-case"] [repr])]
             (loop [idx (if (i.= -1 sign) +1 +0)
                    output 0]
               (if (n.< input-size idx)
                 (let [digit (assume (_lux_proc ["text" "char"] [input idx]))]
                   (case (_lux_proc ["text" "index"]
                                    [<char-set>
                                     (_lux_proc ["char" "to-text"] [digit])
                                     +0])
                     #;None
                     (#;Left <error>)

                     (#;Some index)
                     (recur (n.inc idx)
                            (|> output (i.* <base>) (i.+ (nat-to-int index))))))
                 (#;Right (i.* sign output)))))
           (#;Left <error>)))))]

  [Binary@Codec<Text,Int> 2  "01"               "Invalid binary syntax."]
  [Octal@Codec<Text,Int>  8  "01234567"         "Invalid octal syntax."]
  [_                      10 "0123456789"       "Invalid syntax for Int: "]
  [Hex@Codec<Text,Int>    16 "0123456789ABCDEF" "Invalid hexadecimal syntax."]
  )

(do-template [<macro> <nat> <int> <error> <doc>]
  [(macro: #export (<macro> tokens state)
     {#;doc <doc>}
     (case tokens
       (#;Cons [meta (#;TextS repr)] #;Nil)
       (case (:: <nat> decode repr)
         (#;Right value)
         (#;Right [state (list [meta (#;NatS value)])])

         (^=> (#;Left _)
              [(:: <int> decode repr) (#;Right value)])
         (#;Right [state (list [meta (#;IntS value)])])

         _
         (#;Left <error>))

       _
       (#;Left <error>)))]

  [bin Binary@Codec<Text,Nat> Binary@Codec<Text,Int>
   "Invalid binary syntax."
   (doc "Given syntax for a binary number, generates a Nat, an Int, a Real or a Deg."
        (bin "11001001"))]
  [oct Octal@Codec<Text,Nat>  Octal@Codec<Text,Int>
   "Invalid octal syntax."
   (doc "Given syntax for an octal number, generates a Nat, an Int, a Real or a Deg."
        (oct "615243"))]
  [hex Hex@Codec<Text,Nat>    Hex@Codec<Text,Int>
   "Invalid hexadecimal syntax."
   (doc "Given syntax for a hexadecimal number, generates a Nat, an Int, a Real or a Deg."
        (hex "deadBEEF"))]
  )
