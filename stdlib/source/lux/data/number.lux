(;module: {#;doc "Implementations of common structures for Lux's primitive number types."}
  lux
  (lux (control number
                monoid
                eq
                hash
                [order]
                enum
                interval
                codec)
       (data error)))

## [Structures]
(do-template [<type> <test>]
  [(struct: #export _ (Eq <type>)
     (def: = <test>))]

  [ Nat n.=]
  [ Int i.=]
  [ Deg d.=]
  [Real r.=]
  )

(do-template [<type> <eq> <lt> <lte> <gt> <gte>]
  [(struct: #export _ (order;Order <type>)
     (def: eq <eq>)
     (def: < <lt>)
     (def: <= <lte>)
     (def: > <gt>)
     (def: >= <gte>))]

  [ Nat Eq<Nat>  n.< n.<= n.> n.>=]
  [ Int Eq<Int>  i.< i.<= i.> i.>=]
  [Deg  Eq<Deg>  d.< d.<= d.> d.>=]
  [Real Eq<Real> r.< r.<= r.> r.>=]
  )

(struct: #export _ (Number Nat)
  (def: + n.+)
  (def: - n.-)
  (def: * n.*)
  (def: / n./)
  (def: % n.%)
  (def: negate id)
  (def: abs id)
  (def: (signum x)
    (case x
      +0 +0
      _  +1))
  )

(do-template [<type> <order> <+> <-> <*> </> <%> <=> <<> <0> <1> <-1>]
  [(struct: #export _ (Number <type>)
     (def: + <+>)
     (def: - <->)
     (def: * <*>)
     (def: / </>)
     (def: % <%>)
     (def: negate (<*> <-1>))
     (def: (abs x)
       (if (<<> <0> x)
         (<*> <-1> x)
         x))
     (def: (signum x)
       (cond (<=> <0> x) <0>
             (<<> <0> x) <-1>
             ## else
             <1>))
     )]

  [ Int  Order<Int> i.+ i.- i.* i./ i.% i.= i.<   0   1   -1]
  [Real Order<Real> r.+ r.- r.* r./ r.% r.= r.< 0.0 1.0 -1.0]
  )

(struct: #export _ (Number Deg)
  (def: + d.+)
  (def: - d.-)
  (def: * d.*)
  (def: / d./)
  (def: % d.%)
  (def: (negate x) (d.- x (_lux_proc ["deg" "max-value"] [])))
  (def: abs id)
  (def: (signum x)
    (_lux_proc ["deg" "max-value"] []))
  )

(do-template [<type> <order> <succ> <pred>]
  [(struct: #export _ (Enum <type>)
     (def: order <order>)
     (def: succ <succ>)
     (def: pred <pred>))]

  [Nat Order<Nat> n.inc n.dec]
  [Int Order<Int> i.inc i.dec]
  [Real Order<Real> (r.+ (_lux_proc [ "real" "smallest-value"] [])) (r.- (_lux_proc [ "real" "smallest-value"] []))]
  [Deg Order<Deg> (d.+ (_lux_proc [ "deg" "min-value"] [])) (d.- (_lux_proc [ "deg" "min-value"] []))]
  )

(do-template [<type> <enum> <top> <bottom>]
  [(struct: #export _ (Interval <type>)
     (def: enum <enum>)
     (def: top <top>)
     (def: bottom <bottom>))]

  [ Nat Enum<Nat>  (_lux_proc [ "nat" "max-value"] []) (_lux_proc [ "nat" "min-value"] [])]
  [ Int Enum<Int>  (_lux_proc [ "int" "max-value"] []) (_lux_proc [ "int" "min-value"] [])]
  [Real Enum<Real> (_lux_proc ["real" "max-value"] []) (_lux_proc ["real" "min-value"] [])]
  [ Deg Enum<Deg>  (_lux_proc [ "deg" "max-value"] []) (_lux_proc [ "deg" "min-value"] [])]
  )

(do-template [<name> <type> <unit> <append>]
  [(struct: #export <name> (Monoid <type>)
     (def: unit <unit>)
     (def: append <append>))]

  [ Add@Monoid<Nat>  Nat +0                         n.+]
  [ Mul@Monoid<Nat>  Nat +1                         n.*]
  [ Max@Monoid<Nat>  Nat (:: Interval<Nat> bottom)  n.max]
  [ Min@Monoid<Nat>  Nat (:: Interval<Nat> top)     n.min]
  [ Add@Monoid<Int>  Int 0                          i.+]
  [ Mul@Monoid<Int>  Int 1                          i.*]
  [ Max@Monoid<Int>  Int (:: Interval<Int> bottom)  i.max]
  [ Min@Monoid<Int>  Int (:: Interval<Int> top)     i.min]
  [Add@Monoid<Real> Real 0.0                        r.+]
  [Mul@Monoid<Real> Real 1.0                        r.*]
  [Max@Monoid<Real> Real (:: Interval<Real> bottom) r.max]
  [Min@Monoid<Real> Real (:: Interval<Real> top)    r.min]
  [ Add@Monoid<Deg>  Deg (:: Interval<Deg> bottom)  d.+]
  [ Mul@Monoid<Deg>  Deg (:: Interval<Deg> top)     d.*]
  [ Max@Monoid<Deg>  Deg (:: Interval<Deg> bottom)  d.max]
  [ Min@Monoid<Deg>  Deg (:: Interval<Deg> top)     d.min]
  )

(do-template [<type> <encoder> <decoder> <error>]
  [(struct: #export _ (Codec Text <type>)
     (def: (encode x)
       (_lux_proc <encoder> [x]))

     (def: (decode input)
       (case (_lux_proc <decoder> [input])
         (#;Some value)
         (#;Right value)

         #;None
         (#;Left <error>))))]

  [ Deg [ "deg" "encode"] [ "deg" "decode"] "Couldn't decode Deg"]
  [Real ["real" "encode"] ["real" "decode"] "Couldn't decode Real"]
  )

(def: (digit-to-text digit)
  (-> Nat Text)
  (case digit
    +0 "0"
    +1 "1" +2 "2" +3 "3"
    +4 "4" +5 "5" +6 "6"
    +7 "7" +8 "8" +9 "9"
    _ (undefined)))

(def: (text-to-digit digit)
  (-> Text (Maybe Nat))
  (case digit
    "0" (#;Some +0)
    "1" (#;Some +1) "2" (#;Some +2) "3" (#;Some +3)
    "4" (#;Some +4) "5" (#;Some +5) "6" (#;Some +6)
    "7" (#;Some +7) "8" (#;Some +8) "9" (#;Some +9)
    _ #;None))

(struct: #export _ (Codec Text Int)
  (def: (encode value)
    (if (i.= 0 value)
      "0"
      (let [sign (if (i.> 0 value)
                   ""
                   "-")]
        (loop [input (|> value (i./ 10) (:: Number<Int> abs))
               output (|> value (i.% 10) (:: Number<Int> abs) int-to-nat digit-to-text)]
          (if (i.= 0 input)
            (_lux_proc ["text" "append"] [sign output])
            (recur (i./ 10 input)
                   (_lux_proc ["text" "append"] [(|> input (i.% 10) int-to-nat digit-to-text)
                                                 output])))))
      ))

  (def: (decode repr)
    (let [input-size (_lux_proc ["text" "size"] [repr])]
      (if (n.>= +1 input-size)
        (let [sign (case (_lux_proc ["text" "char"] [repr +0])
                     (#;Some #"-")
                     -1

                     _
                     1)]
          (loop [idx (if (i.= -1 sign) +1 +0)
                 output 0]
            (if (n.< input-size idx)
              (case (_lux_proc ["text" "char"] [repr idx])
                (^=> (#;Some sample)
                     [(text-to-digit (_lux_proc ["char" "to-text"] [sample])) (#;Some digit)])
                (recur (n.inc idx)
                       (|> output (i.* 10) (i.+ (nat-to-int digit))))

                _
                (undefined))
              (#;Right (i.* sign output)))))
        (#;Left "Invalid syntax for Int.")))))

(struct: #export _ (Codec Text Nat)
  (def: (encode value)
    (case value
      +0
      "+0"

      _
      (loop [input value
             output ""]
        (if (n.= +0 input)
          (_lux_proc ["text" "append"] ["+" output])
          (recur (n./ +10 input)
                 (_lux_proc ["text" "append"] [(digit-to-text (n.% +10 input)) output]))))))

  (def: (decode repr)
    (let [input-size (_lux_proc ["text" "size"] [repr])]
      (if (n.>= +2 input-size)
        (case (_lux_proc ["text" "char"] [repr +0])
          (#;Some #"+")
          (loop [idx +1
                 output +0]
            (if (n.< input-size idx)
              (case (_lux_proc ["text" "char"] [repr idx])
                (^=> (#;Some sample)
                     [(text-to-digit (_lux_proc ["char" "to-text"] [sample])) (#;Some digit)])
                (recur (n.inc idx)
                       (|> output (n.* +10) (n.+ digit)))

                _
                (undefined))
              (#;Right output)))

          _
          (#;Left "Invalid syntax for Nat."))
        (#;Left "Invalid syntax for Nat.")))))

(struct: #export _ (Hash Nat)
  (def: eq Eq<Nat>)
  (def: hash id))

(struct: #export _ (Hash Int)
  (def: eq Eq<Int>)
  (def: hash int-to-nat))

(struct: #export _ (Hash Real)
  (def: eq Eq<Real>)
  
  (def: (hash value)
    (_lux_proc ["real" "hash"] [value])))

(do-template [<name> <const> <doc>]
  [(def: #export <name>
     {#;doc <doc>}
     Real
     (_lux_proc ["real" <const>] []))]

  [not-a-number      "not-a-number"      "Not-a-number."]
  [positive-infinity "positive-infinity" "Positive infinity."]
  [negative-infinity "negative-infinity" "Negative infinity."]
  )

(def: #export (not-a-number? number)
  {#;doc "Tests whether a real is actually not-a-number."}
  (-> Real Bool)
  (not (r.= number number)))

## [Values & Syntax]
(do-template [<struct> <base> <macro> <error> <char-set> <doc>]
  [(struct: #export <struct> (Codec Text Nat)
     (def: (encode value)
       (loop [input value
              output ""]
         (let [digit (assume (_lux_proc ["text" "char"] [<char-set> (n.% <base> input)]))
               output' (_lux_proc ["text" "append"] [(_lux_proc ["char" "to-text"] [digit])
                                                     output])
               input' (n./ <base> input)]
           (if (n.= +0 input')
             output'
             (recur input' output')))))

     (def: (decode repr)
       (let [input-size (_lux_proc ["text" "size"] [repr])]
         (if (n.= +0 input-size)
           (#;Left "Empty input.")
           (let [input (_lux_proc ["text" "upper-case"] [repr])]
             (loop [idx +0
                    output +0]
               (if (n.< input-size idx)
                 (let [digit (assume (_lux_proc ["text" "char"] [input idx]))]
                   (case (_lux_proc ["text" "index"]
                                    [<char-set>
                                     (_lux_proc ["char" "to-text"] [digit])
                                     +0])
                     #;None
                     (#;Left <error>)

                     (#;Some index)
                     (recur (n.inc idx)
                            (|> output (n.* <base>) (n.+ index)))))
                 (#;Right output))))))))

   (macro: #export (<macro> tokens state)
     {#;doc <doc>}
     (case tokens
       (#;Cons [meta (#;TextS repr)] #;Nil)
       (case (:: <struct> decode repr)
         (#;Right value)
         (#;Right [state (list [meta (#;NatS value)])])

         (#;Left error)
         (#;Left error))

       _
       (#;Left <error>)))]

  [Binary@Codec<Text,Nat> +2  bin "Invalid binary syntax."
   "01"
   (doc "Given syntax for a binary number, generates a Nat."
        (bin "11001001"))]
  [Octal@Codec<Text,Nat>  +8  oct "Invalid octal syntax."
   "01234567"
   (doc "Given syntax for an octal number, generates a Nat."
        (oct "615243"))]
  [Hex@Codec<Text,Nat>    +16 hex "Invalid hexadecimal syntax."
   "0123456789ABCDEF"
   (doc "Given syntax for a hexadecimal number, generates a Nat."
        (hex "deadBEEF"))]
  )
