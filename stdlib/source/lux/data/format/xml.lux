(.module:
  [lux #*
   [abstract
    [monad (#+ do)]
    [equivalence (#+ Equivalence)]
    [codec (#+ Codec)]]
   [control
    [try (#+ Try)]
    ["<>" parser ("#\." monad)
     ["<.>" text (#+ Parser)]]]
   [data
    ["." product]
    ["." name ("#\." equivalence codec)]
    ["." text ("#\." equivalence monoid)]
    [number
     ["n" nat]
     ["." int]]
    [collection
     ["." list ("#\." functor)]
     ["." dictionary (#+ Dictionary)]]]])

(type: #export Tag
  Name)

(type: #export Attribute
  Name)

(type: #export Attrs
  (Dictionary Attribute Text))

(def: #export attributes
  Attrs
  (dictionary.new name.hash))

(type: #export #rec XML
  (#Text Text)
  (#Node Tag Attrs (List XML)))

(def: namespace-separator
  ":")

(def: xml-standard-escape-char^
  (Parser Text)
  ($_ <>.either
      (<>.after (<text>.this "&lt;") (<>\wrap "<"))
      (<>.after (<text>.this "&gt;") (<>\wrap ">"))
      (<>.after (<text>.this "&amp;") (<>\wrap "&"))
      (<>.after (<text>.this "&apos;") (<>\wrap "'"))
      (<>.after (<text>.this "&quot;") (<>\wrap text.double-quote))
      ))

(def: xml-unicode-escape-char^
  (Parser Text)
  (|> (do <>.monad
        [hex? (<>.maybe (<text>.this "x"))
         code (case hex?
                #.None
                (<>.codec int.decimal (<text>.many <text>.decimal))

                (#.Some _)
                (<>.codec int.decimal (<text>.many <text>.hexadecimal)))]
        (wrap (|> code .nat text.from-code)))
      (<>.before (<text>.this ";"))
      (<>.after (<text>.this "&#"))))

(def: xml-escape-char^
  (Parser Text)
  (<>.either xml-standard-escape-char^
             xml-unicode-escape-char^))

(def: xml-char^
  (Parser Text)
  (<>.either (<text>.none-of ($_ text\compose "<>&'" text.double-quote))
             xml-escape-char^))

(def: xml-identifier
  (Parser Text)
  (do <>.monad
    [head (<>.either (<text>.one-of "_")
                     <text>.alpha)
     tail (<text>.some (<>.either (<text>.one-of "_.-")
                                  <text>.alpha-num))]
    (wrap ($_ text\compose head tail))))

(def: namespaced-symbol^
  (Parser Name)
  (do <>.monad
    [first-part xml-identifier
     ?second-part (<| <>.maybe (<>.after (<text>.this ..namespace-separator)) xml-identifier)]
    (case ?second-part
      #.None
      (wrap ["" first-part])

      (#.Some second-part)
      (wrap [first-part second-part]))))

(def: tag^ namespaced-symbol^)
(def: attr-name^ namespaced-symbol^)

(def: spaced^
  (All [a] (-> (Parser a) (Parser a)))
  (let [white-space^ (<>.some <text>.space)]
    (|>> (<>.before white-space^)
         (<>.after white-space^))))

(def: attr-value^
  (Parser Text)
  (let [value^ (<text>.some xml-char^)]
    (<>.either (<text>.enclosed [text.double-quote text.double-quote] value^)
               (<text>.enclosed ["'" "'"] value^))))

(def: attrs^
  (Parser Attrs)
  (<| (\ <>.monad map (dictionary.from-list name.hash))
      <>.some
      (<>.and (spaced^ attr-name^))
      (<>.after (<text>.this "="))
      (spaced^ attr-value^)))

(def: (close-tag^ expected)
  (-> Tag (Parser []))
  (do <>.monad
    [actual (|> tag^
                spaced^
                (<>.after (<text>.this "/"))
                (<text>.enclosed ["<" ">"]))]
    (<>.assert ($_ text\compose "Close tag does not match open tag." text.new-line
                   "Expected: " (name\encode expected) text.new-line
                   "  Actual: " (name\encode actual) text.new-line)
               (name\= expected actual))))

(def: comment^
  (Parser Text)
  (|> (<text>.not (<text>.this "--"))
      <text>.some
      (<text>.enclosed ["<--" "-->"])
      spaced^))

(def: xml-header^
  (Parser Attrs)
  (|> (spaced^ attrs^)
      (<>.before (<text>.this "?>"))
      (<>.after (<text>.this "<?xml"))
      spaced^))

(def: cdata^
  (Parser Text)
  (let [end (<text>.this "]]>")]
    (|> (<text>.some (<text>.not end))
        (<>.after end)
        (<>.after (<text>.this "<![CDATA["))
        spaced^)))

(def: text^
  (Parser XML)
  (|> (<>.either cdata^
                 (..spaced^ (<text>.many xml-char^)))
      (<>\map (|>> #Text))))

(def: null^
  (Parser Any)
  (<text>.this (text.from-code 0)))

(def: xml^
  (Parser XML)
  (|> (<>.rec
       (function (_ node^)
         (<>.either text^
                    (spaced^
                     (do <>.monad
                       [_ (<text>.this "<")
                        tag (spaced^ tag^)
                        attrs (spaced^ attrs^)
                        #let [no-children^ (do <>.monad
                                             [_ (<text>.this "/>")]
                                             (wrap (#Node tag attrs (list))))
                              with-children^ (do <>.monad
                                               [_ (<text>.this ">")
                                                children (<>.some node^)
                                                _ (close-tag^ tag)]
                                               (wrap (#Node tag attrs children)))]]
                       (<>.either no-children^
                                  with-children^))))))
      ## This is put outside of the call to "rec" because comments
      ## cannot be located inside of XML nodes.
      ## This way, the comments can only be before or after the main document.
      (<>.before (<>.some comment^))
      (<>.before (<>.some ..null^))
      (<>.after (<>.some comment^))
      (<>.after (<>.maybe xml-header^))))

(def: read
  (-> Text (Try XML))
  (<text>.run xml^))

(def: (sanitize-value input)
  (-> Text Text)
  (|> input
      (text.replace-all "&" "&amp;")
      (text.replace-all "<" "&lt;")
      (text.replace-all ">" "&gt;")
      (text.replace-all "'" "&apos;")
      (text.replace-all text.double-quote "&quot;")))

(def: #export (tag [namespace name])
  (-> Tag Text)
  (case namespace
    "" name
    _ ($_ text\compose namespace ..namespace-separator name)))

(def: #export attribute
  (-> Attribute Text)
  ..tag)

(def: (write-attrs attrs)
  (-> Attrs Text)
  (|> attrs
      dictionary.entries
      (list\map (function (_ [key value])
                  ($_ text\compose (..attribute key) "=" text.double-quote (sanitize-value value) text.double-quote)))
      (text.join-with " ")))

(def: xml-header
  Text
  (let [quote (: (-> Text Text)
                 (function (_ value)
                   ($_ text\compose text.double-quote value text.double-quote)))]
    ($_ text\compose
        "<?xml"
        " version=" (quote "1.0")
        " encoding=" (quote "UTF-8")
        "?>")))

(def: (write input)
  (-> XML Text)
  ($_ text\compose
      ..xml-header text.new-line
      (loop [prefix ""
             input input]
        (case input
          (#Text value)
          (sanitize-value value)

          (^ (#Node xml-tag xml-attrs (list (#Text value))))
          (let [tag (..tag xml-tag)
                attrs (if (dictionary.empty? xml-attrs)
                        ""
                        ($_ text\compose " " (..write-attrs xml-attrs)))]
            ($_ text\compose
                prefix "<" tag attrs ">"
                (sanitize-value value)
                "</" tag ">"))
          
          (#Node xml-tag xml-attrs xml-children)
          (let [tag (..tag xml-tag)
                attrs (if (dictionary.empty? xml-attrs)
                        ""
                        ($_ text\compose " " (..write-attrs xml-attrs)))]
            (if (list.empty? xml-children)
              ($_ text\compose prefix "<" tag attrs "/>")
              ($_ text\compose prefix "<" tag attrs ">"
                  (|> xml-children
                      (list\map (|>> (recur (text\compose prefix text.tab)) (text\compose text.new-line)))
                      (text.join-with ""))
                  text.new-line prefix "</" tag ">")))))
      ))

(structure: #export codec
  (Codec Text XML)
  
  (def: encode ..write)
  (def: decode ..read))

(structure: #export equivalence
  (Equivalence XML)
  
  (def: (= reference sample)
    (case [reference sample]
      [(#Text reference/value) (#Text sample/value)]
      (text\= reference/value sample/value)

      [(#Node reference/tag reference/attrs reference/children)
       (#Node sample/tag sample/attrs sample/children)]
      (and (name\= reference/tag sample/tag)
           (\ (dictionary.equivalence text.equivalence) = reference/attrs sample/attrs)
           (n.= (list.size reference/children)
                (list.size sample/children))
           (|> (list.zip/2 reference/children sample/children)
               (list.every? (product.uncurry =))))

      _
      false)))
