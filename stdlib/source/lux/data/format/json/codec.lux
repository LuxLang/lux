(;module: {#;doc "Codecs for values in the JSON format.

                  For more information, please see: http://www.json.org/"}
  lux
  (lux (control functor
                applicative
                ["M" monad #+ do Monad]
                [eq #+ Eq]
                codec
                ["p" parser "p/" Monad<Parser>])
       (data [bool]
             [text "text/" Eq<Text> Monoid<Text>]
             (text ["l" lexer])
             [number "real/" Codec<Text,Real> "nat/" Codec<Text,Nat>]
             maybe
             ["R" result]
             [sum]
             [product]
             (coll [list "L/" Fold<List> Monad<List>]
                   [vector #+ Vector vector "Vector/" Monad<Vector>]
                   ["d" dict]))
       [macro #+ Monad<Lux> with-gensyms]
       (macro ["s" syntax #+ syntax:]
              [code]
              [poly #+ poly:])
       [type]
       )
  [.. #+ JSON]
  [../reader])

## [Values]
(def: #hidden (show-null _) (-> ..;Null Text) "null")
(do-template [<name> <type> <codec>]
  [(def: <name> (-> <type> Text) <codec>)]

  [show-boolean ..;Boolean (:: bool;Codec<Text,Bool> encode)]
  [show-number  ..;Number (:: number;Codec<Text,Real> encode)]
  [show-string  ..;String text;encode])

(def: (show-array show-json elems)
  (-> (-> JSON Text) (-> ..;Array Text))
  ($_ text/append "["
      (|> elems (Vector/map show-json) vector;to-list (text;join-with ","))
      "]"))

(def: (show-object show-json object)
  (-> (-> JSON Text) (-> ..;Object Text))
  ($_ text/append "{"
      (|> object
          d;entries
          (L/map (function [[key value]] ($_ text/append (show-string key) ":" (show-json value))))
          (text;join-with ","))
      "}"))

(def: (show-json json)
  (-> JSON Text)
  (case json
    (^template [<tag> <show>]
      (<tag> value)
      (<show> value))
    ([#..;Null    show-null]
     [#..;Boolean show-boolean]
     [#..;Number  show-number]
     [#..;String  show-string]
     [#..;Array   (show-array show-json)]
     [#..;Object  (show-object show-json)])
    ))

(def: space~
  (l;Lexer Text)
  (l;some l;space))

(def: data-sep
  (l;Lexer [Text Unit Text])
  ($_ p;seq space~ (l;this ",") space~))

(def: null~
  (l;Lexer ..;Null)
  (do p;Monad<Parser>
    [_ (l;this "null")]
    (wrap [])))

(do-template [<name> <token> <value>]
  [(def: <name>
     (l;Lexer ..;Boolean)
     (do p;Monad<Parser>
       [_ (l;this <token>)]
       (wrap <value>)))]

  [t~ "true"  true]
  [f~ "false" false]
  )

(def: boolean~
  (l;Lexer ..;Boolean)
  (p;either t~ f~))

(def: number~
  (l;Lexer ..;Number)
  (do p;Monad<Parser>
    [signed? (l;this? "-")
     digits (l;many l;decimal)
     decimals (p;default "0"
                (do @
                  [_ (l;this ".")]
                  (l;many l;decimal)))
     exp (p;default ""
           (do @
             [mark (l;one-of "eE")
              signed?' (l;this? "-")
              offset (l;many l;decimal)]
             (wrap ($_ text/append mark (if signed?' "-" "") offset))))]
    (case (real/decode ($_ text/append (if signed? "-" "") digits "." decimals exp))
      (#R;Error message)
      (p;fail message)
      
      (#R;Success value)
      (wrap value))))

(def: escaped~
  (l;Lexer Text)
  ($_ p;either
      (p;after (l;this "\\t") (p/wrap "\t"))
      (p;after (l;this "\\b") (p/wrap "\b"))
      (p;after (l;this "\\n") (p/wrap "\n"))
      (p;after (l;this "\\r") (p/wrap "\r"))
      (p;after (l;this "\\f") (p/wrap "\f"))
      (p;after (l;this "\\\"") (p/wrap "\""))
      (p;after (l;this "\\\\") (p/wrap "\\"))))

(def: string~
  (l;Lexer ..;String)
  (<| (l;enclosed ["\"" "\""])
      (loop [_ []]
        (do p;Monad<Parser>
          [chars (l;some (l;none-of "\\\""))
           stop l;peek]
          (if (text/= "\\" stop)
            (do @
              [escaped escaped~
               next-chars (recur [])]
              (wrap ($_ text/append chars escaped next-chars)))
            (wrap chars))))))

(def: (kv~ json~)
  (-> (-> Unit (l;Lexer JSON)) (l;Lexer [..;String JSON]))
  (do p;Monad<Parser>
    [key string~
     _ space~
     _ (l;this ":")
     _ space~
     value (json~ [])]
    (wrap [key value])))

(do-template [<name> <type> <open> <close> <elem-parser> <prep>]
  [(def: (<name> json~)
     (-> (-> Unit (l;Lexer JSON)) (l;Lexer <type>))
     (do p;Monad<Parser>
       [_ (l;this <open>)
        _ space~
        elems (p;sep-by data-sep <elem-parser>)
        _ space~
        _ (l;this <close>)]
       (wrap (<prep> elems))))]

  [array~  ..;Array  "[" "]" (json~ [])  vector;from-list]
  [object~ ..;Object "{" "}" (kv~ json~) (d;from-list text;Hash<Text>)]
  )

(def: (json~' _)
  (-> Unit (l;Lexer JSON))
  ($_ p;alt null~ boolean~ number~ string~ (array~ json~') (object~ json~')))

(struct: #export _ (Codec Text JSON)
  (def: encode show-json)
  (def: decode (function [input] (l;run input (json~' [])))))

## [Polytypism]
(def: #hidden _map_
  (All [a b] (-> (-> a b) (List a) (List b)))
  L/map)

(def: tag
  (-> Nat Real)
  (|>. nat-to-int int-to-real))

(def: #hidden (rec-encode non-rec)
  (All [a] (-> (-> (-> a JSON)
                   (-> a JSON))
               (-> a JSON)))
  (function [input]
    (non-rec (rec-encode non-rec) input)))

(poly: #hidden (Codec<JSON,?>//encode env :x:)
  (let [->Codec//encode (: (-> Code Code)
                           (function [.type.] (` (-> (~ .type.) ..;JSON))))]
    (with-expansions
      [<basic> (do-template [<type> <matcher> <encoder>]
                 [(do @ [_ (<matcher> :x:)] (wrap (` (: (~ (->Codec//encode (` <type>))) <encoder>))))]

                 [Unit poly;unit (function [(~ (code;symbol ["" "0"]))] #..;Null)]
                 [Bool poly;bool ..;boolean]
                 [Real poly;real ..;number]
                 [Text poly;text ..;string])]
      ($_ macro;either
          <basic>
          (with-gensyms [g!input g!key g!val]
            (do @
              [[:key: :val:] (poly;apply-2 (ident-for d;Dict) :x:)
               _ (poly;text :key:)
               .val. (Codec<JSON,?>//encode env :val:)]
              (wrap (` (: (~ (->Codec//encode (poly;to-ast env :x:)))
                          (function [(~ g!input)]
                            (|> (~ g!input)
                                d;entries
                                (;;_map_ (: (-> [Text (~ (poly;to-ast env :val:))]
                                                [Text ..;JSON])
                                            (function [[(~ g!key) (~ g!val)]]
                                              [(~ g!key)
                                               ((~ .val.) (~ g!val))])))
                                (d;from-list text;Hash<Text>)
                                #..;Object))
                          )))))
          (do @
            [:sub: (poly;apply-1 (ident-for ;Maybe) :x:)
             .sub. (Codec<JSON,?>//encode env :sub:)]
            (wrap (` (: (~ (->Codec//encode (poly;to-ast env :x:)))
                        (..;nullable (~ .sub.))))))
          (do @
            [:sub: (poly;apply-1 (ident-for ;List) :x:)
             .sub. (Codec<JSON,?>//encode env :sub:)]
            (wrap (` (: (~ (->Codec//encode (poly;to-ast env :x:)))
                        (|>. (;;_map_ (~ .sub.)) vector;from-list ..;array)))))
          (with-gensyms [g!input]
            (do @
              [members (poly;sum+ :x:)
               pattern-matching (M;map @
                                       (function [[tag :case:]]
                                         (do @
                                           [g!encode (Codec<JSON,?>//encode env :case:)]
                                           (wrap (list (` ((~ (code;nat tag)) (~ g!input)))
                                                       (` (..;json [(~ (code;real (;;tag tag)))
                                                                    ((~ g!encode) (~ g!input))]))))))
                                       (list;enumerate members))]
              (wrap (` (: (~ (->Codec//encode (poly;to-ast env :x:)))
                          (function [(~ g!input)]
                            (case (~ g!input)
                              (~@ (L/join pattern-matching)))))))))
          (do @
            [members (poly;prod+ :x:)
             #let [g!members (|> (list;size members) n.dec
                                 (list;n.range +0)
                                 (L/map (|>. nat/encode code;local-symbol)))]
             g!encoders (M;map @ (Codec<JSON,?>//encode env) members)]
            (wrap (` (: (~ (->Codec//encode (poly;to-ast env :x:)))
                        (function [[(~@ g!members)]]
                          (..;json [(~@ (L/map (function [[g!member g!encode]]
                                                 (` ((~ g!encode) (~ g!member))))
                                               (list;zip2 g!members g!encoders)))]))
                        ))))
          ## Type recursion
          (with-gensyms [g!rec]
            (do @
              [:non-rec: (poly;recursive :x:)
               #let [new-env (poly;extend-env [:x: g!rec] (list [:x: (` (;undefined))]) env)]
               .non-rec. (Codec<JSON,?>//encode new-env :non-rec:)]
              (wrap (` (: (~ (poly;gen-type new-env ->Codec//encode g!rec (list) :x:))
                          (;;rec-encode (;function [(~ g!rec)]
                                          (~ .non-rec.))))))))
          (poly;self env :x:)
          (poly;recursion env :x:)
          ## Type applications
          (do @
            [[:func: :args:] (poly;apply :x:)
             .func. (Codec<JSON,?>//encode env :func:)
             .args. (M;map @ (Codec<JSON,?>//encode env) :args:)]
            (wrap (` (: (~ (->Codec//encode (poly;to-ast env :x:)))
                        ((~ .func.) (~@ .args.))))))
          ## Bound type-vars
          (poly;bound env :x:)
          ## Polymorphism
          (with-gensyms [g!type-fun]
            (do @
              [[g!vars :non-poly:] (poly;polymorphic :x:)
               #let [new-env (poly;extend-env [:x: g!type-fun]
                                              (list;zip2 (|> g!vars list;size poly;type-var-indices) g!vars)
                                              env)]
               .non-poly. (Codec<JSON,?>//encode new-env :non-poly:)]
              (wrap (` (: (All (~ g!type-fun) [(~@ g!vars)]
                            (-> (~@ (L/map ->Codec//encode g!vars))
                                (~ (->Codec//encode (` ((~ (poly;to-ast env :x:)) (~@ g!vars)))))))
                          (function (~ g!type-fun) [(~@ g!vars)]
                            (~ .non-poly.)))))))
          ## If all else fails...
          (macro;fail ($_ text/append "Cannot create JSON encoder for: " (type;to-text :x:)))
          ))))

(poly: #hidden (Codec<JSON,?>//decode env :x:)
  (let [->Codec//decode (: (-> Code Code)
                           (function [.type.] (` (..;Reader (~ .type.)))))]
    (with-expansions
      [<basic> (do-template [<type> <matcher> <decoder>]
                 [(do @ [_ (<matcher> :x:)] (wrap (` (: (~ (->Codec//decode (` <type>))) <decoder>))))]

                 [Unit poly;unit ../reader;null]
                 [Bool poly;bool ../reader;boolean]
                 [Real poly;real ../reader;number]
                 [Text poly;text ../reader;string])]
      ($_ macro;either
          <basic>
          (do @
            [[:key: :val:] (poly;apply-2 (ident-for d;Dict) :x:)
             _ (poly;text :key:)
             .val. (Codec<JSON,?>//decode env :val:)]
            (wrap (` (: (~ (->Codec//decode (poly;to-ast env :x:)))
                        (../reader;object (~ .val.))))))
          (do @
            [:sub: (poly;apply-1 (ident-for ;Maybe) :x:)
             .sub. (Codec<JSON,?>//decode env :sub:)]
            (wrap (` (: (~ (->Codec//decode (poly;to-ast env :x:)))
                        (../reader;nullable (~ .sub.))))))
          (do @
            [:sub: (poly;apply-1 (ident-for ;List) :x:)
             .sub. (Codec<JSON,?>//decode env :sub:)]
            (wrap (` (: (~ (->Codec//decode (poly;to-ast env :x:)))
                        (../reader;array (p;some (~ .sub.)))))))
          (do @
            [members (poly;sum+ :x:)
             pattern-matching (M;map @
                                     (function [[tag :case:]]
                                       (do @
                                         [g!decode (Codec<JSON,?>//decode env :case:)]
                                         (wrap (list (` (|> (~ g!decode)
                                                            (p;after (../reader;number! (~ (code;real (;;tag tag)))))
                                                            ../reader;array))))))
                                     (list;enumerate members))]
            (wrap (` (: (~ (->Codec//decode (poly;to-ast env :x:)))
                        ($_ p;alt
                            (~@ (L/join pattern-matching)))))))
          (do @
            [members (poly;prod+ :x:)
             #let [g!members (|> (list;size members) n.dec
                                 (list;n.range +0)
                                 (L/map (|>. nat/encode code;local-symbol)))]
             g!decoders (M;map @ (Codec<JSON,?>//decode env) members)]
            (wrap (` (: (~ (->Codec//decode (poly;to-ast env :x:)))
                        (../reader;array ($_ p;seq (~@ g!decoders)))))))
          ## Type recursion
          (with-gensyms [g!rec]
            (do @
              [:non-rec: (poly;recursive :x:)
               #let [new-env (poly;extend-env [:x: g!rec] (list [:x: (` (;undefined))]) env)]
               .non-rec. (Codec<JSON,?>//decode new-env :non-rec:)]
              (wrap (` (: (~ (poly;gen-type new-env ->Codec//decode g!rec (list) :x:))
                          (p;rec (;function [(~ g!rec)]
                                   (~ .non-rec.))))))))
          (poly;self env :x:)
          (poly;recursion env :x:)
          ## Type applications
          (do @
            [[:func: :args:] (poly;apply :x:)
             .func. (Codec<JSON,?>//decode env :func:)
             .args. (M;map @ (Codec<JSON,?>//decode env) :args:)]
            (wrap (` (: (~ (->Codec//decode (poly;to-ast env :x:)))
                        ((~ .func.) (~@ .args.))))))
          ## Bound type-vars
          (do @
            [g!bound (poly;bound env :x:)]
            (wrap g!bound))
          ## Polymorphism
          (with-gensyms [g!type-fun]
            (do @
              [[g!vars :non-poly:] (poly;polymorphic :x:)
               #let [new-env (poly;extend-env [:x: g!type-fun]
                                              (list;zip2 (|> g!vars list;size poly;type-var-indices) g!vars)
                                              env)]
               .non-poly. (Codec<JSON,?>//decode new-env :non-poly:)]
              (wrap (` (: (All (~ g!type-fun) [(~@ g!vars)]
                            (-> (~@ (L/map ->Codec//decode g!vars))
                                (~ (->Codec//decode (` ((~ (poly;to-ast env :x:)) (~@ g!vars)))))))
                          (function (~ g!type-fun) [(~@ g!vars)]
                            (~ .non-poly.)))))))
          ## If all else fails...
          (macro;fail ($_ text/append "Cannot create JSON decoder for: " (type;to-text :x:)))
          ))))

(syntax: #export (Codec<JSON,?> :x:)
  {#;doc (doc "A macro for automatically producing JSON codecs."
              (type: Variant
                (#Case0 Bool)
                (#Case1 Text)
                (#Case2 Real))

              (type: Record
                {#unit Unit
                 #bool Bool
                 #real Real
                 #text Text
                 #maybe (Maybe Real)
                 #list (List Real)
                 #variant Variant
                 #tuple [Bool Real Text]
                 #dict (Dict Text Real)})

              (derived: (Codec<JSON,?> Record)))}
  (with-gensyms [g!inputs]
    (wrap (list (` (: (Codec ..;JSON (~ :x:))
                      (struct (def: (~' encode) (Codec<JSON,?>//encode (~ :x:)))
                              (def: ((~' decode) (~ g!inputs)) (../reader;run (~ g!inputs) (Codec<JSON,?>//decode (~ :x:))))
                              )))))))
