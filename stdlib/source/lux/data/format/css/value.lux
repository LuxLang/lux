(.module:
  [lux (#- All Cursor and)
   [data
    ["." color (#+ Color Pigment)]
    ["." maybe]
    ["." number]
    ["." text
     format]
    [collection
     ["." list ("list/." Functor<List>)]]]
   [type
    abstract]
   ["." macro
    ["." code]
    ["s" syntax (#+ syntax:)]]
   [world
    [net (#+ URL)]]])

(syntax: (text-identifier {identifier s.text})
  (wrap (list (code.local-identifier identifier))))

(template: (enumeration: <abstraction> <representation> <out> <sample>+)
  (abstract: #export <abstraction>
    {}

    <representation>

    (def: #export <out>
      (-> <abstraction> <representation>)
      (|>> :representation))

    (`` (do-template [<name> <value>]
          [(def: #export <name> <abstraction> (:abstraction <value>))]

          (~~ (macro.multi <sample>+))
          ))))

(template: (multi: <multi> <type> <separator>)
  (def: #export (<multi> pre post)
    (-> (Value <type>) (Value <type>) (Value <type>))
    (:abstraction (format (:representation pre)
                          <separator>
                          (:representation post)))))

(abstract: #export (Value brand)
  {}
  
  Text

  (def: #export value
    (-> (Value Any) Text)
    (|>> :representation))

  (do-template [<name> <value>]
    [(def: #export <name> Value (:abstraction <value>))]

    [initial "initial"]
    [inherit "inherit"]
    )
  
  (do-template [<brand> <alias>+ <value>+]
    [(abstract: #export <brand> {} Any)

     (`` (do-template [<name> <value>]
           [(def: #export <name>
              (Value <brand>)
              (:abstraction <value>))]
           
           (~~ (macro.multi <alias>+))))

     (with-expansions [<rows> (macro.multi <value>+)]
       (do-template [<value>]
         [(`` (def: #export (~~ (text-identifier <value>))
                (Value <brand>)
                (:abstraction <value>)))]
         
         <rows>))]

    [All
     []
     [["unset"]]]

    [Length
     []
     []]

    [Time
     []
     []]

    [Thickness
     []
     [["medium"]
      ["thin"]
      ["thick"]]]

    [Slice
     []
     [["fill"]]]

    [Alignment
     [[auto-alignment "auto"]]
     [["stretch"]
      ["center"]
      ["flex-start"]
      ["flex-end"]
      ["baseline"]
      ["space-between"]
      ["space-around"]]]

    [Direction
     [[normal-direction "normal"]]
     [["reverse"]
      ["alternate"]
      ["alternate-reverse"]]]

    [Animation
     []
     []]
    
    [Animation-Fill
     [[fill-forwards "forwards"]
      [fill-backwards "backwards"]
      [fill-both "both"]]
     []]

    [Column-Fill
     []
     [["balance"]
      ["auto"]]]

    [Column-Span
     []
     [["all"]]]

    [Iteration
     []
     [["infinite"]]]

    [Count
     []
     []]

    [Play
     []
     [["paused"]
      ["running"]]]

    [Timing
     []
     [["linear"]
      ["ease"]
      ["ease-in"]
      ["ease-out"]
      ["ease-in-out"]
      ["step-start"]
      ["step-end"]]]

    [Visibility
     [[invisible "hidden"]]
     [["visible"]]]

    [Attachment
     []
     [["scroll"]
      ["fixed"]
      ["local"]]]

    [Blend
     [[normal-blend "normal"]]
     [["multiply"]
      ["screen"]
      ["overlay"]
      ["darken"]
      ["lighten"]
      ["color-dodge"]
      ["saturation"]
      ["color"]
      ["luminosity"]]]

    [Span
     []
     [["border-box"]
      ["padding-box"]
      ["content-box"]]]

    [Image
     [[no-image "none"]]
     []]

    [Repeat
     [[stretch-repeat "stretch"]]
     [["repeat"]
      ["repeat-x"]
      ["repeat-y"]
      ["no-repeat"]
      ["space"]
      ["round"]]]

    [Location
     [[left-top "left top"]
      [left-center "left center"]
      [left-bottom "left bottom"]
      [right-top "right top"]
      [right-center "right center"]
      [right-bottom "right bottom"]
      [center-top "center top"]
      [center-center "center center"]
      [center-bottom "center bottom"]]
     []]

    [Area
     []
     [["cover"]
      ["contain"]]]

    [Border
     []
     [["hidden"]
      ["dotted"]
      ["dashed"]
      ["solid"]
      ["double"]
      ["groove"]
      ["ridge"]
      ["inset"]
      ["outset"]]]

    [Collapse
     []
     [["separate"]
      ["collapse"]]]

    [Break
     []
     [["slice"]
      ["clone"]]]

    [Caption
     []
     [["top"]
      ["bottom"]]]

    [Clear
     [[clear-left "left"]
      [clear-right "right"]
      [clear-both "both"]]
     []]

    [Counter
     []
     []]

    [Content
     []
     [["open-quote"]
      ["close-quote"]
      ["no-open-quote"]
      ["no-close-quote"]]]

    [Cursor
     [[horizontal-text "text"]]
     [["alias"]
      ["all-scroll"]
      ["cell"]
      ["context-menu"]
      ["col-resize"]
      ["copy"]
      ["crosshair"]
      ["default"]
      ["e-resize"]
      ["ew-resize"]
      ["grab"]
      ["grabbing"]
      ["help"]
      ["move"]
      ["n-resize"]
      ["ne-resize"]
      ["nesw-resize"]
      ["ns-resize"]
      ["nw-resize"]
      ["nwse-resize"]
      ["no-drop"]
      ["none"]
      ["not-allowed"]
      ["pointer"]
      ["progress"]
      ["row-resize"]
      ["s-resize"]
      ["se-resize"]
      ["sw-resize"]
      ["vertical-text"]
      ["w-resize"]
      ["wait"]
      ["zoom-in"]
      ["zoom-out"]]]

    [Shadow
     []
     []]

    [Clip
     []
     []]
    )

  (def: value-separator ",")

  (def: (apply name inputs)
    (-> Text (List Text) Value)
    (|> inputs
        (text.join-with ..value-separator)
        (text.enclose ["(" ")"])
        (format name)
        :abstraction))

  (enumeration: Step Text
    step
    [[start "start"]
     [end "end"]])

  (def: #export (steps intervals step)
    (-> Nat Step (Value Timing))
    (..apply "steps" (list (%n intervals) (..step step))))

  (def: #export (cubic-bezier p0 p1 p2 p3)
    (-> Frac Frac Frac Frac (Value Timing))
    (|> (list p0 p1 p2 p3)
        (list/map %f)
        (..apply "cubic-bezier")))

  (def: #export iteration
    (-> Nat (Value Iteration))
    (|>> %n :abstraction))

  (def: #export count
    (-> Nat (Value Count))
    (|>> %n :abstraction))

  (def: #export animation
    (-> Text (Value Animation))
    (|>> :abstraction))

  (def: #export (rgb color)
    (-> Color (Value Color))
    (let [[red green blue] (color.to-rgb color)]
      (..apply "rgb" (list (%n red)
                           (%n green)
                           (%n blue)))))

  (def: #export (rgba pigment)
    (-> Pigment (Value Color))
    (let [(^slots [#color.color #color.alpha]) pigment
          [red green blue] (color.to-rgb color)]
      (..apply "rgba" (list (%n red)
                            (%n green)
                            (%n blue)
                            (if (r/= (:: number.Interval<Rev> top) alpha)
                              "1.0"
                              (format "0" (%r alpha)))))))

  (do-template [<name> <suffix>]
    [(def: #export (<name> value)
       (-> Frac (Value Length))
       (:abstraction (format (%f value) <suffix>)))]

    [em "em"]
    [ex "ex"]
    [rem "rem"]
    [ch "ch"]
    [vw "vw"]
    [vh "vh"]
    [vmin "vmin"]
    [vmax "vmax"]
    [% "%"]
    [cm "cm"]
    [mm "mm"]
    [in "in"]
    [px "px"]
    [pt "pt"]
    [pc "pc"]
    )

  (def: (%int value)
    (Format Int)
    (if (i/< +0 value)
      (%i value)
      (%n (.nat value))))

  (do-template [<name> <suffix>]
    [(def: #export (<name> value)
       (-> Int (Value Time))
       (:abstraction (format (if (i/< +0 value)
                               (%i value)
                               (%n (.nat value)))
                             <suffix>)))]

    
    [seconds "s"]
    [milli-seconds "ms"]
    )

  (def: #export thickness
    (-> (Value Length) (Value Thickness))
    (|>> :transmutation))

  (def: #export slice-number/1
    (-> Nat (Value Slice))
    (|>> %n :abstraction))

  (def: slice-separator " ")

  (def: #export (slice-number/2 horizontal vertical)
    (-> Nat Nat (Value Slice))
    (:abstraction (format (%n horizontal) ..slice-separator
                          (%n vertical))))

  (def: percent-limit Nat (.inc 100))

  (def: (percentage value)
    (-> Nat Text)
    (format (%n (n/% percent-limit value)) "%"))

  (def: #export slice-percent/1
    (-> Nat (Value Slice))
    (|>> percentage :abstraction))

  (def: #export (slice-percent/2 horizontal vertical)
    (-> Nat Nat (Value Slice))
    (:abstraction (format (..percentage horizontal) ..slice-separator
                          (..percentage vertical))))

  (def: length-separator " ")

  (do-template [<name> <type>]
    [(def: #export (<name> horizontal vertical)
       (-> (Value Length) (Value Length) (Value <type>))
       (:abstraction (format (:representation horizontal)
                             ..length-separator
                             (:representation vertical))))]

    [location Location]
    [area Area]
    )

  (def: #export (area/1 length)
    (-> (Value Length) (Value Area))
    (..area length length))

  (def: #export image
    (-> URL (Value Image))
    (|>> %t
         (list)
         (..apply "url")))

  (abstract: #export Stop
    {}

    Text

    (def: #export stop
      (-> (Value Color) Stop)
      (|>> (:representation Value) (:abstraction Stop)))

    (def: stop-separator " ")

    (def: #export (single-stop length color)
      (-> (Value Length) (Value Color) Stop)
      (:abstraction (format (:representation Value color) ..stop-separator
                            (:representation Value length))))

    (def: #export (double-stop start end color)
      (-> (Value Length) (Value Length) (Value Color) Stop)
      (:abstraction (format (:representation Value color) ..stop-separator
                            (:representation Value start) ..stop-separator
                            (:representation Value end))))

    (abstract: #export Hint
      {}

      Text

      (def: #export hint
        (-> (Value Length) Hint)
        (|>> (:representation Value) (:abstraction Hint)))

      (def: (with-hint [hint stop])
        (-> [(Maybe Hint) Stop] Text)
        (case hint
          #.None
          (:representation Stop stop)
          
          (#.Some hint)
          (format (:representation Hint hint) ..value-separator (:representation Stop stop))))))

  (type: #export (List/1 a)
    [a (List a)])

  (abstract: #export Angle
    {}
    
    Text

    (def: #export (turn value)
      (-> Rev Angle)
      (:abstraction (format (%r value) "turn")))

    (def: degree-limit Nat 360)
    
    (def: #export (degree value)
      (-> Nat Angle)
      (:abstraction (format (%n (n/% ..degree-limit value)) "deg")))

    (do-template [<name> <degree>]
      [(def: #export <name> Angle (..degree <degree>))]
      
      [to-top 0]
      [to-right 90]
      [to-bottom 180]
      [to-left 270]
      )

    (do-template [<name> <function>]
      [(def: #export (<name> angle start next)
         (-> Angle Stop (List/1 [(Maybe Hint) Stop]) (Value Image))
         (let [[now after] next]
           (..apply <function> (list& (:representation Angle angle)
                                      (with-hint now)
                                      (list/map with-hint after)))))]

      [linear-gradient "linear-gradient"]
      [repeating-linear-gradient "repeating-linear-gradient"]
      )
    )

  (enumeration: Shape Text
    shape
    [[ellipse "ellipse"]
     [circle "circle"]])

  (enumeration: Extent Text
    extent
    [[closest-side "closest-side"]
     [closest-corner "closest-corner"]
     [farthest-side "farthest-side"]
     [farthest-corner "farthest-corner"]])

  (do-template [<name> <function>]
    [(def: #export (<name> shape extent location start next)
       (-> Shape (Maybe Extent) (Value Location)
           Stop (List/1 [(Maybe Hint) Stop])
           (Value Image))
       (let [after-extent (format "at " (:representation location))
             with-extent (case extent
                           (#.Some extent)
                           (format (..extent extent) " " after-extent)
                           
                           #.None
                           after-extent)
             where (format (..shape shape) " " with-extent)
             [now after] next]
         (..apply <function> (list& (..shape shape)
                                    (with-hint now)
                                    (list/map with-hint after)))))]
    
    [radial-gradient "radial-gradient"]
    [repeating-radial-gradient "repeating-radial-gradient"]
    )

  (def: default-length (px +0.0))

  (def: #export (shadow horizontal vertical blur spread color inset?)
    (-> (Value Length) (Value Length)
        (Maybe (Value Length)) (Maybe (Value Length))
        (Value Color) Bit
        (Value Shadow))
    (let [with-inset (if inset?
                       (list "inset")
                       (list))]
      (|> (list& (:representation horizontal)
                 (:representation vertical)
                 (|> blur (maybe.default ..default-length) :representation)
                 (|> spread (maybe.default ..default-length) :representation)
                 (:representation color)
                 with-inset)
          (text.join-with " ")
          :abstraction)))

  (type: #export Rectangle
    {#top (Value Length)
     #right (Value Length)
     #bottom (Value Length)
     #left (Value Length)})

  (def: #export (clip rectangle)
    (-> Rectangle (Value Clip))
    (`` (..apply "rect" (list (~~ (do-template [<side>]
                                    [(:representation (get@ <side> rectangle))]

                                    [#top] [#right] [#bottom] [#left]))))))

  (def: #export counter
    (-> Text (Value Counter))
    (|>> :abstraction))

  (def: #export current-count
    (-> (Value Counter) (Value Content))
    (|>> :representation (list) (..apply "counter")))

  (def: #export text
    (-> Text (Value Content))
    (|>> %t :abstraction))

  (def: #export attribute
    (-> Text (Value Content))
    (|>> (list) (..apply "attr")))

  (def: #export media
    (-> URL (Value Content))
    (|>> (list) (..apply "url")))

  (multi: multi-image Image ",")
  (multi: multi-shadow Shadow ",")
  (multi: multi-content Content " ")
  )
