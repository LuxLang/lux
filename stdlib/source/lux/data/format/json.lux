(.module: {#.doc (.doc "Functionality for reading and writing values in the JSON format."
                       "For more information, please see: http://www.json.org/")}
  [lux #*
   ["." meta (#+ monad with-gensyms)]
   [abstract
    [equivalence (#+ Equivalence)]
    [codec (#+ Codec)]
    [predicate (#+ Predicate)]
    ["." monad (#+ do)]]
   [control
    pipe
    ["." try (#+ Try)]
    ["<>" parser ("#\." monad)
     ["<.>" text (#+ Parser)]]]
   [data
    ["." bit]
    ["." maybe]
    ["." product]
    ["." text ("#\." equivalence monoid)]
    [number
     ["n" nat]
     ["f" frac ("#\." decimal)]]
    [collection
     ["." list ("#\." fold functor)]
     ["." row (#+ Row row) ("#\." monad)]
     ["." dictionary (#+ Dictionary)]]]
   [macro
    [syntax (#+ syntax:)]
    ["." code]]])

(template [<name> <type>]
  [(type: #export <name>
     <type>)]

  [Null    Any]
  [Boolean Bit]
  [Number  Frac]
  [String  Text]
  )

(type: #export #rec JSON
  (#Null    Null)
  (#Boolean Boolean)
  (#Number  Number)
  (#String  String)
  (#Array   (Row JSON))
  (#Object  (Dictionary String JSON)))

(template [<name> <type>]
  [(type: #export <name>
     <type>)]

  [Array  (Row JSON)]
  [Object (Dictionary String JSON)]
  )

(def: #export null?
  (Predicate JSON)
  (|>> (case> #Null true
              _ false)))

(def: #export object
  (-> (List [String JSON]) JSON)
  (|>> (dictionary.from-list text.hash) #..Object))

(syntax: #export (json token)
  {#.doc (doc "A simple way to produce JSON literals."
              (json #null)
              (json #1)
              (json +123.456)
              (json "this is a string")
              (json ["this" "is" "an" "array"])
              (json {"this" "is"
                     "an" "object"}))}
  (let [(^open ".") ..monad
        wrapper (function (_ x) (` (..json (~ x))))]
    (case token
      (^template [<ast-tag> <ctor> <json-tag>]
        [[_ (<ast-tag> value)]
         (wrap (list (` (: JSON (<json-tag> (~ (<ctor> value)))))))])
      ([#.Bit  code.bit  #..Boolean]
       [#.Frac code.frac #..Number]
       [#.Text code.text #..String])

      [_ (#.Tag ["" "null"])]
      (wrap (list (` (: JSON #..Null))))

      [_ (#.Tuple members)]
      (wrap (list (` (: JSON (#..Array ((~! row) (~+ (list\map wrapper members))))))))

      [_ (#.Record pairs)]
      (do {! ..monad}
        [pairs' (monad.map !
                           (function (_ [slot value])
                             (case slot
                               [_ (#.Text key-name)]
                               (wrap (` [(~ (code.text key-name)) (~ (wrapper value))]))

                               _
                               (meta.fail "Wrong syntax for JSON object.")))
                           pairs)]
        (wrap (list (` (: JSON (#..Object ((~! dictionary.from-list)
                                           (~! text.hash)
                                           (list (~+ pairs')))))))))
      
      _
      (wrap (list token)))))

(def: #export (fields json)
  {#.doc "Get all the fields in a JSON object."}
  (-> JSON (Try (List String)))
  (case json
    (#Object obj)
    (#try.Success (dictionary.keys obj))

    _
    (#try.Failure ($_ text\compose "Cannot get the fields of a non-object."))))

(def: #export (get key json)
  {#.doc "A JSON object field getter."}
  (-> String JSON (Try JSON))
  (case json
    (#Object obj)
    (case (dictionary.get key obj)
      (#.Some value)
      (#try.Success value)

      #.None
      (#try.Failure ($_ text\compose "Missing field '" key "' on object.")))

    _
    (#try.Failure ($_ text\compose "Cannot get field '" key "' on a non-object."))))

(def: #export (set key value json)
  {#.doc "A JSON object field setter."}
  (-> String JSON JSON (Try JSON))
  (case json
    (#Object obj)
    (#try.Success (#Object (dictionary.put key value obj)))

    _
    (#try.Failure ($_ text\compose "Cannot set field '" key "' on a non-object."))))

(template [<name> <tag> <type> <desc>]
  [(def: #export (<name> key json)
     {#.doc (code.text ($_ text\compose "A JSON object field getter for " <desc> "."))}
     (-> Text JSON (Try <type>))
     (case (get key json)
       (#try.Success (<tag> value))
       (#try.Success value)

       (#try.Success _)
       (#try.Failure ($_ text\compose "Wrong value type at key: " key))

       (#try.Failure error)
       (#try.Failure error)))]

  [get-boolean #Boolean Boolean "booleans"]
  [get-number  #Number  Number  "numbers"]
  [get-string  #String  String  "strings"]
  [get-array   #Array   Array   "arrays"]
  [get-object  #Object  Object  "objects"]
  )

(structure: #export equivalence
  (Equivalence JSON)
  
  (def: (= x y)
    (case [x y]
      [#Null #Null]
      #1

      (^template [<tag> <struct>]
        [[(<tag> x') (<tag> y')]
         (:: <struct> = x' y')])
      ([#Boolean bit.equivalence]
       [#Number  f.equivalence]
       [#String  text.equivalence])

      [(#Array xs) (#Array ys)]
      (and (n.= (row.size xs) (row.size ys))
           (list\fold (function (_ idx prev)
                        (and prev
                             (maybe.default #0
                                            (do maybe.monad
                                              [x' (row.nth idx xs)
                                               y' (row.nth idx ys)]
                                              (wrap (= x' y'))))))
                      #1
                      (list.indices (row.size xs))))
      
      [(#Object xs) (#Object ys)]
      (and (n.= (dictionary.size xs) (dictionary.size ys))
           (list\fold (function (_ [xk xv] prev)
                        (and prev
                             (case (dictionary.get xk ys)
                               #.None   #0
                               (#.Some yv) (= xv yv))))
                      #1
                      (dictionary.entries xs)))
      
      _
      #0)))

############################################################
############################################################
############################################################

(def: (format-null _)
  (-> Null Text)
  "null")

(def: format-boolean
  (-> Boolean Text)
  (|>> (case>
        #0 "false"
        #1 "true")))

(def: format-number
  (-> Number Text)
  (|>> (case>
        (^or +0.0 -0.0) "0.0"
        value (let [raw (:: f.decimal encode value)]
                (if (f.< +0.0 value)
                  raw
                  (|> raw (text.split 1) maybe.assume product.right))))))

(def: escape "\")
(def: escaped-dq (text\compose ..escape text.double-quote))

(def: format-string
  (-> String Text)
  (|>> (text.replace-all text.double-quote ..escaped-dq)
       (text.enclose [text.double-quote text.double-quote])))

(template [<token> <name>]
  [(def: <name>
     Text
     <token>)]

  ["," separator]
  [":" entry-separator]

  ["[" open-array]
  ["]" close-array]

  ["{" open-object]
  ["}" close-object]
  )

(def: (format-array format)
  (-> (-> JSON Text) (-> Array Text))
  (|>> (row\map format)
       row.to-list
       (text.join-with ..separator)
       (text.enclose [..open-array ..close-array])))

(def: (format-kv format [key value])
  (-> (-> JSON Text) (-> [String JSON] Text))
  ($_ text\compose
      (..format-string key)
      ..entry-separator
      (format value)
      ))

(def: (format-object format)
  (-> (-> JSON Text) (-> Object Text))
  (|>> dictionary.entries
       (list\map (..format-kv format))
       (text.join-with ..separator)
       (text.enclose [..open-object ..close-object])))

(def: #export (format json)
  (-> JSON Text)
  (case json
    (^template [<tag> <format>]
      [(<tag> value)
       (<format> value)])
    ([#Null    ..format-null]
     [#Boolean ..format-boolean]
     [#Number  ..format-number]
     [#String  ..format-string]
     [#Array   (..format-array format)]
     [#Object  (..format-object format)])
    ))

############################################################
############################################################
############################################################

(def: parse-space
  (Parser Text)
  (<text>.some <text>.space))

(def: parse-separator
  (Parser [Text Any Text])
  ($_ <>.and
      ..parse-space
      (<text>.this ..separator)
      ..parse-space))

(def: parse-null
  (Parser Null)
  (do <>.monad
    [_ (<text>.this "null")]
    (wrap [])))

(template [<name> <token> <value>]
  [(def: <name>
     (Parser Boolean)
     (do <>.monad
       [_ (<text>.this <token>)]
       (wrap <value>)))]

  [parse-true  "true"  #1]
  [parse-false "false" #0]
  )

(def: parse-boolean
  (Parser Boolean)
  ($_ <>.either
      ..parse-true
      ..parse-false))

(def: parse-number
  (Parser Number)
  (do {! <>.monad}
    [signed? (<>.parses? (<text>.this "-"))
     digits (<text>.many <text>.decimal)
     decimals (<>.default "0"
                          (do !
                            [_ (<text>.this ".")]
                            (<text>.many <text>.decimal)))
     exp (<>.default ""
                     (do !
                       [mark (<text>.one-of "eE")
                        signed?' (<>.parses? (<text>.this "-"))
                        offset (<text>.many <text>.decimal)]
                       (wrap ($_ text\compose mark (if signed?' "-" "") offset))))]
    (case (f\decode ($_ text\compose (if signed? "-" "") digits "." decimals exp))
      (#try.Failure message)
      (<>.fail message)
      
      (#try.Success value)
      (wrap value))))

(def: parse-escaped
  (Parser Text)
  ($_ <>.either
      (<>.after (<text>.this "\t")
                (<>\wrap text.tab))
      (<>.after (<text>.this "\b")
                (<>\wrap text.back-space))
      (<>.after (<text>.this "\n")
                (<>\wrap text.new-line))
      (<>.after (<text>.this "\r")
                (<>\wrap text.carriage-return))
      (<>.after (<text>.this "\f")
                (<>\wrap text.form-feed))
      (<>.after (<text>.this (text\compose "\" text.double-quote))
                (<>\wrap text.double-quote))
      (<>.after (<text>.this "\\")
                (<>\wrap "\"))))

(def: parse-string
  (Parser String)
  (<| (<text>.enclosed [text.double-quote text.double-quote])
      (loop [_ []])
      (do {! <>.monad}
        [chars (<text>.some (<text>.none-of (text\compose "\" text.double-quote)))
         stop <text>.peek])
      (if (text\= "\" stop)
        (do !
          [escaped parse-escaped
           next-chars (recur [])]
          (wrap ($_ text\compose chars escaped next-chars)))
        (wrap chars))))

(def: (parse-kv parse-json)
  (-> (Parser JSON) (Parser [String JSON]))
  (do <>.monad
    [key ..parse-string
     _ ..parse-space
     _ (<text>.this ..entry-separator)
     _ ..parse-space
     value parse-json]
    (wrap [key value])))

(template [<name> <type> <open> <close> <elem-parser> <prep>]
  [(def: (<name> parse-json)
     (-> (Parser JSON) (Parser <type>))
     (do <>.monad
       [_ (<text>.this <open>)
        _ parse-space
        elems (<>.sep-by ..parse-separator <elem-parser>)
        _ parse-space
        _ (<text>.this <close>)]
       (wrap (<prep> elems))))]

  [parse-array  Array  ..open-array ..close-array parse-json  row.from-list]
  [parse-object Object ..open-object ..close-object (parse-kv parse-json) (dictionary.from-list text.hash)]
  )

(def: parse-json
  (Parser JSON)
  (<>.rec
   (function (_ parse-json)
     ($_ <>.or
         parse-null
         parse-boolean
         parse-number
         parse-string
         (parse-array parse-json)
         (parse-object parse-json)))))

(structure: #export codec
  (Codec Text JSON)
  
  (def: encode ..format)
  (def: decode (<text>.run parse-json)))
