(;module: {#;doc "Functionality for reading, generating and processing values in the JSON format.

                  For more information, please see: http://www.json.org/"}
  lux
  (lux (control functor
                applicative
                monad
                eq
                codec)
       (data [bool]
             [text "Text/" Eq<Text> Monoid<Text>]
             text/format
             (text [lexer #+ Lexer Monad<Lexer>])
             [number #* "Real/" Codec<Text,Real>]
             maybe
             [char "Char/" Eq<Char> Codec<Text,Char>]
             ["R" result #- fail]
             [sum]
             [product]
             (coll [list "" Fold<List> "List/" Monad<List>]
                   [vector #+ Vector vector "Vector/" Monad<Vector>]
                   [dict #+ Dict]))
       [macro #+ Monad<Lux> with-gensyms]
       (macro [syntax #+ syntax:]
              [code]
              [poly #+ poly:])
       [type]
       ))

## [Types]
(do-template [<name> <type>]
  [(type: #export <name> <type>)]

  [Null    Unit]
  [Boolean Bool]
  [Number  Real]
  [String  Text]
  )

(type: #export #rec JSON
  (#Null    Null)
  (#Boolean Boolean)
  (#Number  Number)
  (#String  String)
  (#Array   (Vector JSON))
  (#Object  (Dict String JSON)))

(do-template [<name> <type>]
  [(type: #export <name> <type>)]

  [Array   (Vector JSON)]
  [Object  (Dict String JSON)]
  )

(type: #export (Parser a)
  {#;doc "JSON parsers."}
  (-> JSON (Result a)))

(type: #export (Gen a)
  {#;doc "JSON generators."}
  (-> a JSON))

## [Syntax]
(syntax: #export (json token)
  {#;doc (doc "A way to produce JSON literals."
              (json true)
              (json 123)
              (json 456.78)
              (json "Some text")
              (json #null)
              (json ["this" "is" "an" "array"])
              (json {"this" "is"
                     "an" "object"}))}
  (let [(^open) Monad<Lux>
        wrapper (function [x] (` (;;json (~ x))))]
    (case token
      (^template [<ast-tag> <ctor> <json-tag>]
        [_ (<ast-tag> value)]
        (wrap (list (` (: JSON (<json-tag> (~ (<ctor> value))))))))
      ([#;Bool code;bool            #Boolean]
       [#;Int  (|>. int-to-real code;real) #Number]
       [#;Real code;real            #Number]
       [#;Text code;text            #String])

      [_ (#;Tag ["" "null"])]
      (wrap (list (` (: JSON #Null))))

      [_ (#;Tuple members)]
      (wrap (list (` (: JSON (#Array (vector (~@ (List/map wrapper members))))))))

      [_ (#;Record pairs)]
      (do Monad<Lux>
        [pairs' (mapM @
                      (function [[slot value]]
                        (case slot
                          [_ (#;Text key-name)]
                          (wrap (` [(~ (code;text key-name)) (~ (wrapper value))]))

                          _
                          (macro;fail "Wrong syntax for JSON object.")))
                      pairs)]
        (wrap (list (` (: JSON (#Object (dict;from-list text;Hash<Text> (list (~@ pairs')))))))))
      
      _
      (wrap (list token))
      )))

## [Values]
(def: #hidden (show-null _) (-> Null Text) "null")
(do-template [<name> <type> <codec>]
  [(def: <name> (-> <type> Text) (:: <codec> encode))]

  [show-boolean Boolean bool;Codec<Text,Bool>]
  [show-number  Number number;Codec<Text,Real>]
  [show-string  String text;Codec<Text,Text>])

(def: (show-array show-json elems)
  (-> (-> JSON Text) (-> Array Text))
  (format "["
          (|> elems (Vector/map show-json) vector;to-list (text;join-with ","))
          "]"))

(def: (show-object show-json object)
  (-> (-> JSON Text) (-> Object Text))
  (format "{"
          (|> object
              dict;entries
              (List/map (function [[key value]] (format (:: text;Codec<Text,Text> encode key) ":" (show-json value))))
              (text;join-with ","))
          "}"))

(def: (show-json json)
  (-> JSON Text)
  (case json
    (^template [<tag> <show>]
      (<tag> value)
      (<show> value))
    ([#Null    show-null]
     [#Boolean show-boolean]
     [#Number  show-number]
     [#String  show-string]
     [#Array   (show-array show-json)]
     [#Object  (show-object show-json)])
    ))

(def: #export null
  {#;doc "The null JSON value."}
  JSON
  #Null)

(def: #export (fields json)
  {#;doc "Get all the fields in a JSON object."}
  (-> JSON (Result (List String)))
  (case json
    (#Object obj)
    (#R;Success (dict;keys obj))

    _
    (#R;Error (format "Cannot get the fields of a non-object."))))

(def: #export (get key json)
  {#;doc "A JSON object field getter."}
  (-> String JSON (Result JSON))
  (case json
    (#Object obj)
    (case (dict;get key obj)
      (#;Some value)
      (#R;Success value)

      #;None
      (#R;Error (format "Missing field " (show-string key) " on object.")))

    _
    (#R;Error (format "Cannot get field " (show-string key) " of a non-object."))))

(def: #export (set key value json)
  {#;doc "A JSON object field setter."}
  (-> String JSON JSON (Result JSON))
  (case json
    (#Object obj)
    (#R;Success (#Object (dict;put key value obj)))

    _
    (#R;Error (format "Cannot set field " (show-string key) " of a non-object."))))

(do-template [<name> <tag> <type> <desc>]
  [(def: #export (<name> key json)
     {#;doc (#;TextA (format "A JSON object field getter for " <desc> "."))}
     (-> Text JSON (Result <type>))
     (case (get key json)
       (#R;Success (<tag> value))
       (#R;Success value)

       (#R;Success _)
       (#R;Error (format "Wrong value type at key " (show-string key)))

       (#R;Error error)
       (#R;Error error)))]

  [get-boolean #Boolean Boolean "booleans"]
  [get-number  #Number  Number  "numbers"]
  [get-string  #String  String  "strings"]
  [get-array   #Array   Array   "arrays"]
  [get-object  #Object  Object  "objects"]
  )

(do-template [<name> <type> <tag> <desc>]
  [(def: #export (<name> value)
     {#;doc (#;TextA (format "A JSON generator for " <desc> "."))}
     (Gen <type>)
     (<tag> value))]

  [gen-boolean Boolean #Boolean "booleans"]
  [gen-number  Number  #Number  "numbers"]
  [gen-string  String  #String  "strings"]
  [gen-array   Array   #Array   "arrays"]
  [gen-object  Object  #Object  "objects"]
  )

(def: #export (gen-nullable gen)
  {#;doc "Builds a JSON generator for potentially inexistent values."}
  (All [a] (-> (Gen a) (Gen (Maybe a))))
  (function [elem]
    (case elem
      #;None         #Null
      (#;Some value) (gen value))))

## Lexers
(def: space~
  (Lexer Text)
  (lexer;some' lexer;space))

(def: data-sep
  (Lexer [Text Char Text])
  ($_ lexer;seq space~ (lexer;char #",") space~))

(def: null~
  (Lexer Null)
  (do Monad<Lexer>
    [_ (lexer;text "null")]
    (wrap [])))

(do-template [<name> <token> <value>]
  [(def: <name>
     (Lexer Boolean)
     (do Monad<Lexer>
       [_ (lexer;text <token>)]
       (wrap <value>)))]

  [t~ "true"  true]
  [f~ "false" false]
  )

(def: boolean~
  (Lexer Boolean)
  (lexer;either t~ f~))

(def: number~
  (Lexer Number)
  (do Monad<Lexer>
    [?sign (: (Lexer Text)
              (lexer;default ""
                (lexer;text "-")))
     digits (: (Lexer Text)
               (lexer;many' lexer;digit))
     decimals (: (Lexer Text)
                 (lexer;default "0"
                   (do @
                     [_ (lexer;text ".")]
                     (lexer;many' lexer;digit))))
     exp (: (Lexer Text)
            (lexer;default ""
              (do @
                [mark (lexer;either (lexer;text "e") (lexer;text "E"))
                 sign (lexer;default "" (lexer;text "-"))
                 offset (lexer;many' lexer;digit)]
                (wrap (format mark sign offset)))))]
    (case (: (Result Real)
             (Real/decode (format ?sign digits "." decimals exp)))
      (#R;Error message)
      (lexer;fail message)
      
      (#R;Success value)
      (wrap value))))

(def: (un-escape escaped)
  (-> Char Text)
  (case escaped
    #"t"  "\t"
    #"b"  "\b"
    #"n"  "\n"
    #"r"  "\r"
    #"f"  "\f"
    #"\"" "\""
    #"\\" "\\"
    _     ""))

(def: string-body~
  (Lexer Text)
  (loop [_ []]
    (do Monad<Lexer>
      [chars (lexer;some' (lexer;none-of "\\\""))
       stop-char lexer;peek]
      (if (Char/= #"\\" stop-char)
        (do @
          [_ lexer;any
           escaped lexer;any
           next-chars (recur [])]
          (wrap (format chars (un-escape escaped) next-chars)))
        (wrap chars)))))

(def: string~
  (Lexer String)
  (do Monad<Lexer>
    [_ (lexer;text "\"")
     string-body string-body~
     _ (lexer;text "\"")]
    (wrap string-body)))

(def: (kv~ json~)
  (-> (-> Unit (Lexer JSON)) (Lexer [String JSON]))
  (do Monad<Lexer>
    [key string~
     _ space~
     _ (lexer;char #":")
     _ space~
     value (json~ [])]
    (wrap [key value])))

(do-template [<name> <type> <open> <close> <elem-parser> <prep>]
  [(def: (<name> json~)
     (-> (-> Unit (Lexer JSON)) (Lexer <type>))
     (do Monad<Lexer>
       [_ (lexer;char <open>)
        _ space~
        elems (lexer;sep-by data-sep <elem-parser>)
        _ space~
        _ (lexer;char <close>)]
       (wrap (<prep> elems))))]

  [array~  Array  #"[" #"]" (json~ [])  vector;from-list]
  [object~ Object #"{" #"}" (kv~ json~) (dict;from-list text;Hash<Text>)]
  )

(def: (json~' _)
  (-> Unit (Lexer JSON))
  ($_ lexer;alt null~ boolean~ number~ string~ (array~ json~') (object~ json~')))

## [Structures]
(struct: #export _ (Functor Parser)
  (def: (map f ma)
    (function [json]
      (case (ma json)
        (#R;Error msg)
        (#R;Error msg)

        (#R;Success a)
        (#R;Success (f a))))))

(struct: #export _ (Applicative Parser)
  (def: functor Functor<Parser>)

  (def: (wrap x json)
    (#R;Success x))

  (def: (apply ff fa)
    (function [json]
      (case (ff json)
        (#R;Success f)
        (case (fa json)
          (#R;Success a)
          (#R;Success (f a))

          (#R;Error msg)
          (#R;Error msg))

        (#R;Error msg)
        (#R;Error msg)))))

(struct: #export _ (Monad Parser)
  (def: applicative Applicative<Parser>)

  (def: (join mma)
    (function [json]
      (case (mma json)
        (#R;Error msg)
        (#R;Error msg)

        (#R;Success ma)
        (ma json)))))

## [Values]
## Syntax
(do-template [<name> <type> <tag> <desc> <pre>]
  [(def: #export (<name> json)
     {#;doc (#;TextA (format "Reads a JSON value as " <desc> "."))}
     (Parser <type>)
     (case json
       (<tag> value)
       (#R;Success (<pre> value))

       _
       (#R;Error (format "JSON value is not " <desc> ": " (show-json json)))))]

  [unit Unit #Null    "unit"    id]
  [bool Bool #Boolean "bool" id]
  [int  Int  #Number  "int"  real-to-int]
  [real Real #Number  "real"  id]
  [text Text #String  "text"  id]
  )

(do-template [<test> <check> <type> <eq> <codec> <tag> <desc> <pre>]
  [(def: #export (<test> test json)
     {#;doc (#;TextA (format "Asks whether a JSON value is a " <desc> "."))}
     (-> <type> (Parser Bool))
     (case json
       (<tag> value)
       (#R;Success (:: <eq> = test (<pre> value)))

       _
       (#R;Error (format "JSON value is not a " <desc> ": " (show-json json)))))

   (def: #export (<check> test json)
     {#;doc (#;TextA (format "Ensures a JSON value is a " <desc> "."))}
     (-> <type> (Parser Unit))
     (case json
       (<tag> value)
       (let [value (<pre> value)]
         (if (:: <eq> = test value)
           (#R;Success [])
           (#R;Error (format "Value mismatch: "
                             (:: <codec> encode test) "=/=" (:: <codec> encode value)))))

       _
       (#R;Error (format "JSON value is not a " <desc> ": " (show-json json)))))]

  [bool? bool! Bool bool;Eq<Bool>   bool;Codec<Text,Bool>   #Boolean "boolean" id]
  [int?  int!  Int  number;Eq<Int>  number;Codec<Text,Int>  #Number  "number"  real-to-int]
  [real? real! Real number;Eq<Real> number;Codec<Text,Real> #Number  "number"  id]
  [text? text! Text text;Eq<Text>   text;Codec<Text,Text>   #String  "string"  id]
  )

(def: #export (char json)
  {#;doc "Reads a JSON value as a single-character string."}
  (Parser Char)
  (case json
    (#String input)
    (case (Char/decode (format "#\"" input "\""))
      (#R;Success value)
      (#R;Success value)

      (#R;Error _)
      (#R;Error (format "Invalid format for char: " input)))

    _
    (#R;Error (format "JSON value is not a " "string" ": " (show-json json)))))

(def: #export (char? test json)
  {#;doc "Asks whether a JSON value is a single-character string with the specified character."}
  (-> Char (Parser Bool))
  (case json
    (#String input)
    (case (Char/decode (format "#\"" input "\""))
      (#R;Success value)
      (if (:: char;Eq<Char> = test value)
        (#R;Success true)
        (#R;Error (format "Value mismatch: "
                          (:: char;Codec<Text,Char> encode test) "=/=" (:: char;Codec<Text,Char> encode value))))

      (#R;Error _)
      (#R;Error (format "Invalid format for char: " input)))

    _
    (#R;Error (format "JSON value is not a " "string" ": " (show-json json)))))

(def: #export (char! test json)
  {#;doc "Ensures a JSON value is a single-character string with the specified character."}
  (-> Char (Parser Unit))
  (case json
    (#String input)
    (case (Char/decode (format "#\"" input "\""))
      (#R;Success value)
      (if (:: char;Eq<Char> = test value)
        (#R;Success [])
        (#R;Error (format "Value mismatch: "
                          (:: char;Codec<Text,Char> encode test) "=/=" (:: char;Codec<Text,Char> encode value))))

      (#R;Error _)
      (#R;Error (format "Invalid format for char: " input)))

    _
    (#R;Error (format "JSON value is not a " "string" ": " (show-json json)))))

(def: #export (nullable parser)
  {#;doc "A parser that can handle the presence of null values."}
  (All [a] (-> (Parser a) (Parser (Maybe a))))
  (function [json]
    (case json
      #Null
      (#R;Success #;None)
      
      _
      (case (parser json)
        (#R;Error error)
        (#R;Error error)

        (#R;Success value)
        (#R;Success (#;Some value)))
      )))

(def: #export (array parser)
  {#;doc "Parses a JSON array, assuming that every element can be parsed the same way."}
  (All [a] (-> (Parser a) (Parser (List a))))
  (function [json]
    (case json
      (#Array values)
      (do Monad<Result>
        [elems (mapM @ parser (vector;to-list values))]
        (wrap elems))

      _
      (#R;Error (format "JSON value is not an array: " (show-json json))))))

(def: #export (object parser)
  {#;doc "Parses a JSON object, assuming that every field's value can be parsed the same way."}
  (All [a] (-> (Parser a) (Parser (Dict String a))))
  (function [json]
    (case json
      (#Object fields)
      (do Monad<Result>
        [kvs (mapM @
                   (function [[key val']]
                     (do @
                       [val (parser val')]
                       (wrap [key val])))
                   (dict;entries fields))]
        (wrap (dict;from-list text;Hash<Text> kvs)))

      _
      (#R;Error (format "JSON value is not an object: " (show-json json))))))

(def: #export (nth idx parser)
  {#;doc "Parses an element inside a JSON array."}
  (All [a] (-> Nat (Parser a) (Parser a)))
  (function [json]
    (case json
      (#Array values)
      (case (vector;nth idx values)
        (#;Some value)
        (case (parser value)
          (#R;Success output)
          (#R;Success output)

          (#R;Error error)
          (#R;Error (format "JSON array index [" (%n idx) "]: (" error ") @ " (show-json json))))

        #;None
        (#R;Error (format "JSON array does not have index " (%n idx) " @ " (show-json json))))
      
      _
      (#R;Error (format "JSON value is not an array: " (show-json json))))))

(def: #export (field field-name parser)
  {#;doc "Parses a field inside a JSON object."}
  (All [a] (-> Text (Parser a) (Parser a)))
  (function [json]
    (case (get field-name json)
      (#;Some value)
      (case (parser value)
        (#R;Success output)
        (#R;Success output)

        (#R;Error error)
        (#R;Error (format "Failed to get JSON object field " (show-string field-name) ": (" error ") @ " (show-json json))))

      (#R;Error _)
      (#R;Error (format "JSON object does not have field " (show-string field-name) " @ " (show-json json))))))

(def: #export any
  {#;doc "Just returns the JSON input without applying any logic."}
  (Parser JSON)
  (function [json]
    (#R;Success json)))

(def: #export (seq pa pb)
  {#;doc "Sequencing combinator."}
  (All [a b] (-> (Parser a) (Parser b) (Parser [a b])))
  (do Monad<Parser>
    [=a pa
     =b pb]
    (wrap [=a =b])))

(def: #export (alt pa pb json)
  {#;doc "Heterogeneous alternative combinator."}
  (All [a b] (-> (Parser a) (Parser b) (Parser (| a b))))
  (case (pa json)
    (#R;Success a)
    (sum;right (sum;left a))

    (#R;Error message0)
    (case (pb json)
      (#R;Success b)
      (sum;right (sum;right b))

      (#R;Error message1)
      (#R;Error message0))))

(def: #export (either pl pr json)
  {#;doc "Homogeneous alternative combinator."}
  (All [a] (-> (Parser a) (Parser a) (Parser a)))
  (case (pl json)
    (#R;Success x)
    (#R;Success x)

    _
    (pr json)))

(def: #export (opt p json)
  {#;doc "Optionality combinator."}
  (All [a]
    (-> (Parser a) (Parser (Maybe a))))
  (case (p json)
    (#R;Error _)  (#R;Success #;None)
    (#R;Success x) (#R;Success (#;Some x))))

(def: #export (run json parser)
  (All [a] (-> JSON (Parser a) (Result a)))
  (parser json))

(def: #export (ensure test parser json)
  {#;doc "Only parses a JSON if it passes a test (which is also a parser)."}
  (All [a] (-> (Parser Unit) (Parser a) (Parser a)))
  (case (test json)
    (#R;Success _)
    (parser json)

    (#R;Error error)
    (#R;Error error)))

(def: #export (array-size! size json)
  {#;doc "Ensures a JSON array has the specified size."}
  (-> Nat (Parser Unit))
  (case json
    (#Array parts)
    (if (n.= size (vector;size parts))
      (#R;Success [])
      (#R;Error (format "JSON array does no have size " (%n size) " " (show-json json))))

    _
    (#R;Error (format "JSON value is not an array: " (show-json json)))))

(def: #export (object-fields! wanted-fields json)
  {#;doc "Ensures that every field in the list of wanted-fields is present in a JSON object."}
  (-> (List String) (Parser Unit))
  (case json
    (#Object kvs)
    (let [actual-fields (dict;keys kvs)]
      (if (and (n.= (list;size wanted-fields) (list;size actual-fields))
               (list;every? (list;member? text;Eq<Text> wanted-fields)
                            actual-fields))
        (#R;Success [])
        (#R;Error (format "JSON object has wrong field-set. Expected: [" (text;join-with ", " wanted-fields) "]. Actual: [" (text;join-with ", " actual-fields) "]"))))

    _
    (#R;Error (format "JSON value is not an object: " (show-json json)))))

## [Structures]
(struct: #export _ (Eq JSON)
  (def: (= x y)
    (case [x y]
      [#Null #Null]
      true

      (^template [<tag> <struct>]
        [(<tag> x') (<tag> y')]
        (:: <struct> = x' y'))
      ([#Boolean bool;Eq<Bool>]
       [#Number  number;Eq<Real>]
       [#String  text;Eq<Text>])

      [(#Array xs) (#Array ys)]
      (and (n.= (vector;size xs) (vector;size ys))
           (fold (function [idx prev]
                   (and prev
                        (default false
                          (do Monad<Maybe>
                            [x' (vector;nth idx xs)
                             y' (vector;nth idx ys)]
                            (wrap (= x' y'))))))
                 true
                 (list;indices (vector;size xs))))
      
      [(#Object xs) (#Object ys)]
      (and (n.= (dict;size xs) (dict;size ys))
           (fold (function [[xk xv] prev]
                   (and prev
                        (case (dict;get xk ys)
                          #;None   false
                          (#;Some yv) (= xv yv))))
                 true
                 (dict;entries xs)))
      
      _
      false)))

(struct: #export _ (Codec Text JSON)
  (def: encode show-json)
  (def: decode (function [input] (lexer;run input (json~' [])))))

## [Syntax]
(type: Shape
  (#ArrayShape (List Code))
  (#ObjectShape (List [Text Code])))

(def: _shape^
  (syntax;Syntax Shape)
  (syntax;alt (syntax;tuple (syntax;some syntax;any))
              (syntax;record (syntax;some (syntax;seq syntax;text syntax;any)))))

(syntax: #export (shape [shape _shape^])
  {#;doc (doc "Builds a parser that ensures the (inclusive) shape of an array or object."
              (shape [bool! int! real!])
              (shape {"isAlive" bool!
                      "age" int!
                      "income" real!}))}
  (case shape
    (#ArrayShape parts)
    (let [array-size (list;size parts)
          parsers (|> parts
                      (list;zip2 (list;indices array-size))
                      (List/map (function [[idx parser]]
                                  (` (nth (~ (code;nat idx)) (~ parser))))))]
      (wrap (list (` ($_ seq (~@ parsers))))))

    (#ObjectShape kvs)
    (let [fields (List/map product;left kvs)
          parsers (List/map (function [[field-name parser]]
                              (` (field (~ (code;text field-name)) (~ parser))))
                            kvs)]
      (wrap (list (` ($_ seq (~@ parsers))))))
    ))

(syntax: #export (shape! [shape _shape^])
  {#;doc (doc "Builds a parser that ensures the (exclusive) shape of an array or object."
              (shape! [bool! int! real!])
              (shape! {"isAlive" bool!
                       "age" int!
                       "income" real!}))}
  (case shape
    (#ArrayShape parts)
    (let [array-size (list;size parts)
          parsers (|> parts
                      (list;zip2 (list;indices array-size))
                      (List/map (function [[idx parser]]
                                  (` (nth (~ (code;nat idx)) (~ parser))))))]
      (wrap (list (` (ensure (array-size! (~ (code;nat array-size)))
                             ($_ seq (~@ parsers)))))))

    (#ObjectShape kvs)
    (let [fields (List/map product;left kvs)
          parsers (List/map (function [[field-name parser]]
                              (` (field (~ (code;text field-name)) (~ parser))))
                            kvs)]
      (wrap (list (` (ensure (object-fields! (list (~@ (List/map code;text fields))))
                             ($_ seq (~@ parsers)))))))
    ))

## [Polytypism]
(def: #hidden _map_
  (All [a b] (-> (-> a b) (List a) (List b)))
  List/map)

(poly: #hidden (Codec<JSON,?>//encode *env* :x:)
  (let [->Codec//encode (: (-> Code Code)
                           (function [.type.] (` (-> (~ .type.) JSON))))]
    (with-expansions
      [<basic> (do-template [<type> <matcher> <encoder>]
                 [(do @ [_ (<matcher> :x:)] (wrap (` (: (~ (->Codec//encode (` <type>))) <encoder>))))]

                 [Unit poly;unit (function [(~ (code;symbol ["" "0"]))] #Null)]
                 [Bool poly;bool ;;gen-boolean]
                 [Int  poly;int  (|>. ;int-to-real ;;gen-number)]
                 [Real poly;real ;;gen-number]
                 [Char poly;char (|>. char;as-text ;;gen-string)]
                 [Text poly;text ;;gen-string])]
      ($_ macro;either
          <basic>
          (with-gensyms [g!type-fun g!case g!input g!key g!val]
            (do @
              [:sub: (poly;apply-1 (ident-for ;List) :x:)
               [g!vars members] (poly;tuple :sub:)
               :val: (case members
                       (^ (list :key: :val:))
                       (do @ [_ (poly;text :key:)]
                         (wrap :val:))

                       _
                       (macro;fail ""))
               #let [new-*env* (poly;extend-env [:x: g!type-fun]
                                                (list;zip2 (|> g!vars list;size poly;type-var-indices)
                                                           g!vars)
                                                *env*)]
               .val. (Codec<JSON,?>//encode new-*env* :val:)
               #let [:x:+ (case g!vars
                            #;Nil
                            (->Codec//encode (type;to-ast :x:))

                            _
                            (` (All (~ g!type-fun) [(~@ g!vars)]
                                 (-> (~@ (List/map ->Codec//encode g!vars))
                                     (~ (->Codec//encode (` ((~ (type;to-ast :x:)) (~@ g!vars)))))))))]]
              (wrap (` (: (~ :x:+)
                          (function [(~@ g!vars) (~ g!input)]
                            (|> (~ g!input)
                                (_map_ (: (-> [Text (~ (type;to-ast :val:))]
                                              [Text JSON])
                                          (function [[(~ g!key) (~ g!val)]]
                                            [(~ g!key)
                                             ((~ .val.) (~ g!val))])))
                                ;;object))
                          )))
              ))
          (do @
            [:sub: (poly;apply-1 (ident-for ;Maybe) :x:)
             .sub. (Codec<JSON,?>//encode *env* :sub:)]
            (wrap (` (: (~ (->Codec//encode (type;to-ast :x:)))
                        (;;gen-nullable (~ .sub.))))))
          (do @
            [:sub: (poly;apply-1 (ident-for ;List) :x:)
             .sub. (Codec<JSON,?>//encode *env* :sub:)]
            (wrap (` (: (~ (->Codec//encode (type;to-ast :x:)))
                        (|>. (_map_ (~ .sub.)) vector;from-list ;;gen-array)))))
          (with-gensyms [g!type-fun g!case g!input]
            (do @
              [[g!vars members] (poly;variant :x:)
               #let [new-*env* (poly;extend-env [:x: g!type-fun]
                                                (list;zip2 (|> g!vars list;size poly;type-var-indices) g!vars)
                                                *env*)]
               pattern-matching (mapM @
                                      (function [[name :case:]]
                                        (do @
                                          [#let [tag (code;tag name)]
                                           encoder (Codec<JSON,?>//encode new-*env* :case:)]
                                          (wrap (list (` ((~ tag) (~ g!case)))
                                                      (` (;;json [(~ (code;text (product;right name)))
                                                                  ((~ encoder) (~ g!case))]))))))
                                      members)
               #let [:x:+ (case g!vars
                            #;Nil
                            (->Codec//encode (type;to-ast :x:))

                            _
                            (` (All (~ g!type-fun) [(~@ g!vars)]
                                 (-> (~@ (List/map ->Codec//encode g!vars))
                                     (~ (->Codec//encode (` ((~ (type;to-ast :x:)) (~@ g!vars)))))))))]]
              (wrap (` (: (~ :x:+)
                          (function [(~@ g!vars) (~ g!input)]
                            (case (~ g!input)
                              (~@ (List/join pattern-matching))))
                          )))))
          (with-gensyms [g!type-fun g!case g!input]
            (do @
              [[g!vars members] (poly;record :x:)
               #let [new-*env* (poly;extend-env [:x: g!type-fun]
                                                (list;zip2 (|> g!vars list;size poly;type-var-indices) g!vars)
                                                *env*)]
               synthesis (mapM @
                               (function [[name :slot:]]
                                 (do @
                                   [encoder (Codec<JSON,?>//encode new-*env* :slot:)]
                                   (wrap [(` (~ (code;text (product;right name))))
                                          (` ((~ encoder) (get@ (~ (code;tag name)) (~ g!input))))])))
                               members)
               #let [:x:+ (case g!vars
                            #;Nil
                            (->Codec//encode (type;to-ast :x:))

                            _
                            (` (All (~ g!type-fun) [(~@ g!vars)]
                                 (-> (~@ (List/map ->Codec//encode g!vars))
                                     (~ (->Codec//encode (` ((~ (type;to-ast :x:)) (~@ g!vars)))))))))]]
              (wrap (` (: (~ :x:+)
                          (function [(~@ g!vars) (~ g!input)]
                            (;;json (~ (code;record synthesis))))
                          )))))
          (with-gensyms [g!type-fun g!case]
            (do @
              [[g!vars members] (poly;tuple :x:)
               #let [new-*env* (poly;extend-env [:x: g!type-fun]
                                                (list;zip2 (|> g!vars list;size poly;type-var-indices) g!vars)
                                                *env*)]
               pattern-matching (mapM @
                                      (function [:member:]
                                        (do @
                                          [g!member (macro;gensym "g!member")
                                           encoder (Codec<JSON,?>//encode new-*env* :member:)]
                                          (wrap [g!member encoder])))
                                      members)
               #let [:x:+ (case g!vars
                            #;Nil
                            (->Codec//encode (type;to-ast :x:))

                            _
                            (` (All (~ g!type-fun) [(~@ g!vars)]
                                 (-> (~@ (List/map ->Codec//encode g!vars))
                                     (~ (->Codec//encode (` ((~ (type;to-ast :x:)) (~@ g!vars)))))))))]
               #let [.tuple. (` [(~@ (List/map product;left pattern-matching))])]]
              (wrap (` (: (~ :x:+)
                          (function [(~@ g!vars) (~ .tuple.)]
                            (;;json [(~@ (List/map (function [[g!member g!encoder]]
                                                     (` ((~ g!encoder) (~ g!member))))
                                                   pattern-matching))]))
                          )))
              ))
          (do @
            [[:func: :args:] (poly;apply :x:)
             .func. (Codec<JSON,?>//encode *env* :func:)
             .args. (mapM @ (Codec<JSON,?>//encode *env*) :args:)]
            (wrap (` (: (~ (->Codec//encode (type;to-ast :x:)))
                        ((~ .func.) (~@ .args.))))))
          (poly;bound *env* :x:)
          (macro;fail (format "Cannot create JSON encoder for: " (%type :x:)))
          ))))

(poly: #hidden (Codec<JSON,?>//decode *env* :x:)
  (let [->Codec//decode (: (-> Code Code)
                           (function [.type.] (` (-> JSON (Result (~ .type.))))))]
    (with-expansions
      [<basic> (do-template [<type> <matcher> <decoder>]
                 [(do @ [_ (<matcher> :x:)] (wrap (` (: (~ (->Codec//decode (` <type>))) <decoder>))))]

                 [Unit poly;unit ;;unit]
                 [Bool poly;bool ;;bool]
                 [Int  poly;int  ;;int]
                 [Real poly;real ;;real]
                 [Char poly;char ;;char]
                 [Text poly;text ;;text])
       <complex> (do-template [<type> <matcher> <decoder>]
                   [(do @
                      [:sub: (<matcher> :x:)
                       .sub. (Codec<JSON,?>//decode *env* :sub:)]
                      (wrap (` (: (~ (->Codec//decode (type;to-ast :x:)))
                                  (<decoder> (~ .sub.))))))]

                   [Maybe (poly;apply-1 (ident-for ;Maybe)) ;;nullable]
                   [List  (poly;apply-1 (ident-for ;List))  ;;array])]
      ($_ macro;either
          <basic>
          (with-gensyms [g!type-fun g!case g!input g!key g!val]
            (do @
              [:sub: (poly;apply-1 (ident-for ;List) :x:)
               [g!vars members] (poly;tuple :sub:)
               :val: (case members
                       (^ (list :key: :val:))
                       (do @ [_ (poly;text :key:)]
                         (wrap :val:))

                       _
                       (macro;fail ""))
               #let [new-*env* (poly;extend-env [:x: g!type-fun]
                                                (list;zip2 (|> g!vars list;size poly;type-var-indices) g!vars)
                                                *env*)]
               .val. (Codec<JSON,?>//decode new-*env* :val:)
               #let [:x:+ (case g!vars
                            #;Nil
                            (->Codec//decode (type;to-ast :x:))

                            _
                            (` (All (~ g!type-fun) [(~@ g!vars)]
                                 (-> (~@ (List/map ->Codec//decode g!vars))
                                     (~ (->Codec//decode (` ((~ (type;to-ast :x:)) (~@ g!vars)))))))))]]
              (wrap (` (: (~ :x:+)
                          (function [(~@ g!vars) (~ g!input)]
                            (do Monad<Result>
                              [(~ g!key) (;;fields (~ g!input))]
                              (mapM (~ (' %))
                                    (function [(~ g!key)]
                                      (do Monad<Result>
                                        [(~ g!val) (;;get (~ g!key) (~ g!input))
                                         (~ g!val) (;;run (~ g!val) (~ .val.))]
                                        ((~ (' wrap)) [(~ g!key) (~ g!val)])))
                                    (~ g!key))))
                          )))
              ))
          <complex>
          (with-gensyms [g!type-fun g!_]
            (do @
              [[g!vars members] (poly;variant :x:)
               #let [new-*env* (poly;extend-env [:x: g!type-fun]
                                                (list;zip2 (|> g!vars list;size poly;type-var-indices) g!vars)
                                                *env*)]
               pattern-matching (mapM @
                                      (function [[name :case:]]
                                        (do @
                                          [#let [tag (code;tag name)]
                                           decoder (Codec<JSON,?>//decode new-*env* :case:)]
                                          (wrap (list (` (do Monad<Parser>
                                                           [(~ g!_) (;;nth +0 (;;text! (~ (code;text (product;right name)))))
                                                            (~ g!_) (;;nth +1 (~ decoder))]
                                                           ((~ (' wrap)) ((~ tag) (~ g!_)))))))))
                                      members)
               #let [:x:+ (case g!vars
                            #;Nil
                            (->Codec//decode (type;to-ast :x:))

                            _
                            (` (All (~ g!type-fun) [(~@ g!vars)]
                                 (-> (~@ (List/map ->Codec//decode g!vars))
                                     (~ (->Codec//decode (` ((~ (type;to-ast :x:)) (~@ g!vars)))))))))
                     base-parser (` ($_ ;;either
                                        (~@ (List/join pattern-matching))))
                     parser (case g!vars
                              #;Nil
                              base-parser

                              _
                              (` (function [(~@ g!vars)] (~ base-parser))))]]
              (wrap (` (: (~ :x:+) (~ parser))))
              ))
          (with-gensyms [g!type-fun g!case g!input]
            (do @
              [[g!vars members] (poly;record :x:)
               #let [new-*env* (poly;extend-env [:x: g!type-fun]
                                                (list;zip2 (|> g!vars list;size poly;type-var-indices) g!vars)
                                                *env*)]
               extraction (mapM @
                                (function [[name :slot:]]
                                  (do @
                                    [#let [g!member (code;symbol ["" (product;right name)])]
                                     decoder (Codec<JSON,?>//decode new-*env* :slot:)]
                                    (wrap (list g!member
                                                (` (;;get (~ (code;text (product;right name))) (~ g!input)))
                                                g!member
                                                (` ((~ decoder) (~ g!member)))))))
                                members)
               #let [:x:+ (case g!vars
                            #;Nil
                            (->Codec//decode (type;to-ast :x:))

                            _
                            (` (All (~ g!type-fun) [(~@ g!vars)]
                                 (-> (~@ (List/map ->Codec//decode g!vars))
                                     (~ (->Codec//decode (` ((~ (type;to-ast :x:)) (~@ g!vars)))))))))]]
              (wrap (` (: (~ :x:+)
                          (function [(~@ g!vars) (~ g!input)]
                            (do Monad<Result>
                              [(~@ (List/join extraction))]
                              ((~ (' wrap)) (~ (code;record (List/map (function [[name :slot:]]
                                                                        [(code;tag name) (code;symbol ["" (product;right name)])])
                                                                      members))))))
                          )))))
          (with-gensyms [g!type-fun g!case g!input]
            (do @
              [[g!vars members] (poly;tuple :x:)
               #let [new-*env* (poly;extend-env [:x: g!type-fun]
                                                (list;zip2 (|> g!vars list;size poly;type-var-indices) g!vars)
                                                *env*)]
               pattern-matching (mapM @
                                      (function [:member:]
                                        (do @
                                          [g!member (macro;gensym "g!member")
                                           decoder (Codec<JSON,?>//decode new-*env* :member:)]
                                          (wrap [g!member decoder])))
                                      members)
               #let [:x:+ (case g!vars
                            #;Nil
                            (->Codec//decode (type;to-ast :x:))

                            _
                            (` (All (~ g!type-fun) [(~@ g!vars)]
                                 (-> (~@ (List/map ->Codec//decode g!vars))
                                     (~ (->Codec//decode (` ((~ (type;to-ast :x:)) (~@ g!vars)))))))))]
               #let [.decoder. (case g!vars
                                 #;Nil
                                 (` (;;shape [(~@ (List/map product;right pattern-matching))]))

                                 _
                                 (` (function [(~@ g!vars)]
                                      (;;shape [(~@ (List/map product;right pattern-matching))]))))]]
              (wrap (` (: (~ :x:+) (~ .decoder.))))
              ))
          (do @
            [[:func: :args:] (poly;apply :x:)
             .func. (Codec<JSON,?>//decode *env* :func:)
             .args. (mapM @ (Codec<JSON,?>//decode *env*) :args:)]
            (wrap (` (: (~ (->Codec//decode (type;to-ast :x:)))
                        ((~ .func.) (~@ .args.))))))
          (do @
            [g!bound (poly;bound *env* :x:)]
            (wrap g!bound))
          (macro;fail (format "Cannot create JSON decoder for: " (%type :x:)))
          ))))

(syntax: #export (Codec<JSON,?> :x:)
  {#;doc (doc "A macro for automatically producing JSON codecs."
              (type: Variant
                (#Case0 Bool)
                (#Case1 Int)
                (#Case2 Real))

              (type: Record
                {#unit Unit
                 #bool Bool
                 #int Int
                 #real Real
                 #char Char
                 #text Text
                 #maybe (Maybe Int)
                 #list (List Int)
                 #variant Variant
                 #tuple [Int Real Char]})

              (derived: (Codec<JSON,?> Record)))}
  (wrap (list (` (: (Codec JSON (~ :x:))
                    (struct (def: (~ (' encode)) (Codec<JSON,?>//encode (~ :x:)))
                            (def: (~ (' decode)) (Codec<JSON,?>//decode (~ :x:)))
                            ))))))
