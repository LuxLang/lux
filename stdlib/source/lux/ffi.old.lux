(.module:
  [lux (#- type interface:)
   ["." type ("#\." equivalence)]
   [abstract
    ["." monad (#+ Monad do)]
    ["." enum]]
   [control
    ["." function]
    ["." io]
    ["." try (#+ Try)]
    ["<>" parser
     ["<.>" code (#+ Parser)]]]
   [data
    ["." maybe]
    ["." product]
    ["." bit ("#\." codec)]
    ["." text ("#\." equivalence monoid)
     ["%" format (#+ format)]]
    [collection
     ["." array (#+ Array)]
     ["." list ("#\." monad fold monoid)]]]
   [macro (#+ with_gensyms)
    [syntax (#+ syntax:)]
    ["." code]]
   ["." meta
    ["." annotation]]])

(template [<name> <op> <from> <to>]
  [(def: #export (<name> value)
     {#.doc (doc "Type converter."
                 (: <to>
                    (<name> (: <from> foo))))}
     (-> (primitive <from>) (primitive <to>))
     (<op> value))]

  [byte_to_long "jvm convert byte-to-long" "java.lang.Byte"      "java.lang.Long"]

  [short_to_long "jvm convert short-to-long" "java.lang.Short"     "java.lang.Long"]
  
  [double_to_int "jvm convert double-to-int" "java.lang.Double"    "java.lang.Integer"]
  [double_to_long "jvm convert double-to-long" "java.lang.Double"    "java.lang.Long"]
  [double_to_float "jvm convert double-to-float" "java.lang.Double"    "java.lang.Float"]

  [float_to_int "jvm convert float-to-int" "java.lang.Float"     "java.lang.Integer"]
  [float_to_long "jvm convert float-to-long" "java.lang.Float"     "java.lang.Long"]
  [float_to_double "jvm convert float-to-double" "java.lang.Float"     "java.lang.Double"]
  
  [int_to_byte "jvm convert int-to-byte" "java.lang.Integer"   "java.lang.Byte"]
  [int_to_short "jvm convert int-to-short" "java.lang.Integer"   "java.lang.Short"]
  [int_to_long "jvm convert int-to-long" "java.lang.Integer"   "java.lang.Long"]
  [int_to_float "jvm convert int-to-float" "java.lang.Integer"   "java.lang.Float"]
  [int_to_double "jvm convert int-to-double" "java.lang.Integer"   "java.lang.Double"]
  [int_to_char "jvm convert int-to-char" "java.lang.Integer"   "java.lang.Character"]

  [long_to_byte "jvm convert long-to-byte" "java.lang.Long"      "java.lang.Byte"]
  [long_to_short "jvm convert long-to-short" "java.lang.Long"      "java.lang.Short"]
  [long_to_int "jvm convert long-to-int" "java.lang.Long"      "java.lang.Integer"]
  [long_to_float "jvm convert long-to-float" "java.lang.Long"      "java.lang.Float"]
  [long_to_double "jvm convert long-to-double" "java.lang.Long"      "java.lang.Double"]

  [char_to_byte "jvm convert char-to-byte" "java.lang.Character" "java.lang.Byte"]
  [char_to_short "jvm convert char-to-short" "java.lang.Character" "java.lang.Short"]
  [char_to_int "jvm convert char-to-int" "java.lang.Character" "java.lang.Integer"]
  [char_to_long "jvm convert char-to-long" "java.lang.Character" "java.lang.Long"]
  )

## [Utils]
(def: constructor_method_name "<init>")
(def: member_separator "::")

## Types
(type: JVM_Code Text)

(type: BoundKind
  #UpperBound
  #LowerBound)

(type: #rec GenericType
  (#GenericTypeVar Text)
  (#GenericClass [Text (List GenericType)])
  (#GenericArray GenericType)
  (#GenericWildcard (Maybe [BoundKind GenericType])))

(type: Type_Parameter
  [Text (List GenericType)])

(type: Primitive_Mode
  #ManualPrM
  #AutoPrM)

(type: PrivacyModifier
  #PublicPM
  #PrivatePM
  #ProtectedPM
  #DefaultPM)

(type: StateModifier
  #VolatileSM
  #FinalSM
  #DefaultSM)

(type: InheritanceModifier
  #FinalIM
  #AbstractIM
  #DefaultIM)

(type: Class_Kind
  #Class
  #Interface)

(type: Class_Declaration
  {#class_name   Text
   #class_params (List Type_Parameter)})

(type: StackFrame (primitive "java/lang/StackTraceElement"))
(type: StackTrace (Array StackFrame))

(type: Super_Class_Decl
  {#super_class_name   Text
   #super_class_params (List GenericType)})

(type: AnnotationParam
  [Text Code])

(type: Annotation
  {#ann_name   Text
   #ann_params (List AnnotationParam)})

(type: Member_Declaration
  {#member_name Text
   #member_privacy PrivacyModifier
   #member_anns (List Annotation)})

(type: FieldDecl
  (#ConstantField GenericType Code)
  (#VariableField StateModifier GenericType))

(type: MethodDecl
  {#method_tvars  (List Type_Parameter)
   #method_inputs (List GenericType)
   #method_output GenericType
   #method_exs    (List GenericType)})

(type: ArgDecl
  {#arg_name Text
   #arg_type GenericType})

(type: ConstructorArg
  [GenericType Code])

(type: Method_Definition
  (#ConstructorMethod [Bit
                       (List Type_Parameter)
                       (List ArgDecl)
                       (List ConstructorArg)
                       Code
                       (List GenericType)])
  (#VirtualMethod [Bit
                   Bit
                   (List Type_Parameter)
                   Text
                   (List ArgDecl)
                   GenericType
                   Code
                   (List GenericType)])
  (#OverridenMethod [Bit
                     Class_Declaration
                     (List Type_Parameter)
                     Text
                     (List ArgDecl)
                     GenericType
                     Code
                     (List GenericType)])
  (#StaticMethod [Bit
                  (List Type_Parameter)
                  (List ArgDecl)
                  GenericType
                  Code
                  (List GenericType)])
  (#AbstractMethod [(List Type_Parameter)
                    (List ArgDecl)
                    GenericType
                    (List GenericType)])
  (#NativeMethod [(List Type_Parameter)
                  (List ArgDecl)
                  GenericType
                  (List GenericType)]))

(type: Partial_Call
  {#pc_method Name
   #pc_args   (List Code)})

(type: ImportMethodKind
  #StaticIMK
  #VirtualIMK)

(type: ImportMethodCommons
  {#import_member_mode   Primitive_Mode
   #import_member_alias  Text
   #import_member_kind   ImportMethodKind
   #import_member_tvars  (List Type_Parameter)
   #import_member_args   (List [Bit GenericType])
   #import_member_maybe? Bit
   #import_member_try?   Bit
   #import_member_io?    Bit})

(type: ImportConstructorDecl
  {})

(type: ImportMethodDecl
  {#import_method_name    Text
   #import_method_return  GenericType})

(type: ImportFieldDecl
  {#import_field_mode    Primitive_Mode
   #import_field_name    Text
   #import_field_static? Bit
   #import_field_maybe?  Bit
   #import_field_setter? Bit
   #import_field_type    GenericType})

(type: Import_Member_Declaration
  (#EnumDecl        (List Text))
  (#ConstructorDecl [ImportMethodCommons ImportConstructorDecl])
  (#MethodDecl      [ImportMethodCommons ImportMethodDecl])
  (#FieldAccessDecl ImportFieldDecl))

## Utils
(def: (manual_primitive_to_type class)
  (-> Text (Maybe Code))
  (case class
    (^template [<prim> <type>]
      [<prim>
       (#.Some (' <type>))])
    (["boolean" (primitive "java.lang.Boolean")]
     ["byte"    (primitive "java.lang.Byte")]
     ["short"   (primitive "java.lang.Short")]
     ["int"     (primitive "java.lang.Integer")]
     ["long"    (primitive "java.lang.Long")]
     ["float"   (primitive "java.lang.Float")]
     ["double"  (primitive "java.lang.Double")]
     ["char"    (primitive "java.lang.Character")]
     ["void"    .Any])

    _
    #.None))

(def: (auto_primitive_to_type class)
  (-> Text (Maybe Code))
  (case class
    (^template [<prim> <type>]
      [<prim>
       (#.Some (' <type>))])
    (["boolean" .Bit]
     ["byte"    .Int]
     ["short"   .Int]
     ["int"     .Int]
     ["long"    .Int]
     ["float"   .Frac]
     ["double"  .Frac]
     ["void"    .Any])

    _
    #.None))

(def: sanitize
  (-> Text Text)
  (text.replace_all "/" "."))

(def: (generic_class->type' mode type_params in_array? name+params
                            class->type')
  (-> Primitive_Mode (List Type_Parameter) Bit [Text (List GenericType)]
      (-> Primitive_Mode (List Type_Parameter) Bit GenericType Code)
      Code)
  (case [name+params mode in_array?]
    (^multi [[prim #.Nil] #ManualPrM #0]
            [(manual_primitive_to_type prim) (#.Some output)])
    output

    (^multi [[prim #.Nil] #AutoPrM #0]
            [(auto_primitive_to_type prim) (#.Some output)])
    output
    
    [[name params] _ _]
    (let [name (sanitize name)
          =params (list\map (class->type' mode type_params in_array?) params)]
      (` (primitive (~ (code.text name)) [(~+ =params)])))))

(def: (class->type' mode type_params in_array? class)
  (-> Primitive_Mode (List Type_Parameter) Bit GenericType Code)
  (case class
    (#GenericTypeVar name)
    (case (list.find (function (_ [pname pbounds])
                       (and (text\= name pname)
                            (not (list.empty? pbounds))))
                     type_params)
      #.None
      (code.identifier ["" name])

      (#.Some [pname pbounds])
      (class->type' mode type_params in_array? (maybe.assume (list.head pbounds))))
    
    (#GenericClass name+params)
    (generic_class->type' mode type_params in_array? name+params
                          class->type')

    (#GenericArray param)
    (let [=param (class->type' mode type_params #1 param)]
      (` ((~! array.Array) (~ =param))))

    (^or (#GenericWildcard #.None) (#GenericWildcard (#.Some [#LowerBound _])))
    (` .Any)

    (#GenericWildcard (#.Some [#UpperBound upper_bound]))
    (class->type' mode type_params in_array? upper_bound)
    ))

(def: (class->type mode type_params class)
  (-> Primitive_Mode (List Type_Parameter) GenericType Code)
  (class->type' mode type_params #0 class))

(def: (type_param_type$ [name bounds])
  (-> Type_Parameter Code)
  (code.identifier ["" name]))

(def: (class_decl_type$ (^slots [#class_name #class_params]))
  (-> Class_Declaration Code)
  (let [=params (list\map (: (-> Type_Parameter Code)
                             (function (_ [pname pbounds])
                               (case pbounds
                                 #.Nil
                                 (code.identifier ["" pname])

                                 (#.Cons bound1 _)
                                 (class->type #ManualPrM class_params bound1))))
                          class_params)]
    (` (primitive (~ (code.text (sanitize class_name)))
                  [(~+ =params)]))))

(def: type_var_class Text "java.lang.Object")

(def: (simple_class$ env class)
  (-> (List Type_Parameter) GenericType Text)
  (case class
    (#GenericTypeVar name)
    (case (list.find (function (_ [pname pbounds])
                       (and (text\= name pname)
                            (not (list.empty? pbounds))))
                     env)
      #.None
      type_var_class

      (#.Some [pname pbounds])
      (simple_class$ env (maybe.assume (list.head pbounds))))

    (^or (#GenericWildcard #.None) (#GenericWildcard (#.Some [#LowerBound _])))
    type_var_class
    
    (#GenericWildcard (#.Some [#UpperBound upper_bound]))
    (simple_class$ env upper_bound)
    
    (#GenericClass name env)
    (sanitize name)

    (#GenericArray param')
    (case param'
      (#GenericArray param)
      (format "[" (simple_class$ env param))
      
      (^template [<prim> <class>]
        [(#GenericClass <prim> #.Nil)
         <class>])
      (["boolean" "[Z"]
       ["byte"    "[B"]
       ["short"   "[S"]
       ["int"     "[I"]
       ["long"    "[J"]
       ["float"   "[F"]
       ["double"  "[D"]
       ["char"    "[C"])
      
      param
      (format "[L" (simple_class$ env param) ";"))
    ))

(def: (make_get_const_parser class_name field_name)
  (-> Text Text (Parser Code))
  (do <>.monad
    [#let [dotted_name (format "::" field_name)]
     _ (<code>.this! (code.identifier ["" dotted_name]))]
    (wrap (`' ((~ (code.text (format "jvm getstatic" ":" class_name ":" field_name))))))))

(def: (make_get_var_parser class_name field_name)
  (-> Text Text (Parser Code))
  (do <>.monad
    [#let [dotted_name (format "::" field_name)]
     _ (<code>.this! (code.identifier ["" dotted_name]))]
    (wrap (`' ((~ (code.text (format "jvm getfield" ":" class_name ":" field_name))) _jvm_this)))))

(def: (make_put_var_parser class_name field_name)
  (-> Text Text (Parser Code))
  (do <>.monad
    [#let [dotted_name (format "::" field_name)]
     [_ _ value] (: (Parser [Any Any Code])
                    (<code>.form ($_ <>.and (<code>.this! (' :=)) (<code>.this! (code.identifier ["" dotted_name])) <code>.any)))]
    (wrap (`' ((~ (code.text (format "jvm putfield" ":" class_name ":" field_name))) _jvm_this (~ value))))))

(def: (pre_walk_replace f input)
  (-> (-> Code Code) Code Code)
  (case (f input)
    (^template [<tag>]
      [[meta (<tag> parts)]
       [meta (<tag> (list\map (pre_walk_replace f) parts))]])
    ([#.Form]
     [#.Tuple])
    
    [meta (#.Record pairs)]
    [meta (#.Record (list\map (: (-> [Code Code] [Code Code])
                                 (function (_ [key val])
                                   [(pre_walk_replace f key) (pre_walk_replace f val)]))
                              pairs))]
    
    ast'
    ast'))

(def: (parser->replacer p ast)
  (-> (Parser Code) (-> Code Code))
  (case (<>.run p (list ast))
    (#.Right [#.Nil ast'])
    ast'

    _
    ast
    ))

(def: (field->parser class_name [[field_name _ _] field])
  (-> Text [Member_Declaration FieldDecl] (Parser Code))
  (case field
    (#ConstantField _)
    (make_get_const_parser class_name field_name)
    
    (#VariableField _)
    (<>.either (make_get_var_parser class_name field_name)
               (make_put_var_parser class_name field_name))))

(def: (make_constructor_parser params class_name arg_decls)
  (-> (List Type_Parameter) Text (List ArgDecl) (Parser Code))
  (do <>.monad
    [args (: (Parser (List Code))
             (<code>.form (<>.after (<code>.this! (' ::new!))
                                    (<code>.tuple (<>.exactly (list.size arg_decls) <code>.any)))))
     #let [arg_decls' (: (List Text) (list\map (|>> product.right (simple_class$ params)) arg_decls))]]
    (wrap (` ((~ (code.text (format "jvm new" ":" class_name ":" (text.join_with "," arg_decls'))))
              (~+ args))))))

(def: (make_static_method_parser params class_name method_name arg_decls)
  (-> (List Type_Parameter) Text Text (List ArgDecl) (Parser Code))
  (do <>.monad
    [#let [dotted_name (format "::" method_name "!")]
     args (: (Parser (List Code))
             (<code>.form (<>.after (<code>.this! (code.identifier ["" dotted_name]))
                                    (<code>.tuple (<>.exactly (list.size arg_decls) <code>.any)))))
     #let [arg_decls' (: (List Text) (list\map (|>> product.right (simple_class$ params)) arg_decls))]]
    (wrap (`' ((~ (code.text (format "jvm invokestatic" ":" class_name ":" method_name ":" (text.join_with "," arg_decls'))))
               (~+ args))))))

(template [<name> <jvm_op>]
  [(def: (<name> params class_name method_name arg_decls)
     (-> (List Type_Parameter) Text Text (List ArgDecl) (Parser Code))
     (do <>.monad
       [#let [dotted_name (format "::" method_name "!")]
        args (: (Parser (List Code))
                (<code>.form (<>.after (<code>.this! (code.identifier ["" dotted_name]))
                                       (<code>.tuple (<>.exactly (list.size arg_decls) <code>.any)))))
        #let [arg_decls' (: (List Text) (list\map (|>> product.right (simple_class$ params)) arg_decls))]]
       (wrap (`' ((~ (code.text (format <jvm_op> ":" class_name ":" method_name ":" (text.join_with "," arg_decls'))))
                  (~' _jvm_this) (~+ args))))))]

  [make_special_method_parser "jvm invokespecial"]
  [make_virtual_method_parser "jvm invokevirtual"]
  )

(def: (method->parser params class_name [[method_name _ _] meth_def])
  (-> (List Type_Parameter) Text [Member_Declaration Method_Definition] (Parser Code))
  (case meth_def
    (#ConstructorMethod strict? type_vars args constructor_args return_expr exs)
    (make_constructor_parser params class_name args)
    
    (#StaticMethod strict? type_vars args return_type return_expr exs)
    (make_static_method_parser params class_name method_name args)
    
    (^or (#VirtualMethod final? strict? type_vars self_name args return_type return_expr exs)
         (#OverridenMethod strict? owner_class type_vars self_name args return_type return_expr exs))
    (make_special_method_parser params class_name method_name args)

    (#AbstractMethod type_vars args return_type exs)
    (make_virtual_method_parser params class_name method_name args)

    (#NativeMethod type_vars args return_type exs)
    (make_virtual_method_parser params class_name method_name args)))

## Parsers
(def: privacy_modifier^
  (Parser PrivacyModifier)
  (let [(^open ".") <>.monad]
    ($_ <>.or
        (<code>.this! (' #public))
        (<code>.this! (' #private))
        (<code>.this! (' #protected))
        (wrap []))))

(def: inheritance_modifier^
  (Parser InheritanceModifier)
  (let [(^open ".") <>.monad]
    ($_ <>.or
        (<code>.this! (' #final))
        (<code>.this! (' #abstract))
        (wrap []))))

(def: bound_kind^
  (Parser BoundKind)
  (<>.or (<code>.this! (' <))
         (<code>.this! (' >))))

(def: (assert_no_periods name)
  (-> Text (Parser Any))
  (<>.assert "Names in class declarations cannot contain periods."
             (not (text.contains? "." name))))

(def: (generic_type^ type_vars)
  (-> (List Type_Parameter) (Parser GenericType))
  (<>.rec
   (function (_ recur^)
     ($_ <>.either
         (do <>.monad
           [_ (<code>.this! (' ?))]
           (wrap (#GenericWildcard #.None)))
         (<code>.tuple (do <>.monad
                         [_ (<code>.this! (' ?))
                          bound_kind bound_kind^
                          bound recur^]
                         (wrap (#GenericWildcard (#.Some [bound_kind bound])))))
         (do <>.monad
           [name <code>.local_identifier
            _ (assert_no_periods name)]
           (if (list.member? text.equivalence (list\map product.left type_vars) name)
             (wrap (#GenericTypeVar name))
             (wrap (#GenericClass name (list)))))
         (<code>.tuple (do <>.monad
                         [component recur^]
                         (case component
                           (^template [<class> <name>]
                             [(#GenericClass <name> #.Nil)
                              (wrap (#GenericClass <class> (list)))])
                           (["[Z" "boolean"]
                            ["[B" "byte"]
                            ["[S" "short"]
                            ["[I" "int"]
                            ["[J" "long"]
                            ["[F" "float"]
                            ["[D" "double"]
                            ["[C" "char"])

                           _
                           (wrap (#GenericArray component)))))
         (<code>.form (do <>.monad
                        [name <code>.local_identifier
                         _ (assert_no_periods name)
                         params (<>.some recur^)
                         _ (<>.assert (format name " cannot be a type-parameter!")
                                      (not (list.member? text.equivalence (list\map product.left type_vars) name)))]
                        (wrap (#GenericClass name params))))
         ))))

(def: type_param^
  (Parser Type_Parameter)
  (<>.either (do <>.monad
               [param_name <code>.local_identifier]
               (wrap [param_name (list)]))
             (<code>.tuple (do <>.monad
                             [param_name <code>.local_identifier
                              _ (<code>.this! (' <))
                              bounds (<>.many (..generic_type^ (list)))]
                             (wrap [param_name bounds])))))

(def: type_params^
  (Parser (List Type_Parameter))
  (|> ..type_param^
      <>.some
      <code>.tuple
      (<>.default (list))))

(def: class_decl^
  (Parser Class_Declaration)
  (<>.either (do <>.monad
               [name <code>.local_identifier
                _ (assert_no_periods name)]
               (wrap [name (list)]))
             (<code>.form (do <>.monad
                            [name <code>.local_identifier
                             _ (assert_no_periods name)
                             params (<>.some ..type_param^)]
                            (wrap [name params])))
             ))

(def: (super_class_decl^ type_vars)
  (-> (List Type_Parameter) (Parser Super_Class_Decl))
  (<>.either (do <>.monad
               [name <code>.local_identifier
                _ (assert_no_periods name)]
               (wrap [name (list)]))
             (<code>.form (do <>.monad
                            [name <code>.local_identifier
                             _ (assert_no_periods name)
                             params (<>.some (..generic_type^ type_vars))]
                            (wrap [name params])))))

(def: annotation_params^
  (Parser (List AnnotationParam))
  (<code>.record (<>.some (<>.and <code>.local_tag <code>.any))))

(def: annotation^
  (Parser Annotation)
  (<>.either (do <>.monad
               [ann_name <code>.local_identifier]
               (wrap [ann_name (list)]))
             (<code>.form (<>.and <code>.local_identifier
                                  annotation_params^))))

(def: annotations^'
  (Parser (List Annotation))
  (do <>.monad
    [_ (<code>.this! (' #ann))]
    (<code>.tuple (<>.some ..annotation^))))

(def: annotations^
  (Parser (List Annotation))
  (do <>.monad
    [anns?? (<>.maybe ..annotations^')]
    (wrap (maybe.default (list) anns??))))

(def: (throws_decl'^ type_vars)
  (-> (List Type_Parameter) (Parser (List GenericType)))
  (do <>.monad
    [_ (<code>.this! (' #throws))]
    (<code>.tuple (<>.some (..generic_type^ type_vars)))))

(def: (throws_decl^ type_vars)
  (-> (List Type_Parameter) (Parser (List GenericType)))
  (do <>.monad
    [exs? (<>.maybe (throws_decl'^ type_vars))]
    (wrap (maybe.default (list) exs?))))

(def: (method_decl^ type_vars)
  (-> (List Type_Parameter) (Parser [Member_Declaration MethodDecl]))
  (<code>.form (do <>.monad
                 [tvars ..type_params^
                  name <code>.local_identifier
                  anns ..annotations^
                  inputs (<code>.tuple (<>.some (..generic_type^ type_vars)))
                  output (..generic_type^ type_vars)
                  exs (..throws_decl^ type_vars)]
                 (wrap [[name #PublicPM anns] {#method_tvars tvars
                                               #method_inputs inputs
                                               #method_output output
                                               #method_exs    exs}]))))

(def: state_modifier^
  (Parser StateModifier)
  ($_ <>.or
      (<code>.this! (' #volatile))
      (<code>.this! (' #final))
      (\ <>.monad wrap [])))

(def: (field_decl^ type_vars)
  (-> (List Type_Parameter) (Parser [Member_Declaration FieldDecl]))
  (<>.either (<code>.form (do <>.monad
                            [_ (<code>.this! (' #const))
                             name <code>.local_identifier
                             anns ..annotations^
                             type (..generic_type^ type_vars)
                             body <code>.any]
                            (wrap [[name #PublicPM anns] (#ConstantField [type body])])))
             (<code>.form (do <>.monad
                            [pm privacy_modifier^
                             sm state_modifier^
                             name <code>.local_identifier
                             anns ..annotations^
                             type (..generic_type^ type_vars)]
                            (wrap [[name pm anns] (#VariableField [sm type])])))))

(def: (arg_decl^ type_vars)
  (-> (List Type_Parameter) (Parser ArgDecl))
  (<code>.record (<>.and <code>.local_identifier
                         (..generic_type^ type_vars))))

(def: (arg_decls^ type_vars)
  (-> (List Type_Parameter) (Parser (List ArgDecl)))
  (<>.some (arg_decl^ type_vars)))

(def: (constructor_arg^ type_vars)
  (-> (List Type_Parameter) (Parser ConstructorArg))
  (<code>.record (<>.and (..generic_type^ type_vars) <code>.any)))

(def: (constructor_args^ type_vars)
  (-> (List Type_Parameter) (Parser (List ConstructorArg)))
  (<code>.tuple (<>.some (constructor_arg^ type_vars))))

(def: (constructor_method^ class_vars)
  (-> (List Type_Parameter) (Parser [Member_Declaration Method_Definition]))
  (<code>.form (do <>.monad
                 [pm privacy_modifier^
                  strict_fp? (<>.parses? (<code>.this! (' #strict)))
                  method_vars ..type_params^
                  #let [total_vars (list\compose class_vars method_vars)]
                  [_ arg_decls] (<code>.form (<>.and (<code>.this! (' new))
                                                     (..arg_decls^ total_vars)))
                  constructor_args (..constructor_args^ total_vars)
                  exs (..throws_decl^ total_vars)
                  annotations ..annotations^
                  body <code>.any]
                 (wrap [{#member_name constructor_method_name
                         #member_privacy pm
                         #member_anns annotations}
                        (#ConstructorMethod strict_fp? method_vars arg_decls constructor_args body exs)]))))

(def: (virtual_method_def^ class_vars)
  (-> (List Type_Parameter) (Parser [Member_Declaration Method_Definition]))
  (<code>.form (do <>.monad
                 [pm privacy_modifier^
                  strict_fp? (<>.parses? (<code>.this! (' #strict)))
                  final? (<>.parses? (<code>.this! (' #final)))
                  method_vars ..type_params^
                  #let [total_vars (list\compose class_vars method_vars)]
                  [name this_name arg_decls] (<code>.form ($_ <>.and
                                                              <code>.local_identifier
                                                              <code>.local_identifier
                                                              (..arg_decls^ total_vars)))
                  return_type (..generic_type^ total_vars)
                  exs (..throws_decl^ total_vars)
                  annotations ..annotations^
                  body <code>.any]
                 (wrap [{#member_name name
                         #member_privacy pm
                         #member_anns annotations}
                        (#VirtualMethod final? strict_fp?
                                        method_vars
                                        this_name arg_decls return_type
                                        body exs)]))))

(def: overriden_method_def^
  (Parser [Member_Declaration Method_Definition])
  (<code>.form (do <>.monad
                 [strict_fp? (<>.parses? (<code>.this! (' #strict)))
                  owner_class ..class_decl^
                  method_vars ..type_params^
                  #let [total_vars (list\compose (product.right owner_class) method_vars)]
                  [name this_name arg_decls] (<code>.form ($_ <>.and
                                                              <code>.local_identifier
                                                              <code>.local_identifier
                                                              (..arg_decls^ total_vars)))
                  return_type (..generic_type^ total_vars)
                  exs (..throws_decl^ total_vars)
                  annotations ..annotations^
                  body <code>.any]
                 (wrap [{#member_name name
                         #member_privacy #PublicPM
                         #member_anns annotations}
                        (#OverridenMethod strict_fp?
                                          owner_class method_vars
                                          this_name arg_decls return_type
                                          body exs)]))))

(def: static_method_def^
  (Parser [Member_Declaration Method_Definition])
  (<code>.form (do <>.monad
                 [pm privacy_modifier^
                  strict_fp? (<>.parses? (<code>.this! (' #strict)))
                  _ (<code>.this! (' #static))
                  method_vars ..type_params^
                  #let [total_vars method_vars]
                  [name arg_decls] (<code>.form (<>.and <code>.local_identifier
                                                        (..arg_decls^ total_vars)))
                  return_type (..generic_type^ total_vars)
                  exs (..throws_decl^ total_vars)
                  annotations ..annotations^
                  body <code>.any]
                 (wrap [{#member_name name
                         #member_privacy pm
                         #member_anns annotations}
                        (#StaticMethod strict_fp? method_vars arg_decls return_type body exs)]))))

(def: abstract_method_def^
  (Parser [Member_Declaration Method_Definition])
  (<code>.form (do <>.monad
                 [pm privacy_modifier^
                  _ (<code>.this! (' #abstract))
                  method_vars ..type_params^
                  #let [total_vars method_vars]
                  [name arg_decls] (<code>.form (<>.and <code>.local_identifier
                                                        (..arg_decls^ total_vars)))
                  return_type (..generic_type^ total_vars)
                  exs (..throws_decl^ total_vars)
                  annotations ..annotations^]
                 (wrap [{#member_name name
                         #member_privacy pm
                         #member_anns annotations}
                        (#AbstractMethod method_vars arg_decls return_type exs)]))))

(def: native_method_def^
  (Parser [Member_Declaration Method_Definition])
  (<code>.form (do <>.monad
                 [pm privacy_modifier^
                  _ (<code>.this! (' #native))
                  method_vars ..type_params^
                  #let [total_vars method_vars]
                  [name arg_decls] (<code>.form (<>.and <code>.local_identifier
                                                        (..arg_decls^ total_vars)))
                  return_type (..generic_type^ total_vars)
                  exs (..throws_decl^ total_vars)
                  annotations ..annotations^]
                 (wrap [{#member_name name
                         #member_privacy pm
                         #member_anns annotations}
                        (#NativeMethod method_vars arg_decls return_type exs)]))))

(def: (method_def^ class_vars)
  (-> (List Type_Parameter) (Parser [Member_Declaration Method_Definition]))
  ($_ <>.either
      (..constructor_method^ class_vars)
      (..virtual_method_def^ class_vars)
      ..overriden_method_def^
      ..static_method_def^
      ..abstract_method_def^
      ..native_method_def^))

(def: partial_call^
  (Parser Partial_Call)
  (<code>.form (<>.and <code>.identifier (<>.some <code>.any))))

(def: class_kind^
  (Parser Class_Kind)
  (<>.either (do <>.monad
               [_ (<code>.this! (' #class))]
               (wrap #Class))
             (do <>.monad
               [_ (<code>.this! (' #interface))]
               (wrap #Interface))
             ))

(def: import_member_alias^
  (Parser (Maybe Text))
  (<>.maybe (do <>.monad
              [_ (<code>.this! (' #as))]
              <code>.local_identifier)))

(def: (import_member_args^ type_vars)
  (-> (List Type_Parameter) (Parser (List [Bit GenericType])))
  (<code>.tuple (<>.some (<>.and (<>.parses? (<code>.this! (' #?))) (..generic_type^ type_vars)))))

(def: import_member_return_flags^
  (Parser [Bit Bit Bit])
  ($_ <>.and (<>.parses? (<code>.this! (' #io))) (<>.parses? (<code>.this! (' #try))) (<>.parses? (<code>.this! (' #?)))))

(def: primitive_mode^
  (Parser Primitive_Mode)
  (<>.or (<code>.this! (' #manual))
         (<code>.this! (' #auto))))

(def: (import_member_decl^ owner_vars)
  (-> (List Type_Parameter) (Parser Import_Member_Declaration))
  ($_ <>.either
      (<code>.form (do <>.monad
                     [_ (<code>.this! (' #enum))
                      enum_members (<>.some <code>.local_identifier)]
                     (wrap (#EnumDecl enum_members))))
      (<code>.form (do <>.monad
                     [tvars ..type_params^
                      _ (<code>.this! (' new))
                      ?alias import_member_alias^
                      #let [total_vars (list\compose owner_vars tvars)]
                      ?prim_mode (<>.maybe primitive_mode^)
                      args (..import_member_args^ total_vars)
                      [io? try? maybe?] import_member_return_flags^]
                     (wrap (#ConstructorDecl [{#import_member_mode    (maybe.default #AutoPrM ?prim_mode)
                                               #import_member_alias   (maybe.default "new" ?alias)
                                               #import_member_kind    #VirtualIMK
                                               #import_member_tvars   tvars
                                               #import_member_args    args
                                               #import_member_maybe?  maybe?
                                               #import_member_try?    try?
                                               #import_member_io?     io?}
                                              {}]))
                     ))
      (<code>.form (do <>.monad
                     [kind (: (Parser ImportMethodKind)
                              (<>.or (<code>.this! (' #static))
                                     (wrap [])))
                      tvars ..type_params^
                      name <code>.local_identifier
                      ?alias import_member_alias^
                      #let [total_vars (list\compose owner_vars tvars)]
                      ?prim_mode (<>.maybe primitive_mode^)
                      args (..import_member_args^ total_vars)
                      [io? try? maybe?] import_member_return_flags^
                      return (..generic_type^ total_vars)]
                     (wrap (#MethodDecl [{#import_member_mode    (maybe.default #AutoPrM ?prim_mode)
                                          #import_member_alias   (maybe.default name ?alias)
                                          #import_member_kind    kind
                                          #import_member_tvars   tvars
                                          #import_member_args    args
                                          #import_member_maybe?  maybe?
                                          #import_member_try?    try?
                                          #import_member_io?     io?}
                                         {#import_method_name    name
                                          #import_method_return  return
                                          }]))))
      (<code>.form (do <>.monad
                     [static? (<>.parses? (<code>.this! (' #static)))
                      name <code>.local_identifier
                      ?prim_mode (<>.maybe primitive_mode^)
                      gtype (..generic_type^ owner_vars)
                      maybe? (<>.parses? (<code>.this! (' #?)))
                      setter? (<>.parses? (<code>.this! (' #!)))]
                     (wrap (#FieldAccessDecl {#import_field_mode    (maybe.default #AutoPrM ?prim_mode)
                                              #import_field_name    name
                                              #import_field_static? static?
                                              #import_field_maybe?  maybe?
                                              #import_field_setter? setter?
                                              #import_field_type    gtype}))))
      ))

(def: bundle
  (-> (List Type_Parameter) (Parser [Text (List Import_Member_Declaration)]))
  (|>> ..import_member_decl^
       <>.some
       (<>.and <code>.text)
       <code>.tuple))

## Generators
(def: with_parens
  (-> JVM_Code JVM_Code)
  (text.enclose ["(" ")"]))

(def: with_brackets
  (-> JVM_Code JVM_Code)
  (text.enclose ["[" "]"]))

(def: spaced
  (-> (List JVM_Code) JVM_Code)
  (text.join_with " "))

(def: (privacy_modifier$ pm)
  (-> PrivacyModifier JVM_Code)
  (case pm
    #PublicPM    "public"
    #PrivatePM   "private"
    #ProtectedPM "protected"
    #DefaultPM   "default"))

(def: (inheritance_modifier$ im)
  (-> InheritanceModifier JVM_Code)
  (case im
    #FinalIM    "final"
    #AbstractIM "abstract"
    #DefaultIM  "default"))

(def: (annotation_param$ [name value])
  (-> AnnotationParam JVM_Code)
  (format name "=" (code.format value)))

(def: (annotation$ [name params])
  (-> Annotation JVM_Code)
  (format "(" name " " "{" (text.join_with text.tab (list\map annotation_param$ params)) "}" ")"))

(def: (bound_kind$ kind)
  (-> BoundKind JVM_Code)
  (case kind
    #UpperBound "<"
    #LowerBound ">"))

(def: (generic_type$ gtype)
  (-> GenericType JVM_Code)
  (case gtype
    (#GenericTypeVar name)
    name

    (#GenericClass name params)
    (format "(" (sanitize name) " " (spaced (list\map generic_type$ params)) ")")
    
    (#GenericArray param)
    (format "(" array.type_name " " (generic_type$ param) ")")
    
    (#GenericWildcard #.None)
    "?"

    (#GenericWildcard (#.Some [bound_kind bound]))
    (format (bound_kind$ bound_kind) (generic_type$ bound))))

(def: (type_param$ [name bounds])
  (-> Type_Parameter JVM_Code)
  (format "(" name " " (spaced (list\map generic_type$ bounds)) ")"))

(def: (class_decl$ (^open "."))
  (-> Class_Declaration JVM_Code)
  (format "(" (sanitize class_name) " " (spaced (list\map type_param$ class_params)) ")"))

(def: (super_class_decl$ (^slots [#super_class_name #super_class_params]))
  (-> Super_Class_Decl JVM_Code)
  (format "(" (sanitize super_class_name) " " (spaced (list\map generic_type$ super_class_params)) ")"))

(def: (method_decl$ [[name pm anns] method_decl])
  (-> [Member_Declaration MethodDecl] JVM_Code)
  (let [(^slots [#method_tvars #method_inputs #method_output #method_exs]) method_decl]
    (with_parens
      (spaced (list name
                    (with_brackets (spaced (list\map annotation$ anns)))
                    (with_brackets (spaced (list\map type_param$ method_tvars)))
                    (with_brackets (spaced (list\map generic_type$ method_exs)))
                    (with_brackets (spaced (list\map generic_type$ method_inputs)))
                    (generic_type$ method_output))
              ))))

(def: (state_modifier$ sm)
  (-> StateModifier JVM_Code)
  (case sm
    #VolatileSM "volatile"
    #FinalSM    "final"
    #DefaultSM  "default"))

(def: (field_decl$ [[name pm anns] field])
  (-> [Member_Declaration FieldDecl] JVM_Code)
  (case field
    (#ConstantField class value)
    (with_parens
      (spaced (list "constant" name
                    (with_brackets (spaced (list\map annotation$ anns)))
                    (generic_type$ class)
                    (code.format value))
              ))

    (#VariableField sm class)
    (with_parens
      (spaced (list "variable" name
                    (privacy_modifier$ pm)
                    (state_modifier$ sm)
                    (with_brackets (spaced (list\map annotation$ anns)))
                    (generic_type$ class))
              ))
    ))

(def: (arg_decl$ [name type])
  (-> ArgDecl JVM_Code)
  (with_parens
    (spaced (list name (generic_type$ type)))))

(def: (constructor_arg$ [class term])
  (-> ConstructorArg JVM_Code)
  (with_brackets
    (spaced (list (generic_type$ class) (code.format term)))))

(def: (method_def$ replacer super_class [[name pm anns] method_def])
  (-> (-> Code Code) Super_Class_Decl [Member_Declaration Method_Definition] JVM_Code)
  (case method_def
    (#ConstructorMethod strict_fp? type_vars arg_decls constructor_args body exs)
    (with_parens
      (spaced (list "init"
                    (privacy_modifier$ pm)
                    (bit\encode strict_fp?)
                    (with_brackets (spaced (list\map annotation$ anns)))
                    (with_brackets (spaced (list\map type_param$ type_vars)))
                    (with_brackets (spaced (list\map generic_type$ exs)))
                    (with_brackets (spaced (list\map arg_decl$ arg_decls)))
                    (with_brackets (spaced (list\map constructor_arg$ constructor_args)))
                    (code.format (pre_walk_replace replacer body))
                    )))
    
    (#VirtualMethod final? strict_fp? type_vars this_name arg_decls return_type body exs)
    (with_parens
      (spaced (list "virtual"
                    name
                    (privacy_modifier$ pm)
                    (bit\encode final?)
                    (bit\encode strict_fp?)
                    (with_brackets (spaced (list\map annotation$ anns)))
                    (with_brackets (spaced (list\map type_param$ type_vars)))
                    (with_brackets (spaced (list\map generic_type$ exs)))
                    (with_brackets (spaced (list\map arg_decl$ arg_decls)))
                    (generic_type$ return_type)
                    (code.format (pre_walk_replace replacer (` (let [(~ (code.local_identifier this_name)) (~' _jvm_this)]
                                                                 (~ body))))))))
    
    (#OverridenMethod strict_fp? class_decl type_vars this_name arg_decls return_type body exs)
    (let [super_replacer (parser->replacer (<code>.form (do <>.monad
                                                          [_ (<code>.this! (' ::super!))
                                                           args (<code>.tuple (<>.exactly (list.size arg_decls) <code>.any))
                                                           #let [arg_decls' (: (List Text) (list\map (|>> product.right (simple_class$ (list)))
                                                                                                     arg_decls))]]
                                                          (wrap (`' ((~ (code.text (format "jvm invokespecial"
                                                                                           ":" (get@ #super_class_name super_class)
                                                                                           ":" name
                                                                                           ":" (text.join_with "," arg_decls'))))
                                                                     (~' _jvm_this) (~+ args)))))))]
      (with_parens
        (spaced (list "override"
                      (class_decl$ class_decl)
                      name
                      (bit\encode strict_fp?)
                      (with_brackets (spaced (list\map annotation$ anns)))
                      (with_brackets (spaced (list\map type_param$ type_vars)))
                      (with_brackets (spaced (list\map generic_type$ exs)))
                      (with_brackets (spaced (list\map arg_decl$ arg_decls)))
                      (generic_type$ return_type)
                      (|> (` (let [(~ (code.local_identifier this_name)) (~' _jvm_this)]
                               (~ body)))
                          (pre_walk_replace replacer)
                          (pre_walk_replace super_replacer)
                          (code.format))
                      ))))

    (#StaticMethod strict_fp? type_vars arg_decls return_type body exs)
    (with_parens
      (spaced (list "static"
                    name
                    (privacy_modifier$ pm)
                    (bit\encode strict_fp?)
                    (with_brackets (spaced (list\map annotation$ anns)))
                    (with_brackets (spaced (list\map type_param$ type_vars)))
                    (with_brackets (spaced (list\map generic_type$ exs)))
                    (with_brackets (spaced (list\map arg_decl$ arg_decls)))
                    (generic_type$ return_type)
                    (code.format (pre_walk_replace replacer body)))))

    (#AbstractMethod type_vars arg_decls return_type exs)
    (with_parens
      (spaced (list "abstract"
                    name
                    (privacy_modifier$ pm)
                    (with_brackets (spaced (list\map annotation$ anns)))
                    (with_brackets (spaced (list\map type_param$ type_vars)))
                    (with_brackets (spaced (list\map generic_type$ exs)))
                    (with_brackets (spaced (list\map arg_decl$ arg_decls)))
                    (generic_type$ return_type))))

    (#NativeMethod type_vars arg_decls return_type exs)
    (with_parens
      (spaced (list "native"
                    name
                    (privacy_modifier$ pm)
                    (with_brackets (spaced (list\map annotation$ anns)))
                    (with_brackets (spaced (list\map type_param$ type_vars)))
                    (with_brackets (spaced (list\map generic_type$ exs)))
                    (with_brackets (spaced (list\map arg_decl$ arg_decls)))
                    (generic_type$ return_type))))
    ))

(def: (complete_call$ g!obj [method args])
  (-> Code Partial_Call Code)
  (` ((~ (code.identifier method)) (~+ args) (~ g!obj))))

## [Syntax]
(def: object_super_class
  Super_Class_Decl
  {#super_class_name   "java/lang/Object"
   #super_class_params (list)})

(syntax: #export (class:
                   {im inheritance_modifier^}
                   {class_decl ..class_decl^}
                   {#let [full_class_name (product.left class_decl)]}
                   {#let [class_vars (product.right class_decl)]}
                   {super (<>.default object_super_class
                                      (..super_class_decl^ class_vars))}
                   {interfaces (<>.default (list)
                                           (<code>.tuple (<>.some (..super_class_decl^ class_vars))))}
                   {annotations ..annotations^}
                   {fields (<>.some (..field_decl^ class_vars))}
                   {methods (<>.some (..method_def^ class_vars))})
  {#.doc (doc "Allows defining JVM classes in Lux code."
              "For example:"
              (class: #final (TestClass A) [Runnable]
                ## Fields
                (#private foo boolean)
                (#private bar A)
                (#private baz java/lang/Object)
                ## Methods
                (#public [] (new [value A]) []
                         (exec (:= ::foo #1)
                           (:= ::bar value)
                           (:= ::baz "")
                           []))
                (#public (virtual) java/lang/Object
                         "")
                (#public #static (static) java/lang/Object
                         "")
                (Runnable [] (run) void
                          [])
                )

              "The tuple corresponds to parent interfaces."
              "An optional super-class can be specified before the tuple. If not specified, java.lang.Object will be assumed."
              "Fields and methods defined in the class can be used with special syntax."
              "For example:"
              "::resolved, for accessing the 'resolved' field."
              "(:= ::resolved #1) for modifying it."
              "(::new! []) for calling the class's constructor."
              "(::resolve! container [value]) for calling the 'resolve' method."
              )}
  (do meta.monad
    [current_module meta.current_module_name
     #let [fully_qualified_class_name (format (sanitize current_module) "." full_class_name)
           field_parsers (list\map (field->parser fully_qualified_class_name) fields)
           method_parsers (list\map (method->parser (product.right class_decl) fully_qualified_class_name) methods)
           replacer (parser->replacer (list\fold <>.either
                                                 (<>.fail "")
                                                 (list\compose field_parsers method_parsers)))
           def_code (format "jvm class:"
                            (spaced (list (class_decl$ class_decl)
                                          (super_class_decl$ super)
                                          (with_brackets (spaced (list\map super_class_decl$ interfaces)))
                                          (inheritance_modifier$ im)
                                          (with_brackets (spaced (list\map annotation$ annotations)))
                                          (with_brackets (spaced (list\map field_decl$ fields)))
                                          (with_brackets (spaced (list\map (method_def$ replacer super) methods))))))]]
    (wrap (list (` ((~ (code.text def_code))))))))

(syntax: #export (interface:
                   {class_decl ..class_decl^}
                   {#let [class_vars (product.right class_decl)]}
                   {supers (<>.default (list)
                                       (<code>.tuple (<>.some (..super_class_decl^ class_vars))))}
                   {annotations ..annotations^}
                   {members (<>.some (..method_decl^ class_vars))})
  {#.doc (doc "Allows defining JVM interfaces."
              (interface: TestInterface
                ([] foo [boolean String] void #throws [Exception])))}
  (let [def_code (format "jvm interface:"
                         (spaced (list (class_decl$ class_decl)
                                       (with_brackets (spaced (list\map super_class_decl$ supers)))
                                       (with_brackets (spaced (list\map annotation$ annotations)))
                                       (spaced (list\map method_decl$ members)))))]
    (wrap (list (` ((~ (code.text def_code))))))
    ))

(syntax: #export (object
                   {class_vars (<code>.tuple (<>.some ..type_param^))}
                   {super (<>.default object_super_class
                                      (..super_class_decl^ class_vars))}
                   {interfaces (<>.default (list)
                                           (<code>.tuple (<>.some (..super_class_decl^ class_vars))))}
                   {constructor_args (..constructor_args^ class_vars)}
                   {methods (<>.some ..overriden_method_def^)})
  {#.doc (doc "Allows defining anonymous classes."
              "The 1st tuple corresponds to class-level type-variables."
              "The 2nd tuple corresponds to parent interfaces."
              "The 3rd tuple corresponds to arguments to the super class constructor."
              "An optional super-class can be specified before the 1st tuple. If not specified, java.lang.Object will be assumed."
              (object [] [Runnable]
                []
                (Runnable [] (run self) void
                          (exec (do_something some_value)
                            [])))
              )}
  (let [def_code (format "jvm anon-class:"
                         (spaced (list (super_class_decl$ super)
                                       (with_brackets (spaced (list\map super_class_decl$ interfaces)))
                                       (with_brackets (spaced (list\map constructor_arg$ constructor_args)))
                                       (with_brackets (spaced (list\map (method_def$ function.identity super) methods))))))]
    (wrap (list (` ((~ (code.text def_code))))))))

(syntax: #export (null)
  {#.doc (doc "Null object reference."
              (null))}
  (wrap (list (` ("jvm object null")))))

(def: #export (null? obj)
  {#.doc (doc "Test for null object reference."
              (= (null? (null))
                 true)
              (= (null? "YOLO")
                 false))}
  (-> (primitive "java.lang.Object") Bit)
  ("jvm object null?" obj))

(syntax: #export (??? expr)
  {#.doc (doc "Takes a (potentially null) ObjectType reference and creates a (Maybe ObjectType) for it."
              (= (??? (: java/lang/String (null)))
                 #.None)
              (= (??? "YOLO")
                 (#.Some "YOLO")))}
  (with_gensyms [g!temp]
    (wrap (list (` (let [(~ g!temp) (~ expr)]
                     (if ("jvm object null?" (~ g!temp))
                       #.None
                       (#.Some (~ g!temp)))))))))

(syntax: #export (!!! expr)
  {#.doc (doc "Takes a (Maybe ObjectType) and returns a ObjectType."
              "A #.None would get translated into a (null)."
              (= (null)
                 (!!! (??? (: java/lang/Thread (null)))))
              (= "foo"
                 (!!! (??? "foo"))))}
  (with_gensyms [g!value]
    (wrap (list (` ({(#.Some (~ g!value))
                     (~ g!value)

                     #.None
                     ("jvm object null")}
                    (~ expr)))))))

(syntax: #export (try expression)
  {#.doc (doc (case (try (risky_computation input))
                (#.Right success)
                (do_something success)

                (#.Left error)
                (recover_from_failure error)))}
  (wrap (list (` ("lux try" ((~! io.io) (~ expression)))))))

(syntax: #export (check {class (..generic_type^ (list))}
                        {unchecked (<>.maybe <code>.any)})
  {#.doc (doc "Checks whether an object is an instance of a particular class."
              "Caveat emptor: Cannot check for polymorphism, so avoid using parameterized classes."
              (case (check java/lang/String "YOLO")
                (#.Some value_as_string)
                #.None))}
  (with_gensyms [g!_ g!unchecked]
    (let [class_name (simple_class$ (list) class)
          class_type (` (.primitive (~ (code.text class_name))))
          check_type (` (.Maybe (~ class_type)))
          check_code (` (if ((~ (code.text (format "jvm instanceof" ":" class_name))) (~ g!unchecked))
                          (#.Some (.:coerce (~ class_type)
                                            (~ g!unchecked)))
                          #.None))]
      (case unchecked
        (#.Some unchecked)
        (wrap (list (` (: (~ check_type)
                          (let [(~ g!unchecked) (~ unchecked)]
                            (~ check_code))))))

        #.None
        (wrap (list (` (: (-> (primitive "java.lang.Object") (~ check_type))
                          (function ((~ g!_) (~ g!unchecked))
                            (~ check_code))))))
        ))))

(syntax: #export (synchronized lock body)
  {#.doc (doc "Evaluates body, while holding a lock on a given object."
              (synchronized object_to_be_locked
                (exec (do_something ___)
                  (do_something_else ___)
                  (finish_the_computation ___))))}
  (wrap (list (` ("jvm object synchronized" (~ lock) (~ body))))))

(syntax: #export (do_to obj {methods (<>.some partial_call^)})
  {#.doc (doc "Call a variety of methods on an object. Then, return the object."
              (do_to object
                (ClassName::method1 arg0 arg1 arg2)
                (ClassName::method2 arg3 arg4 arg5)))}
  (with_gensyms [g!obj]
    (wrap (list (` (let [(~ g!obj) (~ obj)]
                     (exec (~+ (list\map (complete_call$ g!obj) methods))
                       (~ g!obj))))))))

(def: (class_import$ [full_name params])
  (-> Class_Declaration Code)
  (let [params' (list\map (|>> product.left code.local_identifier) params)]
    (` (def: (~ (code.identifier ["" full_name]))
         {#..jvm_class (~ (code.text full_name))}
         Type
         (All [(~+ params')]
           (primitive (~ (code.text (sanitize full_name)))
                      [(~+ params')]))))))

(def: (member_type_vars class_tvars member)
  (-> (List Type_Parameter) Import_Member_Declaration (List Type_Parameter))
  (case member
    (#ConstructorDecl [commons _])
    (list\compose class_tvars (get@ #import_member_tvars commons))

    (#MethodDecl [commons _])
    (case (get@ #import_member_kind commons)
      #StaticIMK
      (get@ #import_member_tvars commons)

      _
      (list\compose class_tvars (get@ #import_member_tvars commons)))

    _
    class_tvars))

(def: (member_def_arg_bindings type_params class member)
  (-> (List Type_Parameter) Class_Declaration Import_Member_Declaration (Meta [(List [Bit Code]) (List Text) (List Code)]))
  (case member
    (^or (#ConstructorDecl [commons _]) (#MethodDecl [commons _]))
    (let [(^slots [#import_member_tvars #import_member_args]) commons]
      (do {! meta.monad}
        [arg_inputs (monad.map !
                               (: (-> [Bit GenericType] (Meta [Bit Code]))
                                  (function (_ [maybe? _])
                                    (with_gensyms [arg_name]
                                      (wrap [maybe? arg_name]))))
                               import_member_args)
         #let [arg_classes (: (List Text)
                              (list\map (|>> product.right (simple_class$ (list\compose type_params import_member_tvars)))
                                        import_member_args))
               arg_types (list\map (: (-> [Bit GenericType] Code)
                                      (function (_ [maybe? arg])
                                        (let [arg_type (class->type (get@ #import_member_mode commons) type_params arg)]
                                          (if maybe?
                                            (` (Maybe (~ arg_type)))
                                            arg_type))))
                                   import_member_args)]]
        (wrap [arg_inputs arg_classes arg_types])))

    _
    (\ meta.monad wrap [(list) (list) (list)])))

(def: (decorate_return_maybe class member return_term)
  (-> Class_Declaration Import_Member_Declaration Code Code)
  (case member
    (^or (#ConstructorDecl [commons _]) (#MethodDecl [commons _]))
    (if (get@ #import_member_maybe? commons)
      (` (??? (~ return_term)))
      (let [g!temp (` ((~' ~') (~ (code.identifier ["" "  "]))))]
        (` (let [(~ g!temp) (~ return_term)]
             (if (not (..null? (:coerce (primitive "java.lang.Object")
                                        (~ g!temp))))
               (~ g!temp)
               (error! (~ (code.text (format "Cannot produce null references from method calls @ "
                                             (get@ #class_name class)
                                             "." (get@ #import_member_alias commons))))))))))

    _
    return_term))

(template [<name> <tag> <term_trans>]
  [(def: (<name> member return_term)
     (-> Import_Member_Declaration Code Code)
     (case member
       (^or (#ConstructorDecl [commons _]) (#MethodDecl [commons _]))
       (if (get@ <tag> commons)
         <term_trans>
         return_term)

       _
       return_term))]

  [decorate_return_try #import_member_try? (` (..try (~ return_term)))]
  [decorate_return_io  #import_member_io?  (` ((~! io.io) (~ return_term)))]
  )

(def: (free_type_param? [name bounds])
  (-> Type_Parameter Bit)
  (case bounds
    #.Nil #1
    _     #0))

(def: (type_param->type_arg [name _])
  (-> Type_Parameter Code)
  (code.identifier ["" name]))

(template [<name> <byte> <short> <int> <float>]
  [(def: (<name> mode [class expression])
     (-> Primitive_Mode [Text Code] Code)
     (case mode
       #ManualPrM
       expression
       
       #AutoPrM
       (case class
         "byte"  (` (<byte> (~ expression)))
         "short" (` (<short> (~ expression)))
         "int"   (` (<int> (~ expression)))
         "float" (` (<float> (~ expression)))
         _       expression)))]

  [auto_convert_input  long_to_byte long_to_short long_to_int double_to_float]
  [auto_convert_output byte_to_long short_to_long int_to_long float_to_double]
  )

(def: (un_quote quoted)
  (-> Code Code)
  (` ((~' ~) (~ quoted))))

(def: (jvm_extension_inputs mode classes inputs)
  (-> Primitive_Mode (List Text) (List [Bit Code]) (List Code))
  (|> inputs
      (list\map (function (_ [maybe? input])
                  (if maybe?
                    (` ((~! !!!) (~ (un_quote input))))
                    (un_quote input))))
      (list.zip/2 classes)
      (list\map (auto_convert_input mode))))

(def: (import_name format class member)
  (-> Text Text Text Text)
  (|> format
      (text.replace_all "#" class)
      (text.replace_all "." member)))

(def: (member_def_interop type_params kind class [arg_function_inputs arg_classes arg_types] member method_prefix import_format)
  (-> (List Type_Parameter) Class_Kind Class_Declaration [(List [Bit Code]) (List Text) (List Code)] Import_Member_Declaration Text Text (Meta (List Code)))
  (let [[full_name class_tvars] class
        full_name (sanitize full_name)
        all_params (|> (member_type_vars class_tvars member)
                       (list.filter free_type_param?)
                       (list\map type_param->type_arg))]
    (case member
      (#EnumDecl enum_members)
      (do {! meta.monad}
        [#let [enum_type (: Code
                            (case class_tvars
                              #.Nil
                              (` (primitive (~ (code.text full_name))))

                              _
                              (let [=class_tvars (|> class_tvars
                                                     (list.filter free_type_param?)
                                                     (list\map type_param->type_arg))]
                                (` (All [(~+ =class_tvars)] (primitive (~ (code.text full_name)) [(~+ =class_tvars)]))))))
               getter_interop (: (-> Text Code)
                                 (function (_ name)
                                   (let [getter_name (code.identifier ["" (..import_name import_format method_prefix name)])]
                                     (` (def: (~ getter_name)
                                          (~ enum_type)
                                          ((~ (code.text (format "jvm getstatic" ":" full_name ":" name)))))))))]]
        (wrap (list\map getter_interop enum_members)))
      
      (#ConstructorDecl [commons _])
      (do meta.monad
        [#let [def_name (code.identifier ["" (..import_name import_format method_prefix (get@ #import_member_alias commons))])
               jvm_extension (code.text (format "jvm new" ":" full_name ":" (text.join_with "," arg_classes)))
               jvm_interop (|> (` ((~ jvm_extension)
                                   (~+ (jvm_extension_inputs (get@ #import_member_mode commons) arg_classes arg_function_inputs))))
                               (decorate_return_maybe class member)
                               (decorate_return_try member)
                               (decorate_return_io member))]]
        (wrap (list (` ((~! syntax:) ((~ def_name) (~+ (list\map product.right arg_function_inputs)))
                        ((~' wrap) (.list (.` (~ jvm_interop)))))))))

      (#MethodDecl [commons method])
      (with_gensyms [g!obj]
        (do meta.monad
          [#let [def_name (code.identifier ["" (..import_name import_format method_prefix (get@ #import_member_alias commons))])
                 (^slots [#import_member_kind]) commons
                 (^slots [#import_method_name]) method
                 [jvm_op object_ast] (: [Text (List Code)]
                                        (case import_member_kind
                                          #StaticIMK
                                          ["invokestatic"
                                           (list)]

                                          #VirtualIMK
                                          (case kind
                                            #Class
                                            ["invokevirtual"
                                             (list g!obj)]
                                            
                                            #Interface
                                            ["invokeinterface"
                                             (list g!obj)]
                                            )))
                 jvm_extension (code.text (format "jvm " jvm_op ":" full_name ":" import_method_name ":" (text.join_with "," arg_classes)))
                 jvm_interop (|> [(simple_class$ (list) (get@ #import_method_return method))
                                  (` ((~ jvm_extension) (~+ (list\map un_quote object_ast))
                                      (~+ (jvm_extension_inputs (get@ #import_member_mode commons) arg_classes arg_function_inputs))))]
                                 (auto_convert_output (get@ #import_member_mode commons))
                                 (decorate_return_maybe class member)
                                 (decorate_return_try member)
                                 (decorate_return_io member))]]
          (wrap (list (` ((~! syntax:) ((~ def_name) (~+ (list\map product.right arg_function_inputs)) (~+ object_ast))
                          ((~' wrap) (.list (.` (~ jvm_interop))))))))))

      (#FieldAccessDecl fad)
      (do meta.monad
        [#let [(^open ".") fad
               base_gtype (class->type import_field_mode type_params import_field_type)
               classC (class_decl_type$ class)
               typeC (if import_field_maybe?
                       (` (Maybe (~ base_gtype)))
                       base_gtype)
               tvar_asts (: (List Code)
                            (|> class_tvars
                                (list.filter free_type_param?)
                                (list\map type_param->type_arg)))
               getter_name (code.identifier ["" (..import_name import_format method_prefix import_field_name)])
               setter_name (code.identifier ["" (..import_name import_format method_prefix (format import_field_name "!"))])]
         getter_interop (with_gensyms [g!obj]
                          (let [getter_call (if import_field_static?
                                              (` ((~ getter_name)))
                                              (` ((~ getter_name) (~ g!obj))))
                                getter_body (<| (auto_convert_output import_field_mode)
                                                [(simple_class$ (list) import_field_type)
                                                 (if import_field_static?
                                                   (let [jvm_extension (code.text (format "jvm getstatic" ":" full_name ":" import_field_name))]
                                                     (` ((~ jvm_extension))))
                                                   (let [jvm_extension (code.text (format "jvm getfield" ":" full_name ":" import_field_name))]
                                                     (` ((~ jvm_extension) (~ (un_quote g!obj))))))])
                                getter_body (if import_field_maybe?
                                              (` ((~! ???) (~ getter_body)))
                                              getter_body)
                                getter_body (if import_field_setter?
                                              (` ((~! io.io) (~ getter_body)))
                                              getter_body)]
                            (wrap (` ((~! syntax:) (~ getter_call)
                                      ((~' wrap) (.list (.` (~ getter_body)))))))))
         setter_interop (: (Meta (List Code))
                           (if import_field_setter?
                             (with_gensyms [g!obj g!value]
                               (let [setter_call (if import_field_static?
                                                   (` ((~ setter_name) (~ g!value)))
                                                   (` ((~ setter_name) (~ g!value) (~ g!obj))))
                                     setter_value (auto_convert_input import_field_mode
                                                                      [(simple_class$ (list) import_field_type) (un_quote g!value)])
                                     setter_value (if import_field_maybe?
                                                    (` ((~! !!!) (~ setter_value)))
                                                    setter_value)
                                     setter_command (format (if import_field_static? "jvm putstatic" "jvm putfield")
                                                            ":" full_name ":" import_field_name)
                                     g!obj+ (: (List Code)
                                               (if import_field_static?
                                                 (list)
                                                 (list (un_quote g!obj))))]
                                 (wrap (list (` ((~! syntax:) (~ setter_call)
                                                 ((~' wrap) (.list (.` ((~! io.io) ((~ (code.text setter_command)) (~+ g!obj+) (~ setter_value))))))))))))
                             (wrap (list))))]
        (wrap (list& getter_interop setter_interop)))
      )))

(def: (member_import$ type_params kind class [import_format member])
  (-> (List Type_Parameter) Class_Kind Class_Declaration [Text Import_Member_Declaration] (Meta (List Code)))
  (let [[method_prefix _] class]
    (do meta.monad
      [=args (member_def_arg_bindings type_params class member)]
      (member_def_interop type_params kind class =args member method_prefix import_format))))

(type: (java/lang/Class a)
  (primitive "java.lang.Class" [a]))

(def: interface?
  (All [a] (-> (java/lang/Class a) Bit))
  (|>> "jvm invokevirtual:java.lang.Class:isInterface:"))

(def: (load_class class_name)
  (-> Text (Try (java/lang/Class Any)))
  (..try ("jvm invokestatic:java.lang.Class:forName:java.lang.String" class_name)))

(def: (class_kind [class_name _])
  (-> Class_Declaration (Meta Class_Kind))
  (let [class_name (..sanitize class_name)]
    (case (..load_class class_name)
      (#try.Success class)
      (\ meta.monad wrap (if (interface? class)
                           #Interface
                           #Class))

      (#try.Failure error)
      (meta.fail (format "Cannot load class: " class_name text.new_line
                         error)))))

(syntax: #export (import:
                   {class_decl ..class_decl^}
                   {bundles (<>.some (..bundle (product.right class_decl)))})
  {#.doc (doc "Allows importing JVM classes, and using them as types."
              "Their methods, fields and enum options can also be imported."
              (import: java/lang/Object
                ["#::."
                 (new [])
                 (equals [java/lang/Object] boolean)
                 (wait [int] #io #try void)])
              
              "Special options can also be given for the return values."
              "#? means that the values will be returned inside a Maybe type. That way, null becomes #.None."
              "#try means that the computation might throw an exception, and the return value will be wrapped by the Try type."
              "#io means the computation has side effects, and will be wrapped by the IO type."
              "These options must show up in the following order [#io #try #?] (although, each option can be used independently)."
              (import: java/lang/String
                ["#::."
                 (new [[byte]])
                 (#static valueOf [char] java/lang/String)
                 (#static valueOf #as int_valueOf [int] java/lang/String)])

              (import: (java/util/List e)
                ["#::."
                 (size [] int)
                 (get [int] e)])

              (import: (java/util/ArrayList a)
                ["#::."
                 ([T] toArray [[T]] [T])])
              
              "The class-type that is generated is of the fully-qualified name."
              "This avoids a clash between the java.util.List type, and Lux's own List type."
              "All enum options to be imported must be specified."
              (import: java/lang/Character$UnicodeScript
                ["#::."
                 (#enum ARABIC CYRILLIC LATIN)])

              "It should also be noted, the only types that may show up in method arguments or return values may be Java classes, arrays, primitives, void or type-parameters."
              "Lux types, such as Maybe cannot be named (otherwise, they'd be confused for Java classes)."
              (import: (lux/concurrency/promise/JvmPromise A)
                ["#::."
                 (resolve [A] boolean)
                 (poll [] A)
                 (wasResolved [] boolean)
                 (waitOn [lux/Function] void)
                 (#static [A] make [A] (lux/concurrency/promise/JvmPromise A))])
              
              "Also, the names of the imported members will look like Class::member"
              (java/lang/Object::new [])
              (java/lang/Object::equals [other_object] my_object)
              (java/util/List::size [] my_list)
              java/lang/Character$UnicodeScript::LATIN
              )}
  (do {! meta.monad}
    [kind (class_kind class_decl)
     =members (|> bundles
                  (list\map (function (_ [import_format members])
                              (list\map (|>> [import_format]) members)))
                  list.concat
                  (monad.map ! (member_import$ (product.right class_decl) kind class_decl)))]
    (wrap (list& (class_import$ class_decl) (list\join =members)))))

(syntax: #export (array {type (..generic_type^ (list))}
                        size)
  {#.doc (doc "Create an array of the given type, with the given size."
              (array java/lang/Object 10))}
  (case type
    (^template [<type> <array_op>]
      [(^ (#GenericClass <type> (list)))
       (wrap (list (` (<array_op> (~ size)))))])
    (["boolean" "jvm znewarray"]
     ["byte"    "jvm bnewarray"]
     ["short"   "jvm snewarray"]
     ["int"     "jvm inewarray"]
     ["long"    "jvm lnewarray"]
     ["float"   "jvm fnewarray"]
     ["double"  "jvm dnewarray"]
     ["char"    "jvm cnewarray"])

    _
    (wrap (list (` ("jvm anewarray" (~ (code.text (generic_type$ type))) (~ size)))))))

(syntax: #export (array_length array)
  {#.doc (doc "Gives the length of an array."
              (array_length my_array))}
  (wrap (list (` ("jvm arraylength" (~ array))))))

(def: (type->class_name type)
  (-> Type (Meta Text))
  (if (type\= Any type)
    (\ meta.monad wrap "java.lang.Object")
    (case type
      (#.Primitive name params)
      (\ meta.monad wrap name)

      (#.Apply A F)
      (case (type.apply (list A) F)
        #.None
        (meta.fail (format "Cannot apply type: " (type.format F) " to " (type.format A)))

        (#.Some type')
        (type->class_name type'))
      
      (#.Named _ type')
      (type->class_name type')

      _
      (meta.fail (format "Cannot convert to JvmType: " (type.format type))))))

(syntax: #export (array_read idx array)
  {#.doc (doc "Loads an element from an array."
              (array_read 10 my_array))}
  (case array
    [_ (#.Identifier array_name)]
    (do meta.monad
      [array_type (meta.find_type array_name)
       array_jvm_type (type->class_name array_type)]
      (case array_jvm_type
        (^template [<type> <array_op>]
          [<type>
           (wrap (list (` (<array_op> (~ array) (~ idx)))))])
        (["[Z" "jvm zaload"]
         ["[B" "jvm baload"]
         ["[S" "jvm saload"]
         ["[I" "jvm iaload"]
         ["[J" "jvm jaload"]
         ["[F" "jvm faload"]
         ["[D" "jvm daload"]
         ["[C" "jvm caload"])

        _
        (wrap (list (` ("jvm aaload" (~ array) (~ idx)))))))

    _
    (with_gensyms [g!array]
      (wrap (list (` (let [(~ g!array) (~ array)]
                       (..array_read (~ idx) (~ g!array)))))))))

(syntax: #export (array_write idx value array)
  {#.doc (doc "Stores an element into an array."
              (array_write 10 my_object my_array))}
  (case array
    [_ (#.Identifier array_name)]
    (do meta.monad
      [array_type (meta.find_type array_name)
       array_jvm_type (type->class_name array_type)]
      (case array_jvm_type
        (^template [<type> <array_op>]
          [<type>
           (wrap (list (` (<array_op> (~ array) (~ idx) (~ value)))))])
        (["[Z" "jvm zastore"]
         ["[B" "jvm bastore"]
         ["[S" "jvm sastore"]
         ["[I" "jvm iastore"]
         ["[J" "jvm jastore"]
         ["[F" "jvm fastore"]
         ["[D" "jvm dastore"]
         ["[C" "jvm castore"])

        _
        (wrap (list (` ("jvm aastore" (~ array) (~ idx) (~ value)))))))

    _
    (with_gensyms [g!array]
      (wrap (list (` (let [(~ g!array) (~ array)]
                       (..array_write (~ idx) (~ value) (~ g!array)))))))))

(syntax: #export (class_for {type (..generic_type^ (list))})
  {#.doc (doc "Loads the class as a java.lang.Class object."
              (class_for java/lang/String))}
  (wrap (list (` ("jvm object class" (~ (code.text (simple_class$ (list) type))))))))

(syntax: #export (type {type (..generic_type^ (list))})
  (wrap (list (class->type #ManualPrM (list) type))))
