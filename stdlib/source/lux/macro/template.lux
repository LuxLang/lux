(.module:
  [lux #*
   [abstract
    ["." monad (#+ do)]]
   [control
    ["<>" parser ("#//." functor)
     ["<.>" code (#+ Parser)]]]
   [data
    ["." bit ("#//." codec)]
    ["." text]
    [number
     ["." nat ("#//." decimal)]
     ["." int ("#//." decimal)]
     ["." rev ("#//." decimal)]
     ["." frac ("#//." decimal)]]
    [collection
     ["." list ("#//." monad)]]]
   ["." meta]]
  [//
   [syntax (#+ syntax:)]
   ["." code]])

(syntax: #export (splice {parts (<code>.tuple (<>.some <code>.any))})
  (wrap parts))

(syntax: #export (count {parts (<code>.tuple (<>.some <code>.any))})
  (wrap (list (code.nat (list.size parts)))))

(syntax: #export (with-locals {locals (<code>.tuple (<>.some <code>.local-identifier))}
                   body)
  (do {! meta.monad}
    [g!locals (|> locals
                  (list//map meta.gensym)
                  (monad.seq !))]
    (wrap (list (` (.with-expansions [(~+ (|> (list.zip/2 locals g!locals)
                                              (list//map (function (_ [name identifier])
                                                           (list (code.local-identifier name) (as-is identifier))))
                                              list//join))]
                     (~ body)))))))

(def: (name-side module-side? parser)
  (-> Bit (Parser Name) (Parser Text))
  (do <>.monad
    [[module short] parser]
    (wrap (if module-side?
            (case module
              "" short
              _ module)
            short))))

(def: (snippet module-side?)
  (-> Bit (Parser Text))
  (let [full-identifier (..name-side module-side? <code>.identifier)
        full-tag (..name-side module-side? <code>.tag)]
    ($_ <>.either
        <code>.text
        (if module-side?
          full-identifier
          (<>.either <code>.local-identifier
                     full-identifier))
        (if module-side?
          full-tag
          (<>.either <code>.local-tag
                     full-tag))
        (<>//map bit//encode <code>.bit)
        (<>//map nat//encode <code>.nat)
        (<>//map int//encode <code>.int)
        (<>//map rev//encode <code>.rev)
        (<>//map frac//encode <code>.frac)
        )))

(def: (part module-side?)
  (-> Bit (Parser (List Text)))
  (<code>.tuple (<>.many (..snippet module-side?))))

(syntax: #export (text {simple (..part false)})
  (wrap (list (|> simple (text.join-with "") code.text))))

(template [<name> <simple> <complex>]
  [(syntax: #export (<name> {name (<>.or (<>.and (..part true) (..part false))
                                         (..part false))})
     (case name
       (#.Left [simple complex])
       (wrap (list (<complex> [(text.join-with "" simple)
                               (text.join-with "" complex)])))
       
       (#.Right simple)
       (wrap (list (|> simple (text.join-with "") <simple>)))))]

  [identifier code.local-identifier code.identifier]
  [tag code.local-tag code.tag]
  )
