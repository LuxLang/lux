(.module:
  [lux #*
   [abstract
    ["." monad (#+ do)]]
   [control
    ["<>" parser ("#\." functor)
     ["<.>" code (#+ Parser)]]]
   [data
    ["." bit ("#\." codec)]
    ["." text]
    [number
     ["." nat ("#\." decimal)]
     ["." int ("#\." decimal)]
     ["." rev ("#\." decimal)]
     ["." frac ("#\." decimal)]]
    [collection
     ["." list ("#\." monad)]]]
   ["." meta]]
  [//
   [syntax (#+ syntax:)]
   ["." code]])

(syntax: #export (splice {parts (<code>.tuple (<>.some <code>.any))})
  (wrap parts))

(syntax: #export (count {parts (<code>.tuple (<>.some <code>.any))})
  (wrap (list (code.nat (list.size parts)))))

(syntax: #export (with_locals {locals (<code>.tuple (<>.some <code>.local_identifier))}
                   body)
  (do {! meta.monad}
    [g!locals (|> locals
                  (list\map meta.gensym)
                  (monad.seq !))]
    (wrap (list (` (.with_expansions [(~+ (|> (list.zip/2 locals g!locals)
                                              (list\map (function (_ [name identifier])
                                                          (list (code.local_identifier name) (as_is identifier))))
                                              list\join))]
                     (~ body)))))))

(def: (name_side module_side? parser)
  (-> Bit (Parser Name) (Parser Text))
  (do <>.monad
    [[module short] parser]
    (wrap (if module_side?
            (case module
              "" short
              _ module)
            short))))

(def: (snippet module_side?)
  (-> Bit (Parser Text))
  (let [full_identifier (..name_side module_side? <code>.identifier)
        full_tag (..name_side module_side? <code>.tag)]
    ($_ <>.either
        <code>.text
        (if module_side?
          full_identifier
          (<>.either <code>.local_identifier
                     full_identifier))
        (if module_side?
          full_tag
          (<>.either <code>.local_tag
                     full_tag))
        (<>\map bit\encode <code>.bit)
        (<>\map nat\encode <code>.nat)
        (<>\map int\encode <code>.int)
        (<>\map rev\encode <code>.rev)
        (<>\map frac\encode <code>.frac)
        )))

(def: (part module_side?)
  (-> Bit (Parser (List Text)))
  (<code>.tuple (<>.many (..snippet module_side?))))

(syntax: #export (text {simple (..part false)})
  (wrap (list (|> simple (text.join_with "") code.text))))

(template [<name> <simple> <complex>]
  [(syntax: #export (<name> {name (<>.or (<>.and (..part true) (..part false))
                                         (..part false))})
     (case name
       (#.Left [simple complex])
       (wrap (list (<complex> [(text.join_with "" simple)
                               (text.join_with "" complex)])))
       
       (#.Right simple)
       (wrap (list (|> simple (text.join_with "") <simple>)))))]

  [identifier code.local_identifier code.identifier]
  [tag code.local_tag code.tag]
  )
