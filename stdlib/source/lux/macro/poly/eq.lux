(;module:
  lux
  (lux (control [monad #+ do Monad]
                [eq]
                ["p" parser])
       (data [text "text/" Monoid<Text>]
             text/format
             (coll [list "L/" Monad<List>]
                   [vector]
                   [array]
                   [queue]
                   [set]
                   [seq]
                   [dict #+ Dict]
                   (tree [rose]))
             [number "nat/" Codec<Text,Nat>]
             [product]
             [bool]
             [maybe])
       [macro #+ Monad<Lux> with-gensyms]
       (macro [code]
              [syntax #+ syntax: Syntax]
              (syntax [common])
              [poly #+ poly:])
       [type]
       ))

## [Derivers]
(poly: #export Eq<?>
  (with-expansions
    [<basic> (do-template [<type> <matcher> <eq>]
               [(do @
                  [[primT _] (p;seq poly;peek <matcher>)]
                  (wrap (` (: (~ (@Eq primT))
                              <eq>))))]

               [Unit poly;unit (function [(~' test) (~' input)] true)]
               [Bool poly;bool bool;Eq<Bool>]
               [Nat  poly;nat  number;Eq<Nat>]
               [Int  poly;int  number;Eq<Int>]
               [Deg  poly;deg  number;Eq<Deg>]
               [Real poly;real number;Eq<Real>]
               [Text poly;text text;Eq<Text>])
     <composites> (do-template [<name> <eq>]
                    [(do @
                       [[collT [_ argC]] (p;seq poly;peek
                                                (poly;apply (p;seq (poly;named (ident-for <name>))
                                                                   Eq<?>)))]
                       (wrap (` (: (~ (@Eq collT))
                                   (<eq> (~ argC))))))]

                    ## [;Maybe        maybe;Eq<Maybe>]
                    ## [;List         list;Eq<List>]
                    [vector;Vector vector;Eq<Vector>]
                    [array;Array   array;Eq<Array>]
                    [queue;Queue   queue;Eq<Queue>]
                    [set;Set       set;Eq<Set>]
                    [seq;Seq       seq;Eq<Seq>]
                    [rose;Tree     rose;Eq<Tree>]
                    )]
    (do @
      [*env* poly;env
       #let [@Eq (: (-> Type Code)
                    (function [type]
                      (` (eq;Eq (~ (poly;to-ast *env* type))))))]]
      ($_ p;either
          ## Primitive types
          <basic>
          ## Composite types
          <composites>
          (do @
            [[collT [_ _ valC]] (p;seq poly;peek
                                       (poly;apply ($_ p;seq
                                                       (poly;named (ident-for dict;Dict))
                                                       poly;any
                                                       Eq<?>)))]
            (wrap (` (: (~ (@Eq collT))
                        (dict;Eq<Dict> (~ valC))))))
          ## Variants
          (do @
            [[variantT members] (p;seq poly;peek
                                       (poly;variant (p;many Eq<?>)))
             #let [g!left (code;local-symbol "\u0000left")
                   g!right (code;local-symbol "\u0000right")]]
            (wrap (` (: (~ (@Eq variantT))
                        (function [(~ g!left) (~ g!right)]
                          (case [(~ g!left) (~ g!right)]
                            (~@ (L/join (L/map (function [[tag g!eq]]
                                                 (list (` [((~ (code;nat tag)) (~ g!left))
                                                           ((~ (code;nat tag)) (~ g!right))])
                                                       (` ((~ g!eq) (~ g!left) (~ g!right)))))
                                               (list;enumerate members))))))))))
          ## Tuples
          (do @
            [[tupleT g!eqs] (p;seq poly;peek
                                   (poly;tuple (p;many Eq<?>)))
             #let [indices (|> (list;size g!eqs) n.dec (list;n.range +0))
                   g!lefts (L/map (|>. nat/encode (text/append "left") code;local-symbol) indices)
                   g!rights (L/map (|>. nat/encode (text/append "right") code;local-symbol) indices)]]
            (wrap (` (: (~ (@Eq tupleT))
                        (function [[(~@ g!lefts)] [(~@ g!rights)]]
                          (and (~@ (|> (list;zip3 g!eqs g!lefts g!rights)
                                       (L/map (function [[g!eq g!left g!right]]
                                                (` ((~ g!eq) (~ g!left) (~ g!right)))))))))))))
          ## Type recursion
          (do @
            [[recT [g!self bodyC]] (p;seq poly;peek
                                          (poly;recursive Eq<?>))]
            (wrap (` (: (~ (@Eq recT))
                        (eq;rec (;function [(~ g!self)]
                                  (~ bodyC)))))))
          poly;recursive-self
          ## Type applications
          (do @
            [[funcC argsC] (poly;apply (p;seq Eq<?> (p;many Eq<?>)))]
            (wrap (` ((~ funcC) (~@ argsC)))))
          ## Bound type-vars
          poly;bound
          ## Polymorphism
          (do @
            [[polyT [funcC varsC bodyC]] (p;seq poly;peek
                                                (poly;polymorphic Eq<?>))]
            (wrap (` (: (All [(~@ varsC)]
                          (-> (~@ (L/map (|>. (~) eq;Eq (`)) varsC))
                              (eq;Eq ((~ (poly;to-ast *env* polyT)) (~@ varsC)))))
                        (function (~ funcC) [(~@ varsC)]
                          (~ bodyC))))))
          poly;recursive-call
          ## If all else fails...
          (|> poly;any
              (:: @ map (|>. %type (format "Cannot create Eq for: ") p;fail))
              (:: @ join))
          ))))
