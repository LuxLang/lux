(;module:
  lux
  (lux (control [monad #+ do Monad]
                [eq])
       (data [text "text/" Monoid<Text>]
             text/format
             (coll [list "L/" Monad<List>]
                   [vector]
                   [array]
                   [queue]
                   [set]
                   [seq]
                   [dict #+ Dict]
                   (tree [rose]))
             [number "nat/" Codec<Text,Nat>]
             [product]
             [bool]
             [maybe])
       [macro #+ Monad<Lux> with-gensyms]
       (macro [code]
              [syntax #+ syntax: Syntax]
              (syntax [common])
              [poly #+ poly:])
       [type]
       ))

## [Derivers]
(poly: #export (Eq<?> env :x:)
  (let [->Eq (: (-> Code Code)
                (function [.type.] (` (eq;Eq (~ .type.)))))]
    (with-expansions
      [<basic> (do-template [<type> <matcher> <eq>]
                 [(do @
                    [_ (<matcher> :x:)]
                    (wrap (` (: (~ (->Eq (` <type>)))
                                <eq>))))]

                 [Unit poly;unit (function [(~' test) (~' input)] true)]
                 [Bool poly;bool bool;Eq<Bool>]
                 [Nat  poly;nat  number;Eq<Nat>]
                 [Int  poly;int  number;Eq<Int>]
                 [Deg  poly;deg  number;Eq<Deg>]
                 [Real poly;real number;Eq<Real>]
                 [Text poly;text text;Eq<Text>])
       <composites> (do-template [<name> <eq>]
                      [(do @
                         [:arg: (poly;apply-1 (ident-for <name>) :x:)
                          g!arg (Eq<?> env :arg:)]
                         (wrap (` (: (~ (->Eq (type;to-ast :x:)))
                                     (<eq> (~ g!arg))))))]

                      [list;List     list;Eq<List>]
                      [vector;Vector vector;Eq<Vector>]
                      [array;Array   array;Eq<Array>]
                      [queue;Queue   queue;Eq<Queue>]
                      [set;Set       set;Eq<Set>]
                      [seq;Seq       seq;Eq<Seq>]
                      [rose;Tree     rose;Eq<Tree>]
                      )]
      ($_ macro;either
          ## Primitive types
          <basic>
          ## Composite types
          <composites>
          (do @
            [[:key: :val:] (poly;apply-2 (ident-for dict;Dict) :x:)
             g!val (Eq<?> env :val:)]
            (wrap (` (: (~ (->Eq (type;to-ast :x:)))
                        (dict;Eq<Dict> (~ g!val))))))
          ## Variants
          (with-gensyms [g!left g!right]
            (do @
              [members (poly;sum+ :x:)
               pattern-matching (monad;map @
                                           (function [[tag :case:]]
                                             (do @
                                               [g!eq (Eq<?> env :case:)]
                                               (wrap (list (` [((~ (code;nat tag)) (~ g!left))
                                                               ((~ (code;nat tag)) (~ g!right))])
                                                           (` ((~ g!eq) (~ g!left) (~ g!right)))))))
                                           (list;enumerate members))]
              (wrap (` (: (~ (->Eq (poly;to-ast env :x:)))
                          (function [(~ g!left) (~ g!right)]
                            (case [(~ g!left) (~ g!right)]
                              (~@ (L/join pattern-matching)))))))))
          ## Tuples
          (do @
            [:members: (poly;prod+ :x:)
             #let [indices (|> (list;size :members:) n.dec (list;n.range +0))
                   g!lefts (L/map (|>. nat/encode (text/append "left") code;local-symbol) indices)
                   g!rights (L/map (|>. nat/encode (text/append "right") code;local-symbol) indices)]
             g!eqs (monad;map @ (Eq<?> env) :members:)]
            (wrap (` (: (~ (->Eq (poly;to-ast env :x:)))
                        (function [[(~@ g!lefts)] [(~@ g!rights)]]
                          (and (~@ (|> (list;zip3 g!eqs g!lefts g!rights)
                                       (L/map (function [[g!eq g!left g!right]]
                                                (` ((~ g!eq) (~ g!left) (~ g!right)))))))))))))
          ## Type recursion
          (with-gensyms [g!rec]
            (do @
              [:non-rec: (poly;recursive :x:)
               #let [new-env (poly;extend-env [:x: g!rec] (list [Bottom (` (;undefined))]) env)]
               .non-rec. (Eq<?> new-env :non-rec:)]
              (wrap (` (: (~ (poly;gen-type new-env ->Eq g!rec (list) :x:))
                          (eq;rec (;function [(~ g!rec)]
                                    (~ .non-rec.))))))))
          (poly;self env :x:)
          (poly;recursion env :x:)
          ## Type applications
          (do @
            [[:func: :args:] (poly;apply :x:)
             .func. (Eq<?> env :func:)
             .args. (monad;map @ (Eq<?> env) :args:)]
            (wrap (` (: (~ (->Eq (type;to-ast :x:)))
                        ((~ .func.) (~@ .args.))))))
          ## Bound type-vars
          (poly;bound env :x:)
          ## Polymorphism
          (with-gensyms [g!type-fun]
            (do @
              [[g!vars :non-poly:] (poly;polymorphic :x:)
               #let [new-env (poly;extend-env [:x: g!type-fun]
                                              (list;zip2 (|> g!vars list;size poly;type-var-indices) g!vars)
                                              env)]
               .non-poly. (Eq<?> new-env :non-poly:)]
              (wrap (` (: (All (~ g!type-fun) [(~@ g!vars)]
                            (-> (~@ (L/map ->Eq g!vars))
                                (~ (->Eq (` ((~ (poly;to-ast env :x:)) (~@ g!vars)))))))
                          (function (~ g!type-fun) [(~@ g!vars)]
                            (~ .non-poly.)))))))
          ## If all else fails...
          (macro;fail (format "Cannot create Eq for: " (%type :x:)))
          ))))
