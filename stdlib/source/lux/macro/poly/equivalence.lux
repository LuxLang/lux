(.module:
  [lux #*
   [control
    [monad (#+ do Monad)]
    ["eq" equivalence]
    ["p" parser]]
   [data
    ["." product]
    ["." bit]
    ["." maybe]
    [number
     ["." nat ("#@." decimal)]
     ["." int]
     ["." rev]
     ["." frac]]
    ["." text ("#@." monoid)
     format]
    [collection
     ["." list ("#@." monad)]
     ["." row]
     ["." array]
     ["." queue]
     ["." set]
     ["." dictionary (#+ Dictionary)]
     [tree
      ["." rose]]]]
   [time
    ["." duration]
    ["." date]
    ["." instant]
    ["." day]
    ["." month]]
   ["." macro
    ["." code]
    [syntax (#+ syntax: Syntax)
     ["." common]]
    ["." poly (#+ poly:)]]
   ["." type
    ["." unit]]])

(poly: #export equivalence
  (`` (do @
        [#let [g!_ (code.local-identifier "_____________")]
         *env* poly.env
         inputT poly.peek
         #let [@Equivalence (: (-> Type Code)
                               (function (_ type)
                                 (` ((~! eq.Equivalence) (~ (poly.to-code *env* type))))))]]
        ($_ p.either
            ## Basic types
            (~~ (do-template [<matcher> <eq>]
                  [(do @
                     [_ <matcher>]
                     (wrap (` (: (~ (@Equivalence inputT))
                                 <eq>))))]

                  [(poly.exactly Any) (function ((~ g!_) (~ g!_) (~ g!_)) #1)]
                  [(poly.sub Bit)     (~! bit.equivalence)]
                  [(poly.sub Nat)     (~! nat.equivalence)]
                  [(poly.sub Int)     (~! int.equivalence)]
                  [(poly.sub Rev)     (~! rev.equivalence)]
                  [(poly.sub Frac)    (~! frac.equivalence)]
                  [(poly.sub Text)    (~! text.equivalence)]))
            ## Composite types
            (~~ (do-template [<name> <eq>]
                  [(do @
                     [[_ argC] (poly.apply (p.and (poly.exactly <name>)
                                                  equivalence))]
                     (wrap (` (: (~ (@Equivalence inputT))
                                 (<eq> (~ argC))))))]

                  [.Maybe      (~! maybe.equivalence)]
                  [.List       (~! list.equivalence)]
                  [row.Row     (~! row.equivalence)]
                  [array.Array (~! array.equivalence)]
                  [queue.Queue (~! queue.equivalence)]
                  [set.Set     (~! set.equivalence)]
                  [rose.Tree   (~! rose.equivalence)]
                  ))
            (do @
              [[_ _ valC] (poly.apply ($_ p.and
                                          (poly.exactly dictionary.Dictionary)
                                          poly.any
                                          equivalence))]
              (wrap (` (: (~ (@Equivalence inputT))
                          ((~! dictionary.equivalence) (~ valC))))))
            ## Models
            (~~ (do-template [<type> <eq>]
                  [(do @
                     [_ (poly.exactly <type>)]
                     (wrap (` (: (~ (@Equivalence inputT))
                                 <eq>))))]

                  [duration.Duration duration.equivalence]
                  [instant.Instant instant.equivalence]
                  [date.Date date.equivalence]
                  [day.Day day.equivalence]
                  [month.Month month.equivalence]
                  ))
            (do @
              [_ (poly.apply (p.and (poly.exactly unit.Qty)
                                    poly.any))]
              (wrap (` (: (~ (@Equivalence inputT))
                          unit.equivalence))))
            ## Variants
            (do @
              [members (poly.variant (p.many equivalence))
               #let [g!_ (code.local-identifier "_____________")
                     g!left (code.local-identifier "_____________left")
                     g!right (code.local-identifier "_____________right")]]
              (wrap (` (: (~ (@Equivalence inputT))
                          (function ((~ g!_) (~ g!left) (~ g!right))
                            (case [(~ g!left) (~ g!right)]
                              (~+ (list@join (list@map (function (_ [tag g!eq])
                                                         (list (` [((~ (code.nat tag)) (~ g!left))
                                                                   ((~ (code.nat tag)) (~ g!right))])
                                                               (` ((~ g!eq) (~ g!left) (~ g!right)))))
                                                       (list.enumerate members))))
                              (~ g!_)
                              #0))))))
            ## Tuples
            (do @
              [g!eqs (poly.tuple (p.many equivalence))
               #let [g!_ (code.local-identifier "_____________")
                     indices (list.indices (list.size g!eqs))
                     g!lefts (list@map (|>> nat@encode (text@compose "left") code.local-identifier) indices)
                     g!rights (list@map (|>> nat@encode (text@compose "right") code.local-identifier) indices)]]
              (wrap (` (: (~ (@Equivalence inputT))
                          (function ((~ g!_) [(~+ g!lefts)] [(~+ g!rights)])
                            (and (~+ (|> (list.zip3 g!eqs g!lefts g!rights)
                                         (list@map (function (_ [g!eq g!left g!right])
                                                     (` ((~ g!eq) (~ g!left) (~ g!right)))))))))))))
            ## Type recursion
            (do @
              [[g!self bodyC] (poly.recursive equivalence)
               #let [g!_ (code.local-identifier "_____________")]]
              (wrap (` (: (~ (@Equivalence inputT))
                          ((~! eq.rec) (.function ((~ g!_) (~ g!self))
                                         (~ bodyC)))))))
            poly.recursive-self
            ## Type applications
            (do @
              [[funcC argsC] (poly.apply (p.and equivalence (p.many equivalence)))]
              (wrap (` ((~ funcC) (~+ argsC)))))
            ## Parameters
            poly.parameter
            ## Polymorphism
            (do @
              [[funcC varsC bodyC] (poly.polymorphic equivalence)]
              (wrap (` (: (All [(~+ varsC)]
                            (-> (~+ (list@map (|>> (~) ((~! eq.Equivalence)) (`)) varsC))
                                ((~! eq.Equivalence) ((~ (poly.to-code *env* inputT)) (~+ varsC)))))
                          (function ((~ funcC) (~+ varsC))
                            (~ bodyC))))))
            poly.recursive-call
            ## If all else fails...
            (|> poly.any
                (:: @ map (|>> %type (format "Cannot create Equivalence for: ") p.fail))
                (:: @ join))
            ))))
