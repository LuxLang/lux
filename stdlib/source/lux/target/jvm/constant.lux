(.module:
  [lux #*
   [abstract
    [monad (#+ do)]
    ["." equivalence (#+ Equivalence)]]
   [control
    ["<>" parser ("#@." functor)
     ["<2>" binary (#+ Parser)]]]
   [data
    [number
     ["." int]
     ["." frac]]
    ["." text]
    [format
     [".F" binary (#+ Writer) ("#@." monoid)]]
    [collection
     ["." row (#+ Row)]]]
   [type
    abstract]]
  ["." / #_
   ["#." tag ("#;." equivalence)]
   ["." // #_
    ["#." descriptor (#+ Descriptor)]
    ["#." index (#+ Index)]
    [encoding
     [unsigned (#+ U4)]]]])

(type: #export UTF8 Text)

(def: utf8-parser
  (Parser UTF8)
  <2>.utf8/16)

(def: utf8-writer
  (Writer UTF8)
  binaryF.utf8/16)

(abstract: #export Class
  {}
  
  (Index UTF8)
  
  (def: #export class
    (-> (Index UTF8) Class)
    (|>> :abstraction))

  (def: #export class-equivalence
    (Equivalence Class)
    (:: equivalence.contravariant map-1
        (|>> :representation)
        //index.equivalence))

  (def: class-parser
    (Parser Class)
    (<>@map (|>> :abstraction) //index.parser))

  (def: class-writer
    (Writer Class)
    (|>> :representation //index.writer))
  )

(abstract: #export (Value kind)

  {}

  kind

  (def: #export value
    (All [kind] (-> (Value kind) kind))
    (|>> :representation))

  (def: #export (value-equivalence Equivalence<kind>)
    (All [kind]
      (-> (Equivalence kind)
          (Equivalence (Value kind))))
    (:: equivalence.contravariant map-1
        (|>> :representation)
        Equivalence<kind>))

  (template [<constructor> <type> <marker>]
    [(type: #export <type> (Value <marker>))

     (def: #export <constructor>
       (-> <marker> <type>)
       (|>> :abstraction))]

    [integer Integer U4]
    [long    Long    .Int]
    [float   Float   Nothing]
    [double  Double  Frac]
    [string  String  (Index UTF8)]
    )

  (template [<parser-name> <writer-name> <type> <read> <write> <parser> <writer>]
    [(def: <parser-name>
       (Parser <type>)
       (<>@map (|>> <read> :abstraction) <parser>))
     (def: <writer-name>
       (Writer <type>)
       (|>> :representation <write> <writer>))]

    [long-parser long-writer Long .int (<|) <2>.bits/64 binaryF.bits/64]
    [double-parser double-writer Double frac.bits-to-frac frac.frac-to-bits <2>.bits/64 binaryF.bits/64]
    [string-parser string-writer String (<|) (<|) //index.parser //index.writer]
    )
  )

(type: #export (Name-And-Type of)
  {#name (Index UTF8)
   #descriptor (Index (Descriptor of))})

(type: #export (Reference of)
  {#class (Index Class)
   #name-and-type (Index (Name-And-Type of))})

(template [<type> <equivalence> <parser> <writer>]
  [(def: #export <equivalence>
     (Equivalence (<type> Any))
     ($_ equivalence.product
         //index.equivalence
         //index.equivalence))

   (def: <parser>
     (Parser <type>)
     ($_ <>.and
         //index.parser
         //index.parser))

   (def: <writer>
     (Writer (<type> Any))
     ($_ binaryF.and
         //index.writer
         //index.writer))]

  [Name-And-Type name-and-type-equivalence name-and-type-parser name-and-type-writer]
  [Reference reference-equivalence reference-parser reference-writer]
  )

(type: #export Constant
  (#UTF8 UTF8)
  (#Long Long)
  (#Double Double)
  (#Class Class)
  (#String String)
  (#Field (Reference //descriptor.Field))
  (#Method (Reference //descriptor.Method))
  (#Interface-Method (Reference //descriptor.Method))
  (#Name-And-Type (Name-And-Type Any)))

(def: #export equivalence
  (Equivalence Constant)
  ## TODO: Delete the explicit "structure" and use the combinator
  ## version below as soon as the new format for variants is implemented.
  (structure
   (def: (= reference sample)
     (case [reference sample]
       (^template [<tag> <equivalence>]
         [(<tag> reference) (<tag> sample)]
         (:: <equivalence> = reference sample))
       ([#UTF8 text.equivalence]
        [#Long (..value-equivalence int.equivalence)]
        [#Double (..value-equivalence frac.equivalence)]
        [#Class ..class-equivalence]
        [#String (..value-equivalence //index.equivalence)]
        [#Field ..reference-equivalence]
        [#Method ..reference-equivalence]
        [#Interface-Method ..reference-equivalence]
        [#Name-And-Type ..name-and-type-equivalence])
       
       _
       false)))
  ## ($_ equivalence.sum
  ##     ## #UTF8
  ##     text.equivalence
  ##     ## #Long
  ##     (..value-equivalence int.equivalence)
  ##     ## #Double
  ##     (..value-equivalence frac.equivalence)
  ##     ## #Class
  ##     ..class-equivalence
  ##     ## #String
  ##     (..value-equivalence //index.equivalence)
  ##     ## #Field
  ##     ..reference-equivalence
  ##     ## #Method
  ##     ..reference-equivalence
  ##     ## #Interface-Method
  ##     ..reference-equivalence
  ##     ## #Name-And-Type
  ##     ..name-and-type-equivalence
  ##     )
  )

(def: #export parser
  (Parser Constant)
  (with-expansions [<constants> (as-is [#UTF8             /tag.utf8             ..utf8-parser]
                                       ## TODO: Integer
                                       ## TODO: Float
                                       [#Long             /tag.long             ..long-parser]
                                       [#Double           /tag.double           ..double-parser]
                                       [#Class            /tag.class            ..class-parser]
                                       [#String           /tag.string           ..string-parser]
                                       [#Field            /tag.field            ..reference-parser]
                                       [#Method           /tag.method           ..reference-parser]
                                       [#Interface-Method /tag.interface-method ..reference-parser]
                                       [#Name-And-Type    /tag.name-and-type    ..name-and-type-parser]
                                       ## TODO: Method-Handle
                                       ## TODO: Method-Type
                                       ## TODO: Invoke-Dynamic
                                       )]
    (do <>.monad
      [tag /tag.parser]
      (`` (cond (~~ (template [<case> <tag> <parser>]
                      [(/tag;= <tag> tag)
                       (:: @ map (|>> <case>) <parser>)]

                      <constants>))
                
                ## else
                (<>.fail "Cannot parse constant."))))))

(def: #export writer
  (Writer Constant)
  (with-expansions [<constants> (as-is [#UTF8             /tag.utf8             ..utf8-writer]
                                       ## TODO: Integer
                                       ## TODO: Float
                                       [#Long             /tag.long             ..long-writer]
                                       [#Double           /tag.double           ..double-writer]
                                       [#Class            /tag.class            ..class-writer]
                                       [#String           /tag.string           ..string-writer]
                                       [#Field            /tag.field            ..reference-writer]
                                       [#Method           /tag.method           ..reference-writer]
                                       [#Interface-Method /tag.interface-method ..reference-writer]
                                       [#Name-And-Type    /tag.name-and-type    ..name-and-type-writer]
                                       ## TODO: Method-Handle
                                       ## TODO: Method-Type
                                       ## TODO: Invoke-Dynamic
                                       )]
    (function (_ value)
      (case value
        (^template [<case> <tag> <writer>]
          (<case> value)
          (binaryF@compose (/tag.writer <tag>)
                           (<writer> value)))
        (<constants>)
        ))))
