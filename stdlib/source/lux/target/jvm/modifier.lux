(.module:
  [lux #*
   [abstract
    ["." equivalence (#+ Equivalence)]
    ["." monoid (#+ Monoid)]]
   [control
    ["<>" parser
     ["<c>" code (#+ Parser)]]]
   [data
    ["." number (#+ hex)
     ["." i64]]
    [format
     [".F" binary (#+ Format)]]
    [collection
     ["." list ("#@." functor)]]]
   [type
    abstract]
   [macro (#+ with-gensyms)
    [syntax (#+ syntax:)]
    ["." code]]]
  ["." // #_
   ["#." encoding]])

(abstract: #export (Modifier of)
  {}
  //encoding.U2

  (template: (!wrap value)
    (|> value
        //encoding.u2
        :abstraction))

  (template: (!unwrap value)
    (|> value
        :representation
        //encoding.nat))

  (def: #export code
    (-> (Modifier Any) //encoding.U2)
    (|>> :representation))

  (def: modifier
    (-> Nat Modifier)
    (|>> !wrap))

  (structure: #export equivalence
    (All [of] (Equivalence (Modifier of)))
    (def: (= reference sample)
      (:: //encoding.equivalence =
          (:representation reference)
          (:representation sample))))

  (structure: #export monoid
    (All [of] (Monoid (Modifier of)))

    (def: identity
      (!wrap (hex "0000")))
    
    (def: (compose left right)
      (!wrap (i64.and (!unwrap left) (!unwrap right)))))

  (def: #export empty
    Modifier
    (:: ..monoid identity))

  (def: #export format
    (All [of] (Format (Modifier of)))
    (let [(^open "_@.") //encoding.u2-format]
      {#binaryF.reader (:: <>.functor map (|>> :abstraction) _@reader)
       #binaryF.writer (|>> :representation _@writer)}))
  )

(syntax: #export (modifiers: ofT {options (<>.many <c>.any)})
  (with-gensyms [g!modifier g!code]
    (wrap (list (` (template [(~ g!code) (~ g!modifier)]
                     [(def: (~' #export) (~ g!modifier)
                        (..Modifier (~ ofT))
                        ((~! ..modifier) ((~! number.hex) (~ g!code))))]
                     
                     (~+ options)))))))
