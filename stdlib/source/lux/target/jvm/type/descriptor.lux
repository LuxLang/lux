(.module:
  [lux (#- int char)
   [abstract
    [equivalence (#+ Equivalence)]]
   [data
    ["." maybe]
    [number
     ["n" nat]]
    ["." text ("#@." equivalence)
     ["%" format (#+ format)]]
    [collection
     ["." list ("#@." functor)]]]
   [macro
    ["." template]]
   [type
    abstract]]
  ["." /// #_
   [encoding
    ["#." name (#+ External)]]])

(abstract: #export Void' {} Any)

(abstract: #export (Value' brand) {} Any)
(abstract: #export (Return' brand) {} Any)

(abstract: #export Method {} Any)

(abstract: #export (Descriptor brand)
  {}

  Text

  (type: #export Return (<| Return' Any))
  (type: #export Value (<| Return' Value' Any))
  (type: #export Void (<| Return' Void'))

  (abstract: #export (Object' brand) {} Any)
  (type: #export Object (<| Return' Value' Object' Any))

  (template [<parents> <child>]
    [(with-expansions [<raw> (template.identifier [<child> "'"])]
       (abstract: #export <raw> {} Any)
       (type: #export <child>
         (`` (<| Return' Value' (~~ (template.splice <parents>)) <raw>))))]

    [[] Primitive]
    [[Object'] Class]
    [[Object'] Array]
    )

  (def: #export descriptor
    (-> (Descriptor Any) Text)
    (|>> :representation))

  (template [<sigil> <brand> <name>]
    [(def: #export <name>
       (Descriptor <brand>)
       (:abstraction <sigil>))]

    ["V" Void void]
    ["Z" Primitive boolean]
    ["B" Primitive byte]
    ["S" Primitive short]
    ["I" Primitive int]
    ["J" Primitive long]
    ["F" Primitive float]
    ["D" Primitive double]
    ["C" Primitive char]
    )

  (def: #export class-prefix "L")
  (def: #export class-suffix ";")

  (def: #export class
    (-> External (Descriptor Class))
    (|>> ///name.internal
         ///name.read
         (text.enclose [..class-prefix ..class-suffix])
         :abstraction))

  (def: #export var (..class "java.lang.Object"))
  (def: #export wildcard (..class "java.lang.Object"))

  (def: #export array-prefix "[")

  (def: #export array
    (-> (Descriptor Value)
        (Descriptor Array))
    (|>> :representation
         (format ..array-prefix)
         :abstraction))

  (def: #export (method [inputs output])
    (-> [(List (Descriptor Value))
         (Descriptor Return)]
        (Descriptor Method))
    (:abstraction
     (format (|> inputs
                 (list@map ..descriptor)
                 (text.join-with "")
                 (text.enclose ["(" ")"]))
             (:representation output))))

  (structure: #export equivalence
    (All [brand] (Equivalence (Descriptor brand)))
    
    (def: (= parameter subject)
      (text@= (:representation parameter) (:representation subject))))

  (def: #export (primitive? descriptor)
    (-> (Descriptor Value) (Either (Descriptor Object)
                                   (Descriptor Primitive)))
    (if (`` (or (~~ (template [<descriptor>]
                      [(:: ..equivalence = <descriptor> descriptor)]
                      
                      [..boolean]
                      [..byte]
                      [..short]
                      [..int]
                      [..long]
                      [..float]
                      [..double]
                      [..char]))))
      (|> descriptor :transmutation #.Right)
      (|> descriptor :transmutation #.Left)))

  (def: binary-name (|>> ///name.internal ///name.external))

  (def: #export (class? descriptor)
    (-> (Descriptor Value) (Maybe Text))
    (let [repr (:representation descriptor)]
      (if (and (text.starts-with? ..class-prefix repr)
               (text.ends-with? ..class-suffix repr))
        (|> repr
            (text.clip (text.size ..class-prefix)
                       (n.- (text.size ..class-suffix)
                            (text.size repr)))
            (:: maybe.monad map ..binary-name))
        #.None)))

  (def: #export class-name
    (-> (Descriptor Object) Text)
    (let [prefix-size (text.size ..class-prefix)
          suffix-size (text.size ..class-suffix)]
      (function (_ descriptor)
        (let [repr (:representation descriptor)]
          (if (text.starts-with? ..array-prefix repr)
            repr
            (|> repr
                (text.clip prefix-size
                           (n.- suffix-size
                                (text.size repr)))
                (:: maybe.monad map ..binary-name)
                maybe.assume))))))
  )
