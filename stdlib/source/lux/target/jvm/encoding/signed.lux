(.module:
  [lux (#- int)
   [abstract
    [equivalence (#+ Equivalence)]
    [order (#+ Order)]]
   [control
    ["<>" parser ("#@." functor)
     ["<2>" binary (#+ Parser)]]]
   [data
    [number
     ["." i64]]
    [format
     [".F" binary (#+ Writer)]]]
   [macro
    ["." template]]
   [type
    abstract]])

(abstract: #export (Signed brand)
  {}
  Int

  (def: #export int
    (-> (Signed Any) Int)
    (|>> :representation))

  (structure: #export equivalence
    (All [brand] (Equivalence (Signed brand)))
    (def: (= reference sample)
      (i/= (:representation reference) (:representation sample))))

  (structure: #export order
    (All [brand] (Order (Signed brand)))
    
    (def: &equivalence ..equivalence)
    (def: (< reference sample)
      (i/< (:representation reference) (:representation sample))))

  (template [<bytes> <name> <size> <constructor> <max> <+>]
    [(with-expansions [<raw> (template.identifier [<name> "'"])]
       (abstract: #export <raw> {} Any)
       (type: #export <name> (Signed <raw>)))

     (def: #export <size> Nat <bytes>)
     
     (def: #export <max>
       <name>
       (|> <bytes> (n/* i64.bits-per-byte) dec i64.mask :abstraction))
     
     (def: #export <constructor>
       (-> Int <name>)
       (let [limit (|> <bytes> (n/* i64.bits-per-byte) i64.mask .nat)]
         (|>> (i64.and limit) :abstraction)))

     (def: #export (<+> parameter subject)
       (-> <name> <name> <name>)
       (let [limit (|> <bytes> (n/* i64.bits-per-byte) i64.mask .nat)]
         (:abstraction
          (i64.and limit
                   (i/+ (:representation parameter)
                        (:representation subject))))))]

    [1 S1 s1-bytes s1 max-s1 s1/+]
    [2 S2 s2-bytes s2 max-s2 s2/+]
    [4 S4 s4-bytes s4 max-s4 s4/+]
    )
  )

(template [<parser-name> <writer-name> <type> <parser> <writer> <post-read>]
  [(def: #export <parser-name>
     (Parser <type>)
     (<>@map (|>> .int <post-read>) <parser>))

   (def: #export <writer-name>
     (Writer <type>)
     (|>> ..int <writer>))]

  [s1-parser s1-writer S1 <2>.bits/8 binaryF.bits/8  ..s1]
  [s2-parser s2-writer S2 <2>.bits/16 binaryF.bits/16 ..s2]
  [s4-parser s4-writer S4 <2>.bits/32 binaryF.bits/32 ..s4]
  )
