(.module:
  [lux (#- Type int char)
   [abstract
    [equivalence (#+ Equivalence)]
    [monad (#+ do)]]
   [control
    ["." function]
    ["<>" parser ("#@." monad)
     ["<t>" text (#+ Parser)]]]
   [data
    ["." product]
    ["." maybe ("#@." functor)]
    ["." text ("#@." equivalence)
     ["%" format (#+ format)]]
    [collection
     ["." list ("#@." functor)]]]
   [type
    abstract]]
  ["." // #_
   [encoding
    ["#." name (#+ External)]]]
  ["." / #_
   [category (#+ Void Value Return Method Primitive Object Class Array Parameter)]
   ["#." signature (#+ Signature)]
   ["#." descriptor (#+ Descriptor)]
   ["#." reflection (#+ Reflection)]])

(abstract: #export (Type category)
  {}

  [(Signature category) (Descriptor category) (Reflection category)]

  (template [<name> <style>]
    [(def: #export (<name> type)
       (All [category] (-> (Type category) (<style> category)))
       (let [[signature descriptor reflection] (:representation type)]
         <name>))]

    [signature Signature]
    [descriptor Descriptor]
    [reflection Reflection]
    )

  (template [<category> <name> <signature> <descriptor> <reflection>]
    [(def: #export <name>
       (Type <category>)
       (:abstraction [<signature> <descriptor> <reflection>]))]

    [Void void /signature.void /descriptor.void /reflection.void]
    [Primitive boolean /signature.boolean /descriptor.boolean /reflection.boolean]
    [Primitive byte /signature.byte /descriptor.byte /reflection.byte]
    [Primitive short /signature.short /descriptor.short /reflection.short]
    [Primitive int /signature.int /descriptor.int /reflection.int]
    [Primitive long /signature.long /descriptor.long /reflection.long]
    [Primitive float /signature.float /descriptor.float /reflection.float]
    [Primitive double /signature.double /descriptor.double /reflection.double]
    [Primitive char /signature.char /descriptor.char /reflection.char]
    )

  (def: #export (array type)
    (-> (Type Value) (Type Array))
    (:abstraction
     [(/signature.array (..signature type))
      (/descriptor.array (..descriptor type))
      (/reflection.array (..reflection type))]))

  (def: #export (class name parameters)
    (-> External (List (Type Parameter)) (Type Class))
    (:abstraction
     [(/signature.class name (list@map ..signature parameters))
      (/descriptor.class name)
      (/reflection.class name)]))

  (def: #export wildcard
    (Type Parameter)
    (:abstraction
     [/signature.wildcard
      /descriptor.wildcard
      /reflection.wildcard]))

  (def: #export (var name)
    (-> Text (Type Parameter))
    (:abstraction
     [(/signature.var name)
      /descriptor.var
      /reflection.var]))

  (def: #export (lower bound)
    (-> (Type Class) (Type Parameter))
    (:abstraction
     [(/signature.lower (..signature bound))
      (/descriptor.lower (..descriptor bound))
      (/reflection.lower (..reflection bound))]))

  (def: #export (upper bound)
    (-> (Type Class) (Type Parameter))
    (:abstraction
     [(/signature.upper (..signature bound))
      (/descriptor.upper (..descriptor bound))
      (/reflection.upper (..reflection bound))]))

  (def: #export (method [inputs output exceptions])
    (-> [(List (Type Value))
         (Type Return)
         (List (Type Class))]
        [(Signature Method)
         (Descriptor Method)])
    [(/signature.method [(list@map ..signature inputs)
                         (..signature output)
                         (list@map ..signature exceptions)])
     (/descriptor.method [(list@map ..descriptor inputs)
                          (..descriptor output)])])

  (structure: #export equivalence
    (All [category] (Equivalence (Type category)))

    (def: (= parameter subject)
      (:: /signature.equivalence =
          (..signature parameter)
          (..signature subject))))
  )

(template [<category> <name> <signature> <type>]
  [(def: <name>
     (Parser (Type <category>))
     (<>.after (<t>.this (/signature.signature <signature>))
               (<>@wrap <type>)))]

  [Void void-parser /signature.void ..void]
  [Primitive boolean-parser /signature.boolean ..boolean]
  [Primitive byte-parser /signature.byte ..byte]
  [Primitive short-parser /signature.short ..short]
  [Primitive int-parser /signature.int ..int]
  [Primitive long-parser /signature.long ..long]
  [Primitive float-parser /signature.float ..float]
  [Primitive double-parser /signature.double ..double]
  [Primitive char-parser /signature.char ..char]
  [Parameter wildcard-parser /signature.wildcard ..wildcard]
  )

(def: primitive-parser
  (Parser (Type Primitive))
  ($_ <>.either
      ..boolean-parser
      ..byte-parser
      ..short-parser
      ..int-parser
      ..long-parser
      ..float-parser
      ..double-parser
      ..char-parser))

(def: valid-var-characters/head
  (format "abcdefghijklmnopqrstuvwxyz"
          "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
          "_"))

(def: valid-var-characters/tail
  (format valid-var-characters/head
          "0123456789"))

(def: valid-class-characters/head
  (format valid-var-characters/head //name.internal-separator))

(def: valid-class-characters/tail
  (format valid-var-characters/tail //name.internal-separator))

(template [<type> <name> <head> <tail> <adapter>]
  [(def: <name>
     (Parser <type>)
     (:: <>.functor map <adapter>
         (<t>.slice (<t>.and! (<t>.one-of! <head>)
                              (<t>.some! (<t>.one-of! <tail>))))))]

  [External class-name-parser valid-class-characters/head valid-class-characters/tail (|>> //name.internal //name.external)]
  [Text var-name-parser   valid-var-characters/head   valid-var-characters/tail   function.identity]
  )

(def: var-parser
  (Parser (Type Parameter))
  (|> ..var-name-parser
      (<>.after (<t>.this /signature.var-prefix))
      (<>.before (<t>.this /descriptor.class-suffix))
      (<>@map ..var)))

(template [<name> <prefix> <constructor>]
  [(def: <name>
     (-> (Parser (Type Class)) (Parser (Type Parameter)))
     (|>> (<>.after (<t>.this <prefix>))
          (<>@map <constructor>)))]

  [lower-parser /signature.lower-prefix ..lower]
  [upper-parser /signature.upper-prefix ..upper]
  )

(def: (class-parser parameter-parser)
  (-> (Parser (Type Parameter)) (Parser (Type Class)))
  (|> (do <>.monad
        [_ (<t>.this /descriptor.class-prefix)
         name ..class-name-parser
         parameters (|> (<>.some parameter-parser)
                        (<>.after (<t>.this /signature.parameters-start))
                        (<>.before (<t>.this /signature.parameters-end))
                        (<>.default (list)))
         _ (<t>.this /descriptor.class-suffix)]
        (wrap (..class name parameters)))
      (<>.after (<t>.this /descriptor.class-prefix))
      (<>.before (<t>.this /descriptor.class-suffix))))

(def: generic-parser
  (Parser (Type Parameter))
  (<>.rec
   (function (_ generic-parser)
     (let [class-parser (..class-parser generic-parser)]
       ($_ <>.either
           ..var-parser
           ..wildcard-parser
           (..lower-parser class-parser)
           (..upper-parser class-parser)
           class-parser
           )))))

(def: array-parser
  (-> (Parser (Type Value)) (Parser (Type Array)))
  (|>> (<>.after (<t>.this /descriptor.array-prefix))
       (<>@map ..array)))

(def: #export value-parser
  (Parser (Type Value))
  (<>.rec
   (function (_ parser)
     ($_ <>.either
         ..primitive-parser
         ..generic-parser
         (..array-parser parser)
         ))))

(def: #export method-parser
  (Parser [(Signature Method)
           (Descriptor Method)])
  (let [parameters-parser (: (Parser (List (Type Value)))
                             (|> (<>.some ..value-parser)
                                 (<>.after (<t>.this /signature.arguments-start))
                                 (<>.before (<t>.this /signature.arguments-end))))
        return-parser (: (Parser (Type Return))
                         (<>.either ..void-parser
                                    ..value-parser))
        exception-parser (: (Parser (Type Class))
                            (|> (..class-parser ..generic-parser)
                                (<>.after (<t>.this /signature.exception-prefix))))]
    (do <>.monad
      [parameters parameters-parser
       return return-parser
       exceptions (<>.some exception-parser)]
      (wrap (..method [parameters return exceptions])))))
