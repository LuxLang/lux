(.module:
  [lux (#- Type int char)
   [abstract
    [equivalence (#+ Equivalence)]]
   [control
    ["." function]
    ["<>" parser
     ["<t>" text (#+ Parser)]]]
   [data
    ["." product]
    ["." maybe ("#@." functor)]
    ["." text ("#@." equivalence)
     ["%" format (#+ format)]]
    [collection
     ["." list ("#@." functor)]]]
   [type
    abstract]]
  ["." // #_
   [encoding
    ["#." name (#+ External)]]]
  ["." / #_
   [category (#+ Void Value Return Method Primitive Object Class Array Parameter)]
   ["#." signature (#+ Signature)]
   ["#." descriptor (#+ Descriptor)]
   ["#." reflection (#+ Reflection)]])

(abstract: #export (Type brand)
  {}

  [(Signature Any) (Descriptor Any) (Reflection Any)]

  (template [<name> <style>]
    [(def: #export (<name> type)
       (-> (Type Any) (<style> Any))
       (let [[signature descriptor reflection] (:representation type)]
         <name>))]

    [signature Signature]
    [descriptor Descriptor]
    [reflection Reflection]
    )

  (template [<brand> <name> <signature> <descriptor> <reflection>]
    [(def: #export <name>
       (Type <brand>)
       (:abstraction [<signature> <descriptor> <reflection>]))]

    [Void void /signature.void /descriptor.void /reflection.void]
    [Primitive boolean /signature.boolean /descriptor.boolean /reflection.boolean]
    [Primitive byte /signature.byte /descriptor.byte /reflection.byte]
    [Primitive short /signature.short /descriptor.short /reflection.short]
    [Primitive int /signature.int /descriptor.int /reflection.int]
    [Primitive long /signature.long /descriptor.long /reflection.long]
    [Primitive float /signature.float /descriptor.float /reflection.float]
    [Primitive double /signature.double /descriptor.double /reflection.double]
    [Primitive char /signature.char /descriptor.char /reflection.char]
    )

  (def: #export (array type)
    (-> (Type Value) (Type Array))
    (:abstraction
     [(/signature.array (..signature type))
      (/descriptor.array (..descriptor type))
      (/reflection.array (..reflection type))]))

  (def: #export (class name parameters)
    (-> External (List (Type Parameter)) (Type Class))
    (:abstraction
     [(/signature.class name (list@map ..signature parameters))
      (/descriptor.class name)
      (/reflection.class name)]))

  (def: #export wildcard
    (Type Parameter)
    (:abstraction
     [/signature.wildcard
      /descriptor.wildcard
      /reflection.wildcard]))

  (def: #export (var name)
    (-> Text (Type Parameter))
    (:abstraction
     [(/signature.var name)
      /descriptor.var
      /reflection.var]))

  (def: #export (lower bound)
    (-> (Type Class) (Type Parameter))
    (:abstraction
     [(/signature.lower (..signature bound))
      (/descriptor.lower (..descriptor bound))
      (/reflection.lower (..reflection bound))]))

  (def: #export (upper bound)
    (-> (Type Class) (Type Parameter))
    (:abstraction
     [(/signature.upper (..signature bound))
      (/descriptor.upper (..descriptor bound))
      (/reflection.upper (..reflection bound))]))

  (def: #export (method [inputs output exceptions])
    (-> [(List (Type Value))
         (Type Return)
         (List (Type Class))]
        (Type Method))
    (:abstraction
     [(/signature.method [(list@map ..signature inputs)
                          (..signature output)
                          (list@map ..signature exceptions)])
      (/descriptor.method [(list@map ..descriptor inputs)
                           (..descriptor output)])
      (/reflection.method [(list@map ..reflection inputs)
                           (..reflection output)])]))
  )

## (def: valid-var-characters/head
##   (format "abcdefghijklmnopqrstuvwxyz"
##           "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
##           "_"))

## (def: valid-var-characters/tail
##   (format valid-var-characters/head
##           "0123456789"))

## (def: valid-class-characters/head
##   (format valid-var-characters/head //name.internal-separator))

## (def: valid-class-characters/tail
##   (format valid-var-characters/tail //name.internal-separator))

## (type: #export Parameter
##   [Text Class (List Class)])

## (type: #export Argument
##   [Text Type])

## (type: #export (Typed a)
##   [Type a])

## (template [<name> <head> <tail> <adapter>]
##   [(def: <name>
##      (Parser Text)
##      (:: <>.functor map <adapter>
##          (<t>.slice (<t>.and! (<t>.one-of! <head>)
##                               (<t>.some! (<t>.one-of! <tail>))))))]

##   [parse-class-name valid-class-characters/head valid-class-characters/tail (|>> //name.internal //name.external)]
##   [parse-var-name valid-var-characters/head valid-var-characters/tail function.identity]
##   )

## (def: parse-var
##   (Parser Var)
##   (|> ..parse-var-name
##       (<>.after (<t>.this ..var-prefix))
##       (<>.before (<t>.this ..object-suffix))))

## (def: parse-bound
##   (Parser Bound)
##   ($_ <>.or
##       (<t>.this ..lower-prefix)
##       (<t>.this ..upper-prefix)))

## (def: parse-generic
##   (Parser Generic)
##   (<>.rec
##    (function (_ recur)
##      ($_ <>.or
##          ..parse-var
##          ($_ <>.or
##              (<t>.this ..wildcard-signature)
##              (<>.and ..parse-bound recur)
##              )
##          (|> (<>.and ..parse-class-name
##                      (|> (<>.some recur)
##                          (<>.after (<t>.this "<"))
##                          (<>.before (<t>.this ">"))
##                          (<>.default (list))))
##              (<>.after (<t>.this ..object-prefix))
##              (<>.before (<t>.this ..object-suffix)))
##          ))))

## (def: #export parse-signature
##   (Parser Type)
##   (<>.rec
##    (function (_ recur)
##      ($_ <>.or
##          ($_ <>.or
##              (<t>.this ..boolean-descriptor)
##              (<t>.this ..byte-descriptor)
##              (<t>.this ..short-descriptor)
##              (<t>.this ..int-descriptor)
##              (<t>.this ..long-descriptor)
##              (<t>.this ..float-descriptor)
##              (<t>.this ..double-descriptor)
##              (<t>.this ..char-descriptor)
##              )
##          ..parse-generic
##          (<>.after (<t>.this ..array-prefix)
##                    recur)
##          ))))
