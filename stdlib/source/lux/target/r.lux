(.module:
  [lux (#- Code or and list if function cond not int)
   [control
    [pipe (#+ case> cond> new>)]
    ["." function]
    [parser
     ["<.>" code]]]
   [data
    ["." maybe ("#\." functor)]
    ["." text
     ["%" format (#+ format)]]
    [collection
     ["." list ("#\." functor fold)]]]
   [macro
    [syntax (#+ syntax:)]
    ["." template]
    ["." code]]
   [math
    [number
     ["f" frac]]]
   [type
    abstract]])

(abstract: #export (Code kind)
  Text

  {}

  (template [<type> <super>+]
    [(with_expansions [<kind> (template.identifier [<type> "'"])]
       (abstract: #export (<kind> kind) Any)
       (`` (type: #export <type> (|> Any <kind> (~~ (template.splice <super>+))))))]
    
    [Expression [Code]]
    )

  (template [<type> <super>+]
    [(with_expansions [<kind> (template.identifier [<type> "'"])]
       (abstract: #export (<kind> kind) Any)
       (`` (type: #export (<type> <brand>) (|> <brand> <kind> (~~ (template.splice <super>+))))))]
    
    [Var [Expression' Code]]
    )

  (template [<var> <kind>]
    [(abstract: #export <kind> Any)
     (type: #export <var> (Var <kind>))]

    [SVar Single]
    [PVar Poly]
    )

  (def: #export var
    (-> Text SVar)
    (|>> :abstraction))
  
  (def: #export var_args
    PVar
    (:abstraction "..."))

  (def: #export manual
    (-> Text Code)
    (|>> :abstraction))
  
  (def: #export code
    (-> (Code Any) Text)
    (|>> :representation))

  (def: (self_contained code)
    (-> Text Expression)
    (:abstraction
     (format "(" code ")")))

  (def: nest
    (-> Text Text)
    (let [nested_new_line (format text.new_line text.tab)]
      (|>> (format text.new_line)
           (text.replace_all text.new_line nested_new_line))))

  (def: (_block expression)
    (-> Text Text)
    (format "{" (nest expression) text.new_line "}"))

  (def: #export (block expression)
    (-> Expression Expression)
    (:abstraction
     (format "{" (:representation expression) "}")))

  (template [<name> <r>]
    [(def: #export <name>
       Expression
       (..self_contained <r>))]

    [null "NULL"]
    [n/a "NA"]
    )

  (template [<name>]
    [(def: #export <name> Expression n/a)]

    [not_available]
    [not_applicable]
    [no_answer]
    )

  (def: #export bool
    (-> Bit Expression)
    (|>> (case> #0 "FALSE"
                #1 "TRUE")
         ..self_contained))

  (def: #export (int value)
    (-> Int Expression)
    (..self_contained (format "as.integer(" (%.int value) ")")))

  (def: #export float
    (-> Frac Expression)
    (|>> (cond> [(f.= f.positive_infinity)]
                [(new> "1.0/0.0" [])]
                
                [(f.= f.negative_infinity)]
                [(new> "-1.0/0.0" [])]
                
                [(f.= f.not_a_number)]
                [(new> "0.0/0.0" [])]
                
                ## else
                [%.frac])
         ..self_contained))

  (def: sanitize
    (-> Text Text)
    (`` (|>> (~~ (template [<find> <replace>]
                   [(text.replace_all <find> <replace>)]

                   ["\" "\\"]
                   ["|" "\|"]
                   [text.alarm "\a"]
                   [text.back_space "\b"]
                   [text.tab "\t"]
                   [text.new_line "\n"]
                   [text.carriage_return "\r"]
                   [text.double_quote (format "\" text.double_quote)]
                   ))
             )))

  (def: #export string
    (-> Text Expression)
    (|>> %.text ..sanitize ..self_contained))

  (def: (composite_literal left_delimiter right_delimiter entry_serializer)
    (All [a] (-> Text Text (-> a Text)
                 (-> (List a) Expression)))
    (.function (_ entries)
      (..self_contained
       (format left_delimiter
               (|> entries (list\map entry_serializer) (text.join_with ","))
               right_delimiter))))

  (def: #export named_list
    (-> (List [Text Expression]) Expression)
    (composite_literal "list(" ")" (.function (_ [key value])
                                     (format key "=" (:representation value)))))
  
  (template [<name> <function>]
    [(def: #export <name>
       (-> (List Expression) Expression)
       (composite_literal (format <function> "(") ")" ..code))]

    [vector "c"]
    [list   "list"]
    )
  
  (def: #export (slice from to list)
    (-> Expression Expression Expression Expression)
    (..self_contained
     (format (:representation list)
             "[" (:representation from) ":" (:representation to) "]")))

  (def: #export (slice_from from list)
    (-> Expression Expression Expression)
    (..self_contained
     (format (:representation list)
             "[-1"  ":-" (:representation from) "]")))

  (def: #export (apply args func)
    (-> (List Expression) Expression Expression)
    (..self_contained
     (format (:representation func) "(" (text.join_with "," (list\map ..code args)) ")")))

  (def: #export (apply_kw args kw_args func)
    (-> (List Expression) (List [Text Expression]) Expression Expression)
    (..self_contained
     (format (:representation func)
             (format "("
                     (text.join_with "," (list\map ..code args)) ","
                     (text.join_with "," (list\map (.function (_ [key val])
                                                     (format key "=" (:representation val)))
                                                   kw_args))
                     ")"))))

  (syntax: (arity_inputs {arity <code>.nat})
    (wrap (case arity
            0 (.list)
            _ (|> arity
                  list.indices
                  (list\map (|>> %.nat code.local_identifier))))))

  (syntax: (arity_types {arity <code>.nat})
    (wrap (list.repeat arity (` ..Expression))))

  (template [<arity> <function>+]
    [(with_expansions [<apply> (template.identifier ["apply/" <arity>])
                       <inputs> (arity_inputs <arity>)
                       <types> (arity_types <arity>)
                       <definitions> (template.splice <function>+)]
       (def: #export (<apply> function [<inputs>])
         (-> Expression [<types>] Expression)
         (..apply (.list <inputs>) function))

       (template [<function>]
         [(`` (def: #export (~~ (template.identifier [<function> "/" <arity>]))
                (-> [<types>] Expression)
                (<apply> (..var <function>))))]

         <definitions>))]

    [0
     [["commandArgs"]]]
    [1
     []]
    [2
     []]
    )

  (def: #export (nth idx list)
    (-> Expression Expression Expression)
    (..self_contained
     (format (:representation list) "[[" (:representation idx) "]]")))

  (def: #export (if test then else)
    (-> Expression Expression Expression Expression)
    (..self_contained
     (format "if(" (:representation test) ")"
             " " (.._block (:representation then))
             " else " (.._block (:representation else)))))

  (def: #export (when test then)
    (-> Expression Expression Expression)
    (..self_contained
     (format "if(" (:representation test) ") {"
             (.._block (:representation then))
             text.new_line "}")))

  (def: #export (cond clauses else)
    (-> (List [Expression Expression]) Expression Expression)
    (list\fold (.function (_ [test then] next)
                 (if test then next))
               else
               (list.reverse clauses)))

  (template [<name> <op>]
    [(def: #export (<name> param subject)
       (-> Expression Expression Expression)
       (..self_contained
        (format (:representation subject)
                " " <op> " "
                (:representation param))))]

    [=       "=="]
    [<       "<"]
    [<=      "<="]
    [>       ">"]
    [>=      ">="]
    [+       "+"]
    [-       "-"]
    [*       "*"]
    [/       "/"]
    [%%      "%%"]
    [**      "**"]
    [or      "||"]
    [and     "&&"]
    )

  (template [<name> <func>]
    [(def: #export (<name> param subject)
       (-> Expression Expression Expression)
       (..apply (.list subject param) (..var <func>)))]

    [bit_or   "bitwOr"]
    [bit_and  "bitwAnd"]
    [bit_xor  "bitwXor"]
    [bit_shl  "bitwShiftL"]
    [bit_ushr "bitwShiftR"]
    )

  (def: #export (bit_not subject)
    (-> Expression Expression)
    (..apply (.list subject) (..var "bitwNot")))

  (template [<name> <op>]
    [(def: #export <name>
       (-> Expression Expression)
       (|>> :representation (format <op>) ..self_contained))]

    [not    "!"]
    [negate "-"]
    )
  
  (def: #export (length list)
    (-> Expression Expression)
    (..apply (.list list) (..var "length")))

  (def: #export (range from to)
    (-> Expression Expression Expression)
    (..self_contained
     (format (:representation from) ":" (:representation to))))

  (def: #export (function inputs body)
    (-> (List (Ex [k] (Var k))) Expression Expression)
    (let [args (|> inputs (list\map ..code) (text.join_with ", "))]
      (..self_contained
       (format "function(" args ") "
               (.._block (:representation body))))))

  (def: #export (try body warning error finally)
    (-> Expression (Maybe Expression) (Maybe Expression) (Maybe Expression) Expression)
    (let [optional (: (-> Text (Maybe Expression) (-> Text Text) Text)
                      (.function (_ parameter value preparation)
                        (|> value
                            (maybe\map (|>> :representation preparation (format ", " parameter " = ")))
                            (maybe.default ""))))]
      (..self_contained
       (format "tryCatch("
               (.._block (:representation body))
               (optional "warning" warning function.identity)
               (optional "error" error function.identity)
               (optional "finally" finally .._block)
               ")"))))

  (def: #export (while test body)
    (-> Expression Expression Expression)
    (..self_contained
     (format "while (" (:representation test) ") "
             (.._block (:representation body)))))

  (def: #export (for_in var inputs body)
    (-> SVar Expression Expression Expression)
    (..self_contained
     (format "for (" (:representation var) " in " (:representation inputs) ")"
             (.._block (:representation body)))))

  (template [<name> <keyword>]
    [(def: #export (<name> message)
       (-> Expression Expression)
       (..apply (.list message) (..var <keyword>)))]

    [stop  "stop"]
    [print "print"]
    )

  (def: #export (set! var value)
    (-> SVar Expression Expression)
    (..self_contained
     (format (:representation var) " <- " (:representation value))))

  (def: #export (set_nth! idx value list)
    (-> Expression Expression SVar Expression)
    (..self_contained
     (format (:representation list) "[[" (:representation idx) "]] <- " (:representation value))))

  (def: #export (then pre post)
    (-> Expression Expression Expression)
    (:abstraction
     (format (:representation pre)
             text.new_line
             (:representation post))))
  )
