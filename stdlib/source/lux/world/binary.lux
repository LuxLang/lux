(.module:
  [lux (#- i64)
   ["." host (#+ import:)]
   ["@" target]
   [abstract
    [monad (#+ do)]
    [equivalence (#+ Equivalence)]]
   [control
    ["." exception (#+ exception:)]]
   [data
    ["." maybe]
    ["." error (#+ Error)]
    [number
     ["." i64]]
    [text
     format]
    [collection
     [array (#+ Array)]]]])

(exception: #export (index-out-of-bounds {size Nat} {index Nat})
  (exception.report
   ["Size" (%n size)]
   ["Index" (%n index)]))

(template [<name>]
  [(exception: #export (<name> {size Nat} {from Nat} {to Nat})
     (exception.report
      ["Size" (%n size)]
      ["From" (%n from)]
      ["To" (%n to)]))]

  [slice-out-of-bounds]
  [inverted-slice]
  )

(`` (for {(~~ (static @.old))
          (as-is (type: #export Binary (host.type (Array byte)))

                 (import: #long java/lang/Object)

                 (import: #long java/lang/System
                   (#static arraycopy [java/lang/Object int java/lang/Object int int] #try void))

                 (import: #long java/util/Arrays
                   (#static copyOfRange [(Array byte) int int] (Array byte))
                   (#static equals [(Array byte) (Array byte)] boolean)))

          (~~ (static @.jvm))
          (as-is (type: #export Binary (host.type [byte]))

                 (import: #long java/lang/Object)
                 
                 (import: #long java/lang/System
                   (#static arraycopy [java/lang/Object int java/lang/Object int int] #try void))

                 (import: #long java/util/Arrays
                   (#static copyOfRange [[byte] int int] [byte])
                   (#static equals [[byte] [byte]] boolean)))}))

(def: byte-mask
  I64
  (|> i64.bits-per-byte i64.mask .i64))

(def: i64
  (-> (primitive "java.lang.Byte") I64)
  (|>> host.byte-to-long (:coerce I64) (i64.and ..byte-mask)))

(def: byte
  (-> (I64 Any) (primitive "java.lang.Byte"))
  (`` (for {(~~ (static @.old))
            (|>> .int host.long-to-byte)

            (~~ (static @.jvm))
            (|>> .int (:coerce (primitive "java.lang.Long")) host.long-to-byte)})))

(template: (!size binary)
  (`` (for {(~~ (static @.old))
            (host.array-length binary)

            (~~ (static @.jvm))
            (host.array-length binary)})))

(def: #export size
  (-> Binary Nat)
  (|>> !size))

(def: #export create
  (-> Nat Binary)
  (`` (for {(~~ (static @.old))
            (|>> (host.array byte))

            (~~ (static @.jvm))
            (|>> (host.array byte))})))

(def: #export (read/8 idx binary)
  (-> Nat Binary (Error I64))
  (if (n/< (..!size binary) idx)
    (#error.Success (..i64 (host.array-read idx binary)))
    (exception.throw index-out-of-bounds [(..!size binary) idx])))

(def: #export (read/16 idx binary)
  (-> Nat Binary (Error I64))
  (if (n/< (..!size binary) (n/+ 1 idx))
    (#error.Success ($_ i64.or
                        (i64.left-shift 8 (..i64 (host.array-read idx binary)))
                        (..i64 (host.array-read (n/+ 1 idx) binary))))
    (exception.throw index-out-of-bounds [(..!size binary) idx])))

(def: #export (read/32 idx binary)
  (-> Nat Binary (Error I64))
  (if (n/< (..!size binary) (n/+ 3 idx))
    (#error.Success ($_ i64.or
                        (i64.left-shift 24 (..i64 (host.array-read idx binary)))
                        (i64.left-shift 16 (..i64 (host.array-read (n/+ 1 idx) binary)))
                        (i64.left-shift 8 (..i64 (host.array-read (n/+ 2 idx) binary)))
                        (..i64 (host.array-read (n/+ 3 idx) binary))))
    (exception.throw index-out-of-bounds [(..!size binary) idx])))

(def: #export (read/64 idx binary)
  (-> Nat Binary (Error I64))
  (if (n/< (..!size binary) (n/+ 7 idx))
    (#error.Success ($_ i64.or
                        (i64.left-shift 56 (..i64 (host.array-read idx binary)))
                        (i64.left-shift 48 (..i64 (host.array-read (n/+ 1 idx) binary)))
                        (i64.left-shift 40 (..i64 (host.array-read (n/+ 2 idx) binary)))
                        (i64.left-shift 32 (..i64 (host.array-read (n/+ 3 idx) binary)))
                        (i64.left-shift 24 (..i64 (host.array-read (n/+ 4 idx) binary)))
                        (i64.left-shift 16 (..i64 (host.array-read (n/+ 5 idx) binary)))
                        (i64.left-shift 8 (..i64 (host.array-read (n/+ 6 idx) binary)))
                        (..i64 (host.array-read (n/+ 7 idx) binary))))
    (exception.throw index-out-of-bounds [(..!size binary) idx])))

(def: #export (write/8 idx value binary)
  (-> Nat (I64 Any) Binary (Error Binary))
  (if (n/< (..!size binary) idx)
    (exec (|> binary
              (host.array-write idx (..byte value)))
      (#error.Success binary))
    (exception.throw index-out-of-bounds [(..!size binary) idx])))

(def: #export (write/16 idx value binary)
  (-> Nat (I64 Any) Binary (Error Binary))
  (if (n/< (..!size binary) (n/+ 1 idx))
    (exec (|> binary
              (host.array-write idx (..byte (i64.logic-right-shift 8 value)))
              (host.array-write (n/+ 1 idx) (..byte value)))
      (#error.Success binary))
    (exception.throw index-out-of-bounds [(..!size binary) idx])))

(def: #export (write/32 idx value binary)
  (-> Nat (I64 Any) Binary (Error Binary))
  (if (n/< (..!size binary) (n/+ 3 idx))
    (exec (|> binary
              (host.array-write idx (..byte (i64.logic-right-shift 24 value)))
              (host.array-write (n/+ 1 idx) (..byte (i64.logic-right-shift 16 value)))
              (host.array-write (n/+ 2 idx) (..byte (i64.logic-right-shift 8 value)))
              (host.array-write (n/+ 3 idx) (..byte value)))
      (#error.Success binary))
    (exception.throw index-out-of-bounds [(..!size binary) idx])))

(def: #export (write/64 idx value binary)
  (-> Nat (I64 Any) Binary (Error Binary))
  (if (n/< (..!size binary) (n/+ 7 idx))
    (exec (|> binary
              (host.array-write idx (..byte (i64.logic-right-shift 56 value)))
              (host.array-write (n/+ 1 idx) (..byte (i64.logic-right-shift 48 value)))
              (host.array-write (n/+ 2 idx) (..byte (i64.logic-right-shift 40 value)))
              (host.array-write (n/+ 3 idx) (..byte (i64.logic-right-shift 32 value)))
              (host.array-write (n/+ 4 idx) (..byte (i64.logic-right-shift 24 value)))
              (host.array-write (n/+ 5 idx) (..byte (i64.logic-right-shift 16 value)))
              (host.array-write (n/+ 6 idx) (..byte (i64.logic-right-shift 8 value)))
              (host.array-write (n/+ 7 idx) (..byte value)))
      (#error.Success binary))
    (exception.throw index-out-of-bounds [(..!size binary) idx])))

(def: #export (slice from to binary)
  (-> Nat Nat Binary (Error Binary))
  (let [size (..!size binary)]
    (cond (not (n/<= to from))
          (exception.throw inverted-slice [size from to])

          (not (and (n/< size from)
                    (n/< size to)))
          (exception.throw slice-out-of-bounds [size from to])

          ## else
          (#error.Success (java/util/Arrays::copyOfRange binary (.int from) (.int (inc to)))))))

(def: #export (slice' from binary)
  (-> Nat Binary (Error Binary))
  (slice from (dec (..!size binary)) binary))

(structure: #export equivalence (Equivalence Binary)
  (def: (= reference sample)
    (`` (for {(~~ (static @.old))
              (java/util/Arrays::equals reference sample)

              (~~ (static @.jvm))
              (java/util/Arrays::equals reference sample)}))))

(def: #export (copy bytes source-offset source target-offset target)
  (-> Nat Nat Binary Nat Binary (Error Binary))
  (do error.monad
    [_ (java/lang/System::arraycopy source (.int source-offset) target (.int target-offset) (.int bytes))]
    (wrap target)))
