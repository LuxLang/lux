(.module:
  [lux #*
   ["." host]
   ["@" target]
   [abstract
    ["." monad (#+ Monad do)]]
   [control
    ["." try (#+ Try) ("#\." functor)]
    ["." exception (#+ Exception exception:)]
    ["." io (#+ IO) ("#\." functor)]
    ["." function]
    [concurrency
     ["." promise (#+ Promise)]
     ["." stm (#+ Var STM)]]
    [security
     ["!" capability (#+ capability:)]]]
   [data
    ["." bit ("#\." equivalence)]
    ["." product]
    ["." maybe]
    ["." binary (#+ Binary)]
    ["." text ("#\." equivalence)
     ["%" format (#+ format)]]
    [collection
     ["." array (#+ Array)]
     ["." list ("#\." functor)]
     ["." dictionary (#+ Dictionary)]]]
   [macro
    ["." template]]
   [math
    [number
     ["i" int]
     ["f" frac]]]
   [time
    ["." instant (#+ Instant)]
    ["." duration]]])

(type: #export Path
  Text)

(capability: #export (Can_Open ! capability)
  (can_open Path (! (Try (capability !)))))

(capability: #export (Can_See o)
  (can_see [] o))

(capability: #export (Can_Query ! o)
  (can_query [] (! (Try o))))

(capability: #export (Can_Modify ! i)
  (can_modify [i] (! (Try Any))))

(capability: #export (Can_Delete !)
  (can_delete [] (! (Try Any))))

(`` (signature: #export (File !)
      (~~ (template [<name> <output>]
            [(: (Can_See <output>)
                <name>)]

            [name Text]
            [path Path]
            ))

      (~~ (template [<name> <output>]
            [(: (Can_Query ! <output>)
                <name>)]

            [size          Nat]
            [last_modified Instant]
            [can_execute?  Bit]
            [content       Binary]
            ))

      (: (Can_Open ! File)
         move)

      (~~ (template [<name> <input>]
            [(: (Can_Modify ! <input>)
                <name>)]

            [modify     Instant]
            [over_write Binary]
            [append     Binary]
            ))

      (: (Can_Delete !)
         delete)
      ))

(signature: #export (Directory !)
  (: (Can_See Path)
     scope)

  (: (Can_Query ! (List (File !)))
     files)

  (: (Can_Query ! (List (Directory !)))
     directories)

  (: (Can_Delete !)
     discard))

(`` (signature: #export (System !)
      (~~ (template [<name> <capability>]
            [(: (Can_Open ! <capability>)
                <name>)]

            [file             File]
            [create_file      File]
            [directory        Directory]
            [create_directory Directory]
            ))

      (: Text
         separator)
      ))

(def: (async_file file)
  (-> (File IO) (File Promise))
  (`` (structure
       (~~ (template [<forge> <name>+]
             [(with_expansions [<rows> (template.splice <name>+)]
                (template [<name>]
                  [(def: <name> (<forge> (|>> (!.use (\ file <name>)))))]

                  <rows>))]

             [..can_see
              [[name] [path]]]
             
             ))

       (~~ (template [<forge> <name>+]
             [(with_expansions [<rows> (template.splice <name>+)]
                (template [<name>]
                  [(def: <name> (<forge> (|>> (!.use (\ file <name>)) promise.future)))]

                  <rows>))]

             [..can_query
              [[size] [last_modified] [can_execute?] [content]]]
             
             [..can_modify
              [[modify] [over_write] [append]]]
             
             [..can_delete
              [[delete]]]))

       (def: move
         (..can_open
          (|>> (!.use (\ file move)) (io\map (try\map async_file)) promise.future))))))

(def: (async_directory directory)
  (-> (Directory IO) (Directory Promise))
  (`` (structure (def: scope
                   (\ directory scope))

                 (~~ (template [<name> <async>]
                       [(def: <name>
                          (..can_query
                           (|>> (!.use (\ directory <name>))
                                (io\map (try\map (list\map <async>)))
                                promise.future)))]

                       [files       ..async_file]
                       [directories async_directory]))

                 (def: discard
                   (..can_delete
                    (|>> (!.use (\ directory discard)) promise.future))))))

(def: #export (async system)
  (-> (System IO) (System Promise))
  (`` (structure
       (~~ (template [<name> <async>]
             [(def: <name> (..can_open
                            (|>> (!.use (\ system <name>)) (io\map (try\map <async>)) promise.future)))]

             [file             ..async_file]
             [create_file      ..async_file]
             [directory        ..async_directory]
             [create_directory ..async_directory]))

       (def: separator (\ system separator)))))

(def: #export (un_nest system file)
  (All [!] (-> (System !) Path (Maybe [Path Text])))
  (case (text.last_index_of (\ system separator) file)
    #.None
    #.None
    
    (#.Some last_separator)
    (let [[parent temp] (maybe.assume (text.split last_separator file))
          [_ child] (maybe.assume (text.split (text.size (\ system separator)) temp))]
      (#.Some [parent child]))))

(def: #export (nest system [parent child])
  (All [!] (-> (System !) [Path Text] Path))
  (format parent (\ system separator) child))

(template [<name>]
  [(exception: #export (<name> {file Path})
     (exception.report
      ["Path" file]))]

  [cannot_create_file]
  [cannot_find_file]
  [cannot_delete_file]
  [not_a_file]

  [cannot_create_directory]
  [cannot_find_directory]
  [cannot_discard_directory]
  
  [cannot_read_all_data]
  [not_a_directory]
  )

(with_expansions [<extra> (as_is (exception: #export (cannot_move {target Path} {source Path})
                                   (exception.report
                                    ["Source" source]
                                    ["Target" target])))]
  (for {@.old (as_is <extra>)
        @.jvm (as_is <extra>)
        @.lua (as_is <extra>)}
       (as_is)))

(with_expansions [<for_jvm> (as_is (exception: #export (cannot_modify {instant Instant} {file Path})
                                     (exception.report
                                      ["Instant" (%.instant instant)]
                                      ["Path" file]))

                                   (host.import: java/lang/String)

                                   (`` (host.import: java/io/File
                                         ["#::."
                                          (new [java/lang/String])
                                          (~~ (template [<name>]
                                                [(<name> [] #io #try boolean)]

                                                [createNewFile] [mkdir]
                                                [exists] [delete]
                                                [isFile] [isDirectory]
                                                [canRead] [canWrite] [canExecute]))

                                          (getName [] java/lang/String)
                                          (length [] #io #try long)
                                          (listFiles [] #io #try #? [java/io/File])
                                          (getAbsolutePath [] #io #try java/lang/String)
                                          (renameTo [java/io/File] #io #try boolean)
                                          (lastModified [] #io #try long)
                                          (setLastModified [long] #io #try boolean)
                                          (#static separator java/lang/String)]))

                                   (template: (!delete path exception)
                                     (do io.monad
                                       [outcome (java/io/File::delete (java/io/File::new path))]
                                       (case outcome
                                         (#try.Success #1)
                                         (wrap (#try.Success []))

                                         _
                                         (wrap (exception.throw exception [path])))))

                                   (host.import: java/lang/AutoCloseable
                                     ["#::."
                                      (close [] #io #try void)])

                                   (host.import: java/io/OutputStream
                                     ["#::."
                                      (write [[byte]] #io #try void)
                                      (flush [] #io #try void)])

                                   (host.import: java/io/FileOutputStream
                                     ["#::."
                                      (new [java/io/File boolean] #io #try)])

                                   (host.import: java/io/InputStream
                                     ["#::."
                                      (read [[byte]] #io #try int)])

                                   (host.import: java/io/FileInputStream
                                     ["#::."
                                      (new [java/io/File] #io #try)])

                                   (`` (structure: (file path)
                                         (-> Path (File IO))

                                         (~~ (template [<name> <flag>]
                                               [(def: <name>
                                                  (..can_modify
                                                   (function (<name> data)
                                                     (do (try.with io.monad)
                                                       [stream (java/io/FileOutputStream::new (java/io/File::new path) <flag>)
                                                        _ (java/io/OutputStream::write data stream)
                                                        _ (java/io/OutputStream::flush stream)]
                                                       (java/lang/AutoCloseable::close stream)))))]

                                               [over_write  #0]
                                               [append      #1]
                                               ))

                                         (def: content
                                           (..can_query
                                            (function (content _)
                                              (do (try.with io.monad)
                                                [#let [file (java/io/File::new path)]
                                                 size (java/io/File::length file)
                                                 #let [data (binary.create (.nat size))]
                                                 stream (java/io/FileInputStream::new file)
                                                 bytes_read (java/io/InputStream::read data stream)
                                                 _ (java/lang/AutoCloseable::close stream)]
                                                (if (i.= size bytes_read)
                                                  (wrap data)
                                                  (\ io.monad wrap (exception.throw ..cannot_read_all_data path)))))))

                                         (def: name
                                           (..can_see
                                            (function (name _)
                                              (|> path
                                                  java/io/File::new
                                                  java/io/File::getName))))

                                         (def: path
                                           (..can_see
                                            (function (_ _)
                                              path)))

                                         (def: size
                                           (..can_query
                                            (function (size _)
                                              (|> path
                                                  java/io/File::new
                                                  java/io/File::length
                                                  (\ (try.with io.monad) map .nat)))))

                                         (def: last_modified
                                           (..can_query
                                            (function (last_modified _)
                                              (|> path
                                                  java/io/File::new
                                                  (java/io/File::lastModified)
                                                  (\ (try.with io.monad) map (|>> duration.from_millis instant.absolute))))))

                                         (def: can_execute?
                                           (..can_query
                                            (function (can_execute? _)
                                              (|> path
                                                  java/io/File::new
                                                  java/io/File::canExecute))))

                                         (def: move
                                           (..can_open
                                            (function (move destination)
                                              (do io.monad
                                                [outcome (java/io/File::renameTo (java/io/File::new destination)
                                                                                 (java/io/File::new path))]
                                                (case outcome
                                                  (#try.Success #1)
                                                  (wrap (#try.Success (file destination)))

                                                  _
                                                  (wrap (exception.throw ..cannot_move [destination path])))))))

                                         (def: modify
                                           (..can_modify
                                            (function (modify time_stamp)
                                              (do io.monad
                                                [outcome (java/io/File::setLastModified (|> time_stamp instant.relative duration.to_millis)
                                                                                        (java/io/File::new path))]
                                                (case outcome
                                                  (#try.Success #1)
                                                  (wrap (#try.Success []))

                                                  _
                                                  (wrap (exception.throw ..cannot_modify [time_stamp path])))))))

                                         (def: delete
                                           (..can_delete
                                            (function (delete _)
                                              (!delete path cannot_delete_file))))))

                                   (`` (structure: (directory path)
                                         (-> Path (Directory IO))

                                         (def: scope
                                           (..can_see
                                            (function (_ _)
                                              path)))
                                         
                                         (~~ (template [<name> <method> <capability>]
                                               [(def: <name>
                                                  (..can_query
                                                   (function (<name> _)
                                                     (do {! (try.with io.monad)}
                                                       [?children (java/io/File::listFiles (java/io/File::new path))]
                                                       (case ?children
                                                         (#.Some children)
                                                         (|> children
                                                             array.to_list
                                                             (monad.filter ! (|>> <method>))
                                                             (\ ! map (monad.map ! (|>> java/io/File::getAbsolutePath (\ ! map <capability>))))
                                                             (\ ! join))

                                                         #.None
                                                         (\ io.monad wrap (exception.throw ..not_a_directory [path])))))))]

                                               [files       java/io/File::isFile      file]
                                               [directories java/io/File::isDirectory directory]
                                               ))

                                         (def: discard
                                           (..can_delete
                                            (function (discard _)
                                              (!delete path cannot_discard_directory))))))

                                   (`` (structure: #export default
                                         (System IO)
                                         
                                         (~~ (template [<name> <method> <capability> <exception>]
                                               [(def: <name>
                                                  (..can_open
                                                   (function (<name> path)
                                                     (do io.monad
                                                       [#let [file (java/io/File::new path)]
                                                        outcome (<method> file)]
                                                       (case outcome
                                                         (#try.Success #1)
                                                         (wrap (#try.Success (<capability> path)))

                                                         _
                                                         (wrap (exception.throw <exception> [path])))))))]

                                               [file             java/io/File::isFile        ..file      cannot_find_file]
                                               [create_file      java/io/File::createNewFile ..file      cannot_create_file]
                                               [directory        java/io/File::isDirectory   ..directory cannot_find_directory]
                                               [create_directory java/io/File::mkdir         ..directory cannot_create_directory]
                                               ))

                                         (def: separator (java/io/File::separator))
                                         )))]
  (for {@.old (as_is <for_jvm>)
        @.jvm (as_is <for_jvm>)

        @.js
        (as_is (host.import: Buffer
                 (#static from [Binary] ..Buffer))
               
               (host.import: FileDescriptor)

               (host.import: Stats
                 (size host.Number)
                 (mtimeMs host.Number)
                 (isFile [] #io #try host.Boolean)
                 (isDirectory [] #io #try host.Boolean))

               (host.import: FsConstants
                 (F_OK host.Number)
                 (R_OK host.Number)
                 (W_OK host.Number)
                 (X_OK host.Number))
               
               (host.import: Fs
                 (constants FsConstants)
                 (readFileSync [host.String] #io #try Binary)
                 (appendFileSync [host.String Buffer] #io #try Any)
                 (writeFileSync [host.String Buffer] #io #try Any)
                 (statSync [host.String] #io #try Stats)
                 (accessSync [host.String host.Number] #io #try Any)
                 (renameSync [host.String host.String] #io #try Any)
                 (utimesSync [host.String host.Number host.Number] #io #try Any)
                 (unlink [host.String] #io #try Any)
                 (readdirSync [host.String] #io #try (Array host.String))
                 (mkdirSync [host.String] #io #try Any)
                 (rmdirSync [host.String] #io #try Any))

               (host.import: JsPath
                 (sep host.String)
                 (basename [host.String] host.String))
               
               (template [<name> <path>]
                 [(def: (<name> _)
                    (-> [] (Maybe (-> host.String Any)))
                    (host.constant (-> host.String Any) <path>))]

                 [normal_require [require]]
                 [global_require [global require]]
                 [process_load [global process mainModule constructor _load]]
                 )

               (def: (require _)
                 (-> [] (-> host.String Any))
                 (case [(normal_require []) (global_require []) (process_load [])]
                   (^or [(#.Some require) _ _]
                        [_ (#.Some require) _]
                        [_ _ (#.Some require)])
                   require

                   _
                   (undefined)))

               (template [<name> <module> <type>]
                 [(def: (<name> _)
                    (-> [] <type>)
                    (:coerce <type> (..require [] <module>)))]

                 [node_fs "fs" ..Fs]
                 [node_path "path" ..JsPath]
                 )

               (`` (structure: (file path)
                     (-> Path (File IO))

                     (~~ (template [<name> <method>]
                           [(def: <name>
                              (..can_modify
                               (function (<name> data)
                                 (<method> [path (Buffer::from data)] (..node_fs [])))))]

                           [over_write  Fs::writeFileSync]
                           [append      Fs::appendFileSync]
                           ))

                     (def: content
                       (..can_query
                        (function (_ _)
                          (Fs::readFileSync [path] (..node_fs [])))))

                     (def: name
                       (..can_see
                        (function (_ _)
                          (JsPath::basename path (..node_path [])))))

                     (def: path
                       (..can_see
                        (function (_ _)
                          path)))

                     (def: size
                       (..can_query
                        (function (_ _)
                          (do (try.with io.monad)
                            [stat (Fs::statSync [path] (..node_fs []))]
                            (wrap (|> stat
                                      Stats::size
                                      f.nat))))))

                     (def: last_modified
                       (..can_query
                        (function (_ _)
                          (do (try.with io.monad)
                            [stat (Fs::statSync [path] (..node_fs []))]
                            (wrap (|> stat
                                      Stats::mtimeMs
                                      f.int
                                      duration.from_millis
                                      instant.absolute))))))

                     (def: can_execute?
                       (..can_query
                        (function (can_execute? _)
                          (do (try.with io.monad)
                            [#let [node_fs (..node_fs [])]
                             _ (Fs::accessSync [path (|> node_fs Fs::constants FsConstants::F_OK)] node_fs)]
                            (do io.monad
                              [outcome (Fs::accessSync [path (|> node_fs Fs::constants FsConstants::X_OK)] node_fs)]
                              (wrap (#try.Success (case outcome
                                                    (#try.Success _)
                                                    true

                                                    (#try.Failure _)
                                                    false))))))))

                     (def: move
                       (..can_open
                        (function (move destination)
                          (do (try.with io.monad)
                            [_ (Fs::renameSync [path destination] (..node_fs []))]
                            (wrap (file destination))))))

                     (def: modify
                       (..can_modify
                        (function (modify time_stamp)
                          (let [when (|> time_stamp instant.relative duration.to_millis i.frac)]
                            (Fs::utimesSync [path when when] (..node_fs []))))))

                     (def: delete
                       (..can_delete
                        (function (delete _)
                          (Fs::unlink [path] (..node_fs [])))))))

               (`` (structure: (directory path)
                     (-> Path (Directory IO))

                     (def: scope
                       (..can_see
                        (function (_ _)
                          path)))
                     
                     (~~ (template [<name> <method> <capability>]
                           [(def: <name>
                              (..can_query
                               (function (<name> _)
                                 (do {! (try.with io.monad)}
                                   [#let [node_fs (..node_fs [])]
                                    subs (Fs::readdirSync [path] node_fs)
                                    subs (monad.map ! (function (_ sub)
                                                        (do !
                                                          [stats (Fs::statSync [sub] node_fs)
                                                           verdict (<method> [] stats)]
                                                          (wrap [verdict sub])))
                                                    (array.to_list subs))]
                                   (wrap (|> subs
                                             (list.filter product.left)
                                             (list\map (|>> product.right <capability>))))))))]

                           [files       Stats::isFile      ..file]
                           [directories Stats::isDirectory directory]
                           ))

                     (def: discard
                       (..can_delete
                        (function (discard _)
                          (Fs::rmdirSync [path] (..node_fs [])))))))

               (`` (structure: #export default
                     (System IO)
                     
                     (~~ (template [<name> <method> <capability> <exception>]
                           [(with_expansions [<failure> (exception.throw <exception> [path])]
                              (def: <name>
                                (..can_open
                                 (function (<name> path)
                                   (do {! io.monad}
                                     [?stats (Fs::statSync [path] (..node_fs []))]
                                     (case ?stats
                                       (#try.Success stats)
                                       (do !
                                         [?verdict (<method> [] stats)]
                                         (wrap (case ?verdict
                                                 (#try.Success verdict)
                                                 (if verdict
                                                   (#try.Success (<capability> path))
                                                   <failure>)
                                                 
                                                 (#try.Failure _)
                                                 <failure>)))
                                       
                                       (#try.Failure _)
                                       (wrap <failure>)))))))]

                           [file             Stats::isFile        ..file      ..cannot_find_file]
                           [directory        Stats::isDirectory   ..directory ..cannot_find_directory]
                           ))

                     (~~ (template [<name> <capability> <exception> <prep>]
                           [(def: <name>
                              (..can_open
                               (function (<name> path)
                                 (let [node_fs (..node_fs [])]
                                   (do io.monad
                                     [outcome (Fs::accessSync [path (|> node_fs Fs::constants FsConstants::F_OK)] node_fs)]
                                     (case outcome
                                       (#try.Success _)
                                       (wrap (exception.throw <exception> [path]))
                                       
                                       (#try.Failure _)
                                       (do (try.with io.monad)
                                         [_ (|> node_fs <prep>)]
                                         (wrap (<capability> path)))))))))]

                           [create_file ..file ..cannot_create_file (Fs::appendFileSync [path (Buffer::from (binary.create 0))])]
                           [create_directory ..directory ..cannot_create_directory (Fs::mkdirSync [path])]
                           ))

                     (def: separator
                       (if host.on_node_js?
                         (JsPath::sep (..node_path []))
                         "/"))
                     ))
               )

        @.python
        (as_is (type: (Tuple/2 left right)
                 (primitive "python_tuple[2]" [left right]))

               (host.import: PyFile
                 (read [] #io #try Binary)
                 (write [Binary] #io #try #? Any)
                 (close [] #io #try #? Any))

               (host.import: (open [host.String host.String] #io #try PyFile))
               (host.import: (tuple [[host.Integer host.Integer]] (Tuple/2 host.Integer host.Integer)))

               (host.import: os
                 (#static F_OK host.Integer)
                 (#static R_OK host.Integer)
                 (#static W_OK host.Integer)
                 (#static X_OK host.Integer)

                 (#static mkdir [host.String] #io #try #? Any)
                 (#static access [host.String host.Integer] #io #try host.Boolean)
                 (#static remove [host.String] #io #try #? Any)
                 (#static rmdir [host.String] #io #try #? Any)
                 (#static rename [host.String host.String] #io #try #? Any)
                 (#static utime [host.String (Tuple/2 host.Integer host.Integer)] #io #try #? Any)
                 (#static listdir [host.String] #io #try (Array host.String)))

               (host.import: os/path
                 (#static isfile [host.String] #io #try host.Boolean)
                 (#static isdir [host.String] #io #try host.Boolean)
                 (#static sep host.String)
                 (#static basename [host.String] host.String)
                 (#static getsize [host.String] #io #try host.Integer)
                 (#static getmtime [host.String] #io #try host.Float))

               (`` (structure: (file path)
                     (-> Path (File IO))

                     (~~ (template [<name> <mode>]
                           [(def: <name>
                              (..can_modify
                               (function (<name> data)
                                 (do (try.with io.monad)
                                   [file (..open [path <mode>])
                                    _ (PyFile::write [data] file)
                                    _ (PyFile::close [] file)]
                                   (wrap [])))))]
                           
                           [over_write  "w+b"]
                           [append      "ab"]
                           ))

                     (def: content
                       (..can_query
                        (function (_ _)
                          (do (try.with io.monad)
                            [file (..open [path "rb"])
                             data (PyFile::read [] file)
                             _ (PyFile::close [] file)]
                            (wrap data)))))

                     (def: name
                       (..can_see
                        (function (_ _)
                          (os/path::basename [path]))))

                     (def: path
                       (..can_see
                        (function (_ _)
                          path)))

                     (def: size
                       (..can_query
                        (function (_ _)
                          (do (try.with io.monad)
                            [size (os/path::getsize [path])]
                            (wrap (.nat size))))))

                     (def: last_modified
                       (..can_query
                        (function (_ _)
                          (do (try.with io.monad)
                            [seconds_since_epoch (os/path::getmtime [path])]
                            (wrap (|> seconds_since_epoch
                                      f.int
                                      (i.* +1,000)
                                      duration.from_millis
                                      instant.absolute))))))

                     (def: can_execute?
                       (..can_query
                        (function (can_execute? _)
                          (os::access [path (os::X_OK)]))))

                     (def: move
                       (..can_open
                        (function (move destination)
                          (do (try.with io.monad)
                            [_ (os::rename [path destination])]
                            (wrap (file destination))))))

                     (def: modify
                       (..can_modify
                        (function (modify time_stamp)
                          (let [when (|> time_stamp instant.relative duration.to_millis (i./ +1,000))]
                            (os::utime [path (..tuple [when when])])))))

                     (def: delete
                       (..can_delete
                        (function (delete _)
                          (os::remove [path]))))
                     ))

               (`` (structure: (directory path)
                     (-> Path (Directory IO))

                     (def: scope
                       (..can_see
                        (function (_ _)
                          path)))
                     
                     (~~ (template [<name> <method> <capability>]
                           [(def: <name>
                              (..can_query
                               (function (<name> _)
                                 (do {! (try.with io.monad)}
                                   [subs (os::listdir [path])
                                    subs (monad.map ! (function (_ sub)
                                                        (do !
                                                          [verdict (<method> [sub])]
                                                          (wrap [verdict sub])))
                                                    (array.to_list subs))]
                                   (wrap (|> subs
                                             (list.filter product.left)
                                             (list\map (|>> product.right <capability>))))))))]

                           [files       os/path::isfile ..file]
                           [directories os/path::isdir  directory]
                           ))

                     (def: discard
                       (..can_delete
                        (function (discard _)
                          (os::rmdir [path]))))
                     ))

               (`` (structure: #export default
                     (System IO)
                     
                     (~~ (template [<name> <method> <capability> <exception>]
                           [(with_expansions [<failure> (exception.throw <exception> [path])]
                              (def: <name>
                                (..can_open
                                 (function (<name> path)
                                   (do io.monad
                                     [?verdict (<method> [path])]
                                     (wrap (case ?verdict
                                             (#try.Success verdict)
                                             (if verdict
                                               (#try.Success (<capability> path))
                                               <failure>)
                                             
                                             (#try.Failure _)
                                             <failure>)))))))]

                           [file      os/path::isfile  ..file      ..cannot_find_file]
                           [directory os/path::isdir   ..directory ..cannot_find_directory]
                           ))

                     (def: create_file
                       (..can_open
                        (function (create_file path)
                          (do {! io.monad}
                            [file (..open [path "w"])]
                            (case file
                              (#try.Success file)
                              (do (try.with !)
                                [_ (PyFile::close [] file)]
                                (wrap (..file path)))
                              
                              (#try.Failure error)
                              (wrap (exception.throw ..cannot_create_file [path])))))))

                     (def: create_directory
                       (..can_open
                        (function (create_directory path)
                          (do io.monad
                            [outcome (os::mkdir [path])]
                            (wrap (case outcome
                                    (#try.Success _)
                                    (#try.Success (..directory path))
                                    
                                    (#try.Failure error)
                                    (exception.throw ..cannot_create_directory [path])))))))

                     (def: separator
                       (os/path::sep))
                     ))
               )

        @.lua
        (as_is (host.import: LuaFile
                 (read [host.String] #io host.String)
                 (write [host.String] #io #? LuaFile)
                 (flush [] #io host.Boolean)
                 (close [] #io host.Boolean))

               (host.import: (io/open [host.String host.String] #io #? LuaFile))

               (host.import: (package/config host.String))

               (host.import: (os/rename [host.String host.String] #io #? host.Boolean))
               (host.import: (os/remove [host.String] #io #? host.Boolean))
               (host.import: (os/execute [host.String] #io #? host.Boolean))

               (def: default_separator
                 Text
                 (|> (package/config)
                     (text.split_all_with text.new_line)
                     list.head
                     (maybe.default "/")))

               (template [<name>]
                 [(exception: #export (<name> {file Path})
                    (exception.report
                     ["Path" file]))]

                 [cannot_open_file]
                 [cannot_close_file]
                 [cannot_write_to_file]
                 [file_already_exists]
                 )

               (exception: #export (invalid_operation {signature Name} {operation Text})
                 (exception.report
                  ["Platform" @.lua]
                  ["Signature" (%.name signature)]
                  ["Operation" (%.text operation)]))

               (`` (structure: (file path)
                     (-> Path (File IO))

                     (~~ (template [<name> <mode>]
                           [(def: <name>
                              (..can_modify
                               (function (<name> data)
                                 (do {! io.monad}
                                   [?file (io/open [path <mode>])]
                                   (case ?file
                                     (#.Some file)
                                     (do !
                                       [?wrote (LuaFile::write [("lua utf8 decode" data)] file)]
                                       (case ?wrote
                                         (#.Some _)
                                         (do !
                                           [flushed? (LuaFile::flush [] file)
                                            closed? (LuaFile::close [] file)]
                                           (wrap (cond (not flushed?)
                                                       (exception.throw ..cannot_write_to_file [path])

                                                       (not closed?)
                                                       (exception.throw ..cannot_close_file [path])

                                                       ## else
                                                       (#try.Success []))))
                                         
                                         #.None
                                         (wrap (exception.throw ..cannot_write_to_file [path]))))
                                     
                                     #.None
                                     (wrap (exception.throw ..cannot_open_file [path])))))))]
                           
                           [over_write  "w+b"]
                           [append      "ab"]
                           ))

                     (def: content
                       (..can_query
                        (function (_ _)
                          (do {! io.monad}
                            [?file (io/open [path "rb"])]
                            (case ?file
                              (#.Some file)
                              (do !
                                [data (LuaFile::read ["a"] file)
                                 closed? (LuaFile::close [] file)]
                                (wrap (if closed?
                                        (#try.Success ("lua utf8 encode" data))
                                        (exception.throw ..cannot_close_file [path]))))
                              
                              #.None
                              (wrap (exception.throw ..cannot_read_all_data [path])))))))

                     (def: name
                       (..can_see
                        (function (_ _)
                          (|> path
                              (text.split_all_with ..default_separator)
                              list.reverse
                              list.head
                              (maybe.default path)))))

                     (def: path
                       (..can_see
                        (function (_ _)
                          path)))

                     (~~ (template [<capability> <name>]
                           [(def: <name>
                              (<capability>
                               (function (_ _)
                                 (let [[_ short] (name_of <name>)]
                                   (\ io.monad wrap (exception.throw ..invalid_operation [(name_of ..File) short]))))))]

                           [..can_query size]
                           [..can_query last_modified]
                           [..can_query can_execute?]

                           [..can_modify modify]
                           ))

                     (def: move
                       (..can_open
                        (function (move destination)
                          (do io.monad
                            [?verdict (os/rename [path destination])]
                            (wrap (if (case ?verdict
                                        (#.Some verdict)
                                        verdict
                                        
                                        #.None
                                        false)
                                    (#try.Success (file destination))
                                    (exception.throw ..cannot_move [destination path])))))))

                     (def: delete
                       (..can_delete
                        (function (delete _)
                          (do io.monad
                            [?verdict (os/remove [path])]
                            (wrap (if (case ?verdict
                                        (#.Some verdict)
                                        verdict
                                        
                                        #.None
                                        false)
                                    (#try.Success [])
                                    (exception.throw ..cannot_delete_file path)))))))
                     ))

               (`` (structure: (directory path)
                     (-> Path (Directory IO))

                     (def: scope
                       (..can_see
                        (function (_ _)
                          path)))

                     (~~ (template [<name>]
                           [(def: <name>
                              (..can_query
                               (function (_ _)
                                 (let [[_ short] (name_of <name>)]
                                   (\ io.monad wrap (exception.throw ..invalid_operation [(name_of ..File) short]))))))]

                           [files]
                           [directories]
                           ))

                     (def: discard
                       (..can_delete
                        (function (discard _)
                          (do io.monad
                            [?verdict (os/remove [path])]
                            (wrap (if (case ?verdict
                                        (#.Some verdict)
                                        verdict
                                        
                                        #.None
                                        false)
                                    (#try.Success [])
                                    (exception.throw ..cannot_discard_directory path)))))))
                     ))

               (def: (default_file path)
                 (-> Path (IO (Try (File IO))))
                 (do {! io.monad}
                   [?file (io/open [path "r"])]
                   (case ?file
                     (#try.Success file)
                     (do !
                       [closed? (LuaFile::close [] file)]
                       (wrap (if closed?
                               (#try.Success (..file path))
                               (exception.throw ..cannot_close_file [path]))))
                     
                     (#try.Failure _)
                     (wrap (exception.throw ..cannot_find_file [path])))))

               (def: (default_create_file path)
                 (-> Path (IO (Try (File IO))))
                 (do {! io.monad}
                   [?file (..default_file path)]
                   (case ?file
                     (#try.Failure _)
                     (do {! io.monad}
                       [?file (io/open [path "w+b"])]
                       (case ?file
                         (#.Some file)
                         (do !
                           [closed? (LuaFile::close [] file)]
                           (wrap (if closed?
                                   (#try.Success (..file path))
                                   (exception.throw ..cannot_close_file [path]))))
                         
                         #.None
                         (wrap (exception.throw ..cannot_create_file [path]))))

                     (#try.Success file)
                     (wrap (exception.throw ..file_already_exists [path])))))

               (`` (structure: #export default
                     (System IO)

                     (def: file (..can_open ..default_file))
                     (def: create_file (..can_open ..default_create_file))

                     (def: directory
                       (let [dummy "lux_lua_dummy_file"]
                         (..can_open
                          (function (directory path)
                            (do {! io.monad}
                              [?file (..default_create_file (format path ..default_separator dummy))]
                              (case ?file
                                (#try.Success file)
                                (do (try.with !)
                                  [_ (!.use (\ file delete) [])]
                                  (wrap (..directory path)))
                                
                                (#try.Failure error)
                                (wrap (if (exception.match? ..file_already_exists error)
                                        (#try.Success (..directory path))
                                        (exception.throw ..cannot_find_directory [path])))))))))

                     (def: create_directory
                       (..can_open
                        (function (create_directory path)
                          (do io.monad
                            [?verdict (os/execute [(format "mkdir " path)])]
                            (wrap (case ?verdict
                                    (#.Some verdict)
                                    (#try.Success (..directory path))
                                    
                                    #.None
                                    (exception.throw ..cannot_create_directory [path])))))))

                     (def: separator
                       ..default_separator)
                     ))
               )

        @.ruby
        (as_is (host.import: Time #as RubyTime
                 (#static at [Frac] RubyTime)
                 
                 (to_f [] Frac))

               (host.import: Stat #as RubyStat
                 (executable? [] Bit)
                 (size Int)
                 (mtime [] RubyTime))

               (host.import: File #as RubyFile
                 (#static SEPARATOR host.String)
                 (#static open [Path host.String] #io #try RubyFile)
                 (#static stat [Path] #io #try RubyStat)
                 (#static delete [Path] #io #try Int)
                 (#static file? [Path] #io #try Bit)
                 (#static directory? [Path] #io #try Bit)
                 (#static utime [RubyTime RubyTime Path] #io #try Int)

                 (read [] #io #try Binary)
                 (write [Binary] #io #try Int)
                 (flush [] #io #try #? Any)
                 (close [] #io #try #? Any))

               (host.import: Dir #as RubyDir
                 (#static open [Path] #io #try RubyDir)
                 
                 (children [] #io #try (Array Path))
                 (close [] #io #try #? Any))

               (host.import: "fileutils" FileUtils #as RubyFileUtils
                 (#static touch [Path] #io #try #? Any)
                 (#static move [Path Path] #io #try #? Any)
                 (#static rmdir [Path] #io #try #? Any)
                 (#static mkdir [Path] #io #try #? Any))

               (def: default_separator
                 Text
                 (..RubyFile::SEPARATOR))

               (`` (structure: (file path)
                     (-> Path (File IO))

                     (~~ (template [<name> <mode>]
                           [(def: <name>
                              (..can_modify
                               (function (<name> data)
                                 (do {! (try.with io.monad)}
                                   [file (RubyFile::open [path <mode>])
                                    data (RubyFile::write [data] file)
                                    _ (RubyFile::flush [] file)
                                    _ (RubyFile::close [] file)]
                                   (wrap [])))))]
                           
                           [over_write  "wb"]
                           [append      "ab"]
                           ))

                     (def: content
                       (..can_query
                        (function (_ _)
                          (do {! (try.with io.monad)}
                            [file (RubyFile::open [path "rb"])
                             data (RubyFile::read [] file)
                             _ (RubyFile::close [] file)]
                            (wrap data)))))

                     (def: name
                       (..can_see
                        (function (_ _)
                          (|> path
                              (text.split_all_with ..default_separator)
                              list.reverse
                              list.head
                              (maybe.default path)))))

                     (def: path
                       (..can_see
                        (function (_ _)
                          path)))

                     (~~ (template [<capability> <name> <pipeline>]
                           [(def: <name>
                              (<capability>
                               (function (_ _)
                                 (do {! (try.with io.monad)}
                                   [stat (: (IO (Try RubyStat))
                                            (RubyFile::stat [path]))]
                                   (wrap (`` (|> stat (: RubyStat) (~~ (template.splice <pipeline>)))))))))]

                           [..can_query size [RubyStat::size .nat]]
                           [..can_query last_modified [(RubyStat::mtime [])
                                                       (RubyTime::to_f [])
                                                       (f.* +1,000.0)
                                                       f.int
                                                       duration.from_millis
                                                       instant.absolute]]
                           [..can_query can_execute? [(RubyStat::executable? [])]]
                           ))

                     (def: modify
                       (..can_modify
                        (function (_ moment)
                          (let [moment (|> moment
                                           instant.relative
                                           duration.to_millis
                                           i.frac
                                           (f./ +1,000.0)
                                           RubyTime::at)]
                            (do {! (try.with io.monad)}
                              [_ (RubyFile::utime [moment moment path])]
                              (wrap []))))))

                     (def: move
                       (..can_open
                        (function (_ destination)
                          (do {! (try.with io.monad)}
                            [_ (RubyFileUtils::move [path destination])]
                            (wrap (file destination))))))

                     (def: delete
                       (..can_delete
                        (function (_ _)
                          (do {! (try.with io.monad)}
                            [_ (RubyFile::delete [path])]
                            (wrap [])))))
                     ))

               (`` (structure: (directory path)
                     (-> Path (Directory IO))

                     (def: scope
                       (..can_see
                        (function (_ _)
                          path)))

                     (~~ (template [<name> <test> <constructor> <capability>]
                           [(def: <name>
                              (..can_query
                               (function (_ _)
                                 (do {! (try.with io.monad)}
                                   [self (RubyDir::open [path])
                                    children (RubyDir::children [] self)
                                    output (loop [input (|> children
                                                            array.to_list
                                                            (list\map (|>> (format path ..default_separator))))
                                                  output (: (List (<capability> IO))
                                                            (list))]
                                             (case input
                                               #.Nil
                                               (wrap output)

                                               (#.Cons head tail)
                                               (do !
                                                 [verdict (<test> head)]
                                                 (if verdict
                                                   (recur tail (#.Cons (<constructor> head) output))
                                                   (recur tail output)))))
                                    _ (RubyDir::close [] self)]
                                   (wrap output)))))]

                           [files RubyFile::file? ..file File]
                           [directories RubyFile::directory? directory Directory]
                           ))

                     (def: discard
                       (..can_delete
                        (function (discard _)
                          (do {! (try.with io.monad)}
                            [_ (RubyFileUtils::rmdir [path])]
                            (wrap [])))))
                     ))

               (`` (structure: #export default
                     (System IO)

                     (~~ (template [<name> <test> <constructor> <exception>]
                           [(def: <name>
                              (..can_open
                               (function (_ path)
                                 (do {! (try.with io.monad)}
                                   [verdict (<test> path)]
                                   (\ io.monad wrap
                                      (if verdict
                                        (#try.Success (<constructor> path))
                                        (exception.throw <exception> [path])))))))]

                           [file RubyFile::file? ..file ..cannot_find_file]
                           [directory RubyFile::directory? ..directory ..cannot_find_directory]
                           ))
                     
                     (def: create_file
                       (..can_open
                        (function (_ path)
                          (do {! (try.with io.monad)}
                            [_ (RubyFileUtils::touch [path])]
                            (wrap (..file path))))))

                     (def: create_directory
                       (..can_open
                        (function (create_directory path)
                          (do {! (try.with io.monad)}
                            [_ (RubyFileUtils::mkdir path)]
                            (wrap (..directory path))))))

                     (def: separator
                       ..default_separator)
                     ))
               )

        @.php
        (as_is (host.import: (FILE_APPEND Int))
               ## https://www.php.net/manual/en/dir.constants.php
               (host.import: (DIRECTORY_SEPARATOR host.String))
               ## https://www.php.net/manual/en/function.pack.php
               ## https://www.php.net/manual/en/function.unpack.php
               (host.import: (unpack [host.String host.String] Binary))
               ## https://www.php.net/manual/en/ref.filesystem.php
               ## https://www.php.net/manual/en/function.file-get-contents.php
               (host.import: (file_get_contents [Path] #io #try host.String))
               ## https://www.php.net/manual/en/function.file-put-contents.php
               (host.import: (file_put_contents [Path host.String Int] #io #try host.Integer))
               (host.import: (filemtime [Path] #io #try host.Integer))
               (host.import: (filesize [Path] #io #try host.Integer))
               (host.import: (is_executable [Path] #io #try host.Boolean))
               (host.import: (touch [Path host.Integer] #io #try host.Boolean))
               (host.import: (rename [Path Path] #io #try host.Boolean))
               (host.import: (unlink [Path] #io #try host.Boolean))

               ## https://www.php.net/manual/en/function.rmdir.php
               (host.import: (rmdir [Path] #io #try host.Boolean))
               ## https://www.php.net/manual/en/function.scandir.php
               (host.import: (scandir [Path] #io #try (Array Path)))
               ## https://www.php.net/manual/en/function.is-file.php
               (host.import: (is_file [Path] #io #try host.Boolean))
               ## https://www.php.net/manual/en/function.is-dir.php
               (host.import: (is_dir [Path] #io #try host.Boolean))
               ## https://www.php.net/manual/en/function.mkdir.php
               (host.import: (mkdir [Path] #io #try host.Boolean))

               (def: byte_array_format "C*")
               (def: default_separator (..DIRECTORY_SEPARATOR))

               (template [<name>]
                 [(exception: #export (<name> {file Path})
                    (exception.report
                     ["Path" file]))]

                 [cannot_write_to_file]
                 )

               (`` (structure: (file path)
                     (-> Path (File IO))

                     (~~ (template [<name> <mode>]
                           [(def: <name>
                              (..can_modify
                               (function (<name> data)
                                 (do {! (try.with io.monad)}
                                   [outcome (..file_put_contents [path ("php pack" ..byte_array_format data) <mode>])]
                                   (if (bit\= false (:coerce Bit outcome))
                                     (\ io.monad wrap (exception.throw ..cannot_write_to_file [path]))
                                     (wrap []))))))]
                           
                           [over_write  +0]
                           [append      (..FILE_APPEND)]
                           ))

                     (def: content
                       (..can_query
                        (function (_ _)
                          (do {! (try.with io.monad)}
                            [data (..file_get_contents [path])]
                            (if (bit\= false (:coerce Bit data))
                              (\ io.monad wrap (exception.throw ..cannot_find_file [path]))
                              (wrap (..unpack [..byte_array_format data])))))))

                     (def: name
                       (..can_see
                        (function (_ _)
                          (|> path
                              (text.split_all_with ..default_separator)
                              list.reverse
                              list.head
                              (maybe.default path)))))

                     (def: path
                       (..can_see
                        (function (_ _)
                          path)))

                     (~~ (template [<capability> <name> <ffi> <pipeline>]
                           [(def: <name>
                              (<capability>
                               (function (_ _)
                                 (do {! (try.with io.monad)}
                                   [value (<ffi> [path])]
                                   (if (bit\= false (:coerce Bit value))
                                     (\ io.monad wrap (exception.throw ..cannot_find_file [path]))
                                     (wrap (`` (|> value (~~ (template.splice <pipeline>))))))))))]

                           [..can_query size ..filesize [.nat]]
                           [..can_query last_modified ..filemtime [(i.* +1,000) duration.from_millis instant.absolute]]
                           ))

                     (def: can_execute?
                       (..can_query
                        (function (_ _)
                          (..is_executable [path]))))

                     (def: modify
                       (..can_modify
                        (function (_ moment)
                          (do {! (try.with io.monad)}
                            [verdict (..touch [path (|> moment instant.relative duration.to_millis (i./ +1,000))])]
                            (if (bit\= false (:coerce Bit verdict))
                              (\ io.monad wrap (exception.throw ..cannot_find_file [path]))
                              (wrap []))))))

                     (def: move
                       (..can_open
                        (function (_ destination)
                          (do {! (try.with io.monad)}
                            [verdict (..rename [path destination])]
                            (if (bit\= false (:coerce Bit verdict))
                              (\ io.monad wrap (exception.throw ..cannot_find_file [path]))
                              (wrap (file destination)))))))

                     (def: delete
                       (..can_delete
                        (function (_ _)
                          (do {! (try.with io.monad)}
                            [verdict (..unlink [path])]
                            (if (bit\= false (:coerce Bit verdict))
                              (\ io.monad wrap (exception.throw ..cannot_find_file [path]))
                              (wrap []))))))
                     ))

               (`` (structure: (directory path)
                     (-> Path (Directory IO))

                     (def: scope
                       (..can_see
                        (function (_ _)
                          path)))

                     (~~ (template [<name> <test> <constructor> <capability>]
                           [(def: <name>
                              (..can_query
                               (function (_ _)
                                 (do {! (try.with io.monad)}
                                   [children (..scandir [path])]
                                   (loop [input (|> children
                                                    array.to_list
                                                    (list.filter (function (_ child)
                                                                   (not (or (text\= "." child)
                                                                            (text\= ".." child))))))
                                          output (: (List (<capability> IO))
                                                    (list))]
                                     (case input
                                       #.Nil
                                       (wrap output)

                                       (#.Cons head tail)
                                       (do !
                                         [verdict (<test> head)]
                                         (if verdict
                                           (recur tail (#.Cons (<constructor> head) output))
                                           (recur tail output)))))))))]

                           [files ..is_file ..file File]
                           [directories ..is_dir directory Directory]
                           ))

                     (def: discard
                       (..can_delete
                        (function (_ _)
                          (do {! (try.with io.monad)}
                            [verdict (..rmdir [path])]
                            (if (bit\= false (:coerce Bit verdict))
                              (\ io.monad wrap (exception.throw ..cannot_find_directory [path]))
                              (wrap []))))))
                     ))

               (`` (structure: #export default
                     (System IO)

                     (~~ (template [<name> <test> <constructor> <exception>]
                           [(def: <name>
                              (..can_open
                               (function (_ path)
                                 (do {! (try.with io.monad)}
                                   [verdict (<test> path)]
                                   (\ io.monad wrap
                                      (if verdict
                                        (#try.Success (<constructor> path))
                                        (exception.throw <exception> [path])))))))]

                           [file ..is_file ..file ..cannot_find_file]
                           [directory ..is_dir ..directory ..cannot_find_directory]
                           ))

                     (def: create_file
                       (..can_open
                        (function (_ path)
                          (do {! (try.with io.monad)}
                            [verdict (..touch [path (|> instant.now io.run instant.relative duration.to_millis (i./ +1,000))])]
                            (\ io.monad wrap
                               (if verdict
                                 (#try.Success (..file path))
                                 (exception.throw ..cannot_create_file [path])))))))
                     
                     (def: create_directory
                       (..can_open
                        (function (_ path)
                          (do {! (try.with io.monad)}
                            [verdict (..mkdir path)]
                            (\ io.monad wrap
                               (if verdict
                                 (#try.Success (..directory path))
                                 (exception.throw ..cannot_create_directory [path])))))))

                     (def: separator
                       ..default_separator)
                     ))
               )

        @.scheme
        (as_is)
        }))

(template [<get> <signature> <create> <find> <exception>]
  [(def: #export (<get> monad system path)
     (All [!] (-> (Monad !) (System !) Path (! (Try (<signature> !)))))
     (do monad
       [outcome (!.use (\ system <find>) path)]
       (case outcome
         (#try.Success file)
         (wrap (#try.Success file))
         
         (#try.Failure error)
         (if (exception.match? <exception> error)
           (!.use (\ system <create>) path)
           (wrap (#try.Failure error))))))]

  [get_file      File      create_file      file      ..cannot_find_file]
  [get_directory Directory create_directory directory ..cannot_find_directory]
  )

(template [<predicate> <capability>]
  [(def: #export (<predicate> monad system path)
     (All [!] (-> (Monad !) (System !) Path (! Bit)))
     (do monad
       [?file (!.use (\ system <capability>) path)]
       (case ?file
         (#try.Success file)
         (wrap true)

         (#try.Failure _)
         (wrap false))))]

  [file_exists? file]
  [directory_exists? directory]
  )

(def: #export (exists? monad system path)
  (All [!] (-> (Monad !) (System !) Path (! Bit)))
  (do monad
    [verdict (..file_exists? monad system path)]
    (if verdict
      (wrap verdict)
      (..directory_exists? monad system path))))

(type: Mock_File
  {#mock_last_modified Instant
   #mock_can_execute Bit
   #mock_content Binary})

(type: #rec Mock
  (Dictionary Text (Either Mock_File Mock)))

(def: empty_mock
  Mock
  (dictionary.new text.hash))

(def: (create_mock_file! separator path now mock)
  (-> Text Path Instant Mock (Try [Text Mock]))
  (loop [directory mock
         trail (text.split_all_with separator path)]
    (case trail
      (#.Cons head tail)
      (case (dictionary.get head directory)
        #.None
        (case tail
          #.Nil
          (#try.Success [head (dictionary.put head
                                              (#.Left {#mock_last_modified now
                                                       #mock_can_execute false
                                                       #mock_content (binary.create 0)})
                                              directory)])

          (#.Cons _)
          (exception.throw ..cannot_create_file [path]))
        
        (#.Some node)
        (case [node tail]
          [(#.Right sub_directory) (#.Cons _)]
          (do try.monad
            [[file_name sub_directory] (recur sub_directory tail)]
            (wrap [file_name (dictionary.put head (#.Right sub_directory) directory)]))

          _
          (exception.throw ..cannot_create_file [path])))

      #.Nil
      (exception.throw ..cannot_create_file [path]))))

(def: (retrieve_mock_file! separator path mock)
  (-> Text Path Mock (Try [Text Mock_File]))
  (loop [directory mock
         trail (text.split_all_with separator path)]
    (case trail
      (#.Cons head tail)
      (case (dictionary.get head directory)
        #.None
        (exception.throw ..cannot_find_file [path])
        
        (#.Some node)
        (case [node tail]
          [(#.Left file) #.Nil]
          (#try.Success [head file])

          [(#.Right sub_directory) (#.Cons _)]
          (recur sub_directory tail)

          _
          (exception.throw ..cannot_find_file [path])))

      #.Nil
      (exception.throw ..not_a_file [path]))))

(def: (update_mock_file! separator path now content mock)
  (-> Text Path Instant Binary Mock (Try Mock))
  (loop [directory mock
         trail (text.split_all_with separator path)]
    (case trail
      (#.Cons head tail)
      (case (dictionary.get head directory)
        #.None
        (exception.throw ..cannot_find_file [path])
        
        (#.Some node)
        (case [node tail]
          [(#.Left file) #.Nil]
          (#try.Success (dictionary.put head
                                        (#.Left (|> file
                                                    (set@ #mock_last_modified now)
                                                    (set@ #mock_content content)))
                                        directory))

          [(#.Right sub_directory) (#.Cons _)]
          (do try.monad
            [sub_directory (recur sub_directory tail)]
            (wrap (dictionary.put head (#.Right sub_directory) directory)))

          _
          (exception.throw ..cannot_find_file [path])))

      #.Nil
      (exception.throw ..cannot_find_file [path]))))

(def: (delete_mock_file! separator path mock)
  (-> Text Path Mock (Try Mock))
  (loop [directory mock
         trail (text.split_all_with separator path)]
    (case trail
      (#.Cons head tail)
      (case (dictionary.get head directory)
        #.None
        (exception.throw ..cannot_delete_file [path])
        
        (#.Some node)
        (case [node tail]
          [(#.Left file) #.Nil]
          (#try.Success (dictionary.remove head directory))

          [(#.Right sub_directory) (#.Cons _)]
          (do try.monad
            [sub_directory (recur sub_directory tail)]
            (wrap (dictionary.put head (#.Right sub_directory) directory)))

          _
          (exception.throw ..cannot_delete_file [path])))

      #.Nil
      (exception.throw ..cannot_delete_file [path]))))

(def: (try_update! transform var)
  (All [a] (-> (-> a (Try a)) (Var a) (STM (Try Any))))
  (do {! stm.monad}
    [|var| (stm.read var)]
    (case (transform |var|)
      (#try.Success |var|)
      (do !
        [_ (stm.write |var| var)]
        (wrap (#try.Success [])))
      
      (#try.Failure error)
      (wrap (#try.Failure error)))))

(def: (mock_file separator name path store)
  (-> Text Text Path (Var Mock) (File Promise))
  (structure
   (def: name
     (..can_see
      (function.constant name)))

   (def: path
     (..can_see
      (function.constant path)))
   
   (def: size
     (..can_query
      (function (_ _)
        (stm.commit
         (do stm.monad
           [|store| (stm.read store)]
           (wrap (do try.monad
                   [[name file] (..retrieve_mock_file! separator path |store|)]
                   (wrap (binary.size (get@ #mock_content file))))))))))

   (def: content
     (..can_query
      (function (_ _)
        (stm.commit
         (do stm.monad
           [|store| (stm.read store)]
           (wrap (do try.monad
                   [[name file] (..retrieve_mock_file! separator path |store|)]
                   (wrap (get@ #mock_content file)))))))))

   (def: last_modified
     (..can_query
      (function (_ _)
        (stm.commit
         (do stm.monad
           [|store| (stm.read store)]
           (wrap (do try.monad
                   [[name file] (..retrieve_mock_file! separator path |store|)]
                   (wrap (get@ #mock_last_modified file)))))))))

   (def: can_execute?
     (..can_query
      (function (_ _)
        (stm.commit
         (do stm.monad
           [|store| (stm.read store)]
           (wrap (do try.monad
                   [[name file] (..retrieve_mock_file! separator path |store|)]
                   (wrap (get@ #mock_can_execute file)))))))))

   (def: over_write
     (..can_modify
      (function (_ content)
        (do promise.monad
          [now (promise.future instant.now)]
          (stm.commit
           (..try_update! (..update_mock_file! separator path now content) store))))))

   (def: append
     (..can_modify
      (function (_ content)
        (do promise.monad
          [now (promise.future instant.now)]
          (stm.commit
           (..try_update! (function (_ |store|)
                            (do try.monad
                              [[name file] (..retrieve_mock_file! separator path |store|)]
                              (..update_mock_file! separator path now
                                                   (\ binary.monoid compose
                                                      (get@ #mock_content file)
                                                      content)
                                                   |store|)))
                          store))))))

   (def: modify
     (..can_modify
      (function (_ now)
        (stm.commit
         (..try_update! (function (_ |store|)
                          (do try.monad
                            [[name file] (..retrieve_mock_file! separator path |store|)]
                            (..update_mock_file! separator path now (get@ #mock_content file) |store|)))
                        store)))))

   (def: delete
     (..can_delete
      (function (_ _)
        (stm.commit
         (..try_update! (..delete_mock_file! separator path) store)))))

   (def: move
     (..can_open
      (function (_ path)
        (stm.commit
         (do {! stm.monad}
           [|store| (stm.read store)]
           (case (do try.monad
                   [[name file] (..retrieve_mock_file! separator path |store|)
                    |store| (..delete_mock_file! separator path |store|)
                    [name |store|] (..create_mock_file! separator path (get@ #mock_last_modified file) |store|)
                    |store| (..update_mock_file! separator path (get@ #mock_last_modified file) (get@ #mock_content file) |store|)]
                   (wrap [|store| (mock_file separator name path store)]))
             (#try.Success [|store| moved])
             (do !
               [_ (stm.write |store| store)]
               (wrap (#try.Success moved)))
             
             (#try.Failure error)
             (wrap (#try.Failure error))))))))
   ))

(def: (create_mock_directory! separator path mock)
  (-> Text Path Mock (Try Mock))
  (loop [directory mock
         trail (text.split_all_with separator path)]
    (case trail
      (#.Cons head tail)
      (case (dictionary.get head directory)
        #.None
        (case tail
          #.Nil
          (#try.Success (dictionary.put head (#.Right ..empty_mock) directory))

          (#.Cons _)
          (exception.throw ..cannot_create_directory [path]))
        
        (#.Some node)
        (case [node tail]
          [(#.Right sub_directory) (#.Cons _)]
          (do try.monad
            [sub_directory (recur sub_directory tail)]
            (wrap (dictionary.put head (#.Right sub_directory) directory)))

          _
          (exception.throw ..cannot_create_directory [path])))

      #.Nil
      (exception.throw ..cannot_create_directory [path]))))

(def: (retrieve_mock_directory! separator path mock)
  (-> Text Path Mock (Try Mock))
  (loop [directory mock
         trail (text.split_all_with separator path)]
    (case trail
      (#.Cons head tail)
      (case (dictionary.get head directory)
        #.None
        (exception.throw ..cannot_find_directory [path])
        
        (#.Some node)
        (case [node tail]
          [(#.Right sub_directory) #.Nil]
          (#try.Success sub_directory)

          [(#.Right sub_directory) (#.Cons _)]
          (recur sub_directory tail)

          _
          (exception.throw ..cannot_find_directory [path])))

      #.Nil
      (#try.Success directory))))

(def: (delete_mock_directory! separator path mock)
  (-> Text Path Mock (Try Mock))
  (loop [directory mock
         trail (text.split_all_with separator path)]
    (case trail
      (#.Cons head tail)
      (case (dictionary.get head directory)
        #.None
        (exception.throw ..cannot_discard_directory [path])
        
        (#.Some node)
        (case [node tail]
          [(#.Right directory) #.Nil]
          (if (dictionary.empty? directory)
            (#try.Success (dictionary.remove head directory))
            (exception.throw ..cannot_discard_directory [path]))

          [(#.Right sub_directory) (#.Cons _)]
          (do try.monad
            [sub_directory (recur sub_directory tail)]
            (wrap (dictionary.put head (#.Right sub_directory) directory)))

          _
          (exception.throw ..cannot_discard_directory [path])))

      #.Nil
      (exception.throw ..cannot_discard_directory [path]))))

(def: (mock_directory separator path store)
  (-> Text Path (Var Mock) (Directory Promise))
  (structure
   (def: scope
     (..can_see
      (function (_ _)
        path)))
   
   (def: files
     (..can_query
      (function (_ _)
        (stm.commit
         (do stm.monad
           [|store| (stm.read store)]
           (wrap (do try.monad
                   [directory (..retrieve_mock_directory! separator path |store|)]
                   (wrap (|> directory
                             dictionary.entries
                             (list.all (function (_ [node_name node])
                                         (case node
                                           (#.Left file)
                                           (#.Some (..mock_file separator
                                                                node_name
                                                                (format path separator node_name)
                                                                store))
                                           
                                           (#.Right directory)
                                           #.None))))))))))))

   (def: directories
     (..can_query
      (function (_ _)
        (stm.commit
         (do stm.monad
           [|store| (stm.read store)]
           (wrap (do try.monad
                   [directory (..retrieve_mock_directory! separator path |store|)]
                   (wrap (|> directory
                             dictionary.entries
                             (list.all (function (_ [node_name node])
                                         (case node
                                           (#.Left file)
                                           #.None
                                           
                                           (#.Right directory)
                                           (#.Some (mock_directory separator
                                                                   (format path separator node_name)
                                                                   store))))))))))))))

   (def: discard
     (..can_delete
      (function (_ _)
        (stm.commit
         (do {! stm.monad}
           [|store| (stm.read store)]
           (case (..delete_mock_directory! separator path |store|)
             (#try.Success |store|)
             (do !
               [_ (stm.write |store| store)]
               (wrap (#try.Success [])))
             
             (#try.Failure error)
             (wrap (#try.Failure error))))))))
   ))

(def: #export (mock separator)
  (-> Text (System Promise))
  (let [store (stm.var ..empty_mock)]
    (structure
     (def: separator separator)

     (def: file
       (..can_open
        (function (_ path)
          (stm.commit
           (do stm.monad
             [|store| (stm.read store)]
             (wrap (do try.monad
                     [[name file] (..retrieve_mock_file! separator path |store|)]
                     (wrap (..mock_file separator name path store)))))))))

     (def: create_file
       (..can_open
        (function (_ path)
          (do promise.monad
            [now (promise.future instant.now)]
            (stm.commit
             (do {! stm.monad}
               [|store| (stm.read store)]
               (case (..create_mock_file! separator path now |store|)
                 (#try.Success [name |store|])
                 (do !
                   [_ (stm.write |store| store)]
                   (wrap (#try.Success (..mock_file separator name path store))))
                 
                 (#try.Failure error)
                 (wrap (#try.Failure error)))))))))

     (def: directory
       (..can_open
        (function (_ path)
          (stm.commit
           (do stm.monad
             [|store| (stm.read store)]
             (wrap (do try.monad
                     [directory (..retrieve_mock_directory! separator path |store|)]
                     (wrap (..mock_directory separator path store)))))))))

     (def: create_directory
       (..can_open
        (function (_ path)
          (stm.commit
           (do {! stm.monad}
             [|store| (stm.read store)]
             (case (..create_mock_directory! separator path |store|)
               (#try.Success |store|)
               (do !
                 [_ (stm.write |store| store)]
                 (wrap (#try.Success (..mock_directory separator path store))))
               
               (#try.Failure error)
               (wrap (#try.Failure error))))))))
     )))

(def: #export (make_directories monad system path)
  (All [!] (-> (Monad !) (System !) Path (! (Try Path))))
  (let [rooted? (text.starts_with? (\ system separator) path)
        segments (text.split_all_with (\ system separator) path)]
    (case (if rooted?
            (list.drop 1 segments)
            segments)
      #.Nil
      (\ monad wrap (exception.throw ..cannot_create_directory [path]))

      (#.Cons head tail)
      (loop [current (if rooted?
                       (format (\ system separator) head)
                       head)
             next tail]
        (do monad
          [? (..get_directory monad system current)]
          (case ?
            (#try.Success _)
            (case next
              #.Nil
              (wrap (#try.Success current))
              
              (#.Cons head tail)
              (recur (format current (\ system separator) head)
                     tail))
            
            (#try.Failure error)
            (wrap (#try.Failure error))))))))

(def: #export (parent system path)
  (All [!] (-> (System !) Path Path))
  (let [/ (\ system separator)]
    (|> path
        (text.split_all_with /)
        list.inits
        (maybe.default (list))
        (text.join_with /))))
