(.module:
  [lux (#- Type type int char)
   ["lux-." type ("#@." equivalence)]
   [abstract
    ["." monad (#+ Monad do)]
    ["." enum]]
   [control
    ["." function]
    ["." io]
    ["." try (#+ Try)]
    ["<>" parser ("#@." monad)
     ["<c>" code (#+ Parser)]]]
   [data
    ["." maybe]
    ["." product]
    ["." bit ("#@." codec)]
    number
    ["." text ("#@." equivalence monoid)
     ["%" format (#+ format)]]
    [collection
     ["." array]
     ["." list ("#@." monad fold monoid)]
     ["." dictionary (#+ Dictionary)]]]
   ["." macro (#+ with-gensyms)
    [syntax (#+ syntax:)]
    ["." code]
    ["." template]]
   [target
    [jvm
     [encoding
      ["." name (#+ External)]]
     ["." type (#+ Type Argument Typed)
      ["." category (#+ Void Value Return Method Primitive Object Class Array Var Parameter)]
      ["." box]
      ["." signature]
      ["." reflection]
      ["." parser]]]]])

(type: Variable Text)

(def: signature (|>> type.signature signature.signature))
(def: reflection (|>> type.reflection reflection.reflection))

(template [<name> <class>]
  [(def: #export <name> .Type (#.Primitive <class> #.Nil))]

  [Boolean   box.boolean]
  [Byte      box.byte]
  [Short     box.short]
  [Integer   box.int]
  [Long      box.long]
  [Float     box.float]
  [Double    box.double]
  [Character box.char]
  )

(template [<name> <class>]
  [(def: #export <name> .Type (#.Primitive (reflection.reflection <class>) #.Nil))]

  ## Primitives
  [boolean   reflection.boolean]
  [byte      reflection.byte]
  [short     reflection.short]
  [int       reflection.int]
  [long      reflection.long]
  [float     reflection.float]
  [double    reflection.double]
  [char      reflection.char]
  )

(def: (get-static-field class field)
  (-> Text Text Code)
  (` ("jvm member get static"
      (~ (code.text class))
      (~ (code.text field)))))

(def: (get-virtual-field class field object)
  (-> Text Text Code Code)
  (` ("jvm member get virtual"
      (~ (code.text class))
      (~ (code.text field))
      (~ object))))

(def: boxes
  (Dictionary (Type Value) Text)
  (|> (list [type.boolean box.boolean]
            [type.byte    box.byte]
            [type.short   box.short]
            [type.int     box.int]
            [type.long    box.long]
            [type.float   box.float]
            [type.double  box.double]
            [type.char    box.char])
      (dictionary.from-list type.hash)))

(template [<name> <pre> <post>]
  [(def: (<name> unboxed boxed raw)
     (-> (Type Value) Text Code Code)
     (let [unboxed (..reflection unboxed)]
       (` (|> (~ raw)
              (: (primitive (~ (code.text <pre>))))
              "jvm object cast"
              (: (primitive (~ (code.text <post>))))))))]

  [unbox boxed unboxed]
  [box unboxed boxed]
  )

(template [<name> <op> <from> <to>]
  [(template: #export (<name> value)
     {#.doc (doc "Type converter."
                 (: <to>
                    (<name> (: <from> foo))))}
     (|> value
         (: <from>)
         "jvm object cast"
         <op>
         "jvm object cast"
         (: <to>)))]

  [byte-to-long    "jvm conversion byte-to-long"    ..Byte      ..Long]

  [short-to-long   "jvm conversion short-to-long"   ..Short     ..Long]
  
  [double-to-int   "jvm conversion double-to-int"   ..Double    ..Integer]
  [double-to-long  "jvm conversion double-to-long"  ..Double    ..Long]
  [double-to-float "jvm conversion double-to-float" ..Double    ..Float]

  [float-to-int    "jvm conversion float-to-int"    ..Float     ..Integer]
  [float-to-long   "jvm conversion float-to-long"   ..Float     ..Long]
  [float-to-double "jvm conversion float-to-double" ..Float     ..Double]
  
  [int-to-byte     "jvm conversion int-to-byte"     ..Integer   ..Byte]
  [int-to-short    "jvm conversion int-to-short"    ..Integer   ..Short]
  [int-to-long     "jvm conversion int-to-long"     ..Integer   ..Long]
  [int-to-float    "jvm conversion int-to-float"    ..Integer   ..Float]
  [int-to-double   "jvm conversion int-to-double"   ..Integer   ..Double]
  [int-to-char     "jvm conversion int-to-char"     ..Integer   ..Character]

  [long-to-byte    "jvm conversion long-to-byte"    ..Long      ..Byte]
  [long-to-short   "jvm conversion long-to-short"   ..Long      ..Short]
  [long-to-int     "jvm conversion long-to-int"     ..Long      ..Integer]
  [long-to-float   "jvm conversion long-to-float"   ..Long      ..Float]
  [long-to-double  "jvm conversion long-to-double"  ..Long      ..Double]

  [char-to-byte    "jvm conversion char-to-byte"    ..Character ..Byte]
  [char-to-short   "jvm conversion char-to-short"   ..Character ..Short]
  [char-to-int     "jvm conversion char-to-int"     ..Character ..Integer]
  [char-to-long    "jvm conversion char-to-long"    ..Character ..Long]
  )

(def: constructor-method-name "<init>")
(def: member-separator "::")

(type: Primitive-Mode
  #ManualPrM
  #AutoPrM)

(type: Privacy
  #PublicP
  #PrivateP
  #ProtectedP
  #DefaultP)

(type: StateModifier
  #VolatileSM
  #FinalSM
  #DefaultSM)

(type: InheritanceModifier
  #FinalIM
  #AbstractIM
  #DefaultIM)

(type: Class-Kind
  #Class
  #Interface)

(type: Class-Declaration
  {#class-name   Text
   #class-params (List (Type Var))})

(type: StackFrame (primitive "java/lang/StackTraceElement"))
(type: StackTrace (array.Array StackFrame))

(type: AnnotationParam
  [Text Code])

(type: Annotation
  {#ann-name   Text
   #ann-params (List AnnotationParam)})

(type: Member-Declaration
  {#member-name Text
   #member-privacy Privacy
   #member-anns (List Annotation)})

(type: FieldDecl
  (#ConstantField Type Code)
  (#VariableField StateModifier Type))

(type: MethodDecl
  {#method-tvars  (List Variable)
   #method-inputs (List Type)
   #method-output Return
   #method-exs    (List Class)})

(type: Method-Definition
  (#ConstructorMethod [Bit
                       (List Variable)
                       Text
                       (List Argument)
                       (List (Typed Code))
                       Code
                       (List Class)])
  (#VirtualMethod [Bit
                   Bit
                   (List Variable)
                   Text
                   (List Argument)
                   Return
                   Code
                   (List Class)])
  (#OverridenMethod [Bit
                     Class-Declaration
                     (List Variable)
                     Text
                     (List Argument)
                     Return
                     Code
                     (List Class)])
  (#StaticMethod [Bit
                  (List Variable)
                  (List Argument)
                  Return
                  Code
                  (List Class)])
  (#AbstractMethod [(List Variable)
                    (List Argument)
                    Return
                    (List Class)])
  (#NativeMethod [(List Variable)
                  (List Argument)
                  Return
                  (List Class)]))

(type: Partial-Call
  {#pc-method Name
   #pc-args   (List Code)})

(type: ImportMethodKind
  #StaticIMK
  #VirtualIMK)

(type: ImportMethodCommons
  {#import-member-mode   Primitive-Mode
   #import-member-alias  Text
   #import-member-kind   ImportMethodKind
   #import-member-tvars  (List Variable)
   #import-member-args   (List [Bit Type])
   #import-member-maybe? Bit
   #import-member-try?   Bit
   #import-member-io?    Bit})

(type: ImportConstructorDecl
  {})

(type: ImportMethodDecl
  {#import-method-name    Text
   #import-method-return  Return})

(type: ImportFieldDecl
  {#import-field-mode    Primitive-Mode
   #import-field-name    Text
   #import-field-static? Bit
   #import-field-maybe?  Bit
   #import-field-setter? Bit
   #import-field-type    Type})

(type: Import-Member-Declaration
  (#EnumDecl        (List Text))
  (#ConstructorDecl [ImportMethodCommons ImportConstructorDecl])
  (#MethodDecl      [ImportMethodCommons ImportMethodDecl])
  (#FieldAccessDecl ImportFieldDecl))

(type: Class-Imports
  (List [Text Text]))

(def: (short-class-name name)
  (-> Text Text)
  (case (list.reverse (text.split-all-with name.internal-separator name))
    (#.Cons short-name _)
    short-name

    #.Nil
    name))

(def: (primitive-type mode type)
  (-> Primitive-Mode (Type Primitive) Code)
  (case mode
    #ManualPrM
    (cond (:: type.equivalence = type.boolean type) (` ..Boolean)
          (:: type.equivalence = type.byte type) (` ..Byte)
          (:: type.equivalence = type.short type) (` ..Short)
          (:: type.equivalence = type.int type) (` ..Integer)
          (:: type.equivalence = type.long type) (` ..Long)
          (:: type.equivalence = type.float type) (` ..Float)
          (:: type.equivalence = type.double type) (` ..Double)
          (:: type.equivalence = type.char type) (` ..Character)
          ## else
          (undefined))
    
    #AutoPrM
    (cond (:: type.equivalence = type.boolean type)
          (` .Bit)
          
          (or (:: type.equivalence = type.short type)
              (:: type.equivalence = type.byte type)
              (:: type.equivalence = type.int type)
              (:: type.equivalence = type.long type))
          (` .Int)
          
          (or (:: type.equivalence = type.float type)
              (:: type.equivalence = type.double type))
          (` .Frac)

          (:: type.equivalence = type.char type)
          (` .Nat)

          ## else
          (undefined))))

(def: (parameter-type type)
  (-> (Type Parameter) Code)
  (`` (<| (~~ (template [<when> <binding> <then>]
                [(case (<when> type)
                   (#.Some <binding>)
                   <then>

                   #.None)]

                [parser.var? name (code.identifier ["" name])]
                [parser.wildcard? bound (` .Any)]
                [parser.lower? bound (` .Any)]
                [parser.upper? bound (parameter-type bound)]
                [parser.class? [name parameters]
                 (` (.primitive (~ (code.text name))
                                [(~+ (list@map parameter-type parameters))]))]))
          ## else
          (undefined)
          )))

(def: (value-type mode type)
  (-> Primitive-Mode (Type Value) Code)
  (`` (<| (~~ (template [<when> <binding> <then>]
                [(case (<when> type)
                   (#.Some <binding>)
                   <then>

                   #.None)]

                [parser.parameter? type (parameter-type type)]
                [parser.primitive? type (primitive-type mode type)]
                [parser.array? elementT (case (parser.primitive? elementT)
                                          (#.Some elementT)
                                          (` (#.Primitive (~ (code.text (..reflection (type.array elementT)))) #.Nil))
                                          
                                          #.None
                                          (` (#.Primitive (~ (code.text array.type-name))
                                                          (#.Cons (~ (value-type mode elementT)) #.Nil))))]))
          (undefined)
          )))

(def: (declaration-type$ (^slots [#class-name #class-params]))
  (-> Class-Declaration Code)
  (` (primitive (~ (code.text class-name))
                [(~+ (list@map code.local-identifier class-params))])))

(def: empty-imports
  Class-Imports
  (list))

(def: (get-import name imports)
  (-> Text Class-Imports (Maybe Text))
  (:: maybe.functor map product.right
      (list.find (|>> product.left (text@= name))
                 imports)))

(def: (add-import short+full imports)
  (-> [Text Text] Class-Imports Class-Imports)
  (#.Cons short+full imports))

(def: (class-imports compiler)
  (-> Lux Class-Imports)
  (case (macro.run compiler
                   (: (Meta Class-Imports)
                      (do macro.monad
                        [current-module macro.current-module-name
                         definitions (macro.definitions current-module)]
                        (wrap (list@fold (: (-> [Text Global] Class-Imports Class-Imports)
                                            (function (_ [short-name constant] imports)
                                              (case constant
                                                (#.Left _)
                                                imports
                                                
                                                (#.Right [_ _ meta _])
                                                (case (macro.get-text-ann (name-of #..jvm-class) meta)
                                                  (#.Some full-class-name)
                                                  (add-import [short-name full-class-name] imports)

                                                  _
                                                  imports))))
                                         empty-imports
                                         definitions)))))
    (#.Left _)        (list)
    (#.Right imports) imports))

(def: (qualify imports name)
  (-> Class-Imports Text Text)
  (|> imports (get-import name) (maybe.default name)))

(def: (make-get-const-parser class-name field-name)
  (-> Text Text (Parser Code))
  (do <>.monad
    [#let [dotted-name (format "::" field-name)]
     _ (<c>.this! (code.identifier ["" dotted-name]))]
    (wrap (get-static-field class-name field-name))))

(def: (make-get-var-parser class-name field-name)
  (-> Text Text (Parser Code))
  (do <>.monad
    [#let [dotted-name (format "::" field-name)]
     _ (<c>.this! (code.identifier ["" dotted-name]))]
    (wrap (get-virtual-field class-name field-name (' _jvm_this)))))

(def: (make-put-var-parser class-name field-name)
  (-> Text Text (Parser Code))
  (do <>.monad
    [#let [dotted-name (format "::" field-name)]
     [_ _ value] (: (Parser [Any Any Code])
                    (<c>.form ($_ <>.and (<c>.this! (' :=)) (<c>.this! (code.identifier ["" dotted-name])) <c>.any)))]
    (wrap (`' ((~ (code.text (format "jvm putfield" ":" class-name ":" field-name))) _jvm_this (~ value))))))

(def: (pre-walk-replace f input)
  (-> (-> Code Code) Code Code)
  (case (f input)
    (^template [<tag>]
      [meta (<tag> parts)]
      [meta (<tag> (list@map (pre-walk-replace f) parts))])
    ([#.Form]
     [#.Tuple])
    
    [meta (#.Record pairs)]
    [meta (#.Record (list@map (: (-> [Code Code] [Code Code])
                                 (function (_ [key val])
                                   [(pre-walk-replace f key) (pre-walk-replace f val)]))
                              pairs))]
    
    ast'
    ast'))

(def: (parser->replacer p ast)
  (-> (Parser Code) (-> Code Code))
  (case (<>.run p (list ast))
    (#.Right [#.Nil ast'])
    ast'

    _
    ast
    ))

(def: (field->parser class-name [[field-name _ _] field])
  (-> Text [Member-Declaration FieldDecl] (Parser Code))
  (case field
    (#ConstantField _)
    (make-get-const-parser class-name field-name)
    
    (#VariableField _)
    (<>.either (make-get-var-parser class-name field-name)
               (make-put-var-parser class-name field-name))))

(def: (decorate-input [class value])
  (-> [Text Code] Code)
  (` [(~ (code.text class)) (~ value)]))

(def: (make-constructor-parser class-name arguments)
  (-> Text (List Argument) (Parser Code))
  (do <>.monad
    [args (: (Parser (List Code))
             (<c>.form (<>.after (<c>.this! (' ::new!))
                                 (<c>.tuple (<>.exactly (list.size arguments) <c>.any)))))]
    (wrap (` ("jvm member invoke constructor" (~ (code.text class-name))
              (~+ (|> args
                      (list.zip2 (list@map (|>> product.right ..signature) arguments))
                      (list@map ..decorate-input))))))))

(def: (make-static-method-parser class-name method-name arguments)
  (-> Text Text (List Argument) (Parser Code))
  (do <>.monad
    [#let [dotted-name (format "::" method-name "!")]
     args (: (Parser (List Code))
             (<c>.form (<>.after (<c>.this! (code.identifier ["" dotted-name]))
                                 (<c>.tuple (<>.exactly (list.size arguments) <c>.any)))))]
    (wrap (` ("jvm member invoke static" (~ (code.text class-name)) (~ (code.text method-name))
              (~+ (|> args
                      (list.zip2 (list@map (|>> product.right ..signature) arguments))
                      (list@map ..decorate-input))))))))

(template [<name> <jvm-op>]
  [(def: (<name> class-name method-name arguments)
     (-> Text Text (List Argument) (Parser Code))
     (do <>.monad
       [#let [dotted-name (format "::" method-name "!")]
        args (: (Parser (List Code))
                (<c>.form (<>.after (<c>.this! (code.identifier ["" dotted-name]))
                                    (<c>.tuple (<>.exactly (list.size arguments) <c>.any)))))]
       (wrap (` (<jvm-op> (~ (code.text class-name)) (~ (code.text method-name))
                          (~' _jvm_this)
                          (~+ (|> args
                                  (list.zip2 (list@map (|>> product.right ..signature) arguments))
                                  (list@map ..decorate-input))))))))]

  [make-special-method-parser "jvm member invoke special"]
  [make-virtual-method-parser "jvm member invoke virtual"]
  )

(def: (method->parser class-name [[method-name _ _] meth-def])
  (-> Text [Member-Declaration Method-Definition] (Parser Code))
  (case meth-def
    (#ConstructorMethod strict? type-vars self-name args constructor-args return-expr exs)
    (make-constructor-parser class-name args)
    
    (#StaticMethod strict? type-vars args return-type return-expr exs)
    (make-static-method-parser class-name method-name args)
    
    (^or (#VirtualMethod final? strict? type-vars self-name args return-type return-expr exs)
         (#OverridenMethod strict? owner-class type-vars self-name args return-type return-expr exs))
    (make-special-method-parser class-name method-name args)

    (#AbstractMethod type-vars args return-type exs)
    (make-virtual-method-parser class-name method-name args)

    (#NativeMethod type-vars args return-type exs)
    (make-virtual-method-parser class-name method-name args)))

(def: (full-class-name^ imports)
  (-> Class-Imports (Parser Text))
  (do <>.monad
    [name <c>.local-identifier]
    (wrap (qualify imports name))))

(def: privacy-modifier^
  (Parser Privacy)
  (let [(^open ".") <>.monad]
    ($_ <>.or
        (<c>.this! (' #public))
        (<c>.this! (' #private))
        (<c>.this! (' #protected))
        (wrap []))))

(def: inheritance-modifier^
  (Parser InheritanceModifier)
  (let [(^open ".") <>.monad]
    ($_ <>.or
        (<c>.this! (' #final))
        (<c>.this! (' #abstract))
        (wrap []))))

(def: (assert-valid-class-name type-vars name)
  (-> (List Variable) Text (Parser Any))
  (do <>.monad
    [_ (<>.assert "Names in class declarations cannot contain periods."
                  (not (text.contains? name.external-separator name)))]
    (<>.assert (format name " cannot be a type-var!")
               (not (list.member? text.equivalence type-vars name)))))

(def: (valid-class-name imports type-vars)
  (-> Class-Imports (List Variable) (Parser Text))
  (do <>.monad
    [name (full-class-name^ imports)
     _ (assert-valid-class-name type-vars name)]
    (wrap name)))

(def: (class^' parameter^ imports type-vars)
  (-> (-> Class-Imports (List Variable) (Parser (Type Parameter)))
      (-> Class-Imports (List Variable) (Parser (Type Class))))
  (do <>.monad
    [[name parameters] (: (Parser [External (List (Type Parameter))])
                          ($_ <>.either
                              (<>.and (valid-class-name imports type-vars)
                                      (<>@wrap (list)))
                              (<c>.form (<>.and (full-class-name^ imports)
                                                (<>.some (parameter^ imports type-vars))))))]
    (wrap (type.class name parameters))))

(def: (variable^ imports type-vars)
  (-> Class-Imports (List Variable) (Parser (Type Parameter)))
  (do <>.monad
    [name (full-class-name^ imports)
     _ (<>.assert "Variable name must ne one of the expected type-variables."
                  (list.member? text.equivalence type-vars name))]
    (wrap (type.var name))))

(def: wildcard^
  (Parser (Type Parameter))
  (do <>.monad
    [_ (<c>.this! (' ?))]
    (wrap type.wildcard)))

(template [<name> <comparison> <constructor>]
  [(def: <name>
     (-> (Parser (Type Class)) (Parser (Type Parameter)))
     (|>> (<>.after (<c>.this! (' <comparison>)))
          (<>.after ..wildcard^)
          <c>.tuple
          (:: <>.monad map <constructor>)))]

  [upper^ < type.upper]
  [lower^ > type.lower]
  )

(def: (parameter^ imports type-vars)
  (-> Class-Imports (List Variable) (Parser (Type Parameter)))
  (<>.rec
   (function (_ recur^)
     (let [class^ (..class^' parameter^ imports type-vars)]
       ($_ <>.either
           (..variable^ imports type-vars)
           ..wildcard^
           (upper^ class^)
           (lower^ class^)
           class^
           )))))

(def: (itself^ type)
  (All [a] (-> (Type a) (Parser (Type a))))
  (do <>.monad
    [_ (<c>.identifier! ["" (..reflection type)])]
    (wrap type)))

(def: primitive^
  (Parser (Type Primitive))
  ($_ <>.either
      (itself^ type.boolean)
      (itself^ type.byte)
      (itself^ type.short)
      (itself^ type.int)
      (itself^ type.long)
      (itself^ type.float)
      (itself^ type.double)
      (itself^ type.char)
      ))

(def: array^
  (-> (Parser (Type Value)) (Parser (Type Array)))
  (|>> <c>.tuple
       (:: <>.monad map type.array)))

(def: (type^ imports type-vars)
  (-> Class-Imports (List Variable) (Parser (Type Value)))
  (<>.rec
   (function (_ type^)
     ($_ <>.either
         ..primitive^
         (..parameter^ imports type-vars)
         (..array^ type^)
         ))))

(def: (return^ imports type-vars)
  (-> Class-Imports (List Variable) (Parser (Type Return)))
  (<>.either (itself^ type.void)
             (..type^ imports type-vars)))

(def: var^
  (Parser (Type Var))
  (:: <>.monad map type.var <c>.local-identifier))

(def: vars^
  (Parser (List (Type Var)))
  (<c>.tuple (<>.some var^)))

(def: (declaration^ imports)
  (-> Class-Imports (Parser Class-Declaration))
  (<>.either (<>.and (valid-class-name imports (list))
                     (<>@wrap (list)))
             (<c>.form (<>.and (valid-class-name imports (list))
                               (<>.some var^)))
             ))

(def: (class^ imports type-vars)
  (-> Class-Imports (List Variable) (Parser Class))
  (class^' parameter^ imports type-vars))

(def: annotation-params^
  (Parser (List AnnotationParam))
  (<c>.record (<>.some (<>.and <c>.local-tag <c>.any))))

(def: (annotation^ imports)
  (-> Class-Imports (Parser Annotation))
  (<>.either (do <>.monad
               [ann-name (full-class-name^ imports)]
               (wrap [ann-name (list)]))
             (<c>.form (<>.and (full-class-name^ imports)
                               annotation-params^))))

(def: (annotations^' imports)
  (-> Class-Imports (Parser (List Annotation)))
  (do <>.monad
    [_ (<c>.this! (' #ann))]
    (<c>.tuple (<>.some (annotation^ imports)))))

(def: (annotations^ imports)
  (-> Class-Imports (Parser (List Annotation)))
  (do <>.monad
    [anns?? (<>.maybe (annotations^' imports))]
    (wrap (maybe.default (list) anns??))))

(def: (throws-decl^ imports type-vars)
  (-> Class-Imports (List Variable) (Parser (List Class)))
  (<| (<>.default (list))
      (do <>.monad
        [_ (<c>.this! (' #throws))]
        (<c>.tuple (<>.some (..class^ imports type-vars))))))

(def: (method-decl^ imports type-vars)
  (-> Class-Imports (List Variable) (Parser [Member-Declaration MethodDecl]))
  (<c>.form (do <>.monad
              [tvars (<>.default (list) ..vars^)
               name <c>.local-identifier
               anns (annotations^ imports)
               inputs (<c>.tuple (<>.some (..type^ imports type-vars)))
               output (..return^ imports type-vars)
               exs (throws-decl^ imports type-vars)]
              (wrap [[name #PublicP anns] {#method-tvars tvars
                                           #method-inputs inputs
                                           #method-output output
                                           #method-exs    exs}]))))

(def: state-modifier^
  (Parser StateModifier)
  ($_ <>.or
      (<c>.this! (' #volatile))
      (<c>.this! (' #final))
      (:: <>.monad wrap [])))

(def: (field-decl^ imports type-vars)
  (-> Class-Imports (List Variable) (Parser [Member-Declaration FieldDecl]))
  (<>.either (<c>.form (do <>.monad
                         [_ (<c>.this! (' #const))
                          name <c>.local-identifier
                          anns (annotations^ imports)
                          type (..type^ imports type-vars)
                          body <c>.any]
                         (wrap [[name #PublicP anns] (#ConstantField [type body])])))
             (<c>.form (do <>.monad
                         [pm privacy-modifier^
                          sm state-modifier^
                          name <c>.local-identifier
                          anns (annotations^ imports)
                          type (..type^ imports type-vars)]
                         (wrap [[name pm anns] (#VariableField [sm type])])))))

(def: (argument^ imports type-vars)
  (-> Class-Imports (List Variable) (Parser Argument))
  (<c>.record (<>.and <c>.local-identifier
                      (..type^ imports type-vars))))

(def: (arguments^ imports type-vars)
  (-> Class-Imports (List Variable) (Parser (List Argument)))
  (<>.some (argument^ imports type-vars)))

(def: (constructor-arg^ imports type-vars)
  (-> Class-Imports (List Variable) (Parser (Typed Code)))
  (<c>.record (<>.and (..type^ imports type-vars) <c>.any)))

(def: (constructor-args^ imports type-vars)
  (-> Class-Imports (List Variable) (Parser (List (Typed Code))))
  (<c>.tuple (<>.some (constructor-arg^ imports type-vars))))

(def: (constructor-method^ imports class-vars)
  (-> Class-Imports (List Variable) (Parser [Member-Declaration Method-Definition]))
  (<c>.form (do <>.monad
              [pm privacy-modifier^
               strict-fp? (<>.parses? (<c>.this! (' #strict)))
               method-vars (<>.default (list) ..vars^)
               #let [total-vars (list@compose class-vars method-vars)]
               [_ self-name arguments] (<c>.form ($_ <>.and
                                                     (<c>.this! (' new))
                                                     <c>.local-identifier
                                                     (arguments^ imports total-vars)))
               constructor-args (constructor-args^ imports total-vars)
               exs (throws-decl^ imports total-vars)
               annotations (annotations^ imports)
               body <c>.any]
              (wrap [{#member-name constructor-method-name
                      #member-privacy pm
                      #member-anns annotations}
                     (#ConstructorMethod strict-fp? method-vars self-name arguments constructor-args body exs)]))))

(def: (virtual-method-def^ imports class-vars)
  (-> Class-Imports (List Variable) (Parser [Member-Declaration Method-Definition]))
  (<c>.form (do <>.monad
              [pm privacy-modifier^
               strict-fp? (<>.parses? (<c>.this! (' #strict)))
               final? (<>.parses? (<c>.this! (' #final)))
               method-vars (<>.default (list) ..vars^)
               #let [total-vars (list@compose class-vars method-vars)]
               [name self-name arguments] (<c>.form ($_ <>.and
                                                        <c>.local-identifier
                                                        <c>.local-identifier
                                                        (arguments^ imports total-vars)))
               return-type (..return^ imports total-vars)
               exs (throws-decl^ imports total-vars)
               annotations (annotations^ imports)
               body <c>.any]
              (wrap [{#member-name name
                      #member-privacy pm
                      #member-anns annotations}
                     (#VirtualMethod final? strict-fp? method-vars self-name arguments return-type body exs)]))))

(def: (overriden-method-def^ imports)
  (-> Class-Imports (Parser [Member-Declaration Method-Definition]))
  (<c>.form (do <>.monad
              [strict-fp? (<>.parses? (<c>.this! (' #strict)))
               owner-class (declaration^ imports)
               method-vars (<>.default (list) ..vars^)
               #let [total-vars (list@compose (product.right owner-class) method-vars)]
               [name self-name arguments] (<c>.form ($_ <>.and
                                                        <c>.local-identifier
                                                        <c>.local-identifier
                                                        (arguments^ imports total-vars)))
               return-type (..return^ imports total-vars)
               exs (throws-decl^ imports total-vars)
               annotations (annotations^ imports)
               body <c>.any]
              (wrap [{#member-name name
                      #member-privacy #PublicP
                      #member-anns annotations}
                     (#OverridenMethod strict-fp? owner-class method-vars self-name arguments return-type body exs)]))))

(def: (static-method-def^ imports)
  (-> Class-Imports (Parser [Member-Declaration Method-Definition]))
  (<c>.form (do <>.monad
              [pm privacy-modifier^
               strict-fp? (<>.parses? (<c>.this! (' #strict)))
               _ (<c>.this! (' #static))
               method-vars (<>.default (list) ..vars^)
               #let [total-vars method-vars]
               [name arguments] (<c>.form (<>.and <c>.local-identifier
                                                  (arguments^ imports total-vars)))
               return-type (..return^ imports total-vars)
               exs (throws-decl^ imports total-vars)
               annotations (annotations^ imports)
               body <c>.any]
              (wrap [{#member-name name
                      #member-privacy pm
                      #member-anns annotations}
                     (#StaticMethod strict-fp? method-vars arguments return-type body exs)]))))

(def: (abstract-method-def^ imports)
  (-> Class-Imports (Parser [Member-Declaration Method-Definition]))
  (<c>.form (do <>.monad
              [pm privacy-modifier^
               _ (<c>.this! (' #abstract))
               method-vars (<>.default (list) ..vars^)
               #let [total-vars method-vars]
               [name arguments] (<c>.form (<>.and <c>.local-identifier
                                                  (arguments^ imports total-vars)))
               return-type (..return^ imports total-vars)
               exs (throws-decl^ imports total-vars)
               annotations (annotations^ imports)]
              (wrap [{#member-name name
                      #member-privacy pm
                      #member-anns annotations}
                     (#AbstractMethod method-vars arguments return-type exs)]))))

(def: (native-method-def^ imports)
  (-> Class-Imports (Parser [Member-Declaration Method-Definition]))
  (<c>.form (do <>.monad
              [pm privacy-modifier^
               _ (<c>.this! (' #native))
               method-vars (<>.default (list) ..vars^)
               #let [total-vars method-vars]
               [name arguments] (<c>.form (<>.and <c>.local-identifier
                                                  (arguments^ imports total-vars)))
               return-type (..return^ imports total-vars)
               exs (throws-decl^ imports total-vars)
               annotations (annotations^ imports)]
              (wrap [{#member-name name
                      #member-privacy pm
                      #member-anns annotations}
                     (#NativeMethod method-vars arguments return-type exs)]))))

(def: (method-def^ imports class-vars)
  (-> Class-Imports (List Variable) (Parser [Member-Declaration Method-Definition]))
  ($_ <>.either
      (constructor-method^ imports class-vars)
      (virtual-method-def^ imports class-vars)
      (overriden-method-def^ imports)
      (static-method-def^ imports)
      (abstract-method-def^ imports)
      (native-method-def^ imports)))

(def: partial-call^
  (Parser Partial-Call)
  (<c>.form (<>.and <c>.identifier (<>.some <c>.any))))

(def: class-kind^
  (Parser Class-Kind)
  (<>.either (do <>.monad
               [_ (<c>.this! (' #class))]
               (wrap #Class))
             (do <>.monad
               [_ (<c>.this! (' #interface))]
               (wrap #Interface))
             ))

(def: import-member-alias^
  (Parser (Maybe Text))
  (<>.maybe (do <>.monad
              [_ (<c>.this! (' #as))]
              <c>.local-identifier)))

(def: (import-member-args^ imports type-vars)
  (-> Class-Imports (List Variable) (Parser (List [Bit Type])))
  (<c>.tuple (<>.some (<>.and (<>.parses? (<c>.tag! ["" "?"]))
                              (..type^ imports type-vars)))))

(def: import-member-return-flags^
  (Parser [Bit Bit Bit])
  ($_ <>.and
      (<>.parses? (<c>.this! (' #io)))
      (<>.parses? (<c>.this! (' #try)))
      (<>.parses? (<c>.this! (' #?)))))

(def: primitive-mode^
  (Parser Primitive-Mode)
  (<>.or (<c>.tag! ["" "manual"])
         (<c>.tag! ["" "auto"])))

(def: (import-member-decl^ imports owner-vars)
  (-> Class-Imports (List Variable) (Parser Import-Member-Declaration))
  ($_ <>.either
      (<c>.form (do <>.monad
                  [_ (<c>.this! (' #enum))
                   enum-members (<>.some <c>.local-identifier)]
                  (wrap (#EnumDecl enum-members))))
      (<c>.form (do <>.monad
                  [tvars (<>.default (list) ..vars^)
                   _ (<c>.identifier! ["" "new"])
                   ?alias import-member-alias^
                   #let [total-vars (list@compose owner-vars tvars)]
                   ?prim-mode (<>.maybe primitive-mode^)
                   args (import-member-args^ imports total-vars)
                   [io? try? maybe?] import-member-return-flags^]
                  (wrap (#ConstructorDecl [{#import-member-mode    (maybe.default #AutoPrM ?prim-mode)
                                            #import-member-alias   (maybe.default "new" ?alias)
                                            #import-member-kind    #VirtualIMK
                                            #import-member-tvars   tvars
                                            #import-member-args    args
                                            #import-member-maybe?  maybe?
                                            #import-member-try?    try?
                                            #import-member-io?     io?}
                                           {}]))
                  ))
      (<c>.form (do <>.monad
                  [kind (: (Parser ImportMethodKind)
                           (<>.or (<c>.tag! ["" "static"])
                                  (wrap [])))
                   tvars (<>.default (list) ..vars^)
                   name <c>.local-identifier
                   ?alias import-member-alias^
                   #let [total-vars (list@compose owner-vars tvars)]
                   ?prim-mode (<>.maybe primitive-mode^)
                   args (import-member-args^ imports total-vars)
                   [io? try? maybe?] import-member-return-flags^
                   return (..return^ imports total-vars)]
                  (wrap (#MethodDecl [{#import-member-mode    (maybe.default #AutoPrM ?prim-mode)
                                       #import-member-alias   (maybe.default name ?alias)
                                       #import-member-kind    kind
                                       #import-member-tvars   tvars
                                       #import-member-args    args
                                       #import-member-maybe?  maybe?
                                       #import-member-try?    try?
                                       #import-member-io?     io?}
                                      {#import-method-name    name
                                       #import-method-return  return}]))))
      (<c>.form (do <>.monad
                  [static? (<>.parses? (<c>.this! (' #static)))
                   name <c>.local-identifier
                   ?prim-mode (<>.maybe primitive-mode^)
                   gtype (..type^ imports owner-vars)
                   maybe? (<>.parses? (<c>.this! (' #?)))
                   setter? (<>.parses? (<c>.this! (' #!)))]
                  (wrap (#FieldAccessDecl {#import-field-mode    (maybe.default #AutoPrM ?prim-mode)
                                           #import-field-name    name
                                           #import-field-static? static?
                                           #import-field-maybe?  maybe?
                                           #import-field-setter? setter?
                                           #import-field-type    gtype}))))
      ))

(def: (privacy-modifier$ pm)
  (-> Privacy Code)
  (case pm
    #PublicP    (' "public")
    #PrivateP   (' "private")
    #ProtectedP (' "protected")
    #DefaultP   (' "default")))

(def: (inheritance-modifier$ im)
  (-> InheritanceModifier Code)
  (case im
    #FinalIM    (' "final")
    #AbstractIM (' "abstract")
    #DefaultIM  (' "default")))

(def: (annotation-param$ [name value])
  (-> AnnotationParam Code)
  (` [(~ (code.text name)) (~ value)]))

(def: (annotation$ [name params])
  (-> Annotation Code)
  (` ((~ (code.text name)) (~+ (list@map annotation-param$ params)))))

(def: (bound$ kind)
  (-> Bound Code)
  (case kind
    #jvm.Lower (code.local-identifier ">")
    #jvm.Upper (code.local-identifier "<")))

(def: var$
  (-> Variable Code)
  code.text)

(def: (generic$ generic)
  (-> Generic Code)
  (case generic
    (#jvm.Var var)
    (var$ var)

    (#jvm.Class name params)
    (` ((~ (code.text name)) (~+ (list@map generic$ params))))
    
    (#jvm.Wildcard wilcard)
    (case wilcard
      #.None
      (code.local-identifier "?")

      (#.Some [bound bound])
      (` ((~ (..bound$ bound)) (~ (generic$ bound)))))))

(def: (type$ type)
  (-> Type Code)
  (case type
    (#jvm.Primitive primitive)
    (case primitive
      #jvm.Boolean (code.local-identifier reflection.boolean)
      #jvm.Byte (code.local-identifier reflection.byte)
      #jvm.Short (code.local-identifier reflection.short)
      #jvm.Int (code.local-identifier reflection.int)
      #jvm.Long (code.local-identifier reflection.long)
      #jvm.Float (code.local-identifier reflection.float)
      #jvm.Double (code.local-identifier reflection.double)
      #jvm.Char (code.local-identifier reflection.char))
    
    (#jvm.Generic generic)
    (generic$ generic)
    
    (#jvm.Array elementT)
    (` [(~ (type$ elementT))])))

(def: (return$ return)
  (-> Return Code)
  (case return
    #.None
    (code.local-identifier "void")
    
    (#.Some type)
    (type$ type)))

(def: (declaration$ (^open "."))
  (-> Class-Declaration Code)
  (` ((~ (code.text class-name))
      (~+ (list@map var$ class-params)))))

(def: (class$ [name params])
  (-> Class Code)
  (` ((~ (code.text name))
      (~+ (list@map generic$ params)))))

(def: (method-decl$ [[name pm anns] method-decl])
  (-> [Member-Declaration MethodDecl] Code)
  (let [(^slots [#method-tvars #method-inputs #method-output #method-exs]) method-decl]
    (` ((~ (code.text name))
        [(~+ (list@map annotation$ anns))]
        [(~+ (list@map var$ method-tvars))]
        [(~+ (list@map class$ method-exs))]
        [(~+ (list@map type$ method-inputs))]
        (~ (return$ method-output))))))

(def: (state-modifier$ sm)
  (-> StateModifier Code)
  (case sm
    #VolatileSM (' "volatile")
    #FinalSM    (' "final")
    #DefaultSM  (' "default")))

(def: (field-decl$ [[name pm anns] field])
  (-> [Member-Declaration FieldDecl] Code)
  (case field
    (#ConstantField class value)
    (` ("constant" (~ (code.text name))
        [(~+ (list@map annotation$ anns))]
        (~ (type$ class))
        (~ value)
        ))

    (#VariableField sm class)
    (` ("variable" (~ (code.text name))
        (~ (privacy-modifier$ pm))
        (~ (state-modifier$ sm))
        [(~+ (list@map annotation$ anns))]
        (~ (type$ class))
        ))
    ))

(def: (argument$ [name type])
  (-> Argument Code)
  (` [(~ (code.text name)) (~ (type$ type))]))

(def: (constructor-arg$ [class term])
  (-> (Typed Code) Code)
  (` [(~ (type$ class)) (~ term)]))

(def: (method-def$ replacer super-class [[name pm anns] method-def])
  (-> (-> Code Code) Class [Member-Declaration Method-Definition] Code)
  (case method-def
    (#ConstructorMethod strict-fp? type-vars self-name arguments constructor-args body exs)
    (` ("init"
        (~ (privacy-modifier$ pm))
        (~ (code.bit strict-fp?))
        [(~+ (list@map annotation$ anns))]
        [(~+ (list@map var$ type-vars))]
        [(~+ (list@map class$ exs))]
        (~ (code.text self-name))
        [(~+ (list@map argument$ arguments))]
        [(~+ (list@map constructor-arg$ constructor-args))]
        (~ (pre-walk-replace replacer body))
        ))
    
    (#VirtualMethod final? strict-fp? type-vars self-name arguments return-type body exs)
    (` ("virtual"
        (~ (code.text name))
        (~ (privacy-modifier$ pm))
        (~ (code.bit final?))
        (~ (code.bit strict-fp?))
        [(~+ (list@map annotation$ anns))]
        [(~+ (list@map var$ type-vars))]
        (~ (code.text self-name))
        [(~+ (list@map argument$ arguments))]
        (~ (return$ return-type))
        [(~+ (list@map class$ exs))]
        (~ (pre-walk-replace replacer body))))
    
    (#OverridenMethod strict-fp? declaration type-vars self-name arguments return-type body exs)
    (let [super-replacer (parser->replacer (<c>.form (do <>.monad
                                                       [_ (<c>.this! (' ::super!))
                                                        args (<c>.tuple (<>.exactly (list.size arguments) <c>.any))
                                                        #let [arguments' (list@map (|>> product.right type.signature) arguments)]]
                                                       (wrap (` ("jvm member invoke special"
                                                                 (~ (code.text (product.left super-class)))
                                                                 (~ (code.text name))
                                                                 (~' _jvm_this)
                                                                 (~+ (|> args
                                                                         (list.zip2 arguments')
                                                                         (list@map ..decorate-input)))))))))]
      (` ("override"
          (~ (declaration$ declaration))
          (~ (code.text name))
          (~ (code.bit strict-fp?))
          [(~+ (list@map annotation$ anns))]
          [(~+ (list@map var$ type-vars))]
          (~ (code.text self-name))
          [(~+ (list@map argument$ arguments))]
          (~ (return$ return-type))
          [(~+ (list@map class$ exs))]
          (~ (|> body
                 (pre-walk-replace replacer)
                 (pre-walk-replace super-replacer)))
          )))

    (#StaticMethod strict-fp? type-vars arguments return-type body exs)
    (` ("static"
        (~ (code.text name))
        (~ (privacy-modifier$ pm))
        (~ (code.bit strict-fp?))
        [(~+ (list@map annotation$ anns))]
        [(~+ (list@map var$ type-vars))]
        [(~+ (list@map class$ exs))]
        [(~+ (list@map argument$ arguments))]
        (~ (return$ return-type))
        (~ (pre-walk-replace replacer body))))

    (#AbstractMethod type-vars arguments return-type exs)
    (` ("abstract"
        (~ (code.text name))
        (~ (privacy-modifier$ pm))
        [(~+ (list@map annotation$ anns))]
        [(~+ (list@map var$ type-vars))]
        [(~+ (list@map class$ exs))]
        [(~+ (list@map argument$ arguments))]
        (~ (return$ return-type))))

    (#NativeMethod type-vars arguments return-type exs)
    (` ("native"
        (~ (code.text name))
        (~ (privacy-modifier$ pm))
        [(~+ (list@map annotation$ anns))]
        [(~+ (list@map var$ type-vars))]
        [(~+ (list@map class$ exs))]
        [(~+ (list@map argument$ arguments))]
        (~ (return$ return-type))))
    ))

(def: (complete-call$ g!obj [method args])
  (-> Code Partial-Call Code)
  (` ((~ (code.identifier method)) (~+ args) (~ g!obj))))

(def: object-class
  Class
  ["java/lang/Object" (list)])

(syntax: #export (class:
                   {#let [imports (class-imports *compiler*)]}
                   {im inheritance-modifier^}
                   {declaration (declaration^ imports)}
                   {#let [full-class-name (product.left declaration)
                          imports (add-import [(short-class-name full-class-name) full-class-name]
                                              (class-imports *compiler*))]}
                   {#let [class-vars (product.right declaration)]}
                   {super (<>.default object-class
                                      (class^ imports class-vars))}
                   {interfaces (<>.default (list)
                                           (<c>.tuple (<>.some (class^ imports class-vars))))}
                   {annotations (annotations^ imports)}
                   {fields (<>.some (field-decl^ imports class-vars))}
                   {methods (<>.some (method-def^ imports class-vars))})
  {#.doc (doc "Allows defining JVM classes in Lux code."
              "For example:"
              (class: #final (TestClass A) [Runnable]
                ## Fields
                (#private foo boolean)
                (#private bar A)
                (#private baz java/lang/Object)
                ## Methods
                (#public [] (new [value A]) []
                         (exec (:= ::foo #1)
                           (:= ::bar value)
                           (:= ::baz "")
                           []))
                (#public (virtual) java/lang/Object
                         "")
                (#public #static (static) java/lang/Object
                         "")
                (Runnable [] (run) void
                          [])
                )

              "The tuple corresponds to parent interfaces."
              "An optional super-class can be specified before the tuple. If not specified, java.lang.Object will be assumed."
              "Fields and methods defined in the class can be used with special syntax."
              "For example:"
              "::resolved, for accessing the 'resolved' field."
              "(:= ::resolved #1) for modifying it."
              "(::new! []) for calling the class's constructor."
              "(::resolve! container [value]) for calling the 'resolve' method."
              )}
  (do macro.monad
    [current-module macro.current-module-name
     #let [fully-qualified-class-name (name.qualify current-module full-class-name)
           field-parsers (list@map (field->parser fully-qualified-class-name) fields)
           method-parsers (list@map (method->parser fully-qualified-class-name) methods)
           replacer (parser->replacer (list@fold <>.either
                                                 (<>.fail "")
                                                 (list@compose field-parsers method-parsers)))]]
    (wrap (list (` ("jvm class"
                    (~ (declaration$ (update@ #class-name (name.qualify current-module) declaration)))
                    (~ (class$ super))
                    [(~+ (list@map class$ interfaces))]
                    (~ (inheritance-modifier$ im))
                    [(~+ (list@map annotation$ annotations))]
                    [(~+ (list@map field-decl$ fields))]
                    [(~+ (list@map (method-def$ replacer super) methods))]))))))

(syntax: #export (interface:
                   {#let [imports (class-imports *compiler*)]}
                   {declaration (declaration^ imports)}
                   {#let [full-class-name (product.left declaration)
                          imports (add-import [(short-class-name full-class-name) full-class-name]
                                              (class-imports *compiler*))]}
                   {#let [class-vars (product.right declaration)]}
                   {supers (<>.default (list)
                                       (<c>.tuple (<>.some (class^ imports class-vars))))}
                   {annotations (annotations^ imports)}
                   {members (<>.some (method-decl^ imports class-vars))})
  {#.doc (doc "Allows defining JVM interfaces."
              (interface: TestInterface
                ([] foo [boolean String] void #throws [Exception])))}
  (wrap (list (` ("jvm class interface"
                  (~ (declaration$ declaration))
                  [(~+ (list@map class$ supers))]
                  [(~+ (list@map annotation$ annotations))]
                  (~+ (list@map method-decl$ members)))))))

(syntax: #export (object
                   {#let [imports (class-imports *compiler*)]}
                   {class-vars ..vars^}
                   {super (<>.default object-class
                                      (class^ imports class-vars))}
                   {interfaces (<>.default (list)
                                           (<c>.tuple (<>.some (class^ imports class-vars))))}
                   {constructor-args (constructor-args^ imports class-vars)}
                   {methods (<>.some (overriden-method-def^ imports))})
  {#.doc (doc "Allows defining anonymous classes."
              "The 1st tuple corresponds to class-level type-variables."
              "The 2nd tuple corresponds to parent interfaces."
              "The 3rd tuple corresponds to arguments to the super class constructor."
              "An optional super-class can be specified before the 1st tuple. If not specified, java.lang.Object will be assumed."
              (object [] [Runnable]
                []
                (Runnable [] (run self) void
                          (exec (do-something some-value)
                            [])))
              )}
  (wrap (list (` ("jvm class anonymous"
                  [(~+ (list@map var$ class-vars))]
                  (~ (class$ super))
                  [(~+ (list@map class$ interfaces))]
                  [(~+ (list@map constructor-arg$ constructor-args))]
                  [(~+ (list@map (method-def$ function.identity super) methods))])))))

(syntax: #export (null)
  {#.doc (doc "Null object reference."
              (null))}
  (wrap (list (` ("jvm object null")))))

(def: #export (null? obj)
  {#.doc (doc "Test for null object reference."
              (= (null? (null))
                 true)
              (= (null? "YOLO")
                 false))}
  (-> (primitive "java.lang.Object") Bit)
  ("jvm object null?" obj))

(syntax: #export (??? expr)
  {#.doc (doc "Takes a (potentially null) ObjectType reference and creates a (Maybe ObjectType) for it."
              (= (??? (: java/lang/String (null)))
                 #.None)
              (= (??? "YOLO")
                 (#.Some "YOLO")))}
  (with-gensyms [g!temp]
    (wrap (list (` (let [(~ g!temp) (~ expr)]
                     (if ("jvm object null?" (~ g!temp))
                       #.None
                       (#.Some (~ g!temp)))))))))

(syntax: #export (!!! expr)
  {#.doc (doc "Takes a (Maybe ObjectType) and returns a ObjectType."
              "A #.None would get translated into a (null)."
              (= (null)
                 (!!! (??? (: java/lang/Thread (null)))))
              (= "foo"
                 (!!! (??? "foo"))))}
  (with-gensyms [g!value]
    (wrap (list (` ({(#.Some (~ g!value))
                     (~ g!value)

                     #.None
                     ("jvm object null")}
                    (~ expr)))))))

(syntax: #export (try expression)
  {#.doc (doc (case (try (risky-computation input))
                (#.Right success)
                (do-something success)

                (#.Left error)
                (recover-from-failure error)))}
  (with-gensyms [g!_]
    (wrap (list (` ("lux try" ((~! io.label) (.function ((~ g!_) (~ g!_))
                                               (~ expression)))))))))

(syntax: #export (check {#let [imports (class-imports *compiler*)]}
                        {class (..type^ imports (list))}
                        {unchecked (<>.maybe <c>.any)})
  {#.doc (doc "Checks whether an object is an instance of a particular class."
              "Caveat emptor: Cannot check for polymorphism, so avoid using parameterized classes."
              (case (check String "YOLO")
                (#.Some value-as-string)
                #.None))}
  (with-gensyms [g!_ g!unchecked]
    (let [class-name (reflection.class class)
          class-type (` (.primitive (~ (code.text class-name))))
          check-type (` (.Maybe (~ class-type)))
          check-code (` (if ("jvm object instance?" (~ (code.text class-name)) (~ g!unchecked))
                          (#.Some (.:coerce (~ class-type)
                                            (~ g!unchecked)))
                          #.None))]
      (case unchecked
        (#.Some unchecked)
        (wrap (list (` (: (~ check-type)
                          (let [(~ g!unchecked) (~ unchecked)]
                            (~ check-code))))))

        #.None
        (wrap (list (` (: (-> (primitive "java.lang.Object") (~ check-type))
                          (function ((~ g!_) (~ g!unchecked))
                            (~ check-code))))))
        ))))

(syntax: #export (synchronized lock body)
  {#.doc (doc "Evaluates body, while holding a lock on a given object."
              (synchronized object-to-be-locked
                (exec (do-something ___)
                  (do-something-else ___)
                  (finish-the-computation ___))))}
  (wrap (list (` ("jvm object synchronized" (~ lock) (~ body))))))

(syntax: #export (do-to obj {methods (<>.some partial-call^)})
  {#.doc (doc "Call a variety of methods on an object. Then, return the object."
              (do-to object
                (ClassName::method1 arg0 arg1 arg2)
                (ClassName::method2 arg3 arg4 arg5)))}
  (with-gensyms [g!obj]
    (wrap (list (` (let [(~ g!obj) (~ obj)]
                     (exec (~+ (list@map (complete-call$ g!obj) methods))
                       (~ g!obj))))))))

(def: (class-import$ long-name? [full-name params])
  (-> Bit Class-Declaration Code)
  (let [def-name (if long-name?
                   full-name
                   (short-class-name full-name))
        params' (list@map code.local-identifier params)]
    (` (def: (~ (code.identifier ["" def-name]))
         {#..jvm-class (~ (code.text full-name))}
         .Type
         (All [(~+ params')]
           (primitive (~ (code.text full-name))
                      [(~+ params')]))))))

(def: (member-type-vars class-tvars member)
  (-> (List Variable) Import-Member-Declaration (List Variable))
  (case member
    (#ConstructorDecl [commons _])
    (list@compose class-tvars (get@ #import-member-tvars commons))

    (#MethodDecl [commons _])
    (case (get@ #import-member-kind commons)
      #StaticIMK
      (get@ #import-member-tvars commons)

      _
      (list@compose class-tvars (get@ #import-member-tvars commons)))

    _
    class-tvars))

(def: (member-def-arg-bindings vars class member)
  (-> (List Variable) Class-Declaration Import-Member-Declaration (Meta [(List [Bit Code]) (List Text) (List Code)]))
  (case member
    (^or (#ConstructorDecl [commons _]) (#MethodDecl [commons _]))
    (let [(^slots [#import-member-tvars #import-member-args]) commons]
      (do macro.monad
        [arg-inputs (monad.map @
                               (: (-> [Bit Type] (Meta [Bit Code]))
                                  (function (_ [maybe? _])
                                    (with-gensyms [arg-name]
                                      (wrap [maybe? arg-name]))))
                               import-member-args)
         #let [arg-classes (list@map (|>> product.right type.descriptor) import-member-args)
               arg-types (list@map (: (-> [Bit Type] Code)
                                      (function (_ [maybe? arg])
                                        (let [arg-type (value-type (get@ #import-member-mode commons) arg)]
                                          (if maybe?
                                            (` (Maybe (~ arg-type)))
                                            arg-type))))
                                   import-member-args)]]
        (wrap [arg-inputs arg-classes arg-types])))

    _
    (:: macro.monad wrap [(list) (list) (list)])))

(def: (decorate-return-maybe member never-null? unboxed return-term)
  (-> Import-Member-Declaration Bit Text Code Code)
  (case member
    (^or (#ConstructorDecl [commons _]) (#MethodDecl [commons _]))
    (cond (or never-null?
              (dictionary.contains? unboxed ..boxes))
          return-term

          (get@ #import-member-maybe? commons)
          (` (??? (~ return-term)))

          ## else
          (let [g!temp (` ((~' ~') (~ (code.identifier ["" "  "]))))]
            (` (let [(~ g!temp) (~ return-term)]
                 (if (not (..null? (:coerce (primitive "java.lang.Object")
                                            (~ g!temp))))
                   (~ g!temp)
                   (error! "Cannot produce null references from method calls."))))))

    _
    return-term))

(template [<name> <tag> <term-trans>]
  [(def: (<name> member return-term)
     (-> Import-Member-Declaration Code Code)
     (case member
       (^or (#ConstructorDecl [commons _]) (#MethodDecl [commons _]))
       (if (get@ <tag> commons)
         <term-trans>
         return-term)

       _
       return-term))]

  [decorate-return-try #import-member-try? (` (..try (~ return-term)))]
  [decorate-return-io  #import-member-io?  (` ((~! io.io) (~ return-term)))]
  )

(def: var->type-arg
  (-> Variable Code)
  code.local-identifier)

(template [<jvm> <class> <descriptor>]
  [(def: <class> <jvm>)
   (def: <descriptor> (type.signature (type.class <jvm> (list))))]

  ["java.lang.String" string-class string-descriptor]
  [box.boolean boolean-box-class boolean-box-descriptor]
  [box.byte byte-box-class byte-box-descriptor]
  [box.short short-box-class short-box-descriptor]
  [box.int int-box-class int-box-descriptor]
  [box.long long-box-class long-box-descriptor]
  [box.float float-box-class float-box-descriptor]
  [box.double double-box-class double-box-descriptor]
  [box.char char-box-class char-box-descriptor]
  )

(template [<input?> <name> <unbox/box> <special+>]
  [(def: (<name> mode [unboxed raw])
     (-> Primitive-Mode [Text Code] Code)
     (let [[unboxed refined post] (: [Text Code (List Code)]
                                     (case mode
                                       #ManualPrM
                                       [unboxed raw (list)]
                                       
                                       #AutoPrM
                                       (`` (case unboxed
                                             (^template [<old> <new> <pre> <post>]
                                               (^ (static <old>))
                                               (with-expansions [<post>' (template.splice <post>)]
                                                 [<new>
                                                  (` (.|> (~ raw) (~+ <pre>)))
                                                  (list <post>')]))
                                             ((~~ (template.splice <special+>)))
                                             
                                             _
                                             [unboxed
                                              (if <input?>
                                                (` ("jvm object cast" (~ raw)))
                                                raw)
                                              (list)]))))
           unboxed/boxed (case (dictionary.get unboxed ..boxes)
                           (#.Some boxed)
                           (<unbox/box> unboxed boxed refined)
                           
                           #.None
                           refined)]
       (case post
         #.Nil
         unboxed/boxed

         _
         (` (.|> (~ unboxed/boxed) (~+ post))))))]

  [#1 auto-convert-input ..unbox
   [[type.boolean-descriptor type.boolean-descriptor (list (` (.: .Bit)) (` (.:coerce (.primitive (~ (code.text box.boolean)))))) []]
    [type.byte-descriptor type.byte-descriptor (list (` (.: .Int)) (` (.:coerce (.primitive (~ (code.text box.long))))) (` ..long-to-byte)) []]
    [type.short-descriptor type.short-descriptor (list (` (.: .Int)) (` (.:coerce (.primitive (~ (code.text box.long))))) (` ..long-to-short)) []]
    [type.int-descriptor type.int-descriptor (list (` (.: .Int)) (` (.:coerce (.primitive (~ (code.text box.long))))) (` ..long-to-int)) []]
    [type.long-descriptor type.long-descriptor (list (` (.: .Int)) (` (.:coerce (.primitive (~ (code.text box.long)))))) []]
    [type.float-descriptor type.float-descriptor (list (` (.: .Frac)) (` (.:coerce (.primitive (~ (code.text box.double))))) (` ..double-to-float)) []]
    [type.double-descriptor type.double-descriptor (list (` (.: .Frac)) (` (.:coerce (.primitive (~ (code.text box.double)))))) []]
    [..string-descriptor ..string-descriptor (list (` (.: .Text)) (` (.:coerce (.primitive (~ (code.text ..string-class)))))) []]
    [..boolean-box-descriptor ..boolean-box-descriptor (list (` (.: .Bit)) (` (.:coerce (.primitive (~ (code.text ..boolean-box-class)))))) []]
    [..long-box-descriptor ..long-box-descriptor (list (` (.: .Int)) (` (.:coerce (.primitive (~ (code.text ..long-box-class)))))) []]
    [..double-box-descriptor ..double-box-descriptor (list (` (.: .Frac)) (` (.:coerce (.primitive (~ (code.text ..double-box-class)))))) []]]]
  [#0 auto-convert-output ..box
   [[type.boolean-descriptor type.boolean-descriptor (list) [(` (.: (.primitive (~ (code.text box.boolean))))) (` (.:coerce .Bit))]]
    [type.byte-descriptor type.long-descriptor (list (` "jvm conversion byte-to-long")) [(` (.: (.primitive (~ (code.text box.long))))) (` (.:coerce .Int))]]
    [type.short-descriptor type.long-descriptor (list (` "jvm conversion short-to-long")) [(` (.: (.primitive (~ (code.text box.long))))) (` (.:coerce .Int))]]
    [type.int-descriptor type.long-descriptor (list (` "jvm conversion int-to-long")) [(` (.: (.primitive (~ (code.text box.long))))) (` (.:coerce .Int))]]
    [type.long-descriptor type.long-descriptor (list) [(` (.: (.primitive (~ (code.text box.long))))) (` (.:coerce .Int))]]
    [type.float-descriptor type.double-descriptor (list (` "jvm conversion float-to-double")) [(` (.: (.primitive (~ (code.text box.double))))) (` (.:coerce .Frac))]]
    [type.double-descriptor type.double-descriptor (list) [(` (.: (.primitive (~ (code.text box.double))))) (` (.:coerce .Frac))]]
    [..string-descriptor ..string-descriptor (list) [(` (.: (.primitive (~ (code.text ..string-class))))) (` (.:coerce .Text))]]
    [..boolean-box-descriptor ..boolean-box-descriptor (list) [(` (.: (.primitive (~ (code.text ..boolean-box-class))))) (` (.:coerce .Bit))]]
    [..long-box-descriptor ..long-box-descriptor (list) [(` (.: (.primitive (~ (code.text ..long-box-class))))) (` (.:coerce .Int))]]
    [..double-box-descriptor ..double-box-descriptor (list) [(` (.: (.primitive (~ (code.text ..double-box-class))))) (` (.:coerce .Frac))]]]]
  )

(def: (un-quote quoted)
  (-> Code Code)
  (` ((~' ~) (~ quoted))))

(def: (jvm-invoke-inputs mode classes inputs)
  (-> Primitive-Mode (List Text) (List [Bit Code]) (List Code))
  (|> inputs
      (list@map (function (_ [maybe? input])
                  (if maybe?
                    (` ((~! !!!) (~ (un-quote input))))
                    (un-quote input))))
      (list.zip2 classes)
      (list@map (auto-convert-input mode))))

(def: (with-class-type class expression)
  (-> Text Code Code)
  (` (.: (.primitive (~ (code.text class))) (~ expression))))

(def: (member-def-interop vars kind class [arg-function-inputs arg-classes arg-types] member method-prefix)
  (-> (List Variable) Class-Kind Class-Declaration [(List [Bit Code]) (List Text) (List Code)] Import-Member-Declaration Text (Meta (List Code)))
  (let [[full-name class-tvars] class
        all-params (list@map var->type-arg (member-type-vars class-tvars member))]
    (case member
      (#EnumDecl enum-members)
      (do macro.monad
        [#let [enum-type (: Code
                            (case class-tvars
                              #.Nil
                              (` (primitive (~ (code.text full-name))))

                              _
                              (let [=class-tvars (list@map var->type-arg class-tvars)]
                                (` (All [(~+ =class-tvars)] (primitive (~ (code.text full-name)) [(~+ =class-tvars)]))))))
               getter-interop (: (-> Text Code)
                                 (function (_ name)
                                   (let [getter-name (code.identifier ["" (format method-prefix member-separator name)])]
                                     (` (def: (~ getter-name)
                                          (~ enum-type)
                                          (~ (get-static-field full-name name)))))))]]
        (wrap (list@map getter-interop enum-members)))
      
      (#ConstructorDecl [commons _])
      (do macro.monad
        [#let [def-name (code.identifier ["" (format method-prefix member-separator (get@ #import-member-alias commons))])
               jvm-interop (|> [(type.signature (type.class full-name (list)))
                                (` ("jvm member invoke constructor"
                                    (~ (code.text full-name))
                                    (~+ (|> (jvm-invoke-inputs (get@ #import-member-mode commons) arg-classes arg-function-inputs)
                                            (list.zip2 arg-classes)
                                            (list@map ..decorate-input)))))]
                               (auto-convert-output (get@ #import-member-mode commons))
                               (decorate-return-maybe member true full-name)
                               (decorate-return-try member)
                               (decorate-return-io member))]]
        (wrap (list (` ((~! syntax:) ((~ def-name) (~+ (list@map product.right arg-function-inputs)))
                        ((~' wrap) (.list (.` (~ jvm-interop)))))))))

      (#MethodDecl [commons method])
      (with-gensyms [g!obj]
        (do @
          [#let [def-name (code.identifier ["" (format method-prefix member-separator (get@ #import-member-alias commons))])
                 (^slots [#import-member-kind]) commons
                 (^slots [#import-method-name]) method
                 [jvm-op object-ast] (: [Text (List Code)]
                                        (case import-member-kind
                                          #StaticIMK
                                          ["jvm member invoke static"
                                           (list)]

                                          #VirtualIMK
                                          (case kind
                                            #Class
                                            ["jvm member invoke virtual"
                                             (list g!obj)]
                                            
                                            #Interface
                                            ["jvm member invoke interface"
                                             (list g!obj)]
                                            )))
                 method-return-class (case (get@ #import-method-return method)
                                       #.None
                                       type.void-descriptor

                                       (#.Some return)
                                       (type.signature return))
                 jvm-interop (|> [method-return-class
                                  (` ((~ (code.text jvm-op))
                                      (~ (code.text full-name))
                                      (~ (code.text import-method-name))
                                      (~+ (|> object-ast
                                              (list@map ..un-quote)
                                              (list.zip2 (list (type.signature (type.class full-name (list)))))
                                              (list@map (auto-convert-input (get@ #import-member-mode commons)))))
                                      (~+ (|> (jvm-invoke-inputs (get@ #import-member-mode commons) arg-classes arg-function-inputs)
                                              (list.zip2 arg-classes)
                                              (list@map ..decorate-input)))))]
                                 (auto-convert-output (get@ #import-member-mode commons))
                                 (decorate-return-maybe member false method-return-class)
                                 (decorate-return-try member)
                                 (decorate-return-io member))]]
          (wrap (list (` ((~! syntax:) ((~ def-name) (~+ (list@map product.right arg-function-inputs)) (~+ object-ast))
                          ((~' wrap) (.list (.` (~ jvm-interop))))))))))

      (#FieldAccessDecl fad)
      (do macro.monad
        [#let [(^open ".") fad
               base-gtype (value-type import-field-mode import-field-type)
               classC (declaration-type$ class)
               typeC (if import-field-maybe?
                       (` (Maybe (~ base-gtype)))
                       base-gtype)
               tvar-asts (list@map var->type-arg class-tvars)
               getter-name (code.identifier ["" (format method-prefix member-separator import-field-name)])
               setter-name (code.identifier ["" (format method-prefix member-separator import-field-name "!")])]
         getter-interop (with-gensyms [g!obj]
                          (let [getter-call (if import-field-static?
                                              (` ((~ getter-name)))
                                              (` ((~ getter-name) (~ g!obj))))
                                getter-body (<| (auto-convert-output import-field-mode)
                                                [(type.signature import-field-type)
                                                 (if import-field-static?
                                                   (get-static-field full-name import-field-name)
                                                   (get-virtual-field full-name import-field-name (un-quote g!obj)))])
                                getter-body (if import-field-maybe?
                                              (` ((~! ???) (~ getter-body)))
                                              getter-body)
                                getter-body (if import-field-setter?
                                              (` ((~! io.io) (~ getter-body)))
                                              getter-body)]
                            (wrap (` ((~! syntax:) (~ getter-call)
                                      ((~' wrap) (.list (.` (~ getter-body)))))))))
         setter-interop (: (Meta (List Code))
                           (if import-field-setter?
                             (with-gensyms [g!obj g!value]
                               (let [setter-call (if import-field-static?
                                                   (` ((~ setter-name) (~ g!value)))
                                                   (` ((~ setter-name) (~ g!value) (~ g!obj))))
                                     setter-value (|> [(type.signature import-field-type) (un-quote g!value)]
                                                      (auto-convert-input import-field-mode))
                                     setter-value (if import-field-maybe?
                                                    (` ((~! !!!) (~ setter-value)))
                                                    setter-value)
                                     setter-command (format (if import-field-static? "jvm putstatic" "jvm putfield")
                                                            ":" full-name ":" import-field-name)
                                     g!obj+ (: (List Code)
                                               (if import-field-static?
                                                 (list)
                                                 (list (un-quote g!obj))))]
                                 (wrap (list (` ((~! syntax:) (~ setter-call)
                                                 ((~' wrap) (.list (.` ((~! io.io) ((~ (code.text setter-command)) (~+ g!obj+) (~ setter-value))))))))))))
                             (wrap (list))))]
        (wrap (list& getter-interop setter-interop)))
      )))

(def: (member-import$ vars long-name? kind class member)
  (-> (List Variable) Bit Class-Kind Class-Declaration Import-Member-Declaration (Meta (List Code)))
  (let [[full-name _] class
        method-prefix (if long-name?
                        full-name
                        (short-class-name full-name))]
    (do macro.monad
      [=args (member-def-arg-bindings vars class member)]
      (member-def-interop vars kind class =args member method-prefix))))

(def: interface?
  (All [a] (-> (primitive "java.lang.Class" [a]) Bit))
  (|>> ("jvm member invoke virtual" "java.lang.Class" "isInterface")
       "jvm object cast"
       (: ..Boolean)
       (:coerce Bit)))

(def: load-class
  (-> Text (Try (primitive "java.lang.Class" [Any])))
  (|>> (:coerce (primitive "java.lang.String"))
       ["Ljava/lang/String;"]
       ("jvm member invoke static" "java.lang.Class" "forName")
       try))

(def: (class-kind [class-name _])
  (-> Class-Declaration (Meta Class-Kind))
  (case (load-class class-name)
    (#.Right class)
    (:: macro.monad wrap (if (interface? class)
                           #Interface
                           #Class))

    (#.Left _)
    (macro.fail (format "Unknown class: " class-name))))

(syntax: #export (import:
                   {#let [imports (class-imports *compiler*)]}
                   {long-name? (<>.parses? (<c>.this! (' #long)))}
                   {declaration (declaration^ imports)}
                   {#let [full-class-name (product.left declaration)
                          imports (add-import [(short-class-name full-class-name) full-class-name]
                                              (class-imports *compiler*))]}
                   {members (<>.some (import-member-decl^ imports (product.right declaration)))})
  {#.doc (doc "Allows importing JVM classes, and using them as types."
              "Their methods, fields and enum options can also be imported."
              "Also, classes which get imported into a module can also be referred-to with their short names in other macros that require JVM classes."
              (import: java/lang/Object
                (new [])
                (equals [Object] boolean)
                (wait [int] #io #try void))
              
              "Special options can also be given for the return values."
              "#? means that the values will be returned inside a Maybe type. That way, null becomes #.None."
              "#try means that the computation might throw an exception, and the return value will be wrapped by the Try type."
              "#io means the computation has side effects, and will be wrapped by the IO type."
              "These options must show up in the following order [#io #try #?] (although, each option can be used independently)."
              (import: java/lang/String
                (new [[byte]])
                (#static valueOf [char] String)
                (#static valueOf #as int-valueOf [int] String))

              (import: #long (java/util/List e)
                (size [] int)
                (get [int] e))

              (import: (java/util/ArrayList a)
                ([T] toArray [[T]] [T]))
              
              "#long makes it so the class-type that is generated is of the fully-qualified name."
              "In this case, it avoids a clash between the java.util.List type, and Lux's own List type."
              "All enum options to be imported must be specified."
              (import: java/lang/Character$UnicodeScript
                (#enum ARABIC CYRILLIC LATIN))

              "It should also be noted, the only types that may show up in method arguments or return values may be Java classes, arrays, primitives, void or type-vars."
              "Lux types, such as Maybe cannot be named (otherwise, they'd be confused for Java classes)."
              (import: #long (lux/concurrency/promise/JvmPromise A)
                (resolve [A] boolean)
                (poll [] A)
                (wasResolved [] boolean)
                (waitOn [lux/Function] void)
                (#static [A] make [A] (JvmPromise A)))
              
              "Also, the names of the imported members will look like Class::member"
              (Object::new [])
              (Object::equals [other-object] my-object)
              (java/util/List::size [] my-list)
              Character$UnicodeScript::LATIN
              )}
  (do macro.monad
    [kind (class-kind declaration)
     =members (monad.map @ (member-import$ (product.right declaration) long-name? kind declaration) members)]
    (wrap (list& (class-import$ long-name? declaration) (list@join =members)))))

(syntax: #export (array {#let [imports (class-imports *compiler*)]}
                        {type (..type^ imports (list))}
                        size)
  {#.doc (doc "Create an array of the given type, with the given size."
              (array java/lang/Object 10))}
  (let [g!size (` (|>  (~ size)
                       (.: .Nat)
                       (.:coerce (.primitive (~ (code.text box.long))))
                       "jvm object cast"
                       "jvm conversion long-to-int"))]
    (case type
      (^template [<primitive> <array-op>]
        (^ (#jvm.Primitive <primitive>))
        (wrap (list (` (<array-op> (~ g!size))))))
      ([#jvm.Boolean "jvm array new boolean"]
       [#jvm.Byte    "jvm array new byte"]
       [#jvm.Short   "jvm array new short"]
       [#jvm.Int     "jvm array new int"]
       [#jvm.Long    "jvm array new long"]
       [#jvm.Float   "jvm array new float"]
       [#jvm.Double  "jvm array new double"]
       [#jvm.Char    "jvm array new char"])

      _
      (wrap (list (` (: (~ (value-type #ManualPrM (type.array 1 type)))
                        ("jvm array new object" (~ g!size)))))))))

(def: (type->class-name type)
  (-> .Type (Meta Text))
  (if (lux-type@= Any type)
    (:: macro.monad wrap "java.lang.Object")
    (case type
      (#.Primitive name params)
      (:: macro.monad wrap name)

      (#.Apply A F)
      (case (lux-type.apply (list A) F)
        #.None
        (macro.fail (format "Cannot apply type: " (%.type F) " to " (%.type A)))

        (#.Some type')
        (type->class-name type'))
      
      (#.Named _ type')
      (type->class-name type')

      _
      (macro.fail (format "Cannot convert to JVM type: " (%.type type))))))

(syntax: #export (array-length array)
  {#.doc (doc "Gives the length of an array."
              (array-length my-array))}
  (case array
    [_ (#.Identifier array-name)]
    (do macro.monad
      [array-type (macro.find-type array-name)
       array-jvm-type (type->class-name array-type)
       #let [g!extension (code.text (case array-jvm-type
                                      "[Z" "jvm array length boolean"
                                      "[B" "jvm array length byte"
                                      "[S" "jvm array length short"
                                      "[I" "jvm array length int"
                                      "[J" "jvm array length long"
                                      "[F" "jvm array length float"
                                      "[D" "jvm array length double"
                                      "[C" "jvm array length char"
                                      _ "jvm array length object"))]]
      (wrap (list (` (.|> ((~ g!extension) (~ array))
                          "jvm conversion int-to-long"
                          "jvm object cast"
                          (.: (.primitive (~ (code.text box.long))))
                          (.:coerce .Nat))))))

    _
    (with-gensyms [g!array]
      (wrap (list (` (let [(~ g!array) (~ array)]
                       (..array-length (~ g!array)))))))))

(syntax: #export (array-read idx array)
  {#.doc (doc "Loads an element from an array."
              (array-read 10 my-array))}
  (case array
    [_ (#.Identifier array-name)]
    (do macro.monad
      [array-type (macro.find-type array-name)
       array-jvm-type (type->class-name array-type)
       #let [g!idx (` (.|> (~ idx)
                           (.: .Nat)
                           (.:coerce (.primitive (~ (code.text box.long))))
                           "jvm object cast"
                           "jvm conversion long-to-int"))]]
      (case array-jvm-type
        (^template [<type> <array-op> <box>]
          <type>
          (wrap (list (` (.|> (<array-op> (~ g!idx) (~ array))
                              "jvm object cast"
                              (.: (.primitive (~ (code.text <box>)))))))))
        (["[Z" "jvm array read boolean" box.boolean]
         ["[B" "jvm array read byte" box.byte]
         ["[S" "jvm array read short" box.short]
         ["[I" "jvm array read int" box.int]
         ["[J" "jvm array read long" box.long]
         ["[F" "jvm array read float" box.float]
         ["[D" "jvm array read double" box.double]
         ["[C" "jvm array read char" box.char])

        _
        (wrap (list (` ("jvm array read object" (~ g!idx) (~ array)))))))

    _
    (with-gensyms [g!array]
      (wrap (list (` (let [(~ g!array) (~ array)]
                       (..array-read (~ idx) (~ g!array)))))))))

(syntax: #export (array-write idx value array)
  {#.doc (doc "Stores an element into an array."
              (array-write 10 my-object my-array))}
  (case array
    [_ (#.Identifier array-name)]
    (do macro.monad
      [array-type (macro.find-type array-name)
       array-jvm-type (type->class-name array-type)
       #let [g!idx (` (.|> (~ idx)
                           (.: .Nat)
                           (.:coerce (.primitive (~ (code.text box.long))))
                           "jvm object cast"
                           "jvm conversion long-to-int"))]]
      (case array-jvm-type
        (^template [<type> <array-op> <box>]
          <type>
          (let [g!value (` (.|> (~ value)
                                (.:coerce (.primitive (~ (code.text <box>))))
                                "jvm object cast"))]
            (wrap (list (` (<array-op> (~ g!idx) (~ g!value) (~ array)))))))
        (["[Z" "jvm array write boolean" box.boolean]
         ["[B" "jvm array write byte" box.byte]
         ["[S" "jvm array write short" box.short]
         ["[I" "jvm array write int" box.int]
         ["[J" "jvm array write long" box.long]
         ["[F" "jvm array write float" box.float]
         ["[D" "jvm array write double" box.double]
         ["[C" "jvm array write char" box.char])

        _
        (wrap (list (` ("jvm array write object" (~ g!idx) (~ value) (~ array)))))))

    _
    (with-gensyms [g!array]
      (wrap (list (` (let [(~ g!array) (~ array)]
                       (..array-write (~ idx) (~ value) (~ g!array)))))))))

(syntax: #export (class-for {#let [imports (class-imports *compiler*)]}
                            {type (..type^ imports (list))})
  {#.doc (doc "Loads the class as a java.lang.Class object."
              (class-for java/lang/String))}
  (wrap (list (` ("jvm object class" (~ (code.text (reflection.class type))))))))

(def: get-compiler
  (Meta Lux)
  (function (_ compiler)
    (#.Right [compiler compiler])))

(def: #export (resolve class)
  {#.doc (doc "Given a potentially unqualified class name, qualifies it if necessary."
              (resolve "String")
              =>
              "java.lang.String")}
  (-> Text (Meta Text))
  (do macro.monad
    [*compiler* get-compiler]
    (wrap (qualify (class-imports *compiler*) class))))

(syntax: #export (type {#let [imports (class-imports *compiler*)]}
                       {type (..type^ imports (list))})
  (wrap (list (value-type #ManualPrM type))))
