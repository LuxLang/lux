(;module:
  lux
  (lux (control [monad #+ do Monad]
                [eq]
                ["p" parser])
       (data [text "text/" Monoid<Text>]
             text/format
             (coll [list "list/" Monad<List>]
                   [sequence]
                   [array]
                   [queue]
                   [set]
                   [dict #+ Dict]
                   (tree [rose]))
             [number "nat/" Codec<Text,Nat>]
             [product]
             [bool]
             [maybe])
       (time ["du" duration]
             ["da" date]
             ["i" instant])
       [meta]
       (meta [code]
             [syntax #+ syntax: Syntax]
             (syntax [common])
             [poly #+ poly:])
       (type [unit])
       (lang [type])
       ))

## [Derivers]
(poly: #export Eq<?>
  (`` (do @
        [#let [g!_ (code;local-symbol "\u0000_")]
         *env* poly;env
         inputT poly;peek
         #let [@Eq (: (-> Type Code)
                      (function [type]
                        (` (eq;Eq (~ (poly;to-ast *env* type))))))]]
        ($_ p;either
            ## Basic types
            (~~ (do-template [<matcher> <eq>]
                  [(do @
                     [_ <matcher>]
                     (wrap (` (: (~ (@Eq inputT))
                                 <eq>))))]

                  [poly;unit (function [(~ g!_) (~ g!_)] true)]
                  [poly;bool bool;Eq<Bool>]
                  [poly;nat  number;Eq<Nat>]
                  [poly;int  number;Eq<Int>]
                  [poly;deg  number;Eq<Deg>]
                  [poly;frac number;Eq<Frac>]
                  [poly;text text;Eq<Text>]))
            ## Composite types
            (~~ (do-template [<name> <eq>]
                  [(do @
                     [[_ argC] (poly;apply (p;seq (poly;this <name>)
                                                  Eq<?>))]
                     (wrap (` (: (~ (@Eq inputT))
                                 (<eq> (~ argC))))))]

                  [;Maybe            maybe;Eq<Maybe>]
                  [;List             list;Eq<List>]
                  [sequence;Sequence sequence;Eq<Sequence>]
                  [;Array            array;Eq<Array>]
                  [queue;Queue       queue;Eq<Queue>]
                  [set;Set           set;Eq<Set>]
                  [rose;Tree         rose;Eq<Tree>]
                  ))
            (do @
              [[_ _ valC] (poly;apply ($_ p;seq
                                          (poly;this dict;Dict)
                                          poly;any
                                          Eq<?>))]
              (wrap (` (: (~ (@Eq inputT))
                          (dict;Eq<Dict> (~ valC))))))
            ## Models
            (~~ (do-template [<type> <eq>]
                  [(do @
                     [_ (poly;this <type>)]
                     (wrap (` (: (~ (@Eq inputT))
                                 <eq>))))]

                  [du;Duration du;Eq<Duration>]
                  [i;Instant   i;Eq<Instant>]
                  [da;Date     da;Eq<Date>]
                  [da;Day      da;Eq<Day>]
                  [da;Month    da;Eq<Month>]))
            (do @
              [_ (poly;apply (p;seq (poly;this unit;Qty)
                                    poly;any))]
              (wrap (` (: (~ (@Eq inputT))
                          unit;Eq<Qty>))))
            ## Variants
            (do @
              [members (poly;variant (p;many Eq<?>))
               #let [g!left (code;local-symbol "\u0000left")
                     g!right (code;local-symbol "\u0000right")]]
              (wrap (` (: (~ (@Eq inputT))
                          (function [(~ g!left) (~ g!right)]
                            (case [(~ g!left) (~ g!right)]
                              (~@ (list/join (list/map (function [[tag g!eq]]
                                                         (list (` [((~ (code;nat tag)) (~ g!left))
                                                                   ((~ (code;nat tag)) (~ g!right))])
                                                               (` ((~ g!eq) (~ g!left) (~ g!right)))))
                                                       (list;enumerate members))))
                              (~ g!_)
                              false))))))
            ## Tuples
            (do @
              [g!eqs (poly;tuple (p;many Eq<?>))
               #let [indices (|> (list;size g!eqs) n.dec (list;n.range +0))
                     g!lefts (list/map (|>. nat/encode (text/compose "left") code;local-symbol) indices)
                     g!rights (list/map (|>. nat/encode (text/compose "right") code;local-symbol) indices)]]
              (wrap (` (: (~ (@Eq inputT))
                          (function [[(~@ g!lefts)] [(~@ g!rights)]]
                            (and (~@ (|> (list;zip3 g!eqs g!lefts g!rights)
                                         (list/map (function [[g!eq g!left g!right]]
                                                     (` ((~ g!eq) (~ g!left) (~ g!right)))))))))))))
            ## Type recursion
            (do @
              [[g!self bodyC] (poly;recursive Eq<?>)]
              (wrap (` (: (~ (@Eq inputT))
                          (eq;rec (;function [(~ g!self)]
                                    (~ bodyC)))))))
            poly;recursive-self
            ## Type applications
            (do @
              [[funcC argsC] (poly;apply (p;seq Eq<?> (p;many Eq<?>)))]
              (wrap (` ((~ funcC) (~@ argsC)))))
            ## Bound type-vars
            poly;bound
            ## Polymorphism
            (do @
              [[funcC varsC bodyC] (poly;polymorphic Eq<?>)]
              (wrap (` (: (All [(~@ varsC)]
                            (-> (~@ (list/map (|>. (~) eq;Eq (`)) varsC))
                                (eq;Eq ((~ (poly;to-ast *env* inputT)) (~@ varsC)))))
                          (function (~ funcC) [(~@ varsC)]
                            (~ bodyC))))))
            poly;recursive-call
            ## If all else fails...
            (|> poly;any
                (:: @ map (|>. %type (format "Cannot create Eq for: ") p;fail))
                (:: @ join))
            ))))
