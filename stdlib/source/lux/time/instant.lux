(.module:
  [lux #*
   [abstract
    [equivalence (#+ Equivalence)]
    [order (#+ Order)]
    [enum (#+ Enum)]
    [codec (#+ Codec)]
    [monad (#+ Monad do)]]
   [control
    [io (#+ IO io)]
    ["." exception (#+ exception:)]
    ["<>" parser
     ["<t>" text (#+ Parser)]]]
   [data
    ["." maybe]
    [number
     ["n" nat ("#@." decimal)]
     ["i" int ("#@." decimal)]]
    ["." text ("#@." monoid)]
    [collection
     ["." row]
     ["." list ("#@." fold)]]]
   [type
    abstract]]
  [//
   ["." duration (#+ Duration)]
   ["." year (#+ Year)]
   ["." month (#+ Month)]
   ["." day (#+ Day)]
   ["." date (#+ Date)]])

(abstract: #export Instant
  Int

  {#.doc "Instant is defined as milliseconds since the epoch."}

  (def: #export from-millis
    (-> Int Instant)
    (|>> :abstraction))

  (def: #export to-millis
    (-> Instant Int)
    (|>> :representation))

  (def: #export (span from to)
    (-> Instant Instant Duration)
    (duration.from-millis (i.- (:representation from) (:representation to))))

  (def: #export (shift duration instant)
    (-> Duration Instant Instant)
    (:abstraction (i.+ (duration.to-millis duration) (:representation instant))))

  (def: #export (relative instant)
    (-> Instant Duration)
    (|> instant :representation duration.from-millis))

  (def: #export (absolute offset)
    (-> Duration Instant)
    (|> offset duration.to-millis :abstraction))

  (structure: #export equivalence
    (Equivalence Instant)
    
    (def: (= param subject)
      (:: i.equivalence = (:representation param) (:representation subject))))

  (structure: #export order
    (Order Instant)
    
    (def: &equivalence ..equivalence)
    (def: (< param subject)
      (:: i.order < (:representation param) (:representation subject))))

  (`` (structure: #export enum
        (Enum Instant)
        
        (def: &order ..order)
        (~~ (template [<name>]
              [(def: <name>
                 (|>> :representation (:: i.enum <name>) :abstraction))]

              [succ] [pred]
              ))))
  )

(def: #export epoch
  {#.doc "The instant corresponding to 1970-01-01T00:00:00Z"}
  Instant
  (..from-millis +0))

(def: (pad value)
  (-> Nat Text)
  (if (n.< 10 value)
    (text@compose "0" (n@encode value))
    (n@encode value)))

(def: (adjust-negative space duration)
  (-> Duration Duration Duration)
  (if (duration.negative? duration)
    (duration.merge space duration)
    duration))

(def: (encode-millis millis)
  (-> Nat Text)
  (cond (n.= 0 millis)   ""
        (n.< 10 millis)  ($_ text@compose ".00" (n@encode millis))
        (n.< 100 millis) ($_ text@compose ".0" (n@encode millis))
        ## (n.< 1,000 millis)
        ($_ text@compose "." (n@encode millis))))

(def: millis-per-day
  (duration.query duration.milli-second duration.day))

(def: (date-time instant)
  (-> Instant [Date Duration])
  (let [offset (..to-millis instant)
        bce? (i.< +0 offset)
        [days day-time] (if bce?
                          (let [[days millis] (i./% ..millis-per-day offset)]
                            (case millis
                              +0 [days millis]
                              _ [(dec days) (i.+ ..millis-per-day millis)]))
                          (i./% ..millis-per-day offset))]
    [(date.from-days days)
     (duration.from-millis day-time)]))

(template [<value> <definition>]
  [(def: <definition> Text <value>)]

  ["T" date-suffix]
  
  [":" time-separator]
  ["Z" time-suffix]
  )

(def: #export (encode instant)
  (-> Instant Text)
  (let [[date time] (..date-time instant)
        time (if (:: duration.order < duration.empty time)
               (duration.merge duration.day time)
               time)
        [hours time] [(duration.query duration.hour time) (duration.frame duration.hour time)]
        [minutes time] [(duration.query duration.minute time) (duration.frame duration.minute time)]
        [seconds millis] [(duration.query duration.second time) (duration.frame duration.second time)]]
    ($_ text@compose
        (:: date.codec encode date)
        ..date-suffix (..pad (.nat hours))
        ..time-separator (..pad (.nat minutes))
        ..time-separator (..pad (.nat seconds))
        (|> millis
            (..adjust-negative duration.second)
            duration.to-millis
            .nat
            ..encode-millis)
        ..time-suffix)))

(def: parse-section
  (Parser Nat)
  (<>.codec n.decimal (<t>.exactly 2 <t>.decimal)))

(def: parse-millis
  (Parser Nat)
  (<>.either (|> (<t>.at-most 3 <t>.decimal)
                 (<>.codec n.decimal)
                 (<>.after (<t>.this ".")))
             (:: <>.monad wrap 0)))

(template [<minimum> <maximum> <parser> <exception>]
  [(exception: #export (<exception> {value Nat})
     (exception.report
      ["Value" (n@encode value)]
      ["Minimum" (n@encode <minimum>)]
      ["Maximum" (n@encode <maximum>)]))

   (def: <parser>
     (Parser Nat)
     (do <>.monad
       [value ..parse-section]
       (if (and (n.>= <minimum> value)
                (n.<= <maximum> value))
         (wrap value)
         (<>.lift (exception.throw <exception> [value])))))]

  [0 23 parse-hour invalid-hour]
  [0 59 parse-minute invalid-minute]
  [0 59 parse-second invalid-second]
  )

(def: parser
  (Parser Instant)
  (do {@ <>.monad}
    [days (:: @ map date.days date.parser)
     _ (<t>.this ..date-suffix)
     utc-hour (<>.before (<t>.this ..time-separator)
                         ..parse-hour)
     utc-minute (<>.before (<t>.this ..time-separator)
                           ..parse-minute)
     utc-second ..parse-second
     utc-millis (<>.before (<t>.this ..time-suffix)
                           ..parse-millis)]
    (wrap (|> (if (i.< +0 days)
                (|> duration.day
                    (duration.scale-up (.nat (i.* -1 days)))
                    duration.inverse)
                (duration.scale-up (.nat days) duration.day))
              (duration.merge (duration.scale-up utc-hour duration.hour))
              (duration.merge (duration.scale-up utc-minute duration.minute))
              (duration.merge (duration.scale-up utc-second duration.second))
              (duration.merge (duration.scale-up utc-millis duration.milli-second))
              ..absolute))))

(structure: #export codec
  {#.doc (doc "Based on ISO 8601."
              "For example: 2017-01-15T21:14:51.827Z")}
  (Codec Text Instant)
  
  (def: encode ..encode)
  (def: decode (<t>.run ..parser)))

(def: #export now
  (IO Instant)
  (io (..from-millis ("lux io current-time"))))

(def: #export (date instant)
  (-> Instant Date)
  (let [[date _] (..date-time instant)]
    date))

(def: #export (day-of-week instant)
  (-> Instant Day)
  (let [offset (..relative instant)
        days (duration.query duration.day offset)
        day-time (duration.frame duration.day offset)
        days (if (and (duration.negative? offset)
                      (not (duration.neutral? day-time)))
               (dec days)
               days)
        ## 1970/01/01 was a Thursday
        y1970m0d0 +4]
    (case (|> y1970m0d0
              (i.+ days) (i.% +7)
              ## This is done to turn negative days into positive days.
              (i.+ +7) (i.% +7))
      +0 #day.Sunday
      +1 #day.Monday
      +2 #day.Tuesday
      +3 #day.Wednesday
      +4 #day.Thursday
      +5 #day.Friday
      +6 #day.Saturday
      _ (undefined))))
