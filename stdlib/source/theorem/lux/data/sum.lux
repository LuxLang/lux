... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   ["_" theorem (.only)
    ["?" proposition]]
   [compiler
    [language
     [lux
      ["[0]" analysis]]]]
   [meta
    ["[0]" provenance]]
   [error
    ["[0]" try]]
   [abstract
    ["[0]" monad]]
   ["[0]" function]]]
 [\\library
  ["[0]" /]])

(the (either by_choice)
  (Change _.Rule)
  (all _.and
       (_.of _.by_definition (list _.as_is _.as_is by_choice))
       (_.by_when _.as_is
                  (function (_ ==)
                    (_.of' _.as_is (list (_.by ==)))))))

(the (then case by_choice)
  (-> (Change _.Rule)
      (Change _.Rule))
  (all _.and
       (_.of _.by_definition (list _.as_is _.as_is by_choice))
       (_.by_when _.as_is
                  (function (_ ==)
                    (case (_.of' _.as_is (list (_.by ==))))))))

(the any_either
  (_.= (either (_.of _.by_definition (list _.as_is)))
       _.as_is))

(_.the .public left_either
  (?.let [any_left any_right any]
    [left any_left
     right any_right
     on_left (-> any_left any)
     on_right (-> any_right any)]
    (?.= (/.either on_left on_right (/.left left))
         (on_left left)))
  ..any_either)

(_.the .public right_either
  (?.let [any_left any_right any]
    [left any_left
     right any_right
     on_left (-> any_left any)
     on_right (-> any_right any)]
    (?.= (/.either on_left on_right (/.right right))
         (on_right right)))
  ..any_either)

(the (any_then case)
  (-> (Change _.Rule)
      _.Proof)
  (_.= (all _.and
            (_.of _.by_definition
                  (list _.as_is
                        _.as_is
                        (_.of _.by_definition (list _.as_is))))
            (_.by_when _.as_is
                       (function (_ ==)
                         (case (_.of' _.as_is (list (_.by ==)))))))
       (_.of _.by_definition (list _.as_is))))

(_.the .public left_then
  (?.let [any_left any_right any]
    [left any_left
     right any_right
     on_left (-> any_left any)
     on_right (-> any_right any)]
    (?.= (/.then on_left on_right (/.left left))
         (/.left (on_left left))))
  (any_then _.left_case))

(_.the .public right_then
  (?.let [any_left any_right any]
    [left any_left
     right any_right
     on_left (-> any_left any)
     on_right (-> any_right any)]
    (?.= (/.then on_left on_right (/.right right))
         (/.right (on_right right))))
  (any_then _.right_case))

(the (valid? [left right])
  (-> [analysis.Term analysis.Term]
      Bit)
  (.with analysis.equivalence
    (= left right)))

(every .public Case
  (-> ?.Identity
      _.Proof))

... https://en.wikipedia.org/wiki/Mathematical_induction
(the .public (by_induction for_left for_right
                           [lux next_induction] it)
  (-> Case Case
      _.Proof)
  (monad.let try.monad
    [.let [content (?.term provenance.dummy next_induction)
           variable (_.induction_variable provenance.dummy next_induction)
           environment [lux (++ next_induction)]]
     left! (for_left [variable
                      (analysis.variant provenance.dummy [0 .false content])]
                     environment
                     it)
     right! (for_right [variable
                        (analysis.variant provenance.dummy [0 .true content])]
                       environment
                       it)]
    (pure (.if (valid? left!)
               right!
               left!))))

(_.the .public identity_by_either
  (?.let [any_left any_right]
    [it (Or any_left any_right)]
    (?.= (/.either /.left /.right it)
         it))
  (let [proof (function (_ =_it)
                (_.= (all _.and
                          (either (_.by =_it))
                          (_.of _.by_definition (list _.as_is)))
                     (_.by =_it)))]
    (by_induction proof proof)))

(_.the .public double_reversal
  (?.let [any_left any_right]
    [it (Or any_left any_right)]
    (?.= (/.either /.right /.left (/.either /.right /.left it))
         it))
  (let [proof (function (_ =_it)
                (_.= (all _.and
                          (either (all _.and
                                       (either (_.by =_it))
                                       (_.of _.by_definition (list _.as_is))))
                          (_.of _.by_definition (list _.as_is)))
                     (_.by =_it)))]
    (by_induction proof proof)))

(_.the .public identity_by_then
  (?.let [any_left any_right]
    [it (Or any_left any_right)]
    (?.= (/.then function.identity function.identity it)
         it))
  (let [proof (is (-> (Change _.Rule)
                      Case)
                  (function (_ case
                               =_it)
                    (_.= (all _.and
                              (then case (_.by =_it))
                              (case (_.of _.by_definition (list _.as_is))))
                         (_.by =_it))))]
    (by_induction (proof _.left_case) (proof _.right_case))))
