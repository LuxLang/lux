... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   ["_" theorem (.only)
    ["?" proposition]
    ["[0]" induction]]
   ["[0]" function]]]
 [\\library
  ["[0]" /]])

(the (either by_choice)
  (Change _.Rule)
  (all _.and
       (_.of _.by_definition (list _.as_is _.as_is by_choice))
       (_.by_when _.as_is
                  (function (_ ==)
                    (_.of' _.as_is (list (_.by ==)))))))

(the (then case by_choice)
  (-> (Change _.Rule)
      (Change _.Rule))
  (all _.and
       (_.of _.by_definition (list _.as_is _.as_is by_choice))
       (_.by_when _.as_is
                  (function (_ ==)
                    (case (_.of' _.as_is (list (_.by ==))))))))

(the any_either
  (_.= (either (_.of _.by_definition (list _.as_is)))
       _.as_is))

(_.the .public left_either
  (?.let [any_left any_right any]
    [left any_left
     right any_right
     on_left (-> any_left any)
     on_right (-> any_right any)]
    (?.= (/.either on_left on_right (/.left left))
         (on_left left)))
  ..any_either)

(_.the .public right_either
  (?.let [any_left any_right any]
    [left any_left
     right any_right
     on_left (-> any_left any)
     on_right (-> any_right any)]
    (?.= (/.either on_left on_right (/.right right))
         (on_right right)))
  ..any_either)

(the (any_then case)
  (-> (Change _.Rule)
      _.Proof)
  (_.= (all _.and
            (_.of _.by_definition
                  (list _.as_is
                        _.as_is
                        (_.of _.by_definition (list _.as_is))))
            (_.by_when _.as_is
                       (function (_ ==)
                         (case (_.of' _.as_is (list (_.by ==)))))))
       (_.of _.by_definition (list _.as_is))))

(_.the .public left_then
  (?.let [any_left any_right any]
    [left any_left
     right any_right
     on_left (-> any_left any)
     on_right (-> any_right any)]
    (?.= (/.then on_left on_right (/.left left))
         (/.left (on_left left))))
  (any_then _.left_case))

(_.the .public right_then
  (?.let [any_left any_right any]
    [left any_left
     right any_right
     on_left (-> any_left any)
     on_right (-> any_right any)]
    (?.= (/.then on_left on_right (/.right right))
         (/.right (on_right right))))
  (any_then _.right_case))

(_.the .public identity_by_either
  (?.let [any_left any_right]
    [it (Or any_left any_right)]
    (?.= (/.either /.left /.right it)
         it))
  (let [proof (function (_ =_it)
                (_.= (all _.and
                          (either (_.by =_it))
                          (_.of _.by_definition (list _.as_is)))
                     (_.by =_it)))]
    (induction.case proof proof)))

(_.the .public double_reversal
  (?.let [any_left any_right]
    [it (Or any_left any_right)]
    (?.= (/.either /.right /.left (/.either /.right /.left it))
         it))
  (let [proof (function (_ =_it)
                (_.= (all _.and
                          (either (all _.and
                                       (either (_.by =_it))
                                       (_.of _.by_definition (list _.as_is))))
                          (_.of _.by_definition (list _.as_is)))
                     (_.by =_it)))]
    (induction.case proof proof)))

(_.the .public identity_by_then
  (?.let [any_left any_right]
    [it (Or any_left any_right)]
    (?.= (/.then function.identity function.identity it)
         it))
  (let [proof (is (-> (Change _.Rule)
                      induction.Case)
                  (function (_ case
                               =_it)
                    (_.= (all _.and
                              (then case (_.by =_it))
                              (case (_.of _.by_definition (list _.as_is))))
                         (_.by =_it))))]
    (induction.case (proof _.left_case)
                    (proof _.right_case))))
