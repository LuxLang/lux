... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   ["_" theorem (.only)
    ["?" proposition]
    ["[0]" induction]]
   ["[0]" function]]]
 [\\library
  ["[0]" /]])

(_.the .public left
  (?.let [any_left any_right]
    [left any_left
     right any_right]
    (?.= (/.left [left right])
         left))
  (_.= (all _.and
            (_.of _.by_definition (list _.as_is))
            (_.by_when _.as_is
                       (_.with _.left_of_pair _.by)))
       _.as_is))

(_.the .public right
  (?.let [any_left any_right]
    [left any_left
     right any_right]
    (?.= (/.right [left right])
         right))
  (_.= (all _.and
            (_.of _.by_definition (list _.as_is))
            (_.by_when _.as_is
                       (_.with _.right_of_pair _.by)))
       _.as_is))

(_.the .public in_reverse
  (?.let [any_left any_right]
    [left any_left
     right any_right]
    (?.= (/.in_reverse [left right])
         [right left]))
  (_.= (all _.and
            (_.of _.by_definition (list _.as_is))
            (_.by_when _.as_is
                       ((_.with _.pair)
                        (function (_ [@left @right])
                          (_.by_pair (_.by @right) (_.by @left))))))
       _.as_is))

(_.the .public involution_of_in_reverse
  (?.let [any_left any_right]
    [left any_left
     right any_right]
    (?.= (/.in_reverse (/.in_reverse [left right]))
         [left right]))
  (let [by_reversal (_.by_when _.as_is
                               ((_.with _.pair)
                                (function (_ [@left @right])
                                  (_.by_pair (_.by @right) (_.by @left)))))]
    (_.= (all _.and
              (_.of _.by_definition (list (all _.and
                                               (_.of _.by_definition (list _.as_is))
                                               by_reversal)))
              by_reversal)
         _.as_is)))

(_.the intermediation
  (?.let [premise conclusion]
    [_ premise
     of (-> premise conclusion)]
    (?.= (function (_ it) (of it))
         of))
  (induction.function
    (_.= (_.of _.as_is (list _.as_is))
         _.as_is)))

(_.the .public uncurried_is_inverse_of_curried
  (?.let [any_left any_right any]
    [it (-> [any_left any_right] any)]
    (?.= (/.uncurried (/.curried it))
         it))
  (_.= (all _.and
            (_.of _.by_definition (list (_.of _.by_definition (list _.as_is))))
            (_.function (_.it _.as_is)
              (function (_ @0)
                (_.by_when _.as_is
                           (function (_ ==)
                             (all _.and
                                  (_.of (_.by @0) (list _.as_is _.as_is))
                                  (_.of' _.as_is (list (_.by ==))))))))
            (_.by ..intermediation))
       _.as_is))

(_.the .public curried_is_inverse_of_uncurried
  (?.let [any_left any_right any]
    [it (-> any_left any_right any)]
    (?.= (/.curried (/.uncurried it))
         it))
  (_.= (all _.and
            (_.of _.by_definition (list (_.of _.by_definition (list _.as_is))))
            ((_.function (_.it _.as_is))
             (function (_ @0)
               (all _.and
                    ((_.function (_.and' (_.it (_.by @0))
                                         (_.it _.as_is)))
                     (function (_ [@0 @1])
                       (all _.and
                            (_.of (_.by @0) (list (_.by_pair _.as_is _.as_is)))
                            (_.by_when _.as_is
                                       ((_.with _.pair)
                                        (function (_ [@left @right])
                                          (_.of' _.as_is (list (_.and (_.by @left)
                                                                      (_.by @1))
                                                               (_.by @right)))))))))
                    (_.by ..intermediation))))
            (_.by ..intermediation))
       _.as_is))

(_.the .public then
  (?.let [any_left any_right
          any_left' any_right']
    [left any_left
     right any_right
     by_left (-> any_left any_left')
     by_right (-> any_right any_right')]
    (?.= (/.then by_left by_right [left right])
         [(by_left left) (by_right right)]))
  (_.= (all _.and
            (_.of _.by_definition (list _.as_is _.as_is _.as_is))
            (_.by_when _.as_is
                       ((_.with _.pair)
                        (function (_ [@left @right])
                          (_.by_pair (_.of' _.as_is (list (_.by @left)))
                                     (_.of' _.as_is (list (_.by @right))))))))
       _.as_is))

(_.the .public identity_by_then
  (?.let [any_left any_right]
    [left any_left
     right any_right]
    (?.= (/.then function.identity function.identity [left right])
         [left right]))
  (let [by_identity (_.of _.by_definition (list _.as_is))]
    (_.= (all _.and
              (_.by ..then)
              (_.by_pair by_identity by_identity))
         _.as_is)))

(_.the .public forked
  (?.let [any any_left any_right]
    [it any
     by_left (-> any any_left)
     by_right (-> any any_right)]
    (?.= [(by_left it) (by_right it)]
         (/.forked by_left by_right it)))
  (_.= _.as_is
       (_.of _.by_definition (list _.as_is _.as_is _.as_is))))

(_.the .public identity_by_forked
  (?.let [any_left any_right]
    [it [any_left any_right]]
    (?.= (/.forked /.left /.right it)
         it))
  (induction.pair
   (function (_ @it)
     (_.= (all _.and
               (_.of' _.as_is (list _.as_is _.as_is (_.by @it)))
               (_.by (?.in_reverse ..forked))
               (_.by_pair (_.by ..left) (_.by ..right)))
          (_.by @it)))))
