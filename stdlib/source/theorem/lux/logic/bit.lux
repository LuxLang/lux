... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except or and if not)
   ["_" theorem (.only)
    ["?" proposition]
    ["!" proof (.only)
     ["[0]" induction]
     ["[0]" exhaustion]]
    ["in" substitution]
    ["by" rule]]
   [error
    ["[0]" try]]
   [abstract
    ["[0]" monad]]
   [meta
    ["[0]" provenance]]
   [compiler
    [language
     [lux
      ["[0]" analysis]]]]
   ["[0]" function]
   [macro
    ["[0]" template]]]]
 [\\library
  ["[0]" /]])

(the intact_branch
  in.Case
  (function.constant in.any))

(the intact_when
  [in.Case
   (List in.Case)]
  [..intact_branch
   (list ..intact_branch)])

(the .public (or this that)
  (-> in.Rule in.Rule
      in.Rule)
  (in.when this [..intact_branch
                 (list (function.constant that))]))

(the .public (and this that)
  (-> in.Rule in.Rule
      in.Rule)
  (in.when this [(function.constant that)
                 (list ..intact_branch)]))

(the (if cause effect)
  (-> in.Rule in.Rule
      in.Rule)
  (by.application (by.application in.any cause) effect))

(the (not it)
  (-> in.Rule
      in.Rule)
  (by.application in.any it))

... https://en.wikipedia.org/wiki/Boolean_algebra#Laws

(the (|not| it)
  (Change in.Rule)
  (all by.and
       (by.application by.definition it)
       by.reification
       (by.when in.any
         (function (_ _)
           in.any))))

(the |true|
  (all by.and
       by.definition
       (|not| by.definition)))

... Lemma
(_.the @false
  (?.= 0b
       .false)
  (!.= in.any
       by.definition))

(_.the @true
  (?.= 1b
       .true)
  (!.= in.any
       |true|))

(the (of/1 abstraction argument)
  (-> in.Rule in.Rule
      in.Rule)
  (all by.and
       (by.application abstraction argument)
       by.reification))

(_.the .public if_true
  (?.let [it]
    [then it
     else it]
    (?.= (.if .true
              then
              else)
         then))
  (!.= (by.when |true|
         (function (_ _)
           in.any))
       in.any))

(_.the .public if_false
  (?.let [it]
    [then it
     else it]
    (?.= (.if .false
              then
              else)
         else))
  (!.= (by.when by.definition
         (function (_ _)
           in.any))
       in.any))

(_.the .public true_is_not_false
  (?.= (.not .false)
       .true)
  (!.= in.any
       by.definition))

... https://en.wikipedia.org/wiki/Double_negation
(_.the .public double_negation
  (?.let [it Bit]
    (?.= (.not (.not it))
         it))
  (let [$= (function (_ ==)
             (!.= (|not| (|not| (by.= ==)))
                  (by.= ==)))]
    (induction.bit (function (_ =_false)
                     ($= =_false))
                   (function (_ =_true)
                     ($= =_true)))))

(_.the .public false_is_not_true
  (?.= (.not .true)
       .false)
  (!.= (all by.and
            (by.application in.any by.definition)
            (by.= double_negation))
       in.any))

... https://en.wikipedia.org/wiki/Idempotence
(template.with [,theorem ,composition ,if_false ,if_true]
  [(_.the .public ,theorem
     (?.let [it Bit]
       (?.= (,composition it it)
            it))
     (induction.bit (function (_ ==)
                      (!.= (by.when (by.= ==)
                             (function (_ _)
                               ,if_false))
                           (by.= ==)))
                    (function (_ ==)
                      (!.= (by.when (by.= ==)
                             (function (_ _)
                               ,if_true))
                           (by.= ==)))))]

  [[idempotence_of_or .or (by.= ==) in.any]
   [idempotence_of_and .and in.any (by.= ==)]])

(template.with [,theorem ,composition ,identity ,value]
  [(_.the .public ,theorem
     (?.let [it Bit]
       (?.= (,composition ,identity it)
            it))
     (!.= (by.when ,value
            (function (_ _)
              in.any))
          in.any))]

  [[identity_of_or .or .false by.definition]
   [identity_of_and .and .true |true|]])

(template.with [,theorem ,composition ,identity ,value]
  [(_.the .public ,theorem
     (?.let [it Bit]
       (?.= (,composition ,identity it)
            ,identity))
     (!.= (by.when ,value
            (function (_ _)
              in.any))
          ,value))]

  [[annihilation_of_or .or .true |true|]
   [annihilation_of_and .and .false by.definition]])

... https://en.wikipedia.org/wiki/Commutative_property
(_.the .public commutativity_of_or
  (?.let [this Bit
          that Bit]
    (?.= (.or this that)
         (.or that this)))
  (induction.bit (function (_ this_=_false)
                   (let [this_=_false (by.and (by.= this_=_false) (by.= @false))]
                     (induction.bit (function (_ that_=_false)
                                      (let [that_=_false (by.and (by.= that_=_false) (by.= @false))]
                                        (!.= (all by.and
                                                  (in.when this_=_false ..intact_when)
                                                  (by.= ..identity_of_or)
                                                  that_=_false)
                                             (all by.and
                                                  (in.when that_=_false ..intact_when)
                                                  (by.= ..identity_of_or)
                                                  this_=_false))))
                                    (function (_ that_=_true)
                                      (let [that_=_true (by.and (by.= that_=_true) (by.= @true))]
                                        (!.= (all by.and
                                                  (in.when this_=_false ..intact_when)
                                                  (by.= ..identity_of_or)
                                                  that_=_true)
                                             (all by.and
                                                  (in.when that_=_true ..intact_when)
                                                  (by.= ..annihilation_of_or))))))))
                 (function (_ this_=_true)
                   (let [this_=_true (by.and (by.= this_=_true) (by.= @true))]
                     (induction.bit (function (_ that_=_false)
                                      (let [that_=_false (by.and (by.= that_=_false) (by.= @false))]
                                        (!.= (all by.and
                                                  (in.when this_=_true ..intact_when)
                                                  (by.= ..annihilation_of_or))
                                             (all by.and
                                                  (in.when that_=_false ..intact_when)
                                                  (by.= ..identity_of_or)
                                                  this_=_true))))
                                    (function (_ that_=_true)
                                      (let [that_=_true (by.and (by.= that_=_true) (by.= @true))]
                                        (!.= (all by.and
                                                  (in.when this_=_true ..intact_when)
                                                  (by.= ..annihilation_of_or))
                                             (all by.and
                                                  (in.when that_=_true ..intact_when)
                                                  (by.= ..annihilation_of_or))))))))))

(_.the .public commutativity_of_and
  (?.let [this Bit
          that Bit]
    (?.= (.and this that)
         (.and that this)))
  (induction.bit (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @false))]
                     (induction.bit (function (_ =that)
                                      (let [=that (by.and (by.= =that) (by.= @false))]
                                        (!.= (all by.and
                                                  (in.when =this ..intact_when)
                                                  (by.= ..annihilation_of_and))
                                             (all by.and
                                                  (in.when =that ..intact_when)
                                                  (by.= ..annihilation_of_and)))))
                                    (function (_ =that)
                                      (let [=that (by.and (by.= =that) (by.= @true))]
                                        (!.= (all by.and
                                                  (in.when =this ..intact_when)
                                                  (by.= ..annihilation_of_and))
                                             (all by.and
                                                  (in.when =that ..intact_when)
                                                  (by.= ..identity_of_and)
                                                  =this)))))))
                 (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @true))]
                     (induction.bit (function (_ =that)
                                      (let [=that (by.and (by.= =that) (by.= @false))]
                                        (!.= (all by.and
                                                  (in.when =this ..intact_when)
                                                  (by.= ..identity_of_and)
                                                  =that)
                                             (all by.and
                                                  (in.when =that ..intact_when)
                                                  (by.= ..annihilation_of_and)))))
                                    (function (_ =that)
                                      (let [=that (by.and (by.= =that) (by.= @true))]
                                        (!.= (all by.and
                                                  (in.when =this ..intact_when)
                                                  (by.= ..identity_of_and)
                                                  =that)
                                             (all by.and
                                                  (in.when =that ..intact_when)
                                                  (by.= ..identity_of_and)
                                                  =this)))))))))

... https://en.wikipedia.org/wiki/Complement_(set_theory)
... https://en.wikipedia.org/wiki/Law_of_excluded_middle
(_.the .public complementation_of_or
  (?.let [it Bit]
    (?.= (.or it (.not it))
         .true))
  (induction.bit (function (_ =_false)
                   (let [=_false (by.and (by.= =_false) (by.= @false))]
                     (!.= (all by.and
                               (in.when =_false ..intact_when)
                               (by.= identity_of_or)
                               (by.application in.any =_false))
                          by.definition)))
                 (function (_ =_true)
                   (let [=_true (by.and (by.= =_true) (by.= @true))]
                     (!.= (all by.and
                               (in.when =_true ..intact_when)
                               (by.= annihilation_of_or))
                          in.any)))))

... https://en.wikipedia.org/wiki/Law_of_noncontradiction
(_.the .public complementation_of_and
  (?.let [it Bit]
    (?.= (.and it (.not it))
         .false))
  (induction.bit (function (_ =it)
                   (let [=it (by.and (by.= =it) (by.= @false))]
                     (!.= (all by.and
                               (in.when =it ..intact_when)
                               (by.= annihilation_of_and))
                          in.any)))
                 (function (_ =it)
                   (let [=it (by.and (by.= =it) (by.= @true))]
                     (!.= (all by.and
                               (in.when =it ..intact_when)
                               (by.= identity_of_and)
                               (by.application in.any =it)
                               (by.= false_is_not_true))
                          in.any)))))

... https://en.wikipedia.org/wiki/Associative_property
(_.the .public associativity_of_or
  (?.let [$0 Bit
          $1 Bit
          $2 Bit]
    (?.= (.or $0 (.or $1 $2))
         (.or (.or $0 $1) $2)))
  (induction.bit (function (_ $0_=_false)
                   (let [$0_=_false (by.and (by.= $0_=_false) (by.= @false))]
                     (induction.bit (function (_ $1_=_false)
                                      (let [$1_=_false (by.and (by.= $1_=_false) (by.= @false))]
                                        (!.= (all by.and
                                                  (in.when $0_=_false ..intact_when)
                                                  (by.= identity_of_or)
                                                  (in.when $1_=_false ..intact_when)
                                                  (by.= identity_of_or))
                                             (all by.and
                                                  (in.when (all by.and
                                                                (in.when $0_=_false ..intact_when)
                                                                (by.= identity_of_or)
                                                                $1_=_false)
                                                    ..intact_when)
                                                  (by.= identity_of_or)))))
                                    (function (_ $1_=_true)
                                      (let [$1_=_true (by.and (by.= $1_=_true) (by.= @true))]
                                        (!.= (all by.and
                                                  (in.when $0_=_false ..intact_when)
                                                  (by.= identity_of_or)
                                                  (in.when $1_=_true ..intact_when)
                                                  (by.= annihilation_of_or))
                                             (all by.and
                                                  (in.when (all by.and
                                                                (in.when $0_=_false ..intact_when)
                                                                (by.= identity_of_or)
                                                                $1_=_true)
                                                    ..intact_when)
                                                  (by.= annihilation_of_or))))))))
                 (function (_ $0_=_true)
                   (let [$0_=_true (by.and (by.= $0_=_true) (by.= @true))]
                     (!.= (all by.and
                               (in.when $0_=_true ..intact_when)
                               (by.= annihilation_of_or))
                          (all by.and
                               (in.when (all by.and
                                             (in.when $0_=_true ..intact_when)
                                             (by.= annihilation_of_or))
                                 ..intact_when)
                               (by.= annihilation_of_or)))))))

(_.the .public associativity_of_and
  (?.let [$0 Bit
          $1 Bit
          $2 Bit]
    (?.= (.and $0 (.and $1 $2))
         (.and (.and $0 $1) $2)))
  (induction.bit (function (_ =0)
                   (let [=0 (by.and (by.= =0) (by.= @false))]
                     (!.= (all by.and
                               (in.when =0 ..intact_when)
                               (by.= annihilation_of_and))
                          (all by.and
                               (in.when (all by.and
                                             (in.when =0 ..intact_when)
                                             (by.= annihilation_of_and))
                                 ..intact_when)
                               (by.= annihilation_of_and)))))
                 (function (_ =0)
                   (let [=0 (by.and (by.= =0) (by.= @true))]
                     (induction.bit (function (_ =1)
                                      (let [=1 (by.and (by.= =1) (by.= @false))]
                                        (!.= (all by.and
                                                  (in.when =0 ..intact_when)
                                                  (by.= identity_of_and)
                                                  (in.when =1 ..intact_when)
                                                  (by.= annihilation_of_and))
                                             (all by.and
                                                  (in.when (all by.and
                                                                (in.when =0 ..intact_when)
                                                                (by.= identity_of_and)
                                                                =1)
                                                    ..intact_when)
                                                  (by.= annihilation_of_and)))))
                                    (function (_ =1)
                                      (let [=1 (by.and (by.= =1) (by.= @true))]
                                        (!.= (all by.and
                                                  (in.when =0 ..intact_when)
                                                  (by.= identity_of_and)
                                                  (in.when =1 ..intact_when)
                                                  (by.= identity_of_and))
                                             (all by.and
                                                  (in.when (all by.and
                                                                (in.when =0 ..intact_when)
                                                                (by.= identity_of_and)
                                                                =1)
                                                    ..intact_when)
                                                  (by.= identity_of_and))))))))))

... https://en.wikipedia.org/wiki/Distributive_property
(_.the .public distributivity_of_or
  (?.let [$0 Bit
          $1 Bit
          $2 Bit]
    (?.= (.and (.or $0 $1) (.or $0 $2))
         (.or $0 (.and $1 $2))))
  (induction.bit (function (_ =_false)
                   (let [=_false (by.and (by.= =_false) (by.= @false))
                         $or_false (all by.and
                                        (in.when =_false ..intact_when)
                                        (by.= identity_of_or))]
                     (!.= (in.when $or_false
                            [(function.constant $or_false)
                             (list ..intact_branch)])
                          $or_false)))
                 (function (_ =_true)
                   (let [=_true (by.and (by.= =_true) (by.= @true))
                         $or_true (all by.and
                                       (in.when =_true ..intact_when)
                                       (by.= annihilation_of_or))]
                     (!.= (all by.and
                               (in.when $or_true
                                 [(function.constant $or_true)
                                  (list ..intact_branch)])
                               (by.= identity_of_and))
                          $or_true))
                   )))

(_.the .public distributivity_of_and
  (?.let [$0 Bit
          $1 Bit
          $2 Bit]
    (?.= (.or (.and $0 $1) (.and $0 $2))
         (.and $0 (.or $1 $2))))
  (induction.bit (function (_ =0)
                   (let [=0 (by.and (by.= =0) (by.= @false))
                         annihilation (all by.and
                                           (in.when =0 ..intact_when)
                                           (by.= annihilation_of_and))]
                     (!.= (all by.and
                               (in.when annihilation
                                 [..intact_branch
                                  (list (function.constant annihilation))])
                               (by.= identity_of_or))
                          annihilation)))
                 (function (_ =0)
                   (let [=0 (by.and (by.= =0) (by.= @true))
                         identity (all by.and
                                       (in.when =0 ..intact_when)
                                       (by.= identity_of_and))]
                     (!.= (in.when identity
                            [..intact_branch
                             (list (function.constant identity))])
                          identity))
                   )))

... https://en.wikipedia.org/wiki/De_Morgan%27s_laws
(_.the .public negation_of_or
  (?.let [this Bit
          that Bit]
    (?.= (.and (.not this) (.not that))
         (.not (.or this that))))
  (induction.bit (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @false))]
                     (!.= (all by.and
                               (in.when (all by.and
                                             (by.application in.any =this)
                                             (by.= true_is_not_false))
                                 ..intact_when)
                               (by.= identity_of_and))
                          (by.application in.any
                                          (all by.and
                                               (in.when =this ..intact_when)
                                               (by.= identity_of_or))))))
                 (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @true))]
                     (!.= (all by.and
                               (in.when (all by.and
                                             (by.application in.any =this)
                                             (by.= false_is_not_true))
                                 ..intact_when)
                               (by.= annihilation_of_and))
                          (all by.and
                               (by.application in.any
                                               (all by.and
                                                    (in.when =this ..intact_when)
                                                    (by.= annihilation_of_or)))
                               (by.= false_is_not_true)))))))

(_.the .public negation_of_and
  (?.let [this Bit
          that Bit]
    (?.= (.or (.not this) (.not that))
         (.not (.and this that))))
  (induction.bit (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @false))]
                     (!.= (all by.and
                               (in.when (all by.and
                                             (by.application in.any =this)
                                             (by.= true_is_not_false))
                                 ..intact_when)
                               (by.= annihilation_of_or))
                          (all by.and
                               (by.application in.any
                                               (all by.and
                                                    (in.when =this ..intact_when)
                                                    (by.= annihilation_of_and)))
                               (by.= true_is_not_false)))))
                 (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @true))]
                     (!.= (all by.and
                               (in.when (all by.and
                                             (by.application in.any =this)
                                             (by.= false_is_not_true))
                                 ..intact_when)
                               (by.= identity_of_or))
                          (by.application in.any
                                          (all by.and
                                               (in.when =this ..intact_when)
                                               (by.= identity_of_and))))))))

(_.the .public absorption_of_or
  (?.let [this Bit
          that Bit]
    (?.= (.or this (.and this that))
         this))
  (induction.bit (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @false))]
                     (!.= (all by.and
                               (in.when =this ..intact_when)
                               (by.= identity_of_or)
                               (in.when =this ..intact_when)
                               (by.= annihilation_of_and))
                          =this)))
                 (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @true))]
                     (!.= (all by.and
                               (in.when =this ..intact_when)
                               (by.= annihilation_of_or))
                          =this)))))

(_.the .public absorption_of_and
  (?.let [this Bit
          that Bit]
    (?.= (.and this (.or this that))
         this))
  (induction.bit (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @false))]
                     (!.= (all by.and
                               (in.when =this ..intact_when)
                               (by.= annihilation_of_and))
                          =this)))
                 (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @true))]
                     (!.= (all by.and
                               (in.when =this ..intact_when)
                               (by.= identity_of_and)
                               (in.when =this ..intact_when)
                               (by.= annihilation_of_or))
                          =this)))))

(_.the .public if_not
  (?.let [it]
    [test Bit
     then it
     else it]
    (?.= (.if (.not test)
              then
              else)
         (.if test
              else
              then)))
  (induction.bit (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @false))]
                     (!.= (all by.and
                               (in.when (all by.and
                                             (by.application in.any =this)
                                             (by.= true_is_not_false))
                                 ..intact_when)
                               (by.= if_true))
                          (all by.and
                               (in.when =this ..intact_when)
                               (by.= if_false)))))
                 (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @true))]
                     (!.= (all by.and
                               (in.when (all by.and
                                             (by.application in.any =this)
                                             (by.= false_is_not_true))
                                 ..intact_when)
                               (by.= if_false))
                          (all by.and
                               (in.when =this ..intact_when)
                               (by.= if_true)))))))

... https://en.wikipedia.org/wiki/Exclusive_or#Properties
(_.the .public identity_of_xor
  (?.let [it Bit]
    (?.= (/.xor .false it)
         it))
  (!.= (all by.and
            (of/1 (of/1 by.definition by.definition) in.any)
            (by.when in.any ..intact_branch))
       in.any))

(_.the .public negation_by_xor
  (?.let [it Bit]
    (?.= (/.xor .true it)
         (.not it)))
  (!.= (all by.and
            (of/1 (of/1 by.definition |true|) in.any)
            (by.when in.any ..intact_branch))
       in.any))

(_.the .public non_idempotence_of_xor
  (?.let [it Bit]
    (?.= (/.xor it it)
         .false))
  (induction.bit (function (_ =it)
                   (!.= (all by.and
                             (of/1 (of/1 by.definition (by.= =it)) (by.= =it))
                             (by.when in.any ..intact_branch))
                        by.definition))
                 (function (_ =it')
                   (let [=it (by.and (by.= =it') (by.= @true))]
                     (!.= (all by.and
                               (of/1 (of/1 by.definition (by.= =it')) =it)
                               (by.when in.any ..intact_branch)
                               (by.= false_is_not_true))
                          in.any)))))

... https://en.wikipedia.org/wiki/Complement_(set_theory)
(_.the .public complementation_of_xor
  (?.let [it Bit]
    (?.= (/.xor it (.not it))
         .true))
  (induction.bit (function (_ =it')
                   (let [=it (by.and (by.= =it') (by.= @false))]
                     (!.= (all by.and
                               (of/1 (of/1 by.definition (by.= =it'))
                                     (by.application in.any =it))
                               (by.when in.any ..intact_branch)
                               (by.= true_is_not_false))
                          in.any)))
                 (function (_ =it')
                   (let [=it (by.and (by.= =it') (by.= @true))]
                     (!.= (all by.and
                               (of/1 (of/1 by.definition (by.= =it'))
                                     (by.application in.any =it))
                               (by.when in.any ..intact_branch)
                               (by.= double_negation))
                          in.any)))))

... https://en.wikipedia.org/wiki/Commutative_property
(_.the .public commutativity_of_xor
  (?.let [this Bit
          that Bit]
    (?.= (/.xor this that)
         (/.xor that this)))
  (induction.bit (function (_ =this')
                   (let [=this (by.and (by.= =this') (by.= @false))]
                     (induction.bit (function (_ =that)
                                      (let [=that (by.and (by.= =that) (by.= @false))]
                                        (!.= (by.application (by.application in.any =this) =that)
                                             (by.application (by.application in.any =that) =this))))
                                    (function (_ =that')
                                      (let [=that (by.and (by.= =that') (by.= @true))]
                                        (!.= (all by.and
                                                  (of/1 (of/1 by.definition (by.= =this')) =that)
                                                  (by.when in.any ..intact_branch))
                                             (all by.and
                                                  (of/1 (of/1 by.definition (by.= =that')) =this)
                                                  (by.when in.any ..intact_branch)
                                                  (by.= true_is_not_false))))))))
                 (function (_ =this')
                   (let [=this (by.and (by.= =this') (by.= @true))]
                     (induction.bit (function (_ =that')
                                      (let [=that (by.and (by.= =that') (by.= @false))]
                                        (!.= (all by.and
                                                  (of/1 (of/1 by.definition (by.= =this')) =that)
                                                  (by.when in.any ..intact_branch)
                                                  (by.= true_is_not_false))
                                             (all by.and
                                                  (of/1 (of/1 by.definition (by.= =that')) =this)
                                                  (by.when in.any ..intact_branch)))))
                                    (function (_ =that)
                                      (let [=that (by.and (by.= =that) (by.= @true))]
                                        (!.= (by.application (by.application in.any =this) =that)
                                             (by.application (by.application in.any =that) =this)))))))))

(_.the .public negation_in_xor
  (?.let [this Bit
          that Bit]
    (?.= (/.xor (.not this) that)
         (.not (/.xor this that))))
  (induction.bit (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @false))]
                     (!.= (all by.and
                               (by.application (by.application in.any (all by.and
                                                                           (by.application in.any =this)
                                                                           (by.= true_is_not_false)))
                                               in.any)
                               (by.= negation_by_xor))
                          (by.application in.any
                                          (all by.and
                                               (by.application (by.application in.any =this)
                                                               in.any)
                                               (by.= identity_of_xor))))))
                 (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @true))]
                     (!.= (all by.and
                               (by.application (by.application in.any (all by.and
                                                                           (by.application in.any =this)
                                                                           (by.= false_is_not_true)))
                                               in.any)
                               (by.= identity_of_xor))
                          (all by.and
                               (by.application in.any
                                               (all by.and
                                                    (by.application (by.application in.any =this)
                                                                    in.any)
                                                    (by.= negation_by_xor)))
                               (by.= double_negation)))))))

... https://en.wikipedia.org/wiki/Associative_property
(_.the .public associativity_of_xor
  (?.let [$0 Bit
          $1 Bit
          $2 Bit]
    (?.= (/.xor $0 (/.xor $1 $2))
         (/.xor (/.xor $0 $1) $2)))
  (induction.bit (function (_ =0)
                   (let [=0 (by.and (by.= =0) (by.= @false))

                         identity_of_xor (all by.and
                                              (by.application (by.application in.any =0)
                                                              in.any)
                                              (by.= ..identity_of_xor))]
                     (!.= identity_of_xor
                          (by.application (by.application in.any identity_of_xor)
                                          in.any))))
                 (function (_ =0)
                   (let [=0 (by.and (by.= =0) (by.= @true))

                         negation_by_xor (all by.and
                                              (by.application (by.application in.any =0)
                                                              in.any)
                                              (by.= ..negation_by_xor))]
                     (!.= negation_by_xor
                          (all by.and
                               (by.application (by.application in.any negation_by_xor)
                                               in.any)
                               (by.= ..negation_in_xor)))))))

(_.the .public xor_is_an_involution
  (?.let [this Bit
          that Bit]
    (?.= (/.xor that (/.xor that this))
         this))
  (!.= (all by.and
            (by.= associativity_of_xor)
            (by.application (by.application in.any (by.= non_idempotence_of_xor))
                            in.any)
            (by.= identity_of_xor))
       in.any))

(_.the .public distributivity_in_xor
  (?.let [$0 Bit
          $1 Bit
          $2 Bit]
    (?.= (/.xor (.and $0 $1) (.and $0 $2))
         (.and $0 (/.xor $1 $2))))
  (induction.bit (function (_ =0)
                   (let [=0 (by.and (by.= =0) (by.= @false))

                         annihilation_of_and (all by.and
                                                  (in.when =0 ..intact_when)
                                                  (by.= ..annihilation_of_and))]
                     (!.= (all by.and
                               (by.application (by.application in.any annihilation_of_and)
                                               annihilation_of_and)
                               (by.= non_idempotence_of_xor))
                          annihilation_of_and)))
                 (function (_ =0)
                   (let [=0 (by.and (by.= =0) (by.= @true))

                         identity_of_and (all by.and
                                              (in.when =0 ..intact_when)
                                              (by.= ..identity_of_and))]
                     (!.= (by.application (by.application in.any identity_of_and)
                                          identity_of_and)
                          identity_of_and)))))

... https://en.wikipedia.org/wiki/Material_conditional#Formal_properties
... https://en.wikipedia.org/wiki/Principle_of_explosion
(_.the .public principle_of_explosion
  (?.let [it Bit]
    (?.= (/.if .false it)
         .true))
  (!.= (all by.and
            (by.application (all by.and
                                 (by.application by.definition by.definition)
                                 by.reification)
                            in.any)
            by.reification
            (by.when in.any intact_branch))
       in.any))

(_.the .public identity_of_if
  (?.let [it Bit]
    (?.= (/.if .true it)
         it))
  (!.= (all by.and
            (by.application (all by.and
                                 (by.application by.definition |true|)
                                 by.reification)
                            in.any)
            by.reification
            (by.when in.any intact_branch))
       in.any))

... https://en.wikipedia.org/wiki/Reflexive_relation
(_.the .public reflexivity_of_if
  (?.let [it Bit]
    (?.= (/.if it it)
         .true))
  (induction.bit (function (_ =it)
                   (let [=it (by.and (by.= =it) (by.= @false))]
                     (!.= (all by.and
                               (by.application (by.application in.any =it) in.any)
                               (by.= principle_of_explosion))
                          in.any)))
                 (function (_ =it)
                   (let [=it (by.and (by.= =it) (by.= @true))]
                     (!.= (all by.and
                               (by.application (all by.and
                                                    (by.application by.definition =it)
                                                    by.reification)
                                               =it)
                               by.reification
                               (by.when |true| intact_branch))
                          in.any)))))

... https://en.wikipedia.org/wiki/Connected_relation
(_.the .public totality_of_if
  (?.let [this Bit
          that Bit]
    (?.= (.or (/.if this that)
              (/.if that this))
         .true))
  (induction.bit (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @false))]
                     (!.= (all by.and
                               (or (all by.and
                                        (by.application (by.application in.any =this) in.any)
                                        (by.= principle_of_explosion))
                                   in.any)
                               (by.= annihilation_of_or))
                          in.any)))
                 (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @true))]
                     (induction.bit (function (_ =that)
                                      (let [=that (by.and (by.= =that) (by.= @false))]
                                        (!.= (all by.and
                                                  (or in.any
                                                      (all by.and
                                                           (by.application (by.application in.any =that) in.any)
                                                           (by.= principle_of_explosion)))
                                                  (by.= commutativity_of_or)
                                                  (by.= annihilation_of_or))
                                             in.any)))
                                    (function (_ =that)
                                      (let [=that (by.and (by.= =that) (by.= @true))]
                                        (!.= (all by.and
                                                  (or (all by.and
                                                           (by.application (by.application in.any =this) =that)
                                                           (by.= reflexivity_of_if))
                                                      in.any)
                                                  (by.= annihilation_of_or))
                                             in.any))))))))

... https://en.wikipedia.org/wiki/Law_of_excluded_middle
(_.the .public complementation_of_if
  (?.let [this Bit
          that Bit]
    (?.= (.or (/.if this that)
              (/.if this (.not that)))
         .true))
  (induction.bit (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @false))
                         principle_of_explosion (all by.and
                                                     (by.application (by.application in.any =this) in.any)
                                                     (by.= ..principle_of_explosion))]
                     (!.= (all by.and
                               (or principle_of_explosion
                                   principle_of_explosion)
                               (by.= idempotence_of_or))
                          in.any)))
                 (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @true))

                         identity_of_if (all by.and
                                             (by.application (by.application in.any =this) in.any)
                                             (by.= ..identity_of_if))]
                     (!.= (all by.and
                               (or identity_of_if
                                   identity_of_if)
                               (by.= complementation_of_or))
                          in.any)))))

(_.the .public contraposition
  (?.let [this Bit
          that Bit]
    (?.= (/.if this that)
         (/.if (.not that) (.not this))))
  (induction.bit (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @false))
                         
                         principle_of_explosion (function (_ it)
                                                  (all by.and
                                                       (if it in.any)
                                                       (by.= ..principle_of_explosion)))]
                     (induction.bit (function (_ =that)
                                      (let [=that (by.and (by.= =that) (by.= @false))]
                                        (!.= (principle_of_explosion =this)
                                             (all by.and
                                                  (if (all by.and
                                                           (not =that)
                                                           (by.= true_is_not_false))
                                                      (all by.and
                                                           (not =this)
                                                           (by.= true_is_not_false)))
                                                  (by.= ..identity_of_if)))))
                                    (function (_ =that)
                                      (let [=that (by.and (by.= =that) (by.= @true))]
                                        (!.= (principle_of_explosion =this)
                                             (principle_of_explosion (all by.and
                                                                          (not =that)
                                                                          (by.= false_is_not_true)))))))))
                 (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @true))]
                     (induction.bit (function (_ =that)
                                      (let [=that (by.and (by.= =that) (by.= @false))]
                                        (!.= (if =this =that)
                                             (if (all by.and
                                                      (not =that)
                                                      (by.= true_is_not_false))
                                                 (all by.and
                                                      (not =this)
                                                      (by.= false_is_not_true))))))
                                    (function (_ =that)
                                      (let [=that (by.and (by.= =that) (by.= @true))]
                                        (!.= (all by.and
                                                  (if =this =that)
                                                  (by.= ..identity_of_if))
                                             (all by.and
                                                  (if (all by.and
                                                           (not =that)
                                                           (by.= false_is_not_true))
                                                      in.any)
                                                  (by.= ..principle_of_explosion))))))))))

... https://en.wikipedia.org/wiki/Import%E2%80%93export_(logic)
... https://en.wikipedia.org/wiki/Exportation_(logic)
(_.the .public import_export
  (?.let [this Bit
          that Bit
          return Bit]
    (?.= (/.if this (/.if that return))
         (/.if (.and this that) return)))
  (induction.bit (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @false))]
                     (!.= (all by.and
                               (if =this in.any)
                               (by.= principle_of_explosion))
                          (all by.and
                               (if (all by.and
                                        (and =this in.any)
                                        (by.= annihilation_of_and))
                                   in.any)
                               (by.= principle_of_explosion)))))
                 (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @true))]
                     (!.= (all by.and
                               (if =this in.any)
                               (by.= identity_of_if))
                          (all by.and
                               (if (all by.and
                                        (and =this in.any)
                                        (by.= identity_of_and))
                                   in.any)))))))

(_.the .public negation_of_if
  (?.let [this Bit
          that Bit
          return Bit]
    (?.= (.not (/.if this that))
         (.and this (.not that))))
  (induction.bit (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @false))]
                     (!.= (all by.and
                               (not (all by.and
                                         (if =this in.any)
                                         (by.= principle_of_explosion)))
                               (by.= false_is_not_true))
                          (all by.and
                               (and =this in.any)
                               (by.= annihilation_of_and)))))
                 (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @true))]
                     (!.= (not (all by.and
                                    (if =this in.any)
                                    (by.= ..identity_of_if)))
                          (all by.and
                               (and =this in.any)
                               (by.= identity_of_and)))))))

(_.the .public or_if
  (?.let [this Bit
          that Bit
          return Bit]
    (?.= (/.if this that)
         (.or (.not this) that)))
  (induction.bit (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @false))]
                     (!.= (all by.and
                               (if =this in.any)
                               (by.= principle_of_explosion))
                          (all by.and
                               (or (all by.and
                                        (not =this)
                                        (by.= true_is_not_false))
                                   in.any)
                               (by.= annihilation_of_or)))))
                 (function (_ =this)
                   (let [=this (by.and (by.= =this) (by.= @true))]
                     (!.= (all by.and
                               (if =this in.any)
                               (by.= ..identity_of_if))
                          (all by.and
                               (or (all by.and
                                        (not =this)
                                        (by.= false_is_not_true))
                                   in.any)
                               (by.= identity_of_or)))))))

(_.the .public necessity
  (?.let [it Bit]
    (?.= (/.if it .true)
         .true))
  (induction.bit (function (_ this)
                   (let [this (by.and (by.= this) (by.= @false))]
                     (!.= (all by.and
                               (if this in.any)
                               (by.= principle_of_explosion))
                          in.any)))
                 (function (_ this)
                   (let [this (by.and (by.= this) (by.= @true))]
                     (!.= (all by.and
                               (if this in.any)
                               (by.= ..identity_of_if))
                          in.any)))))

... https://en.wikipedia.org/wiki/Commutative_property
(_.the .public commutativity_of_if
  (?.let [this Bit
          that Bit
          return Bit]
    (?.= (/.if this (/.if that return))
         (/.if that (/.if this return))))
  (induction.bit (function (_ this)
                   (let [this (by.and (by.= this) (by.= @false))

                         principle_of_explosion (all by.and
                                                     (if this in.any)
                                                     (by.= ..principle_of_explosion))]
                     (!.= principle_of_explosion
                          (all by.and
                               (if in.any principle_of_explosion)
                               (by.= ..necessity)))))
                 (function (_ this)
                   (let [this (by.and (by.= this) (by.= @true))

                         identity_of_if (all by.and
                                             (if this in.any)
                                             (by.= ..identity_of_if))]
                     (!.= identity_of_if
                          (if in.any identity_of_if))))))

... https://en.wikipedia.org/wiki/Distributive_property
(_.the .public left_distributivity
  (?.let [this Bit
          that Bit
          return Bit]
    (?.= (/.if this (/.if that return))
         (/.if (/.if this that)
               (/.if this return))))
  (induction.bit (function (_ this)
                   (let [this (by.and (by.= this) (by.= @false))

                         principle_of_explosion (function (_ it)
                                                  (all by.and
                                                       (if it in.any)
                                                       (by.= ..principle_of_explosion)))]
                     (!.= (principle_of_explosion this)
                          (all by.and
                               (if (principle_of_explosion this)
                                   (principle_of_explosion this))
                               (by.= ..necessity)))))
                 (function (_ this)
                   (let [this (by.and (by.= this) (by.= @true))

                         identity_of_if (all by.and
                                             (if this in.any)
                                             (by.= ..identity_of_if))]
                     (!.= identity_of_if
                          (if identity_of_if
                              identity_of_if))))))

... https://en.wikipedia.org/wiki/Equality_(mathematics)#Basic_properties
(the (= this that)
  (-> in.Rule in.Rule
      in.Rule)
  (all by.and
       (by.application (all by.and
                            (by.application by.definition this)
                            by.reification)
                       that)
       by.reification))

... https://en.wikipedia.org/wiki/Reflexive_relation
(_.the .public reflexivity_of_=
  (?.let [it Bit]
    (?.= (/.= it it)
         .true))
  (induction.bit (function (_ it)
                   (let [it (by.and (by.= it) (by.= @false))]
                     (!.= (all by.and
                               (= it it)
                               (by.= ..if_false)
                               (by.= ..true_is_not_false))
                          in.any)))
                 (function (_ it)
                   (let [it (by.and (by.= it) (by.= @true))]
                     (!.= (all by.and
                               (= it it)
                               (by.= ..if_true))
                          in.any)))))

(_.the .public extraction_of_commonality
  (?.let [premise conclusion]
    [test Bit
     then premise
     else premise
     after (-> premise conclusion)]
    (?.= (.if test
              (after then)
              (after else))
         (after (.if test
                     then
                     else))))
  (let [proof (is (-> ?.Proposition ?.Proposition
                      induction.Case)
                  (function (_ @constant if_constant)
                    (function (_ =_test)
                      (let [=_test (by.and (by.= =_test) (by.= @constant))
                            if' (by.and (in.when =_test
                                          [..intact_branch
                                           (list ..intact_branch)])
                                        (by.= if_constant))]
                        (!.= if'
                             (by.application in.any if'))))))]
    (induction.bit (proof @false ..if_false)
                   (proof @true ..if_true))))

(_.the .public if_identical
  (?.let [any]
    [test Bit
     then_or_else any]
    (?.= (.if test
              then_or_else
              then_or_else)
         then_or_else))
  (let [proof (is (-> ?.Proposition ?.Proposition
                      induction.Case)
                  (function (_ @constant if_constant)
                    (function (_ =_test)
                      (let [=_test (by.and (by.= =_test) (by.= @constant))
                            if' (by.and (in.when =_test
                                          [..intact_branch
                                           (list ..intact_branch)])
                                        (by.= if_constant))]
                        (!.= if'
                             in.any)))))]
    (induction.bit (proof @false ..if_false)
                   (proof @true ..if_true))))

(_.the .public if_or
  (?.let [cause Bit
          effect Bit]
    (?.if (?.= (/.if cause effect)
               .true)
          (?.or (?.= cause
                     .false)
                (?.= effect
                     .true))))
  (<| !.if (function (_ cause_|-_effect))
      (!.or (function (_ |cause_=_false| |effect_=_true|)
              ((!.let [cause_|-_effect
                       (!.=' (by.of by.definition (list in.any in.any))
                             in.any)])
               (function (_ cause_|-_effect)
                 (exhaustion.if cause_|-_effect
                                (function (_ cause_=_1b effect_=_true)
                                  (|effect_=_true|
                                   (!.= (by.= effect_=_true)
                                        in.any)))
                                (function (_ cause_=_0b true_=_true)
                                  (|cause_=_false|
                                   (!.= (all by.and
                                             (by.= cause_=_0b)
                                             (by.= ..@false))
                                        in.any))))))))))

... https://en.wikipedia.org/wiki/Law_of_excluded_middle
(_.the .public bit
  (?.let [it Bit]
    (?.or (?.= it
               .false)
          (?.= it
               .true)))
  !.axiom)
