... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except or and if not)
   ["_" theorem (.only)
    ["?" proposition (.only Identity)]
    ["in" rule]
    ["[0]" induction]]
   [error
    ["[0]" try]]
   [abstract
    ["[0]" monad]]
   [meta
    ["[0]" provenance]]
   [compiler
    [language
     [lux
      ["[0]" analysis]]]]
   ["[0]" function]
   [macro
    ["[0]" template]]]]
 [\\library
  ["[0]" /]])

(the intact_branch
  in.Case
  (function.constant in.as_is))

(the intact_when
  [in.Case
   (List in.Case)]
  [..intact_branch
   (list ..intact_branch)])

(the (or this that)
  (-> in.Rule in.Rule
      in.Rule)
  (in.in_when this [..intact_branch
                    (list (function.constant that))]))

(the (and this that)
  (-> in.Rule in.Rule
      in.Rule)
  (in.in_when this [(function.constant that)
                    (list ..intact_branch)]))

(the (if cause effect)
  (-> in.Rule in.Rule
      in.Rule)
  (in.by_application (in.by_application in.as_is cause) effect))

(the (not it)
  (-> in.Rule
      in.Rule)
  (in.by_application in.as_is it))

... https://en.wikipedia.org/wiki/Boolean_algebra#Laws

(the (|not| it)
  (Change in.Rule)
  (all in.and
       (in.by_application in.by_definition it)
       in.by_reification
       (in.by_when in.as_is
                   (function (_ _)
                     in.as_is))))

(the |true|
  (all in.and
       in.by_definition
       (|not| in.by_definition)))

... Lemma
(_.the @false
  (?.= 0b
       .false)
  (_.= in.as_is
       in.by_definition))

(_.the @true
  (?.= 1b
       .true)
  (_.= in.as_is
       |true|))

(the (of/1 abstraction argument)
  (-> in.Rule in.Rule
      in.Rule)
  (all in.and
       (in.by_application abstraction argument)
       in.by_reification))

(_.the .public if_true
  (?.let [it]
    [then it
     else it]
    (?.= (.if .true
              then
              else)
         then))
  (all in.and
       (_.= (in.by_when |true|
                        (function (_ _)
                          in.as_is))
            in.as_is)
       _.qed))

(_.the .public if_false
  (?.let [it]
    [then it
     else it]
    (?.= (.if .false
              then
              else)
         else))
  (all in.and
       (_.= (in.by_when in.by_definition
                        (function (_ _)
                          in.as_is))
            in.as_is)
       _.qed))

(_.the .public true_is_not_false
  (?.= (.not .false)
       .true)
  (all in.and
       (_.= in.as_is
            in.by_definition)
       _.qed))

... https://en.wikipedia.org/wiki/Double_negation
(_.the .public double_negation
  (?.let [it Bit]
    (?.= (.not (.not it))
         it))
  (let [$= (function (_ ==)
             (_.= (|not| (|not| (in.by ==)))
                  (in.by ==)))]
    (induction.bit (function (_ =_false)
                     ($= =_false))
                   (function (_ =_true)
                     ($= =_true)))))

(_.the .public false_is_not_true
  (?.= (.not .true)
       .false)
  (all in.and
       (_.= (all in.and
                 (in.by_application in.as_is in.by_definition)
                 (in.by double_negation))
            in.as_is)
       _.qed))

... https://en.wikipedia.org/wiki/Idempotence
(template.with [,theorem ,composition ,if_false ,if_true]
  [(_.the .public ,theorem
     (?.let [it Bit]
       (?.= (,composition it it)
            it))
     (induction.bit (function (_ ==)
                      (_.= (in.by_when (in.by ==)
                                       (function (_ _)
                                         ,if_false))
                           (in.by ==)))
                    (function (_ ==)
                      (_.= (in.by_when (in.by ==)
                                       (function (_ _)
                                         ,if_true))
                           (in.by ==)))))]

  [[idempotence_of_or .or (in.by ==) in.as_is]
   [idempotence_of_and .and in.as_is (in.by ==)]])

(template.with [,theorem ,composition ,identity ,value]
  [(_.the .public ,theorem
     (?.let [it Bit]
       (?.= (,composition ,identity it)
            it))
     (_.= (in.by_when ,value
                      (function (_ _)
                        in.as_is))
          in.as_is))]

  [[identity_of_or .or .false in.by_definition]
   [identity_of_and .and .true |true|]])

(template.with [,theorem ,composition ,identity ,value]
  [(_.the .public ,theorem
     (?.let [it Bit]
       (?.= (,composition ,identity it)
            ,identity))
     (_.= (in.by_when ,value
                      (function (_ _)
                        in.as_is))
          ,value))]

  [[annihilation_of_or .or .true |true|]
   [annihilation_of_and .and .false in.by_definition]])

... https://en.wikipedia.org/wiki/Commutative_property
(_.the .public commutativity_of_or
  (?.let [this Bit
          that Bit]
    (?.= (.or this that)
         (.or that this)))
  (induction.bit (function (_ this_=_false)
                   (let [this_=_false (in.and (in.by this_=_false) (in.by @false))]
                     (induction.bit (function (_ that_=_false)
                                      (let [that_=_false (in.and (in.by that_=_false) (in.by @false))]
                                        (_.= (all in.and
                                                  (in.in_when this_=_false ..intact_when)
                                                  (in.by ..identity_of_or)
                                                  that_=_false)
                                             (all in.and
                                                  (in.in_when that_=_false ..intact_when)
                                                  (in.by ..identity_of_or)
                                                  this_=_false))))
                                    (function (_ that_=_true)
                                      (let [that_=_true (in.and (in.by that_=_true) (in.by @true))]
                                        (_.= (all in.and
                                                  (in.in_when this_=_false ..intact_when)
                                                  (in.by ..identity_of_or)
                                                  that_=_true)
                                             (all in.and
                                                  (in.in_when that_=_true ..intact_when)
                                                  (in.by ..annihilation_of_or))))))))
                 (function (_ this_=_true)
                   (let [this_=_true (in.and (in.by this_=_true) (in.by @true))]
                     (induction.bit (function (_ that_=_false)
                                      (let [that_=_false (in.and (in.by that_=_false) (in.by @false))]
                                        (_.= (all in.and
                                                  (in.in_when this_=_true ..intact_when)
                                                  (in.by ..annihilation_of_or))
                                             (all in.and
                                                  (in.in_when that_=_false ..intact_when)
                                                  (in.by ..identity_of_or)
                                                  this_=_true))))
                                    (function (_ that_=_true)
                                      (let [that_=_true (in.and (in.by that_=_true) (in.by @true))]
                                        (_.= (all in.and
                                                  (in.in_when this_=_true ..intact_when)
                                                  (in.by ..annihilation_of_or))
                                             (all in.and
                                                  (in.in_when that_=_true ..intact_when)
                                                  (in.by ..annihilation_of_or))))))))))

(_.the .public commutativity_of_and
  (?.let [this Bit
          that Bit]
    (?.= (.and this that)
         (.and that this)))
  (induction.bit (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @false))]
                     (induction.bit (function (_ =that)
                                      (let [=that (in.and (in.by =that) (in.by @false))]
                                        (_.= (all in.and
                                                  (in.in_when =this ..intact_when)
                                                  (in.by ..annihilation_of_and))
                                             (all in.and
                                                  (in.in_when =that ..intact_when)
                                                  (in.by ..annihilation_of_and)))))
                                    (function (_ =that)
                                      (let [=that (in.and (in.by =that) (in.by @true))]
                                        (_.= (all in.and
                                                  (in.in_when =this ..intact_when)
                                                  (in.by ..annihilation_of_and))
                                             (all in.and
                                                  (in.in_when =that ..intact_when)
                                                  (in.by ..identity_of_and)
                                                  =this)))))))
                 (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @true))]
                     (induction.bit (function (_ =that)
                                      (let [=that (in.and (in.by =that) (in.by @false))]
                                        (_.= (all in.and
                                                  (in.in_when =this ..intact_when)
                                                  (in.by ..identity_of_and)
                                                  =that)
                                             (all in.and
                                                  (in.in_when =that ..intact_when)
                                                  (in.by ..annihilation_of_and)))))
                                    (function (_ =that)
                                      (let [=that (in.and (in.by =that) (in.by @true))]
                                        (_.= (all in.and
                                                  (in.in_when =this ..intact_when)
                                                  (in.by ..identity_of_and)
                                                  =that)
                                             (all in.and
                                                  (in.in_when =that ..intact_when)
                                                  (in.by ..identity_of_and)
                                                  =this)))))))))

... https://en.wikipedia.org/wiki/Complement_(set_theory)
... https://en.wikipedia.org/wiki/Law_of_excluded_middle
(_.the .public complementation_of_or
  (?.let [it Bit]
    (?.= (.or it (.not it))
         .true))
  (induction.bit (function (_ =_false)
                   (let [=_false (in.and (in.by =_false) (in.by @false))]
                     (_.= (all in.and
                               (in.in_when =_false ..intact_when)
                               (in.by identity_of_or)
                               (in.by_application in.as_is =_false))
                          in.by_definition)))
                 (function (_ =_true)
                   (let [=_true (in.and (in.by =_true) (in.by @true))]
                     (_.= (all in.and
                               (in.in_when =_true ..intact_when)
                               (in.by annihilation_of_or))
                          in.as_is)))))

... https://en.wikipedia.org/wiki/Law_of_noncontradiction
(_.the .public complementation_of_and
  (?.let [it Bit]
    (?.= (.and it (.not it))
         .false))
  (induction.bit (function (_ =it)
                   (let [=it (in.and (in.by =it) (in.by @false))]
                     (_.= (all in.and
                               (in.in_when =it ..intact_when)
                               (in.by annihilation_of_and))
                          in.as_is)))
                 (function (_ =it)
                   (let [=it (in.and (in.by =it) (in.by @true))]
                     (_.= (all in.and
                               (in.in_when =it ..intact_when)
                               (in.by identity_of_and)
                               (in.by_application in.as_is =it)
                               (in.by false_is_not_true))
                          in.as_is)))))

... https://en.wikipedia.org/wiki/Associative_property
(_.the .public associativity_of_or
  (?.let [$0 Bit
          $1 Bit
          $2 Bit]
    (?.= (.or $0 (.or $1 $2))
         (.or (.or $0 $1) $2)))
  (induction.bit (function (_ $0_=_false)
                   (let [$0_=_false (in.and (in.by $0_=_false) (in.by @false))]
                     (induction.bit (function (_ $1_=_false)
                                      (let [$1_=_false (in.and (in.by $1_=_false) (in.by @false))]
                                        (_.= (all in.and
                                                  (in.in_when $0_=_false ..intact_when)
                                                  (in.by identity_of_or)
                                                  (in.in_when $1_=_false ..intact_when)
                                                  (in.by identity_of_or))
                                             (all in.and
                                                  (in.in_when (all in.and
                                                                   (in.in_when $0_=_false ..intact_when)
                                                                   (in.by identity_of_or)
                                                                   $1_=_false)
                                                              ..intact_when)
                                                  (in.by identity_of_or)))))
                                    (function (_ $1_=_true)
                                      (let [$1_=_true (in.and (in.by $1_=_true) (in.by @true))]
                                        (_.= (all in.and
                                                  (in.in_when $0_=_false ..intact_when)
                                                  (in.by identity_of_or)
                                                  (in.in_when $1_=_true ..intact_when)
                                                  (in.by annihilation_of_or))
                                             (all in.and
                                                  (in.in_when (all in.and
                                                                   (in.in_when $0_=_false ..intact_when)
                                                                   (in.by identity_of_or)
                                                                   $1_=_true)
                                                              ..intact_when)
                                                  (in.by annihilation_of_or))))))))
                 (function (_ $0_=_true)
                   (let [$0_=_true (in.and (in.by $0_=_true) (in.by @true))]
                     (_.= (all in.and
                               (in.in_when $0_=_true ..intact_when)
                               (in.by annihilation_of_or))
                          (all in.and
                               (in.in_when (all in.and
                                                (in.in_when $0_=_true ..intact_when)
                                                (in.by annihilation_of_or))
                                           ..intact_when)
                               (in.by annihilation_of_or)))))))

(_.the .public associativity_of_and
  (?.let [$0 Bit
          $1 Bit
          $2 Bit]
    (?.= (.and $0 (.and $1 $2))
         (.and (.and $0 $1) $2)))
  (induction.bit (function (_ =0)
                   (let [=0 (in.and (in.by =0) (in.by @false))]
                     (_.= (all in.and
                               (in.in_when =0 ..intact_when)
                               (in.by annihilation_of_and))
                          (all in.and
                               (in.in_when (all in.and
                                                (in.in_when =0 ..intact_when)
                                                (in.by annihilation_of_and))
                                           ..intact_when)
                               (in.by annihilation_of_and)))))
                 (function (_ =0)
                   (let [=0 (in.and (in.by =0) (in.by @true))]
                     (induction.bit (function (_ =1)
                                      (let [=1 (in.and (in.by =1) (in.by @false))]
                                        (_.= (all in.and
                                                  (in.in_when =0 ..intact_when)
                                                  (in.by identity_of_and)
                                                  (in.in_when =1 ..intact_when)
                                                  (in.by annihilation_of_and))
                                             (all in.and
                                                  (in.in_when (all in.and
                                                                   (in.in_when =0 ..intact_when)
                                                                   (in.by identity_of_and)
                                                                   =1)
                                                              ..intact_when)
                                                  (in.by annihilation_of_and)))))
                                    (function (_ =1)
                                      (let [=1 (in.and (in.by =1) (in.by @true))]
                                        (_.= (all in.and
                                                  (in.in_when =0 ..intact_when)
                                                  (in.by identity_of_and)
                                                  (in.in_when =1 ..intact_when)
                                                  (in.by identity_of_and))
                                             (all in.and
                                                  (in.in_when (all in.and
                                                                   (in.in_when =0 ..intact_when)
                                                                   (in.by identity_of_and)
                                                                   =1)
                                                              ..intact_when)
                                                  (in.by identity_of_and))))))))))

... https://en.wikipedia.org/wiki/Distributive_property
(_.the .public distributivity_of_or
  (?.let [$0 Bit
          $1 Bit
          $2 Bit]
    (?.= (.and (.or $0 $1) (.or $0 $2))
         (.or $0 (.and $1 $2))))
  (induction.bit (function (_ =_false)
                   (let [=_false (in.and (in.by =_false) (in.by @false))
                         $or_false (all in.and
                                        (in.in_when =_false ..intact_when)
                                        (in.by identity_of_or))]
                     (_.= (in.in_when $or_false
                                      [(function.constant $or_false)
                                       (list ..intact_branch)])
                          $or_false)))
                 (function (_ =_true)
                   (let [=_true (in.and (in.by =_true) (in.by @true))
                         $or_true (all in.and
                                       (in.in_when =_true ..intact_when)
                                       (in.by annihilation_of_or))]
                     (_.= (all in.and
                               (in.in_when $or_true
                                           [(function.constant $or_true)
                                            (list ..intact_branch)])
                               (in.by identity_of_and))
                          $or_true))
                   )))

(_.the .public distributivity_of_and
  (?.let [$0 Bit
          $1 Bit
          $2 Bit]
    (?.= (.or (.and $0 $1) (.and $0 $2))
         (.and $0 (.or $1 $2))))
  (induction.bit (function (_ =0)
                   (let [=0 (in.and (in.by =0) (in.by @false))
                         annihilation (all in.and
                                           (in.in_when =0 ..intact_when)
                                           (in.by annihilation_of_and))]
                     (_.= (all in.and
                               (in.in_when annihilation
                                           [..intact_branch
                                            (list (function.constant annihilation))])
                               (in.by identity_of_or))
                          annihilation)))
                 (function (_ =0)
                   (let [=0 (in.and (in.by =0) (in.by @true))
                         identity (all in.and
                                       (in.in_when =0 ..intact_when)
                                       (in.by identity_of_and))]
                     (_.= (in.in_when identity
                                      [..intact_branch
                                       (list (function.constant identity))])
                          identity))
                   )))

... https://en.wikipedia.org/wiki/De_Morgan%27s_laws
(_.the .public negation_of_or
  (?.let [this Bit
          that Bit]
    (?.= (.and (.not this) (.not that))
         (.not (.or this that))))
  (induction.bit (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @false))]
                     (_.= (all in.and
                               (in.in_when (all in.and
                                                (in.by_application in.as_is =this)
                                                (in.by true_is_not_false))
                                           ..intact_when)
                               (in.by identity_of_and))
                          (in.by_application in.as_is
                                             (all in.and
                                                  (in.in_when =this ..intact_when)
                                                  (in.by identity_of_or))))))
                 (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @true))]
                     (_.= (all in.and
                               (in.in_when (all in.and
                                                (in.by_application in.as_is =this)
                                                (in.by false_is_not_true))
                                           ..intact_when)
                               (in.by annihilation_of_and))
                          (all in.and
                               (in.by_application in.as_is
                                                  (all in.and
                                                       (in.in_when =this ..intact_when)
                                                       (in.by annihilation_of_or)))
                               (in.by false_is_not_true)))))))

(_.the .public negation_of_and
  (?.let [this Bit
          that Bit]
    (?.= (.or (.not this) (.not that))
         (.not (.and this that))))
  (induction.bit (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @false))]
                     (_.= (all in.and
                               (in.in_when (all in.and
                                                (in.by_application in.as_is =this)
                                                (in.by true_is_not_false))
                                           ..intact_when)
                               (in.by annihilation_of_or))
                          (all in.and
                               (in.by_application in.as_is
                                                  (all in.and
                                                       (in.in_when =this ..intact_when)
                                                       (in.by annihilation_of_and)))
                               (in.by true_is_not_false)))))
                 (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @true))]
                     (_.= (all in.and
                               (in.in_when (all in.and
                                                (in.by_application in.as_is =this)
                                                (in.by false_is_not_true))
                                           ..intact_when)
                               (in.by identity_of_or))
                          (in.by_application in.as_is
                                             (all in.and
                                                  (in.in_when =this ..intact_when)
                                                  (in.by identity_of_and))))))))

(_.the .public absorption_of_or
  (?.let [this Bit
          that Bit]
    (?.= (.or this (.and this that))
         this))
  (induction.bit (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @false))]
                     (_.= (all in.and
                               (in.in_when =this ..intact_when)
                               (in.by identity_of_or)
                               (in.in_when =this ..intact_when)
                               (in.by annihilation_of_and))
                          =this)))
                 (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @true))]
                     (_.= (all in.and
                               (in.in_when =this ..intact_when)
                               (in.by annihilation_of_or))
                          =this)))))

(_.the .public absorption_of_and
  (?.let [this Bit
          that Bit]
    (?.= (.and this (.or this that))
         this))
  (induction.bit (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @false))]
                     (_.= (all in.and
                               (in.in_when =this ..intact_when)
                               (in.by annihilation_of_and))
                          =this)))
                 (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @true))]
                     (_.= (all in.and
                               (in.in_when =this ..intact_when)
                               (in.by identity_of_and)
                               (in.in_when =this ..intact_when)
                               (in.by annihilation_of_or))
                          =this)))))

(_.the .public if_not
  (?.let [it]
    [test Bit
     then it
     else it]
    (?.= (.if (.not test)
              then
              else)
         (.if test
              else
              then)))
  (induction.bit (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @false))]
                     (_.= (all in.and
                               (in.in_when (all in.and
                                                (in.by_application in.as_is =this)
                                                (in.by true_is_not_false))
                                           ..intact_when)
                               (in.by if_true))
                          (all in.and
                               (in.in_when =this ..intact_when)
                               (in.by if_false)))))
                 (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @true))]
                     (_.= (all in.and
                               (in.in_when (all in.and
                                                (in.by_application in.as_is =this)
                                                (in.by false_is_not_true))
                                           ..intact_when)
                               (in.by if_false))
                          (all in.and
                               (in.in_when =this ..intact_when)
                               (in.by if_true)))))))

... https://en.wikipedia.org/wiki/Exclusive_or#Properties
(_.the .public identity_by_xor
  (?.let [it Bit]
    (?.= (/.xor .false it)
         it))
  (_.= (all in.and
            (of/1 (of/1 in.by_definition in.by_definition) in.as_is)
            (in.by_when in.as_is ..intact_branch))
       in.as_is))

(_.the .public negation_by_xor
  (?.let [it Bit]
    (?.= (/.xor .true it)
         (.not it)))
  (_.= (all in.and
            (of/1 (of/1 in.by_definition |true|) in.as_is)
            (in.by_when in.as_is ..intact_branch))
       in.as_is))

(_.the .public non_idempotence_of_xor
  (?.let [it Bit]
    (?.= (/.xor it it)
         .false))
  (induction.bit (function (_ =it)
                   (_.= (all in.and
                             (of/1 (of/1 in.by_definition (in.by =it)) (in.by =it))
                             (in.by_when in.as_is ..intact_branch))
                        in.by_definition))
                 (function (_ =it')
                   (let [=it (in.and (in.by =it') (in.by @true))]
                     (_.= (all in.and
                               (of/1 (of/1 in.by_definition (in.by =it')) =it)
                               (in.by_when in.as_is ..intact_branch)
                               (in.by false_is_not_true))
                          in.as_is)))))

... https://en.wikipedia.org/wiki/Complement_(set_theory)
(_.the .public complementation_of_xor
  (?.let [it Bit]
    (?.= (/.xor it (.not it))
         .true))
  (induction.bit (function (_ =it')
                   (let [=it (in.and (in.by =it') (in.by @false))]
                     (_.= (all in.and
                               (of/1 (of/1 in.by_definition (in.by =it'))
                                     (in.by_application in.as_is =it))
                               (in.by_when in.as_is ..intact_branch)
                               (in.by true_is_not_false))
                          in.as_is)))
                 (function (_ =it')
                   (let [=it (in.and (in.by =it') (in.by @true))]
                     (_.= (all in.and
                               (of/1 (of/1 in.by_definition (in.by =it'))
                                     (in.by_application in.as_is =it))
                               (in.by_when in.as_is ..intact_branch)
                               (in.by double_negation))
                          in.as_is)))))

... https://en.wikipedia.org/wiki/Commutative_property
(_.the .public commutativity_of_xor
  (?.let [this Bit
          that Bit]
    (?.= (/.xor this that)
         (/.xor that this)))
  (induction.bit (function (_ =this')
                   (let [=this (in.and (in.by =this') (in.by @false))]
                     (induction.bit (function (_ =that)
                                      (let [=that (in.and (in.by =that) (in.by @false))]
                                        (_.= (in.by_application (in.by_application in.as_is =this) =that)
                                             (in.by_application (in.by_application in.as_is =that) =this))))
                                    (function (_ =that')
                                      (let [=that (in.and (in.by =that') (in.by @true))]
                                        (_.= (all in.and
                                                  (of/1 (of/1 in.by_definition (in.by =this')) =that)
                                                  (in.by_when in.as_is ..intact_branch))
                                             (all in.and
                                                  (of/1 (of/1 in.by_definition (in.by =that')) =this)
                                                  (in.by_when in.as_is ..intact_branch)
                                                  (in.by true_is_not_false))))))))
                 (function (_ =this')
                   (let [=this (in.and (in.by =this') (in.by @true))]
                     (induction.bit (function (_ =that')
                                      (let [=that (in.and (in.by =that') (in.by @false))]
                                        (_.= (all in.and
                                                  (of/1 (of/1 in.by_definition (in.by =this')) =that)
                                                  (in.by_when in.as_is ..intact_branch)
                                                  (in.by true_is_not_false))
                                             (all in.and
                                                  (of/1 (of/1 in.by_definition (in.by =that')) =this)
                                                  (in.by_when in.as_is ..intact_branch)))))
                                    (function (_ =that)
                                      (let [=that (in.and (in.by =that) (in.by @true))]
                                        (_.= (in.by_application (in.by_application in.as_is =this) =that)
                                             (in.by_application (in.by_application in.as_is =that) =this)))))))))

(_.the .public negation_in_xor
  (?.let [this Bit
          that Bit]
    (?.= (/.xor (.not this) that)
         (.not (/.xor this that))))
  (induction.bit (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @false))]
                     (_.= (all in.and
                               (in.by_application (in.by_application in.as_is (all in.and
                                                                                   (in.by_application in.as_is =this)
                                                                                   (in.by true_is_not_false)))
                                                  in.as_is)
                               (in.by negation_by_xor))
                          (in.by_application in.as_is
                                             (all in.and
                                                  (in.by_application (in.by_application in.as_is =this)
                                                                     in.as_is)
                                                  (in.by identity_by_xor))))))
                 (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @true))]
                     (_.= (all in.and
                               (in.by_application (in.by_application in.as_is (all in.and
                                                                                   (in.by_application in.as_is =this)
                                                                                   (in.by false_is_not_true)))
                                                  in.as_is)
                               (in.by identity_by_xor))
                          (all in.and
                               (in.by_application in.as_is
                                                  (all in.and
                                                       (in.by_application (in.by_application in.as_is =this)
                                                                          in.as_is)
                                                       (in.by negation_by_xor)))
                               (in.by double_negation)))))))

... https://en.wikipedia.org/wiki/Associative_property
(_.the .public associativity_of_xor
  (?.let [$0 Bit
          $1 Bit
          $2 Bit]
    (?.= (/.xor $0 (/.xor $1 $2))
         (/.xor (/.xor $0 $1) $2)))
  (induction.bit (function (_ =0)
                   (let [=0 (in.and (in.by =0) (in.by @false))

                         identity_by_xor (all in.and
                                              (in.by_application (in.by_application in.as_is =0)
                                                                 in.as_is)
                                              (in.by ..identity_by_xor))]
                     (_.= identity_by_xor
                          (in.by_application (in.by_application in.as_is identity_by_xor)
                                             in.as_is))))
                 (function (_ =0)
                   (let [=0 (in.and (in.by =0) (in.by @true))

                         negation_by_xor (all in.and
                                              (in.by_application (in.by_application in.as_is =0)
                                                                 in.as_is)
                                              (in.by ..negation_by_xor))]
                     (_.= negation_by_xor
                          (all in.and
                               (in.by_application (in.by_application in.as_is negation_by_xor)
                                                  in.as_is)
                               (in.by ..negation_in_xor)))))))

(_.the .public xor_is_an_involution
  (?.let [this Bit
          that Bit]
    (?.= (/.xor that (/.xor that this))
         this))
  (_.= (all in.and
            (in.by associativity_of_xor)
            (in.by_application (in.by_application in.as_is (in.by non_idempotence_of_xor))
                               in.as_is)
            (in.by identity_by_xor))
       in.as_is))

(_.the .public distributivity_in_xor
  (?.let [$0 Bit
          $1 Bit
          $2 Bit]
    (?.= (/.xor (.and $0 $1) (.and $0 $2))
         (.and $0 (/.xor $1 $2))))
  (induction.bit (function (_ =0)
                   (let [=0 (in.and (in.by =0) (in.by @false))

                         annihilation_of_and (all in.and
                                                  (in.in_when =0 ..intact_when)
                                                  (in.by ..annihilation_of_and))]
                     (_.= (all in.and
                               (in.by_application (in.by_application in.as_is annihilation_of_and)
                                                  annihilation_of_and)
                               (in.by non_idempotence_of_xor))
                          annihilation_of_and)))
                 (function (_ =0)
                   (let [=0 (in.and (in.by =0) (in.by @true))

                         identity_of_and (all in.and
                                              (in.in_when =0 ..intact_when)
                                              (in.by ..identity_of_and))]
                     (_.= (in.by_application (in.by_application in.as_is identity_of_and)
                                             identity_of_and)
                          identity_of_and)))))

... https://en.wikipedia.org/wiki/Material_conditional#Formal_properties
... https://en.wikipedia.org/wiki/Principle_of_explosion
(_.the .public principle_of_explosion
  (?.let [it Bit]
    (?.= (/.if .false it)
         .true))
  (_.= (all in.and
            (in.by_application (all in.and
                                    (in.by_application in.by_definition in.by_definition)
                                    in.by_reification)
                               in.as_is)
            in.by_reification
            (in.by_when in.as_is intact_branch))
       in.as_is))

(_.the .public identity_of_if
  (?.let [it Bit]
    (?.= (/.if .true it)
         it))
  (_.= (all in.and
            (in.by_application (all in.and
                                    (in.by_application in.by_definition |true|)
                                    in.by_reification)
                               in.as_is)
            in.by_reification
            (in.by_when in.as_is intact_branch))
       in.as_is))

... https://en.wikipedia.org/wiki/Reflexive_relation
(_.the .public reflexivity_of_if
  (?.let [it Bit]
    (?.= (/.if it it)
         .true))
  (induction.bit (function (_ =it)
                   (let [=it (in.and (in.by =it) (in.by @false))]
                     (_.= (all in.and
                               (in.by_application (in.by_application in.as_is =it) in.as_is)
                               (in.by principle_of_explosion))
                          in.as_is)))
                 (function (_ =it)
                   (let [=it (in.and (in.by =it) (in.by @true))]
                     (_.= (all in.and
                               (in.by_application (all in.and
                                                       (in.by_application in.by_definition =it)
                                                       in.by_reification)
                                                  =it)
                               in.by_reification
                               (in.by_when |true| intact_branch))
                          in.as_is)))))

... https://en.wikipedia.org/wiki/Connected_relation
(_.the .public totality_of_if
  (?.let [this Bit
          that Bit]
    (?.= (.or (/.if this that)
              (/.if that this))
         .true))
  (induction.bit (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @false))]
                     (_.= (all in.and
                               (or (all in.and
                                        (in.by_application (in.by_application in.as_is =this) in.as_is)
                                        (in.by principle_of_explosion))
                                   in.as_is)
                               (in.by annihilation_of_or))
                          in.as_is)))
                 (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @true))]
                     (induction.bit (function (_ =that)
                                      (let [=that (in.and (in.by =that) (in.by @false))]
                                        (_.= (all in.and
                                                  (or in.as_is
                                                      (all in.and
                                                           (in.by_application (in.by_application in.as_is =that) in.as_is)
                                                           (in.by principle_of_explosion)))
                                                  (in.by commutativity_of_or)
                                                  (in.by annihilation_of_or))
                                             in.as_is)))
                                    (function (_ =that)
                                      (let [=that (in.and (in.by =that) (in.by @true))]
                                        (_.= (all in.and
                                                  (or (all in.and
                                                           (in.by_application (in.by_application in.as_is =this) =that)
                                                           (in.by reflexivity_of_if))
                                                      in.as_is)
                                                  (in.by annihilation_of_or))
                                             in.as_is))))))))

... https://en.wikipedia.org/wiki/Law_of_excluded_middle
(_.the .public complementation_of_if
  (?.let [this Bit
          that Bit]
    (?.= (.or (/.if this that)
              (/.if this (.not that)))
         .true))
  (induction.bit (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @false))
                         principle_of_explosion (all in.and
                                                     (in.by_application (in.by_application in.as_is =this) in.as_is)
                                                     (in.by ..principle_of_explosion))]
                     (_.= (all in.and
                               (or principle_of_explosion
                                   principle_of_explosion)
                               (in.by idempotence_of_or))
                          in.as_is)))
                 (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @true))

                         identity_of_if (all in.and
                                             (in.by_application (in.by_application in.as_is =this) in.as_is)
                                             (in.by ..identity_of_if))]
                     (_.= (all in.and
                               (or identity_of_if
                                   identity_of_if)
                               (in.by complementation_of_or))
                          in.as_is)))))

(_.the .public contraposition
  (?.let [this Bit
          that Bit]
    (?.= (/.if this that)
         (/.if (.not that) (.not this))))
  (induction.bit (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @false))
                         
                         principle_of_explosion (function (_ it)
                                                  (all in.and
                                                       (if it in.as_is)
                                                       (in.by ..principle_of_explosion)))]
                     (induction.bit (function (_ =that)
                                      (let [=that (in.and (in.by =that) (in.by @false))]
                                        (_.= (principle_of_explosion =this)
                                             (all in.and
                                                  (if (all in.and
                                                           (not =that)
                                                           (in.by true_is_not_false))
                                                      (all in.and
                                                           (not =this)
                                                           (in.by true_is_not_false)))
                                                  (in.by ..identity_of_if)))))
                                    (function (_ =that)
                                      (let [=that (in.and (in.by =that) (in.by @true))]
                                        (_.= (principle_of_explosion =this)
                                             (principle_of_explosion (all in.and
                                                                          (not =that)
                                                                          (in.by false_is_not_true)))))))))
                 (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @true))]
                     (induction.bit (function (_ =that)
                                      (let [=that (in.and (in.by =that) (in.by @false))]
                                        (_.= (if =this =that)
                                             (if (all in.and
                                                      (not =that)
                                                      (in.by true_is_not_false))
                                                 (all in.and
                                                      (not =this)
                                                      (in.by false_is_not_true))))))
                                    (function (_ =that)
                                      (let [=that (in.and (in.by =that) (in.by @true))]
                                        (_.= (all in.and
                                                  (if =this =that)
                                                  (in.by ..identity_of_if))
                                             (all in.and
                                                  (if (all in.and
                                                           (not =that)
                                                           (in.by false_is_not_true))
                                                      in.as_is)
                                                  (in.by ..principle_of_explosion))))))))))

... https://en.wikipedia.org/wiki/Import%E2%80%93export_(logic)
... https://en.wikipedia.org/wiki/Exportation_(logic)
(_.the .public import_export
  (?.let [this Bit
          that Bit
          return Bit]
    (?.= (/.if this (/.if that return))
         (/.if (.and this that) return)))
  (induction.bit (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @false))]
                     (_.= (all in.and
                               (if =this in.as_is)
                               (in.by principle_of_explosion))
                          (all in.and
                               (if (all in.and
                                        (and =this in.as_is)
                                        (in.by annihilation_of_and))
                                   in.as_is)
                               (in.by principle_of_explosion)))))
                 (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @true))]
                     (_.= (all in.and
                               (if =this in.as_is)
                               (in.by identity_of_if))
                          (all in.and
                               (if (all in.and
                                        (and =this in.as_is)
                                        (in.by identity_of_and))
                                   in.as_is)))))))

(_.the .public negation_of_if
  (?.let [this Bit
          that Bit
          return Bit]
    (?.= (.not (/.if this that))
         (.and this (.not that))))
  (induction.bit (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @false))]
                     (_.= (all in.and
                               (not (all in.and
                                         (if =this in.as_is)
                                         (in.by principle_of_explosion)))
                               (in.by false_is_not_true))
                          (all in.and
                               (and =this in.as_is)
                               (in.by annihilation_of_and)))))
                 (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @true))]
                     (_.= (not (all in.and
                                    (if =this in.as_is)
                                    (in.by ..identity_of_if)))
                          (all in.and
                               (and =this in.as_is)
                               (in.by identity_of_and)))))))

(_.the .public or_if
  (?.let [this Bit
          that Bit
          return Bit]
    (?.= (/.if this that)
         (.or (.not this) that)))
  (induction.bit (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @false))]
                     (_.= (all in.and
                               (if =this in.as_is)
                               (in.by principle_of_explosion))
                          (all in.and
                               (or (all in.and
                                        (not =this)
                                        (in.by true_is_not_false))
                                   in.as_is)
                               (in.by annihilation_of_or)))))
                 (function (_ =this)
                   (let [=this (in.and (in.by =this) (in.by @true))]
                     (_.= (all in.and
                               (if =this in.as_is)
                               (in.by ..identity_of_if))
                          (all in.and
                               (or (all in.and
                                        (not =this)
                                        (in.by false_is_not_true))
                                   in.as_is)
                               (in.by identity_of_or)))))))

(_.the .public necessity
  (?.let [it Bit]
    (?.= (/.if it .true)
         .true))
  (induction.bit (function (_ this)
                   (let [this (in.and (in.by this) (in.by @false))]
                     (_.= (all in.and
                               (if this in.as_is)
                               (in.by principle_of_explosion))
                          in.as_is)))
                 (function (_ this)
                   (let [this (in.and (in.by this) (in.by @true))]
                     (_.= (all in.and
                               (if this in.as_is)
                               (in.by ..identity_of_if))
                          in.as_is)))))

... https://en.wikipedia.org/wiki/Commutative_property
(_.the .public commutativity_of_if
  (?.let [this Bit
          that Bit
          return Bit]
    (?.= (/.if this (/.if that return))
         (/.if that (/.if this return))))
  (induction.bit (function (_ this)
                   (let [this (in.and (in.by this) (in.by @false))

                         principle_of_explosion (all in.and
                                                     (if this in.as_is)
                                                     (in.by ..principle_of_explosion))]
                     (_.= principle_of_explosion
                          (all in.and
                               (if in.as_is principle_of_explosion)
                               (in.by ..necessity)))))
                 (function (_ this)
                   (let [this (in.and (in.by this) (in.by @true))

                         identity_of_if (all in.and
                                             (if this in.as_is)
                                             (in.by ..identity_of_if))]
                     (_.= identity_of_if
                          (if in.as_is identity_of_if))))))

... https://en.wikipedia.org/wiki/Distributive_property
(_.the .public left_distributivity
  (?.let [this Bit
          that Bit
          return Bit]
    (?.= (/.if this (/.if that return))
         (/.if (/.if this that)
               (/.if this return))))
  (induction.bit (function (_ this)
                   (let [this (in.and (in.by this) (in.by @false))

                         principle_of_explosion (function (_ it)
                                                  (all in.and
                                                       (if it in.as_is)
                                                       (in.by ..principle_of_explosion)))]
                     (_.= (principle_of_explosion this)
                          (all in.and
                               (if (principle_of_explosion this)
                                   (principle_of_explosion this))
                               (in.by ..necessity)))))
                 (function (_ this)
                   (let [this (in.and (in.by this) (in.by @true))

                         identity_of_if (all in.and
                                             (if this in.as_is)
                                             (in.by ..identity_of_if))]
                     (_.= identity_of_if
                          (if identity_of_if
                              identity_of_if))))))

... https://en.wikipedia.org/wiki/Equality_(mathematics)#Basic_properties
(the (= this that)
  (-> in.Rule in.Rule
      in.Rule)
  (all in.and
       (in.by_application (all in.and
                               (in.by_application in.by_definition this)
                               in.by_reification)
                          that)
       in.by_reification))

... https://en.wikipedia.org/wiki/Reflexive_relation
(_.the .public reflexivity_of_=
  (?.let [it Bit]
    (?.= (/.= it it)
         .true))
  (induction.bit (function (_ it)
                   (let [it (in.and (in.by it) (in.by @false))]
                     (_.= (all in.and
                               (= it it)
                               (in.by ..if_false)
                               (in.by ..true_is_not_false))
                          in.as_is)))
                 (function (_ it)
                   (let [it (in.and (in.by it) (in.by @true))]
                     (_.= (all in.and
                               (= it it)
                               (in.by ..if_true))
                          in.as_is)))))

(_.the .public extraction_of_commonality
  (?.let [premise conclusion]
    [test Bit
     then premise
     else premise
     after (-> premise conclusion)]
    (?.= (.if test
              (after then)
              (after else))
         (after (.if test
                     then
                     else))))
  (let [proof (is (-> Identity Identity
                      induction.Case)
                  (function (_ @constant if_constant)
                    (function (_ =_test)
                      (let [=_test (in.and (in.by =_test) (in.by @constant))
                            if' (in.and (in.in_when =_test
                                                    [..intact_branch
                                                     (list ..intact_branch)])
                                        (in.by if_constant))]
                        (_.= if'
                             (in.by_application in.as_is if'))))))]
    (induction.bit (proof @false ..if_false)
                   (proof @true ..if_true))))

(comment
  ... https://en.wikipedia.org/wiki/Complement_(set_theory)
  (_.the .public complementation_of_=
    (?.let [it]
      (?.= (/.= it (.not it))
           .false))
    (_.= in.as_is
         in.as_is))

  ... https://en.wikipedia.org/wiki/Commutative_property
  (_.the .public commutativity_of_=
    (?.let [this that]
      (?.= (/.= this that)
           (/.= that this)))
    (_.= in.as_is
         in.as_is))

  (_.the .public double_negation_in_xor
    (?.let [this that]
      (?.= (/.xor (.not this) (.not that))
           (/.xor this that)))
    (_.= in.as_is
         in.as_is))

  (_.the .public negation_in_=
    (?.let [this that]
      (?.= (/.= (.not this) that)
           (.not (/.= this that))))
    (_.= in.as_is
         in.as_is))

  (_.the .public double_negation_in_=
    (?.let [this that]
      (?.= (/.= (.not this) (.not that))
           (/.= this that)))
    (_.= in.as_is
         in.as_is))

  (_.the .public ,,,
    (?.let [this that]
      (?.= (/.if (.and this that) this)
           .true))
    (_.= in.as_is
         in.as_is))

  (_.the .public ,,,
    (?.let [this that]
      (?.= (/.if (.and this that) that)
           .true))
    (_.= in.as_is
         in.as_is))

  (_.the .public ,,,
    (?.let [this that]
      (?.= (/.if this (.or this that))
           .true))
    (_.= in.as_is
         in.as_is))

  (_.the .public ,,,
    (?.let [this that]
      (?.= (/.if that (.or this that))
           .true))
    (_.= in.as_is
         in.as_is))

  (_.the .public ,,,
    (?.let [this that]
      (?.= (.and (.or this that)
                 (.not (.and this that)))
           (/.xor this that)))
    (_.= in.as_is
         in.as_is))

  (_.the .public ,,,
    (?.let [this that]
      (?.= (/.xor (/.xor this that)
                  (.and this that))
           (.or this that)))
    (_.= in.as_is
         in.as_is))

  (_.the .public ,,,
    (?.let [cause effect]
      (?.= (.not (/.xor cause (.and cause effect)))
           (/.if cause effect)))
    (_.= in.as_is
         in.as_is))

  (_.the .public ,,,
    (?.let [this that]
      (?.= (.and (/.xor this that)
                 (.not (.and this that)))
           (/.xor this that)))
    (_.= in.as_is
         in.as_is))

  (_.the .public ,,,
    (?.let [this that]
      (?.= (.and (/.xor this that)
                 (.and this that))
           .false))
    (_.= in.as_is
         in.as_is))

  (_.the .public ,,,
    (?.let [this that]
      (?.= (.or (.and this (.not that))
                (.and (.not this) that))
           (/.xor this that)))
    (_.= in.as_is
         in.as_is))

  (_.the .public ,,,
    (?.let [this that]
      (?.= (.and (.or this that)
                 (.or (.not this) (.not that)))
           (/.xor this that)))
    (_.= in.as_is
         in.as_is))

  (_.the .public ,,,
    (?.let [this that]
      (?.= (.or (.and this that)
                (.and (.not this) (.not that)))
           (.not (/.xor this that))))
    (_.= in.as_is
         in.as_is))

  implement_all_'gates'_in_terms_of_nor
  implement_all_'gates'_in_terms_of_nand

  ,,,
  For Nat, 0 = 0 and infinity = 1
  0 + 0 = 0
  0 + I = I
  I + 0 = I
  I + I = 0

  0 x (in_reverse 0) = 0
  0 x (in_reverse I) = 0
  I x (in_reverse 0) = 0
  I x (in_reverse I) = I

  0 x (/ I 0) = 0
  0 x (/ I I) = 0
  I x (/ I 0) = 0
  I x (/ I I) = I

  (0b 1b xor and)
  (0 I + (x (/ I)))
  (0 1 i64_xor x)
  ... https://math.stackexchange.com/questions/665369/converting-division-by-a-constant-into-multiplication
  ,,,

  ... https://en.wikipedia.org/wiki/Modus_ponens
  (_.the .public modus_ponens
    (?.let [cause effect]
      (?.= (/.if (.and (/.if cause effect)
                       cause)
                 effect)
           .true))
    (_.= in.as_is
         in.as_is))
  )
