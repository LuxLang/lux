... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except or and if not)
   ["_" proof]
   [error
    ["[0]" try]]
   [abstract
    ["[0]" monad]]
   [meta
    ["[0]" provenance]]
   [compiler
    [language
     [lux
      ["[0]" analysis]]]]
   ["[0]" function]
   [macro
    ["[0]" template]]]]
 [\\library
  ["[0]" /]])

(the intact_branch
  (-> _.Identity
      _.Rule)
  (function.constant _.as_is))

(the intact_when
  [(-> _.Identity _.Rule)
   (List (-> _.Identity _.Rule))]
  [..intact_branch
   (list ..intact_branch)])

(the (or this that)
  (-> _.Rule _.Rule
      _.Rule)
  (_.in_when this [..intact_branch
                   (list (function.constant that))]))

(the (and this that)
  (-> _.Rule _.Rule
      _.Rule)
  (_.in_when this [(function.constant that)
                   (list ..intact_branch)]))

(the (if cause effect)
  (-> _.Rule _.Rule
      _.Rule)
  (_.by_application (_.by_application _.as_is cause) effect))

(the (not it)
  (-> _.Rule
      _.Rule)
  (_.by_application _.as_is it))

... https://en.wikipedia.org/wiki/Boolean_algebra#Laws

(the (|not| it)
  (Change _.Rule)
  (all _.and
       (_.by_application _.by_definition it)
       _.by_reification
       (_.by_when _.as_is
                  (function (_ _)
                    _.as_is))))

(the |true|
  (all _.and
       _.by_definition
       (|not| _.by_definition)))

... Lemma
(_.the @false
  (_.= 0b
       .false)
  (_.=' _.as_is
        _.by_definition))

(_.the @true
  (_.= 1b
       .true)
  (_.=' _.as_is
        |true|))

(the (of/1 abstraction argument)
  (-> _.Rule _.Rule
      _.Rule)
  (all _.and
       (_.by_application abstraction argument)
       _.by_reification))

(_.the .public if_true
  (_.let [then else]
    (_.= (.if .true
              then
              else)
         then))
  (all _.and
       (_.=' (_.by_when |true|
                        (function (_ _)
                          _.as_is))
             _.as_is)
       _.qed))

(_.the .public if_false
  (_.let [then else]
    (_.= (.if .false
              then
              else)
         else))
  (all _.and
       (_.=' (_.by_when _.by_definition
                        (function (_ _)
                          _.as_is))
             _.as_is)
       _.qed))

(the (valid? [left right])
  (-> [analysis.Term analysis.Term]
      Bit)
  (.with analysis.equivalence
    (= left right)))

... https://en.wikipedia.org/wiki/Mathematical_induction
(the .public (by_induction for_false for_true
                           [lux next_induction] it)
  (-> (-> _.Identity _.Proof)
      (-> _.Identity _.Proof)
      _.Proof)
  (monad.let try.monad
    [.let [variable (_.induction_variable provenance.dummy next_induction)
           ... variable (_.variable provenance.dummy next_induction)
           environment [lux (++ next_induction)]]
     false! (for_false [variable
                        (analysis.bit provenance.dummy false)]
                       environment
                       it)
     true! (for_true [variable
                      (analysis.bit provenance.dummy true)]
                     environment
                     it)]
    (pure (.if (valid? false!)
               true!
               false!))))

(_.the .public true_is_not_false
  (_.= (.not .false)
       .true)
  (all _.and
       (_.=' _.as_is
             _.by_definition)
       _.qed))

... https://en.wikipedia.org/wiki/Double_negation
(_.the .public double_negation
  (_.let [it]
    (_.= (.not (.not it))
         it))
  (let [$= (function (_ ==)
             (_.=' (|not| (|not| (_.by ==)))
                   (_.by ==)))]
    (by_induction (function (_ =_false)
                    ($= =_false))
                  (function (_ =_true)
                    ($= =_true)))))

(_.the .public false_is_not_true
  (_.= (.not .true)
       .false)
  (all _.and
       (_.=' (all _.and
                  (_.by_application _.as_is _.by_definition)
                  (_.by double_negation))
             _.as_is)
       _.qed))

... https://en.wikipedia.org/wiki/Idempotence
(template.with [,theorem ,composition ,if_false ,if_true]
  [(_.the .public ,theorem
     (_.let [it]
       (_.= (,composition it it)
            it))
     (by_induction (function (_ ==)
                     (_.=' (_.by_when (_.by ==)
                                      (function (_ _)
                                        ,if_false))
                           (_.by ==)))
                   (function (_ ==)
                     (_.=' (_.by_when (_.by ==)
                                      (function (_ _)
                                        ,if_true))
                           (_.by ==)))))]

  [[idempotence_of_or .or (_.by ==) _.as_is]
   [idempotence_of_and .and _.as_is (_.by ==)]])

(template.with [,theorem ,composition ,identity ,value]
  [(_.the .public ,theorem
     (_.let [it]
       (_.= (,composition ,identity it)
            it))
     (_.=' (_.by_when ,value
                      (function (_ _)
                        _.as_is))
           _.as_is))]

  [[identity_of_or .or .false _.by_definition]
   [identity_of_and .and .true |true|]])

(template.with [,theorem ,composition ,identity ,value]
  [(_.the .public ,theorem
     (_.let [it]
       (_.= (,composition ,identity it)
            ,identity))
     (_.=' (_.by_when ,value
                      (function (_ _)
                        _.as_is))
           ,value))]

  [[annihilation_of_or .or .true |true|]
   [annihilation_of_and .and .false _.by_definition]])

... https://en.wikipedia.org/wiki/Commutative_property
(_.the .public commutativity_of_or
  (_.let [this that]
    (_.= (.or this that)
         (.or that this)))
  (by_induction (function (_ this_=_false)
                  (let [this_=_false (_.and (_.by this_=_false) (_.by @false))]
                    (by_induction (function (_ that_=_false)
                                    (let [that_=_false (_.and (_.by that_=_false) (_.by @false))]
                                      (_.=' (all _.and
                                                 (_.in_when this_=_false ..intact_when)
                                                 (_.by ..identity_of_or)
                                                 that_=_false)
                                            (all _.and
                                                 (_.in_when that_=_false ..intact_when)
                                                 (_.by ..identity_of_or)
                                                 this_=_false))))
                                  (function (_ that_=_true)
                                    (let [that_=_true (_.and (_.by that_=_true) (_.by @true))]
                                      (_.=' (all _.and
                                                 (_.in_when this_=_false ..intact_when)
                                                 (_.by ..identity_of_or)
                                                 that_=_true)
                                            (all _.and
                                                 (_.in_when that_=_true ..intact_when)
                                                 (_.by ..annihilation_of_or))))))))
                (function (_ this_=_true)
                  (let [this_=_true (_.and (_.by this_=_true) (_.by @true))]
                    (by_induction (function (_ that_=_false)
                                    (let [that_=_false (_.and (_.by that_=_false) (_.by @false))]
                                      (_.=' (all _.and
                                                 (_.in_when this_=_true ..intact_when)
                                                 (_.by ..annihilation_of_or))
                                            (all _.and
                                                 (_.in_when that_=_false ..intact_when)
                                                 (_.by ..identity_of_or)
                                                 this_=_true))))
                                  (function (_ that_=_true)
                                    (let [that_=_true (_.and (_.by that_=_true) (_.by @true))]
                                      (_.=' (all _.and
                                                 (_.in_when this_=_true ..intact_when)
                                                 (_.by ..annihilation_of_or))
                                            (all _.and
                                                 (_.in_when that_=_true ..intact_when)
                                                 (_.by ..annihilation_of_or))))))))))

(_.the .public commutativity_of_and
  (_.let [this that]
    (_.= (.and this that)
         (.and that this)))
  (by_induction (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @false))]
                    (by_induction (function (_ =that)
                                    (let [=that (_.and (_.by =that) (_.by @false))]
                                      (_.=' (all _.and
                                                 (_.in_when =this ..intact_when)
                                                 (_.by ..annihilation_of_and))
                                            (all _.and
                                                 (_.in_when =that ..intact_when)
                                                 (_.by ..annihilation_of_and)))))
                                  (function (_ =that)
                                    (let [=that (_.and (_.by =that) (_.by @true))]
                                      (_.=' (all _.and
                                                 (_.in_when =this ..intact_when)
                                                 (_.by ..annihilation_of_and))
                                            (all _.and
                                                 (_.in_when =that ..intact_when)
                                                 (_.by ..identity_of_and)
                                                 =this)))))))
                (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @true))]
                    (by_induction (function (_ =that)
                                    (let [=that (_.and (_.by =that) (_.by @false))]
                                      (_.=' (all _.and
                                                 (_.in_when =this ..intact_when)
                                                 (_.by ..identity_of_and)
                                                 =that)
                                            (all _.and
                                                 (_.in_when =that ..intact_when)
                                                 (_.by ..annihilation_of_and)))))
                                  (function (_ =that)
                                    (let [=that (_.and (_.by =that) (_.by @true))]
                                      (_.=' (all _.and
                                                 (_.in_when =this ..intact_when)
                                                 (_.by ..identity_of_and)
                                                 =that)
                                            (all _.and
                                                 (_.in_when =that ..intact_when)
                                                 (_.by ..identity_of_and)
                                                 =this)))))))))

... https://en.wikipedia.org/wiki/Complement_(set_theory)
... https://en.wikipedia.org/wiki/Law_of_excluded_middle
(_.the .public complementation_of_or
  (_.let [it]
    (_.= (.or it (.not it))
         .true))
  (by_induction (function (_ =_false)
                  (let [=_false (_.and (_.by =_false) (_.by @false))]
                    (_.=' (all _.and
                               (_.in_when =_false ..intact_when)
                               (_.by identity_of_or)
                               (_.by_application _.as_is =_false))
                          _.by_definition)))
                (function (_ =_true)
                  (let [=_true (_.and (_.by =_true) (_.by @true))]
                    (_.=' (all _.and
                               (_.in_when =_true ..intact_when)
                               (_.by annihilation_of_or))
                          _.as_is)))))

... https://en.wikipedia.org/wiki/Law_of_noncontradiction
(_.the .public complementation_of_and
  (_.let [it]
    (_.= (.and it (.not it))
         .false))
  (by_induction (function (_ =it)
                  (let [=it (_.and (_.by =it) (_.by @false))]
                    (_.=' (all _.and
                               (_.in_when =it ..intact_when)
                               (_.by annihilation_of_and))
                          _.as_is)))
                (function (_ =it)
                  (let [=it (_.and (_.by =it) (_.by @true))]
                    (_.=' (all _.and
                               (_.in_when =it ..intact_when)
                               (_.by identity_of_and)
                               (_.by_application _.as_is =it)
                               (_.by false_is_not_true))
                          _.as_is)))))

... https://en.wikipedia.org/wiki/Associative_property
(_.the .public associativity_of_or
  (_.let [$0 $1 $2]
    (_.= (.or $0 (.or $1 $2))
         (.or (.or $0 $1) $2)))
  (by_induction (function (_ $0_=_false)
                  (let [$0_=_false (_.and (_.by $0_=_false) (_.by @false))]
                    (by_induction (function (_ $1_=_false)
                                    (let [$1_=_false (_.and (_.by $1_=_false) (_.by @false))]
                                      (_.=' (all _.and
                                                 (_.in_when $0_=_false ..intact_when)
                                                 (_.by identity_of_or)
                                                 (_.in_when $1_=_false ..intact_when)
                                                 (_.by identity_of_or))
                                            (all _.and
                                                 (_.in_when (all _.and
                                                                 (_.in_when $0_=_false ..intact_when)
                                                                 (_.by identity_of_or)
                                                                 $1_=_false)
                                                            ..intact_when)
                                                 (_.by identity_of_or)))))
                                  (function (_ $1_=_true)
                                    (let [$1_=_true (_.and (_.by $1_=_true) (_.by @true))]
                                      (_.=' (all _.and
                                                 (_.in_when $0_=_false ..intact_when)
                                                 (_.by identity_of_or)
                                                 (_.in_when $1_=_true ..intact_when)
                                                 (_.by annihilation_of_or))
                                            (all _.and
                                                 (_.in_when (all _.and
                                                                 (_.in_when $0_=_false ..intact_when)
                                                                 (_.by identity_of_or)
                                                                 $1_=_true)
                                                            ..intact_when)
                                                 (_.by annihilation_of_or))))))))
                (function (_ $0_=_true)
                  (let [$0_=_true (_.and (_.by $0_=_true) (_.by @true))]
                    (_.=' (all _.and
                               (_.in_when $0_=_true ..intact_when)
                               (_.by annihilation_of_or))
                          (all _.and
                               (_.in_when (all _.and
                                               (_.in_when $0_=_true ..intact_when)
                                               (_.by annihilation_of_or))
                                          ..intact_when)
                               (_.by annihilation_of_or)))))))

(_.the .public associativity_of_and
  (_.let [$0 $1 $2]
    (_.= (.and $0 (.and $1 $2))
         (.and (.and $0 $1) $2)))
  (by_induction (function (_ =0)
                  (let [=0 (_.and (_.by =0) (_.by @false))]
                    (_.=' (all _.and
                               (_.in_when =0 ..intact_when)
                               (_.by annihilation_of_and))
                          (all _.and
                               (_.in_when (all _.and
                                               (_.in_when =0 ..intact_when)
                                               (_.by annihilation_of_and))
                                          ..intact_when)
                               (_.by annihilation_of_and)))))
                (function (_ =0)
                  (let [=0 (_.and (_.by =0) (_.by @true))]
                    (by_induction (function (_ =1)
                                    (let [=1 (_.and (_.by =1) (_.by @false))]
                                      (_.=' (all _.and
                                                 (_.in_when =0 ..intact_when)
                                                 (_.by identity_of_and)
                                                 (_.in_when =1 ..intact_when)
                                                 (_.by annihilation_of_and))
                                            (all _.and
                                                 (_.in_when (all _.and
                                                                 (_.in_when =0 ..intact_when)
                                                                 (_.by identity_of_and)
                                                                 =1)
                                                            ..intact_when)
                                                 (_.by annihilation_of_and)))))
                                  (function (_ =1)
                                    (let [=1 (_.and (_.by =1) (_.by @true))]
                                      (_.=' (all _.and
                                                 (_.in_when =0 ..intact_when)
                                                 (_.by identity_of_and)
                                                 (_.in_when =1 ..intact_when)
                                                 (_.by identity_of_and))
                                            (all _.and
                                                 (_.in_when (all _.and
                                                                 (_.in_when =0 ..intact_when)
                                                                 (_.by identity_of_and)
                                                                 =1)
                                                            ..intact_when)
                                                 (_.by identity_of_and))))))))))

... https://en.wikipedia.org/wiki/Distributive_property
(_.the .public distributivity_of_or
  (_.let [$0 $1 $2]
    (_.= (.and (.or $0 $1) (.or $0 $2))
         (.or $0 (.and $1 $2))))
  (by_induction (function (_ =_false)
                  (let [=_false (_.and (_.by =_false) (_.by @false))
                        $or_false (all _.and
                                       (_.in_when =_false ..intact_when)
                                       (_.by identity_of_or))]
                    (_.=' (_.in_when $or_false
                                     [(function.constant $or_false)
                                      (list ..intact_branch)])
                          $or_false)))
                (function (_ =_true)
                  (let [=_true (_.and (_.by =_true) (_.by @true))
                        $or_true (all _.and
                                      (_.in_when =_true ..intact_when)
                                      (_.by annihilation_of_or))]
                    (_.=' (all _.and
                               (_.in_when $or_true
                                          [(function.constant $or_true)
                                           (list ..intact_branch)])
                               (_.by identity_of_and))
                          $or_true))
                  )))

(_.the .public distributivity_of_and
  (_.let [$0 $1 $2]
    (_.= (.or (.and $0 $1) (.and $0 $2))
         (.and $0 (.or $1 $2))))
  (by_induction (function (_ =0)
                  (let [=0 (_.and (_.by =0) (_.by @false))
                        annihilation (all _.and
                                          (_.in_when =0 ..intact_when)
                                          (_.by annihilation_of_and))]
                    (_.=' (all _.and
                               (_.in_when annihilation
                                          [..intact_branch
                                           (list (function.constant annihilation))])
                               (_.by identity_of_or))
                          annihilation)))
                (function (_ =0)
                  (let [=0 (_.and (_.by =0) (_.by @true))
                        identity (all _.and
                                      (_.in_when =0 ..intact_when)
                                      (_.by identity_of_and))]
                    (_.=' (_.in_when identity
                                     [..intact_branch
                                      (list (function.constant identity))])
                          identity))
                  )))

... https://en.wikipedia.org/wiki/De_Morgan%27s_laws
(_.the .public negation_of_or
  (_.let [this that]
    (_.= (.and (.not this) (.not that))
         (.not (.or this that))))
  (by_induction (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @false))]
                    (_.=' (all _.and
                               (_.in_when (all _.and
                                               (_.by_application _.as_is =this)
                                               (_.by true_is_not_false))
                                          ..intact_when)
                               (_.by identity_of_and))
                          (_.by_application _.as_is
                                            (all _.and
                                                 (_.in_when =this ..intact_when)
                                                 (_.by identity_of_or))))))
                (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @true))]
                    (_.=' (all _.and
                               (_.in_when (all _.and
                                               (_.by_application _.as_is =this)
                                               (_.by false_is_not_true))
                                          ..intact_when)
                               (_.by annihilation_of_and))
                          (all _.and
                               (_.by_application _.as_is
                                                 (all _.and
                                                      (_.in_when =this ..intact_when)
                                                      (_.by annihilation_of_or)))
                               (_.by false_is_not_true)))))))

(_.the .public negation_of_and
  (_.let [this that]
    (_.= (.or (.not this) (.not that))
         (.not (.and this that))))
  (by_induction (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @false))]
                    (_.=' (all _.and
                               (_.in_when (all _.and
                                               (_.by_application _.as_is =this)
                                               (_.by true_is_not_false))
                                          ..intact_when)
                               (_.by annihilation_of_or))
                          (all _.and
                               (_.by_application _.as_is
                                                 (all _.and
                                                      (_.in_when =this ..intact_when)
                                                      (_.by annihilation_of_and)))
                               (_.by true_is_not_false)))))
                (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @true))]
                    (_.=' (all _.and
                               (_.in_when (all _.and
                                               (_.by_application _.as_is =this)
                                               (_.by false_is_not_true))
                                          ..intact_when)
                               (_.by identity_of_or))
                          (_.by_application _.as_is
                                            (all _.and
                                                 (_.in_when =this ..intact_when)
                                                 (_.by identity_of_and))))))))

(_.the .public absorption_of_or
  (_.let [this that]
    (_.= (.or this (.and this that))
         this))
  (by_induction (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @false))]
                    (_.=' (all _.and
                               (_.in_when =this ..intact_when)
                               (_.by identity_of_or)
                               (_.in_when =this ..intact_when)
                               (_.by annihilation_of_and))
                          =this)))
                (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @true))]
                    (_.=' (all _.and
                               (_.in_when =this ..intact_when)
                               (_.by annihilation_of_or))
                          =this)))))

(_.the .public absorption_of_and
  (_.let [this that]
    (_.= (.and this (.or this that))
         this))
  (by_induction (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @false))]
                    (_.=' (all _.and
                               (_.in_when =this ..intact_when)
                               (_.by annihilation_of_and))
                          =this)))
                (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @true))]
                    (_.=' (all _.and
                               (_.in_when =this ..intact_when)
                               (_.by identity_of_and)
                               (_.in_when =this ..intact_when)
                               (_.by annihilation_of_or))
                          =this)))))

(_.the .public if_not
  (_.let [test then else]
    (_.= (.if (.not test)
              then
              else)
         (.if test
              else
              then)))
  (by_induction (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @false))]
                    (_.=' (all _.and
                               (_.in_when (all _.and
                                               (_.by_application _.as_is =this)
                                               (_.by true_is_not_false))
                                          ..intact_when)
                               (_.by if_true))
                          (all _.and
                               (_.in_when =this ..intact_when)
                               (_.by if_false)))))
                (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @true))]
                    (_.=' (all _.and
                               (_.in_when (all _.and
                                               (_.by_application _.as_is =this)
                                               (_.by false_is_not_true))
                                          ..intact_when)
                               (_.by if_false))
                          (all _.and
                               (_.in_when =this ..intact_when)
                               (_.by if_true)))))))

... https://en.wikipedia.org/wiki/Exclusive_or#Properties
(_.the .public identity_by_xor
  (_.let [it]
    (_.= (/.xor .false it)
         it))
  (_.=' (all _.and
             (of/1 (of/1 _.by_definition _.by_definition) _.as_is)
             (_.by_when _.as_is ..intact_branch))
        _.as_is))

(_.the .public negation_by_xor
  (_.let [it]
    (_.= (/.xor .true it)
         (.not it)))
  (_.=' (all _.and
             (of/1 (of/1 _.by_definition |true|) _.as_is)
             (_.by_when _.as_is ..intact_branch))
        _.as_is))

(_.the .public non_idempotence_of_xor
  (_.let [it]
    (_.= (/.xor it it)
         .false))
  (by_induction (function (_ =it)
                  (_.=' (all _.and
                             (of/1 (of/1 _.by_definition (_.by =it)) (_.by =it))
                             (_.by_when _.as_is ..intact_branch))
                        _.by_definition))
                (function (_ =it')
                  (let [=it (_.and (_.by =it') (_.by @true))]
                    (_.=' (all _.and
                               (of/1 (of/1 _.by_definition (_.by =it')) =it)
                               (_.by_when _.as_is ..intact_branch)
                               (_.by false_is_not_true))
                          _.as_is)))))

... https://en.wikipedia.org/wiki/Complement_(set_theory)
(_.the .public complementation_of_xor
  (_.let [it]
    (_.= (/.xor it (.not it))
         .true))
  (by_induction (function (_ =it')
                  (let [=it (_.and (_.by =it') (_.by @false))]
                    (_.=' (all _.and
                               (of/1 (of/1 _.by_definition (_.by =it'))
                                     (_.by_application _.as_is =it))
                               (_.by_when _.as_is ..intact_branch)
                               (_.by true_is_not_false))
                          _.as_is)))
                (function (_ =it')
                  (let [=it (_.and (_.by =it') (_.by @true))]
                    (_.=' (all _.and
                               (of/1 (of/1 _.by_definition (_.by =it'))
                                     (_.by_application _.as_is =it))
                               (_.by_when _.as_is ..intact_branch)
                               (_.by double_negation))
                          _.as_is)))))

... https://en.wikipedia.org/wiki/Commutative_property
(_.the .public commutativity_of_xor
  (_.let [this that]
    (_.= (/.xor this that)
         (/.xor that this)))
  (by_induction (function (_ =this')
                  (let [=this (_.and (_.by =this') (_.by @false))]
                    (by_induction (function (_ =that)
                                    (let [=that (_.and (_.by =that) (_.by @false))]
                                      (_.=' (_.by_application (_.by_application _.as_is =this) =that)
                                            (_.by_application (_.by_application _.as_is =that) =this))))
                                  (function (_ =that')
                                    (let [=that (_.and (_.by =that') (_.by @true))]
                                      (_.=' (all _.and
                                                 (of/1 (of/1 _.by_definition (_.by =this')) =that)
                                                 (_.by_when _.as_is ..intact_branch))
                                            (all _.and
                                                 (of/1 (of/1 _.by_definition (_.by =that')) =this)
                                                 (_.by_when _.as_is ..intact_branch)
                                                 (_.by true_is_not_false))))))))
                (function (_ =this')
                  (let [=this (_.and (_.by =this') (_.by @true))]
                    (by_induction (function (_ =that')
                                    (let [=that (_.and (_.by =that') (_.by @false))]
                                      (_.=' (all _.and
                                                 (of/1 (of/1 _.by_definition (_.by =this')) =that)
                                                 (_.by_when _.as_is ..intact_branch)
                                                 (_.by true_is_not_false))
                                            (all _.and
                                                 (of/1 (of/1 _.by_definition (_.by =that')) =this)
                                                 (_.by_when _.as_is ..intact_branch)))))
                                  (function (_ =that)
                                    (let [=that (_.and (_.by =that) (_.by @true))]
                                      (_.=' (_.by_application (_.by_application _.as_is =this) =that)
                                            (_.by_application (_.by_application _.as_is =that) =this)))))))))

(_.the .public negation_in_xor
  (_.let [this that]
    (_.= (/.xor (.not this) that)
         (.not (/.xor this that))))
  (by_induction (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @false))]
                    (_.=' (all _.and
                               (_.by_application (_.by_application _.as_is (all _.and
                                                                                (_.by_application _.as_is =this)
                                                                                (_.by true_is_not_false)))
                                                 _.as_is)
                               (_.by negation_by_xor))
                          (_.by_application _.as_is
                                            (all _.and
                                                 (_.by_application (_.by_application _.as_is =this)
                                                                   _.as_is)
                                                 (_.by identity_by_xor))))))
                (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @true))]
                    (_.=' (all _.and
                               (_.by_application (_.by_application _.as_is (all _.and
                                                                                (_.by_application _.as_is =this)
                                                                                (_.by false_is_not_true)))
                                                 _.as_is)
                               (_.by identity_by_xor))
                          (all _.and
                               (_.by_application _.as_is
                                                 (all _.and
                                                      (_.by_application (_.by_application _.as_is =this)
                                                                        _.as_is)
                                                      (_.by negation_by_xor)))
                               (_.by double_negation)))))))

... https://en.wikipedia.org/wiki/Associative_property
(_.the .public associativity_of_xor
  (_.let [$0 $1 $2]
    (_.= (/.xor $0 (/.xor $1 $2))
         (/.xor (/.xor $0 $1) $2)))
  (by_induction (function (_ =0)
                  (let [=0 (_.and (_.by =0) (_.by @false))

                        identity_by_xor (all _.and
                                             (_.by_application (_.by_application _.as_is =0)
                                                               _.as_is)
                                             (_.by ..identity_by_xor))]
                    (_.=' identity_by_xor
                          (_.by_application (_.by_application _.as_is identity_by_xor)
                                            _.as_is))))
                (function (_ =0)
                  (let [=0 (_.and (_.by =0) (_.by @true))

                        negation_by_xor (all _.and
                                             (_.by_application (_.by_application _.as_is =0)
                                                               _.as_is)
                                             (_.by ..negation_by_xor))]
                    (_.=' negation_by_xor
                          (all _.and
                               (_.by_application (_.by_application _.as_is negation_by_xor)
                                                 _.as_is)
                               (_.by ..negation_in_xor)))))))

(_.the .public xor_is_an_involution
  (_.let [this that]
    (_.= (/.xor that (/.xor that this))
         this))
  (_.=' (all _.and
             (_.by associativity_of_xor)
             (_.by_application (_.by_application _.as_is (_.by non_idempotence_of_xor))
                               _.as_is)
             (_.by identity_by_xor))
        _.as_is))

(_.the .public distributivity_in_xor
  (_.let [$0 $1 $2]
    (_.= (/.xor (.and $0 $1) (.and $0 $2))
         (.and $0 (/.xor $1 $2))))
  (by_induction (function (_ =0)
                  (let [=0 (_.and (_.by =0) (_.by @false))

                        annihilation_of_and (all _.and
                                                 (_.in_when =0 ..intact_when)
                                                 (_.by ..annihilation_of_and))]
                    (_.=' (all _.and
                               (_.by_application (_.by_application _.as_is annihilation_of_and)
                                                 annihilation_of_and)
                               (_.by non_idempotence_of_xor))
                          annihilation_of_and)))
                (function (_ =0)
                  (let [=0 (_.and (_.by =0) (_.by @true))

                        identity_of_and (all _.and
                                             (_.in_when =0 ..intact_when)
                                             (_.by ..identity_of_and))]
                    (_.=' (_.by_application (_.by_application _.as_is identity_of_and)
                                            identity_of_and)
                          identity_of_and)))))

... https://en.wikipedia.org/wiki/Material_conditional#Formal_properties
... https://en.wikipedia.org/wiki/Principle_of_explosion
(_.the .public principle_of_explosion
  (_.let [it]
    (_.= (/.if .false it)
         .true))
  (_.=' (all _.and
             (_.by_application (all _.and
                                    (_.by_application _.by_definition _.by_definition)
                                    _.by_reification)
                               _.as_is)
             _.by_reification
             (_.by_when _.as_is intact_branch))
        _.as_is))

(_.the .public identity_of_if
  (_.let [it]
    (_.= (/.if .true it)
         it))
  (_.=' (all _.and
             (_.by_application (all _.and
                                    (_.by_application _.by_definition |true|)
                                    _.by_reification)
                               _.as_is)
             _.by_reification
             (_.by_when _.as_is intact_branch))
        _.as_is))

... https://en.wikipedia.org/wiki/Reflexive_relation
(_.the .public reflexivity_of_if
  (_.let [it]
    (_.= (/.if it it)
         .true))
  (by_induction (function (_ =it)
                  (let [=it (_.and (_.by =it) (_.by @false))]
                    (_.=' (all _.and
                               (_.by_application (_.by_application _.as_is =it) _.as_is)
                               (_.by principle_of_explosion))
                          _.as_is)))
                (function (_ =it)
                  (let [=it (_.and (_.by =it) (_.by @true))]
                    (_.=' (all _.and
                               (_.by_application (all _.and
                                                      (_.by_application _.by_definition =it)
                                                      _.by_reification)
                                                 =it)
                               _.by_reification
                               (_.by_when |true| intact_branch))
                          _.as_is)))))

... https://en.wikipedia.org/wiki/Connected_relation
(_.the .public totality_of_if
  (_.let [this that]
    (_.= (.or (/.if this that)
              (/.if that this))
         .true))
  (by_induction (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @false))]
                    (_.=' (all _.and
                               (or (all _.and
                                        (_.by_application (_.by_application _.as_is =this) _.as_is)
                                        (_.by principle_of_explosion))
                                   _.as_is)
                               (_.by annihilation_of_or))
                          _.as_is)))
                (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @true))]
                    (by_induction (function (_ =that)
                                    (let [=that (_.and (_.by =that) (_.by @false))]
                                      (_.=' (all _.and
                                                 (or _.as_is
                                                     (all _.and
                                                          (_.by_application (_.by_application _.as_is =that) _.as_is)
                                                          (_.by principle_of_explosion)))
                                                 (_.by commutativity_of_or)
                                                 (_.by annihilation_of_or))
                                            _.as_is)))
                                  (function (_ =that)
                                    (let [=that (_.and (_.by =that) (_.by @true))]
                                      (_.=' (all _.and
                                                 (or (all _.and
                                                          (_.by_application (_.by_application _.as_is =this) =that)
                                                          (_.by reflexivity_of_if))
                                                     _.as_is)
                                                 (_.by annihilation_of_or))
                                            _.as_is))))))))

... https://en.wikipedia.org/wiki/Law_of_excluded_middle
(_.the .public complementation_of_if
  (_.let [this that]
    (_.= (.or (/.if this that)
              (/.if this (.not that)))
         .true))
  (by_induction (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @false))
                        principle_of_explosion (all _.and
                                                    (_.by_application (_.by_application _.as_is =this) _.as_is)
                                                    (_.by ..principle_of_explosion))]
                    (_.=' (all _.and
                               (or principle_of_explosion
                                   principle_of_explosion)
                               (_.by idempotence_of_or))
                          _.as_is)))
                (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @true))

                        identity_of_if (all _.and
                                            (_.by_application (_.by_application _.as_is =this) _.as_is)
                                            (_.by ..identity_of_if))]
                    (_.=' (all _.and
                               (or identity_of_if
                                   identity_of_if)
                               (_.by complementation_of_or))
                          _.as_is)))))

(_.the .public contraposition
  (_.let [this that]
    (_.= (/.if this that)
         (/.if (.not that) (.not this))))
  (by_induction (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @false))
                        
                        principle_of_explosion (function (_ it)
                                                 (all _.and
                                                      (if it _.as_is)
                                                      (_.by ..principle_of_explosion)))]
                    (by_induction (function (_ =that)
                                    (let [=that (_.and (_.by =that) (_.by @false))]
                                      (_.=' (principle_of_explosion =this)
                                            (all _.and
                                                 (if (all _.and
                                                          (not =that)
                                                          (_.by true_is_not_false))
                                                     (all _.and
                                                          (not =this)
                                                          (_.by true_is_not_false)))
                                                 (_.by ..identity_of_if)))))
                                  (function (_ =that)
                                    (let [=that (_.and (_.by =that) (_.by @true))]
                                      (_.=' (principle_of_explosion =this)
                                            (principle_of_explosion (all _.and
                                                                         (not =that)
                                                                         (_.by false_is_not_true)))))))))
                (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @true))]
                    (by_induction (function (_ =that)
                                    (let [=that (_.and (_.by =that) (_.by @false))]
                                      (_.=' (if =this =that)
                                            (if (all _.and
                                                     (not =that)
                                                     (_.by true_is_not_false))
                                                (all _.and
                                                     (not =this)
                                                     (_.by false_is_not_true))))))
                                  (function (_ =that)
                                    (let [=that (_.and (_.by =that) (_.by @true))]
                                      (_.=' (all _.and
                                                 (if =this =that)
                                                 (_.by ..identity_of_if))
                                            (all _.and
                                                 (if (all _.and
                                                          (not =that)
                                                          (_.by false_is_not_true))
                                                     _.as_is)
                                                 (_.by ..principle_of_explosion))))))))))

... https://en.wikipedia.org/wiki/Import%E2%80%93export_(logic)
... https://en.wikipedia.org/wiki/Exportation_(logic)
(_.the .public import_export
  (_.let [this that return]
    (_.= (/.if this (/.if that return))
         (/.if (.and this that) return)))
  (by_induction (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @false))]
                    (_.=' (all _.and
                               (if =this _.as_is)
                               (_.by principle_of_explosion))
                          (all _.and
                               (if (all _.and
                                        (and =this _.as_is)
                                        (_.by annihilation_of_and))
                                   _.as_is)
                               (_.by principle_of_explosion)))))
                (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @true))]
                    (_.=' (all _.and
                               (if =this _.as_is)
                               (_.by identity_of_if))
                          (all _.and
                               (if (all _.and
                                        (and =this _.as_is)
                                        (_.by identity_of_and))
                                   _.as_is)))))))

(_.the .public negation_of_if
  (_.let [this that return]
    (_.= (.not (/.if this that))
         (.and this (.not that))))
  (by_induction (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @false))]
                    (_.=' (all _.and
                               (not (all _.and
                                         (if =this _.as_is)
                                         (_.by principle_of_explosion)))
                               (_.by false_is_not_true))
                          (all _.and
                               (and =this _.as_is)
                               (_.by annihilation_of_and)))))
                (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @true))]
                    (_.=' (not (all _.and
                                    (if =this _.as_is)
                                    (_.by ..identity_of_if)))
                          (all _.and
                               (and =this _.as_is)
                               (_.by identity_of_and)))))))

(_.the .public or_if
  (_.let [this that return]
    (_.= (/.if this that)
         (.or (.not this) that)))
  (by_induction (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @false))]
                    (_.=' (all _.and
                               (if =this _.as_is)
                               (_.by principle_of_explosion))
                          (all _.and
                               (or (all _.and
                                        (not =this)
                                        (_.by true_is_not_false))
                                   _.as_is)
                               (_.by annihilation_of_or)))))
                (function (_ =this)
                  (let [=this (_.and (_.by =this) (_.by @true))]
                    (_.=' (all _.and
                               (if =this _.as_is)
                               (_.by ..identity_of_if))
                          (all _.and
                               (or (all _.and
                                        (not =this)
                                        (_.by false_is_not_true))
                                   _.as_is)
                               (_.by identity_of_or)))))))

(_.the .public necessity
  (_.let [it]
    (_.= (/.if it .true)
         .true))
  (by_induction (function (_ this)
                  (let [this (_.and (_.by this) (_.by @false))]
                    (_.=' (all _.and
                               (if this _.as_is)
                               (_.by principle_of_explosion))
                          _.as_is)))
                (function (_ this)
                  (let [this (_.and (_.by this) (_.by @true))]
                    (_.=' (all _.and
                               (if this _.as_is)
                               (_.by ..identity_of_if))
                          _.as_is)))))

... https://en.wikipedia.org/wiki/Commutative_property
(_.the .public commutativity_of_if
  (_.let [this that return]
    (_.= (/.if this (/.if that return))
         (/.if that (/.if this return))))
  (by_induction (function (_ this)
                  (let [this (_.and (_.by this) (_.by @false))

                        principle_of_explosion (all _.and
                                                    (if this _.as_is)
                                                    (_.by ..principle_of_explosion))]
                    (_.=' principle_of_explosion
                          (all _.and
                               (if _.as_is principle_of_explosion)
                               (_.by ..necessity)))))
                (function (_ this)
                  (let [this (_.and (_.by this) (_.by @true))

                        identity_of_if (all _.and
                                            (if this _.as_is)
                                            (_.by ..identity_of_if))]
                    (_.=' identity_of_if
                          (if _.as_is identity_of_if))))))

... https://en.wikipedia.org/wiki/Distributive_property
(_.the .public left_distributivity
  (_.let [this that return]
    (_.= (/.if this (/.if that return))
         (/.if (/.if this that)
               (/.if this return))))
  (by_induction (function (_ this)
                  (let [this (_.and (_.by this) (_.by @false))

                        principle_of_explosion (function (_ it)
                                                 (all _.and
                                                      (if it _.as_is)
                                                      (_.by ..principle_of_explosion)))]
                    (_.=' (principle_of_explosion this)
                          (all _.and
                               (if (principle_of_explosion this)
                                   (principle_of_explosion this))
                               (_.by ..necessity)))))
                (function (_ this)
                  (let [this (_.and (_.by this) (_.by @true))

                        identity_of_if (all _.and
                                            (if this _.as_is)
                                            (_.by ..identity_of_if))]
                    (_.=' identity_of_if
                          (if identity_of_if
                              identity_of_if))))))

... https://en.wikipedia.org/wiki/Equality_(mathematics)#Basic_properties
(the (= this that)
  (-> _.Rule _.Rule
      _.Rule)
  (all _.and
       (_.by_application (all _.and
                              (_.by_application _.by_definition this)
                              _.by_reification)
                         that)
       _.by_reification))

... https://en.wikipedia.org/wiki/Reflexive_relation
(_.the .public reflexivity_of_=
  (_.let [it]
    (_.= (/.= it it)
         .true))
  (by_induction (function (_ it)
                  (let [it (_.and (_.by it) (_.by @false))]
                    (_.=' (all _.and
                               (= it it)
                               (_.by ..if_false)
                               (_.by ..true_is_not_false))
                          _.as_is)))
                (function (_ it)
                  (let [it (_.and (_.by it) (_.by @true))]
                    (_.=' (all _.and
                               (= it it)
                               (_.by ..if_true))
                          _.as_is)))))
