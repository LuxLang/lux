(.module:
  [library
   [lux (#- local)
    [abstract
     [functor (#+ Functor)]
     [apply (#+ Apply)]
     [monad (#+ Monad do)]]]])

(type: .public (State s a)
  {#.doc "Stateful computations."}
  (-> s [s a]))

(def: .public get
  {#.doc "Read the current state."}
  (All [s] (State s s))
  (function (_ state)
    [state state]))

(def: .public (put new_state)
  {#.doc "Set the new state."}
  (All [s] (-> s (State s Any)))
  (function (_ state)
    [new_state []]))

(def: .public (update change)
  {#.doc "Compute the new state."}
  (All [s] (-> (-> s s) (State s Any)))
  (function (_ state)
    [(change state) []]))

(def: .public (use user)
  {#.doc "Run a function on the current state."}
  (All [s a] (-> (-> s a) (State s a)))
  (function (_ state)
    [state (user state)]))

(def: .public (local change action)
  {#.doc "Run the computation with a locally-modified state."}
  (All [s a] (-> (-> s s) (State s a) (State s a)))
  (function (_ state)
    (let [[state' output] (action (change state))]
      [state output])))

(def: .public (run state action)
  {#.doc "Run a stateful computation."}
  (All [s a] (-> s (State s a) [s a]))
  (action state))

(implementation: .public functor
  (All [s] (Functor (State s)))
  
  (def: (map f ma)
    (function (_ state)
      (let [[state' a] (ma state)]
        [state' (f a)]))))

(implementation: .public apply
  (All [s] (Apply (State s)))
  
  (def: &functor ..functor)

  (def: (apply ff fa)
    (function (_ state)
      (let [[state' f] (ff state)
            [state'' a] (fa state')]
        [state'' (f a)]))))

(implementation: .public monad
  (All [s] (Monad (State s)))
  
  (def: &functor ..functor)

  (def: (in a)
    (function (_ state)
      [state a]))

  (def: (join mma)
    (function (_ state)
      (let [[state' ma] (mma state)]
        (ma state')))))

(def: .public (while condition body)
  {#.doc (doc "A stateful while loop.")}
  (All [s] (-> (State s Bit) (State s Any) (State s Any)))
  (do {! ..monad}
    [execute? condition]
    (if execute?
      (do !
        [_ body]
        (while condition body))
      (in []))))

(def: .public (do_while condition body)
  {#.doc (doc "A stateful do-while loop.")}
  (All [s] (-> (State s Bit) (State s Any) (State s Any)))
  (do ..monad
    [_ body]
    (while condition body)))

(implementation: (with//functor functor)
  (All [M s] (-> (Functor M) (Functor (All [a] (-> s (M [s a]))))))
  
  (def: (map f sfa)
    (function (_ state)
      (\ functor map (function (_ [s a]) [s (f a)])
         (sfa state)))))

(implementation: (with//apply monad)
  (All [M s] (-> (Monad M) (Apply (All [a] (-> s (M [s a]))))))
  
  (def: &functor (with//functor (\ monad &functor)))

  (def: (apply sFf sFa)
    (function (_ state)
      (do monad
        [[state f] (sFf state)
         [state a] (sFa state)]
        (in [state (f a)])))))

(type: .public (+State M s a)
  {#.doc "Stateful computations decorated by a monad."}
  (-> s (M [s a])))

(def: .public (run' state action)
  {#.doc "Execute a stateful computation decorated by a monad."}
  (All [M s a] (-> s (+State M s a) (M [s a])))
  (action state))

(implementation: .public (with monad)
  {#.doc "A monad transformer to create composite stateful computations."}
  (All [M s] (-> (Monad M) (Monad (+State M s))))

  (def: &functor (with//functor (\ monad &functor)))

  (def: (in a)
    (function (_ state)
      (\ monad in [state a])))
  
  (def: (join sMsMa)
    (function (_ state)
      (do monad
        [[state' sMa] (sMsMa state)]
        (sMa state')))))

(def: .public (lift monad ma)
  {#.doc "Lift monadic values to the +State wrapper."}
  (All [M s a] (-> (Monad M) (M a) (+State M s a)))
  (function (_ state)
    (do monad
      [a ma]
      (in [state a]))))
