(.require
 [library
  [lux (.except)
   [abstract
    ["[0]" monad (.only do)]]
   [control
    ["<>" parser]]
   [data
    [collection
     ["[0]" list (.use "[1]#[0]" monad)]]]
   ["[0]" macro (.only)
    [syntax (.only syntax)
     ["|[0]|" export]]]
   ["[0]" meta (.only)
    ["[0]" code (.only)
     ["<[1]>" \\parser (.only Parser)]]]]])

(def declaration
  (Parser [Text (List Code)])
  (<code>.form (<>.and <code>.local (<>.some <code>.any))))

(def inline
  (Parser [Code [Text (List Code)] Code Code])
  (|export|.parser
   (all <>.and
        ..declaration
        <code>.any
        <code>.any
        )))

(def .public inlined
  (syntax (_ [[privacy [name parameters] type term] ..inline])
    (do [! meta.monad]
      [@ meta.current_module_name
       g!parameters (|> (macro.symbol "parameter")
                        (list.repeated (list.size parameters))
                        (monad.all !))
       .let [inlined (` (("lux in-module"
                          (~ (code.text @))
                          (.is (~ type)
                               (.function ((~ (code.local name)) (~+ parameters))
                                 (~ term))))
                         (~+ (list#each (function (_ g!parameter)
                                          (` ((~' ~) (~ g!parameter))))
                                        g!parameters))))
             g!parameters (|> g!parameters
                              (list#each (function (_ parameter)
                                           (list parameter (` (~! <code>.any)))))
                              list#conjoint)]]
      (in (list (` (def (~ privacy) (~ (code.local name))
                     ((~! syntax) ((~ (code.local name)) [(~+ g!parameters)])
                      (.at (~! meta.monad) (~' in) (.list (.`' (~ inlined))))))))))))
