(.module:
  [library
   [lux {"-" Definition let def: macro}
    ["[0]" meta]
    [abstract
     ["[0]" monad {"+" do}]]
    [control
     ["[0]" try {"+" Try}]
     ["[0]" exception {"+" exception:}]
     ["<>" parser ("[1]#[0]" monad)
      ["<[0]>" code {"+" Parser}]]]
    [data
     ["[0]" product]
     [text
      ["%" format {"+" format}]]
     [collection
      ["[0]" list ("[1]#[0]" functor)]
      [dictionary
       ["[0]" plist {"+" PList}]]]]
    ["[0]" macro
     ["[0]" local]
     ["[0]" code]
     [syntax {"+" syntax:}
      ["[0]" declaration {"+" Declaration}]]]]]
  ["[0]" //])

(type: Mutual
  (Record
   [#declaration Declaration
    #type Code
    #body Code]))

(.def: mutual
  (Parser [Declaration Code Code])
  ($_ <>.and
      declaration.parser
      <code>.any
      <code>.any
      ))

(.def: (mutual_definition context g!context [g!name mutual])
  (-> (List Code) Code [Code Mutual] Code)
  (` (function ((~ g!name) (~ g!context))
       (.let [[(~+ context)] (~ g!context)]
         (function (~ (declaration.format (value@ #declaration mutual)))
           (~ (value@ #body mutual)))))))

(.def: (macro g!context g!self)
  (-> Code Code Macro)
  (<| (:as Macro)
      (: Macro')
      (function (_ parameters)
        (# meta.monad in (list (` (((~ g!self) (~ g!context)) (~+ parameters))))))))

(syntax: .public (let [functions (<code>.tuple (<>.some ..mutual))
                       body <code>.any])
  (case functions
    {.#End}
    (in (list body))
    
    {.#Item mutual {.#End}}
    (.let [g!name (|> mutual (value@ [#declaration declaration.#name]) code.local_identifier)]
      (in (list (` (.let [(~ g!name) (: (~ (value@ #type mutual))
                                        (function (~ (declaration.format (value@ #declaration mutual)))
                                          (~ (value@ #body mutual))))]
                     (~ body))))))
    
    _
    (macro.with_identifiers [g!context g!output]
      (do [! meta.monad]
        [here_name meta.current_module_name
         hidden_names (monad.each ! (//.constant (macro.identifier "mutual_function#"))
                                  functions)
         .let [definitions (list#each (..mutual_definition hidden_names g!context)
                                      (list.zipped/2 hidden_names
                                                     functions))
               context_types (list#each (function (_ mutual)
                                          (` (-> (~ g!context) (~ (value@ #type mutual)))))
                                        functions)
               user_names (list#each (|>> (value@ [#declaration declaration.#name]) code.local_identifier)
                                     functions)]
         g!pop (local.push (list#each (function (_ [g!name mutual])
                                        [[here_name (value@ [#declaration declaration.#name] mutual)]
                                         (..macro g!context g!name)])
                                      (list.zipped/2 hidden_names
                                                     functions)))]
        (in (list (` (.let [(~ g!context) (: (Rec (~ g!context)
                                               [(~+ context_types)])
                                             [(~+ definitions)])
                            [(~+ user_names)] (.let [[(~+ user_names)] (~ g!context)]
                                                [(~+ (list#each (function (_ g!name)
                                                                  (` ((~ g!name) (~ g!context))))
                                                                user_names))])
                            (~ g!output) (~ body)]
                       (exec (~ g!pop)
                         (~ g!output))))))))))

(type: Definition
  (Record
   [#export_policy Code
    #mutual Mutual]))

(.def: definition
  (Parser Definition)
  (<code>.tuple (<>.either (<>.and <code>.any ..mutual)
                           (<>.and (<>#in (` .private)) ..mutual))))

(syntax: .public (def: [functions (<>.many ..definition)])
  (case functions
    {.#End}
    (in (list))
    
    {.#Item definition {.#End}}
    (.let [(^open "_[0]") definition
           (^open "_[0]") _#mutual]
      (in (list (` (.def: (~ _#export_policy) (~ (declaration.format _#declaration))
                     (~ _#type)
                     (~ _#body))))))
    
    _
    (macro.with_identifiers [g!context g!output]
      (do [! meta.monad]
        [here_name meta.current_module_name
         hidden_names (monad.each ! (//.constant (macro.identifier "mutual_function#"))
                                  functions)
         .let [definitions (list#each (..mutual_definition hidden_names g!context)
                                      (list.zipped/2 hidden_names
                                                     (list#each (value@ #mutual) functions)))
               context_types (list#each (function (_ mutual)
                                          (` (-> (~ g!context) (~ (value@ [#mutual #type] mutual)))))
                                        functions)
               user_names (list#each (|>> (value@ [#mutual #declaration declaration.#name]) code.local_identifier)
                                     functions)]
         g!pop (local.push (list#each (function (_ [g!name mutual])
                                        [[here_name (value@ [#mutual #declaration declaration.#name] mutual)]
                                         (..macro g!context g!name)])
                                      (list.zipped/2 hidden_names
                                                     functions)))]
        (in (list& (` (.def: (~ g!context)
                        [(~+ (list#each (value@ [#mutual #type]) functions))]
                        (.let [(~ g!context) (: (Rec (~ g!context)
                                                  [(~+ context_types)])
                                                [(~+ definitions)])
                               [(~+ user_names)] (~ g!context)]
                          [(~+ (list#each (function (_ g!name)
                                            (` ((~ g!name) (~ g!context))))
                                          user_names))])))
                   g!pop
                   (list#each (function (_ mutual)
                                (.let [g!name (|> mutual (value@ [#mutual #declaration declaration.#name]) code.local_identifier)]
                                  (` (.def:
                                       (~ (value@ #export_policy mutual))
                                       (~ g!name)
                                       (~ (value@ [#mutual #type] mutual))
                                       (.let [[(~+ user_names)] (~ g!context)]
                                         (~ g!name))))))
                              functions)))))))
