(.module:
  {#.doc (.doc "Macros for implementing mutually-recursive functions.")}
  [library
   [lux (#- Definition let def:)
    ["." meta]
    [abstract
     ["." monad (#+ do)]]
    [control
     ["." try (#+ Try)]
     ["." exception (#+ exception:)]
     ["<>" parser ("#\." monad)
      ["<.>" code (#+ Parser)]]]
    [data
     ["." product]
     [text
      ["%" format (#+ format)]]
     [collection
      ["." list ("#\." functor)]
      [dictionary
       ["." plist (#+ PList)]]]]
    ["." macro
     ["." local]
     ["." code]
     [syntax (#+ syntax:)
      ["." declaration (#+ Declaration)]]]]]
  ["." //])

(type: Mutual
  {#declaration Declaration
   #type Code
   #body Code})

(.def: mutual
  (Parser [Declaration Code Code])
  ($_ <>.and
      declaration.parser
      <code>.any
      <code>.any
      ))

(.def: (mutual_definition context g!context [g!name mutual])
  (-> (List Code) Code [Code Mutual] Code)
  (` (function ((~ g!name) (~ g!context))
       (.let [[(~+ context)] (~ g!context)]
         (function (~ (declaration.format (get@ #declaration mutual)))
           (~ (get@ #body mutual)))))))

(.def: (macro g!context g!self)
  (-> Code Code Macro)
  (<| (:as Macro)
      (: Macro')
      (function (_ parameters)
        (\ meta.monad in (list (` (((~ g!self) (~ g!context)) (~+ parameters))))))))

(syntax: .public (let {functions (<code>.tuple (<>.some ..mutual))}
                   body)
  {#.doc (doc "Locally-defined mutually-recursive functions."
              (let [(even? number)
                    (-> Nat Bit)
                    (case number
                      0 true
                      _ (odd? (dec number)))

                    (odd? number)
                    (-> Nat Bit)
                    (case number
                      0 false
                      _ (even? (dec number)))]
                (and (even? 4)
                     (odd? 5))))}
  (case functions
    #.End
    (in (list body))
    
    (#.Item mutual #.End)
    (.let [g!name (|> mutual (get@ [#declaration #declaration.name]) code.local_identifier)]
      (in (list (` (.let [(~ g!name) (: (~ (get@ #type mutual))
                                        (function (~ (declaration.format (get@ #declaration mutual)))
                                          (~ (get@ #body mutual))))]
                     (~ body))))))
    
    _
    (macro.with_gensyms [g!context g!output]
      (do {! meta.monad}
        [here_name meta.current_module_name
         hidden_names (monad.map ! (//.constant (macro.gensym "mutual_function#"))
                                 functions)
         .let [definitions (list\map (..mutual_definition hidden_names g!context)
                                     (list.zipped/2 hidden_names
                                                    functions))
               context_types (list\map (function (_ mutual)
                                         (` (-> (~ g!context) (~ (get@ #type mutual)))))
                                       functions)
               user_names (list\map (|>> (get@ [#declaration #declaration.name]) code.local_identifier)
                                    functions)]
         g!pop (local.push (list\map (function (_ [g!name mutual])
                                       [[here_name (get@ [#declaration #declaration.name] mutual)]
                                        (..macro g!context g!name)])
                                     (list.zipped/2 hidden_names
                                                    functions)))]
        (in (list (` (.let [(~ g!context) (: (Rec (~ g!context)
                                               [(~+ context_types)])
                                             [(~+ definitions)])
                            [(~+ user_names)] (.let [[(~+ user_names)] (~ g!context)]
                                                [(~+ (list\map (function (_ g!name)
                                                                 (` ((~ g!name) (~ g!context))))
                                                               user_names))])
                            (~ g!output) (~ body)]
                       (exec (~ g!pop)
                         (~ g!output))))))))))

(type: Definition
  {#export_policy Code
   #mutual Mutual})

(.def: definition
  (Parser Definition)
  (<code>.tuple (<>.either (<>.and <code>.any ..mutual)
                           (<>.and (<>\in (` .private)) ..mutual))))

(syntax: .public (def: {functions (<>.many ..definition)})
  {#.doc (doc "Globally-defined mutually-recursive functions."
              (def:
                [.public (even? number)
                 (-> Nat Bit)
                 (case number
                   0 true
                   _ (odd? (dec number)))]

                [.public (odd? number)
                 (-> Nat Bit)
                 (case number
                   0 false
                   _ (even? (dec number)))]))}
  (case functions
    #.End
    (in (list))
    
    (#.Item definition #.End)
    (.let [(^slots [#export_policy #mutual]) definition
           (^slots [#declaration #type #body]) mutual]
      (in (list (` (.def: (~ export_policy) (~ (declaration.format declaration))
                     (~ type)
                     (~ body))))))
    
    _
    (macro.with_gensyms [g!context g!output]
      (do {! meta.monad}
        [here_name meta.current_module_name
         hidden_names (monad.map ! (//.constant (macro.gensym "mutual_function#"))
                                 functions)
         .let [definitions (list\map (..mutual_definition hidden_names g!context)
                                     (list.zipped/2 hidden_names
                                                    (list\map (get@ #mutual) functions)))
               context_types (list\map (function (_ mutual)
                                         (` (-> (~ g!context) (~ (get@ [#mutual #type] mutual)))))
                                       functions)
               user_names (list\map (|>> (get@ [#mutual #declaration #declaration.name]) code.local_identifier)
                                    functions)]
         g!pop (local.push (list\map (function (_ [g!name mutual])
                                       [[here_name (get@ [#mutual #declaration #declaration.name] mutual)]
                                        (..macro g!context g!name)])
                                     (list.zipped/2 hidden_names
                                                    functions)))]
        (in (list& (` (.def: (~ g!context)
                        [(~+ (list\map (get@ [#mutual #type]) functions))]
                        (.let [(~ g!context) (: (Rec (~ g!context)
                                                  [(~+ context_types)])
                                                [(~+ definitions)])
                               [(~+ user_names)] (~ g!context)]
                          [(~+ (list\map (function (_ g!name)
                                           (` ((~ g!name) (~ g!context))))
                                         user_names))])))
                   g!pop
                   (list\map (function (_ mutual)
                               (.let [g!name (|> mutual (get@ [#mutual #declaration #declaration.name]) code.local_identifier)]
                                 (` (.def:
                                      (~ (get@ #export_policy mutual))
                                      (~ g!name)
                                      (~ (get@ [#mutual #type] mutual))
                                      (.let [[(~+ user_names)] (~ g!context)]
                                        (~ g!name))))))
                             functions)))))))
