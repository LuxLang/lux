... Inspired by;
... "The Different Aspects of Monads and Mixins" by Bruno C. d. S. Oliveira

(.module:
  [library
   [lux #*
    [abstract
     [monoid (#+ Monoid)]
     [predicate (#+ Predicate)]
     [monad (#+ Monad do)]]]])

(type: .public (Mixin i o)
  {#.doc (doc "A function which can be mixed with others to inherit their behavior.")}
  (-> (-> i o) (-> i o) (-> i o)))

(def: .public (mixin f)
  {#.doc (doc "Given a mixin, produces a normal function.")}
  (All [i o] (-> (Mixin i o) (-> i o)))
  (function (mix input)
    ((f mix mix) input)))

(def: .public nothing
  {#.doc (doc "A mixin that does nothing and just delegates work to the next mixin.")}
  Mixin
  (function (_ delegate recur)
    delegate))

(def: .public (inherit parent child)
  {#.doc (doc "Produces a new mixin, where the behavior of the child can make use of the behavior of the parent.")}
  (All [i o] (-> (Mixin i o) (Mixin i o) (Mixin i o)))
  (function (_ delegate recur)
    (parent (child delegate recur) recur)))

(implementation: .public monoid
  (All [i o] (Monoid (Mixin i o)))

  (def: identity ..nothing)
  (def: compose ..inherit))

(def: .public (advice when then)
  {#.doc (doc "Only apply then mixin when the input meets some criterion.")}
  (All [i o] (-> (Predicate i) (Mixin i o) (Mixin i o)))
  (function (_ delegate recur input)
    (if (when input)
      ((then delegate recur) input)
      (delegate input))))

(def: .public (before monad action)
  {#.doc (doc "Executes an action before doing the main work.")}
  (All [! i o] (-> (Monad !) (-> i (! Any)) (Mixin i (! o))))
  (function (_ delegate recur input)
    (do monad
      [_ (action input)]
      (delegate input))))

(def: .public (after monad action)
  {#.doc (doc "Executes an action after doing the main work.")}
  (All [! i o] (-> (Monad !) (-> i o (! Any)) (Mixin i (! o))))
  (function (_ delegate recur input)
    (do monad
      [output (delegate input)
       _ (action input output)]
      (in output))))

(type: .public (Recursive i o)
  {#.doc (doc "An indirectly recursive function.")}
  (-> (-> i o) (-> i o)))

(def: .public (of_recursive recursive)
  {#.doc (doc "Transform an indirectly recursive function into a mixin.")}
  (All [i o] (-> (Recursive i o) (Mixin i o)))
  (function (_ delegate recur)
    (recursive recur)))
