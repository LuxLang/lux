(.require
 [library
  [lux (.except list with)
   [abstract
    [monoid (.only Monoid)]
    [equivalence (.only Equivalence)]
    [hash (.only Hash)]
    [apply (.only Apply)]
    ["[0]" functor (.only Functor)]
    ["[0]" monad (.only Monad do)]]
   [meta
    ["[0]" location]]]])

... (type (Maybe a)
...   {.#None}
...   {.#Some a})

(def .public monoid
  (All (_ a) (Monoid (Maybe a)))
  (implementation
   (def identity
     {.#None})
   
   (def (composite mx my)
     (case mx
       {.#None}
       my
       
       _
       mx))))

(def .public functor
  (Functor Maybe)
  (implementation
   (def (each f ma)
     (case ma
       {.#Some a}
       {.#Some (f a)}
       
       ... {.#None}
       it
       (as_expected it)))))

(def .public apply
  (Apply Maybe)
  (implementation
   (def functor ..functor)

   (def (on fa ff)
     (case [ff fa]
       [{.#Some f} {.#Some a}]
       {.#Some (f a)}

       _
       {.#None}))))

(def .public monad
  (Monad Maybe)
  (implementation
   (def functor ..functor)

   (def (in x)
     {.#Some x})

   (def (conjoint mma)
     (case mma
       {.#Some mx}
       mx
       
       ... {.#None}
       it
       (as_expected it)))))

(def .public (equivalence super)
  (All (_ a) (-> (Equivalence a) (Equivalence (Maybe a))))
  (implementation
   (def (= mx my)
     (case [mx my]
       [{.#None} {.#None}]
       #1

       [{.#Some x} {.#Some y}]
       (at super = x y)
       
       _
       #0))))

(def .public (hash super)
  (All (_ a) (-> (Hash a) (Hash (Maybe a))))
  (implementation
   (def equivalence
     (..equivalence (at super equivalence)))
   
   (def (hash value)
     (case value
       {.#None}
       1

       {.#Some value}
       (at super hash value)))))

(def .public (with monad)
  (All (_ M) (-> (Monad M) (Monad (All (_ a) (M (Maybe a))))))
  (implementation
   (def functor
     (functor.composite (the monad.functor monad)
                        ..functor))

   (def in
     (|>> (at ..monad in)
          (at monad in)))
   
   (def (conjoint MmMma)
     (do monad
       [mMma MmMma]
       (case mMma
         {.#Some Mma}
         Mma

         ... {.#None}
         it
         (in (as_expected it)))))))

(def .public (lifted monad)
  (All (_ M a) (-> (Monad M) (-> (M a) (M (Maybe a)))))
  (at monad each (at ..monad in)))

(def .public else
  (macro (_ tokens state)
    (case tokens
      (.list else maybe)
      (let [g!temp (is Code [location.dummy {.#Symbol ["" ""]}])]
        {.#Right [state (.list (` (.case (, maybe)
                                    {.#Some (, g!temp)}
                                    (, g!temp)

                                    ... {.#None}
                                    (, g!temp)
                                    (, else))))]})

      _
      {.#Left "Wrong syntax for 'else'"})))

(def .public trusted
  (All (_ a) (-> (Maybe a) a))
  (|>> (..else (undefined))))

(def .public (list value)
  (All (_ a) (-> (Maybe a) (List a)))
  (case value
    {.#Some value}
    (.list value)

    ... {.#None}
    _
    (.list)))

(def .public when
  (macro (_ tokens state)
    (case tokens
      (.list test then)
      {.#Right [state (.list (` (.if (, test)
                                  (, then)
                                  {.#None})))]}

      _
      {.#Left "Wrong syntax for 'when'"})))
