(.module:
  [library
   [lux #*
    [abstract
     [apply (#+ Apply)]
     [equivalence (#+ Equivalence)]
     ["." functor (#+ Functor)]
     ["." monad (#+ Monad do)]]
    [meta
     ["." location]]]])

(type: .public (Try a)
  {#.doc (example "A computation that can fail with an error message.")}
  (#Failure Text)
  (#Success a))

(implementation: .public functor
  (Functor Try)
  
  (def: (map f ma)
    (case ma
      (#Failure msg)
      (#Failure msg)
      
      (#Success datum)
      (#Success (f datum)))))

(implementation: .public apply
  (Apply Try)
  
  (def: &functor ..functor)

  (def: (apply ff fa)
    (case ff
      (#Success f)
      (case fa
        (#Success a)
        (#Success (f a))

        (#Failure msg)
        (#Failure msg))

      (#Failure msg)
      (#Failure msg))))

(implementation: .public monad
  (Monad Try)
  
  (def: &functor ..functor)

  (def: (in a)
    (#Success a))

  (def: (join mma)
    (case mma
      (#Failure msg)
      (#Failure msg)
      
      (#Success ma)
      ma)))

(implementation: .public (with monad)
  {#.doc (example "Enhances a monad with error-handling functionality.")}
  ... TODO: Replace (All [a] (! (Try a))) with (functor.Then ! Try)
  (All [!] (-> (Monad !) (Monad (All [a] (! (Try a))))))
  
  (def: &functor
    (functor.compose (get@ #monad.&functor monad) ..functor))

  (def: in
    (|>> (\ ..monad in)
         (\ monad in)))
  
  (def: (join MeMea)
    (do monad
      [eMea MeMea]
      (case eMea
        (#Failure try)
        (in (#Failure try))

        (#Success Mea)
        Mea))))

(def: .public (lifted monad)
  {#.doc (example "Wraps a monadic value with error-handling machinery.")}
  (All [! a] (-> (Monad !) (-> (! a) (! (Try a)))))
  (\ monad map (\ ..monad in)))

(implementation: .public (equivalence (^open "_\."))
  (All [a] (-> (Equivalence a) (Equivalence (Try a))))

  (def: (= reference sample)
    (case [reference sample]
      [(#Success reference) (#Success sample)]
      (_\= reference sample)

      [(#Failure reference) (#Failure sample)]
      ("lux text =" reference sample)

      _
      false
      )))

(def: .public (assumed try)
  {#.doc (example "Assumes a Try value succeeded, and yields its value."
                  "If it didn't, raises the error as a runtime error."
                  "WARNING: Use with caution.")}
  (All [a] (-> (Try a) a))
  (case try
    (#Success value)
    value

    (#Failure message)
    (panic! message)))

(def: .public (maybe try)
  (All [a] (-> (Try a) (Maybe a)))
  (case try
    (#Success value)
    (#.Some value)

    (#Failure message)
    #.None))

(def: .public (of_maybe maybe)
  (All [a] (-> (Maybe a) (Try a)))
  (case maybe
    (#.Some value)
    (#Success value)

    #.None
    (#Failure (`` (("lux in-module" (~~ (static .prelude_module)) .name\encode)
                   (name_of ..of_maybe))))))

(macro: .public (else tokens compiler)
  {#.doc (example "Allows you to provide a default value that will be used"
                  "if a (Try x) value turns out to be #Failure."
                  "Note: the expression for the default value will not be computed if the base computation succeeds."
                  (= "bar"
                     (else "foo" (#..Success "bar")))
                  (= "foo"
                     (else "foo" (#..Failure "KABOOM!"))))}
  (case tokens
    (^ (list else try))
    (#Success [compiler (list (` (case (~ try)
                                   (#..Success (~' g!temp))
                                   (~' g!temp)

                                   (#..Failure (~ [location.dummy (#.Identifier ["" ""])]))
                                   (~ else))))])

    _
    (#Failure "Wrong syntax for else")))
