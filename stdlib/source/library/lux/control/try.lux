(.require
 [library
  [lux (.except with)
   ["@" target]
   [abstract
    [apply (.only Apply)]
    [equivalence (.only Equivalence)]
    ["[0]" functor (.only Functor)]
    ["[0]" monad (.only Monad do)]]
   [meta
    ["[0]" location]]]])

(type: .public (Try a)
  (Variant
   {#Failure Text}
   {#Success a}))

(def .public functor
  (Functor Try)
  (implementation
   (def (each f ma)
     (case ma
       {#Success datum}
       {#Success (f datum)}

       ... {#Failure msg}
       it
       (as_expected it)))))

(def .public apply
  (Apply Try)
  (implementation
   (def functor ..functor)

   (def (on fa ff)
     (case ff
       {#Success f}
       (case fa
         {#Success a}
         {#Success (f a)}

         ... {#Failure msg}
         it
         (as_expected it))

       ... {#Failure msg}
       it
       (as_expected it)))))

(def .public monad
  (Monad Try)
  (implementation
   (def functor ..functor)

   (def (in a)
     {#Success a})

   (def (conjoint mma)
     (case mma
       {#Success ma}
       ma
       
       ... {#Failure msg}
       it
       (as_expected it)))))

(def .public (with monad)
  ... TODO: Replace (All (_ a) (! (Try a))) with (functor.Then ! Try)
  (All (_ !) (-> (Monad !) (Monad (All (_ a) (! (Try a))))))
  (implementation
   (def functor
     (functor.composite (the monad.functor monad)
                        ..functor))

   (def in
     (|>> (at ..monad in)
          (at monad in)))
   
   (def (conjoint MeMea)
     (do monad
       [eMea MeMea]
       (case eMea
         {#Success Mea}
         Mea
         
         ... {#Failure error}
         it
         (in (as_expected it)))))))

(def .public (lifted monad)
  (All (_ ! a) (-> (Monad !) (-> (! a) (! (Try a)))))
  (at monad each (at ..monad in)))

(def .public (equivalence (open "_#[0]"))
  (All (_ a) (-> (Equivalence a) (Equivalence (Try a))))
  (implementation
   (def (= reference sample)
     (case [reference sample]
       [{#Success reference} {#Success sample}]
       (_#= reference sample)

       [{#Failure reference} {#Failure sample}]
       ("lux text =" reference sample)

       _
       false
       ))))

(def .public (trusted try)
  (All (_ a)
    (-> (Try a) a))
  (case try
    {#Success value}
    value

    {#Failure message}
    (panic! message)))

(def .public (maybe try)
  (All (_ a)
    (-> (Try a) (Maybe a)))
  (case try
    {#Success value}
    {.#Some value}

    ... {#Failure message}
    _
    {.#None}))

(def .public (of_maybe maybe)
  (All (_ a)
    (-> (Maybe a) (Try a)))
  (case maybe
    {.#Some value}
    {#Success value}

    {.#None}
    {#Failure (`` (("lux in-module" (~~ (static .prelude)) .symbol#encoded)
                   (symbol ..of_maybe)))}))

(def .public else
  (macro (_ tokens compiler)
    (case tokens
      (pattern (list else try))
      {#Success [compiler (list (` (case (~ try)
                                     {..#Success (~' g!temp)}
                                     (~' g!temp)

                                     ... {..#Failure (~' g!temp)}
                                     (~' g!temp)
                                     (~ else))))]}

      _
      {#Failure "Wrong syntax for 'else'"})))

(def .public when
  (macro (_ tokens state)
    (case tokens
      (pattern (.list test then))
      (let [code#encoded ("lux in-module" "library/lux" .code#encoded)
            text$ ("lux in-module" "library/lux" .text$)]
        {.#Right [state (.list (` (.if (~ test)
                                    (~ then)
                                    {..#Failure (~ (text$ (all "lux text concat"
                                                               "[" (code#encoded (` .when)) "]"
                                                               " " "Invalid condition:")))})))]})

      _
      {.#Left "Wrong syntax for 'when'"})))
