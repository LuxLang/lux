(.module:
  [library
   [lux (#- Alias if loop)
    ["." meta]
    [abstract
     ["." monad]]
    [control
     ["." maybe ("#\." monad)]]
    [data
     ["." text
      ["%" format (#+ format)]]
     [collection
      ["." list ("#\." fold functor)]]]
    ["." macro (#+ with_identifiers)
     ["." code]
     ["." template]
     [syntax (#+ syntax:)
      ["|.|" annotations]]]
    [math
     [number
      ["n" nat]
      ["i" int]
      ["r" rev]
      ["f" frac]]]]]
  [//
   ["<>" parser ("#\." monad)
    ["<.>" code (#+ Parser)]]])

(type: Alias
  [Text Code])

(type: Stack
  {#bottom (Maybe Nat)
   #top (List Code)})

(def: aliases^
  (Parser (List Alias))
  (|> (<>.and <code>.local_identifier <code>.any)
      <>.some
      <code>.record
      (<>.else (list))))

(def: bottom^
  (Parser Nat)
  (<code>.form (<>.after (<code>.this! (` #.Parameter)) <code>.nat)))

(def: stack^
  (Parser Stack)
  (<>.either (<>.and (<>.maybe bottom^)
                     (<code>.tuple (<>.some <code>.any)))
             (<>.and (|> bottom^ (<>\map (|>> #.Some)))
                     (<>\in (list)))))

(def: (stack_fold tops bottom)
  (-> (List Code) Code Code)
  (list\fold (function (_ top bottom)
               (` [(~ bottom) (~ top)]))
             bottom
             tops))

(def: (singleton expander)
  (-> (Meta (List Code)) (Meta Code))
  (monad.do meta.monad
    [expansion expander]
    (case expansion
      (#.Item singleton #.End)
      (in singleton)

      _
      (meta.failure (format "Cannot expand to more than a single AST/Code node:" text.new_line
                            (|> expansion (list\map %.code) (text.interposed " ")))))))

(syntax: .public (=> [aliases aliases^
                      inputs stack^
                      outputs stack^])
  (let [de_alias (function (_ aliased)
                   (list\fold (function (_ [from to] pre)
                                (code.replaced (code.local_identifier from) to pre))
                              aliased
                              aliases))]
    (case [(|> inputs (get@ #bottom) (maybe\map (|>> code.nat (~) #.Parameter (`))))
           (|> outputs (get@ #bottom) (maybe\map (|>> code.nat (~) #.Parameter (`))))]
      [(#.Some bottomI) (#.Some bottomO)]
      (monad.do meta.monad
        [inputC (singleton (macro.full_expansion (stack_fold (get@ #top inputs) bottomI)))
         outputC (singleton (macro.full_expansion (stack_fold (get@ #top outputs) bottomO)))]
        (in (list (` (-> (~ (de_alias inputC))
                         (~ (de_alias outputC)))))))

      [?bottomI ?bottomO]
      (with_identifiers [g!stack]
        (monad.do meta.monad
          [inputC (singleton (macro.full_expansion (stack_fold (get@ #top inputs) (maybe.else g!stack ?bottomI))))
           outputC (singleton (macro.full_expansion (stack_fold (get@ #top outputs) (maybe.else g!stack ?bottomO))))]
          (in (list (` (All [(~ g!stack)]
                         (-> (~ (de_alias inputC))
                             (~ (de_alias outputC))))))))))))

(def: begin!
  Any
  [])

(def: end!
  (All [a] (-> [Any a] a))
  (function (_ [_ top])
    top))

(syntax: .public (||> [commands (<>.some <code>.any)])
  (in (list (` (|> (~! ..begin!) (~+ commands) ((~! ..end!)))))))

(def: word
  (Parser [Code Text |annotations|.Annotations Code (List Code)])
  (let [private (: (Parser [Text |annotations|.Annotations Code (List Code)])
                   ($_ <>.and
                       <code>.local_identifier
                       (<>.else |annotations|.empty |annotations|.parser)
                       <code>.any
                       (<>.many <code>.any)))]
    ($_ <>.either
        (<>.and <code>.any private)
        (<>.and (<>\in (` .private)) private)
        )))

(syntax: .public (word: [[export_policy name annotations type commands] ..word])
  (in (list (` (def: (~ export_policy) (~ (code.local_identifier name))
                 (~ (|annotations|.format annotations))
                 (~ type)
                 (|>> (~+ commands)))))))

(syntax: .public (apply [arity (<>.only (n.> 0) <code>.nat)])
  (with_identifiers [g! g!func g!stack g!output]
    (monad.do {! meta.monad}
      [g!inputs (|> (macro.identifier "input") (list.repeated arity) (monad.seq !))]
      (in (list (` (: (All [(~+ g!inputs) (~ g!output)]
                        (-> (-> (~+ g!inputs) (~ g!output))
                            (=> [(~+ g!inputs)] [(~ g!output)])))
                      (function ((~ g!) (~ g!func))
                        (function ((~ g!) (~ (stack_fold g!inputs g!stack)))
                          [(~ g!stack) ((~ g!func) (~+ g!inputs))])))))))))

(template [<arity>]
  [(`` (def: .public (~~ (template.identifier ["apply/" <arity>]))
         (..apply <arity>)))]

  [1] [2] [3] [4]
  [5] [6] [7] [8]
  )

(def: .public (push x)
  (All [a] (-> a (=> [] [a])))
  (function (_ stack)
    [stack x]))

(def: .public drop
  (All [t] (=> [t] []))
  (function (_ [stack top])
    stack))

(def: .public nip
  (All [_ a] (=> [_ a] [a]))
  (function (_ [[stack _] top])
    [stack top]))

(def: .public dup
  (All [a] (=> [a] [a a]))
  (function (_ [stack top])
    [[stack top] top]))

(def: .public swap
  (All [a b] (=> [a b] [b a]))
  (function (_ [[stack l] r])
    [[stack r] l]))

(def: .public rotL
  (All [a b c] (=> [a b c] [b c a]))
  (function (_ [[[stack a] b] c])
    [[[stack b] c] a]))

(def: .public rotR
  (All [a b c] (=> [a b c] [c a b]))
  (function (_ [[[stack a] b] c])
    [[[stack c] a] b]))

(def: .public &&
  (All [a b] (=> [a b] [(Tuple a b)]))
  (function (_ [[stack l] r])
    [stack [l r]]))

(def: .public ||L
  (All [a b] (=> [a] [(Or a b)]))
  (function (_ [stack l])
    [stack (0 #0 l)]))

(def: .public ||R
  (All [a b] (=> [b] [(Or a b)]))
  (function (_ [stack r])
    [stack (0 #1 r)]))

(template [<input> <output> <word> <func>]
  [(`` (def: .public <word>
         (=> [<input> <input>] [<output>])
         (function (_ [[stack subject] param])
           [stack (<func> param subject)])))]

  [Nat Nat  n/+  n.+]
  [Nat Nat  n/-  n.-]
  [Nat Nat  n/*  n.*]
  [Nat Nat  n//  n./]
  [Nat Nat  n/%  n.%]
  [Nat Bit  n/=  n.=]
  [Nat Bit  n/<  n.<]
  [Nat Bit  n/<= n.<=]
  [Nat Bit  n/>  n.>]
  [Nat Bit  n/>= n.>=]

  [Int Int  i/+  i.+]
  [Int Int  i/-  i.-]
  [Int Int  i/*  i.*]
  [Int Int  i//  i./]
  [Int Int  i/%  i.%]
  [Int Bit  i/=  i.=]
  [Int Bit  i/<  i.<]
  [Int Bit  i/<= i.<=]
  [Int Bit  i/>  i.>]
  [Int Bit  i/>= i.>=]

  [Rev Rev  r/+  r.+]
  [Rev Rev  r/-  r.-]
  [Rev Rev  r/*  r.*]
  [Rev Rev  r//  r./]
  [Rev Rev  r/%  r.%]
  [Rev Bit  r/=  r.=]
  [Rev Bit  r/<  r.<]
  [Rev Bit  r/<= r.<=]
  [Rev Bit  r/>  r.>]
  [Rev Bit  r/>= r.>=]

  [Frac Frac f/+  f.+]
  [Frac Frac f/-  f.-]
  [Frac Frac f/*  f.*]
  [Frac Frac f//  f./]
  [Frac Frac f/%  f.%]
  [Frac Bit  f/=  f.=]
  [Frac Bit  f/<  f.<]
  [Frac Bit  f/<= f.<=]
  [Frac Bit  f/>  f.>]
  [Frac Bit  f/>= f.>=]
  )

(def: .public if
  (All [___a ___z]
    (=> {then (=> ___a ___z)
         else (=> ___a ___z)}
        ___a [Bit then else] ___z))
  (function (_ [[[stack test] then] else])
    (.if test
      (then stack)
      (else stack))))

(def: .public call
  (All [___a ___z]
    (=> {quote (=> ___a ___z)}
        ___a [quote] ___z))
  (function (_ [stack quote])
    (quote stack)))

(def: .public loop
  (All [___]
    (=> {test (=> ___ ___ [Bit])}
        ___ [test] ___))
  (function (loop [stack pred])
    (let [[stack' verdict] (pred stack)]
      (.if verdict
        (loop [stack' pred])
        stack'))))

(def: .public dip
  (All [___ a]
    (=> ___ [a (=> ___ ___)]
        ___ [a]))
  (function (_ [[stack a] quote])
    [(quote stack) a]))

(def: .public dip/2
  (All [___ a b]
    (=> ___ [a b (=> ___ ___)]
        ___ [a b]))
  (function (_ [[[stack a] b] quote])
    [[(quote stack) a] b]))

(def: .public do
  (All [___a ___z]
    (=> {body (=> ___a ___z)
         pred (=> ___z ___a [Bit])}
        ___a [pred body]
        ___z [pred body]))
  (function (_ [[stack pred] body])
    [[(body stack) pred] body]))

(def: .public while
  (All [___a ___z]
    (=> {body (=> ___z ___a)
         pred (=> ___a ___z [Bit])}
        ___a [pred body]
        ___z))
  (function (while [[stack pred] body])
    (let [[stack' verdict] (pred stack)]
      (.if verdict
        (while [[(body stack') pred] body])
        stack'))))

(def: .public compose
  (All [___a ___ ___z]
    (=> [(=> ___a ___) (=> ___ ___z)]
        [(=> ___a ___z)]))
  (function (_ [[stack f] g])
    [stack (|>> f g)]))

(def: .public partial
  (All [___a ___z a]
    (=> ___a [a (=> ___a [a] ___z)]
        ___a [(=> ___a ___z)]))
  (function (_ [[stack arg] quote])
    [stack (|>> (push arg) quote)]))

(word: .public when
  (All [___]
    (=> {body (=> ___ ___)}
        ___ [Bit body]
        ___))
  swap
  (push ..call)
  (push ..drop)
  if)

(word: .public ?
  (All [a]
    (=> [Bit a a] [a]))
  rotL
  (push ..drop)
  (push ..nip)
  if)
