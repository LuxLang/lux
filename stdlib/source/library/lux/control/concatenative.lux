(.module:
  [library
   [lux (#- Alias if loop)
    ["." meta]
    [abstract
     ["." monad]]
    [data
     ["." maybe ("#\." monad)]
     ["." text
      ["%" format (#+ format)]]
     [collection
      ["." list ("#\." fold functor)]]]
    ["." macro (#+ with_gensyms)
     ["." code]
     ["." template]
     [syntax (#+ syntax:)
      ["|.|" annotations]]]
    [math
     [number
      ["n" nat]
      ["i" int]
      ["r" rev]
      ["f" frac]]]]]
  [//
   ["<>" parser ("#\." monad)
    ["<.>" code (#+ Parser)]]])

(type: Alias [Text Code])

(type: Stack
  {#bottom (Maybe Nat)
   #top (List Code)})

(def: aliases^
  (Parser (List Alias))
  (|> (<>.and <code>.local_identifier <code>.any)
      <>.some
      <code>.record
      (<>.else (list))))

(def: bottom^
  (Parser Nat)
  (<code>.form (<>.after (<code>.this! (` #.Parameter)) <code>.nat)))

(def: stack^
  (Parser Stack)
  (<>.either (<>.and (<>.maybe bottom^)
                     (<code>.tuple (<>.some <code>.any)))
             (<>.and (|> bottom^ (<>\map (|>> #.Some)))
                     (<>\in (list)))))

(def: (stack_fold tops bottom)
  (-> (List Code) Code Code)
  (list\fold (function (_ top bottom)
               (` [(~ bottom) (~ top)]))
             bottom
             tops))

(def: (singleton expander)
  (-> (Meta (List Code)) (Meta Code))
  (monad.do meta.monad
    [expansion expander]
    (case expansion
      (#.Item singleton #.End)
      (in singleton)

      _
      (meta.failure (format "Cannot expand to more than a single AST/Code node:" text.new_line
                            (|> expansion (list\map %.code) (text.join_with " ")))))))

(syntax: .public (=> {aliases aliases^}
                     {inputs stack^}
                     {outputs stack^})
  {#.doc (doc "Concatenative function types."
              (=> [Nat] [Nat])
              (All [a] (-> a (=> [] [a])))
              (All [t] (=> [t] []))
              (All [a b c] (=> [a b c] [b c a]))
              (All [___a ___z]
                (=> {then (=> ___a ___z)
                     else (=> ___a ___z)}
                    ___a [Bit then else] ___z)))}
  (let [de_alias (function (_ aliased)
                   (list\fold (function (_ [from to] pre)
                                (code.replaced (code.local_identifier from) to pre))
                              aliased
                              aliases))]
    (case [(|> inputs (get@ #bottom) (maybe\map (|>> code.nat (~) #.Parameter (`))))
           (|> outputs (get@ #bottom) (maybe\map (|>> code.nat (~) #.Parameter (`))))]
      [(#.Some bottomI) (#.Some bottomO)]
      (monad.do meta.monad
        [inputC (singleton (macro.full_expansion (stack_fold (get@ #top inputs) bottomI)))
         outputC (singleton (macro.full_expansion (stack_fold (get@ #top outputs) bottomO)))]
        (in (list (` (-> (~ (de_alias inputC))
                         (~ (de_alias outputC)))))))

      [?bottomI ?bottomO]
      (with_gensyms [g!stack]
        (monad.do meta.monad
          [inputC (singleton (macro.full_expansion (stack_fold (get@ #top inputs) (maybe.else g!stack ?bottomI))))
           outputC (singleton (macro.full_expansion (stack_fold (get@ #top outputs) (maybe.else g!stack ?bottomO))))]
          (in (list (` (All [(~ g!stack)]
                         (-> (~ (de_alias inputC))
                             (~ (de_alias outputC))))))))))))

(def: begin! Any [])

(def: end!
  (All [a] (-> [Any a] a))
  (function (_ [_ top])
    top))

(syntax: .public (||> {commands (<>.some <code>.any)})
  {#.doc (doc "A self-contained sequence of concatenative instructions."
              (is? value
                   (||> (..push sample)))

              (||> (push 123)
                   dup
                   n/=))}
  (in (list (` (|> (~! ..begin!) (~+ commands) ((~! ..end!)))))))

(def: word
  (Parser [Code Text |annotations|.Annotations Code (List Code)])
  (let [private (: (Parser [Text |annotations|.Annotations Code (List Code)])
                   ($_ <>.and
                       <code>.local_identifier
                       (<>.else |annotations|.empty |annotations|.parser)
                       <code>.any
                       (<>.many <code>.any)))]
    ($_ <>.either
        (<>.and <code>.any private)
        (<>.and (<>\in (` .private)) private)
        )))

(syntax: .public (word:
                   {[export_policy name annotations type commands] ..word})
  {#.doc (doc "A named concatenative function."
              (word: square
                (=> [Nat] [Nat])

                dup
                (apply/2 n.*)))}
  (in (list (` (def: (~ export_policy) (~ (code.local_identifier name))
                 (~ (|annotations|.format annotations))
                 (~ type)
                 (|>> (~+ commands)))))))

(syntax: .public (apply {arity (<>.only (n.> 0) <code>.nat)})
  {#.doc (doc "A generator for functions that turn arity N functions into arity N concatenative functions."
              (: (=> [Nat] [Nat])
                 ((apply 1) inc)))}
  (with_gensyms [g! g!func g!stack g!output]
    (monad.do {! meta.monad}
      [g!inputs (|> (macro.gensym "input") (list.repeated arity) (monad.seq !))]
      (in (list (` (: (All [(~+ g!inputs) (~ g!output)]
                        (-> (-> (~+ g!inputs) (~ g!output))
                            (=> [(~+ g!inputs)] [(~ g!output)])))
                      (function ((~ g!) (~ g!func))
                        (function ((~ g!) (~ (stack_fold g!inputs g!stack)))
                          [(~ g!stack) ((~ g!func) (~+ g!inputs))])))))))))

(template [<arity>]
  [(with_expansions [<name> (template.identifier ["apply/" <arity>])
                     <doc> (template.text ["Lift a function of arity " <arity>
                                           " into a concatenative function of arity " <arity> "."])]
     (def: .public <name>
       {#.doc (doc <doc>)}
       (apply <arity>)))]

  [1] [2] [3] [4]
  [5] [6] [7] [8]
  )

(def: .public (push x)
  {#.doc (doc "Push a value onto the stack.")}
  (All [a] (-> a (=> [] [a])))
  (function (_ stack)
    [stack x]))

(def: .public drop
  {#.doc (doc "Drop/pop a value from the top of the stack.")}
  (All [t] (=> [t] []))
  (function (_ [stack top])
    stack))

(def: .public nip
  {#.doc (doc "Drop the second-to-last value from the top of the stack.")}
  (All [_ a] (=> [_ a] [a]))
  (function (_ [[stack _] top])
    [stack top]))

(def: .public dup
  {#.doc (doc "Duplicate the top of the stack.")}
  (All [a] (=> [a] [a a]))
  (function (_ [stack top])
    [[stack top] top]))

(def: .public swap
  {#.doc (doc "Swaps the 2 topmost stack values.")}
  (All [a b] (=> [a b] [b a]))
  (function (_ [[stack l] r])
    [[stack r] l]))

(def: .public rotL
  {#.doc (doc "Rotes the 3 topmost stack values to the left.")}
  (All [a b c] (=> [a b c] [b c a]))
  (function (_ [[[stack a] b] c])
    [[[stack b] c] a]))

(def: .public rotR
  {#.doc (doc "Rotes the 3 topmost stack values to the right.")}
  (All [a b c] (=> [a b c] [c a b]))
  (function (_ [[[stack a] b] c])
    [[[stack c] a] b]))

(def: .public &&
  {#.doc (doc "Groups the 2 topmost stack values as a 2-tuple.")}
  (All [a b] (=> [a b] [(Tuple a b)]))
  (function (_ [[stack l] r])
    [stack [l r]]))

(def: .public ||L
  {#.doc (doc "Left-injects the top into sum.")}
  (All [a b] (=> [a] [(Or a b)]))
  (function (_ [stack l])
    [stack (0 #0 l)]))

(def: .public ||R
  {#.doc (doc "Right-injects the top into sum.")}
  (All [a b] (=> [b] [(Or a b)]))
  (function (_ [stack r])
    [stack (0 #1 r)]))

(template [<input> <output> <word> <func>]
  [(`` (def: .public <word>
         {#.doc (doc (~~ (template.text [<func> " for " <input> " arithmetic."])))}
         (=> [<input> <input>] [<output>])
         (function (_ [[stack subject] param])
           [stack (<func> param subject)])))]

  [Nat Nat  n/+  n.+]
  [Nat Nat  n/-  n.-]
  [Nat Nat  n/*  n.*]
  [Nat Nat  n//  n./]
  [Nat Nat  n/%  n.%]
  [Nat Bit  n/=  n.=]
  [Nat Bit  n/<  n.<]
  [Nat Bit  n/<= n.<=]
  [Nat Bit  n/>  n.>]
  [Nat Bit  n/>= n.>=]

  [Int Int  i/+  i.+]
  [Int Int  i/-  i.-]
  [Int Int  i/*  i.*]
  [Int Int  i//  i./]
  [Int Int  i/%  i.%]
  [Int Bit  i/=  i.=]
  [Int Bit  i/<  i.<]
  [Int Bit  i/<= i.<=]
  [Int Bit  i/>  i.>]
  [Int Bit  i/>= i.>=]

  [Rev Rev  r/+  r.+]
  [Rev Rev  r/-  r.-]
  [Rev Rev  r/*  r.*]
  [Rev Rev  r//  r./]
  [Rev Rev  r/%  r.%]
  [Rev Bit  r/=  r.=]
  [Rev Bit  r/<  r.<]
  [Rev Bit  r/<= r.<=]
  [Rev Bit  r/>  r.>]
  [Rev Bit  r/>= r.>=]

  [Frac Frac f/+  f.+]
  [Frac Frac f/-  f.-]
  [Frac Frac f/*  f.*]
  [Frac Frac f//  f./]
  [Frac Frac f/%  f.%]
  [Frac Bit  f/=  f.=]
  [Frac Bit  f/<  f.<]
  [Frac Bit  f/<= f.<=]
  [Frac Bit  f/>  f.>]
  [Frac Bit  f/>= f.>=]
  )

(def: .public if
  {#.doc (doc "If expression."
              (is? "then"
                   (||> (push true)
                        (push "then")
                        (push "else")
                        if)))}
  (All [___a ___z]
    (=> {then (=> ___a ___z)
         else (=> ___a ___z)}
        ___a [Bit then else] ___z))
  (function (_ [[[stack test] then] else])
    (.if test
      (then stack)
      (else stack))))

(def: .public call
  {#.doc (doc "Executes an anonymous block on the stack.")}
  (All [___a ___z]
    (=> {quote (=> ___a ___z)}
        ___a [quote] ___z))
  (function (_ [stack quote])
    (quote stack)))

(def: .public loop
  {#.doc (doc "Executes a block as a loop until it yields #0 to stop.")}
  (All [___]
    (=> {test (=> ___ ___ [Bit])}
        ___ [test] ___))
  (function (loop [stack pred])
    (let [[stack' verdict] (pred stack)]
      (.if verdict
        (loop [stack' pred])
        stack'))))

(def: .public dip
  {#.doc (doc "Executes a block on the stack, save for the topmost value.")}
  (All [___ a]
    (=> ___ [a (=> ___ ___)]
        ___ [a]))
  (function (_ [[stack a] quote])
    [(quote stack) a]))

(def: .public dip/2
  {#.doc (doc "Executes a block on the stack, save for the 2 topmost values.")}
  (All [___ a b]
    (=> ___ [a b (=> ___ ___)]
        ___ [a b]))
  (function (_ [[[stack a] b] quote])
    [[(quote stack) a] b]))

(def: .public do
  {#.doc (doc "Do-while loop expression."
              (n.= (inc sample)
                   (||> (push sample)
                        (push (push false))
                        (push (|>> (push 1) n/+))
                        do while)))}
  (All [___a ___z]
    (=> {body (=> ___a ___z)
         pred (=> ___z ___a [Bit])}
        ___a [pred body]
        ___z [pred body]))
  (function (_ [[stack pred] body])
    [[(body stack) pred] body]))

(def: .public while
  {#.doc (doc "While loop expression."
              (n.= (n.+ distance start)
                   (||> (push start)
                        (push (|>> dup
                                   (push start) n/-
                                   (push distance) n/<))
                        (push (|>> (push 1) n/+))
                        while)))}
  (All [___a ___z]
    (=> {body (=> ___z ___a)
         pred (=> ___a ___z [Bit])}
        ___a [pred body]
        ___z))
  (function (while [[stack pred] body])
    (let [[stack' verdict] (pred stack)]
      (.if verdict
        (while [[(body stack') pred] body])
        stack'))))

(def: .public compose
  {#.doc (doc "Function composition."
              (n.= (n.+ 2 sample)
                   (||> (push sample)
                        (push (|>> (push 1) n/+))
                        (push (|>> (push 1) n/+))
                        compose
                        call)))}
  (All [___a ___ ___z]
    (=> [(=> ___a ___) (=> ___ ___z)]
        [(=> ___a ___z)]))
  (function (_ [[stack f] g])
    [stack (|>> f g)]))

(def: .public partial
  {#.doc (doc "Partial application."
              (n.= (n.+ sample sample)
                   (||> (push sample)
                        (push sample)
                        (push n/+)
                        partial
                        call)))}
  (All [___a ___z a]
    (=> ___a [a (=> ___a [a] ___z)]
        ___a [(=> ___a ___z)]))
  (function (_ [[stack arg] quote])
    [stack (|>> (push arg) quote)]))

(word: .public when
  {#.doc (doc "Only execute the block when #1.")}
  (All [___]
    (=> {body (=> ___ ___)}
        ___ [Bit body]
        ___))
  swap
  (push ..call)
  (push ..drop)
  if)

(word: .public ?
  {#.doc (doc "Choose the top value when #0 and the second-to-top when #1.")}
  (All [a]
    (=> [Bit a a] [a]))
  rotL
  (push ..drop)
  (push ..nip)
  if)
