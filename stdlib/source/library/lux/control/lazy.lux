(.using
 [library
  [lux (.except)
   [abstract
    [functor (.only Functor)]
    [apply (.only Apply)]
    [monad (.only Monad do)]
    [equivalence (.only Equivalence)]]
   [control
    ["[0]" io]
    [parser
     ["<[0]>" code]]
    [concurrency
     ["[0]" atom]]]
   [macro (.only with_symbols)
    [syntax (.only syntax:)]]
   [type (.only sharing)
    [primitive (.except)]]]])

(primitive: .public (Lazy a)
  (-> [] a)

  (def: (lazy' generator)
    (All (_ a) (-> (-> [] a) (Lazy a)))
    (let [cache (atom.atom (sharing [a]
                                    (-> [] a)
                                    generator

                                    (Maybe a)
                                    {.#None}))]
      (abstraction (function (_ _)
                     (case (io.run! (atom.read! cache))
                       {.#Some value}
                       value

                       _
                       (let [value (generator [])]
                         (exec
                           (io.run! (atom.compare_and_swap! _ {.#Some value} cache))
                           value)))))))

  (def: .public (value lazy)
    (All (_ a) (-> (Lazy a) a))
    ((representation lazy) [])))

(syntax: .public (lazy [expression <code>.any])
  (with_symbols [g!_]
    (in (list (` ((~! ..lazy') (function ((~ g!_) (~ g!_)) (~ expression))))))))

(implementation: .public (equivalence (open "_#[0]"))
  (All (_ a) (-> (Equivalence a) (Equivalence (Lazy a))))
  
  (def: (= left right)
    (_#= (..value left)
         (..value right))))

(implementation: .public functor
  (Functor Lazy)
  
  (def: (each f fa)
    (lazy (f (value fa)))))

(implementation: .public apply
  (Apply Lazy)
  
  (def: functor ..functor)
  (def: (on fa ff)
    (lazy ((value ff) (value fa)))))

(implementation: .public monad
  (Monad Lazy)
  
  (def: functor ..functor)
  (def: in (|>> lazy))
  (def: conjoint ..value))
