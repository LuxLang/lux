(.module:
  [library
   [lux #*
    ["@" target]
    [abstract
     [functor (#+ Functor)]
     [apply (#+ Apply)]
     [monad (#+ Monad do)]]
    [control
     ["." io (#+ IO)]]
    [data
     [collection
      ["." array (#+ Array)]]]
    [type
     abstract]]])

(type: #export (Thread ! a)
  {#.doc (doc "An imperative process with access to mutable values.")}
  (-> ! a))

(abstract: #export (Box t v)
  (Array v)

  {#.doc "A mutable box holding a value."}

  (def: #export (box init)
    {#.doc (doc "A brand-new box initialized to the given value.")}
    (All [a] (-> a (All [!] (Thread ! (Box ! a)))))
    (function (_ !)
      (|> (array.empty 1)
          (array.write! 0 init)
          :abstraction)))

  (def: #export (read box)
    {#.doc (doc "Reads the current value in the box.")}
    (All [! a] (-> (Box ! a) (Thread ! a)))
    (function (_ !)
      (for {@.old
            ("jvm aaload" (:representation box) 0)

            @.jvm
            ("jvm array read object"
             (|> 0
                 (:as (primitive "java.lang.Long"))
                 "jvm object cast"
                 "jvm conversion long-to-int")
             (:representation box))

            @.js ("js array read" 0 (:representation box))
            @.python ("python array read" 0 (:representation box))
            @.lua ("lua array read" 0 (:representation box))
            @.ruby ("ruby array read" 0 (:representation box))
            @.php ("php array read" 0 (:representation box))
            @.scheme ("scheme array read" 0 (:representation box))})))

  (def: #export (write value box)
    {#.doc (doc "Mutates the value in the box.")}
    (All [a] (-> a (All [!] (-> (Box ! a) (Thread ! Any)))))
    (function (_ !)
      (|> box :representation (array.write! 0 value) :abstraction)))
  )

(def: #export (run thread)
  {#.doc (doc "Executes the imperative thread in a self-contained way.")}
  (All [a]
    (-> (All [!] (Thread ! a))
        a))
  (thread []))

(def: #export io
  {#.doc (doc "Transforms the imperative thread into an I/O computation.")}
  (All [a]
    (-> (All [!] (Thread ! a))
        (IO a)))
  (|>> ..run io.io))

(implementation: #export functor
  (All [!] (Functor (Thread !)))

  (def: (map f)
    (function (_ fa)
      (function (_ !)
        (f (fa !))))))

(implementation: #export apply
  (All [!] (Apply (Thread !)))

  (def: &functor ..functor)

  (def: (apply ff fa)
    (function (_ !)
      ((ff !) (fa !)))))

(implementation: #export monad
  (All [!] (Monad (Thread !)))

  (def: &functor ..functor)

  (def: (in value)
    (function (_ !)
      value))

  (def: (join ffa)
    (function (_ !)
      ((ffa !) !))))

(def: #export (update f box)
  {#.doc (doc "Update a box's value by applying a function to it.")}
  (All [a !] (-> (-> a a) (Box ! a) (Thread ! a)))
  (do ..monad
    [old (read box)
     _ (write (f old) box)]
    (in old)))
