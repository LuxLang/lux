(.module:
  {#.doc "Composable extensions to the piping macros (|> and <|) that enhance them with various abilities."}
  [library
   [lux #*
    [abstract
     [monad (#+ do)]]
    [control
     ["." try]
     ["<>" parser
      ["<.>" code (#+ Parser)]]]
    [data
     ["." identity]
     [collection
      ["." list ("#\." fold monad)]]]
    [macro (#+ with_identifiers)
     [syntax (#+ syntax:)]
     ["." code]]
    [math
     [number
      ["n" nat]
      ["i" int]]]]])

(def: body^
  (Parser (List Code))
  (<code>.tuple (<>.some <code>.any)))

(syntax: .public (new> [start <code>.any
                        body body^
                        prev <code>.any])
  {#.doc (example "Ignores the piped argument, and begins a new pipe."
                  (n.= 1
                       (|> 20
                           (n.* 3)
                           (n.+ 4)
                           (new> 0 [inc]))))}
  (in (list (` (|> (~ start) (~+ body))))))

(syntax: .public (let> [binding <code>.any
                        body <code>.any
                        prev <code>.any])
  {#.doc (example "Gives a name to the piped-argument, within the given expression."
                  (n.= 10
                       (|> 5
                           (let> x (n.+ x x)))))}
  (in (list (` (let [(~ binding) (~ prev)]
                 (~ body))))))

(def: _reversed_
  (Parser Any)
  (function (_ tokens)
    (#try.Success [(list.reversed tokens) []])))

(syntax: .public (cond> [_ _reversed_
                         prev <code>.any
                         else body^
                         _ _reversed_
                         branches (<>.some (<>.and body^ body^))])
  {#.doc (example "Branching for pipes."
                  "Both the tests and the bodies are piped-code, and must be given inside a tuple."
                  (|> +5
                      (cond> [i.even?] [(i.* +2)]
                             [i.odd?] [(i.* +3)]
                             [(new> -1 [])])))}
  (with_identifiers [g!temp]
    (in (list (` (let [(~ g!temp) (~ prev)]
                   (cond (~+ (do list.monad
                               [[test then] branches]
                               (list (` (|> (~ g!temp) (~+ test)))
                                     (` (|> (~ g!temp) (~+ then))))))
                         (|> (~ g!temp) (~+ else)))))))))

(syntax: .public (if> [test body^
                       then body^
                       else body^
                       prev <code>.any])
  {#.doc (example "If-branching."
                  (is? (if (n.even? sample)
                         "even"
                         "odd")
                       (|> sample
                           (if> [n.even?]
                                [(new> "even" [])]
                                [(new> "odd" [])]))))}
  (in (list (` (cond> [(~+ test)] [(~+ then)]
                      [(~+ else)]
                      (~ prev))))))

(syntax: .public (when> [test body^
                         then body^
                         prev <code>.any])
  {#.doc (example "Only execute the body when the test passes."
                  (is? (if (n.even? sample)
                         (n.* 2 sample)
                         sample)
                       (|> sample
                           (when> [n.even?]
                                  [(n.* 2)]))))}
  (in (list (` (cond> [(~+ test)] [(~+ then)]
                      []
                      (~ prev))))))

(syntax: .public (loop> [test body^
                         then body^
                         prev <code>.any])
  {#.doc (example "Loops for pipes."
                  "Both the testing and calculating steps are pipes and must be given inside tuples."
                  (|> +1
                      (loop> [(i.< +10)]
                             [inc])))}
  (with_identifiers [g!temp]
    (in (list (` (loop [(~ g!temp) (~ prev)]
                   (if (|> (~ g!temp) (~+ test))
                     ((~' recur) (|> (~ g!temp) (~+ then)))
                     (~ g!temp))))))))

(syntax: .public (do> [monad <code>.any
                       steps (<>.some body^)
                       prev <code>.any])
  {#.doc (example "Monadic pipes."
                  "Each steps in the monadic computation is a pipe and must be given inside a tuple."
                  (|> +5
                      (do> identity.monad
                           [(i.* +3)]
                           [(i.+ +4)]
                           [inc])))}
  (with_identifiers [g!temp]
    (case (list.reversed steps)
      (^ (list& last_step prev_steps))
      (let [step_bindings (do list.monad
                            [step (list.reversed prev_steps)]
                            (list g!temp (` (|> (~ g!temp) (~+ step)))))]
        (in (list (` ((~! do) (~ monad)
                      [.let [(~ g!temp) (~ prev)]
                       (~+ step_bindings)]
                      (|> (~ g!temp) (~+ last_step)))))))

      _
      (in (list prev)))))

(syntax: .public (exec> [body body^
                         prev <code>.any])
  {#.doc (example "Non-updating pipes."
                  "Will generate piped computations, but their results will not be used in the larger scope."
                  (|> +5
                      (exec> [.nat %n log!])
                      (i.* +10)))}
  (with_identifiers [g!temp]
    (in (list (` (let [(~ g!temp) (~ prev)]
                   (exec (|> (~ g!temp) (~+ body))
                     (~ g!temp))))))))

(syntax: .public (tuple> [paths (<>.many body^)
                          prev <code>.any])
  {#.doc (example "Parallel branching for pipes."
                  "Allows to run multiple pipelines for a value and gives you a tuple of the outputs."
                  (|> +5
                      (tuple> [(i.* +10)]
                              [dec (i./ +2)]
                              [Int/encode]))
                  "Will become: [+50 +2 '+5']")}
  (with_identifiers [g!temp]
    (in (list (` (let [(~ g!temp) (~ prev)]
                   [(~+ (list\map (function (_ body) (` (|> (~ g!temp) (~+ body))))
                                  paths))]))))))

(syntax: .public (case> [branches (<>.many (<>.and <code>.any <code>.any))
                         prev <code>.any])
  {#.doc (example "Pattern-matching for pipes."
                  "The bodies of each branch are NOT pipes; just regular values."
                  (|> +5
                      (case> +0 "zero"
                             +1 "one"
                             +2 "two"
                             +3 "three"
                             +4 "four"
                             +5 "five"
                             +6 "six"
                             +7 "seven"
                             +8 "eight"
                             +9 "nine"
                             _ "???")))}
  (in (list (` (case (~ prev)
                 (~+ (list\join (list\map (function (_ [pattern body]) (list pattern body))
                                          branches))))))))
