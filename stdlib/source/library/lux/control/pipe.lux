(.module:
  [library
   [lux "*"
    [abstract
     [monad {"+" [do]}]]
    [control
     ["[0]" try]
     ["<>" parser
      ["<[0]>" code {"+" [Parser]}]]]
    [data
     ["[0]" identity]
     [collection
      ["[0]" list ("[1]\[0]" monad)]]]
    [macro {"+" [with_identifiers]}
     [syntax {"+" [syntax:]}]
     ["[0]" code]]
    [math
     [number
      ["n" nat]
      ["i" int]]]]])

(def: body^
  (Parser (List Code))
  (<code>.tuple (<>.some <code>.any)))

(syntax: .public (new> [start <code>.any
                        body body^
                        prev <code>.any])
  (in (list (` (|> (~ start) (~+ body))))))

(syntax: .public (let> [binding <code>.any
                        body <code>.any
                        prev <code>.any])
  (in (list (` (let [(~ binding) (~ prev)]
                 (~ body))))))

(def: _reversed_
  (Parser Any)
  (function (_ tokens)
    {#try.Success [(list.reversed tokens) []]}))

(syntax: .public (cond> [_ _reversed_
                         prev <code>.any
                         else body^
                         _ _reversed_
                         branches (<>.some (<>.and body^ body^))])
  (with_identifiers [g!temp]
    (in (list (` (let [(~ g!temp) (~ prev)]
                   (cond (~+ (do list.monad
                               [[test then] branches]
                               (list (` (|> (~ g!temp) (~+ test)))
                                     (` (|> (~ g!temp) (~+ then))))))
                         (|> (~ g!temp) (~+ else)))))))))

(syntax: .public (if> [test body^
                       then body^
                       else body^
                       prev <code>.any])
  (in (list (` (cond> [(~+ test)] [(~+ then)]
                      [(~+ else)]
                      (~ prev))))))

(syntax: .public (when> [test body^
                         then body^
                         prev <code>.any])
  (in (list (` (cond> [(~+ test)] [(~+ then)]
                      []
                      (~ prev))))))

(syntax: .public (loop> [test body^
                         then body^
                         prev <code>.any])
  (with_identifiers [g!temp]
    (in (list (` (loop [(~ g!temp) (~ prev)]
                   (if (|> (~ g!temp) (~+ test))
                     ((~' recur) (|> (~ g!temp) (~+ then)))
                     (~ g!temp))))))))

(syntax: .public (do> [monad <code>.any
                       steps (<>.some body^)
                       prev <code>.any])
  (with_identifiers [g!temp]
    (case (list.reversed steps)
      (^ (list& last_step prev_steps))
      (let [step_bindings (do list.monad
                            [step (list.reversed prev_steps)]
                            (list g!temp (` (|> (~ g!temp) (~+ step)))))]
        (in (list (` ((~! do) (~ monad)
                      [.let [(~ g!temp) (~ prev)]
                       (~+ step_bindings)]
                      (|> (~ g!temp) (~+ last_step)))))))

      _
      (in (list prev)))))

(syntax: .public (exec> [body body^
                         prev <code>.any])
  (with_identifiers [g!temp]
    (in (list (` (let [(~ g!temp) (~ prev)]
                   (exec (|> (~ g!temp) (~+ body))
                     (~ g!temp))))))))

(syntax: .public (tuple> [paths (<>.many body^)
                          prev <code>.any])
  (with_identifiers [g!temp]
    (in (list (` (let [(~ g!temp) (~ prev)]
                   [(~+ (list\each (function (_ body) (` (|> (~ g!temp) (~+ body))))
                                   paths))]))))))

(syntax: .public (case> [branches (<>.many (<>.and <code>.any <code>.any))
                         prev <code>.any])
  (in (list (` (case (~ prev)
                 (~+ (|> branches
                         (list\each (function (_ [pattern body]) (list pattern body)))
                         list\conjoint)))))))
