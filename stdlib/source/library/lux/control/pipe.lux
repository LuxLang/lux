... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except let if exec when tuple)
   [abstract
    ["<>" projection]
    ["[0]" monad]]
   [error
    ["[0]" try]]
   [data
    [collection
     ["[0]" list (.use "[1]#[0]" monad)]
     ["[0]" stack (.use "[1]#[0]" monad)]]]
   [math
    [number
     ["n" natural]
     ["i" integer]]]
   [macro (.only with_names)
    ["[0]" syntax]]
   [meta
    ["[0]" code (.only)
     ["<[1]>" \\projection (.only Projection)]]]]])

(the body
  (Projection (List Code))
  (<code>.tuple (<>.some <code>.any)))

(the .public new
  (syntax.macro (_ [start <code>.any
                    body ..body
                    prev <code>.any])
    (in (stack (` (|> (, start)
                      (,* (list.as_stack body))))))))

(the .public let
  (syntax.macro (_ [binding <code>.any
                    body <code>.any
                    prev <code>.any])
    (in (stack (` (.let [(, binding) (, prev)]
                    (, body)))))))

(the _reversed_
  (Projection Any)
  (function (_ tokens)
    {try.#Success [(stack.reversed tokens) []]}))

(the .public if
  (syntax.macro (_ [_ _reversed_
                    prev <code>.any
                    else ..body
                    _ _reversed_
                    branches (<>.some (<>.and ..body ..body))])
    (with_names ['temp]
      (in (stack (` (.let [(, 'temp) (, prev)]
                      (.if (,* (list.as_stack
                                (monad.do list.monad
                                  [[test then] branches]
                                  (list (` (|> (, 'temp) (,* (list.as_stack test))))
                                        (` (|> (, 'temp) (,* (list.as_stack then))))))))
                        (|> (, 'temp)
                            (,* (list.as_stack else)))))))))))

(the .public while
  (syntax.macro (_ [test ..body
                    then ..body
                    prev <code>.any])
    (with_names ['temp 'again]
      (in (stack (` (.loop ((, 'again) [(, 'temp) (, prev)])
                      (.if (|> (, 'temp)
                               (,* (list.as_stack test)))
                        ((, 'again) (|> (, 'temp)
                                        (,* (list.as_stack then))))
                        (, 'temp)))))))))

(the .public do
  (syntax.macro (_ [monad <code>.any
                    steps (<>.some ..body)
                    prev <code>.any])
    (with_names ['temp]
      (.when (list.as_stack (list.reversed steps))
        (stack.partial last_step prev_steps)
        (.let [step_bindings (monad.do stack.monad
                               [step (stack.reversed prev_steps)]
                               (stack 'temp (` (|> (, 'temp) (,* (list.as_stack step))))))]
          (in (stack (` (monad.do (, monad)
                          [.let [(, 'temp) (, prev)]
                           (,* step_bindings)]
                          (|> (, 'temp)
                              (,* (list.as_stack last_step))))))))

        _
        (in (stack prev))))))

(the .public exec
  (syntax.macro (_ [body ..body
                    prev <code>.any])
    (with_names ['temp]
      (in (stack (` (.let [(, 'temp) (, prev)]
                      (.exec
                        (|> (, 'temp)
                            (,* (list.as_stack body)))
                        (, 'temp)))))))))

(the .public tuple
  (syntax.macro (_ [paths (<>.many ..body)
                    prev <code>.any])
    (with_names ['temp]
      (in (stack (` (.let [(, 'temp) (, prev)]
                      [(,* (list.as_stack (list#each (function (_ body) (` (|> (, 'temp) (,* (list.as_stack body)))))
                                                     paths)))])))))))

(the .public when
  (syntax.macro (_ [branches (<>.many (<>.and <code>.any <code>.any))
                    prev <code>.any])
    (in (stack (` (.when (, prev)
                    (,* (|> branches
                            (list#each (function (_ [pattern body]) (list pattern body)))
                            list#conjoint
                            list.as_stack))))))))
