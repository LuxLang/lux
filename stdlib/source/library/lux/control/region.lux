(.module:
  [library
   [lux #*
    [abstract
     [functor (#+ Functor)]
     [apply (#+ Apply)]
     ["." monad (#+ Monad do)]]
    [control
     ["." try (#+ Try)]]
    [data
     ["." text
      ["%" format (#+ format)]]
     [collection
      ["." list ("#\." fold)]]]]]
  [//
   ["." exception (#+ Exception exception:)]])

(type: (Cleaner r !)
  (-> r (! (Try Any))))

(type: .public (Region r ! a)
  {#.doc (example "A region where resources may be be claimed and where a side-effecting computation may be performed."
                  "Every resource is paired with a function that knows how to clean/reclaim it, to make sure there are no leaks.")}
  (-> [r (List (Cleaner r !))]
      (! [(List (Cleaner r !))
          (Try a)])))

(def: separator
  Text
  (format text.new_line
          "-----------------------------------------" text.new_line
          "-----------------------------------------" text.new_line
          "-----------------------------------------" text.new_line
          text.new_line))

(exception: .public [a] (clean_up_error {error Text}
                                        {output (Try a)})
  (format error
          (case output
            (#try.Success _)
            ""

            (#try.Failure error|output)
            (format separator
                    error|output))))

(def: (clean clean_up output)
  (All [a] (-> (Try Any) (Try a) (Try a)))
  (case clean_up
    (#try.Success _)
    output

    (#try.Failure error)
    (exception.except ..clean_up_error [error output])))

(def: .public (run! monad computation)
  {#.doc (example "Executes a region-based computation, with a side-effect determined by the monad.")}
  (All [! a]
    (-> (Monad !) (All [r] (Region r ! a))
        (! (Try a))))
  (do {! monad}
    [[cleaners output] (computation [[] (list)])]
    (|> cleaners
        (monad.map ! (function (_ cleaner) (cleaner [])))
        (\ ! map (list\fold clean output)))))

(def: .public (acquire! monad cleaner value)
  {#.doc (example "Acquire a resource while pairing it a function that knows how to reclaim it.")}
  (All [! a] (-> (Monad !) (-> a (! (Try Any))) a
                 (All [r] (Region r ! a))))
  (function (_ [region cleaners])
    (\ monad in [(#.Item (function (_ region) (cleaner value))
                         cleaners)
                 (#try.Success value)])))

(implementation: .public (functor super)
  (All [!]
    (-> (Functor !)
        (All [r] (Functor (Region r !)))))

  (def: (map f)
    (function (_ fa)
      (function (_ region+cleaners)
        (\ super map
           (function (_ [cleaners' temp])
             [cleaners' (case temp
                          (#try.Success value)
                          (#try.Success (f value))

                          (#try.Failure error)
                          (#try.Failure error))])
           (fa region+cleaners))))))

(implementation: .public (apply super)
  (All [!]
    (-> (Monad !)
        (All [r] (Apply (Region r !)))))

  (def: &functor
    (..functor (get@ #monad.&functor super)))

  (def: (apply ff fa)
    (function (_ [region cleaners])
      (do super
        [[cleaners ef] (ff [region cleaners])
         [cleaners ea] (fa [region cleaners])]
        (case ef
          (#try.Success f)
          (case ea
            (#try.Success a)
            (in [cleaners (#try.Success (f a))])
            
            (#try.Failure error)
            (in [cleaners (#try.Failure error)]))
          
          (#try.Failure error)
          (in [cleaners (#try.Failure error)]))))))

(implementation: .public (monad super)
  (All [!]
    (-> (Monad !)
        (All [r] (Monad (Region r !)))))

  (def: &functor
    (..functor (get@ #monad.&functor super)))

  (def: (in value)
    (function (_ [region cleaners])
      (\ super in [cleaners (#try.Success value)])))

  (def: (join ffa)
    (function (_ [region cleaners])
      (do super
        [[cleaners efa] (ffa [region cleaners])]
        (case efa
          (#try.Success fa)
          (fa [region cleaners])

          (#try.Failure error)
          (in [cleaners (#try.Failure error)]))))))

(def: .public (failure monad error)
  {#.doc (example "Immediately fail with this 'message'.")}
  (All [! a]
    (-> (Monad !) Text
        (All [r] (Region r ! a))))
  (function (_ [region cleaners])
    (\ monad in [cleaners (#try.Failure error)])))

(def: .public (except monad exception message)
  {#.doc (example "Fail by throwing/raising an exception.")}
  (All [! e a]
    (-> (Monad !) (Exception e) e
        (All [r] (Region r ! a))))
  (failure monad (exception.error exception message)))

(def: .public (lifted monad operation)
  {#.doc (example "Lift an effectful computation into a region-based computation.")}
  (All [! a]
    (-> (Monad !) (! a)
        (All [r] (Region r ! a))))
  (function (_ [region cleaners])
    (\ monad map
       (|>> #try.Success [cleaners])
       operation)))
