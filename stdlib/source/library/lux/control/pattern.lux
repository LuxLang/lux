... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

... ["Type-safe pattern combinators" by Morten Rhiger](https://core.ac.uk/works/9613163)
(.require
 [library
  [lux (.except Pattern And
                nat int rev
                or and
                is has
                left right
                when)
   [abstract
    [equivalence (.only Equivalence)]]
   [control
    [pure (.only Pure)]
    ["[0]" function (.only)
     [predicate (.only Predicate)]]]
   [data
    ["[0]" bit]
    ["[0]" text]
    [collection
     [list
      ["[0]" property]]]]
   [math
    [number
     ["[0]" nat]
     ["[0]" int]
     ["[0]" rev]
     ["[0]" frac]]]
   [meta
    ["[0]" type]]]]
 [/
  ["[0]" input]
  ["[0]" match]
  ["[0]" body]])

... Pattern
(every .public (Pattern composition input outer inner value)
  (Record
   [#composition composition
    #match (-> input (body.Body outer inner value))]))

(the .public (or left right)
  (All (_ number input outer inner value)
    (type.let [choice (Pattern number input outer inner value)]
      (-> choice choice
          choice)))
  (let [[number left] left
        [_ right] right]
    [number
     (function (_ input)
       (body.or (left input)
                (right input)))]))

(with_template [,tag ,side]
  [(the .public (,side it)
     (All (_ number
             outer inner
             value
             left right)
       (-> (Pattern number ,side outer inner value)
           (Pattern number (Or left right) outer inner value)))
     (let [[number it] it]
       [number
        (function (_ value)
          (.when value
            {0 ,tag value}
            (it value)

            _
            body.failure))]))]

  [#0 left]
  [#1 right]
  )

(the And
  (template (_ ,left ,right ,pair)
    [(All (_ number_0 number_1 number_2
             arity_0 arity_1 arity_2
             value)
       (-> (Pattern (-> number_0 number_1) ,left arity_1 arity_2 value)
           (Pattern (-> number_1 number_2) ,right arity_0 arity_1 value)
           (Pattern (-> number_0 number_2) ,pair arity_0 arity_2 value)))]))

(the .public (and left right)
  (All (_ input)
    (And input input
         input))
  (let [[numberL left] left
        [numberR right] right]
    [(|>> numberL numberR)
     (function (_ input)
       (body.and (left input)
                 (right input)))]))

(the .public (pair left right)
  (All (_ left right)
    (And left right
         (.And left right)))
  (let [[numberL leftM] left
        [numberR rightM] right]
    [(|>> numberL numberR)
     (function (_ [leftV rightV])
       (body.and (leftM leftV)
                 (rightM rightV)))]))

(the .public (item pattern)
  (All (_ of number outer inner value)
    (-> (Pattern number of outer inner value)
        (Pattern number (List of) outer inner value)))
  (let [[number match] pattern]
    [number
     (function (again input)
       (.when input
         {.#End}
         body.failure

         {.#Item head tail}
         (body.or (match head)
                  (function (_ next exit stack)
                    ((again tail) next exit stack)))))]))

(every .public (Static of)
  (All (_ value arity)
    (Pattern match.Zero of arity (input.One arity) value)))

(the .public none
  Static
  [match.zero
   (function.constant body.failure)])

(the .public any
  Static
  [match.zero
   (function.constant body.success)])

(the .public (is predicate)
  (All (_ of)
    (-> (Predicate of)
        (Static of)))
  [match.zero
   (function (_ input)
     (if (predicate input)
       body.success
       body.failure))])

(the .public (constant = expected)
  (All (_ of)
    (-> (Equivalence of) of
        (Static of)))
  (..is (= expected)))

(with_template [,type ,name ,equivalence]
  [(the .public ,name
     (-> ,type
         (Static ,type))
     (..constant ,equivalence))]

  [Bit bit bit.equivalence]
  [Nat nat nat.equivalence]
  [Int int int.equivalence]
  [Rev rev rev.equivalence]
  [Frac frac frac.equivalence]
  [Text text text.equivalence]
  )

(every .public (Dynamic input of)
  (All (_ value arity)
    (Pattern match.Succ (input of) arity (input.Succ of arity) value)))

(the .public variable
  (Dynamic Pure)
  [match.succ
   body.succ])

(the .public (has key)
  (-> Text
      (Dynamic property.List))
  (..item (..pair (..text key)
                  ..variable)))

(the .public (first predicate)
  (All (_ of)
    (-> (Predicate of)
        (Dynamic List of)))
  (..item (..and (..is predicate)
                 ..variable)))

... Clause
(every .public (Composition term arity value)
  (type.let [negative term
             positive (body.Then arity value)]
    (-> match.Constant
        (-> negative positive))))

(every .public (Clause input value)
  (-> input (body.Else value)
      value))

(every .public (Case input term value)
  (Ex (_ arity)
    (..Pattern (Composition term arity value)
               input input.Zero arity value)))

(the .public (clause pattern body)
  (All (_ input term value)
    (-> (Case input term value) term
        (Clause input value)))
  (function (_ input exit)
    (let [[number match] pattern]
      ((match input) (number match.constant body) exit []))))

(the .public (else left right)
  (All (_ input value)
    (-> (Clause input value) (Clause input value)
        (Clause input value)))
  (function (_ input exit)
    (left input
          (function (_ _)
            (right input exit)))))

... Main
(the .public (when input clause)
  (All (_ input value)
    (-> input (Clause input value)
        value))
  (clause input
          (function (_ _)
            (undefined))))

(the .public (match? pattern input)
  (All (_ of)
    (-> (Case of Bit Bit)
        (Predicate of)))
  (<| (..when input)
      (all ..else
           (..clause pattern true)
           (..clause ..any false))))

(the .public (abstraction pattern body)
  (All (_ input term value)
    (-> (Case input term value) term
        (-> input value)))
  (function (_ input)
    (..when input (..clause pattern body))))
