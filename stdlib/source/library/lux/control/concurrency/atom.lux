... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except)
   ["[0]" ffi]
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" function]
    ["[0]" io (.only IO) (.use "[1]#[0]" functor)]]
   [data
    ["[0]" product]
    [collection
     ["[0]" array
      ["[1]" \\unsafe]]]]
   [meta
    [type
     ["[0]" nominal]
     ["[0]" variance (.only Mutable)]]]]])

(for .jvm (ffi.import (java/util/concurrent/atomic/AtomicReference a)
            "[1]::[0]"
            (new [a])
            (get [] a)
            (compareAndSet [a a] boolean))
     (these))

(nominal.every .public (Atom'' a)
  (for .jvm (java/util/concurrent/atomic/AtomicReference a)
       (array.Array a))

  (every .public (Atom' r w)
    (Atom'' (Mutable r w)))

  (every .public (Atom a)
    (Atom'' (Mutable a a)))

  (the .public (atom value)
    (for_any (_ a) (-> a (Atom a)))
    (nominal.abstraction
     (for .jvm (as_expected (java/util/concurrent/atomic/AtomicReference::new [value]))
          (array.has! 0 (variance.write value) (array.empty 1)))))

  (the .public (read! atom)
    (for_any (_ r w) (-> (Atom' r w) (IO r)))
    (io.io (for .jvm (java/util/concurrent/atomic/AtomicReference::get [] (nominal.representation atom))
                (variance.read (array.item 0 (nominal.representation atom))))))

  (the .public (compare_and_swap! current new atom)
    (for_any (_ r w) (-> r w (Atom' r w) (IO Bit)))
    (io.io (for .jvm (ffi.of_boolean
                      (java/util/concurrent/atomic/AtomicReference::compareAndSet [current new] (nominal.representation atom)))
                (if (|> (nominal.representation atom)
                        (array.item 0)
                        variance.read
                        (same? current))
                  (exec
                    (array.has! 0 (variance.write new) (nominal.representation atom))
                    true)
                  false))))
  )

(the .public (update! f atom)
  (for_any (_ r w) (-> (-> r w) (Atom' r w) (IO [r w])))
  (loop (again [_ []])
    (do io.monad
      [old (read! atom)
       .let [new (f old)]
       swapped? (compare_and_swap! old new atom)]
      (if swapped?
        (in [old new])
        (again [])))))

(the .public (write! value atom)
  (for_any (_ r w) (-> w (Atom' r w) (IO r)))
  (|> atom
      (..update! (function.constant value))
      (io#each product.left)))
