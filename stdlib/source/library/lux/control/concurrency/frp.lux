(.module:
  [library
   [lux (#- list)
    [abstract
     [equivalence (#+ Equivalence)]
     [functor (#+ Functor)]
     [apply (#+ Apply)]
     ["." monad (#+ Monad do)]]
    [control
     ["." maybe ("#\." functor)]
     ["." try (#+ Try)]
     ["." exception (#+ exception:)]
     ["." io (#+ IO io)]]
    [type (#+ :sharing)
     abstract]]]
  [//
   ["." atom (#+ Atom)]
   ["." async (#+ Async) ("#\." functor)]])

(type: .public (Channel a)
  (Async (Maybe [a (Channel a)])))

(exception: .public channel_is_already_closed)

(interface: .public (Sink a)
  (: (IO (Try Any))
     close)
  (: (-> a (IO (Try Any)))
     feed))

(def: (sink resolve)
  (All [a]
    (-> (async.Resolver (Maybe [a (Channel a)]))
        (Sink a)))
  (let [sink (atom.atom resolve)]
    (implementation
     (def: close
       (loop [_ []]
         (do {! io.monad}
           [current (atom.read! sink)
            stopped? (current #.None)]
           (if stopped?
             ... I closed the sink.
             (in (#try.Success []))
             ... Someone else interacted with the sink.
             (do !
               [latter (atom.read! sink)]
               (if (same? current latter)
                 ... Someone else closed the sink.
                 (in (exception.except ..channel_is_already_closed []))
                 ... Someone else fed the sink while I was closing it.
                 (recur [])))))))
     
     (def: (feed value)
       (loop [_ []]
         (do {! io.monad}
           [current (atom.read! sink)
            .let [[next resolve_next] (:sharing [a]
                                                (async.Resolver (Maybe [a (Channel a)]))
                                                current
                                                
                                                [(Async (Maybe [a (Channel a)]))
                                                 (async.Resolver (Maybe [a (Channel a)]))]
                                                (async.async []))]
            fed? (current (#.Some [value next]))]
           (if fed?
             ... I fed the sink.
             (do !
               [_ (atom.compare_and_swap! current resolve_next sink)]
               (in (#try.Success [])))
             ... Someone else interacted with the sink.
             (do !
               [latter (atom.read! sink)]
               (if (same? current latter)
                 ... Someone else closed the sink while I was feeding it.
                 (in (exception.except ..channel_is_already_closed []))
                 ... Someone else fed the sink.
                 (recur []))))))))))

(def: .public (channel _)
  (All [a] (-> Any [(Channel a) (Sink a)]))
  (let [[async resolve] (async.async [])]
    [async (..sink resolve)]))

(implementation: .public functor
  (Functor Channel)
  
  (def: (map f)
    (async\map
     (maybe\map
      (function (_ [head tail])
        [(f head) (map f tail)])))))

(implementation: .public apply
  (Apply Channel)
  
  (def: &functor ..functor)

  (def: (apply ff fa)
    (do async.monad
      [item_f ff
       item_a fa]
      (case [item_f item_a]
        [(#.Some [head_f tail_f]) (#.Some [head_a tail_a])]
        (in (#.Some [(head_f head_a) (apply tail_f tail_a)]))

        _
        (in #.None)))))

(def: empty
  Channel
  (async.resolved #.None))

(implementation: .public monad
  (Monad Channel)
  
  (def: &functor ..functor)

  (def: (in a)
    (async.resolved (#.Some [a ..empty])))

  (def: (join mma)
    (let [[output sink] (channel [])]
      (exec
        (: (Async Any)
           (loop [mma mma]
             (do {! async.monad}
               [?mma mma]
               (case ?mma
                 (#.Some [ma mma'])
                 (do !
                   [_ (loop [ma ma]
                        (do !
                          [?ma ma]
                          (case ?ma
                            (#.Some [a ma'])
                            (exec
                              (io.run! (\ sink feed a))
                              (recur ma'))
                            
                            #.None
                            (in []))))]
                   (recur mma'))
                 
                 #.None
                 (in (: Any (io.run! (\ sink close))))))))
        output))))

(type: .public (Subscriber a)
  (-> a (IO (Maybe Any))))

(def: .public (subscribe! subscriber channel)
  (All [a] (-> (Subscriber a) (Channel a) (IO Any)))
  (io (exec
        (: (Async Any)
           (loop [channel channel]
             (do async.monad
               [item channel]
               (case item
                 (#.Some [head tail])
                 (case (io.run! (subscriber head))
                   (#.Some _)
                   (recur tail)
                   
                   #.None
                   (in []))
                 
                 #.None
                 (in [])))))
        [])))

(def: .public (only pass? channel)
  (All [a] (-> (-> a Bit) (Channel a) (Channel a)))
  (do async.monad
    [item channel]
    (case item
      (#.Some [head tail])
      (let [tail' (only pass? tail)]
        (if (pass? head)
          (in (#.Some [head tail']))
          tail'))
      
      #.None
      (in #.None))))

(def: .public (of_async async)
  (All [a] (-> (Async a) (Channel a)))
  (async\map (function (_ value)
               (#.Some [value ..empty]))
             async))

(def: .public (aggregate f init channel)
  (All [a b]
    (-> (-> b a (Async a)) a (Channel b)
        (Async a)))
  (do {! async.monad}
    [item channel]
    (case item
      #.None
      (in init)
      
      (#.Some [head tail])
      (do !
        [init' (f head init)]
        (aggregate f init' tail)))))

(def: .public (aggregates f init channel)
  (All [a b]
    (-> (-> b a (Async a)) a (Channel b)
        (Channel a)))
  (do {! async.monad}
    [item channel]
    (case item
      #.None
      (in (#.Some [init (in #.None)]))
      
      (#.Some [head tail])
      (do !
        [init' (f head init)]
        (in (#.Some [init (aggregates f init' tail)]))))))

(def: .public (poll milli_seconds action)
  (All [a]
    (-> Nat (IO a) [(Channel a) (Sink a)]))
  (let [[output sink] (channel [])]
    (exec
      (io.run! (loop [_ []]
                 (do io.monad
                   [value action
                    _ (\ sink feed value)]
                   (async.upon! recur (async.delay milli_seconds)))))
      [output sink])))

(def: .public (periodic milli_seconds)
  (-> Nat [(Channel Any) (Sink Any)])
  (..poll milli_seconds (io [])))

(def: .public (iterations f init)
  (All [s o] (-> (-> s (Async (Maybe [s o]))) s (Channel o)))
  (do async.monad
    [?next (f init)]
    (case ?next
      (#.Some [state output])
      (in (#.Some [output (iterations f state)]))
      
      #.None
      (in #.None))))

(def: (distinct' equivalence previous channel)
  (All [a] (-> (Equivalence a) a (Channel a) (Channel a)))
  (do async.monad
    [item channel]
    (case item
      (#.Some [head tail])
      (if (\ equivalence = previous head)
        (distinct' equivalence previous tail)
        (in (#.Some [head (distinct' equivalence head tail)])))
      
      #.None
      (in #.None))))

(def: .public (distinct equivalence channel)
  (All [a] (-> (Equivalence a) (Channel a) (Channel a)))
  (do async.monad
    [item channel]
    (in (case item
          (#.Some [head tail])
          (#.Some [head (distinct' equivalence head tail)])
          
          #.None
          #.None))))

(def: .public (list channel)
  (All [a] (-> (Channel a) (Async (List a))))
  (do {! async.monad}
    [item channel]
    (case item
      (#.Some [head tail])
      (\ ! map (|>> (#.Item head))
         (list tail))

      #.None
      (in #.End))))

(def: .public (sequential milli_seconds values)
  (All [a] (-> Nat (List a) (Channel a)))
  (case values
    #.End
    ..empty

    (#.Item head tail)
    (async.resolved (#.Some [head (do async.monad
                                    [_ (async.delay milli_seconds)]
                                    (sequential milli_seconds tail))]))))
