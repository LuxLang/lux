(.module:
  [library
   [lux "*"
    [abstract
     [functor {"+" [Functor]}]
     [apply {"+" [Apply]}]
     ["[0]" monad {"+" [Monad do]}]]
    [control
     ["[0]" io {"+" [IO io]}]
     ["[0]" maybe]
     ["[0]" try]]
    [data
     ["[0]" product]
     [collection
      ["[0]" list]]]
    [type
     abstract]]]
  [//
   ["[0]" atom {"+" [Atom atom]}]
   ["[0]" async {"+" [Async Resolver]}]
   ["[0]" frp {"+" [Channel Sink]}]])

(type: (Observer a)
  (-> a (IO Any)))

(abstract: .public (Var a)
  (Atom [a (List (Sink a))])

  (def: .public (var value)
    (All (_ a) (-> a (Var a)))
    (:abstraction (atom.atom [value (list)])))

  (def: read!
    (All (_ a) (-> (Var a) a))
    (|>> :representation atom.read! io.run! product.left))

  (def: (un_follow! sink var)
    (All (_ a) (-> (Sink a) (Var a) (IO Any)))
    (do io.monad
      [_ (atom.update! (function (_ [value observers])
                         [value (list.only (|>> (same? sink) not) observers)])
                       (:representation var))]
      (in [])))

  (def: (write! new_value var)
    (All (_ a) (-> a (Var a) (IO Any)))
    (do [! io.monad]
      [.let [var' (:representation var)]
       (^@ old [old_value observers]) (atom.read! var')
       succeeded? (atom.compare_and_swap! old [new_value observers] var')]
      (if succeeded?
        (do !
          [_ (monad.each ! (function (_ sink)
                             (do !
                               [result (\ sink feed new_value)]
                               (case result
                                 {try.#Success _}
                                 (in [])
                                 
                                 {try.#Failure _}
                                 (un_follow! sink var))))
                         observers)]
          (in []))
        (write! new_value var))))

  (def: .public (follow! target)
    (All (_ a) (-> (Var a) (IO [(Channel a) (Sink a)])))
    (do io.monad
      [.let [[channel sink] (frp.channel [])]
       _ (atom.update! (function (_ [value observers])
                         [value {.#Item sink observers}])
                       (:representation target))]
      (in [channel sink])))
  )

(type: (Tx_Frame a)
  (Record
   [#var (Var a)
    #original a
    #current a]))

(type: Tx
  (List (Ex (_ a) (Tx_Frame a))))

(type: .public (STM a)
  (-> Tx [Tx a]))

(def: (var_value var tx)
  (All (_ a) (-> (Var a) Tx (Maybe a)))
  (|> tx
      (list.example (function (_ [_var _original _current])
                      (same? (:as (Var Any) var)
                             (:as (Var Any) _var))))
      (\ maybe.monad each (function (_ [_var _original _current])
                            _current))
      :expected))

(def: .public (read var)
  (All (_ a) (-> (Var a) (STM a)))
  (function (_ tx)
    (case (var_value var tx)
      {.#Some value}
      [tx value]

      {.#None}
      (let [value (..read! var)]
        [{.#Item [var value value] tx}
         value]))))

(def: (with_updated_var var value tx)
  (All (_ a) (-> (Var a) a Tx Tx))
  (case tx
    {.#End}
    {.#End}
    
    {.#Item [_var _original _current] tx'}
    (if (same? (:as (Var Any) var)
               (:as (Var Any) _var))
      {.#Item [#var (:as (Var Any) _var)
               #original (:as Any _original)
               #current (:as Any value)]
              tx'}
      {.#Item [#var _var
               #original _original
               #current _current]
              (with_updated_var var value tx')})))

(def: .public (write value var)
  (All (_ a) (-> a (Var a) (STM Any)))
  (function (_ tx)
    (case (var_value var tx)
      {.#Some _}
      [(with_updated_var var value tx)
       []]

      {.#None}
      [{.#Item [var (..read! var) value] tx}
       []])))

(implementation: .public functor
  (Functor STM)
  
  (def: (each f fa)
    (function (_ tx)
      (let [[tx' a] (fa tx)]
        [tx' (f a)]))))

(implementation: .public apply
  (Apply STM)
  
  (def: &functor ..functor)

  (def: (on fa ff)
    (function (_ tx)
      (let [[tx' f] (ff tx)
            [tx'' a] (fa tx')]
        [tx'' (f a)]))))

(implementation: .public monad
  (Monad STM)
  
  (def: &functor ..functor)

  (def: (in a)
    (function (_ tx)
      [tx a]))

  (def: (conjoint mma)
    (function (_ tx)
      (let [[tx' ma] (mma tx)]
        (ma tx')))))

(def: .public (update f var)
  (All (_ a) (-> (-> a a) (Var a) (STM [a a])))
  (do ..monad
    [a (..read var)
     .let [a' (f a)]
     _ (..write a' var)]
    (in [a a'])))

(def: (can_commit? tx)
  (-> Tx Bit)
  (list.every? (function (_ [_var _original _current])
                 (same? _original (..read! _var)))
               tx))

(def: (commit_var! [_var _original _current])
  (-> (Ex (_ a) (Tx_Frame a)) (IO Any))
  (if (same? _original _current)
    (io [])
    (..write! _current _var)))

(def: fresh_tx Tx (list))

(type: (Commit a)
  [(STM a)
   (Async a)
   (Resolver a)])

(def: pending_commits
  (Atom (Rec Commits
          [(Async [(Ex (_ a) (Commit a)) Commits])
           (Resolver [(Ex (_ a) (Commit a)) Commits])]))
  (atom (async.async [])))

(def: commit_processor_flag
  (Atom Bit)
  (atom #0))

(def: (issue_commit! commit)
  (All (_ a) (-> (Commit a) (IO Any)))
  (let [entry [commit (async.async [])]]
    (do [! io.monad]
      [|commits|&resolve (atom.read! pending_commits)]
      (loop [[|commits| resolve] |commits|&resolve]
        (do !
          [|commits| (async.value |commits|)]
          (case |commits|
            {.#None}
            (do io.monad
              [resolved? (resolve entry)]
              (if resolved?
                (atom.write! (product.right entry) pending_commits)
                (recur |commits|&resolve)))
            
            {.#Some [head tail]}
            (recur tail)))))))

(def: (process_commit! commit)
  (All (_ a) (-> (Commit a) (IO Any)))
  (let [[stm_proc output resolve] commit
        [finished_tx value] (stm_proc fresh_tx)]
    (if (can_commit? finished_tx)
      (do [! io.monad]
        [_ (monad.each ! ..commit_var! finished_tx)]
        (resolve value))
      (..issue_commit! commit))))

(def: start_commit_processor!
  (IO Any)
  (do [! io.monad]
    [flag (atom.read! commit_processor_flag)]
    (if flag
      (in [])
      (do !
        [was_first? (atom.compare_and_swap! flag #1 commit_processor_flag)]
        (if was_first?
          (do !
            [[async resolve] (atom.read! pending_commits)]
            (async.upon! (function (recur [head [tail _resolve]])
                           (do !
                             [_ (..process_commit! head)]
                             (async.upon! recur tail)))
                         async))
          (in [])))
      )))

(def: .public (commit! stm_proc)
  (All (_ a) (-> (STM a) (Async a)))
  (let [[output resolver] (async.async [])]
    (exec
      (io.run! (do io.monad
                 [_ ..start_commit_processor!]
                 (..issue_commit! [stm_proc output resolver])))
      output)))
