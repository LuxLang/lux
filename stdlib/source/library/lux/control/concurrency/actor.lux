(.module:
  [library
   [lux "*"
    ["[0]" debug]
    [abstract
     monad]
    [control
     [pipe {"+" [case>]}]
     ["[0]" function]
     ["[0]" try {"+" [Try]}]
     ["[0]" exception {"+" [exception:]}]
     ["[0]" io {"+" [IO io]}]
     ["<>" parser ("[1]\[0]" monad)
      ["<[0]>" code {"+" [Parser]}]]]
    [data
     ["[0]" bit]
     ["[0]" product]
     [text
      ["%" format {"+" [format]}]]
     [collection
      ["[0]" list ("[1]\[0]" monoid monad)]]]
    ["[0]" macro {"+" [with_identifiers]}
     ["[0]" code]
     [syntax {"+" [syntax:]}
      ["|[0]|" input]
      ["|[0]|" export]]]
    [math
     [number
      ["n" nat]]]
    ["[0]" meta {"+" [monad]}]
    [type {"+" [:sharing]}
     ["[0]" abstract {"+" [abstract: :representation :abstraction]}]]]]
  [//
   ["[0]" atom {"+" [Atom atom]}]
   ["[0]" async {"+" [Async Resolver]} ("[1]\[0]" monad)]
   ["[0]" frp {"+" [Channel]}]])

(exception: .public poisoned)
(exception: .public dead)

(with_expansions
  [<Mail> (as_is (-> s (Actor s) (Async (Try s))))
   <Obituary> (as_is [Text s (List <Mail>)])
   <Mailbox> (as_is (Rec Mailbox
                      [(Async [<Mail> Mailbox])
                       (Resolver [<Mail> Mailbox])]))]

  (def: (pending [read write])
    (All (_ a)
      (-> (Rec Mailbox
            [(Async [a Mailbox])
             (Resolver [a Mailbox])])
          (IO (List a))))
    (do [! io.monad]
      [current (async.value read)]
      (case current
        (#.Some [head tail])
        (\ ! each (|>> (#.Item head))
           (pending tail))
        
        #.None
        (in #.End))))
  
  (abstract: .public (Actor s)
    (Record
     [#obituary [(Async <Obituary>)
                 (Resolver <Obituary>)]
      #mailbox (Atom <Mailbox>)])

    [(type: .public (Mail s)
       <Mail>)

     (type: .public (Obituary s)
       <Obituary>)

     (type: .public (Behavior o s)
       (Record
        [#on_init (-> o s)
         #on_mail (-> (Mail s) s (Actor s) (Async (Try s)))]))

     (def: .public (spawn! behavior init)
       (All (_ o s) (-> (Behavior o s) o (IO (Actor s))))
       (io (let [[on_init on_mail] behavior
                 self (:sharing [o s]
                                (Behavior o s)
                                behavior
                                
                                (Actor s)
                                (:abstraction [#obituary (async.async [])
                                               #mailbox (atom (async.async []))]))
                 process (loop [state (on_init init)
                                [|mailbox| _] (io.run! (atom.read! (value@ #mailbox (:representation self))))]
                           (do [! async.monad]
                             [[head tail] |mailbox|
                              ?state' (on_mail head state self)]
                             (case ?state'
                               (#try.Failure error)
                               (let [[_ resolve] (value@ #obituary (:representation self))]
                                 (exec (io.run!
                                        (do io.monad
                                          [pending (..pending tail)]
                                          (resolve [error state (#.Item head pending)])))
                                   (in [])))

                               (#try.Success state')
                               (recur state' tail))))]
             self)))

     (def: .public (alive? actor)
       (All (_ s) (-> (Actor s) (IO Bit)))
       (let [[obituary _] (value@ #obituary (:representation actor))]
         (|> obituary
             async.value
             (\ io.functor each
                (|>> (case> #.None
                            bit.yes

                            _
                            bit.no))))))

     (def: .public (obituary' actor)
       (All (_ s) (-> (Actor s) (IO (Maybe (Obituary s)))))
       (let [[obituary _] (value@ #obituary (:representation actor))]
         (async.value obituary)))

     (def: .public obituary
       (All (_ s) (-> (Actor s) (Async (Obituary s))))
       (|>> :representation
            (value@ #obituary)
            product.left))

     (def: .public (mail! mail actor)
       (All (_ s) (-> (Mail s) (Actor s) (IO (Try Any))))
       (do [! io.monad]
         [alive? (..alive? actor)]
         (if alive?
           (let [entry [mail (async.async [])]]
             (do !
               [|mailbox|&resolve (atom.read! (value@ #mailbox (:representation actor)))]
               (loop [[|mailbox| resolve] |mailbox|&resolve]
                 (do !
                   [|mailbox| (async.value |mailbox|)]
                   (case |mailbox|
                     #.None
                     (do !
                       [resolved? (resolve entry)]
                       (if resolved?
                         (do !
                           [_ (atom.write! (product.right entry) (value@ #mailbox (:representation actor)))]
                           (in (#try.Success [])))
                         (recur |mailbox|&resolve)))
                     
                     (#.Some [_ |mailbox|'])
                     (recur |mailbox|'))))))
           (in (exception.except ..dead [])))))

     (type: .public (Message s o)
       (-> s (Actor s) (Async (Try [s o]))))

     (def: (mail message)
       (All (_ s o) (-> (Message s o) [(Async (Try o)) (Mail s)]))
       (let [[async resolve] (:sharing [s o]
                                       (Message s o)
                                       message
                                       
                                       [(Async (Try o))
                                        (Resolver (Try o))]
                                       (async.async []))]
         [async
          (function (_ state self)
            (do [! async.monad]
              [outcome (message state self)]
              (case outcome
                (#try.Success [state' return])
                (exec
                  (io.run! (resolve (#try.Success return)))
                  (async.resolved (#try.Success state')))
                
                (#try.Failure error)
                (exec
                  (io.run! (resolve (#try.Failure error)))
                  (async.resolved (#try.Failure error))))))]))

     (def: .public (tell! message actor)
       (All (_ s o) (-> (Message s o) (Actor s) (Async (Try o))))
       (let [[async mail] (..mail message)]
         (do async.monad
           [outcome (async.future (..mail! mail actor))]
           (case outcome
             (#try.Success)
             async
             
             (#try.Failure error)
             (in (#try.Failure error))))))]
    )
  )

(def: (default_on_mail mail state self)
  (All (_ s) (-> (Mail s) s (Actor s) (Async (Try s))))
  (mail state self))

(def: .public default
  (All (_ s) (Behavior s s))
  [#on_init function.identity
   #on_mail ..default_on_mail])

(def: .public (poison! actor)
  (All (_ s) (-> (Actor s) (IO (Try Any))))
  (..mail! (function (_ state self)
             (async.resolved (exception.except ..poisoned [])))
           actor))

(def: actor_decl^
  (Parser [Text (List Text)])
  (<>.either (<code>.form (<>.and <code>.local_identifier (<>.some <code>.local_identifier)))
             (<>.and <code>.local_identifier (\ <>.monad in (list)))))

(type: On_MailC
  [[Text Text Text] Code])

(type: BehaviorC
  [(Maybe On_MailC) (List Code)])

(def: argument
  (Parser Text)
  <code>.local_identifier)

(def: on_mail^
  (Parser (Maybe On_MailC))
  (<>.maybe (<code>.form (<>.and (<code>.form (<>.after (<code>.this! (' on_mail))
                                                        ($_ <>.and ..argument ..argument ..argument)))
                                 <code>.any))))

(def: behavior^
  (Parser BehaviorC)
  (<code>.tuple
   ($_ <>.and
       ..on_mail^
       (<>.some <code>.any))))

(def: (on_mail g!_ ?on_mail)
  (-> Code (Maybe On_MailC) Code)
  (case ?on_mail
    #.None
    (` (~! ..default_on_mail))

    (#.Some [[mailN stateN selfN] bodyC])
    (` (function ((~ g!_)
                  (~ (code.local_identifier mailN))
                  (~ (code.local_identifier stateN))
                  (~ (code.local_identifier selfN)))
         (~ bodyC)))))

(def: actorP
  (Parser [Code [Text (List Text)] Code BehaviorC])
  (|export|.parser
   ($_ <>.and
       ..actor_decl^
       <code>.any
       behavior^)))

(syntax: .public (actor: [[export_policy [name vars] state_type [?on_mail messages]] ..actorP])
  (with_identifiers [g!_]
    (do meta.monad
      [g!type (macro.identifier (format name "_abstract_type"))
       .let [g!actor (code.local_identifier name)
             g!vars (list\each code.local_identifier vars)]]
      (in (list (` ((~! abstract:) (~ export_policy) ((~ g!type) (~+ g!vars))
                    (~ state_type)

                    [(def: (~ export_policy) (~ g!actor)
                       (All ((~ g!_) (~+ g!vars))
                         (..Behavior (~ state_type) ((~ g!type) (~+ g!vars))))
                       [#..on_init (|>> ((~! abstract.:abstraction) (~ g!type)))
                        #..on_mail (~ (..on_mail g!_ ?on_mail))])

                     (~+ messages)])))))))

(syntax: .public (actor [[state_type init] (<code>.tuple (<>.and <code>.any <code>.any))
                         ?on_mail on_mail^])
  (with_identifiers [g!_]
    (in (list (` (: ((~! io.IO) (..Actor (~ state_type)))
                    (..spawn! (: (..Behavior (~ state_type) (~ state_type))
                                 [#..on_init (|>>)
                                  #..on_mail (~ (..on_mail g!_ ?on_mail))])
                              (: (~ state_type)
                                 (~ init)))))))))

(type: Signature
  (Record
   [#vars (List Text)
    #name Text
    #inputs (List |input|.Input)
    #state Text
    #self Text]))

(def: signature^
  (Parser Signature)
  (<code>.form ($_ <>.and
                   (<>.else (list) (<code>.tuple (<>.some <code>.local_identifier)))
                   <code>.local_identifier
                   |input|.parser
                   <code>.local_identifier
                   <code>.local_identifier)))

(def: reference^
  (Parser [Name (List Text)])
  (<>.either (<code>.form (<>.and <code>.identifier (<>.some <code>.local_identifier)))
             (<>.and <code>.identifier (\ <>.monad in (list)))))

(def: messageP
  (Parser [Code Signature Code Code])
  (|export|.parser
   ($_ <>.and
       ..signature^
       <code>.any
       <code>.any)))

(syntax: .public (message: [[export_policy signature output_type body] ..messageP])
  (with_identifiers [g!_ g!return]
    (do meta.monad
      [actor_scope abstract.current
       .let [g!type (code.local_identifier (value@ #abstract.name actor_scope))
             g!message (code.local_identifier (value@ #name signature))
             g!actor_vars (value@ #abstract.type_vars actor_scope)
             g!all_vars (|> signature (value@ #vars) (list\each code.local_identifier) (list\composite g!actor_vars))
             g!inputsC (|> signature (value@ #inputs) (list\each product.left))
             g!inputsT (|> signature (value@ #inputs) (list\each product.right))
             g!state (|> signature (value@ #state) code.local_identifier)
             g!self (|> signature (value@ #self) code.local_identifier)]]
      (in (list (` (def: (~ export_policy) ((~ g!message) (~+ g!inputsC))
                     (All ((~ g!_) (~+ g!all_vars))
                       (-> (~+ g!inputsT)
                           (..Message (~ (value@ #abstract.abstraction actor_scope))
                                      (~ output_type))))
                     (function ((~ g!_) (~ g!state) (~ g!self))
                       (let [(~ g!state) (:as (~ (value@ #abstract.representation actor_scope))
                                              (~ g!state))]
                         (|> (~ body)
                             (: ((~! async.Async) ((~! try.Try) [(~ (value@ #abstract.representation actor_scope))
                                                                 (~ output_type)])))
                             (:as ((~! async.Async) ((~! try.Try) [(~ (value@ #abstract.abstraction actor_scope))
                                                                   (~ output_type)]))))))))
                )))))

(type: .public Stop
  (IO Any))

(def: continue! true)
(def: stop! false)

(def: .public (observe! action channel actor)
  (All (_ e s) (-> (-> e Stop (Mail s)) (Channel e) (Actor s) (IO Any)))
  (let [signal (: (Atom Bit)
                  (atom.atom ..continue!))
        stop (: Stop
                (atom.write! ..stop! signal))]
    (frp.subscribe! (function (_ event)
                      (do [! io.monad]
                        [continue? (atom.read! signal)]
                        (if continue?
                          (|> actor
                              (..mail! (action event stop))
                              (\ ! each try.maybe))
                          (in #.None))))
                    channel)))
