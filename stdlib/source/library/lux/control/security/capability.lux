(.module:
  [library
   [lux #*
    [abstract
     [monad (#+ do)]]
    [control
     ["<>" parser
      ["<c>" code]]
     ["." io (#+ IO)]
     [concurrency
      ["." async (#+ Async)]]]
    [data
     [text
      ["%" format (#+ format)]]
     [collection
      ["." list ("#\." functor)]]]
    [type
     abstract]
    ["." meta]
    ["." macro
     ["." code]
     [syntax (#+ syntax:)
      ["|.|" export]
      ["|.|" declaration]
      ["|.|" annotations]]]]])

(abstract: .public (Capability brand input output)
  {#.doc (doc "Represents the capability to perform an operation."
              "This operation is assumed to have security implications.")}

  (-> input output)

  (def: forge
    (All [brand input output]
      (-> (-> input output)
          (Capability brand input output)))
    (|>> :abstraction))

  (def: .public (use capability input)
    {#.doc (doc "Applies a capability against its required input.")}
    (All [brand input output]
      (-> (Capability brand input output)
          input
          output))
    ((:representation capability) input))

  (syntax: .public (capability: {export |export|.parser}
                     {declaration |declaration|.parser}
                     {annotations (<>.maybe |annotations|.parser)}
                     {[forge input output] (<c>.form ($_ <>.and <c>.local_identifier <c>.any <c>.any))})
    {#.doc (doc "Defines a capability as a unique type, and a constructor for instances."

                (capability: (Can_Duplicate a)
                  (can_duplicate a [a a]))
                
                (let [capability (can_duplicate
                                  (function (_ value)
                                    [value value]))
                      [left right] (..use capability 123)]
                  (is? left right)))}
    (do {! meta.monad}
      [this_module meta.current_module_name
       .let [[name vars] declaration]
       g!brand (\ ! map (|>> %.code code.text)
                  (macro.gensym (format (%.name [this_module name]))))
       .let [capability (` (..Capability (.primitive (~ g!brand)) (~ input) (~ output)))]]
      (in (list (` (type: (~+ (|export|.format export))
                     (~ (|declaration|.format declaration))
                     (~ capability)))
                (` (def: (~ (code.local_identifier forge))
                     (All [(~+ (list\map code.local_identifier vars))]
                       (-> (-> (~ input) (~ output))
                           (~ capability)))
                     (~! ..forge)))
                ))))

  (def: .public (async capability)
    {#.doc (doc "Converts a synchronous I/O-based capability into an asynchronous capability.")}
    (All [brand input output]
      (-> (Capability brand input (IO output))
          (Capability brand input (Async output))))
    (..forge (|>> ((:representation capability)) async.future)))
  )
