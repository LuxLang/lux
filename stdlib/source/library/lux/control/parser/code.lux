(.module:
  [library
   [lux {"-" [nat int rev local not]}
    [abstract
     ["[0]" monad {"+" [do]}]]
    [control
     ["[0]" try {"+" [Try]}]]
    [data
     ["[0]" bit]
     ["[0]" text ("[1]\[0]" monoid)]
     ["[0]" name]
     [collection
      ["[0]" list ("[1]\[0]" functor)]]]
    [macro
     ["[0]" code ("[1]\[0]" equivalence)]]
    [math
     [number
      ["[0]" nat]
      ["[0]" int]
      ["[0]" rev]
      ["[0]" frac]]]]]
  ["[0]" //])

(def: (un_paired pairs)
  (All (_ a) (-> (List [a a]) (List a)))
  (case pairs
    #.End                   #.End
    {#.Item [[x y] pairs']} (list& x y (un_paired pairs'))))

(type: .public Parser
  (//.Parser (List Code)))

(def: remaining_inputs
  (-> (List Code) Text)
  (|>> (list\each code.format)
       (text.interposed " ")
       ($_ text\composite text.new_line "Remaining input: ")))

(def: .public any
  (Parser Code)
  (function (_ tokens)
    (case tokens
      #.End
      {#try.Failure "There are no tokens to parse!"}
      
      {#.Item [t tokens']}
      {#try.Success [tokens' t]})))

(def: .public next
  (Parser Code)
  (function (_ tokens)
    (case tokens
      #.End
      {#try.Failure "There are no tokens to parse!"}
      
      {#.Item next _}
      {#try.Success [tokens next]})))

(template [<query> <check> <type> <tag> <eq> <desc>]
  [(with_expansions [<failure> (as_is {#try.Failure ($_ text\composite "Cannot parse " <desc> (remaining_inputs tokens))})]
     (def: .public <query>
       (Parser <type>)
       (function (_ tokens)
         (case tokens
           {#.Item [[_ {<tag> x}] tokens']}
           {#try.Success [tokens' x]}

           _
           <failure>)))

     (def: .public (<check> expected)
       (-> <type> (Parser Any))
       (function (_ tokens)
         (case tokens
           {#.Item [[_ {<tag> actual}] tokens']}
           (if (\ <eq> = expected actual)
             {#try.Success [tokens' []]}
             <failure>)

           _
           <failure>))))]

  [bit        bit!        Bit  #.Bit        bit.equivalence  "bit"]
  [nat        nat!        Nat  #.Nat        nat.equivalence  "nat"]
  [int        int!        Int  #.Int        int.equivalence  "int"]
  [rev        rev!        Rev  #.Rev        rev.equivalence  "rev"]
  [frac       frac!       Frac #.Frac       frac.equivalence "frac"]
  [text       text!       Text #.Text       text.equivalence "text"]
  [identifier identifier! Name #.Identifier name.equivalence "identifier"]
  [tag        tag!        Name #.Tag        name.equivalence "tag"]
  )

(def: .public (this! code)
  (-> Code (Parser Any))
  (function (_ tokens)
    (case tokens
      {#.Item [token tokens']}
      (if (code\= code token)
        {#try.Success [tokens' []]}
        {#try.Failure ($_ text\composite "Expected a " (code.format code) " but instead got " (code.format token)
                          (remaining_inputs tokens))})

      _
      {#try.Failure "There are no tokens to parse!"})))

(template [<query> <check> <tag> <eq> <desc>]
  [(with_expansions [<failure> (as_is {#try.Failure ($_ text\composite "Cannot parse " <desc> (remaining_inputs tokens))})]
     (def: .public <query>
       (Parser Text)
       (function (_ tokens)
         (case tokens
           {#.Item [[_ {<tag> ["" x]}] tokens']}
           {#try.Success [tokens' x]}

           _
           <failure>)))

     (def: .public (<check> expected)
       (-> Text (Parser Any))
       (function (_ tokens)
         (case tokens
           {#.Item [[_ {<tag> ["" actual]}] tokens']}
           (if (\ <eq> = expected actual)
             {#try.Success [tokens' []]}
             <failure>)

           _
           <failure>))))]

  [local_identifier local_identifier! #.Identifier text.equivalence "local identifier"]
  [       local_tag        local_tag! #.Tag        text.equivalence "local tag"]
  )

(template [<name> <tag> <desc>]
  [(def: .public (<name> p)
     (All (_ a)
       (-> (Parser a) (Parser a)))
     (function (_ tokens)
       (case tokens
         {#.Item [[_ {<tag> members}] tokens']}
         (case (p members)
           {#try.Success [#.End x]} {#try.Success [tokens' x]}
           _                          {#try.Failure ($_ text\composite "Parser was expected to fully consume " <desc> (remaining_inputs tokens))})

         _
         {#try.Failure ($_ text\composite "Cannot parse " <desc> (remaining_inputs tokens))})))]

  [form #.Form "form"]
  [variant #.Variant "variant"]
  [tuple #.Tuple "tuple"]
  )

(def: .public end!
  (Parser Any)
  (function (_ tokens)
    (case tokens
      #.End {#try.Success [tokens []]}
      _     {#try.Failure ($_ text\composite "Expected list of tokens to be empty!" (remaining_inputs tokens))})))

(def: .public end?
  (Parser Bit)
  (function (_ tokens)
    {#try.Success [tokens (case tokens
                            #.End true
                            _     false)]}))

(def: .public (result parser inputs)
  (All (_ a) (-> (Parser a) (List Code) (Try a)))
  (case (parser inputs)
    {#try.Failure error}
    {#try.Failure error}

    {#try.Success [unconsumed value]}
    (case unconsumed
      #.End
      {#try.Success value}

      _
      {#try.Failure (|> unconsumed
                        (list\each code.format)
                        (text.interposed ", ")
                        (text\composite "Unconsumed inputs: "))})))

(def: .public (local inputs parser)
  (All (_ a) (-> (List Code) (Parser a) (Parser a)))
  (function (_ real)
    (do try.monad
      [value (..result parser inputs)]
      (in [real value]))))

(def: .public (not parser)
  (All (_ a) (-> (Parser a) (Parser Code)))
  (do //.monad
    [sample ..next
     result (//.or parser
                   ..any)]
    (case result
      {#.Left _} (//.failure (text\composite "Did NOT expect to parse code: " (code.format sample)))
      {#.Right output} (in output))))
