(.using
 [library
  [lux (.except nat int rev local not symbol local global)
   [abstract
    ["[0]" monad (.only do)]]
   [control
    ["[0]" try (.only Try)]]
   [data
    ["[0]" bit]
    ["[0]" text (.open: "[1]#[0]" monoid)]
    [collection
     ["[0]" list (.open: "[1]#[0]" functor)]]]
   [macro
    ["[0]" code (.open: "[1]#[0]" equivalence)]]
   [math
    [number
     ["[0]" nat]
     ["[0]" int]
     ["[0]" rev]
     ["[0]" frac]]]
   [meta
    ["[0]" symbol]]]]
 ["[0]" //])

(def: (un_paired pairs)
  (All (_ a) (-> (List [a a]) (List a)))
  (case pairs
    {.#End}                 {.#End}
    {.#Item [[x y] pairs']} (partial_list x y (un_paired pairs'))))

(type: .public Parser
  (//.Parser (List Code)))

(def: remaining_inputs
  (-> (List Code) Text)
  (|>> (list#each code.format)
       (text.interposed " ")
       (all text#composite text.new_line "Remaining input: ")))

(def: .public any
  (Parser Code)
  (function (_ tokens)
    (case tokens
      {.#End}
      {try.#Failure "There are no tokens to parse!"}
      
      {.#Item [t tokens']}
      {try.#Success [tokens' t]})))

(def: .public next
  (Parser Code)
  (function (_ tokens)
    (case tokens
      {.#End}
      {try.#Failure "There are no tokens to parse!"}
      
      {.#Item next _}
      {try.#Success [tokens next]})))

(with_template [<query> <check> <type> <tag> <eq> <desc>]
  [(with_expansions [<failure> (these {try.#Failure (all text#composite "Cannot parse " <desc> (remaining_inputs tokens))})]
     (def: .public <query>
       (Parser <type>)
       (function (_ tokens)
         (case tokens
           {.#Item [[_ {<tag> x}] tokens']}
           {try.#Success [tokens' x]}

           _
           <failure>)))

     (def: .public (<check> expected)
       (-> <type> (Parser Any))
       (function (_ tokens)
         (case tokens
           {.#Item [[_ {<tag> actual}] tokens']}
           (if (at <eq> = expected actual)
             {try.#Success [tokens' []]}
             <failure>)

           _
           <failure>))))]

  [bit    this_bit    Bit    .#Bit    bit.equivalence    "bit"]
  [nat    this_nat    Nat    .#Nat    nat.equivalence    "nat"]
  [int    this_int    Int    .#Int    int.equivalence    "int"]
  [rev    this_rev    Rev    .#Rev    rev.equivalence    "rev"]
  [frac   this_frac   Frac   .#Frac   frac.equivalence   "frac"]
  [text   this_text   Text   .#Text   text.equivalence   "text"]
  [symbol this_symbol Symbol .#Symbol symbol.equivalence "symbol"]
  )

(def: .public (this code)
  (-> Code (Parser Any))
  (function (_ tokens)
    (case tokens
      {.#Item [token tokens']}
      (if (code#= code token)
        {try.#Success [tokens' []]}
        {try.#Failure (all text#composite "Expected a " (code.format code) " but instead got " (code.format token)
                           (remaining_inputs tokens))})

      _
      {try.#Failure "There are no tokens to parse!"})))

(with_expansions [<failure> (these {try.#Failure (all text#composite "Cannot parse local symbol" (remaining_inputs tokens))})]
  (def: .public local
    (Parser Text)
    (function (_ tokens)
      (case tokens
        {.#Item [[_ {.#Symbol ["" x]}] tokens']}
        {try.#Success [tokens' x]}

        _
        <failure>)))

  (def: .public (this_local expected)
    (-> Text (Parser Any))
    (function (_ tokens)
      (case tokens
        {.#Item [[_ {.#Symbol ["" actual]}] tokens']}
        (if (at text.equivalence = expected actual)
          {try.#Success [tokens' []]}
          <failure>)

        _
        <failure>))))

(with_expansions [<failure> (these {try.#Failure (all text#composite "Cannot parse local symbol" (remaining_inputs tokens))})]
  (def: .public global
    (Parser Symbol)
    (function (_ tokens)
      (case tokens
        {.#Item [[_ {.#Symbol ["" short]}] tokens']}
        <failure>
        
        {.#Item [[_ {.#Symbol it}] tokens']}
        {try.#Success [tokens' it]}

        _
        <failure>)))

  (def: .public (this_global expected)
    (-> Symbol (Parser Any))
    (function (_ tokens)
      (case tokens
        {.#Item [[_ {.#Symbol ["" actual]}] tokens']}
        <failure>
        
        {.#Item [[_ {.#Symbol it}] tokens']}
        (if (at symbol.equivalence = expected it)
          {try.#Success [tokens' []]}
          <failure>)

        _
        <failure>))))

(with_template [<name> <tag> <desc>]
  [(def: .public (<name> p)
     (All (_ a)
       (-> (Parser a) (Parser a)))
     (function (_ tokens)
       (case tokens
         {.#Item [[_ {<tag> members}] tokens']}
         (case (p members)
           {try.#Success [{.#End} x]} {try.#Success [tokens' x]}
           _                          {try.#Failure (all text#composite "Parser was expected to fully consume " <desc> (remaining_inputs tokens))})

         _
         {try.#Failure (all text#composite "Cannot parse " <desc> (remaining_inputs tokens))})))]

  [form .#Form "form"]
  [variant .#Variant "variant"]
  [tuple .#Tuple "tuple"]
  )

(def: .public end
  (Parser Any)
  (function (_ tokens)
    (case tokens
      {.#End} {try.#Success [tokens []]}
      _       {try.#Failure (all text#composite "Expected list of tokens to be empty!" (remaining_inputs tokens))})))

(def: .public end?
  (Parser Bit)
  (function (_ tokens)
    {try.#Success [tokens (case tokens
                            {.#End} true
                            _       false)]}))

(def: .public (result parser inputs)
  (All (_ a) (-> (Parser a) (List Code) (Try a)))
  (case (parser inputs)
    {try.#Failure error}
    {try.#Failure error}

    {try.#Success [unconsumed value]}
    (case unconsumed
      {.#End}
      {try.#Success value}

      _
      {try.#Failure (|> unconsumed
                        (list#each code.format)
                        (text.interposed ", ")
                        (text#composite "Unconsumed inputs: "))})))

(def: .public (locally inputs parser)
  (All (_ a) (-> (List Code) (Parser a) (Parser a)))
  (function (_ real)
    (do try.monad
      [value (..result parser inputs)]
      (in [real value]))))

(def: .public (not parser)
  (All (_ a) (-> (Parser a) (Parser Code)))
  (do //.monad
    [sample ..next
     result (//.or parser
                   ..any)]
    (case result
      {.#Left _} (//.failure (text#composite "Did NOT expect to parse code: " (code.format sample)))
      {.#Right output} (in output))))
