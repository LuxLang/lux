(.module:
  [library
   [lux (#- Variant Tuple function loop i64)
    [abstract
     [monad (#+ do)]]
    [control
     ["." try (#+ Try)]
     ["." exception (#+ exception:)]]
    [data
     ["." bit]
     ["." name]
     ["." text
      ["%" format (#+ format)]]]
    [macro
     ["." template]]
    [math
     [number
      ["n" nat]
      ["." i64]
      ["." frac]]]
    [tool
     [compiler
      [reference (#+)
       [variable (#+ Register)]]
      [arity (#+ Arity)]
      [language
       [lux
        [analysis (#+ Variant Tuple Environment)]
        ["/" synthesis (#+ Synthesis Abstraction)]]]]]]]
  ["." //])

(exception: #export (cannot_parse {input (List Synthesis)})
  (exception.report
   ["Input" (exception.enumerate /.%synthesis input)]))

(exception: #export (unconsumed_input {input (List Synthesis)})
  (exception.report
   ["Input" (exception.enumerate /.%synthesis input)]))

(exception: #export (expected_empty_input {input (List Synthesis)})
  (exception.report
   ["Input" (exception.enumerate /.%synthesis input)]))

(exception: #export (wrong_arity {expected Arity} {actual Arity})
  (exception.report
   ["Expected" (%.nat expected)]
   ["Actual" (%.nat actual)]))

(exception: #export empty_input)

(type: #export Parser
  {#.doc (doc "A parser for the Lux compiler's synthesis nodes using during optimization.")}
  (//.Parser (List Synthesis)))

(def: #export (run parser input)
  {#.doc (doc "Executes the parser against the inputs."
              "Ensures all inputs are consumed by the parser.")}
  (All [a] (-> (Parser a) (List Synthesis) (Try a)))
  (case (parser input)
    (#try.Failure error)
    (#try.Failure error)

    (#try.Success [#.End value])
    (#try.Success value)
    
    (#try.Success [unconsumed _])
    (exception.except ..unconsumed_input unconsumed)))

(def: #export any
  {#.doc (doc "Yields a synthesis node without subjecting it to any analysis.")}
  (Parser Synthesis)
  (.function (_ input)
    (case input
      #.End
      (exception.except ..empty_input [])
      
      (#.Item [head tail])
      (#try.Success [tail head]))))

(def: #export end!
  {#.doc "Ensures there are no more inputs."}
  (Parser Any)
  (.function (_ tokens)
    (case tokens
      #.End (#try.Success [tokens []])
      _     (exception.except ..expected_empty_input [tokens]))))

(def: #export end?
  {#.doc "Checks whether there are no more inputs."}
  (Parser Bit)
  (.function (_ tokens)
    (#try.Success [tokens (case tokens
                            #.End true
                            _     false)])))

(template [<query> <assertion> <tag> <type> <eq>]
  [(`` (def: #export <query>
         {#.doc (doc (~~ (template.text ["Queries for a " <query> " synthesis node."])))}
         (Parser <type>)
         (.function (_ input)
           (case input
             (^ (list& (<tag> x) input'))
             (#try.Success [input' x])

             _
             (exception.except ..cannot_parse input)))))

   (`` (def: #export (<assertion> expected)
         {#.doc (doc (~~ (template.text ["Checks for a specific " <query> " synthesis node."])))}
         (-> <type> (Parser Any))
         (.function (_ input)
           (case input
             (^ (list& (<tag> actual) input'))
             (if (\ <eq> = expected actual)
               (#try.Success [input' []])
               (exception.except ..cannot_parse input))

             _
             (exception.except ..cannot_parse input)))))]

  [bit bit! /.bit Bit bit.equivalence]
  [i64 i64! /.i64 (I64 Any) i64.equivalence]
  [f64 f64! /.f64 Frac frac.equivalence]
  [text text! /.text Text text.equivalence]
  [local local! /.variable/local Nat n.equivalence]
  [foreign foreign! /.variable/foreign Nat n.equivalence]
  [constant constant! /.constant Name name.equivalence]
  )

(def: #export (tuple parser)
  {#.doc (doc "Parses the contents of a tuple.")}
  (All [a] (-> (Parser a) (Parser a)))
  (.function (_ input)
    (case input
      (^ (list& (/.tuple head) tail))
      (do try.monad
        [output (..run parser head)]
        (#try.Success [tail output]))

      _
      (exception.except ..cannot_parse input))))

(def: #export (function expected parser)
  {#.doc (doc "Parses the body of a function with the 'expected' arity.")}
  (All [a] (-> Arity (Parser a) (Parser [(Environment Synthesis) a])))
  (.function (_ input)
    (case input
      (^ (list& (/.function/abstraction [environment actual body]) tail))
      (if (n.= expected actual)
        (do try.monad
          [output (..run parser (list body))]
          (#try.Success [tail [environment output]]))
        (exception.except ..wrong_arity [expected actual]))

      _
      (exception.except ..cannot_parse input))))

(def: #export (loop init_parsers iteration_parser)
  {#.doc (doc "Parses the initial values and the body of a loop.")}
  (All [a b] (-> (Parser a) (Parser b) (Parser [Register a b])))
  (.function (_ input)
    (case input
      (^ (list& (/.loop/scope [start inits iteration]) tail))
      (do try.monad
        [inits (..run init_parsers inits)
         iteration (..run iteration_parser (list iteration))]
        (#try.Success [tail [start inits iteration]]))

      _
      (exception.except ..cannot_parse input))))
