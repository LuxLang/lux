(.module:
  [library
   [lux #*
    [abstract
     [monad (#+ do)]]
    [control
     ["." try (#+ Try)]]
    [data
     ["." text ("#\." equivalence)
      ["%" format (#+ format)]]]]]
  ["." //])

(type: .public (Parser a)
  {#.doc "A command-line interface parser."}
  (//.Parser (List Text) a))

(def: .public (result parser inputs)
  {#.doc (example "Executes the parser and verifies that all inputs are processed.")}
  (All [a] (-> (Parser a) (List Text) (Try a)))
  (case (//.result parser inputs)
    (#try.Success [remaining output])
    (case remaining 
      #.End
      (#try.Success output)

      _
      (#try.Failure (format "Remaining CLI inputs: " (text.join_with " " remaining))))

    (#try.Failure try)
    (#try.Failure try)))

(def: .public any
  {#.doc "Just returns the next input without applying any logic."}
  (Parser Text)
  (function (_ inputs)
    (case inputs
      (#.Item arg inputs')
      (#try.Success [inputs' arg])
      
      _
      (#try.Failure "Cannot parse empty arguments."))))

(def: .public (parse parser)
  {#.doc "Parses the next input with a parsing function."}
  (All [a] (-> (-> Text (Try a)) (Parser a)))
  (function (_ inputs)
    (do try.monad
      [[remaining raw] (any inputs)
       output (parser raw)]
      (in [remaining output]))))

(def: .public (this reference)
  {#.doc "Checks that a token is in the inputs."}
  (-> Text (Parser Any))
  (function (_ inputs)
    (do try.monad
      [[remaining raw] (any inputs)]
      (if (text\= reference raw)
        (in [remaining []])
        (#try.Failure (format "Missing token: '" reference "'"))))))

(def: .public (somewhere cli)
  {#.doc "Given a parser, tries to parse it somewhere in the inputs (i.e. not necessarily parsing the immediate inputs)."}
  (All [a] (-> (Parser a) (Parser a)))
  (function (_ inputs)
    (loop [immediate inputs]
      (case (//.result cli immediate)
        (#try.Success [remaining output])
        (#try.Success [remaining output])

        (#try.Failure try)
        (case immediate
          #.End
          (#try.Failure try)
          
          (#.Item to_omit immediate')
          (do try.monad
            [[remaining output] (recur immediate')]
            (in [(#.Item to_omit remaining)
                 output])))))))

(def: .public end
  {#.doc "Ensures there are no more inputs."}
  (Parser Any)
  (function (_ inputs)
    (case inputs
      #.End (#try.Success [inputs []])
      _     (#try.Failure (format "Unknown parameters: " (text.join_with " " inputs))))))

(def: .public (named name value)
  {#.doc (example "Parses a named parameter and yields its value.")}
  (All [a] (-> Text (Parser a) (Parser a)))
  (|> value
      (//.after (..this name))
      ..somewhere))

(def: .public (parameter [short long] value)
  {#.doc (example "Parses a parameter that can have either a short or a long name.")}
  (All [a] (-> [Text Text] (Parser a) (Parser a)))
  (|> value
      (//.after (//.either (..this short) (..this long)))
      ..somewhere))
