... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except Pattern And
                nat int rev
                or and
                is has
                left right
                false true)
   [abstract
    [equivalence (.only Equivalence)]]
   [control
    [pure (.only Pure)]
    ["[0]" function (.only)
     [predicate (.only Predicate)]]]
   [data
    ["[0]" bit]
    ["[0]" text]
    [collection
     [list
      ["[0]" property]]]]
   [math
    [number
     ["[0]" nat]
     ["[0]" int]
     ["[0]" rev]
     ["[0]" frac]]]
   [meta
    ["[0]" type]]]]
 [//
  ["[0]" input]
  ["[0]" output]
  ["[0]" match]
  ["[0]" body (.only Body)]])

(every .public (Match input outer inner value)
  (-> input
      (Body outer inner value)))

(every .public (Pattern composition input outer inner value)
  (Record
   [#composition composition
    #match (Match input outer inner value)]))

(the .public (or left right)
  (All (_ number input outer inner value)
    (type.let [choice (Pattern number input outer inner value)]
      (-> choice choice
          choice)))
  (let [[number left] left
        [_ right] right]
    [number
     (function (_ input)
       (body.or (left input)
                (right input)))]))

(with_template [,tag ,side]
  [(the .public (,side it)
     (All (_ number
             outer inner
             value
             left right)
       (-> (Pattern number ,side outer inner value)
           (Pattern number (Or left right) outer inner value)))
     (let [[number it] it]
       [number
        (function (_ value)
          (when value
            {0 ,tag value}
            (it value)

            _
            body.failure))]))]

  [#0 left]
  [#1 right]
  )

(the And
  (template (_ ,left ,right ,pair)
    [(All (_ number_0 number_1 number_2
             arity_0 arity_1 arity_2
             value)
       (-> (Pattern (-> number_0 number_1) ,left arity_1 arity_2 value)
           (Pattern (-> number_1 number_2) ,right arity_0 arity_1 value)
           (Pattern (-> number_0 number_2) ,pair arity_0 arity_2 value)))]))

(the .public (and left right)
  (All (_ input)
    (And input input
         input))
  (let [[numberL left] left
        [numberR right] right]
    [(|>> numberL numberR)
     (function (_ input)
       (body.and (left input)
                 (right input)))]))

(the .public (pair left right)
  (All (_ left right)
    (And left right
         (.And left right)))
  (let [[numberL leftM] left
        [numberR rightM] right]
    [(|>> numberL numberR)
     (function (_ [leftV rightV])
       (body.and (leftM leftV)
                 (rightM rightV)))]))

(the .public (item pattern)
  (All (_ of number outer inner value)
    (-> (Pattern number of outer inner value)
        (Pattern number (List of) outer inner value)))
  (let [[number match] pattern]
    [number
     (function (again input)
       (when input
         {.#End}
         body.failure

         {.#Item head tail}
         (body.or (match head)
                  (function (_ next exit stack)
                    ((again tail) next exit stack)))))]))

(every .public (Zero of)
  (All (_ value arity)
    (Pattern match.Zero of arity (input.One arity) value)))

(the .public none
  Zero
  [match.zero
   (function.constant body.failure)])

(alias [never false]
       ..none)

(the .public any
  Zero
  [match.zero
   (function.constant body.success)])

(alias [else true]
       ..any)

(the .public (is predicate)
  (All (_ of)
    (-> (Predicate of)
        (Zero of)))
  [match.zero
   (function (_ input)
     (if (predicate input)
       body.success
       body.failure))])

(the .public (constant = expected)
  (All (_ of)
    (-> (Equivalence of) of
        (Zero of)))
  (..is (= expected)))

(with_template [,type ,name ,equivalence]
  [(the .public ,name
     (-> ,type
         (Zero ,type))
     (..constant ,equivalence))]

  [Bit bit bit.equivalence]
  [Nat nat nat.equivalence]
  [Int int int.equivalence]
  [Rev rev rev.equivalence]
  [Frac frac frac.equivalence]
  [Text text text.equivalence]
  )

(every .public (Succ input of)
  (All (_ value arity)
    (Pattern match.Succ (input of) arity (input.Succ of arity) value)))

(the .public variable
  (Succ Pure)
  [match.succ
   body.succ])

(the .public (has key)
  (-> Text
      (Succ property.List))
  (..item (..pair (..text key)
                  ..variable)))

(the .public (first predicate)
  (All (_ of)
    (-> (Predicate of)
        (Succ List of)))
  (..item (..and (..is predicate)
                 ..variable)))
