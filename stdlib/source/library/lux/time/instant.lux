(.module:
  [library
   [lux #*
    ["@" target]
    [abstract
     [equivalence (#+ Equivalence)]
     [order (#+ Order)]
     [enum (#+ Enum)]
     [codec (#+ Codec)]
     [monad (#+ Monad do)]]
    [control
     [io (#+ IO io)]
     ["." try]
     ["." exception (#+ exception:)]
     ["<>" parser
      ["<.>" text (#+ Parser)]]]
    [data
     ["." maybe]
     ["." text ("#\." monoid)]
     [collection
      ["." row]]]
    [math
     [number
      ["i" int]
      ["f" frac]]]
    [type
     abstract]]]
  ["." // (#+ Time)
   ["." duration (#+ Duration)]
   ["." year (#+ Year)]
   ["." month (#+ Month)]
   ["." day (#+ Day)]
   ["." date (#+ Date)]])

(abstract: .public Instant
  {#.doc "Instant is defined as milli-seconds since the epoch."}

  Int

  (def: .public of_millis
    (-> Int Instant)
    (|>> :abstraction))

  (def: .public millis
    (-> Instant Int)
    (|>> :representation))

  (def: .public (span from to)
    (-> Instant Instant Duration)
    (duration.of_millis (i.- (:representation from) (:representation to))))

  (def: .public (after duration instant)
    (-> Duration Instant Instant)
    (:abstraction (i.+ (duration.millis duration) (:representation instant))))

  (def: .public (relative instant)
    (-> Instant Duration)
    (|> instant :representation duration.of_millis))

  (def: .public (absolute offset)
    (-> Duration Instant)
    (|> offset duration.millis :abstraction))

  (implementation: .public equivalence
    (Equivalence Instant)
    
    (def: (= param subject)
      (\ i.equivalence = (:representation param) (:representation subject))))

  (implementation: .public order
    (Order Instant)
    
    (def: &equivalence ..equivalence)
    (def: (< param subject)
      (\ i.order < (:representation param) (:representation subject))))

  (`` (implementation: .public enum
        (Enum Instant)
        
        (def: &order ..order)
        (~~ (template [<name>]
              [(def: <name>
                 (|>> :representation (\ i.enum <name>) :abstraction))]

              [succ] [pred]
              ))))
  )

(def: .public epoch
  {#.doc "The instant corresponding to 1970-01-01T00:00:00Z."}
  Instant
  (..of_millis +0))

(def: millis_per_day
  (duration.ticks duration.milli_second duration.day))

(def: (date_time instant)
  (-> Instant [Date Duration])
  (let [offset (..millis instant)
        bce? (i.< +0 offset)
        [days day_time] (if bce?
                          (let [[days millis] (i./% ..millis_per_day offset)]
                            (case millis
                              +0 [days millis]
                              _ [(dec days) (i.+ ..millis_per_day millis)]))
                          (i./% ..millis_per_day offset))]
    [(date.of_days days)
     (duration.of_millis day_time)]))

(template [<value> <definition>]
  [(def: <definition> Text <value>)]

  ["T" date_suffix]
  ["Z" time_suffix]
  )

(def: (clock_time duration)
  (-> Duration Time)
  (|> (if (\ duration.order < duration.empty duration)
        (duration.merged duration.day duration)
        duration)
      duration.millis
      .nat
      //.of_millis
      try.assumed))

(def: (format instant)
  (-> Instant Text)
  (let [[date time] (..date_time instant)
        time (..clock_time time)]
    ($_ text\compose
        (\ date.codec encode date) ..date_suffix
        (\ //.codec encode time) ..time_suffix)))

(def: parser
  (Parser Instant)
  (do {! <>.monad}
    [days (\ ! map date.days date.parser)
     _ (<text>.this ..date_suffix)
     time (\ ! map //.millis //.parser)
     _ (<text>.this ..time_suffix)]
    (in (|> (if (i.< +0 days)
              (|> duration.day
                  (duration.up (.nat (i.* -1 days)))
                  duration.inverse)
              (duration.up (.nat days) duration.day))
            (duration.merged (duration.up time duration.milli_second))
            ..absolute))))

(implementation: .public codec
  {#.doc (doc "Based on ISO 8601."
              "For example: 2017-01-15T21:14:51.827Z")}
  (Codec Text Instant)
  
  (def: encode ..format)
  (def: decode (<text>.run ..parser)))

(def: .public now
  {#.doc (doc "Yields the current instant, as measured from the operating-system's clock.")}
  (IO Instant)
  (io (..of_millis (for {@.old ("jvm invokestatic:java.lang.System:currentTimeMillis:")
                         @.jvm (|> ("jvm member invoke static" [] "java.lang.System" "currentTimeMillis" [])
                                   ("jvm object cast")
                                   (: (primitive "java.lang.Long"))
                                   (:as Int))
                         @.js (let [date ("js object new" ("js constant" "Date") [])]
                                (|> ("js object do" "getTime" date [])
                                    (:as Frac)
                                    "lux f64 i64"))
                         @.python (let [time ("python import" "time")]
                                    (|> ("python object do" "time" time)
                                        (:as Frac)
                                        (f.* +1,000.0)
                                        "lux f64 i64"))
                         @.lua (|> ("lua constant" "os.time")
                                   "lua apply"
                                   (:as Int)
                                   (i.* +1,000))
                         @.ruby (let [% ("ruby constant" "Time")
                                      % ("ruby object do" "now" %)]
                                  (|> ("ruby object do" "to_f" %)
                                      (:as Frac)
                                      (f.* +1,000.0)
                                      "lux f64 i64"))
                         @.php (|> ("php constant" "time")
                                   "php apply"
                                   (:as Int)
                                   (i.* +1,000))
                         @.scheme (|> ("scheme constant" "current-second")
                                      (:as Int)
                                      (i.* +1,000)
                                      ("scheme apply" ("scheme constant" "exact"))
                                      ("scheme apply" ("scheme constant" "truncate")))
                         @.common_lisp (|> ("common_lisp constant" "get-universal-time")
                                           "common_lisp apply"
                                           (:as Int)
                                           (i.* +1,000))
                         }))))

(template [<field> <type> <post_processing>]
  [(def: .public (<field> instant)
     (-> Instant <type>)
     (let [[date time] (..date_time instant)]
       (|> <field> <post_processing>)))]

  [date Date (|>)]
  [time Time ..clock_time]
  )

(def: .public (day_of_week instant)
  (-> Instant Day)
  (let [offset (..relative instant)
        days (duration.ticks duration.day offset)
        day_time (duration.framed duration.day offset)
        days (if (and (duration.negative? offset)
                      (not (duration.neutral? day_time)))
               (dec days)
               days)
        ... 1970/01/01 was a Thursday
        y1970m0d0 +4]
    (case (|> y1970m0d0
              (i.+ days) (i.% +7)
              ... This is done to turn negative days into positive days.
              (i.+ +7) (i.% +7))
      +0 #day.Sunday
      +1 #day.Monday
      +2 #day.Tuesday
      +3 #day.Wednesday
      +4 #day.Thursday
      +5 #day.Friday
      +6 #day.Saturday
      _ (undefined))))

(def: .public (of_date_time date time)
  (-> Date Time Instant)
  (|> (date.days date)
      (i.* (duration.millis duration.day))
      (i.+ (.int (//.millis time)))
      ..of_millis))
