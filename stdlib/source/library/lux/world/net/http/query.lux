(.using
 [library
  [lux (.except)
   [control
    pipe
    [monad (.only do)]
    ["[0]" try (.only Try)]
    ["p" parser
     ["l" text (.only Parser)]]]
   [data
    [number
     ["[0]" nat]]
    ["[0]" text
     ["%" \\format (.only format)]]
    [format
     ["[0]" context (.only Context)]]
    [collection
     ["[0]" dictionary]]]]])

(def: component
  (Parser Text)
  (p.rec
   (function (_ component)
     (do [! p.monad]
       [head (l.some (l.none_of "+%&;"))]
       (all p.either
            (p.after (p.either l.end
                               (l.this "&"))
                     (in head))
            (do !
              [_ (l.this "+")
               tail component]
              (in (format head " " tail)))
            (do !
              [_ (l.this "%")
               code (|> (l.exactly 2 l.hexadecimal)
                        (p.codec nat.hex)
                        (at ! each text.from_code))
               tail component]
              (in (format head code tail))))))))

(def: (form context)
  (-> Context (Parser Context))
  (all p.either
       (do p.monad
         [_ l.end]
         (in context))
       (do [! p.monad]
         [key (l.some (l.none_of "=&;"))
          key (l.local key ..component)]
         (p.either (do !
                     [_ (l.this "=")
                      value ..component]
                     (form (dictionary.has key value context)))
                   (do !
                     [_ (all p.or
                             (l.one_of "&;")
                             l.end)]
                     (form (dictionary.has key "" context)))))
       ... if invalid form data, just stop parsing...
       (at p.monad in context)))

(def: .public (parameters raw)
  (-> Text (Try Context))
  (l.result raw (..form context.empty)))
