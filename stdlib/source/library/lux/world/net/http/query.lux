(.module:
  [library
   [lux #*
    [control
     pipe
     [monad (#+ do)]
     ["." try (#+ Try)]
     ["p" parser
      ["l" text (#+ Parser)]]]
    [data
     [number
      ["." nat]]
     ["." text
      ["%" format (#+ format)]]
     [format
      ["." context (#+ Context)]]
     [collection
      ["." dictionary]]]]])

(def: component
  (Parser Text)
  (p.rec
   (function (_ component)
     (do {! p.monad}
       [head (l.some (l.none_of "+%&;"))]
       ($_ p.either
           (p.after (p.either l.end
                              (l.this "&"))
                    (in head))
           (do !
             [_ (l.this "+")
              tail component]
             (in (format head " " tail)))
           (do !
             [_ (l.this "%")
              code (|> (l.exactly 2 l.hexadecimal)
                       (p.codec nat.hex)
                       (\ ! map text.from_code))
              tail component]
             (in (format head code tail))))))))

(def: (form context)
  (-> Context (Parser Context))
  ($_ p.either
      (do p.monad
        [_ l.end]
        (in context))
      (do {! p.monad}
        [key (l.some (l.none_of "=&;"))
         key (l.local key ..component)]
        (p.either (do !
                    [_ (l.this "=")
                     value ..component]
                    (form (dictionary.put key value context)))
                  (do !
                    [_ ($_ p.or
                           (l.one_of "&;")
                           l.end)]
                    (form (dictionary.put key "" context)))))
      ... if invalid form data, just stop parsing...
      (\ p.monad in context)))

(def: .public (parameters raw)
  (-> Text (Try Context))
  (l.result raw (..form context.empty)))
