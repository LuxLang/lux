... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except Error
                open tuple name)
   [abstract
    ["[0]" monad (.only Monad)]]
   [concurrency
    ["[0]" future (.only Future)]
    ["[0]" stm (.only Var STM)]]
   [control
    ["[0]" pipe]
    ["[0]" io (.only IO) (.use "[1]:[0]" functor)]]
   [error
    ["[0]" try (.only Try) (.use "[1]:[0]" functor)]
    ["[0]" exception (.only Exception)]]
   ["[0]" function]
   [data
    ["[0]" maybe (.use "[1]:[0]" functor)]
    ["[0]" product]
    ["[0]" binary (.only Binary)]
    ["[0]" text (.only)
     ["%" \\injection]]
    [collection
     ["[0]" list (.use "[1]:[0]" functor)]
     ["[0]" dictionary (.only Dictionary)]]]
   [logic
    ["[0]" bit]]
   ["[0]" ffi]
   ["[0]" target]
   [math
    [number
     [/64
      ["i" integer]
      ["d" decimal]]]]
   [macro
    ["[0]" template]
    ["[0]" expansion]]
   [time
    ["[0]" instant (.only Instant)]
    ["[0]" duration]]
   [aspect
    ["[0]" view]]]])

(.`` (.`` (.using
           [library
            [lux
             [ffi
              (.,, (target.if target.js
                              (.,, (.these ["[0]" node_js]))

                              ... else
                              (.,, (.these))))]]])))

(every .public Path
  Text)

(`` (every .public (System !)
      (Interface
       ... https://en.wikipedia.org/wiki/Delimiter
       (is Text
           delimiter)

       (,, (template.with [<name> <output>]
             [(is (-> Path (! <output>))
                  <name>)]

             [[file? Bit]
              [directory? Bit]]))

       (,, (template.with [<name> <output>]
             [(is (-> Path (! (Try <output>)))
                  <name>)]

             [[make_directory  Any]
              [directory_files (List Path)]
              [sub_directories (List Path)]
              
              [file_size     Natural]
              [last_modified Instant]
              [can_execute?  Bit]
              [read          Binary]
              [delete        Any]]))

       (,, (template.with [<name> <input>]
             [(is (-> Path <input> (! (Try Any)))
                  <name>)]

             [[modify Instant]
              [write  Binary]
              [append Binary]
              [move   Path]])))
      ))

(the (un_rooted fs path)
  (for_any (_ !)
    (-> (System !) Path
        (Maybe [Path Text])))
  (let [/ (by fs delimiter)]
    (when (text.last_index / path)
      {.:Some last_delimiter}
      (monad.let maybe.monad
        [[parent temp] (text.split_at last_delimiter path)
         [_ child] (text.split_at (text.size /) temp)]
        (pure [parent child]))

      none
      {.:None})))

(the .public (parent fs path)
  (for_any (_ !)
    (-> (System !) Path
        (Maybe Path)))
  (|> path
      (..un_rooted fs)
      (maybe:each product.left)))

(the .public (name fs path)
  (for_any (_ !)
    (-> (System !) Path
        Text))
  (|> path
      (..un_rooted fs)
      (maybe:each product.right)
      (maybe.else path)))

(the .public (future fs)
  (-> (System IO)
      (System Future))
  (`` (implementation
       (the delimiter
         (by fs delimiter))

       (,, (template.with [<name>]
             [(the <name>
                (|>> (by fs <name>)
                     future.soon))]

             [[file?]
              [directory?]
              
              [make_directory]
              [directory_files]
              [sub_directories]
              
              [file_size]
              [last_modified]
              [can_execute?]
              [read]
              [delete]]))

       (,, (template.with [<name>]
             [(the (<name> path input)
                (future.soon (by fs <name> path input)))]

             [[modify]
              [write]
              [append]
              [move]]))
       )))

(the .public (rooted fs parent child)
  (for_any (_ !)
    (-> (System !) Path Text
        Path))
  (text parent (by fs delimiter) child))

(template.with [<name>]
  [(exception.the .public (<name> file)
     (Exception Path)
     (exception.report
      (list ["Path" file])))]

  [[cannot_make]
   [cannot_find]
   [cannot_delete]

   [cannot_make_directory]
   [cannot_find_directory]])

(target.if target.jvm
           (these (ffi.the java/lang/String
                    "[1]:[0]")

                  (`` (ffi.the java/io/File
                        "[1]:[0]"
                        (new [java/lang/String])
                        (,, (template.with [<name>]
                              [(<name> [] "io" "try" boolean)]

                              [[createNewFile] [mkdir]
                               [delete]
                               [isFile] [isDirectory]
                               [canRead] [canWrite] [canExecute]]))

                        (length [] "io" "try" long)
                        (listFiles [] "io" "try" "?" [java/io/File])
                        (getAbsolutePath [] "io" "try" java/lang/String)
                        (renameTo [java/io/File] "io" "try" boolean)
                        (lastModified [] "io" "try" long)
                        (setLastModified [long] "io" "try" boolean)
                        ("read_only" "static" separator java/lang/String)))

                  (ffi.the java/lang/AutoCloseable
                    "[1]:[0]"
                    (close [] "io" "try" void))

                  (ffi.the java/io/OutputStream
                    "[1]:[0]"
                    (write [[byte]] "io" "try" void)
                    (flush [] "io" "try" void))

                  (ffi.the java/io/FileOutputStream
                    "[1]:[0]"
                    (new [java/io/File boolean] "io" "try"))

                  (ffi.the java/io/InputStream
                    "[1]:[0]"
                    (read [[byte]] "io" "try" int))

                  (ffi.the java/io/FileInputStream
                    "[1]:[0]"
                    (new [java/io/File] "io" "try"))

                  (`` (the .public default
                        (System IO)
                        (implementation
                         (the delimiter
                           (ffi.of_string (java/io/File:separator)))

                         (,, (template.with [<name> <method>]
                               [(the <name>
                                  (|>> ffi.as_string
                                       [] java/io/File:new
                                       (<method> [])
                                       (io:each (|>> (try:each (|>> ffi.of_boolean)) (try.else false)))))]

                               [[file? java/io/File:isFile]
                                [directory? java/io/File:isDirectory]]))

                         (the make_directory
                           (|>> ffi.as_string
                                [] java/io/File:new
                                (java/io/File:mkdir [])))

                         (,, (template.with [<name> <method>]
                               [(the (<name> path)
                                  (monad.let [! (try.with io.monad)]
                                    [?children (java/io/File:listFiles [] (java/io/File:new [(ffi.as_string path)]))]
                                    (when ?children
                                      {.:Some children}
                                      (|> children
                                          (list.of_array {.:None})
                                          (list.only' ! (|>> (<method> [])
                                                             (by ! each (|>> ffi.of_boolean))))
                                          (by ! each (list.each' ! (|>> (java/io/File:getAbsolutePath [])
                                                                        (by ! each (|>> ffi.of_string)))))
                                          (by ! conjoint))

                                      {.:None}
                                      (by io.monad pure (exception.except ..cannot_find_directory [path])))))]

                               [[directory_files java/io/File:isFile]
                                [sub_directories java/io/File:isDirectory]]))

                         (the file_size
                           (|>> ffi.as_string
                                [] java/io/File:new
                                (java/io/File:length [])
                                (by (try.with io.monad) each (|>> ffi.of_long .natural))))

                         (the last_modified
                           (|>> ffi.as_string
                                [] java/io/File:new
                                (java/io/File:lastModified [])
                                (by (try.with io.monad) each (|>> ffi.of_long duration.of_millis instant.absolute))))

                         (the can_execute?
                           (|>> ffi.as_string
                                [] java/io/File:new
                                (java/io/File:canExecute [])
                                (io:each (try:each (|>> ffi.of_boolean)))))

                         (the (read path)
                           (monad.let (try.with io.monad)
                             [.let [file (java/io/File:new [(ffi.as_string path)])]
                              size (java/io/File:length [] file)
                              stream (java/io/FileInputStream:new [file])
                              .let [data (binary.empty (.natural (ffi.of_long size)))]
                              bytes_read (java/io/InputStream:read [data] stream)
                              _ (java/lang/AutoCloseable:close [] stream)]
                             (pure data)))

                         (the (delete path)
                           (|> path
                               ffi.as_string
                               [] java/io/File:new
                               (java/io/File:delete [])))

                         (the (modify path time_stamp)
                           (|> path
                               ffi.as_string
                               [] java/io/File:new
                               (java/io/File:setLastModified [(|> time_stamp instant.relative duration.millis ffi.as_long)])))
                         
                         (,, (template.with [<flag> <name>]
                               [(the (<name> path data)
                                  (monad.let (try.with io.monad)
                                    [stream (java/io/FileOutputStream:new [[(java/io/File:new [(ffi.as_string path)])]
                                                                           (ffi.as_boolean <flag>)])
                                     _ (java/io/OutputStream:write [data] stream)
                                     _ (java/io/OutputStream:flush [] stream)]
                                    (java/lang/AutoCloseable:close [] stream)))]

                               [[0b write]
                                [1b append]]))

                         (the (move origin destination)
                           (|> origin
                               ffi.as_string
                               [] java/io/File:new
                               (java/io/File:renameTo [(java/io/File:new [(ffi.as_string destination)])])))
                         ))))

           target.js
           (these (ffi.the Buffer
                    "[1]:[0]"
                    ("static" from [Binary] ..Buffer))

                  (ffi.the Stats
                    "[1]:[0]"
                    (size ffi.Number)
                    (mtimeMs ffi.Number)
                    (isFile [] ffi.Boolean)
                    (isDirectory [] ffi.Boolean))

                  (ffi.the FsConstants
                    "[1]:[0]"
                    (F_OK ffi.Number)
                    (X_OK ffi.Number))

                  (ffi.the Error
                    "[1]:[0]"
                    (toString [] ffi.String))

                  (the with_future
                    (template.macro (_ <write> <type> <body>)
                      [(template.with_locals [<read>]
                         (let [[<read> <write>] (is [(Future <type>) (future.Resolver <type>)]
                                                    (future.future []))]
                           (exec
                             <body>
                             <read>)))]))
                  
                  (ffi.the Fs
                    "[1]:[0]"
                    (constants FsConstants)
                    (readFile [ffi.String ffi.Function] Any)
                    (appendFile [ffi.String Buffer ffi.Function] Any)
                    (writeFile [ffi.String Buffer ffi.Function] Any)
                    (stat [ffi.String ffi.Function] Any)
                    (access [ffi.String ffi.Number ffi.Function] Any)
                    (rename [ffi.String ffi.String ffi.Function] Any)
                    (utimes [ffi.String ffi.Number ffi.Number ffi.Function] Any)
                    (readdir [ffi.String ffi.Function] Any)
                    (mkdir [ffi.String ffi.Function] Any)
                    (unlink [ffi.String ffi.Function] Any)
                    (rmdir [ffi.String ffi.Function] Any))

                  (the (any_callback write!)
                    (-> (future.Resolver (Try Any)) ffi.Function)
                    (<| (ffi.function (_ [error Error]) Any)
                        io.value
                        write!
                        (if (ffi.null? error)
                            {try.:Success []}
                            {try.:Failure (Error:toString [] error)})))

                  (the (value_callback write!)
                    (for_any (_ a) (-> (future.Resolver (Try a)) ffi.Function))
                    (<| (ffi.function (_ [error Error datum Any]) Any)
                        io.value
                        write!
                        (if (ffi.null? error)
                            {try.:Success (as_expected datum)}
                            {try.:Failure (Error:toString [] error)})))

                  (ffi.the JsPath
                    "[1]:[0]"
                    (sep ffi.String))
                  
                  (the .public default
                    (Maybe (System Future))
                    (monad.let maybe.monad
                      [node_fs (node_js.require "fs")
                       node_path (node_js.require "path")
                       .let [node_fs (as (-> Any ..Fs) node_fs)
                             js_delimiter (if ffi.on_node_js?
                                              (JsPath:sep (as (-> Any ..JsPath) node_path))
                                              "/")]]
                      (pure (is (System Future)
                                (`` (implementation
                                     (the delimiter
                                       js_delimiter)

                                     (,, (template.with [<name> <method>]
                                           [(the (<name> path)
                                              (monad.let future.monad
                                                [?stats (with_future write! (Try Stats)
                                                          (Fs:stat [path (..value_callback write!)]
                                                                   node_fs))]
                                                (pure (when ?stats
                                                        {try.:Success stats}
                                                        (<method> [] stats)
                                                        
                                                        {try.:Failure _}
                                                        false))))]

                                           [[file?      Stats:isFile]
                                            [directory? Stats:isDirectory]]))

                                     (the (make_directory path)
                                       (monad.let future.monad
                                         [outcome (with_future write! (Try Any)
                                                    (Fs:access [path
                                                                (|> node_fs Fs:constants FsConstants:F_OK)
                                                                (..any_callback write!)]
                                                               node_fs))]
                                         (when outcome
                                           {try.:Success _}
                                           (pure (exception.except ..cannot_make_directory [path]))
                                           
                                           {try.:Failure _}
                                           (with_future write! (Try Any)
                                             (Fs:mkdir [path (..any_callback write!)] node_fs)))))

                                     (,, (template.with [<name> <method>]
                                           [(the (<name> path)
                                              (monad.let [! (try.with future.monad)]
                                                [subs (with_future write! (Try (Array ffi.String))
                                                        (Fs:readdir [path (..value_callback write!)]
                                                                    node_fs))]
                                                (|> subs
                                                    (list.of_array {.:None})
                                                    (list:each (|>> (text path js_delimiter)))
                                                    (list.each' ! (function (_ sub)
                                                                    (by ! each (|>> (<method> []) [sub])
                                                                        (with_future write! (Try Stats)
                                                                          (Fs:stat [sub (..value_callback write!)]
                                                                                   node_fs)))))
                                                    (by ! each (|>> (list.only product.right)
                                                                    (list:each product.left))))))]

                                           [[directory_files Stats:isFile]
                                            [sub_directories Stats:isDirectory]]))

                                     (the (file_size path)
                                       (monad.let (try.with future.monad)
                                         [stats (with_future write! (Try Stats)
                                                  (Fs:stat [path (..value_callback write!)]
                                                           node_fs))]
                                         (pure (|> stats
                                                   Stats:size
                                                   d.natural))))

                                     (the (last_modified path)
                                       (monad.let (try.with future.monad)
                                         [stats (with_future write! (Try Stats)
                                                  (Fs:stat [path (..value_callback write!)]
                                                           node_fs))]
                                         (pure (|> stats
                                                   Stats:mtimeMs
                                                   d.integer
                                                   duration.of_millis
                                                   instant.absolute))))

                                     (the (can_execute? path)
                                       (by future.monad each
                                           (|>> (pipe.when
                                                  {try.:Success _}
                                                  true

                                                  {try.:Failure _}
                                                  false)
                                                {try.:Success})
                                           (with_future write! (Try Any)
                                             (Fs:access [path
                                                         (|> node_fs Fs:constants FsConstants:X_OK)
                                                         (..any_callback write!)]
                                                        node_fs))))

                                     (the (read path)
                                       (with_future write! (Try Binary)
                                         (Fs:readFile [path (..value_callback write!)]
                                                      node_fs)))

                                     (the (delete path)
                                       (monad.let (try.with future.monad)
                                         [stats (with_future write! (Try Stats)
                                                  (Fs:stat [path (..value_callback write!)]
                                                           node_fs))]
                                         (with_future write! (Try Any)
                                           (if (Stats:isFile [] stats)
                                               (Fs:unlink [path (..any_callback write!)]
                                                          node_fs)
                                               (Fs:rmdir [path (..any_callback write!)]
                                                         node_fs)))))

                                     (the (modify path time_stamp)
                                       (with_future write! (Try Any)
                                         (let [when (|> time_stamp instant.relative duration.millis i.decimal)]
                                           (Fs:utimes [path when when (..any_callback write!)]
                                                      node_fs))))

                                     (,, (template.with [<name> <method>]
                                           [(the (<name> path data)
                                              (with_future write! (Try Any)
                                                (<method> [path (Buffer:from [data]) (..any_callback write!)]
                                                          node_fs)))]

                                           [[write  Fs:writeFile]
                                            [append Fs:appendFile]]))

                                     (the (move origin destination)
                                       (with_future write! (Try Any)
                                         (Fs:rename [origin destination (..any_callback write!)]
                                                    node_fs))))))))))

           target.python
           (these (`` (every (Tuple/2 left right)
                        (Nominal "python_tuple[2]" [[(,, (static .co_variant)) left]
                                                    [(,, (static .co_variant)) right]])))

                  (ffi.the PyFile
                    "[1]:[0]"
                    (read [] "io" "try" Binary)
                    (write [Binary] "io" "try" "?" Any)
                    (close [] "io" "try" "?" Any))

                  (ffi.the (open [ffi.String ffi.String] "io" "try" PyFile))
                  (ffi.the (tuple [[ffi.Integer ffi.Integer]] (Tuple/2 ffi.Integer ffi.Integer)))

                  (ffi.the os
                    "[1]:[0]"
                    ("static" X_OK ffi.Integer)

                    ("static" mkdir [ffi.String] "io" "try" "?" Any)
                    ("static" access [ffi.String ffi.Integer] "io" "try" ffi.Boolean)
                    ("static" remove [ffi.String] "io" "try" "?" Any)
                    ("static" rmdir [ffi.String] "io" "try" "?" Any)
                    ("static" rename [ffi.String ffi.String] "io" "try" "?" Any)
                    ("static" utime [ffi.String (Tuple/2 ffi.Integer ffi.Integer)] "io" "try" "?" Any)
                    ("static" listdir [ffi.String] "io" "try" (Array ffi.String)))

                  (ffi.the os/path
                    "[1]:[0]"
                    ("static" isfile [ffi.String] "io" "try" ffi.Boolean)
                    ("static" isdir [ffi.String] "io" "try" ffi.Boolean)
                    ("static" sep ffi.String)
                    ("static" getsize [ffi.String] "io" "try" ffi.Integer)
                    ("static" getmtime [ffi.String] "io" "try" ffi.Float))

                  (the python_delimiter
                    (io.value (os/path:sep)))

                  (`` (the .public default
                        (System IO)
                        (implementation
                         (the delimiter
                           ..python_delimiter)

                         (,, (template.with [<name> <method>]
                               [(the <name>
                                  (|>> []
                                       <method>
                                       (io:each (|>> (try.else false)))))]

                               [[file?      os/path:isfile]
                                [directory? os/path:isdir]]))

                         (the make_directory
                           (|>> [] os:mkdir))

                         (,, (template.with [<name> <method>]
                               [(the (<name> path)
                                  (let [! (try.with io.monad)]
                                    (|> path
                                        []
                                        os:listdir
                                        (by ! each (|>> (list.of_array {.:None})
                                                        (list:each (|>> (text path ..python_delimiter)))
                                                        (list.each' ! (function (_ sub)
                                                                        (by ! each (|>> [sub]) (<method> [sub]))))
                                                        (by ! each (|>> (list.only product.right)
                                                                        (list:each product.left)))))
                                        (by ! conjoint))))]

                               [[directory_files os/path:isfile]
                                [sub_directories os/path:isdir]]))

                         (the file_size
                           (|>> []
                                os/path:getsize
                                (by (try.with io.monad) each (|>> .natural))))

                         (the last_modified
                           (|>> []
                                os/path:getmtime
                                (by (try.with io.monad) each (|>> d.integer
                                                                  (i.x +1,000)
                                                                  duration.of_millis
                                                                  instant.absolute))))

                         (the (can_execute? path)
                           (monad.let io.monad
                             [permission (os:X_OK)]
                             (os:access [path permission])))

                         (the (read path)
                           (monad.let (try.with io.monad)
                             [file (..open [path "rb"])
                              data (PyFile:read [] file)
                              _ (PyFile:close [] file)]
                             (pure data)))

                         (the (delete path)
                           (monad.let (try.with io.monad)
                             [? (os/path:isfile [path])]
                             (if ?
                                 (os:remove [path])
                                 (os:rmdir [path]))))

                         (the (modify path time_stamp)
                           (let [when (|> time_stamp instant.relative duration.millis (i./ +1,000))]
                             (os:utime [path (..tuple [when when])])))

                         (,, (template.with [<name> <mode>]
                               [(the (<name> path data)
                                  (monad.let (try.with io.monad)
                                    [file (..open [path <mode>])
                                     _ (PyFile:write [data] file)]
                                    (PyFile:close [] file)))]
                               
                               [[write  "w+b"]
                                [append "ab"]]))

                         (the (move origin destination)
                           (os:rename [origin destination]))
                         ))))

           target.ruby
           (these (ffi.the Time
                    "[1]:[0]"
                    ("static" at [Decimal] Time)
                    (to_f [] Decimal))

                  (ffi.the Stat
                    "[1]:[0]"
                    (executable? [] Bit)
                    (size Integer)
                    (mtime [] Time))

                  (ffi.the File "as" RubyFile
                    "[1]:[0]"
                    ("static" SEPARATOR ffi.String)
                    ("static" open [Path ffi.String] "io" "try" RubyFile)
                    ("static" stat [Path] "io" "try" Stat)
                    ("static" delete [Path] "io" "try" Integer)
                    ("static" file? [Path] "io" "try" Bit)
                    ("static" directory? [Path] "io" "try" Bit)
                    ("static" utime [Time Time Path] "io" "try" Integer)

                    (read [] "io" "try" Binary)
                    (write [Binary] "io" "try" Integer)
                    (flush [] "io" "try" "?" Any)
                    (close [] "io" "try" "?" Any))

                  (ffi.the Dir
                    "[1]:[0]"
                    ("static" open [Path] "io" "try" Dir)
                    
                    (children [] "io" "try" (Array Path))
                    (close [] "io" "try" "?" Any))

                  (ffi.the "fileutils" FileUtils
                    "[2]/[1]:[0]"
                    ("static" move [Path Path] "io" "try" "?" Any)
                    ("static" rmdir [Path] "io" "try" "?" Any)
                    ("static" mkdir [Path] "io" "try" "?" Any))

                  (the ruby_delimiter
                    Text
                    (io.value (..RubyFile:SEPARATOR)))

                  (`` (the .public default
                        (System IO)
                        (implementation
                         (the delimiter
                           ..ruby_delimiter)

                         (,, (template.with [<name> <test>]
                               [(the <name>
                                  (|>> [] <test>
                                       (io:each (|>> (try.else false)))))]

                               [[file? RubyFile:file?]
                                [directory? RubyFile:directory?]]))
                         
                         (the make_directory
                           (|>> [] fileutils/FileUtils:mkdir))

                         (,, (template.with [<name> <test>]
                               [(the (<name> path)
                                  (monad.let [! (try.with io.monad)]
                                    [self (Dir:open [path])
                                     children (Dir:children [] self)
                                     output (loop (of [input (|> children
                                                                 (list.of_array {.:None})
                                                                 (list:each (|>> (text path ..ruby_delimiter)))
                                                                 (view.as list.stack))
                                                       output (is (Stack ..Path)
                                                                  (stack))])
                                              (when input
                                                {.:Empty}
                                                (pure output)

                                                {.:Top head tail}
                                                (monad.let !
                                                  [verdict (<test> [head])]
                                                  (of tail (if verdict
                                                               {.:Top head output}
                                                               output)))))
                                     _ (Dir:close [] self)]
                                    (pure (view.of list.stack output))))]

                               [[directory_files RubyFile:file?]
                                [sub_directories RubyFile:directory?]]))

                         (,, (template.with [<name> <pipeline>]
                               [(the <name>
                                  (let [! (try.with io.monad)]
                                    (|>> [] RubyFile:stat
                                         (by ! each (`` (|>> (,, (template.spliced <pipeline>))))))))]

                               [[file_size [Stat:size .natural]]
                                [last_modified [(Stat:mtime [])
                                                (Time:to_f [])
                                                (d.x +1,000.0)
                                                d.integer
                                                duration.of_millis
                                                instant.absolute]]
                                [can_execute? [(Stat:executable? [])]]]))

                         (the (read path)
                           (monad.let (try.with io.monad)
                             [file (RubyFile:open [path "rb"])
                              data (RubyFile:read [] file)
                              _ (RubyFile:close [] file)]
                             (pure data)))

                         (the (delete path)
                           (monad.let (try.with io.monad)
                             [? (RubyFile:file? [path])]
                             (if ?
                                 (RubyFile:delete [path])
                                 (fileutils/FileUtils:rmdir [path]))))

                         (the (modify path moment)
                           (let [moment (|> moment
                                            instant.relative
                                            duration.millis
                                            i.decimal
                                            (d./ +1,000.0)
                                            [] Time:at)]
                             (RubyFile:utime [moment moment path])))

                         (,, (template.with [<mode> <name>]
                               [(the (<name> path data)
                                  (monad.let [! (try.with io.monad)]
                                    [file (RubyFile:open [path <mode>])
                                     data (RubyFile:write [data] file)
                                     _ (RubyFile:flush [] file)
                                     _ (RubyFile:close [] file)]
                                    (pure [])))]
                               
                               [["wb" write]
                                ["ab" append]]))

                         (the (move origin destination)
                           (monad.let (try.with io.monad)
                             [_ (fileutils/FileUtils:move [origin destination])]
                             (pure [])))
                         ))))

           ... target.php
           ... (these (ffi.the (FILE_APPEND Integer))
           ...        ... https://www.php.net/manual/en/dir.constants.php
           ...        (ffi.the (DIRECTORY_SEPARATOR ffi.String))
           ...        ... https://www.php.net/manual/en/function.pack.php
           ...        ... https://www.php.net/manual/en/function.unpack.php
           ...        (ffi.the (unpack [ffi.String ffi.String] Binary))
           ...        ... https://www.php.net/manual/en/ref.filesystem.php
           ...        ... https://www.php.net/manual/en/function.file-get-contents.php
           ...        (ffi.the (file_get_contents [Path] "io" "try" ffi.String))
           ...        ... https://www.php.net/manual/en/function.file-put-contents.php
           ...        (ffi.the (file_put_contents [Path ffi.String Integer] "io" "try" ffi.Integer))
           ...        (ffi.the (filemtime [Path] "io" "try" ffi.Integer))
           ...        (ffi.the (filesize [Path] "io" "try" ffi.Integer))
           ...        (ffi.the (is_executable [Path] "io" "try" ffi.Boolean))
           ...        (ffi.the (touch [Path ffi.Integer] "io" "try" ffi.Boolean))
           ...        (ffi.the (rename [Path Path] "io" "try" ffi.Boolean))
           ...        (ffi.the (unlink [Path] "io" "try" ffi.Boolean))

           ...        ... https://www.php.net/manual/en/function.rmdir.php
           ...        (ffi.the (rmdir [Path] "io" "try" ffi.Boolean))
           ...        ... https://www.php.net/manual/en/function.scandir.php
           ...        (ffi.the (scandir [Path] "io" "try" (Array Path)))
           ...        ... https://www.php.net/manual/en/function.is-file.php
           ...        (ffi.the (is_file [Path] "io" "try" ffi.Boolean))
           ...        ... https://www.php.net/manual/en/function.is-dir.php
           ...        (ffi.the (is_dir [Path] "io" "try" ffi.Boolean))
           ...        ... https://www.php.net/manual/en/function.mkdir.php
           ...        (ffi.the (mkdir [Path] "io" "try" ffi.Boolean))

           ...        (the byte_array_format "C*")
           ...        (the default_delimiter (..DIRECTORY_SEPARATOR))

           ...        (template.with [<name>]
           ...          [(exception.the .public (<name> file)
           ...             (Exception Path)
           ...             (exception.report
           ...              (list ["Path" file])))]
           
           ...          [cannot_write_to_file]
           ...          )

           ...        (`` (the (file path)
           ...              (-> Path (File IO))
           ...              (implementation
           ...               (,, (template.with [<name> <mode>]
           ...                     [(the (<name> data)
           ...                        (monad.let [! (try.with io.monad)]
           ...                          [outcome (..file_put_contents [path ("php pack" ..byte_array_format data) <mode>])]
           ...                          (if (bit.= false (as Bit outcome))
           ...                            (by io.monad pure (exception.except ..cannot_write_to_file [path]))
           ...                            (pure []))))]
           
           ...                     [over_write  +0]
           ...                     [append      (..FILE_APPEND)]
           ...                     ))

           ...               (the (content _)
           ...                 (monad.let [! (try.with io.monad)]
           ...                   [data (..file_get_contents [path])]
           ...                   (if (bit.= false (as Bit data))
           ...                     (by io.monad pure (exception.except ..cannot_find_file [path]))
           ...                     (pure (..unpack [..byte_array_format data])))))

           ...               (the path
           ...                 path)

           ...               (,, (template.with [<name> <ffi> <pipeline>]
           ...                     [(the (<name> _)
           ...                        (monad.let [! (try.with io.monad)]
           ...                          [value (<ffi> [path])]
           ...                          (if (bit.= false (as Bit value))
           ...                            (by io.monad pure (exception.except ..cannot_find_file [path]))
           ...                            (pure (`` (|> value (,, (template.spliced <pipeline>))))))))]

           ...                     [size ..filesize [.natural]]
           ...                     [last_modified ..filemtime [(i.x +1,000) duration.of_millis instant.absolute]]
           ...                     ))

           ...               (the (can_execute? _)
           ...                 (..is_executable [path]))

           ...               (the (modify moment)
           ...                 (monad.let [! (try.with io.monad)]
           ...                   [verdict (..touch [path (|> moment instant.relative duration.millis (i./ +1,000))])]
           ...                   (if (bit.= false (as Bit verdict))
           ...                     (by io.monad pure (exception.except ..cannot_find [path]))
           ...                     (pure []))))

           ...               (the (move destination)
           ...                 (monad.let [! (try.with io.monad)]
           ...                   [verdict (..rename [path destination])]
           ...                   (if (bit.= false (as Bit verdict))
           ...                     (by io.monad pure (exception.except ..cannot_find [path]))
           ...                     (pure (file destination)))))

           ...               (the (delete _)
           ...                 (monad.let (try.with io.monad)
           ...                   [verdict (..unlink [path])]
           ...                   (if (bit.= false (as Bit verdict))
           ...                     (by io.monad pure (exception.except ..cannot_find [path]))
           ...                     (pure []))))
           ...               )))

           ...        (`` (the (directory path)
           ...              (-> Path (Directory IO))
           ...              (implementation
           ...               (the scope
           ...                 path)

           ...               (,, (template.with [<name> <test> <constructor> <capability>]
           ...                     [(the (<name> _)
           ...                        (monad.let [! (try.with io.monad)]
           ...                          [children (..scandir [path])]
           ...                          (loop (of [input (|> children
           ...                                                  (list.of_array {.:None})
           ...                                                  (list.only (function (_ child)
           ...                                                               (not (or (text.= "." child)
           ...                                                                        (text.= ".." child))))))
           ...                                        output (is (List (<capability> IO))
           ...                                                   (list))])
           ...                            (when input
           ...                              {.:Empty}
           ...                              (pure output)

           ...                              {.:Top head tail}
           ...                              (monad.let !
           ...                                [verdict (<test> head)]
           ...                                (if verdict
           ...                                  (of tail {.:Top (<constructor> head) output})
           ...                                  (of tail output)))))))]

           ...                     [files ..is_file ..file File]
           ...                     [directories ..is_dir directory Directory]
           ...                     ))

           ...               (the (discard _)
           ...                 (monad.let (try.with io.monad)
           ...                   [verdict (..rmdir [path])]
           ...                   (if (bit.= false (as Bit verdict))
           ...                     (by io.monad pure (exception.except ..cannot_find_directory [path]))
           ...                     (pure []))))
           ...               )))

           ...        (`` (the .public default
           ...              (System IO)
           ...              (implementation
           ...               (,, (template.with [<name> <test> <constructor> <exception>]
           ...                     [(the (<name> path)
           ...                        (monad.let [! (try.with io.monad)]
           ...                          [verdict (<test> path)]
           ...                          (by io.monad pure
           ...                              (if verdict
           ...                                {try.:Success (<constructor> path)}
           ...                                (exception.except <exception> [path])))))]

           ...                     [file ..is_file ..file ..cannot_find]
           ...                     [directory ..is_dir ..directory ..cannot_find_directory]
           ...                     ))

           ...               (the (make path)
           ...                 (monad.let [! (try.with io.monad)]
           ...                   [verdict (..touch [path (|> instant.now io.value instant.relative duration.millis (i./ +1,000))])]
           ...                   (by io.monad pure
           ...                       (if verdict
           ...                         {try.:Success (..file path)}
           ...                         (exception.except ..cannot_make [path])))))
           
           ...               (the (make_directory path)
           ...                 (monad.let [! (try.with io.monad)]
           ...                   [verdict (..mkdir path)]
           ...                   (by io.monad pure
           ...                       (if verdict
           ...                         {try.:Success (..directory path)}
           ...                         (exception.except ..cannot_make_directory [path])))))

           ...               (the delimiter
           ...                 ..default_delimiter)
           ...               )))
           ...        )
           
           (these))

(the .public (exists? monad fs path)
  (for_any (_ !)
    (-> (Monad !) (System !) Path
        (! Bit)))
  (monad.let monad
    [verdict (by fs file? path)]
    (if verdict
        (pure verdict)
        (by fs directory? path))))

(every Memory_File
  (Record
   [:memory_last_modified Instant
    :memory_can_execute Bit
    :memory_content Binary]))

(every Memory
  (Rec Memory
    (Dictionary Text (Either Memory_File Memory))))

(the empty_memory
  Memory
  (dictionary.empty text.hash))

(the (retrieve_memory_file! delimiter path memory)
  (-> Text Path Memory
      (Try [Text Memory_File]))
  (loop (of [directory memory
             trail (view.as list.stack (text.all_split_by delimiter path))])
    (when trail
      {.:Top head tail}
      (when (dictionary.value head directory)
        {try.:Success node}
        (when [node tail]
          [{.:Left file} {.:Empty}]
          {try.:Success [head file]}

          [{.:Right sub_directory} {.:Top _}]
          (of sub_directory tail)

          _
          (exception.except ..cannot_find [path]))

        failure
        (exception.except ..cannot_find [path]))

      {.:Empty}
      (exception.except ..cannot_find [path]))))

(the (update_memory_file! / path now content memory)
  (-> Text Path Instant Binary Memory
      (Try Memory))
  (loop (of [directory memory
             trail (view.as list.stack (text.all_split_by / path))])
    (when trail
      {.:Top head tail}
      (when (dictionary.value head directory)
        {try.:Success node}
        (when [node tail]
          [{.:Left file} {.:Empty}]
          {try.:Success (dictionary.has head
                                        {.:Left (|> file
                                                    (has :memory_last_modified now)
                                                    (has :memory_content content))}
                                        directory)}

          [{.:Right sub_directory} {.:Top _}]
          (monad.let try.monad
            [sub_directory (of sub_directory tail)]
            (pure (dictionary.has head {.:Right sub_directory} directory)))

          _
          (exception.except ..cannot_find [path]))

        failure
        (when tail
          {.:Empty}
          {try.:Success (dictionary.has head
                                        {.:Left [:memory_last_modified now
                                                 :memory_can_execute false
                                                 :memory_content content]}
                                        directory)}
          
          {.:Top _}
          (exception.except ..cannot_find [path])))

      {.:Empty}
      (exception.except ..cannot_find [path]))))

(the (delete_memory_node! / path memory)
  (-> Text Path Memory
      (Try Memory))
  (loop (of [directory memory
             trail (view.as list.stack (text.all_split_by / path))])
    (when trail
      {.:Top head tail}
      (when (dictionary.value head directory)
        {try.:Success node}
        (when tail
          {.:Empty}
          (when node
            {.:Left file}
            {try.:Success (dictionary.lacks head directory)}

            {.:Right sub_directory}
            (if (dictionary.empty? sub_directory)
                {try.:Success (dictionary.lacks head directory)}
                (exception.except ..cannot_delete [path])))
          
          {.:Top _}
          (when node
            {.:Left file}
            (exception.except ..cannot_delete [path])

            {.:Right sub_directory}
            (monad.let try.monad
              [sub_directory' (of sub_directory tail)]
              (pure (dictionary.has head {.:Right sub_directory'} directory)))))

        failure
        (exception.except ..cannot_delete [path]))

      {.:Empty}
      (exception.except ..cannot_delete [path]))))

(the (attempt! transform var)
  (for_any (_ it)
    (-> (-> it (Try it)) (Var it)
        (STM (Try Any))))
  (monad.let [! stm.monad]
    [|var| (stm.read var)]
    (when (transform |var|)
      {try.:Success |var|}
      (monad.let !
        [_ (stm.write |var| var)]
        (pure {try.:Success []}))
      
      {try.:Failure error}
      (pure {try.:Failure error}))))

(the (make_memory_directory! / path memory)
  (-> Text Path Memory
      (Try Memory))
  (loop (of [directory memory
             trail (view.as list.stack (text.all_split_by / path))])
    (when trail
      {.:Top head tail}
      (when (dictionary.value head directory)
        {try.:Success node}
        (when [node tail]
          [{.:Right sub_directory} {.:Top _}]
          (monad.let try.monad
            [sub_directory (of sub_directory tail)]
            (pure (dictionary.has head {.:Right sub_directory} directory)))

          _
          (exception.except ..cannot_make_directory [path]))

        failure
        (when tail
          {.:Empty}
          {try.:Success (dictionary.has head {.:Right ..empty_memory} directory)}

          {.:Top _}
          (exception.except ..cannot_make_directory [path])))

      {.:Empty}
      (exception.except ..cannot_make_directory [path]))))

(the (retrieve_memory_directory! / path memory)
  (-> Text Path Memory
      (Try Memory))
  (loop (of [directory memory
             trail (view.as list.stack (text.all_split_by / path))])
    (when trail
      {.:Empty}
      {try.:Success directory}

      {.:Top head tail}
      (when (dictionary.value head directory)
        {try.:Success node}
        (when node
          {.:Left _}
          (exception.except ..cannot_find_directory [path])

          {.:Right sub_directory}
          (when tail
            {.:Empty}
            {try.:Success sub_directory}

            {.:Top _}
            (of sub_directory tail)))

        failure
        (exception.except ..cannot_find_directory [path])))))

(the .public (memory delimiter)
  (-> Text
      (System Future))
  (let [store (stm.var ..empty_memory)]
    (`` (implementation
         (the delimiter
           delimiter)

         (,, (template.with [<method> <retrieve>]
               [(the (<method> path)
                  (|> store
                      stm.read
                      (by stm.monad each
                          (|>> (<retrieve> delimiter path)
                               (try:each (function.constant true))
                               (try.else false)))
                      stm.commit!))]
               
               [[file? ..retrieve_memory_file!]
                [directory? ..retrieve_memory_directory!]]))

         (the (make_directory path)
           (stm.commit!
            (monad.let [! stm.monad]
              [|store| (stm.read store)]
              (when (..make_memory_directory! delimiter path |store|)
                {try.:Success |store|}
                (monad.let !
                  [_ (stm.write |store| store)]
                  (pure {try.:Success []}))
                
                {try.:Failure error}
                (pure {try.:Failure error})))))

         (,, (template.with [<method> <tag>]
               [(the (<method> path)
                  (stm.commit!
                   (monad.let stm.monad
                     [|store| (stm.read store)]
                     (pure (monad.let try.monad
                             [directory (..retrieve_memory_directory! delimiter path |store|)]
                             (pure (|> directory
                                       dictionary.entries
                                       (list.all (function (_ [node_name node])
                                                   (when node
                                                     {<tag> _}
                                                     {.:Some (text path delimiter node_name)}
                                                     
                                                     _
                                                     {.:None}))))))))))]

               [[directory_files .:Left]
                [sub_directories .:Right]]))

         (the (file_size path)
           (stm.commit!
            (monad.let stm.monad
              [|store| (stm.read store)]
              (pure (|> |store|
                        (..retrieve_memory_file! delimiter path)
                        (try:each (|>> product.right
                                       (its :memory_content)
                                       binary.size)))))))

         (the (last_modified path)
           (stm.commit!
            (monad.let stm.monad
              [|store| (stm.read store)]
              (pure (|> |store|
                        (..retrieve_memory_file! delimiter path)
                        (try:each (|>> product.right
                                       (its :memory_last_modified))))))))

         (the (can_execute? path)
           (stm.commit!
            (monad.let stm.monad
              [|store| (stm.read store)]
              (pure (|> |store|
                        (..retrieve_memory_file! delimiter path)
                        (try:each (|>> product.right
                                       (its :memory_can_execute))))))))

         (the (read path)
           (stm.commit!
            (monad.let stm.monad
              [|store| (stm.read store)]
              (pure (|> |store|
                        (..retrieve_memory_file! delimiter path)
                        (try:each (|>> product.right
                                       (its :memory_content)
                                       (composite identity)
                                       (with binary.monoid))))))))

         (the (delete path)
           (stm.commit!
            (..attempt! (..delete_memory_node! delimiter path) store)))

         (the (modify path now)
           (stm.commit!
            (..attempt! (function (_ |store|)
                          (monad.let try.monad
                            [[name file] (..retrieve_memory_file! delimiter path |store|)]
                            (..update_memory_file! delimiter path now (its :memory_content file) |store|)))
                        store)))

         (the (write path content)
           (monad.let future.monad
             [now (future.soon instant.now)]
             (stm.commit!
              (..attempt! (..update_memory_file! delimiter path now
                                                 (with binary.monoid
                                                   (composite identity content)))
                          store))))

         (the (append path content)
           (monad.let future.monad
             [now (future.soon instant.now)]
             (stm.commit!
              (..attempt! (function (_ |store|)
                            (monad.let try.monad
                              [[name file] (..retrieve_memory_file! delimiter path |store|)]
                              (..update_memory_file! delimiter path now
                                                     (by binary.monoid composite
                                                         (its :memory_content file)
                                                         content)
                                                     |store|)))
                          store))))

         (the (move origin destination)
           (stm.commit!
            (monad.let [! stm.monad]
              [|store| (stm.read store)]
              (when (monad.let try.monad
                      [[name file] (..retrieve_memory_file! delimiter origin |store|)
                       |store| (..delete_memory_node! delimiter origin |store|)]
                      (..update_memory_file! delimiter destination (its :memory_last_modified file) (its :memory_content file) |store|))
                {try.:Success |store|}
                (monad.let !
                  [_ (stm.write |store| store)]
                  (pure {try.:Success []}))
                
                {try.:Failure error}
                (pure {try.:Failure error})))))
         ))))

(the (check_or_make_directory monad fs path)
  (for_any (_ !)
    (-> (Monad !) (System !) Path
        (! (Try Any))))
  (monad.let monad
    [? (by fs directory? path)]
    (if ?
        (pure {try.:Success []})
        (by fs make_directory path))))

(the .public (make_directories monad fs path)
  (for_any (_ !)
    (-> (Monad !) (System !) Path
        (! (Try Any))))
  (let [rooted? (text.starts_with? (by fs delimiter) path)
        segments (text.all_split_by (by fs delimiter) path)]
    (when (view.as list.stack (if rooted?
                                  (list.after 1 segments)
                                  segments))
      {.:Empty}
      (by monad pure (exception.except ..cannot_make_directory [path]))

      {.:Top head tail}
      (when head
        "" (by monad pure (exception.except ..cannot_make_directory [path]))
        _ (loop (of [current (if rooted?
                                 (text (by fs delimiter) head)
                                 head)
                     next tail])
            (monad.let monad
              [? (..check_or_make_directory monad fs current)]
              (when ?
                {try.:Success _}
                (when next
                  {.:Empty}
                  (pure {try.:Success []})
                  
                  {.:Top head tail}
                  (of (text current (by fs delimiter) head)
                      tail))
                
                {try.:Failure error}
                (pure {try.:Failure error}))))))))

(the .public (new monad fs content path)
  (for_any (_ !)
    (-> (Monad !) (System !) Binary Path
        (! (Try Any))))
  (monad.let monad
    [? (by fs file? path)]
    (if ?
        (pure (exception.except ..cannot_make [path]))
        (by fs write path content))))

(the .public (copy monad fs from to)
  (for_any (_ !)
    (-> (Monad !) (System !) Path Path
        (! (Try Any))))
  (monad.let (try.with monad)
    [data (by fs read from)]
    (by fs write to data)))
