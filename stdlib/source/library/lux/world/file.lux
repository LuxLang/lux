... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.`` (.`` (.using
           [library
            [lux (.except Error
                          open tuple name)
             [abstract
              ["[0]" monad (.only Monad do)]]
             [concurrency
              ["[0]" future (.only Future)]
              ["[0]" stm (.only Var STM)]]
             [control
              ["[0]" pipe]
              ["[0]" maybe (.use "[1]#[0]" functor)]
              ["[0]" try (.only Try) (.use "[1]#[0]" functor)]
              ["[0]" exception (.only Exception)]
              ["[0]" io (.only IO) (.use "[1]#[0]" functor)]
              ["[0]" function]]
             [data
              ["[0]" bit]
              ["[0]" product]
              ["[0]" binary (.only Binary)]
              ["[0]" text (.only)
               ["%" \\injection]]
              [collection
               ["[0]" array (.only Array)]
               ["[0]" list (.use "[1]#[0]" functor)]
               ["[0]" dictionary (.only Dictionary)]]]
             ["[0]" ffi (.only)
              (.,, (.for .js (.,, (.these ["[0]" node_js]))
                         (.,, (.these))))]
             [math
              [number
               ["i" integer]
               ["d" decimal]]]
             [macro
              ["[0]" template]
              ["[0]" expansion]]
             [time
              ["[0]" instant (.only Instant)]
              ["[0]" duration]]]])))

(every .public Path
  Text)

(`` (every .public (System !)
      (Interface
       ... https://en.wikipedia.org/wiki/Delimiter
       (is Text
           delimiter)

       (,, (template.with [<name> <output>]
             [(is (-> Path (! <output>))
                  <name>)]

             [file? Bit]
             [directory? Bit]
             ))

       (,, (template.with [<name> <output>]
             [(is (-> Path (! (Try <output>)))
                  <name>)]

             [make_directory  Any]
             [directory_files (List Path)]
             [sub_directories (List Path)]
             
             [file_size     Natural]
             [last_modified Instant]
             [can_execute?  Bit]
             [read          Binary]
             [delete        Any]
             ))

       (,, (template.with [<name> <input>]
             [(is (-> Path <input> (! (Try Any)))
                  <name>)]

             [modify Instant]
             [write  Binary]
             [append Binary]
             [move   Path]
             )))
      ))

(the (un_rooted fs path)
  (for_any (_ !)
    (-> (System !) Path
        (Maybe [Path Text])))
  (let [/ (by fs delimiter)]
    (when (text.last_index / path)
      {.#None}
      {.#None}
      
      {.#Some last_delimiter}
      (do maybe.monad
        [[parent temp] (text.split_at last_delimiter path)
         [_ child] (text.split_at (text.size /) temp)]
        (in [parent child])))))

(the .public (parent fs path)
  (for_any (_ !)
    (-> (System !) Path
        (Maybe Path)))
  (|> path
      (..un_rooted fs)
      (maybe#each product.left)))

(the .public (name fs path)
  (for_any (_ !)
    (-> (System !) Path
        Text))
  (|> path
      (..un_rooted fs)
      (maybe#each product.right)
      (maybe.else path)))

(the .public (future fs)
  (-> (System IO)
      (System Future))
  (`` (implementation
       (the delimiter
         (by fs delimiter))

       (,, (template.with [<name>]
             [(the <name>
                (|>> (by fs <name>)
                     future.soon))]

             [file?]
             [directory?]
             
             [make_directory]
             [directory_files]
             [sub_directories]
             
             [file_size]
             [last_modified]
             [can_execute?]
             [read]
             [delete]))

       (,, (template.with [<name>]
             [(the (<name> path input)
                (future.soon (by fs <name> path input)))]

             [modify]
             [write]
             [append]
             [move]))
       )))

(the .public (rooted fs parent child)
  (for_any (_ !)
    (-> (System !) Path Text
        Path))
  (%.message parent (by fs delimiter) child))

(template.with [<name>]
  [(exception.the .public (<name> file)
     (Exception Path)
     (exception.report
      (list ["Path" file])))]

  [cannot_make_file]
  [cannot_find_file]
  [cannot_delete]

  [cannot_make_directory]
  [cannot_find_directory]
  )

(for .jvm
     (these (ffi.import java/lang/String
              "[1]::[0]")

            (`` (ffi.import java/io/File
                  "[1]::[0]"
                  (new [java/lang/String])
                  (,, (template.with [<name>]
                        [(<name> [] "io" "try" boolean)]

                        [createNewFile] [mkdir]
                        [delete]
                        [isFile] [isDirectory]
                        [canRead] [canWrite] [canExecute]))

                  (length [] "io" "try" long)
                  (listFiles [] "io" "try" "?" [java/io/File])
                  (getAbsolutePath [] "io" "try" java/lang/String)
                  (renameTo [java/io/File] "io" "try" boolean)
                  (lastModified [] "io" "try" long)
                  (setLastModified [long] "io" "try" boolean)
                  ("read_only" "static" separator java/lang/String)))

            (ffi.import java/lang/AutoCloseable
              "[1]::[0]"
              (close [] "io" "try" void))

            (ffi.import java/io/OutputStream
              "[1]::[0]"
              (write [[byte]] "io" "try" void)
              (flush [] "io" "try" void))

            (ffi.import java/io/FileOutputStream
              "[1]::[0]"
              (new [java/io/File boolean] "io" "try"))

            (ffi.import java/io/InputStream
              "[1]::[0]"
              (read [[byte]] "io" "try" int))

            (ffi.import java/io/FileInputStream
              "[1]::[0]"
              (new [java/io/File] "io" "try"))

            (`` (the .public default
                  (System IO)
                  (implementation
                   (the delimiter
                     (ffi.of_string (java/io/File::separator)))

                   (,, (template.with [<name> <method>]
                         [(the <name>
                            (|>> ffi.as_string
                                 [] java/io/File::new
                                 (<method> [])
                                 (io#each (|>> (try#each (|>> ffi.of_boolean)) (try.else false)))))]

                         [file? java/io/File::isFile]
                         [directory? java/io/File::isDirectory]
                         ))

                   (the make_directory
                     (|>> ffi.as_string
                          [] java/io/File::new
                          (java/io/File::mkdir [])))

                   (,, (template.with [<name> <method>]
                         [(the (<name> path)
                            (do [! (try.with io.monad)]
                              [?children (java/io/File::listFiles [] (java/io/File::new [(ffi.as_string path)]))]
                              (when ?children
                                {.#Some children}
                                (|> children
                                    (array.list {.#None})
                                    (monad.only ! (|>> (<method> [])
                                                       (by ! each (|>> ffi.of_boolean))))
                                    (by ! each (monad.each ! (|>> (java/io/File::getAbsolutePath [])
                                                                  (by ! each (|>> ffi.of_string)))))
                                    (by ! conjoint))

                                {.#None}
                                (by io.monad in (exception.except ..cannot_find_directory [path])))))]

                         [directory_files java/io/File::isFile]
                         [sub_directories java/io/File::isDirectory]
                         ))

                   (the file_size
                     (|>> ffi.as_string
                          [] java/io/File::new
                          (java/io/File::length [])
                          (by (try.with io.monad) each (|>> ffi.of_long .natural))))

                   (the last_modified
                     (|>> ffi.as_string
                          [] java/io/File::new
                          (java/io/File::lastModified [])
                          (by (try.with io.monad) each (|>> ffi.of_long duration.of_millis instant.absolute))))

                   (the can_execute?
                     (|>> ffi.as_string
                          [] java/io/File::new
                          (java/io/File::canExecute [])
                          (io#each (try#each (|>> ffi.of_boolean)))))

                   (the (read path)
                     (do (try.with io.monad)
                       [.let [file (java/io/File::new [(ffi.as_string path)])]
                        size (java/io/File::length [] file)
                        stream (java/io/FileInputStream::new [file])
                        .let [data (binary.empty (.natural (ffi.of_long size)))]
                        bytes_read (java/io/InputStream::read [data] stream)
                        _ (java/lang/AutoCloseable::close [] stream)]
                       (in data)))

                   (the (delete path)
                     (|> path
                         ffi.as_string
                         [] java/io/File::new
                         (java/io/File::delete [])))

                   (the (modify path time_stamp)
                     (|> path
                         ffi.as_string
                         [] java/io/File::new
                         (java/io/File::setLastModified [(|> time_stamp instant.relative duration.millis ffi.as_long)])))
                   
                   (,, (template.with [<flag> <name>]
                         [(the (<name> path data)
                            (do (try.with io.monad)
                              [stream (java/io/FileOutputStream::new [[(java/io/File::new [(ffi.as_string path)])]
                                                                      (ffi.as_boolean <flag>)])
                               _ (java/io/OutputStream::write [data] stream)
                               _ (java/io/OutputStream::flush [] stream)]
                              (java/lang/AutoCloseable::close [] stream)))]

                         [#0 write]
                         [#1 append]
                         ))

                   (the (move origin destination)
                     (|> origin
                         ffi.as_string
                         [] java/io/File::new
                         (java/io/File::renameTo [(java/io/File::new [(ffi.as_string destination)])])))
                   ))))

     .js
     (these (ffi.import Buffer
              "[1]::[0]"
              ("static" from [Binary] ..Buffer))

            (ffi.import Stats
              "[1]::[0]"
              (size ffi.Number)
              (mtimeMs ffi.Number)
              (isFile [] ffi.Boolean)
              (isDirectory [] ffi.Boolean))

            (ffi.import FsConstants
              "[1]::[0]"
              (F_OK ffi.Number)
              (X_OK ffi.Number))

            (ffi.import Error
              "[1]::[0]"
              (toString [] ffi.String))

            (the with_future
              (template.macro (_ <write> <type> <body>)
                [(template.with_locals [<read>]
                   (let [[<read> <write>] (is [(Future <type>) (future.Resolver <type>)]
                                              (future.future []))]
                     (exec
                       <body>
                       <read>)))]))
            
            (ffi.import Fs
              "[1]::[0]"
              (constants FsConstants)
              (readFile [ffi.String ffi.Function] Any)
              (appendFile [ffi.String Buffer ffi.Function] Any)
              (writeFile [ffi.String Buffer ffi.Function] Any)
              (stat [ffi.String ffi.Function] Any)
              (access [ffi.String ffi.Number ffi.Function] Any)
              (rename [ffi.String ffi.String ffi.Function] Any)
              (utimes [ffi.String ffi.Number ffi.Number ffi.Function] Any)
              (readdir [ffi.String ffi.Function] Any)
              (mkdir [ffi.String ffi.Function] Any)
              (unlink [ffi.String ffi.Function] Any)
              (rmdir [ffi.String ffi.Function] Any))

            (the (any_callback write!)
              (-> (future.Resolver (Try Any)) ffi.Function)
              (<| (ffi.function (_ [error Error]) Any)
                  io.value
                  write!
                  (if (ffi.null? error)
                    {try.#Success []}
                    {try.#Failure (Error::toString [] error)})))

            (the (value_callback write!)
              (for_any (_ a) (-> (future.Resolver (Try a)) ffi.Function))
              (<| (ffi.function (_ [error Error datum Any]) Any)
                  io.value
                  write!
                  (if (ffi.null? error)
                    {try.#Success (as_expected datum)}
                    {try.#Failure (Error::toString [] error)})))

            (ffi.import JsPath
              "[1]::[0]"
              (sep ffi.String))
            
            (the .public default
              (Maybe (System Future))
              (do maybe.monad
                [node_fs (node_js.require "fs")
                 node_path (node_js.require "path")
                 .let [node_fs (as ..Fs node_fs)
                       js_delimiter (if ffi.on_node_js?
                                      (JsPath::sep (as ..JsPath node_path))
                                      "/")]]
                (in (is (System Future)
                        (`` (implementation
                             (the delimiter
                               js_delimiter)

                             (,, (template.with [<name> <method>]
                                   [(the (<name> path)
                                      (do future.monad
                                        [?stats (with_future write! (Try Stats)
                                                  (Fs::stat [path (..value_callback write!)]
                                                            node_fs))]
                                        (in (when ?stats
                                              {try.#Success stats}
                                              (<method> [] stats)
                                              
                                              {try.#Failure _}
                                              false))))]

                                   [file?      Stats::isFile]
                                   [directory? Stats::isDirectory]
                                   ))

                             (the (make_directory path)
                               (do future.monad
                                 [outcome (with_future write! (Try Any)
                                            (Fs::access [path
                                                         (|> node_fs Fs::constants FsConstants::F_OK)
                                                         (..any_callback write!)]
                                                        node_fs))]
                                 (when outcome
                                   {try.#Success _}
                                   (in (exception.except ..cannot_make_directory [path]))
                                   
                                   {try.#Failure _}
                                   (with_future write! (Try Any)
                                     (Fs::mkdir [path (..any_callback write!)] node_fs)))))

                             (,, (template.with [<name> <method>]
                                   [(the (<name> path)
                                      (do [! (try.with future.monad)]
                                        [subs (with_future write! (Try (Array ffi.String))
                                                (Fs::readdir [path (..value_callback write!)]
                                                             node_fs))]
                                        (|> subs
                                            (array.list {.#None})
                                            (list#each (|>> (%.message path js_delimiter)))
                                            (monad.each ! (function (_ sub)
                                                            (by ! each (|>> (<method> []) [sub])
                                                                (with_future write! (Try Stats)
                                                                  (Fs::stat [sub (..value_callback write!)]
                                                                            node_fs)))))
                                            (by ! each (|>> (list.only product.right)
                                                            (list#each product.left))))))]

                                   [directory_files Stats::isFile]
                                   [sub_directories Stats::isDirectory]
                                   ))

                             (the (file_size path)
                               (do (try.with future.monad)
                                 [stats (with_future write! (Try Stats)
                                          (Fs::stat [path (..value_callback write!)]
                                                    node_fs))]
                                 (in (|> stats
                                         Stats::size
                                         d.natural))))

                             (the (last_modified path)
                               (do (try.with future.monad)
                                 [stats (with_future write! (Try Stats)
                                          (Fs::stat [path (..value_callback write!)]
                                                    node_fs))]
                                 (in (|> stats
                                         Stats::mtimeMs
                                         d.integer
                                         duration.of_millis
                                         instant.absolute))))

                             (the (can_execute? path)
                               (by future.monad each
                                   (|>> (pipe.when
                                          {try.#Success _}
                                          true

                                          {try.#Failure _}
                                          false)
                                        {try.#Success})
                                   (with_future write! (Try Any)
                                     (Fs::access [path
                                                  (|> node_fs Fs::constants FsConstants::X_OK)
                                                  (..any_callback write!)]
                                                 node_fs))))

                             (the (read path)
                               (with_future write! (Try Binary)
                                 (Fs::readFile [path (..value_callback write!)]
                                               node_fs)))

                             (the (delete path)
                               (do (try.with future.monad)
                                 [stats (with_future write! (Try Stats)
                                          (Fs::stat [path (..value_callback write!)]
                                                    node_fs))]
                                 (with_future write! (Try Any)
                                   (if (Stats::isFile [] stats)
                                     (Fs::unlink [path (..any_callback write!)]
                                                 node_fs)
                                     (Fs::rmdir [path (..any_callback write!)]
                                                node_fs)))))

                             (the (modify path time_stamp)
                               (with_future write! (Try Any)
                                 (let [when (|> time_stamp instant.relative duration.millis i.decimal)]
                                   (Fs::utimes [path when when (..any_callback write!)]
                                               node_fs))))

                             (,, (template.with [<name> <method>]
                                   [(the (<name> path data)
                                      (with_future write! (Try Any)
                                        (<method> [path (Buffer::from [data]) (..any_callback write!)]
                                                  node_fs)))]

                                   [write  Fs::writeFile]
                                   [append Fs::appendFile]
                                   ))

                             (the (move origin destination)
                               (with_future write! (Try Any)
                                 (Fs::rename [origin destination (..any_callback write!)]
                                             node_fs))))))))))

     .python
     (these (every (Tuple/2 left right)
              (Nominal "python_tuple[2]" [left right]))

            (ffi.import PyFile
              "[1]::[0]"
              (read [] "io" "try" Binary)
              (write [Binary] "io" "try" "?" Any)
              (close [] "io" "try" "?" Any))

            (ffi.import (open [ffi.String ffi.String] "io" "try" PyFile))
            (ffi.import (tuple [[ffi.Integer ffi.Integer]] (Tuple/2 ffi.Integer ffi.Integer)))

            (ffi.import os
              "[1]::[0]"
              ("static" X_OK ffi.Integer)

              ("static" mkdir [ffi.String] "io" "try" "?" Any)
              ("static" access [ffi.String ffi.Integer] "io" "try" ffi.Boolean)
              ("static" remove [ffi.String] "io" "try" "?" Any)
              ("static" rmdir [ffi.String] "io" "try" "?" Any)
              ("static" rename [ffi.String ffi.String] "io" "try" "?" Any)
              ("static" utime [ffi.String (Tuple/2 ffi.Integer ffi.Integer)] "io" "try" "?" Any)
              ("static" listdir [ffi.String] "io" "try" (Array ffi.String)))

            (ffi.import os/path
              "[1]::[0]"
              ("static" isfile [ffi.String] "io" "try" ffi.Boolean)
              ("static" isdir [ffi.String] "io" "try" ffi.Boolean)
              ("static" sep ffi.String)
              ("static" getsize [ffi.String] "io" "try" ffi.Integer)
              ("static" getmtime [ffi.String] "io" "try" ffi.Float))

            (the python_delimiter
              (io.value (os/path::sep)))

            (`` (the .public default
                  (System IO)
                  (implementation
                   (the delimiter
                     ..python_delimiter)

                   (,, (template.with [<name> <method>]
                         [(the <name>
                            (|>> []
                                 <method>
                                 (io#each (|>> (try.else false)))))]

                         [file?      os/path::isfile]
                         [directory? os/path::isdir]
                         ))

                   (the make_directory
                     (|>> [] os::mkdir))

                   (,, (template.with [<name> <method>]
                         [(the (<name> path)
                            (let [! (try.with io.monad)]
                              (|> path
                                  []
                                  os::listdir
                                  (by ! each (|>> (array.list {.#None})
                                                  (list#each (|>> (%.message path ..python_delimiter)))
                                                  (monad.each ! (function (_ sub)
                                                                  (by ! each (|>> [sub]) (<method> [sub]))))
                                                  (by ! each (|>> (list.only product.right)
                                                                  (list#each product.left)))))
                                  (by ! conjoint))))]

                         [directory_files os/path::isfile]
                         [sub_directories os/path::isdir]
                         ))

                   (the file_size
                     (|>> []
                          os/path::getsize
                          (by (try.with io.monad) each (|>> .natural))))

                   (the last_modified
                     (|>> []
                          os/path::getmtime
                          (by (try.with io.monad) each (|>> d.integer
                                                            (i.* +1,000)
                                                            duration.of_millis
                                                            instant.absolute))))

                   (the (can_execute? path)
                     (do io.monad
                       [permission (os::X_OK)]
                       (os::access [path permission])))

                   (the (read path)
                     (do (try.with io.monad)
                       [file (..open [path "rb"])
                        data (PyFile::read [] file)
                        _ (PyFile::close [] file)]
                       (in data)))

                   (the (delete path)
                     (do (try.with io.monad)
                       [? (os/path::isfile [path])]
                       (if ?
                         (os::remove [path])
                         (os::rmdir [path]))))

                   (the (modify path time_stamp)
                     (let [when (|> time_stamp instant.relative duration.millis (i./ +1,000))]
                       (os::utime [path (..tuple [when when])])))

                   (,, (template.with [<name> <mode>]
                         [(the (<name> path data)
                            (do (try.with io.monad)
                              [file (..open [path <mode>])
                               _ (PyFile::write [data] file)]
                              (PyFile::close [] file)))]
                         
                         [write  "w+b"]
                         [append "ab"]
                         ))

                   (the (move origin destination)
                     (os::rename [origin destination]))
                   ))))

     .ruby
     (these (ffi.import Time
              "[1]::[0]"
              ("static" at [Decimal] Time)
              (to_f [] Decimal))

            (ffi.import Stat
              "[1]::[0]"
              (executable? [] Bit)
              (size Integer)
              (mtime [] Time))

            (ffi.import File "as" RubyFile
              "[1]::[0]"
              ("static" SEPARATOR ffi.String)
              ("static" open [Path ffi.String] "io" "try" RubyFile)
              ("static" stat [Path] "io" "try" Stat)
              ("static" delete [Path] "io" "try" Integer)
              ("static" file? [Path] "io" "try" Bit)
              ("static" directory? [Path] "io" "try" Bit)
              ("static" utime [Time Time Path] "io" "try" Integer)

              (read [] "io" "try" Binary)
              (write [Binary] "io" "try" Integer)
              (flush [] "io" "try" "?" Any)
              (close [] "io" "try" "?" Any))

            (ffi.import Dir
              "[1]::[0]"
              ("static" open [Path] "io" "try" Dir)
              
              (children [] "io" "try" (Array Path))
              (close [] "io" "try" "?" Any))

            (ffi.import "fileutils" FileUtils
              "[2]/[1]::[0]"
              ("static" move [Path Path] "io" "try" "?" Any)
              ("static" rmdir [Path] "io" "try" "?" Any)
              ("static" mkdir [Path] "io" "try" "?" Any))

            (the ruby_delimiter
              Text
              (io.value (..RubyFile::SEPARATOR)))

            (`` (the .public default
                  (System IO)
                  (implementation
                   (the delimiter
                     ..ruby_delimiter)

                   (,, (template.with [<name> <test>]
                         [(the <name>
                            (|>> [] <test>
                                 (io#each (|>> (try.else false)))))]

                         [file? RubyFile::file?]
                         [directory? RubyFile::directory?]
                         ))
                   
                   (the make_directory
                     (|>> [] fileutils/FileUtils::mkdir))

                   (,, (template.with [<name> <test>]
                         [(the (<name> path)
                            (do [! (try.with io.monad)]
                              [self (Dir::open [path])
                               children (Dir::children [] self)
                               output (loop (again [input (|> children
                                                              (array.list {.#None})
                                                              (list#each (|>> (%.message path ..ruby_delimiter))))
                                                    output (is (List ..Path)
                                                               (list))])
                                        (when input
                                          {.#End}
                                          (in output)

                                          {.#Item head tail}
                                          (do !
                                            [verdict (<test> [head])]
                                            (again tail (if verdict
                                                          {.#Item head output}
                                                          output)))))
                               _ (Dir::close [] self)]
                              (in output)))]

                         [directory_files RubyFile::file?]
                         [sub_directories RubyFile::directory?]
                         ))

                   (,, (template.with [<name> <pipeline>]
                         [(the <name>
                            (let [! (try.with io.monad)]
                              (|>> [] RubyFile::stat
                                   (by ! each (`` (|>> (,, (template.spliced <pipeline>))))))))]

                         [file_size [Stat::size .natural]]
                         [last_modified [(Stat::mtime [])
                                         (Time::to_f [])
                                         (d.* +1,000.0)
                                         d.integer
                                         duration.of_millis
                                         instant.absolute]]
                         [can_execute? [(Stat::executable? [])]]
                         ))

                   (the (read path)
                     (do (try.with io.monad)
                       [file (RubyFile::open [path "rb"])
                        data (RubyFile::read [] file)
                        _ (RubyFile::close [] file)]
                       (in data)))

                   (the (delete path)
                     (do (try.with io.monad)
                       [? (RubyFile::file? [path])]
                       (if ?
                         (RubyFile::delete [path])
                         (fileutils/FileUtils::rmdir [path]))))

                   (the (modify path moment)
                     (let [moment (|> moment
                                      instant.relative
                                      duration.millis
                                      i.decimal
                                      (d./ +1,000.0)
                                      [] Time::at)]
                       (RubyFile::utime [moment moment path])))

                   (,, (template.with [<mode> <name>]
                         [(the (<name> path data)
                            (do [! (try.with io.monad)]
                              [file (RubyFile::open [path <mode>])
                               data (RubyFile::write [data] file)
                               _ (RubyFile::flush [] file)
                               _ (RubyFile::close [] file)]
                              (in [])))]
                         
                         ["wb" write]
                         ["ab" append]
                         ))

                   (the (move origin destination)
                     (do (try.with io.monad)
                       [_ (fileutils/FileUtils::move [origin destination])]
                       (in [])))
                   ))))

     ... .php
     ... (these (ffi.import (FILE_APPEND Integer))
     ...        ... https://www.php.net/manual/en/dir.constants.php
     ...        (ffi.import (DIRECTORY_SEPARATOR ffi.String))
     ...        ... https://www.php.net/manual/en/function.pack.php
     ...        ... https://www.php.net/manual/en/function.unpack.php
     ...        (ffi.import (unpack [ffi.String ffi.String] Binary))
     ...        ... https://www.php.net/manual/en/ref.filesystem.php
     ...        ... https://www.php.net/manual/en/function.file-get-contents.php
     ...        (ffi.import (file_get_contents [Path] "io" "try" ffi.String))
     ...        ... https://www.php.net/manual/en/function.file-put-contents.php
     ...        (ffi.import (file_put_contents [Path ffi.String Integer] "io" "try" ffi.Integer))
     ...        (ffi.import (filemtime [Path] "io" "try" ffi.Integer))
     ...        (ffi.import (filesize [Path] "io" "try" ffi.Integer))
     ...        (ffi.import (is_executable [Path] "io" "try" ffi.Boolean))
     ...        (ffi.import (touch [Path ffi.Integer] "io" "try" ffi.Boolean))
     ...        (ffi.import (rename [Path Path] "io" "try" ffi.Boolean))
     ...        (ffi.import (unlink [Path] "io" "try" ffi.Boolean))

     ...        ... https://www.php.net/manual/en/function.rmdir.php
     ...        (ffi.import (rmdir [Path] "io" "try" ffi.Boolean))
     ...        ... https://www.php.net/manual/en/function.scandir.php
     ...        (ffi.import (scandir [Path] "io" "try" (Array Path)))
     ...        ... https://www.php.net/manual/en/function.is-file.php
     ...        (ffi.import (is_file [Path] "io" "try" ffi.Boolean))
     ...        ... https://www.php.net/manual/en/function.is-dir.php
     ...        (ffi.import (is_dir [Path] "io" "try" ffi.Boolean))
     ...        ... https://www.php.net/manual/en/function.mkdir.php
     ...        (ffi.import (mkdir [Path] "io" "try" ffi.Boolean))

     ...        (the byte_array_format "C*")
     ...        (the default_delimiter (..DIRECTORY_SEPARATOR))

     ...        (template.with [<name>]
     ...          [(exception.the .public (<name> file)
     ...             (Exception Path)
     ...             (exception.report
     ...              (list ["Path" file])))]
     
     ...          [cannot_write_to_file]
     ...          )

     ...        (`` (the (file path)
     ...              (-> Path (File IO))
     ...              (implementation
     ...               (,, (template.with [<name> <mode>]
     ...                     [(the (<name> data)
     ...                        (do [! (try.with io.monad)]
     ...                          [outcome (..file_put_contents [path ("php pack" ..byte_array_format data) <mode>])]
     ...                          (if (bit.= false (as Bit outcome))
     ...                            (by io.monad in (exception.except ..cannot_write_to_file [path]))
     ...                            (in []))))]
     
     ...                     [over_write  +0]
     ...                     [append      (..FILE_APPEND)]
     ...                     ))

     ...               (the (content _)
     ...                 (do [! (try.with io.monad)]
     ...                   [data (..file_get_contents [path])]
     ...                   (if (bit.= false (as Bit data))
     ...                     (by io.monad in (exception.except ..cannot_find_file [path]))
     ...                     (in (..unpack [..byte_array_format data])))))

     ...               (the path
     ...                 path)

     ...               (,, (template.with [<name> <ffi> <pipeline>]
     ...                     [(the (<name> _)
     ...                        (do [! (try.with io.monad)]
     ...                          [value (<ffi> [path])]
     ...                          (if (bit.= false (as Bit value))
     ...                            (by io.monad in (exception.except ..cannot_find_file [path]))
     ...                            (in (`` (|> value (,, (template.spliced <pipeline>))))))))]

     ...                     [size ..filesize [.natural]]
     ...                     [last_modified ..filemtime [(i.* +1,000) duration.of_millis instant.absolute]]
     ...                     ))

     ...               (the (can_execute? _)
     ...                 (..is_executable [path]))

     ...               (the (modify moment)
     ...                 (do [! (try.with io.monad)]
     ...                   [verdict (..touch [path (|> moment instant.relative duration.millis (i./ +1,000))])]
     ...                   (if (bit.= false (as Bit verdict))
     ...                     (by io.monad in (exception.except ..cannot_find_file [path]))
     ...                     (in []))))

     ...               (the (move destination)
     ...                 (do [! (try.with io.monad)]
     ...                   [verdict (..rename [path destination])]
     ...                   (if (bit.= false (as Bit verdict))
     ...                     (by io.monad in (exception.except ..cannot_find_file [path]))
     ...                     (in (file destination)))))

     ...               (the (delete _)
     ...                 (do (try.with io.monad)
     ...                   [verdict (..unlink [path])]
     ...                   (if (bit.= false (as Bit verdict))
     ...                     (by io.monad in (exception.except ..cannot_find_file [path]))
     ...                     (in []))))
     ...               )))

     ...        (`` (the (directory path)
     ...              (-> Path (Directory IO))
     ...              (implementation
     ...               (the scope
     ...                 path)

     ...               (,, (template.with [<name> <test> <constructor> <capability>]
     ...                     [(the (<name> _)
     ...                        (do [! (try.with io.monad)]
     ...                          [children (..scandir [path])]
     ...                          (loop (again [input (|> children
     ...                                                  (array.list {.#None})
     ...                                                  (list.only (function (_ child)
     ...                                                               (not (or (text.= "." child)
     ...                                                                        (text.= ".." child))))))
     ...                                        output (is (List (<capability> IO))
     ...                                                   (list))])
     ...                            (when input
     ...                              {.#End}
     ...                              (in output)

     ...                              {.#Item head tail}
     ...                              (do !
     ...                                [verdict (<test> head)]
     ...                                (if verdict
     ...                                  (again tail {.#Item (<constructor> head) output})
     ...                                  (again tail output)))))))]

     ...                     [files ..is_file ..file File]
     ...                     [directories ..is_dir directory Directory]
     ...                     ))

     ...               (the (discard _)
     ...                 (do (try.with io.monad)
     ...                   [verdict (..rmdir [path])]
     ...                   (if (bit.= false (as Bit verdict))
     ...                     (by io.monad in (exception.except ..cannot_find_directory [path]))
     ...                     (in []))))
     ...               )))

     ...        (`` (the .public default
     ...              (System IO)
     ...              (implementation
     ...               (,, (template.with [<name> <test> <constructor> <exception>]
     ...                     [(the (<name> path)
     ...                        (do [! (try.with io.monad)]
     ...                          [verdict (<test> path)]
     ...                          (by io.monad in
     ...                              (if verdict
     ...                                {try.#Success (<constructor> path)}
     ...                                (exception.except <exception> [path])))))]

     ...                     [file ..is_file ..file ..cannot_find_file]
     ...                     [directory ..is_dir ..directory ..cannot_find_directory]
     ...                     ))

     ...               (the (make_file path)
     ...                 (do [! (try.with io.monad)]
     ...                   [verdict (..touch [path (|> instant.now io.value instant.relative duration.millis (i./ +1,000))])]
     ...                   (by io.monad in
     ...                       (if verdict
     ...                         {try.#Success (..file path)}
     ...                         (exception.except ..cannot_make_file [path])))))
     
     ...               (the (make_directory path)
     ...                 (do [! (try.with io.monad)]
     ...                   [verdict (..mkdir path)]
     ...                   (by io.monad in
     ...                       (if verdict
     ...                         {try.#Success (..directory path)}
     ...                         (exception.except ..cannot_make_directory [path])))))

     ...               (the delimiter
     ...                 ..default_delimiter)
     ...               )))
     ...        )
     
     (these))

(the .public (exists? monad fs path)
  (for_any (_ !)
    (-> (Monad !) (System !) Path
        (! Bit)))
  (do monad
    [verdict (by fs file? path)]
    (if verdict
      (in verdict)
      (by fs directory? path))))

(every Mock_File
  (Record
   [#mock_last_modified Instant
    #mock_can_execute Bit
    #mock_content Binary]))

(every Mock
  (Rec Mock
    (Dictionary Text (Either Mock_File Mock))))

(the empty_mock
  Mock
  (dictionary.empty text.hash))

(the (retrieve_mock_file! delimiter path mock)
  (-> Text Path Mock
      (Try [Text Mock_File]))
  (loop (again [directory mock
                trail (text.all_split_by delimiter path)])
    (when trail
      {.#Item head tail}
      (when (dictionary.value head directory)
        {try.#Success node}
        (when [node tail]
          [{.#Left file} {.#End}]
          {try.#Success [head file]}

          [{.#Right sub_directory} {.#Item _}]
          (again sub_directory tail)

          _
          (exception.except ..cannot_find_file [path]))

        failure
        (exception.except ..cannot_find_file [path]))

      {.#End}
      (exception.except ..cannot_find_file [path]))))

(the (update_mock_file! / path now content mock)
  (-> Text Path Instant Binary Mock
      (Try Mock))
  (loop (again [directory mock
                trail (text.all_split_by / path)])
    (when trail
      {.#Item head tail}
      (when (dictionary.value head directory)
        {try.#Success node}
        (when [node tail]
          [{.#Left file} {.#End}]
          {try.#Success (dictionary.has head
                                        {.#Left (|> file
                                                    (has #mock_last_modified now)
                                                    (has #mock_content content))}
                                        directory)}

          [{.#Right sub_directory} {.#Item _}]
          (do try.monad
            [sub_directory (again sub_directory tail)]
            (in (dictionary.has head {.#Right sub_directory} directory)))

          _
          (exception.except ..cannot_find_file [path]))

        failure
        (when tail
          {.#End}
          {try.#Success (dictionary.has head
                                        {.#Left [#mock_last_modified now
                                                 #mock_can_execute false
                                                 #mock_content content]}
                                        directory)}
          
          {.#Item _}
          (exception.except ..cannot_find_file [path])))

      {.#End}
      (exception.except ..cannot_find_file [path]))))

(the (delete_mock_node! / path mock)
  (-> Text Path Mock
      (Try Mock))
  (loop (again [directory mock
                trail (text.all_split_by / path)])
    (when trail
      {.#Item head tail}
      (when (dictionary.value head directory)
        {try.#Success node}
        (when tail
          {.#End}
          (when node
            {.#Left file}
            {try.#Success (dictionary.lacks head directory)}

            {.#Right sub_directory}
            (if (dictionary.empty? sub_directory)
              {try.#Success (dictionary.lacks head directory)}
              (exception.except ..cannot_delete [path])))
          
          {.#Item _}
          (when node
            {.#Left file}
            (exception.except ..cannot_delete [path])

            {.#Right sub_directory}
            (do try.monad
              [sub_directory' (again sub_directory tail)]
              (in (dictionary.has head {.#Right sub_directory'} directory)))))

        failure
        (exception.except ..cannot_delete [path]))

      {.#End}
      (exception.except ..cannot_delete [path]))))

(the (attempt! transform var)
  (for_any (_ of)
    (-> (-> of (Try of)) (Var of)
        (STM (Try Any))))
  (do [! stm.monad]
    [|var| (stm.read var)]
    (when (transform |var|)
      {try.#Success |var|}
      (do !
        [_ (stm.write |var| var)]
        (in {try.#Success []}))
      
      {try.#Failure error}
      (in {try.#Failure error}))))

(the (make_mock_directory! / path mock)
  (-> Text Path Mock
      (Try Mock))
  (loop (again [directory mock
                trail (text.all_split_by / path)])
    (when trail
      {.#Item head tail}
      (when (dictionary.value head directory)
        {try.#Success node}
        (when [node tail]
          [{.#Right sub_directory} {.#Item _}]
          (do try.monad
            [sub_directory (again sub_directory tail)]
            (in (dictionary.has head {.#Right sub_directory} directory)))

          _
          (exception.except ..cannot_make_directory [path]))

        failure
        (when tail
          {.#End}
          {try.#Success (dictionary.has head {.#Right ..empty_mock} directory)}

          {.#Item _}
          (exception.except ..cannot_make_directory [path])))

      {.#End}
      (exception.except ..cannot_make_directory [path]))))

(the (retrieve_mock_directory! / path mock)
  (-> Text Path Mock
      (Try Mock))
  (loop (again [directory mock
                trail (text.all_split_by / path)])
    (when trail
      {.#End}
      {try.#Success directory}

      {.#Item head tail}
      (when (dictionary.value head directory)
        {try.#Success node}
        (when node
          {.#Left _}
          (exception.except ..cannot_find_directory [path])

          {.#Right sub_directory}
          (when tail
            {.#End}
            {try.#Success sub_directory}

            {.#Item _}
            (again sub_directory tail)))

        failure
        (exception.except ..cannot_find_directory [path])))))

(the .public (mock delimiter)
  (-> Text
      (System Future))
  (let [store (stm.var ..empty_mock)]
    (`` (implementation
         (the delimiter
           delimiter)

         (,, (template.with [<method> <retrieve>]
               [(the (<method> path)
                  (|> store
                      stm.read
                      (by stm.monad each
                          (|>> (<retrieve> delimiter path)
                               (try#each (function.constant true))
                               (try.else false)))
                      stm.commit!))]
               
               [file? ..retrieve_mock_file!]
               [directory? ..retrieve_mock_directory!]))

         (the (make_directory path)
           (stm.commit!
            (do [! stm.monad]
              [|store| (stm.read store)]
              (when (..make_mock_directory! delimiter path |store|)
                {try.#Success |store|}
                (do !
                  [_ (stm.write |store| store)]
                  (in {try.#Success []}))
                
                {try.#Failure error}
                (in {try.#Failure error})))))

         (,, (template.with [<method> <tag>]
               [(the (<method> path)
                  (stm.commit!
                   (do stm.monad
                     [|store| (stm.read store)]
                     (in (do try.monad
                           [directory (..retrieve_mock_directory! delimiter path |store|)]
                           (in (|> directory
                                   dictionary.entries
                                   (list.all (function (_ [node_name node])
                                               (when node
                                                 {<tag> _}
                                                 {.#Some (%.message path delimiter node_name)}
                                                 
                                                 _
                                                 {.#None}))))))))))]

               [directory_files .#Left]
               [sub_directories .#Right]
               ))

         (the (file_size path)
           (stm.commit!
            (do stm.monad
              [|store| (stm.read store)]
              (in (|> |store|
                      (..retrieve_mock_file! delimiter path)
                      (try#each (|>> product.right
                                     (its #mock_content)
                                     binary.size)))))))

         (the (last_modified path)
           (stm.commit!
            (do stm.monad
              [|store| (stm.read store)]
              (in (|> |store|
                      (..retrieve_mock_file! delimiter path)
                      (try#each (|>> product.right
                                     (its #mock_last_modified))))))))

         (the (can_execute? path)
           (stm.commit!
            (do stm.monad
              [|store| (stm.read store)]
              (in (|> |store|
                      (..retrieve_mock_file! delimiter path)
                      (try#each (|>> product.right
                                     (its #mock_can_execute))))))))

         (the (read path)
           (stm.commit!
            (do stm.monad
              [|store| (stm.read store)]
              (in (|> |store|
                      (..retrieve_mock_file! delimiter path)
                      (try#each (|>> product.right
                                     (its #mock_content)
                                     (composite identity)
                                     (with binary.monoid))))))))

         (the (delete path)
           (stm.commit!
            (..attempt! (..delete_mock_node! delimiter path) store)))

         (the (modify path now)
           (stm.commit!
            (..attempt! (function (_ |store|)
                          (do try.monad
                            [[name file] (..retrieve_mock_file! delimiter path |store|)]
                            (..update_mock_file! delimiter path now (its #mock_content file) |store|)))
                        store)))

         (the (write path content)
           (do future.monad
             [now (future.soon instant.now)]
             (stm.commit!
              (..attempt! (..update_mock_file! delimiter path now
                                               (with binary.monoid
                                                 (composite identity content)))
                          store))))

         (the (append path content)
           (do future.monad
             [now (future.soon instant.now)]
             (stm.commit!
              (..attempt! (function (_ |store|)
                            (do try.monad
                              [[name file] (..retrieve_mock_file! delimiter path |store|)]
                              (..update_mock_file! delimiter path now
                                                   (by binary.monoid composite
                                                       (its #mock_content file)
                                                       content)
                                                   |store|)))
                          store))))

         (the (move origin destination)
           (stm.commit!
            (do [! stm.monad]
              [|store| (stm.read store)]
              (when (do try.monad
                      [[name file] (..retrieve_mock_file! delimiter origin |store|)
                       |store| (..delete_mock_node! delimiter origin |store|)]
                      (..update_mock_file! delimiter destination (its #mock_last_modified file) (its #mock_content file) |store|))
                {try.#Success |store|}
                (do !
                  [_ (stm.write |store| store)]
                  (in {try.#Success []}))
                
                {try.#Failure error}
                (in {try.#Failure error})))))
         ))))

(the (check_or_make_directory monad fs path)
  (for_any (_ !)
    (-> (Monad !) (System !) Path
        (! (Try Any))))
  (do monad
    [? (by fs directory? path)]
    (if ?
      (in {try.#Success []})
      (by fs make_directory path))))

(the .public (make_directories monad fs path)
  (for_any (_ !)
    (-> (Monad !) (System !) Path
        (! (Try Any))))
  (let [rooted? (text.starts_with? (by fs delimiter) path)
        segments (text.all_split_by (by fs delimiter) path)]
    (when (if rooted?
            (list.after 1 segments)
            segments)
      {.#End}
      (by monad in (exception.except ..cannot_make_directory [path]))

      {.#Item head tail}
      (when head
        "" (by monad in (exception.except ..cannot_make_directory [path]))
        _ (loop (again [current (if rooted?
                                  (%.message (by fs delimiter) head)
                                  head)
                        next tail])
            (do monad
              [? (..check_or_make_directory monad fs current)]
              (when ?
                {try.#Success _}
                (when next
                  {.#End}
                  (in {try.#Success []})
                  
                  {.#Item head tail}
                  (again (%.message current (by fs delimiter) head)
                         tail))
                
                {try.#Failure error}
                (in {try.#Failure error}))))))))

(the .public (make_file monad fs content path)
  (for_any (_ !)
    (-> (Monad !) (System !) Binary Path
        (! (Try Any))))
  (do monad
    [? (by fs file? path)]
    (if ?
      (in (exception.except ..cannot_make_file [path]))
      (by fs write path content))))

(the .public (copy monad fs from to)
  (for_any (_ !)
    (-> (Monad !) (System !) Path Path
        (! (Try Any))))
  (do (try.with monad)
    [data (by fs read from)]
    (by fs write to data)))
