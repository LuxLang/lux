(.module:
  [library
   [lux #*
    ["@" target]
    ["." ffi]
    [abstract
     ["." monad (#+ Monad do)]]
    [control
     [pipe (#+ case>)]
     ["." try (#+ Try) ("#\." functor)]
     ["." exception (#+ exception:)]
     ["." io (#+ IO) ("#\." functor)]
     ["." function]
     [concurrency
      ["." async (#+ Async)]
      ["." stm (#+ Var STM)]]]
    [data
     ["." bit ("#\." equivalence)]
     ["." product]
     ["." maybe ("#\." functor)]
     ["." binary (#+ Binary)]
     ["." text ("#\." equivalence)
      ["%" format (#+ format)]]
     [collection
      ["." array (#+ Array)]
      ["." list ("#\." functor)]
      ["." dictionary (#+ Dictionary)]]]
    [macro
     ["." template]]
    [math
     [number
      ["i" int]
      ["f" frac]]]
    [time
     ["." instant (#+ Instant)]
     ["." duration]]]])

(type: #export Path
  Text)

(`` (interface: #export (System !)
      (: Text
         separator)

      (~~ (template [<name> <output>]
            [(: (-> Path (! <output>))
                <name>)]

            [file? Bit]
            [directory? Bit]
            ))

      (~~ (template [<name> <output>]
            [(: (-> Path (! (Try <output>)))
                <name>)]

            [make_directory  Any]
            [directory_files (List Path)]
            [sub_directories (List Path)]
            
            [file_size     Nat]
            [last_modified Instant]
            [can_execute?  Bit]
            [read          Binary]
            [delete        Any]
            ))

      (~~ (template [<name> <input>]
            [(: (-> <input> Path (! (Try Any)))
                <name>)]

            [modify Instant]
            [write  Binary]
            [append Binary]
            [move   Path]
            ))
      ))

(def: #export (un_nest fs path)
  (All [!] (-> (System !) Path (Maybe [Path Text])))
  (let [/ (\ fs separator)]
    (case (text.last_index_of / path)
      #.None
      #.None
      
      (#.Some last_separator)
      (do maybe.monad
        [[parent temp] (text.split last_separator path)
         [_ child] (text.split (text.size /) temp)]
        (in [parent child])))))

(def: #export (parent fs path)
  (All [!] (-> (System !) Path (Maybe Path)))
  (|> (..un_nest fs path)
      (maybe\map product.left)))

(def: #export (name fs path)
  (All [!] (-> (System !) Path Text))
  (|> (..un_nest fs path)
      (maybe\map product.right)
      (maybe.default path)))

(def: #export (async fs)
  (-> (System IO) (System Async))
  (`` (implementation
       (def: separator
         (\ fs separator))

       (~~ (template [<name>]
             [(def: <name>
                (|>> (\ fs <name>)
                     async.future))]

             [file?]
             [directory?]
             
             [make_directory]
             [directory_files]
             [sub_directories]
             
             [file_size]
             [last_modified]
             [can_execute?]
             [read]
             [delete]))

       (~~ (template [<name>]
             [(def: (<name> input path)
                (async.future (\ fs <name> input path)))]

             [modify]
             [write]
             [append]
             [move]))
       )))

(def: #export (nest fs parent child)
  (All [!] (-> (System !) Path Text Path))
  (format parent (\ fs separator) child))

(template [<name>]
  [(exception: #export (<name> {file Path})
     (exception.report
      ["Path" file]))]

  [cannot_make_file]
  [cannot_find_file]
  [cannot_delete]

  [cannot_make_directory]
  [cannot_find_directory]
  
  [cannot_read_all_data]
  )

(with_expansions [<for_jvm> (as_is (exception: #export (cannot_modify_file {instant Instant} {file Path})
                                     (exception.report
                                      ["Instant" (%.instant instant)]
                                      ["Path" file]))

                                   (ffi.import: java/lang/String)

                                   (`` (ffi.import: java/io/File
                                         ["#::."
                                          (new [java/lang/String])
                                          (~~ (template [<name>]
                                                [(<name> [] #io #try boolean)]

                                                [createNewFile] [mkdir]
                                                [delete]
                                                [isFile] [isDirectory]
                                                [canRead] [canWrite] [canExecute]))

                                          (length [] #io #try long)
                                          (listFiles [] #io #try #? [java/io/File])
                                          (getAbsolutePath [] #io #try java/lang/String)
                                          (renameTo [java/io/File] #io #try boolean)
                                          (lastModified [] #io #try long)
                                          (setLastModified [long] #io #try boolean)
                                          (#static separator java/lang/String)]))

                                   (ffi.import: java/lang/AutoCloseable
                                     ["#::."
                                      (close [] #io #try void)])

                                   (ffi.import: java/io/OutputStream
                                     ["#::."
                                      (write [[byte]] #io #try void)
                                      (flush [] #io #try void)])

                                   (ffi.import: java/io/FileOutputStream
                                     ["#::."
                                      (new [java/io/File boolean] #io #try)])

                                   (ffi.import: java/io/InputStream
                                     ["#::."
                                      (read [[byte]] #io #try int)])

                                   (ffi.import: java/io/FileInputStream
                                     ["#::."
                                      (new [java/io/File] #io #try)])

                                   (`` (implementation: #export default
                                         (System IO)

                                         (def: separator
                                           (java/io/File::separator))

                                         (~~ (template [<name> <method>]
                                               [(def: <name>
                                                  (|>> java/io/File::new
                                                       <method>
                                                       (io\map (|>> (try.default false)))))]

                                               [file? java/io/File::isFile]
                                               [directory? java/io/File::isDirectory]
                                               ))

                                         (def: (make_directory path)
                                           (|> path
                                               java/io/File::new
                                               java/io/File::mkdir))

                                         (~~ (template [<name> <method>]
                                               [(def: (<name> path)
                                                  (do {! (try.with io.monad)}
                                                    [?children (java/io/File::listFiles (java/io/File::new path))]
                                                    (case ?children
                                                      (#.Some children)
                                                      (|> children
                                                          array.to_list
                                                          (monad.only ! (|>> <method>))
                                                          (\ ! map (monad.map ! (|>> java/io/File::getAbsolutePath)))
                                                          (\ ! join))

                                                      #.None
                                                      (\ io.monad in (exception.except ..cannot_find_directory [path])))))]

                                               [directory_files java/io/File::isFile]
                                               [sub_directories java/io/File::isDirectory]
                                               ))

                                         (def: file_size
                                           (|>> java/io/File::new
                                                java/io/File::length
                                                (\ (try.with io.monad) map .nat)))

                                         (def: last_modified
                                           (|>> java/io/File::new
                                                (java/io/File::lastModified)
                                                (\ (try.with io.monad) map (|>> duration.of_millis instant.absolute))))

                                         (def: can_execute?
                                           (|>> java/io/File::new
                                                java/io/File::canExecute))

                                         (def: (read path)
                                           (do (try.with io.monad)
                                             [#let [file (java/io/File::new path)]
                                              size (java/io/File::length file)
                                              #let [data (binary.create (.nat size))]
                                              stream (java/io/FileInputStream::new file)
                                              bytes_read (java/io/InputStream::read data stream)
                                              _ (java/lang/AutoCloseable::close stream)]
                                             (if (i.= size bytes_read)
                                               (in data)
                                               (\ io.monad in (exception.except ..cannot_read_all_data path)))))

                                         (def: (delete path)
                                           (|> path
                                               java/io/File::new
                                               java/io/File::delete))

                                         (def: (modify time_stamp path)
                                           (|> path
                                               java/io/File::new
                                               (java/io/File::setLastModified (|> time_stamp instant.relative duration.to_millis))))
                                         
                                         (~~ (template [<name> <flag>]
                                               [(def: (<name> data path)
                                                  (do (try.with io.monad)
                                                    [stream (java/io/FileOutputStream::new (java/io/File::new path) <flag>)
                                                     _ (java/io/OutputStream::write data stream)
                                                     _ (java/io/OutputStream::flush stream)]
                                                    (java/lang/AutoCloseable::close stream)))]

                                               [write #0]
                                               [append #1]
                                               ))

                                         (def: (move destination origin)
                                           (|> origin
                                               java/io/File::new
                                               (java/io/File::renameTo (java/io/File::new destination))))
                                         )))]
  (for {@.old (as_is <for_jvm>)
        @.jvm (as_is <for_jvm>)

        @.js
        (as_is (ffi.import: Buffer
                 ["#::."
                  (#static from [Binary] ..Buffer)])
               
               (ffi.import: FileDescriptor)

               (ffi.import: Stats
                 ["#::."
                  (size ffi.Number)
                  (mtimeMs ffi.Number)
                  (isFile [] ffi.Boolean)
                  (isDirectory [] ffi.Boolean)])

               (ffi.import: FsConstants
                 ["#::."
                  (F_OK ffi.Number)
                  (R_OK ffi.Number)
                  (W_OK ffi.Number)
                  (X_OK ffi.Number)])

               (ffi.import: Error
                 ["#::."
                  (toString [] ffi.String)])

               (template: (with_async <write> <type> <body>)
                 (template.with_locals [<read>]
                   (let [[<read> <write>] (: [(Async <type>) (async.Resolver <type>)]
                                             (async.async []))]
                     (exec
                       <body>
                       <read>))))
               
               (ffi.import: Fs
                 ["#::."
                  (constants FsConstants)
                  (readFile [ffi.String ffi.Function] Any)
                  (appendFile [ffi.String Buffer ffi.Function] Any)
                  (writeFile [ffi.String Buffer ffi.Function] Any)
                  (stat [ffi.String ffi.Function] Any)
                  (access [ffi.String ffi.Number ffi.Function] Any)
                  (rename [ffi.String ffi.String ffi.Function] Any)
                  (utimes [ffi.String ffi.Number ffi.Number ffi.Function] Any)
                  (readdir [ffi.String ffi.Function] Any)
                  (mkdir [ffi.String ffi.Function] Any)
                  (unlink [ffi.String ffi.Function] Any)
                  (rmdir [ffi.String ffi.Function] Any)])

               (def: (any_callback write!)
                 (-> (async.Resolver (Try Any)) ffi.Function)
                 (<| (ffi.closure [error])
                     io.run
                     write!
                     (if (ffi.null? error)
                       (#try.Success [])
                       (#try.Failure (Error::toString [] (:as Error error))))))

               (def: (value_callback write!)
                 (All [a] (-> (async.Resolver (Try a)) ffi.Function))
                 (<| (ffi.closure [error datum])
                     io.run
                     write!
                     (if (ffi.null? error)
                       (#try.Success (:assume datum))
                       (#try.Failure (Error::toString [] (:as Error error))))))

               (ffi.import: JsPath
                 ["#::."
                  (sep ffi.String)])
               
               (template [<name> <path>]
                 [(def: (<name> _)
                    (-> [] (Maybe (-> ffi.String Any)))
                    (ffi.constant (-> ffi.String Any) <path>))]

                 [normal_require [require]]
                 [global_require [global require]]
                 [process_load [global process mainModule constructor _load]]
                 )

               (def: (require _)
                 (-> [] (-> ffi.String Any))
                 (case [(normal_require []) (global_require []) (process_load [])]
                   (^or [(#.Some require) _ _]
                        [_ (#.Some require) _]
                        [_ _ (#.Some require)])
                   require

                   _
                   (undefined)))

               (template [<name> <module> <type>]
                 [(def: (<name> _)
                    (-> [] <type>)
                    (:as <type> (..require [] <module>)))]

                 [node_fs   "fs"   ..Fs]
                 [node_path "path" ..JsPath]
                 )

               (def: js_separator
                 (if ffi.on_node_js?
                   (JsPath::sep (..node_path []))
                   "/"))

               (`` (implementation: #export default
                     (System Async)
                     
                     (def: separator
                       ..js_separator)

                     (~~ (template [<name> <method>]
                           [(def: (<name> path)
                              (do async.monad
                                [?stats (with_async write! (Try Stats)
                                          (Fs::stat [path (..value_callback write!)]
                                                    (..node_fs [])))]
                                (in (case ?stats
                                      (#try.Success stats)
                                      (<method> [] stats)
                                      
                                      (#try.Failure _)
                                      false))))]

                           [file?      Stats::isFile]
                           [directory? Stats::isDirectory]
                           ))

                     (def: (make_directory path)
                       (do async.monad
                         [#let [node_fs (..node_fs [])]
                          outcome (with_async write! (Try Any)
                                    (Fs::access [path
                                                 (|> node_fs Fs::constants FsConstants::F_OK)
                                                 (..any_callback write!)]
                                                node_fs))]
                         (case outcome
                           (#try.Success _)
                           (in (exception.except ..cannot_make_directory [path]))
                           
                           (#try.Failure _)
                           (with_async write! (Try Any)
                             (Fs::mkdir [path (..any_callback write!)] node_fs)))))

                     (~~ (template [<name> <method>]
                           [(def: (<name> path)
                              (do {! (try.with async.monad)}
                                [#let [node_fs (..node_fs [])]
                                 subs (with_async write! (Try (Array ffi.String))
                                        (Fs::readdir [path (..value_callback write!)] node_fs))]
                                (|> subs
                                    array.to_list
                                    (list\map (|>> (format path ..js_separator)))
                                    (monad.map ! (function (_ sub)
                                                   (\ ! map (|>> (<method> []) [sub])
                                                      (with_async write! (Try Stats)
                                                        (Fs::stat [sub (..value_callback write!)] node_fs)))))
                                    (\ ! map (|>> (list.only product.right)
                                                  (list\map product.left))))))]

                           [directory_files Stats::isFile]
                           [sub_directories Stats::isDirectory]
                           ))

                     (def: (file_size path)
                       (do (try.with async.monad)
                         [stats (with_async write! (Try Stats)
                                  (Fs::stat [path (..value_callback write!)]
                                            (..node_fs [])))]
                         (in (|> stats
                                 Stats::size
                                 f.nat))))

                     (def: (last_modified path)
                       (do (try.with async.monad)
                         [stats (with_async write! (Try Stats)
                                  (Fs::stat [path (..value_callback write!)]
                                            (..node_fs [])))]
                         (in (|> stats
                                 Stats::mtimeMs
                                 f.int
                                 duration.of_millis
                                 instant.absolute))))

                     (def: (can_execute? path)
                       (let [node_fs (..node_fs [])]
                         (\ async.monad map
                            (|>> (case> (#try.Success _)
                                        true

                                        (#try.Failure _)
                                        false)
                                 #try.Success)
                            (with_async write! (Try Any)
                              (Fs::access [path
                                           (|> node_fs Fs::constants FsConstants::X_OK)
                                           (..any_callback write!)]
                                          node_fs)))))

                     (def: (read path)
                       (with_async write! (Try Binary)
                         (Fs::readFile [path (..value_callback write!)]
                                       (..node_fs []))))

                     (def: (delete path)
                       (do (try.with async.monad)
                         [#let [node_fs (..node_fs [])]
                          stats (with_async write! (Try Stats)
                                  (Fs::stat [path (..value_callback write!)] node_fs))]
                         (with_async write! (Try Any)
                           (if (Stats::isFile [] stats)
                             (Fs::unlink [path (..any_callback write!)] node_fs)
                             (Fs::rmdir [path (..any_callback write!)] node_fs)))))

                     (def: (modify time_stamp path)
                       (with_async write! (Try Any)
                         (let [when (|> time_stamp instant.relative duration.to_millis i.frac)]
                           (Fs::utimes [path when when (..any_callback write!)]
                                       (..node_fs [])))))

                     (~~ (template [<name> <method>]
                           [(def: (<name> data path)
                              (with_async write! (Try Any)
                                (<method> [path (Buffer::from data) (..any_callback write!)]
                                          (..node_fs []))))]

                           [write  Fs::writeFile]
                           [append Fs::appendFile]
                           ))

                     (def: (move destination origin)
                       (with_async write! (Try Any)
                         (Fs::rename [origin destination (..any_callback write!)]
                                     (..node_fs []))))
                     )))

        @.python
        (as_is (type: (Tuple/2 left right)
                 (primitive "python_tuple[2]" [left right]))

               (ffi.import: PyFile
                 ["#::."
                  (read [] #io #try Binary)
                  (write [Binary] #io #try #? Any)
                  (close [] #io #try #? Any)])

               (ffi.import: (open [ffi.String ffi.String] #io #try PyFile))
               (ffi.import: (tuple [[ffi.Integer ffi.Integer]] (Tuple/2 ffi.Integer ffi.Integer)))

               (ffi.import: os
                 ["#::."
                  (#static F_OK ffi.Integer)
                  (#static R_OK ffi.Integer)
                  (#static W_OK ffi.Integer)
                  (#static X_OK ffi.Integer)

                  (#static mkdir [ffi.String] #io #try #? Any)
                  (#static access [ffi.String ffi.Integer] #io #try ffi.Boolean)
                  (#static remove [ffi.String] #io #try #? Any)
                  (#static rmdir [ffi.String] #io #try #? Any)
                  (#static rename [ffi.String ffi.String] #io #try #? Any)
                  (#static utime [ffi.String (Tuple/2 ffi.Integer ffi.Integer)] #io #try #? Any)
                  (#static listdir [ffi.String] #io #try (Array ffi.String))])

               (ffi.import: os/path
                 ["#::."
                  (#static isfile [ffi.String] #io #try ffi.Boolean)
                  (#static isdir [ffi.String] #io #try ffi.Boolean)
                  (#static sep ffi.String)
                  (#static getsize [ffi.String] #io #try ffi.Integer)
                  (#static getmtime [ffi.String] #io #try ffi.Float)])

               (def: python_separator
                 (os/path::sep))

               (`` (implementation: #export default
                     (System IO)
                     
                     (def: separator
                       ..python_separator)

                     (~~ (template [<name> <method>]
                           [(def: <name>
                              (|>> <method>
                                   (io\map (|>> (try.default false)))))]

                           [file?      os/path::isfile]
                           [directory? os/path::isdir]
                           ))

                     (def: make_directory
                       os::mkdir)

                     (~~ (template [<name> <method>]
                           [(def: (<name> path)
                              (let [! (try.with io.monad)]
                                (|> path
                                    os::listdir
                                    (\ ! map (|>> array.to_list
                                                  (list\map (|>> (format path ..python_separator)))
                                                  (monad.map ! (function (_ sub)
                                                                 (\ ! map (|>> [sub]) (<method> [sub]))))
                                                  (\ ! map (|>> (list.only product.right)
                                                                (list\map product.left)))))
                                    (\ ! join))))]

                           [directory_files os/path::isfile]
                           [sub_directories os/path::isdir]
                           ))

                     (def: file_size
                       (|>> os/path::getsize
                            (\ (try.with io.monad) map .nat)))

                     (def: last_modified
                       (|>> os/path::getmtime
                            (\ (try.with io.monad) map (|>> f.int
                                                            (i.* +1,000)
                                                            duration.of_millis
                                                            instant.absolute))))

                     (def: (can_execute? path)
                       (os::access [path (os::X_OK)]))

                     (def: (read path)
                       (do (try.with io.monad)
                         [file (..open [path "rb"])
                          data (PyFile::read [] file)
                          _ (PyFile::close [] file)]
                         (in data)))

                     (def: (delete path)
                       (do (try.with io.monad)
                         [? (os/path::isfile [path])]
                         (if ?
                           (os::remove [path])
                           (os::rmdir [path]))))

                     (def: (modify time_stamp path)
                       (let [when (|> time_stamp instant.relative duration.to_millis (i./ +1,000))]
                         (os::utime [path (..tuple [when when])])))

                     (~~ (template [<name> <mode>]
                           [(def: (<name> data path)
                              (do (try.with io.monad)
                                [file (..open [path <mode>])
                                 _ (PyFile::write [data] file)]
                                (PyFile::close [] file)))]
                           
                           [write  "w+b"]
                           [append "ab"]
                           ))

                     (def: (move destination origin)
                       (os::rename [origin destination]))
                     )))

        @.ruby
        (as_is (ffi.import: Time #as RubyTime
                 ["#::."
                  (#static at [Frac] RubyTime)
                  (to_f [] Frac)])

               (ffi.import: Stat #as RubyStat
                 ["#::."
                  (executable? [] Bit)
                  (size Int)
                  (mtime [] RubyTime)])

               (ffi.import: File #as RubyFile
                 ["#::."
                  (#static SEPARATOR ffi.String)
                  (#static open [Path ffi.String] #io #try RubyFile)
                  (#static stat [Path] #io #try RubyStat)
                  (#static delete [Path] #io #try Int)
                  (#static file? [Path] #io #try Bit)
                  (#static directory? [Path] #io #try Bit)
                  (#static utime [RubyTime RubyTime Path] #io #try Int)

                  (read [] #io #try Binary)
                  (write [Binary] #io #try Int)
                  (flush [] #io #try #? Any)
                  (close [] #io #try #? Any)])

               (ffi.import: Dir #as RubyDir
                 ["#::."
                  (#static open [Path] #io #try RubyDir)
                  
                  (children [] #io #try (Array Path))
                  (close [] #io #try #? Any)])

               (ffi.import: "fileutils" FileUtils #as RubyFileUtils
                 ["#::."
                  (#static move [Path Path] #io #try #? Any)
                  (#static rmdir [Path] #io #try #? Any)
                  (#static mkdir [Path] #io #try #? Any)])

               (def: ruby_separator
                 Text
                 (..RubyFile::SEPARATOR))

               (`` (implementation: #export default
                     (System IO)

                     (def: separator
                       ..ruby_separator)

                     (~~ (template [<name> <test>]
                           [(def: <name>
                              (|>> <test>
                                   (io\map (|>> (try.default false)))))]

                           [file? RubyFile::file?]
                           [directory? RubyFile::directory?]
                           ))
                     
                     (def: make_directory
                       RubyFileUtils::mkdir)

                     (~~ (template [<name> <test>]
                           [(def: (<name> path)
                              (do {! (try.with io.monad)}
                                [self (RubyDir::open [path])
                                 children (RubyDir::children [] self)
                                 output (loop [input (|> children
                                                         array.to_list
                                                         (list\map (|>> (format path ..ruby_separator))))
                                               output (: (List ..Path)
                                                         (list))]
                                          (case input
                                            #.End
                                            (in output)

                                            (#.Item head tail)
                                            (do !
                                              [verdict (<test> head)]
                                              (recur tail (if verdict
                                                            (#.Item head output)
                                                            output)))))
                                 _ (RubyDir::close [] self)]
                                (in output)))]

                           [directory_files RubyFile::file?]
                           [sub_directories RubyFile::directory?]
                           ))

                     (~~ (template [<name> <pipeline>]
                           [(def: <name>
                              (let [! (try.with io.monad)]
                                (|>> RubyFile::stat
                                     (\ ! map (`` (|>> (~~ (template.spliced <pipeline>))))))))]

                           [file_size [RubyStat::size .nat]]
                           [last_modified [(RubyStat::mtime [])
                                           (RubyTime::to_f [])
                                           (f.* +1,000.0)
                                           f.int
                                           duration.of_millis
                                           instant.absolute]]
                           [can_execute? [(RubyStat::executable? [])]]
                           ))

                     (def: (read path)
                       (do (try.with io.monad)
                         [file (RubyFile::open [path "rb"])
                          data (RubyFile::read [] file)
                          _ (RubyFile::close [] file)]
                         (in data)))

                     (def: (delete path)
                       (do (try.with io.monad)
                         [? (RubyFile::file? path)]
                         (if ?
                           (RubyFile::delete [path])
                           (RubyFileUtils::rmdir [path]))))

                     (def: (modify moment path)
                       (let [moment (|> moment
                                        instant.relative
                                        duration.to_millis
                                        i.frac
                                        (f./ +1,000.0)
                                        RubyTime::at)]
                         (RubyFile::utime [moment moment path])))

                     (~~ (template [<mode> <name>]
                           [(def: (<name> data path)
                              (do {! (try.with io.monad)}
                                [file (RubyFile::open [path <mode>])
                                 data (RubyFile::write [data] file)
                                 _ (RubyFile::flush [] file)
                                 _ (RubyFile::close [] file)]
                                (in [])))]
                           
                           ["wb" write]
                           ["ab" append]
                           ))

                     (def: (move destination origin)
                       (do (try.with io.monad)
                         [_ (RubyFileUtils::move [origin destination])]
                         (in [])))
                     )))

        ## @.php
        ## (as_is (ffi.import: (FILE_APPEND Int))
        ##        ## https://www.php.net/manual/en/dir.constants.php
        ##        (ffi.import: (DIRECTORY_SEPARATOR ffi.String))
        ##        ## https://www.php.net/manual/en/function.pack.php
        ##        ## https://www.php.net/manual/en/function.unpack.php
        ##        (ffi.import: (unpack [ffi.String ffi.String] Binary))
        ##        ## https://www.php.net/manual/en/ref.filesystem.php
        ##        ## https://www.php.net/manual/en/function.file-get-contents.php
        ##        (ffi.import: (file_get_contents [Path] #io #try ffi.String))
        ##        ## https://www.php.net/manual/en/function.file-put-contents.php
        ##        (ffi.import: (file_put_contents [Path ffi.String Int] #io #try ffi.Integer))
        ##        (ffi.import: (filemtime [Path] #io #try ffi.Integer))
        ##        (ffi.import: (filesize [Path] #io #try ffi.Integer))
        ##        (ffi.import: (is_executable [Path] #io #try ffi.Boolean))
        ##        (ffi.import: (touch [Path ffi.Integer] #io #try ffi.Boolean))
        ##        (ffi.import: (rename [Path Path] #io #try ffi.Boolean))
        ##        (ffi.import: (unlink [Path] #io #try ffi.Boolean))

        ##        ## https://www.php.net/manual/en/function.rmdir.php
        ##        (ffi.import: (rmdir [Path] #io #try ffi.Boolean))
        ##        ## https://www.php.net/manual/en/function.scandir.php
        ##        (ffi.import: (scandir [Path] #io #try (Array Path)))
        ##        ## https://www.php.net/manual/en/function.is-file.php
        ##        (ffi.import: (is_file [Path] #io #try ffi.Boolean))
        ##        ## https://www.php.net/manual/en/function.is-dir.php
        ##        (ffi.import: (is_dir [Path] #io #try ffi.Boolean))
        ##        ## https://www.php.net/manual/en/function.mkdir.php
        ##        (ffi.import: (mkdir [Path] #io #try ffi.Boolean))

        ##        (def: byte_array_format "C*")
        ##        (def: default_separator (..DIRECTORY_SEPARATOR))

        ##        (template [<name>]
        ##          [(exception: #export (<name> {file Path})
        ##             (exception.report
        ##              ["Path" file]))]

        ##          [cannot_write_to_file]
        ##          )

        ##        (`` (implementation: (file path)
        ##              (-> Path (File IO))

        ##              (~~ (template [<name> <mode>]
        ##                    [(def: (<name> data)
        ##                       (do {! (try.with io.monad)}
        ##                         [outcome (..file_put_contents [path ("php pack" ..byte_array_format data) <mode>])]
        ##                         (if (bit\= false (:as Bit outcome))
        ##                           (\ io.monad in (exception.except ..cannot_write_to_file [path]))
        ##                           (in []))))]
        
        ##                    [over_write  +0]
        ##                    [append      (..FILE_APPEND)]
        ##                    ))

        ##              (def: (content _)
        ##                (do {! (try.with io.monad)}
        ##                  [data (..file_get_contents [path])]
        ##                  (if (bit\= false (:as Bit data))
        ##                    (\ io.monad in (exception.except ..cannot_find_file [path]))
        ##                    (in (..unpack [..byte_array_format data])))))

        ##              (def: path
        ##                path)

        ##              (~~ (template [<name> <ffi> <pipeline>]
        ##                    [(def: (<name> _)
        ##                       (do {! (try.with io.monad)}
        ##                         [value (<ffi> [path])]
        ##                         (if (bit\= false (:as Bit value))
        ##                           (\ io.monad in (exception.except ..cannot_find_file [path]))
        ##                           (in (`` (|> value (~~ (template.spliced <pipeline>))))))))]

        ##                    [size ..filesize [.nat]]
        ##                    [last_modified ..filemtime [(i.* +1,000) duration.of_millis instant.absolute]]
        ##                    ))

        ##              (def: (can_execute? _)
        ##                (..is_executable [path]))

        ##              (def: (modify moment)
        ##                (do {! (try.with io.monad)}
        ##                  [verdict (..touch [path (|> moment instant.relative duration.to_millis (i./ +1,000))])]
        ##                  (if (bit\= false (:as Bit verdict))
        ##                    (\ io.monad in (exception.except ..cannot_find_file [path]))
        ##                    (in []))))

        ##              (def: (move destination)
        ##                (do {! (try.with io.monad)}
        ##                  [verdict (..rename [path destination])]
        ##                  (if (bit\= false (:as Bit verdict))
        ##                    (\ io.monad in (exception.except ..cannot_find_file [path]))
        ##                    (in (file destination)))))

        ##              (def: (delete _)
        ##                (do (try.with io.monad)
        ##                  [verdict (..unlink [path])]
        ##                  (if (bit\= false (:as Bit verdict))
        ##                    (\ io.monad in (exception.except ..cannot_find_file [path]))
        ##                    (in []))))
        ##              ))

        ##        (`` (implementation: (directory path)
        ##              (-> Path (Directory IO))

        ##              (def: scope
        ##                path)

        ##              (~~ (template [<name> <test> <constructor> <capability>]
        ##                    [(def: (<name> _)
        ##                       (do {! (try.with io.monad)}
        ##                         [children (..scandir [path])]
        ##                         (loop [input (|> children
        ##                                          array.to_list
        ##                                          (list.only (function (_ child)
        ##                                                         (not (or (text\= "." child)
        ##                                                                  (text\= ".." child))))))
        ##                                output (: (List (<capability> IO))
        ##                                          (list))]
        ##                           (case input
        ##                             #.End
        ##                             (in output)

        ##                             (#.Item head tail)
        ##                             (do !
        ##                               [verdict (<test> head)]
        ##                               (if verdict
        ##                                 (recur tail (#.Item (<constructor> head) output))
        ##                                 (recur tail output)))))))]

        ##                    [files ..is_file ..file File]
        ##                    [directories ..is_dir directory Directory]
        ##                    ))

        ##              (def: (discard _)
        ##                (do (try.with io.monad)
        ##                  [verdict (..rmdir [path])]
        ##                  (if (bit\= false (:as Bit verdict))
        ##                    (\ io.monad in (exception.except ..cannot_find_directory [path]))
        ##                    (in []))))
        ##              ))

        ##        (`` (implementation: #export default
        ##              (System IO)

        ##              (~~ (template [<name> <test> <constructor> <exception>]
        ##                    [(def: (<name> path)
        ##                       (do {! (try.with io.monad)}
        ##                         [verdict (<test> path)]
        ##                         (\ io.monad in
        ##                            (if verdict
        ##                              (#try.Success (<constructor> path))
        ##                              (exception.except <exception> [path])))))]

        ##                    [file ..is_file ..file ..cannot_find_file]
        ##                    [directory ..is_dir ..directory ..cannot_find_directory]
        ##                    ))

        ##              (def: (make_file path)
        ##                (do {! (try.with io.monad)}
        ##                  [verdict (..touch [path (|> instant.now io.run instant.relative duration.to_millis (i./ +1,000))])]
        ##                  (\ io.monad in
        ##                     (if verdict
        ##                       (#try.Success (..file path))
        ##                       (exception.except ..cannot_make_file [path])))))
        
        ##              (def: (make_directory path)
        ##                (do {! (try.with io.monad)}
        ##                  [verdict (..mkdir path)]
        ##                  (\ io.monad in
        ##                     (if verdict
        ##                       (#try.Success (..directory path))
        ##                       (exception.except ..cannot_make_directory [path])))))

        ##              (def: separator
        ##                ..default_separator)
        ##              ))
        ##        )
        }
       (as_is)))

(def: #export (exists? monad fs path)
  (All [!] (-> (Monad !) (System !) Path (! Bit)))
  (do monad
    [verdict (\ fs file? path)]
    (if verdict
      (in verdict)
      (\ fs directory? path))))

(type: Mock_File
  {#mock_last_modified Instant
   #mock_can_execute Bit
   #mock_content Binary})

(type: #rec Mock
  (Dictionary Text (Either Mock_File Mock)))

(def: empty_mock
  Mock
  (dictionary.new text.hash))

(def: (retrieve_mock_file! separator path mock)
  (-> Text Path Mock (Try [Text Mock_File]))
  (loop [directory mock
         trail (text.split_all_with separator path)]
    (case trail
      (#.Item head tail)
      (case (dictionary.get head directory)
        #.None
        (exception.except ..cannot_find_file [path])
        
        (#.Some node)
        (case [node tail]
          [(#.Left file) #.End]
          (#try.Success [head file])

          [(#.Right sub_directory) (#.Item _)]
          (recur sub_directory tail)

          _
          (exception.except ..cannot_find_file [path])))

      #.End
      (exception.except ..cannot_find_file [path]))))

(def: (update_mock_file! / path now content mock)
  (-> Text Path Instant Binary Mock (Try Mock))
  (loop [directory mock
         trail (text.split_all_with / path)]
    (case trail
      (#.Item head tail)
      (case (dictionary.get head directory)
        #.None
        (case tail
          #.End
          (#try.Success (dictionary.put head
                                        (#.Left {#mock_last_modified now
                                                 #mock_can_execute false
                                                 #mock_content content})
                                        directory))
          
          (#.Item _)
          (exception.except ..cannot_find_file [path]))
        
        (#.Some node)
        (case [node tail]
          [(#.Left file) #.End]
          (#try.Success (dictionary.put head
                                        (#.Left (|> file
                                                    (set@ #mock_last_modified now)
                                                    (set@ #mock_content content)))
                                        directory))

          [(#.Right sub_directory) (#.Item _)]
          (do try.monad
            [sub_directory (recur sub_directory tail)]
            (in (dictionary.put head (#.Right sub_directory) directory)))

          _
          (exception.except ..cannot_find_file [path])))

      #.End
      (exception.except ..cannot_find_file [path]))))

(def: (mock_delete! / path mock)
  (-> Text Path Mock (Try Mock))
  (loop [directory mock
         trail (text.split_all_with / path)]
    (case trail
      (#.Item head tail)
      (case (dictionary.get head directory)
        #.None
        (exception.except ..cannot_delete [path])
        
        (#.Some node)
        (case tail
          #.End
          (case node
            (#.Left file)
            (#try.Success (dictionary.remove head directory))

            (#.Right sub_directory)
            (if (dictionary.empty? sub_directory)
              (#try.Success (dictionary.remove head directory))
              (exception.except ..cannot_delete [path])))
          
          (#.Item _)
          (case node
            (#.Left file)
            (exception.except ..cannot_delete [path])

            (#.Right sub_directory)
            (do try.monad
              [sub_directory' (recur sub_directory tail)]
              (in (dictionary.put head (#.Right sub_directory') directory))))))

      #.End
      (exception.except ..cannot_delete [path]))))

(def: (try_update! transform var)
  (All [a] (-> (-> a (Try a)) (Var a) (STM (Try Any))))
  (do {! stm.monad}
    [|var| (stm.read var)]
    (case (transform |var|)
      (#try.Success |var|)
      (do !
        [_ (stm.write |var| var)]
        (in (#try.Success [])))
      
      (#try.Failure error)
      (in (#try.Failure error)))))

(def: (make_mock_directory! / path mock)
  (-> Text Path Mock (Try Mock))
  (loop [directory mock
         trail (text.split_all_with / path)]
    (case trail
      (#.Item head tail)
      (case (dictionary.get head directory)
        #.None
        (case tail
          #.End
          (#try.Success (dictionary.put head (#.Right ..empty_mock) directory))

          (#.Item _)
          (exception.except ..cannot_make_directory [path]))
        
        (#.Some node)
        (case [node tail]
          [(#.Right sub_directory) (#.Item _)]
          (do try.monad
            [sub_directory (recur sub_directory tail)]
            (in (dictionary.put head (#.Right sub_directory) directory)))

          _
          (exception.except ..cannot_make_directory [path])))

      #.End
      (exception.except ..cannot_make_directory [path]))))

(def: (retrieve_mock_directory! / path mock)
  (-> Text Path Mock (Try Mock))
  (loop [directory mock
         trail (text.split_all_with / path)]
    (case trail
      #.End
      (#try.Success directory)

      (#.Item head tail)
      (case (dictionary.get head directory)
        #.None
        (exception.except ..cannot_find_directory [path])
        
        (#.Some node)
        (case node
          (#.Left _)
          (exception.except ..cannot_find_directory [path])

          (#.Right sub_directory)
          (case tail
            #.End
            (#try.Success sub_directory)

            (#.Item _)
            (recur sub_directory tail)))))))

(def: #export (mock separator)
  (-> Text (System Async))
  (let [store (stm.var ..empty_mock)]
    (`` (implementation
         (def: separator
           separator)

         (~~ (template [<method> <retrieve>]
               [(def: (<method> path)
                  (|> store
                      stm.read
                      (\ stm.monad map
                         (|>> (<retrieve> separator path)
                              (try\map (function.constant true))
                              (try.default false)))
                      stm.commit))]
               
               [file? ..retrieve_mock_file!]
               [directory? ..retrieve_mock_directory!]))

         (def: (make_directory path)
           (stm.commit
            (do {! stm.monad}
              [|store| (stm.read store)]
              (case (..make_mock_directory! separator path |store|)
                (#try.Success |store|)
                (do !
                  [_ (stm.write |store| store)]
                  (in (#try.Success [])))
                
                (#try.Failure error)
                (in (#try.Failure error))))))

         (~~ (template [<method> <tag>]
               [(def: (<method> path)
                  (stm.commit
                   (do stm.monad
                     [|store| (stm.read store)]
                     (in (do try.monad
                           [directory (..retrieve_mock_directory! separator path |store|)]
                           (in (|> directory
                                   dictionary.entries
                                   (list.all (function (_ [node_name node])
                                               (case node
                                                 (<tag> _)
                                                 (#.Some (format path separator node_name))
                                                 
                                                 _
                                                 #.None))))))))))]

               [directory_files #.Left]
               [sub_directories #.Right]
               ))

         (def: (file_size path)
           (stm.commit
            (do stm.monad
              [|store| (stm.read store)]
              (in (|> |store|
                      (..retrieve_mock_file! separator path)
                      (try\map (|>> product.right
                                    (get@ #mock_content)
                                    binary.size)))))))

         (def: (last_modified path)
           (stm.commit
            (do stm.monad
              [|store| (stm.read store)]
              (in (|> |store|
                      (..retrieve_mock_file! separator path)
                      (try\map (|>> product.right
                                    (get@ #mock_last_modified))))))))

         (def: (can_execute? path)
           (stm.commit
            (do stm.monad
              [|store| (stm.read store)]
              (in (|> |store|
                      (..retrieve_mock_file! separator path)
                      (try\map (|>> product.right
                                    (get@ #mock_can_execute))))))))

         (def: (read path)
           (stm.commit
            (do stm.monad
              [|store| (stm.read store)]
              (in (|> |store|
                      (..retrieve_mock_file! separator path)
                      (try\map (|>> product.right
                                    (get@ #mock_content))))))))

         (def: (delete path)
           (stm.commit
            (..try_update! (..mock_delete! separator path) store)))

         (def: (modify now path)
           (stm.commit
            (..try_update! (function (_ |store|)
                             (do try.monad
                               [[name file] (..retrieve_mock_file! separator path |store|)]
                               (..update_mock_file! separator path now (get@ #mock_content file) |store|)))
                           store)))

         (def: (write content path)
           (do async.monad
             [now (async.future instant.now)]
             (stm.commit
              (..try_update! (..update_mock_file! separator path now content) store))))

         (def: (append content path)
           (do async.monad
             [now (async.future instant.now)]
             (stm.commit
              (..try_update! (function (_ |store|)
                               (do try.monad
                                 [[name file] (..retrieve_mock_file! separator path |store|)]
                                 (..update_mock_file! separator path now
                                                      (\ binary.monoid compose
                                                         (get@ #mock_content file)
                                                         content)
                                                      |store|)))
                             store))))

         (def: (move destination origin)
           (stm.commit
            (do {! stm.monad}
              [|store| (stm.read store)]
              (case (do try.monad
                      [[name file] (..retrieve_mock_file! separator origin |store|)
                       |store| (..mock_delete! separator origin |store|)]
                      (..update_mock_file! separator destination (get@ #mock_last_modified file) (get@ #mock_content file) |store|))
                (#try.Success |store|)
                (do !
                  [_ (stm.write |store| store)]
                  (in (#try.Success [])))
                
                (#try.Failure error)
                (in (#try.Failure error))))))
         ))))

(def: (check_or_make_directory monad fs path)
  (All [!] (-> (Monad !) (System !) Path (! (Try Any))))
  (do monad
    [? (\ fs directory? path)]
    (if ?
      (in (#try.Success []))
      (\ fs make_directory path))))

(def: #export (make_directories monad fs path)
  (All [!] (-> (Monad !) (System !) Path (! (Try Any))))
  (let [rooted? (text.starts_with? (\ fs separator) path)
        segments (text.split_all_with (\ fs separator) path)]
    (case (if rooted?
            (list.drop 1 segments)
            segments)
      #.End
      (\ monad in (exception.except ..cannot_make_directory [path]))

      (#.Item head tail)
      (case head
        "" (\ monad in (exception.except ..cannot_make_directory [path]))
        _ (loop [current (if rooted?
                           (format (\ fs separator) head)
                           head)
                 next tail]
            (do monad
              [? (..check_or_make_directory monad fs current)]
              (case ?
                (#try.Success _)
                (case next
                  #.End
                  (in (#try.Success []))
                  
                  (#.Item head tail)
                  (recur (format current (\ fs separator) head)
                         tail))
                
                (#try.Failure error)
                (in (#try.Failure error)))))))))

(def: #export (make_file monad fs content path)
  (All [!] (-> (Monad !) (System !) Binary Path (! (Try Any))))
  (do monad
    [? (\ fs file? path)]
    (if ?
      (in (exception.except ..cannot_make_file [path]))
      (\ fs write content path))))
