... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

... This is LuxC's parser.
... It takes the source code of a Lux file in raw text form and
... extracts the syntactic structure of the code from it.
... It only produces Lux Code nodes, and thus removes any white-space
... and comments while processing its inputs.

... Another important aspect of the parser is that it keeps track of
... its position within the input data.
... That is, the parser takes into account the line and column
... information in the input text (it doesn't really touch the
... file-name aspect of the provenance, leaving it intact in whatever
... base-line provenance it is given).

... This particular piece of functionality is not located in one
... function, but it is instead scattered throughout several parsers,
... since the logic for how to update the provenance varies, depending on
... what is being parsed, and the rules involved.

... You will notice that several parsers have a "where" parameter, that
... tells them the provenance position prior to the parser being run.
... They are supposed to produce some parsed output, alongside an
... updated provenance pointing to the end position, after the parser was run.

... Lux Code nodes/tokens are annotated with provenance meta-data
... [file-name, line, column] to keep track of their provenance and
... provenance, which is helpful for documentation and debugging.
(.using
 [library
  [lux (.except Alias
                natural revolution or)
   [abstract
    ["<>" projection]]
   ["[0]" error (.only)
    ["[0]" try]
    ["[0]" exception (.only Exception)]]
   [data
    ["[0]" text (.only \n)
     [\\projection (.only Offset)]
     ["%" \\injection]]
    [collection
     ["[0]" dictionary (.only Dictionary)]
     ["[0]" list (.only)
      ["?[1]" \\projection]]]]
   [macro
    ["[0]" syntax]
    ["[0]" template]
    ["[0]" expansion]]
   [meta
    ["[0]" name]
    ["[0]" module]
    ["[0]" static]
    ["[0]" provenance]
    ["[0]" code
     ["<[1]>" \\projection]]]
   [math
    ["[0]" unit]
    [number
     ["[0]" base]
     ["[0]" signum]
     [/64
      ["n" natural]
      ["[0]" integer]
      ["[0]" revolution]
      ["[0]" decimal]
      ["[0]" fraction]
      ["[0]" rational]]]]
   [compiler
    ["@[0]" type]]
   [aspect
    ["[0]" view]]]])

(the declaration_name
  (syntax.macro (_ [[name parameters] (<code>.form (<>.and ?list.any (<>.some ?list.any)))])
    (pure (list name))))

(the inlined
  (template.macro (_ <declaration> <type> <body>)
    [(for .python (the <declaration> <type> <body>)
          ... TODO: No longer skip inlining Lua after Rembulan isn't being used anymore.
          .lua (the <declaration> <type> <body>)
          (`` (the (,, (..declaration_name <declaration>))
                (template.macro <declaration>
                  [<body>]))))]))

... TODO: Implement .when_char# as a custom extension.
... That way, it should be possible to obtain the character without wrapping
... it into a java.lang.Long, thereby improving performance.

... TODO: Make an extension to take advantage of java/lang/String::indexOf<int,int>
... to get better performance than the current .text_index# extension.

... TODO: Instead of always keeping a "where" provenance variable, keep the
... individual components (i.e. file, line and column) separate, so
... that updated the "where" only involved updating the components, and
... producing the provenances only involved building them, without any need
... for pattern-matching and de-structuring.

(template.with [<extension> <diff> <name>]
  [(the <name>
     (template.macro (_ value)
       [(<extension> <diff> value)]))]

  [[.i64_+# 1 after]
   [.i64_+# 2 after/2]
   [.i64_-# 1 !--]]
  )

(the !clip
  (template.macro (_ from to text)
    [(.text_clip# from (n.- from to) text)]))

(template.with [<name> <extension>]
  [(the <name>
     (template.macro (_ expected actual)
       [(<extension> (as (-> Natural Integer) expected)
                     (as (-> Natural Integer) actual))]))]

  [[!n/= .i64_=#]
   [!n/< .int_<#]]
  )

(template.with [<name> <extension>]
  [(the <name>
     (template.macro (_ param subject)
       [(<extension> param subject)]))]

  [[!n/+ .i64_+#]
   [!n/- .i64_-#]]
  )

(every .public Alias
  Text)

(every .public Aliases
  (Dictionary Alias module.Name))

(the .public no_aliases
  Aliases
  (dictionary.empty text.hash))

(the .public text_delimiter text.double_quote)

(template.with [<character> <definition>]
  [(the .public <definition> <character>)]

  [... Form delimiters
   ["(" open_form]
   [")" close_form]

   ... Variant delimiters
   ["{" open_variant]
   ["}" close_variant]

   ... Tuple delimiters
   ["[" open_tuple]
   ["]" close_tuple]

   ... https://en.wikipedia.org/wiki/Delimiter
   ["," digit_delimiter]])

(template.with [<definition> <character>]
  [(the <definition> <character>)]

  [[decimal_delimiter decimal.delimiter]

   [positive_signum (signum.as_text signum.positive)]
   [negative_signum (signum.as_text signum.negative)]])

(template.with [,name ,base]
  [(the ,name
     (its base.#suffix ,base))]

  [[suffix_of_binary base.binary]
   [suffix_of_base_08 base.octal]
   [suffix_of_base_10 base.decimal]
   [suffix_of_base_16 base.hexadecimal]])

(exception.the .public (end_of_file [module])
  (Exception [module.Name])
  (exception.report
   (list ["Module" (%.text module)])))

(the amount_of_input_shown 64)

(every .public Source_Code
  Text)

(inlined (input_at start input)
  (-> Offset Source_Code
      Text)
  (let [end (|> start
                (!n/+ amount_of_input_shown)
                (n.minor (.text_size# input)))]
    (!clip start end input)))

(exception.the .public (unrecognized_input [provenance offset input])
  (Exception [Provenance Offset Source_Code])
  (exception.report
   (list ["Provenance" (provenance.as_text provenance)]
         ["Source code" (..input_at offset input)])))

(exception.the .public (text_cannot_contain_new_lines [text])
  (Exception [Text])
  (exception.report
   (list ["Text" (%.text text)])))

(every Failure
  [Source Error])

(the failure
  (template.macro (_ ,source ,error)
    [{.#Left [,source ,error]}]))

(every Length
  Natural)

(inlined (!forward length where)
  (-> Length Provenance
      Provenance)
  (let [[where::file where::line where::column] where]
    [where::file where::line (!n/+ length where::column)]))

(every (Success it)
  [Source it])

(the success
  (template.macro (_ ,source ,it)
    [{.#Right [,source ,it]}]))

(every (Result it)
  (Either Failure
          (Success it)))

(every (Projection it)
  (-> Source
      (Result it)))

(expansion.let [,bit_false (these "0")
                ,bit_true (these "1")
                
                ,every_digit_of_binary (these ,bit_false ,bit_true)
                ,every_digit_of_base_08 (these ,every_digit_of_binary "2" "3" "4" "5" "6" "7")
                ,every_digit_of_base_10 (these ,every_digit_of_base_08 "8" "9")
                ,every_digit_of_base_16 (these ,every_digit_of_base_10 "A" "B" "C" "D" "E" "F")
                ,delimiter_of_digit (static ..digit_delimiter)]
  (these (expansion.let [<non_name_characters> (template.with [<character>]
                                                 [(,, (static <character>))]

                                                 [[text.space]
                                                  [\n] [text.carriage_return]
                                                  [name.delimiter]
                                                  [..open_form] [..close_form]
                                                  [..open_variant] [..close_variant]
                                                  [..open_tuple] [..close_tuple]
                                                  [..text_delimiter]]
                                                 )]
           (these (template.with [,single ,multiple ,every_digit]
                    [(the ,single
                       (template.macro (_ character then else)
                         [(.when_char# character
                                       [,every_digit
                                        then]

                                       ... else
                                       else)]))

                     (the ,multiple
                       (template.macro (_ character then else_options else)
                         [(`` (.when_char# character
                                           [,every_digit
                                            then

                                            [,delimiter_of_digit]
                                            then

                                            (,, (template.spliced else_options))]

                                           ... else
                                           else))]))]

                    [[!if_binary? !if_binary?+ [,every_digit_of_binary]]
                     [!if_base_08? !if_base_08?+ [,every_digit_of_base_08]]
                     [!if_base_10? !if_base_10?+ [,every_digit_of_base_10]]
                     [!if_base_16? !if_base_16?+ [,every_digit_of_base_16]]]
                    )

                  (`` (the !if_name_character?|tail
                        (template.macro (_ character then else)
                          [(.when_char# character
                                        [[<non_name_characters>]
                                         else]

                                        ... else
                                        then)])))

                  (`` (the !if_name_character?|head
                        (template.macro (_ character then else)
                          [(.when_char# character
                                        [[<non_name_characters> ,every_digit_of_base_10]
                                         else]

                                        ... else
                                        then)]))))
           )

         (the !letE
           (template.macro (_ <binding> <computation> <body>)
             [(when <computation>
                {.#Right <binding>}
                <body>

                ... {.#Left error}
                <<else>>
                (as_expected <<else>>))]))

         (the no_exponent
           Offset
           0)

         (template.with [,as ,extension ,numerator_type ,numerator_tag]
           [(inlined (,as where numerator denominator)
              (-> Provenance ,numerator_type Natural
                  @type.Code)
              {@type.#Form where (list {@type.#Name where [.prelude ,extension]}
                                       {,numerator_tag where numerator}
                                       {@type.#Natural where denominator})})]

           [[as_fraction fraction.extension Natural @type.#Natural]
            [as_rational rational.extension Integer @type.#Integer]]
           )

         (<| (template.with_locals [@size @code @module])
             (expansion.let [the_globals (these @size @code @module)
                             types_of_the_globals (these Length Source_Code module.Name)])
             (these (the !failure
                      (template.macro (_ the_globals where offset)
                        [(..failure [where offset @code]
                                    (exception.error ..unrecognized_input [where offset @code]))]))

                    (the !end_of_file
                      (template.macro (_ the_globals where offset)
                        [(..failure [where offset @code]
                                    (exception.error ..end_of_file @module))]))

                    (the value
                      (template.macro (_ the_globals ,where <start> <end> <format>)
                        [(when (|> @code
                                   (!clip <start> <end>)
                                   (text.replaced ..digit_delimiter "")
                                   (by <format> of))
                           {.#Right output}
                           (..success [(let [[where::file where::line where::column] ,where]
                                         [where::file where::line (!n/+ (!n/- <start> <end>) where::column)])
                                       <end>
                                       @code]
                                      output)
                           
                           {.#Left error}
                           (..failure [,where <start> @code]
                                      error))]))

                    (the value_with_suffix
                      (template.macro (_ the_globals ,where <start> <end> <format>)
                        [(when (|> @code
                                   (!clip <start> <end>)
                                   (text.replaced ..digit_delimiter "")
                                   (by <format> of))
                           {.#Right output}
                           (let [<end>' (after <end>)]
                             (..success [(let [[where::file where::line where::column] ,where]
                                           [where::file where::line (!n/+ (!n/- <start> <end>') where::column)])
                                         <end>'
                                         @code]
                                        output))
                           
                           {.#Left error}
                           (..failure [,where <start> @code]
                                      error))]))

                    (the number
                      (template.macro (_ the_globals <start> <end> <format> <tag>)
                        [(when (|> @code
                                   (!clip <start> <end>)
                                   (text.replaced ..digit_delimiter "")
                                   (by <format> of))
                           {.#Right output}
                           (..success [(let [[where::file where::line where::column] where]
                                         [where::file where::line (!n/+ (!n/- <start> <end>) where::column)])
                                       <end>
                                       @code]
                                      {<tag> where output})
                           
                           {.#Left error}
                           (..failure [where <start> @code]
                                      error))]))

                    (the with_character
                      (template.macro (_ the_globals offset character else body)
                        [(if (!n/< @size offset)
                             (let [character (.text_char# offset @code)]
                               body)
                             else)]))

                    (inlined (name_part the_globals start where offset)
                      (-> types_of_the_globals Offset Provenance Offset
                          (Result Text))
                      (expansion.let [,success (..success [(revised .#column (|>> (!n/+ (!n/- start end))) where)
                                                           end
                                                           @code]
                                                          (!clip start end @code))]
                        (loop (again [end offset])
                          (<| (with_character the_globals end character ,success)
                              (!if_name_character?|tail character
                                                        (again (after end))
                                                        ,success)))))

                    (the !half_name_projection
                      (template.macro (_ the_globals offset character)
                        [(!if_name_character?|head character
                                                   (!letE [source' name] (..name_part the_globals offset (!forward 1 where) (after offset))
                                                          (..success source' [@module name]))
                                                   (!failure the_globals where offset))]))

                    (`` (the (implicit_name the_globals [where offset/0 _])
                          (-> types_of_the_globals
                              (Projection Name))
                          (<| (with_character the_globals offset/0 character/0
                                (!end_of_file the_globals where offset/0))
                              (if (!n/= (character (,, (static name.delimiter)))
                                        character/0)
                                  (<| (let [offset/1 (after offset/0)])
                                      (with_character the_globals offset/1 character/1
                                        (!end_of_file the_globals where offset/1))
                                      (!half_name_projection the_globals offset/1 character/1))
                                  (let [@module (static .prelude)]
                                    (!half_name_projection the_globals offset/0 character/0))))))

                    (the !implicit_name
                      (template.macro (_ the_globals source where tag)
                        [(!letE [source' name] (..implicit_name the_globals source)
                                (..success source' {tag where name}))]))

                    (expansion.let [<simple> (..success source' ["" simple])]
                      (`` (the (full_name_projection the_globals aliases start source)
                            (-> types_of_the_globals Aliases Offset
                                (Projection Name))
                            (<| (!letE [source' simple] (let [[where offset _] source]
                                                          (..name_part the_globals start where offset)))
                                (let [[where' offset' _] source'])
                                (with_character the_globals offset' character/delimiter <simple>)
                                (if (!n/= (character (,, (static name.delimiter)))
                                          character/delimiter)
                                    (<| (let [offset'' (after offset')])
                                        (!letE [source'' complex] (..name_part the_globals offset'' (!forward 1 where') offset''))
                                        (if (.text_=# "" complex)
                                            (let [[where offset _] source]
                                              (!failure the_globals where offset))
                                            (..success source'' [(|> aliases
                                                                     (dictionary.value simple)
                                                                     (try.else simple))
                                                                 complex])))
                                    <simple>)))))

                    (the !full_name_projection
                      (template.macro (_ the_globals offset source where aliases tag)
                        [(!letE [source' full_name] (..full_name_projection the_globals aliases offset source)
                                (..success source' {tag where full_name}))]))

                    (error.the .public error_of_natural_is_not_valid)

                    (the (natural_is_not_valid the_globals @)
                      (-> types_of_the_globals
                          (Projection Natural))
                      (..failure @ ..error_of_natural_is_not_valid))

                    (template.with [,format ,name ,predicate ,suffix ,parent]
                      [(the (,name the_globals @)
                         (-> types_of_the_globals
                             (Projection Natural))
                         (<| (let [[where start @code] @])
                             (loop (next ['end start]))
                             (with_character the_globals 'end 'character (natural_is_not_valid the_globals @))
                             (,predicate 'character
                                         (next (after 'end))
                                         []
                                         (`` (.when_char# 'character
                                                          [[(,, (static ,suffix))]
                                                           (..value_with_suffix the_globals where start 'end ,format)]

                                                          ... else
                                                          (,parent the_globals @))))))]

                      [[n.base_16 natural_in_base_16 !if_base_16?+ ..suffix_of_base_16
                        natural_is_not_valid]
                       [n.base_10 natural_in_base_10 !if_base_10?+ ..suffix_of_base_10
                        natural_in_base_16]
                       [n.base_08 natural_in_base_08 !if_base_08?+ ..suffix_of_base_08
                        natural_in_base_10]
                       [n.base_02 natural_in_binary !if_binary?+ ..suffix_of_binary
                        natural_in_base_08]]
                      )

                    (the (natural_in_default the_globals @)
                      (-> types_of_the_globals
                          (Projection Natural))
                      (<| (let [[where start @code] @])
                          (loop (next ['end start]))
                          (expansion.let [,else (..value the_globals where start 'end n.base_10)])
                          (with_character the_globals 'end 'character ,else)
                          (!if_base_10?+ 'character
                                         (next (after 'end))
                                         []
                                         ,else)))

                    (the (or left right)
                      (for_any (_ it)
                        (-> (-> types_of_the_globals
                                (Projection it))
                            (-> types_of_the_globals
                                (Projection it))
                            (-> types_of_the_globals
                                (Projection it))))
                      (function (_ the_globals @)
                        (when (left the_globals @)
                          {.#Left error}
                          (right the_globals @)

                          success
                          success)))

                    (the natural
                      (-> types_of_the_globals
                          (Projection Natural))
                      (or natural_in_binary
                          natural_in_default))

                    (the (decimal the_globals start where offset)
                      (-> types_of_the_globals Offset Provenance Offset
                          (Result @type.Code))
                      (expansion.let [<success> (..number the_globals start end decimal.base_10 @type.#Decimal)
                                      <failure> (!failure the_globals where offset)
                                      <signs> (template.with [<sign>]
                                                [(,, (static <sign>))]

                                                [[..positive_signum]
                                                 [..negative_signum]])]
                        (loop (again [end offset
                                      exponent (static ..no_exponent)])
                          (<| (with_character the_globals end character/0 <success>)
                              (`` (`` (!if_base_10?+ character/0
                                                     (again (after end) exponent)

                                                     [["e" "E"]
                                                      (if (same? (static ..no_exponent) exponent)
                                                          (<| (with_character the_globals (after end) character/1 <failure>)
                                                              (`` (.when_char# character/1
                                                                               [[<signs>]
                                                                                (<| (with_character the_globals (!n/+ 2 end) character/2 <failure>)
                                                                                    (!if_base_10?+ character/2
                                                                                                   (again (!n/+ 3 end) character/0)
                                                                                                   []
                                                                                                   <failure>))]
                                                                               ... else
                                                                               <failure>)))
                                                          <success>)

                                                      (,, (template.with [,unit]
                                                            [[(,, (static.text (its unit.#suffix ,unit)))]
                                                             (<| (!letE [[where' numerator_end _] numerator] (..value the_globals where start end decimal.base_10))
                                                                 (let [denominator (n.decimal (its unit.#factor ,unit))])
                                                                 (..success [where' (after numerator_end) @code]
                                                                            {@type.#Decimal where (decimal./ denominator numerator)}))]

                                                            [[unit.degree]
                                                             [unit.gradian]
                                                             [unit.per_cent]
                                                             [unit.per_mille]
                                                             [unit.per_myriad]]
                                                            ))
                                                      (,, (template.with [,unit]
                                                            [[(,, (static.text (its unit.#suffix ,unit)))]
                                                             (<| (!letE [[where' numerator_end _] numerator] (..value the_globals where start end decimal.base_10))
                                                                 (..success [where' (after numerator_end) @code]
                                                                            {@type.#Decimal where (decimal.x (its unit.#factor ,unit)
                                                                                                             numerator)}))]

                                                            [[unit.radian]
                                                             [unit.turn]]
                                                            ))]

                                                     <success>)))))))

                    (the (rational numerator the_globals @)
                      (-> Integer types_of_the_globals
                          (Projection @type.Code))
                      (<| (!letE [[where' denominator_end @code] denominator] (..natural the_globals @))
                          (let [[where _] @])
                          (..success [where' denominator_end @code]
                                     (..as_rational where numerator denominator))))

                    (inlined (signed_projection the_globals start where offset)
                      (-> types_of_the_globals Offset Provenance Offset
                          (Result @type.Code))
                      (expansion.let [,success (..number the_globals start end integer.base_10 @type.#Integer)]
                        (loop (again [end offset])
                          (<| (with_character the_globals end character ,success)
                              (`` (`` (!if_base_10?+ character
                                                     (again (after end))

                                                     [[(,, (static ..decimal_delimiter))]
                                                      (..decimal the_globals start where (after end))

                                                      [(,, (static rational.delimiter))]
                                                      (!letE [_ numerator] (..value the_globals where start end integer.base_10)
                                                             (..rational numerator the_globals [where (after end) @code]))

                                                      (,, (template.with [,unit]
                                                            [[(,, (static.text (its unit.#suffix ,unit)))]
                                                             (!letE [[where' numerator_end _] numerator] (..value the_globals where start end integer.base_10)
                                                                    (..success [where' (after numerator_end) @code]
                                                                               (..as_rational where numerator (its unit.#factor ,unit))))]

                                                            [[unit.degree]
                                                             [unit.gradian]
                                                             [unit.per_cent]
                                                             [unit.per_mille]
                                                             [unit.per_myriad]]
                                                            ))]

                                                     ,success)))))))

                    (inlined (revolution the_globals start where offset)
                      (-> types_of_the_globals Offset Provenance Offset
                          (Result @type.Code))
                      (expansion.let [,success (..number the_globals start 'end revolution.base_10 @type.#Revolution)]
                        (loop (next ['end offset])
                          (<| (with_character the_globals 'end 'character ,success)
                              (!if_base_10?+ 'character
                                             (next (after 'end))
                                             []
                                             ,success)))))

                    (the (fraction numerator the_globals @)
                      (-> Natural types_of_the_globals
                          (Projection @type.Code))
                      (<| (!letE [[where' denominator_end @code] denominator] (..natural the_globals @))
                          (let [[where _] @])
                          (..success [where' denominator_end @code]
                                     (..as_fraction where numerator denominator))))

                    (the (positive the_globals @)
                      (-> types_of_the_globals
                          (Projection @type.Code))
                      (<| (let [[where start @code] @])
                          (!letE [[where' numerator_end _] numerator] (..natural the_globals @))
                          (expansion.let [,natural (..success [where' numerator_end @code]
                                                              {@type.#Natural where numerator})])
                          (with_character the_globals numerator_end potential_delimiter ,natural)
                          (`` (`` (.when_char# potential_delimiter
                                               [[(,, (static fraction.delimiter))]
                                                (..fraction numerator the_globals [where' (after numerator_end) @code])

                                                (,, (template.with [,unit]
                                                      [[(,, (static.text (its unit.#suffix ,unit)))]
                                                       (..success [where' (after numerator_end) @code]
                                                                  (..as_fraction where' numerator (its unit.#factor ,unit)))]

                                                      [[unit.degree]
                                                       [unit.gradian]
                                                       [unit.per_cent]
                                                       [unit.per_mille]
                                                       [unit.per_myriad]]
                                                      ))]

                                               ... else
                                               ,natural
                                               )))))

                    (the !signed_projection
                      (template.macro (_ the_globals offset where aliases end)
                        [(<| (let ['offset/1 (after offset)])
                             (with_character the_globals 'offset/1 'character/1 end)
                             (!if_base_10? 'character/1
                                           (signed_projection the_globals offset where (after/2 offset))
                                           (!full_name_projection the_globals offset [where (after offset) @code] where aliases @type.#Name)))]))

                    (the !horizontal
                      (template.macro (_ the_globals where offset)
                        [[(revised .#column ++ where)
                          (after offset)
                          @code]]))

                    (inlined (!new_line where)
                      (-> Provenance
                          Provenance)
                      (let [[where::file where::line where::column] where]
                        [where::file (after where::line) 0]))

                    (the !vertical
                      (template.macro (_ the_globals where offset)
                        [[(!new_line where)
                          (after offset)
                          @code]]))

                    (template.with [<name> <close> <tag>]
                      [(inlined (<name> the_globals parse where offset)
                         (-> types_of_the_globals (Projection @type.Code) Provenance Offset
                             (Result @type.Code))
                         (loop (<name> [source (is Source [(!forward 1 where) offset @code])
                                        composite (is (Stack @type.Code) {.#Empty})])
                           (when (parse source)
                             (..success source' top)
                             (<name> source' {.#Top top composite})
                             
                             (..failure source' error)
                             (if (same? <close> error)
                                 (..success source' {<tag> where (list.reversed (view.of list.stack composite))})
                                 (..failure source' error)))))]

                      ... Form and tuple syntax is mostly the same, differing only in the
                      ... delimiters involved.
                      ... They may have an arbitrary number of arbitrary Code nodes as elements.
                      [[variant_projection ..close_variant @type.#Variant]
                       [tuple_projection   ..close_tuple   @type.#Tuple]
                       [form_projection    ..close_form    @type.#Form]]
                      )

                    (the !guarantee_no_new_lines
                      (template.macro (_ the_globals where offset content body)
                        [(when (.text_index# 0 (static \n) content)
                           {.#None}
                           body

                           '_
                           (..failure [where offset @code]
                                      (exception.error ..text_cannot_contain_new_lines content)))]))

                    (the (text_projection the_globals where offset)
                      (-> types_of_the_globals Provenance Offset
                          (Result @type.Code))
                      (when (.text_index# offset (static ..text_delimiter) @code)
                        {.#Some 'end}
                        (<| (let ['content (!clip offset 'end @code)])
                            (!guarantee_no_new_lines the_globals where offset 'content)
                            (..success [(let [size (!n/- offset 'end)]
                                          (revised .#column (|>> (!n/+ size) (!n/+ 2)) where))
                                        (after 'end)
                                        @code]
                                       {@type.#Text where 'content}))
                        
                        _
                        (!failure the_globals where offset)))

                    ... TODO: Grammar macro for specifying syntax.
                    ... (the lux_grammar
                    ...   (grammar [expression "..."]
                    ...            [form "(" [#* expression] ")"]))

                    (expansion.let [<consume_1> (these [where (after offset/0) @code])
                                    <move_1> [(!forward 1 where) (after offset/0) @code]]
                      (these (the !close
                               (template.macro (_ closer)
                                 [(..failure <move_1> closer)]))

                             (the (bit the_globals @)
                               (-> types_of_the_globals
                                   (Projection @type.Code))
                               (<| (let [[where offset/0 @code] @])
                                   (with_character the_globals offset/0 character_of_bit
                                     (!end_of_file the_globals where offset/0))
                                   (let [offset/1 (after offset/0)])
                                   (with_character the_globals offset/1 suffix_of_bit
                                     (!end_of_file the_globals where offset/1))
                                   (`` (.when_char# character_of_bit
                                                    [(,, (template.with [<character> <bit>]
                                                           [[<character>]
                                                            (`` (.when_char# suffix_of_bit
                                                                             [[(,, (static ..suffix_of_binary))]
                                                                              (..success [(revised .#column (|>> after/2) where)
                                                                                          (after/2 offset/0)
                                                                                          @code]
                                                                                         {@type.#Bit where <bit>})]

                                                                             ... else
                                                                             (..positive the_globals @)))]

                                                           [[,bit_false .false]
                                                            [,bit_true .true]]))]

                                                    ... else
                                                    (..positive the_globals @)))))

                             (the .public (parse @code @module aliases)
                               (-> Source_Code module.Name Aliases
                                   (Projection @type.Code))
                               (let [@size (.text_size# @code)]
                                 (function (again [where offset/0 _])
                                   (<| (with_character the_globals offset/0 character/0
                                         (!end_of_file the_globals where offset/0))
                                       (expansion.let [<composites> (template.with [<open> <close> <projection>]
                                                                      [[(,, (static <open>))]
                                                                       (<projection> the_globals again where (after offset/0))

                                                                       [(,, (static <close>))]
                                                                       (!close <close>)]

                                                                      [[..open_form ..close_form form_projection]
                                                                       [..open_variant ..close_variant variant_projection]
                                                                       [..open_tuple ..close_tuple tuple_projection]]
                                                                      )]
                                         (`` (.when_char# character/0
                                                          [[(,, (static text.space))
                                                            (,, (static text.carriage_return))]
                                                           (again (!horizontal the_globals where offset/0))
                                                           
                                                           ... New line
                                                           [(,, (static \n))]
                                                           (again (!vertical the_globals where offset/0))

                                                           <composites>

                                                           ... Text
                                                           [(,, (static ..text_delimiter))]
                                                           (text_projection the_globals where (after offset/0))

                                                           ... Coincidentally (= name.delimiter ..decimal_delimiter)
                                                           [(,, (static name.delimiter))
                                                            ... (,, (static ..decimal_delimiter))
                                                            ]
                                                           ... It's either a Revolution, a name, or a comment.
                                                           (expansion.let [<implicit_name> (!implicit_name the_globals [where offset/1 @code] where @type.#Name)
                                                                           <comment_projection> (when (.text_index# (after offset/1) (static \n) @code)
                                                                                                  {.#Some end}
                                                                                                  (again (!vertical the_globals where end))
                                                                                                  
                                                                                                  _
                                                                                                  (!end_of_file the_globals where offset/1))]
                                                             (<| (let [offset/1 (after offset/0)])
                                                                 (with_character the_globals offset/1 character/1
                                                                   (!end_of_file the_globals where offset/1))
                                                                 (!if_base_10? character/1
                                                                               ... It's a Revolution.
                                                                               (..revolution the_globals offset/0 where (after offset/1))
                                                                               ... It's either a name, or a comment.
                                                                               (.when_char# character/1
                                                                                            [[(,, (static name.delimiter))]
                                                                                             ... It's either a name, or a comment.
                                                                                             (<| (let [offset/2 (after offset/1)])
                                                                                                 (with_character the_globals offset/2 character/2
                                                                                                   (!end_of_file the_globals where offset/2))
                                                                                                 (.when_char# character/2
                                                                                                              [[(,, (static name.delimiter))]
                                                                                                               ... It's a comment.
                                                                                                               <comment_projection>]
                                                                                                              ... It's a name.
                                                                                                              <implicit_name>))]
                                                                                            ... It's a name.
                                                                                            <implicit_name>))))

                                                           [(,, (static ..positive_signum))
                                                            (,, (static ..negative_signum))]
                                                           (!signed_projection the_globals offset/0 where aliases
                                                                               (!end_of_file the_globals where offset/0))]

                                                          ... else
                                                          (<| (!if_binary? character/0
                                                                           (..bit the_globals [where offset/0 @code]))
                                                              ... Natural number
                                                              (!if_base_10? character/0
                                                                            (..positive the_globals [where offset/0 @code]))
                                                              ... Name
                                                              (!full_name_projection the_globals offset/0 <consume_1> where aliases @type.#Name))
                                                          )))
                                       )))))
                      )
                    ))))
