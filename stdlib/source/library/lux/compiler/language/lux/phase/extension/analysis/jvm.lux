... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except Type Module Declaration Integer Double Parameter Array
                :Variable
                type with argument)
   ["[0]" ffi]
   [abstract
    ["<>" projection (.use "[1]:[0]" monad)]
    ["[0]" monad]]
   [control
    ["|" pipe]
    ["[0]" maybe]]
   [error
    ["[0]" try (.only Try) (.use "[1]:[0]" monad)]
    ["[0]" exception]]
   [function
    ["[0]" predicate]]
   [data
    ["[0]" product]
    [binary (.only Binary)
     ["[0]" \\injection]]
    ["[0]" text (.only)
     ["%" \\injection]
     ["<[1]>" \\projection]]
    [collection
     ["[0]" list (.use "[1]:[0]" mix monad monoid)
      ["?[1]" \\projection]]
     ["[0]" stack]
     ["[0]" dictionary (.only Dictionary)]
     ["[0]" sequence]]]
   [logic
    ["[0]" bit]]
   [math
    [number
     ["i[0]" /32
      ["[1]" integer]]
     [/64
      ["n" natural]]]]
   [macro
    ["^" pattern]
    ["[0]" template]]
   ["[0]" type (.only)
    ["[0]" check (.only Check) (.use "[1]:[0]" monad)]]
   ["[0]" meta (.only)
    ["[0]" module]
    ["[0]" code (.only)
     ["<[1]>" \\projection]]]
   [target
    ["[0]" jvm
     ["_" bytecode (.only Bytecode) (.use "[1]:[0]" monad)]
     ["[0]!" reflection]
     ["[0]" modifier (.only Modifier) (.use "[1]:[0]" monoid)]
     ["[0]" attribute]
     ["[0]" field]
     ["[0]" version]
     ["[0]" method]
     ["[0]" class]
     [constant
      ["[0]" pool (.only Resource)]]
     [encoding
      [name
       ["[0]" external]
       ["[0]" internal]]]
     ["[1]" type (.only Type Argument Typed)
      ["[0]" category (.only Void Value Return Primitive Object Class Array Var Parameter Method)]
      ["[0]" box]
      ["[0]" reflection]
      ["[0]" descriptor]
      ["[0]" signature]
      ["[0]" projection]
      ["[0]" alias (.only Aliasing)]
      ["[0]T" lux (.only Mapping)]]]]
   [aspect
    ["[0]" view]]]]
 ["[0]" //
  ["[1][0]" lux (.only custom with)]
  ["/[1]" // (.only)
   ["/[1]" //
    [translation
     [jvm
      ["[0]" runtime]
      ["[0]" function
       ["[1]" abstract]]]]
    ["/[1]" //
     ["[0]" phase (.use "[1]:[0]" monad)]
     ["[0]" translation]
     ["[0]" declaration]
     ["[0]" analysis (.only Operation Phase Handler Bundle)
      ["[0]" complex]
      ["[0]" pattern]
      ["[0]" inference]
      ["[0]A" type]
      ["[0]" scope]]
     [///
      ["@[0]" type]
      [meta
       [archive (.only Archive)
        [module
         [descriptor (.only Module)]]]]
      ["[0]" extension (.only)
       ["[1]/[0]" jvm]]]]]]])

(ffi.the java/lang/ClassLoader
  "[1]:[0]")

(ffi.the java/lang/Object
  "[1]:[0]"
  (equals [java/lang/Object] boolean))

(ffi.the java/lang/reflect/Type
  "[1]:[0]")

(ffi.the (java/lang/reflect/TypeVariable d)
  "[1]:[0]"
  (getName [] java/lang/String)
  (getBounds [] [java/lang/reflect/Type]))

(ffi.the java/lang/reflect/Modifier
  "[1]:[0]"
  ("static" isStatic [int] boolean)
  ("static" isFinal [int] boolean)
  ("static" isInterface [int] boolean)
  ("static" isAbstract [int] boolean)
  ("static" isPublic [int] boolean)
  ("static" isProtected [int] boolean))

(ffi.the java/lang/annotation/Annotation
  "[1]:[0]")

(ffi.the java/lang/reflect/Method
  "[1]:[0]"
  (getName [] java/lang/String)
  (getModifiers [] int)
  (getDeclaringClass [] (java/lang/Class java/lang/Object))
  (getTypeParameters [] [(java/lang/reflect/TypeVariable java/lang/reflect/Method)])
  (getGenericParameterTypes [] [java/lang/reflect/Type])
  (getDeclaredAnnotations [] [java/lang/annotation/Annotation])
  
  (getReturnType [] (java/lang/Class java/lang/Object))
  (getGenericReturnType [] "?" java/lang/reflect/Type)
  
  (getExceptionTypes [] [(java/lang/Class java/lang/Object)])
  (getGenericExceptionTypes [] [java/lang/reflect/Type]))

(ffi.the (java/lang/reflect/Constructor c)
  "[1]:[0]"
  (getModifiers [] int)
  (getDeclaringClass [] (java/lang/Class c))
  (getTypeParameters [] [(java/lang/reflect/TypeVariable (java/lang/reflect/Constructor c))])
  (getGenericParameterTypes [] [java/lang/reflect/Type])
  (getExceptionTypes [] [(java/lang/Class java/lang/Object)])
  (getGenericExceptionTypes [] [java/lang/reflect/Type])
  (getDeclaredAnnotations [] [java/lang/annotation/Annotation]))

(ffi.the (java/lang/Class c)
  "[1]:[0]"
  ("static" forName [java/lang/String] "try" (java/lang/Class java/lang/Object))
  (getName [] java/lang/String)
  (getModifiers [] int)
  (isAssignableFrom [(java/lang/Class [? < java/lang/Object])] boolean)
  (getTypeParameters [] [(java/lang/reflect/TypeVariable (java/lang/Class c))])
  (getGenericInterfaces [] [java/lang/reflect/Type])
  (getGenericSuperclass [] "?" java/lang/reflect/Type)
  (getDeclaredField [java/lang/String] "try" java/lang/reflect/Field)
  (getConstructors [] [(java/lang/reflect/Constructor java/lang/Object)])
  (getDeclaredMethods [] [java/lang/reflect/Method])
  (getDeclaredAnnotations [] [java/lang/annotation/Annotation])
  (getSuperclass [] "?" (java/lang/Class java/lang/Object))
  (getInterfaces [] [(java/lang/Class java/lang/Object)]))

(template.with [<name>]
  [(exception.the .public (<name> [class field])
     (exception.Exception [external.Name Text])
     (exception.report
      (list ["Class" (%.text class)]
            ["Field" (%.text field)])))]

  [[cannot_set_a_final_field]
   [deprecated_field]])

(exception.the .public (deprecated_method [class method type])
  (exception.Exception [external.Name Text .Type])
  (exception.report
   (list ["Class" (%.text class)]
         ["Method" (%.text method)]
         ["Type" (type.as_text type)])))

(exception.the .public (deprecated_class class)
  (exception.Exception external.Name)
  (exception.report
   (list ["Class" (%.text class)])))

(the (ensure_fresh_class! class_loader name)
  (-> java/lang/ClassLoader external.Name
      (Operation Any))
  (monad.let phase.monad
    [class (phase.of_try (reflection!.load class_loader name))]
    (phase.assertion ..deprecated_class [name]
                     (|> class
                         (java/lang/Class:getDeclaredAnnotations [])
                         reflection!.deprecated?
                         not))))

(the reflection
  (for_any (_ category)
    (-> (Type (Value category))
        Text))
  (|>> jvm.reflection
       reflection.reflection))

(the signature
  (for_any (_ it)
    (-> (Type it)
        Text))
  (|>> jvm.signature
       signature.signature))

(the object_class
  external.Name
  "java.lang.Object")

... TODO: Get rid of this template.with block and use the definition in
... lux/ffi.jvm.lux ASAP
(template.with [<name> <class>]
  [(the .public <name>
     .Type
     {.:Nominal <class> (list)})]

  [... Boxes
   [Boolean   box.boolean]
   [Byte      box.byte]
   [Short     box.short]
   [Integer   box.int]
   [Long      box.long]
   [Float     box.float]
   [Double    box.double]
   [Character box.char]
   [String    "java.lang.String"]

   ... Primitives
   [boolean   (reflection.reflection reflection.boolean)]
   [byte      (reflection.reflection reflection.byte)]
   [short     (reflection.reflection reflection.short)]
   [int       (reflection.reflection reflection.int)]
   [long      (reflection.reflection reflection.long)]
   [float     (reflection.reflection reflection.float)]
   [double    (reflection.reflection reflection.double)]
   [char      (reflection.reflection reflection.char)]])

(.every Member
  (Record
   [:class external.Name
    :member Text]))

(the member
  (<code>.Projection Member)
  (all <>.and
       <code>.text
       <code>.text
       ))

(.every Method_Signature
  (Record
   [:method .Type
    :inputs (List (Type Value))
    :output (Type Return)
    :deprecated? Bit
    :throws (List .Type)]))

(template.with [<name>]
  [(exception.the .public (<name> type)
     (exception.Exception .Type)
     (exception.report
      (list ["Type" (type.as_text type)])))]

  [[non_object]
   [non_array]
   [non_parameter]
   [non_jvm_type]])

(template.with [<name>]
  [(exception.the .public (<name> class)
     (exception.Exception external.Name)
     (exception.report
      (list ["Class/type" (%.text class)])))]

  [[non_interface]
   [non_throwable]
   [primitives_are_not_objects]])

(the (method_signature_text it)
  (text.Injection Method_Signature)
  (exception.report
   (list ["Type" (type.as_text (its :method it))]
         ["Arguments" (exception.listing jvm.as_text (its :inputs it))]
         ["Return" (jvm.as_text (its :output it))]
         ["Deprecated?" (bit.as_text (its :deprecated? it))]
         ["Throws" (exception.listing type.as_text (its :throws it))])))

(template.with [<name>]
  [(exception.the .public (<name> [class_variables class method method_variables inputsJT hints])
     (exception.Exception [(List (Type Var))
                           external.Name
                           Text
                           (List (Type Var))
                           (List (Type Value))
                           (List Method_Signature)])
     (exception.report
      (list ["Class variables" (exception.listing ..signature class_variables)]
            ["Class" class]
            ["Method" method]
            ["Method variables" (exception.listing ..signature method_variables)]
            ["Arguments" (exception.listing ..signature inputsJT)]
            ["Hints" (exception.listing ..method_signature_text hints)])))]

  [[no_candidates]
   [too_many_candidates]])

(exception.the .public (cannot_cast [module from to value])
  (exception.Exception [Text (Type Value) (Type Value) @type.Code])
  (exception.report
   (list ["From" (..signature from)]
         ["To" (..signature to)]
         ["Value" (code.relative module value)])))

(template.with [<name>]
  [(exception.the .public (<name> message)
     (exception.Exception Text)
     message)]

  [[primitives_cannot_have_type_parameters]
   [cannot_possibly_be_an_instance]
   [unknown_type_var]])

(the with_conversion
  (Change Bundle)
  (|>> (with extension/jvm.conversion_double_to_float (//lux.unary ..double ..float))
       (with extension/jvm.conversion_double_to_int (//lux.unary ..double ..int))
       (with extension/jvm.conversion_double_to_long (//lux.unary ..double ..long))
       
       (with extension/jvm.conversion_float_to_double (//lux.unary ..float ..double))
       (with extension/jvm.conversion_float_to_int (//lux.unary ..float ..int))
       (with extension/jvm.conversion_float_to_long (//lux.unary ..float ..long))
       
       (with extension/jvm.conversion_int_to_byte (//lux.unary ..int ..byte))
       (with extension/jvm.conversion_int_to_char (//lux.unary ..int ..char))
       (with extension/jvm.conversion_int_to_double (//lux.unary ..int ..double))
       (with extension/jvm.conversion_int_to_float (//lux.unary ..int ..float))
       (with extension/jvm.conversion_int_to_long (//lux.unary ..int ..long))
       (with extension/jvm.conversion_int_to_short (//lux.unary ..int ..short))
       
       (with extension/jvm.conversion_long_to_double (//lux.unary ..long ..double))
       (with extension/jvm.conversion_long_to_float (//lux.unary ..long ..float))
       (with extension/jvm.conversion_long_to_int (//lux.unary ..long ..int))
       (with extension/jvm.conversion_long_to_short (//lux.unary ..long ..short))
       (with extension/jvm.conversion_long_to_byte (//lux.unary ..long ..byte))
       (with extension/jvm.conversion_long_to_char (//lux.unary ..long ..char))
       
       (with extension/jvm.conversion_char_to_byte (//lux.unary ..char ..byte))
       (with extension/jvm.conversion_char_to_short (//lux.unary ..char ..short))
       (with extension/jvm.conversion_char_to_int (//lux.unary ..char ..int))
       (with extension/jvm.conversion_char_to_long (//lux.unary ..char ..long))
       
       (with extension/jvm.conversion_byte_to_long (//lux.unary ..byte ..long))
       
       (with extension/jvm.conversion_short_to_long (//lux.unary ..short ..long))
       ))

(the with_int
  (Change Bundle)
  (|>> (with extension/jvm.int_+ (//lux.binary ..int ..int ..int))
       (with extension/jvm.int_- (//lux.binary ..int ..int ..int))
       (with extension/jvm.int_x (//lux.binary ..int ..int ..int))
       (with extension/jvm.int_/ (//lux.binary ..int ..int ..int))
       (with extension/jvm.int_% (//lux.binary ..int ..int ..int))
       (with extension/jvm.int_= (//lux.binary ..int ..int @type.Bit))
       (with extension/jvm.int_< (//lux.binary ..int ..int @type.Bit))
       (with extension/jvm.int_and (//lux.binary ..int ..int ..int))
       (with extension/jvm.int_or (//lux.binary ..int ..int ..int))
       (with extension/jvm.int_xor (//lux.binary ..int ..int ..int))
       (with extension/jvm.int_shl (//lux.binary ..int ..int ..int))
       (with extension/jvm.int_shr (//lux.binary ..int ..int ..int))
       (with extension/jvm.int_ushr (//lux.binary ..int ..int ..int))
       ))

(the with_long
  (Change Bundle)
  (|>> (with extension/jvm.long_+ (//lux.binary ..long ..long ..long))
       (with extension/jvm.long_- (//lux.binary ..long ..long ..long))
       (with extension/jvm.long_x (//lux.binary ..long ..long ..long))
       (with extension/jvm.long_/ (//lux.binary ..long ..long ..long))
       (with extension/jvm.long_% (//lux.binary ..long ..long ..long))
       (with extension/jvm.long_= (//lux.binary ..long ..long @type.Bit))
       (with extension/jvm.long_< (//lux.binary ..long ..long @type.Bit))
       (with extension/jvm.long_and (//lux.binary ..long ..long ..long))
       (with extension/jvm.long_or (//lux.binary ..long ..long ..long))
       (with extension/jvm.long_xor (//lux.binary ..long ..long ..long))
       (with extension/jvm.long_shl (//lux.binary ..int ..long ..long))
       (with extension/jvm.long_shr (//lux.binary ..int ..long ..long))
       (with extension/jvm.long_ushr (//lux.binary ..int ..long ..long))
       ))

(the with_float
  (Change Bundle)
  (|>> (with extension/jvm.float_+ (//lux.binary ..float ..float ..float))
       (with extension/jvm.float_- (//lux.binary ..float ..float ..float))
       (with extension/jvm.float_x (//lux.binary ..float ..float ..float))
       (with extension/jvm.float_/ (//lux.binary ..float ..float ..float))
       (with extension/jvm.float_% (//lux.binary ..float ..float ..float))
       (with extension/jvm.float_= (//lux.binary ..float ..float @type.Bit))
       (with extension/jvm.float_< (//lux.binary ..float ..float @type.Bit))
       ))

(the with_double
  (Change Bundle)
  (|>> (with extension/jvm.double_+ (//lux.binary ..double ..double ..double))
       (with extension/jvm.double_- (//lux.binary ..double ..double ..double))
       (with extension/jvm.double_x (//lux.binary ..double ..double ..double))
       (with extension/jvm.double_/ (//lux.binary ..double ..double ..double))
       (with extension/jvm.double_% (//lux.binary ..double ..double ..double))
       (with extension/jvm.double_= (//lux.binary ..double ..double @type.Bit))
       (with extension/jvm.double_< (//lux.binary ..double ..double @type.Bit))
       ))

(the with_char
  (Change Bundle)
  (let [type (reflection.reflection reflection.char)]
    (|>> (with extension/jvm.char_= (//lux.binary ..char ..char @type.Bit))
         (with extension/jvm.char_< (//lux.binary ..char ..char @type.Bit))
         )))

(the .public boxes
  (Dictionary external.Name [external.Name (Type Primitive)])
  (|> (list [(reflection.reflection reflection.boolean) [box.boolean jvm.boolean]]
            [(reflection.reflection reflection.byte)    [box.byte jvm.byte]]
            [(reflection.reflection reflection.short)   [box.short jvm.short]]
            [(reflection.reflection reflection.int)     [box.int jvm.int]]
            [(reflection.reflection reflection.long)    [box.long jvm.long]]
            [(reflection.reflection reflection.float)   [box.float jvm.float]]
            [(reflection.reflection reflection.double)  [box.double jvm.double]]
            [(reflection.reflection reflection.char)    [box.char jvm.char]])
      (dictionary.of_list text.hash)))

(the (jvm_type luxT)
  (-> .Type (Operation (Type Value)))
  (when luxT
    (type.Function _ _)
    (phase:pure function.class)
    
    {.:Named name anonymousT}
    (jvm_type anonymousT)
    
    {.:Reification inputT abstractionT}
    (when (type.reified (list inputT) abstractionT)
      {.:Some outputT}
      (jvm_type outputT)

      {.:None}
      (analysis.except ..non_jvm_type luxT))

    (@type.Array _ elemT)
    (phase:each jvm.array (jvm_type elemT))

    {.:Nominal class parametersT}
    (when (dictionary.value class ..boxes)
      {try.:Success [_ primitive_type]}
      (when parametersT
        (list)
        (phase:pure primitive_type)

        _
        (analysis.except ..primitives_cannot_have_type_parameters class))

      {try.:Failure _}
      (monad.let [! phase.monad]
        [parametersJT (is (Operation (List (Type Parameter)))
                          (list.each' !
                                      (function (_ [polarity parameterT])
                                        (monad.let phase.monad
                                          [parameterJT (jvm_type parameterT)]
                                          (when (projection.parameter? parameterJT)
                                            {.:Some parameterJT}
                                            (pure parameterJT)
                                            
                                            {.:None}
                                            (analysis.except ..non_parameter parameterT))))
                                      parametersT))]
        (pure (jvm.class parametersJT class))))

    {.:Variable .special _}
    (phase:pure (jvm.class (list) ..object_class))

    _
    (analysis.except ..non_jvm_type luxT)))

(the (jvm_array_type objectT)
  (-> .Type
      (Operation (Type Array)))
  (monad.let phase.monad
    [objectJ (jvm_type objectT)]
    (|> objectJ
        ..signature
        (<text>.value projection.array)
        phase.of_try)))

(the (primitive_array_length_handler primitive_type)
  (-> (Type Primitive)
      (-> Text Handler))
  (..custom
   [?list.any
    (function (_ extension_name analyse archive [arrayC])
      (monad.let phase.monad
        [_ (typeA.inference ..int)
         arrayA (<| (typeA.with {.:Nominal (|> (jvm.array primitive_type)
                                               ..reflection)
                                           (list)})
                    (analyse archive arrayC))
         @ analysis.provenance]
        (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                (list arrayA)})))]))

(the array:length:object
  (-> Text Handler)
  (..custom
   [?list.any
    (function (_ extension_name analyse archive [arrayC])
      (<| typeA.with_var (function (_ [_ to_write]))
          typeA.with_var (function (_ [_ to_read]))
          (monad.let phase.monad
            [_ (typeA.inference ..int)
             arrayA (<| (typeA.with (@type.Array to_write to_read))
                        (analyse archive arrayC))
             to_read (typeA.check (check.clean (list) to_read))
             to_write (typeA.check (check.clean (list) to_write))
             arrayJT (jvm_array_type (@type.Array to_write to_read))
             @ analysis.provenance]
            (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                    (list (analysis.text @ (..signature arrayJT))
                                          arrayA)}))))]))

(the (new_primitive_array_handler primitive_type)
  (-> (Type Primitive)
      (-> Text Handler))
  (..custom
   [?list.any
    (function (_ extension_name analyse archive [lengthC])
      (monad.let phase.monad
        [lengthA (<| (typeA.with ..int)
                     (analyse archive lengthC))
         _ (typeA.inference {.:Nominal (|> (jvm.array primitive_type) ..reflection)
                                       (list)})
         @ analysis.provenance]
        (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                (list lengthA)})))]))

(the array:new:object
  (-> Text Handler)
  (..custom
   [?list.any
    (function (_ extension_name analyse archive [lengthC])
      (monad.let [! phase.monad]
        [lengthA (<| (typeA.with ..int)
                     (analyse archive lengthC))
         expectedT analysis.expected_type
         .let [expectedT (@type.old expectedT)]
         expectedJT (jvm_array_type expectedT)
         elementJT (when (projection.array? expectedJT)
                     {.:Some elementJT}
                     (pure elementJT)
                     
                     {.:None}
                     (analysis.except ..non_array [expectedT]))
         @ analysis.provenance]
        (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                (list (analysis.text @ (..signature elementJT))
                                      lengthA)})))]))

(the (check_parameter objectT)
  (-> .Type
      (Operation (Type Parameter)))
  (`` (when objectT
        (type.Function _ _)
        (phase:pure function.class)

        (@type.Array _ elementT)
        (analysis.except ..non_parameter objectT)
        
        {.:Nominal name parameters}
        (`` (if (or (,, (template.with [<type>]
                          [(text.= (..reflection <type>) name)]

                          [[jvm.boolean]
                           [jvm.byte]
                           [jvm.short]
                           [jvm.int]
                           [jvm.long]
                           [jvm.float]
                           [jvm.double]
                           [jvm.char]]))
                    (text.starts_with? descriptor.array_prefix name))
                (analysis.except ..non_parameter objectT)

                ... else
                (phase:pure (jvm.class (list) name))))

        {.:Named name anonymous}
        (check_parameter anonymous)

        {.:Variable .general @var}
        (monad.let phase.monad
          [:var: (phase.try (typeA.check (check.type @var)))]
          (when :var:
            {try.:Success :var:}
            (check_parameter :var:)
            
            un_bound!
            (pure (jvm.class (list) ..object_class))))

        (^.or {.:Variable .special _}
              {.:Parameter _})
        (phase:pure (jvm.class (list) ..object_class))

        {.:Quantification quantification env unquantified}
        (check_parameter unquantified)

        {.:Reification inputT abstractionT}
        (when (type.reified (list inputT) abstractionT)
          {.:Some outputT}
          (check_parameter outputT)

          {.:None}
          (analysis.except ..non_parameter objectT)))))

(the (check_jvm objectT)
  (-> .Type
      (Operation (Type Value)))
  (`` (when objectT
        {.:Nominal name (list)}
        (`` (if (,, (template.with [<type>]
                      [(text.= (..reflection <type>) name)
                       (phase:pure <type>)]

                      [[jvm.boolean]
                       [jvm.byte]
                       [jvm.short]
                       [jvm.int]
                       [jvm.long]
                       [jvm.float]
                       [jvm.double]
                       [jvm.char]]))

                (,, (template.with [<type>]
                      [(text.= (..reflection (jvm.array <type>)) name)
                       (phase:pure (jvm.array <type>))]

                      [[jvm.boolean]
                       [jvm.byte]
                       [jvm.short]
                       [jvm.int]
                       [jvm.long]
                       [jvm.float]
                       [jvm.double]
                       [jvm.char]]))

                (text.starts_with? descriptor.array_prefix name)
                (let [[_ unprefixed] (maybe.trusted (text.split_by descriptor.array_prefix name))]
                  (by phase.monad each jvm.array
                      (check_jvm {.:Nominal unprefixed (list)})))

                ... else
                (phase:pure (jvm.class (list) name))))

        (@type.Array _ elementT)
        (|> elementT
            check_jvm
            (phase:each jvm.array))
        
        {.:Nominal name parameters}
        (monad.let [! phase.monad]
          [parameters (list.each' ! (|>> product.right check_parameter) parameters)]
          (phase:pure (jvm.class parameters name)))

        {.:Named name anonymous}
        (check_jvm anonymous)

        {.:Quantification quantification env unquantified}
        (check_jvm unquantified)

        {.:Reification inputT abstractionT}
        (when (type.reified (list inputT) abstractionT)
          {.:Some outputT}
          (check_jvm outputT)

          {.:None}
          (analysis.except ..non_object objectT))

        _
        (check_parameter objectT))))

(template.with [<name> <category> <projection>]
  [(the .public (<name> mapping typeJ)
     (-> Mapping (Type <category>)
         (Operation .Type))
     (when (|> typeJ ..signature (<text>.value (<projection> mapping)))
       {try.:Success check}
       (typeA.check check)
       
       {try.:Failure error}
       (phase.failure error)))]

  [[boxed_reflection_type Value luxT.boxed_type]
   [reflection_type Value luxT.type]
   [boxed_reflection_return Return luxT.boxed_return]
   [reflection_return Return luxT.return]])

(the (check_object objectT)
  (-> .Type
      (Operation [external.Name .Type]))
  (monad.let [! phase.monad]
    [:object: (check_jvm objectT)
     .let [name (..reflection :object:)]]
    (if (dictionary.in_domain? ..boxes name)
        (analysis.except ..primitives_are_not_objects [name])
        (monad.let !
          [:object: (reflection_type luxT.fresh :object:)]
          (phase:pure [name :object:])))))

(the (check_return type)
  (-> .Type
      (Operation (Type Return)))
  (if (identical? .Any type)
      (phase:pure jvm.void)
      (check_jvm type)))

(the (read_primitive_array_handler lux_type jvm_type)
  (-> .Type (Type Primitive)
      (-> Text Handler))
  (..custom
   [(<>.and ?list.any ?list.any)
    (function (_ extension_name analyse archive [idxC arrayC])
      (monad.let phase.monad
        [_ (typeA.inference lux_type)
         idxA (<| (typeA.with ..int)
                  (analyse archive idxC))
         arrayA (<| (typeA.with {.:Nominal (|> (jvm.array jvm_type) ..reflection)
                                           (list)})
                    (analyse archive arrayC))
         @ analysis.provenance]
        (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                (list idxA arrayA)})))]))

(the array:read:object
  (-> Text Handler)
  (..custom
   [(<>.and ?list.any ?list.any)
    (function (_ extension_name analyse archive [idxC arrayC])
      (<| typeA.with_var (function (_ [_ to_write]))
          typeA.with_var (function (_ [_ to_read]))
          (monad.let phase.monad
            [_ (typeA.inference to_read)
             arrayA (<| (typeA.with (@type.Array to_write to_read))
                        (analyse archive arrayC))
             idxA (<| (typeA.with ..int)
                      (analyse archive idxC))
             to_read (typeA.check (check.clean (list) to_read))
             to_write (typeA.check (check.clean (list) to_write))
             arrayJT (jvm_array_type (@type.Array to_write to_read))
             @ analysis.provenance]
            (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                    (list (analysis.text @ (..signature arrayJT))
                                          idxA
                                          arrayA)}))))]))

(the (write_primitive_array_handler lux_type jvm_type)
  (-> .Type (Type Primitive)
      (-> Text Handler))
  (let [array_type {.:Nominal (|> (jvm.array jvm_type) ..reflection)
                              (list)}]
    (..custom
     [(all <>.and ?list.any ?list.any ?list.any)
      (function (_ extension_name analyse archive [idxC valueC arrayC])
        (monad.let phase.monad
          [_ (typeA.inference array_type)
           idxA (<| (typeA.with ..int)
                    (analyse archive idxC))
           valueA (<| (typeA.with lux_type)
                      (analyse archive valueC))
           arrayA (<| (typeA.with array_type)
                      (analyse archive arrayC))
           @ analysis.provenance]
          (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                  (list idxA
                                        valueA
                                        arrayA)})))])))

(the array:write:object
  (-> Text Handler)
  (..custom
   [(all <>.and ?list.any ?list.any ?list.any)
    (function (_ extension_name analyse archive [idxC valueC arrayC])
      (<| typeA.with_var (function (_ [_ to_write]))
          typeA.with_var (function (_ [_ to_read]))
          (monad.let phase.monad
            [_ (typeA.inference (@type.Array to_write to_read))
             arrayA (<| (typeA.with (@type.Array to_write to_read))
                        (analyse archive arrayC))
             idxA (<| (typeA.with ..int)
                      (analyse archive idxC))
             valueA (<| (typeA.with to_write)
                        (analyse archive valueC))
             to_read (typeA.check (check.clean (list) to_read))
             to_write (typeA.check (check.clean (list) to_write))
             arrayJT (jvm_array_type (@type.Array to_write to_read))
             @ analysis.provenance]
            (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                    (list (analysis.text @ (..signature arrayJT))
                                          idxA
                                          valueA
                                          arrayA)}))))]))

(the with_array
  (Change Bundle)
  (|>> (with extension/jvm.array_length_boolean (primitive_array_length_handler jvm.boolean))
       (with extension/jvm.array_length_byte (primitive_array_length_handler jvm.byte))
       (with extension/jvm.array_length_short (primitive_array_length_handler jvm.short))
       (with extension/jvm.array_length_int (primitive_array_length_handler jvm.int))
       (with extension/jvm.array_length_long (primitive_array_length_handler jvm.long))
       (with extension/jvm.array_length_float (primitive_array_length_handler jvm.float))
       (with extension/jvm.array_length_double (primitive_array_length_handler jvm.double))
       (with extension/jvm.array_length_char (primitive_array_length_handler jvm.char))
       (with extension/jvm.array_length_object array:length:object)

       (with extension/jvm.array_new_boolean (new_primitive_array_handler jvm.boolean))
       (with extension/jvm.array_new_byte (new_primitive_array_handler jvm.byte))
       (with extension/jvm.array_new_short (new_primitive_array_handler jvm.short))
       (with extension/jvm.array_new_int (new_primitive_array_handler jvm.int))
       (with extension/jvm.array_new_long (new_primitive_array_handler jvm.long))
       (with extension/jvm.array_new_float (new_primitive_array_handler jvm.float))
       (with extension/jvm.array_new_double (new_primitive_array_handler jvm.double))
       (with extension/jvm.array_new_char (new_primitive_array_handler jvm.char))
       (with extension/jvm.array_new_object array:new:object)

       (with extension/jvm.array_read_boolean (read_primitive_array_handler ..boolean jvm.boolean))
       (with extension/jvm.array_read_byte (read_primitive_array_handler ..byte jvm.byte))
       (with extension/jvm.array_read_short (read_primitive_array_handler ..short jvm.short))
       (with extension/jvm.array_read_int (read_primitive_array_handler ..int jvm.int))
       (with extension/jvm.array_read_long (read_primitive_array_handler ..long jvm.long))
       (with extension/jvm.array_read_float (read_primitive_array_handler ..float jvm.float))
       (with extension/jvm.array_read_double (read_primitive_array_handler ..double jvm.double))
       (with extension/jvm.array_read_char (read_primitive_array_handler ..char jvm.char))
       (with extension/jvm.array_read_object array:read:object)

       (with extension/jvm.array_write_boolean (write_primitive_array_handler ..boolean jvm.boolean))
       (with extension/jvm.array_write_byte (write_primitive_array_handler ..byte jvm.byte))
       (with extension/jvm.array_write_short (write_primitive_array_handler ..short jvm.short))
       (with extension/jvm.array_write_int (write_primitive_array_handler ..int jvm.int))
       (with extension/jvm.array_write_long (write_primitive_array_handler ..long jvm.long))
       (with extension/jvm.array_write_float (write_primitive_array_handler ..float jvm.float))
       (with extension/jvm.array_write_double (write_primitive_array_handler ..double jvm.double))
       (with extension/jvm.array_write_char (write_primitive_array_handler ..char jvm.char))
       (with extension/jvm.array_write_object array:write:object)
       ))

(the object:null
  (-> Text Handler)
  (..custom
   [(<>:pure [])
    (function (_ extension_name analyse archive [])
      (monad.let phase.monad
        [expectedT analysis.expected_type
         .let [expectedT (@type.old expectedT)]
         [_ :object:] (check_object expectedT)
         _ (typeA.inference :object:)
         @ analysis.provenance]
        (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                (list)})))]))

(the object:null?
  (-> Text Handler)
  (..custom
   [?list.any
    (function (_ extension_name analyse archive [objectC])
      (monad.let phase.monad
        [_ (typeA.inference @type.Bit)
         [objectT objectA] (typeA.inferring
                            (analyse archive objectC))
         _ (check_object objectT)
         @ analysis.provenance]
        (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                (list objectA)})))]))

(the object:synchronized
  (-> Text Handler)
  (..custom
   [(<>.and ?list.any ?list.any)
    (function (_ extension_name analyse archive [monitorC exprC])
      (monad.let phase.monad
        [[monitorT monitorA] (typeA.inferring
                              (analyse archive monitorC))
         _ (check_object monitorT)
         exprA (analyse archive exprC)
         @ analysis.provenance]
        (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                (list monitorA exprA)})))]))

(the (object:throw class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [?list.any
    (function (_ extension_name analyse archive [exceptionC])
      (monad.let phase.monad
        [_ (typeA.inference Nothing)
         [exceptionT exceptionA] (typeA.inferring
                                  (analyse archive exceptionC))
         [exception_class _] (check_object exceptionT)
         ? (phase.of_try (reflection!.sub? class_loader "java.lang.Throwable" exception_class))
         _ (is (Operation Any)
               (if ?
                   (pure [])
                   (analysis.except non_throwable exception_class)))
         @ analysis.provenance]
        (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                (list exceptionA)})))]))

(the (object:class class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [<code>.text
    (function (_ extension_name analyse archive [class])
      (monad.let phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         _ (typeA.inference {.:Nominal "java.lang.Class" (list [.co_variant {.:Nominal class (list)}])})
         _ (phase.of_try (reflection!.load class_loader class))
         @ analysis.provenance]
        (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                (list (analysis.text @ class))})))]))

(the (object:instance? class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [(all <>.and <code>.text ?list.any)
    (function (_ extension_name analyse archive [sub_class objectC])
      (monad.let phase.monad
        [_ (..ensure_fresh_class! class_loader sub_class)
         _ (typeA.inference @type.Bit)
         [objectT objectA] (typeA.inferring
                            (analyse archive objectC))
         [object_class _] (check_object objectT)
         ? (phase.of_try (reflection!.sub? class_loader object_class sub_class))
         @ analysis.provenance]
        (if ?
            (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                    (list (analysis.text @ sub_class) objectA)})
            (analysis.except cannot_possibly_be_an_instance (text sub_class " !<= "  object_class)))))]))

(the (class_candidate_parents class_loader from_name fromT to_name to_class)
  (-> java/lang/ClassLoader external.Name .Type external.Name (java/lang/Class java/lang/Object)
      (Operation (List [[Text .Type] Bit])))
  (monad.let [! phase.monad]
    [from_class (phase.of_try (reflection!.load class_loader from_name))
     mapping (phase.of_try (reflection!.correspond from_class fromT))]
    (list.each' !
                (function (_ superJT)
                  (monad.let !
                    [superJT (phase.of_try (reflection!.type superJT))
                     .let [super_name (..reflection superJT)]
                     super_class (phase.of_try (reflection!.load class_loader super_name))
                     superT (reflection_type mapping superJT)]
                    (pure [[super_name superT]
                           (ffi.of_boolean (java/lang/Class:isAssignableFrom [super_class] to_class))])))
                (when (java/lang/Class:getGenericSuperclass [] from_class)
                  {.:Some super}
                  (list:composite (list super)
                                  (list.of_array {.:None} (java/lang/Class:getGenericInterfaces [] from_class)))

                  {.:None}
                  (if (|> from_class
                          (java/lang/Class:getModifiers [])
                          [] java/lang/reflect/Modifier:isInterface
                          ffi.of_boolean)
                      (list:composite (list (as (-> Any java/lang/reflect/Type)
                                                (ffi.class_for java/lang/Object)))
                                      (list.of_array {.:None} (java/lang/Class:getGenericInterfaces [] from_class)))
                      (list.of_array {.:None} (java/lang/Class:getGenericInterfaces [] from_class)))))))

(the (object:cast class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [?list.any
    (function (_ extension_name analyse archive [fromC])
      (monad.let [! phase.monad]
        [toT analysis.expected_type
         .let [toT (@type.old toT)]
         toJT (check_jvm toT)
         [fromT fromA] (typeA.inferring
                        (analyse archive fromC))
         fromJT (check_jvm fromT)
         .let [from_name (..reflection fromJT)
               to_name (..reflection toJT)]
         can_cast? (is (Operation Bit)
                       (`` (if (,, (template.with [<primitive> <object>]
                                     [(let [=primitive (reflection.reflection <primitive>)]
                                        (or (and (text.= =primitive from_name)
                                                 (or (text.= <object> to_name)
                                                     (text.= =primitive to_name)))
                                            (and (text.= <object> from_name)
                                                 (text.= =primitive to_name))))
                                      (pure true)]

                                     [[reflection.boolean box.boolean]
                                      [reflection.byte    box.byte]
                                      [reflection.short   box.short]
                                      [reflection.int     box.int]
                                      [reflection.long    box.long]
                                      [reflection.float   box.float]
                                      [reflection.double  box.double]
                                      [reflection.char    box.char]]))

                               ... else
                               (monad.let !
                                 [_ (phase.assertion ..primitives_are_not_objects [from_name]
                                                     (not (dictionary.in_domain? ..boxes from_name)))
                                  _ (phase.assertion ..primitives_are_not_objects [to_name]
                                                     (not (dictionary.in_domain? ..boxes to_name)))
                                  to_class (phase.of_try (reflection!.load class_loader to_name))
                                  from_class (phase.of_try (reflection!.load class_loader from_name))]
                                 (if (ffi.of_boolean (java/lang/Class:isAssignableFrom [from_class] to_class))
                                     (loop (of [[current_name currentT] [from_name fromT]])
                                       (if (text.= to_name current_name)
                                           (pure true)
                                           (monad.let !
                                             [candidate_parents (is (Operation (List [[Text .Type] Bit]))
                                                                    (class_candidate_parents class_loader current_name currentT to_name to_class))]
                                             (when (|> candidate_parents
                                                       (list.only product.right)
                                                       (list:each product.left)
                                                       (list.item 0))
                                               {try.:Success [next_name nextT]}
                                               (of [next_name nextT])

                                               {try.:Failure _}
                                               (pure false)))))
                                     (pure (when [(type.= java/lang/Object fromT)
                                                  (projection.array? toJT)]
                                             [.true {.:Some _}]
                                             true
                                             
                                             _
                                             false)))))))
         @ analysis.provenance]
        (if can_cast?
            (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                    (list (analysis.text @ from_name)
                                          (analysis.text @ to_name)
                                          fromA)})
            (monad.let !
              [here phase.name_of_current_module]
              (analysis.except ..cannot_cast [here fromJT toJT fromC])))))]))

(the (with_object class_loader)
  (-> java/lang/ClassLoader
      (Change Bundle))
  (|>> (with extension/jvm.object_null object:null)
       (with extension/jvm.object_null? object:null?)
       (with extension/jvm.object_synchronized object:synchronized)
       (with extension/jvm.object_throw (object:throw class_loader))
       (with extension/jvm.object_class (object:class class_loader))
       (with extension/jvm.object_instance? (object:instance? class_loader))
       (with extension/jvm.object_cast (object:cast class_loader))
       ))

(the (get:static class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [..member
    (function (_ extension_name analyse archive [class field])
      (monad.let phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         [final? deprecated? fieldJT] (phase.of_try
                                       (monad.let try.monad
                                         [class (reflection!.load class_loader class)]
                                         (reflection!.static_field field class)))
         _ (phase.assertion ..deprecated_field [class field]
                            (not deprecated?))
         fieldT (reflection_type luxT.fresh fieldJT)
         _ (typeA.inference fieldT)
         @ analysis.provenance]
        (pure (<| {@type.:Extension @ [.prelude (extension.synthesis extension_name)]}
                  (list (analysis.text @ class)
                        (analysis.text @ field)
                        (analysis.text @ (..signature fieldJT)))))))]))

(the (put:static class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [(all <>.and ..member ?list.any)
    (function (_ extension_name analyse archive [[class field] valueC])
      (monad.let phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         _ (typeA.inference Any)
         [final? deprecated? fieldJT] (phase.of_try
                                       (monad.let try.monad
                                         [class (reflection!.load class_loader class)]
                                         (reflection!.static_field field class)))
         _ (phase.assertion ..deprecated_field [class field]
                            (not deprecated?))
         ... _ (phase.assertion ..cannot_set_a_final_field [class field]
         ...                    (not final?))
         fieldT (reflection_type luxT.fresh fieldJT)
         valueA (<| (typeA.with fieldT)
                    (analyse archive valueC))
         @ analysis.provenance]
        (pure (<| {@type.:Extension @ [.prelude (extension.synthesis extension_name)]}
                  (list (analysis.text @ class)
                        (analysis.text @ field)
                        (analysis.text @ (..signature fieldJT))
                        valueA)))))]))

(the (get:virtual class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [(all <>.and ..member ?list.any)
    (function (_ extension_name analyse archive [[class field] objectC])
      (monad.let phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         [objectT objectA] (typeA.inferring
                            (analyse archive objectC))
         [deprecated? mapping fieldJT] (phase.of_try
                                        (monad.let try.monad
                                          [class (reflection!.load class_loader class)
                                           [final? deprecated? fieldJT] (reflection!.virtual_field field class)
                                           mapping (reflection!.correspond class objectT)]
                                          (pure [deprecated? mapping fieldJT])))
         _ (phase.assertion ..deprecated_field [class field]
                            (not deprecated?))
         fieldT (reflection_type mapping fieldJT)
         _ (typeA.inference fieldT)
         @ analysis.provenance]
        (pure (<| {@type.:Extension @ [.prelude (extension.synthesis extension_name)]}
                  (list (analysis.text @ class)
                        (analysis.text @ field)
                        (analysis.text @ (..signature fieldJT))
                        objectA)))))]))

(the (put:virtual class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [(all <>.and ..member ?list.any ?list.any)
    (function (_ extension_name analyse archive [[class field] valueC objectC])
      (monad.let phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         [objectT objectA] (typeA.inferring
                            (analyse archive objectC))
         _ (typeA.inference objectT)
         [final? deprecated? mapping fieldJT] (phase.of_try
                                               (monad.let try.monad
                                                 [class (reflection!.load class_loader class)
                                                  [final? deprecated? fieldJT] (reflection!.virtual_field field class)
                                                  mapping (reflection!.correspond class objectT)]
                                                 (pure [final? deprecated? mapping fieldJT])))
         _ (phase.assertion ..deprecated_field [class field]
                            (not deprecated?))
         _ (phase.assertion ..cannot_set_a_final_field [class field]
                            (not final?))
         fieldT (reflection_type mapping fieldJT)
         valueA (<| (typeA.with fieldT)
                    (analyse archive valueC))
         @ analysis.provenance]
        (pure (<| {@type.:Extension @ [.prelude (extension.synthesis extension_name)]}
                  (list (analysis.text @ class)
                        (analysis.text @ field)
                        (analysis.text @ (..signature fieldJT))
                        valueA
                        objectA)))))]))

(.every Method_Style
  (Variant
   {:Static}
   {:Abstract}
   {:Virtual}
   {:Special}
   {:Interface}))

(the (de_aliased aliasing)
  (-> Aliasing
      (Change (Type Value)))
  (function (of it)
    (`` (<| (when (projection.var? it)
              {.:Some name}
              (|> aliasing
                  (dictionary.value name)
                  (try:each jvm.var)
                  (try.else it))
              
              {.:None})
            (when (projection.class? it)
              {.:Some [parameters name]}
              (|> parameters
                  (list:each (|>> of (as (-> (Type Value) (Type Parameter)))))
                  (|.let parameters (jvm.class parameters name)))
              
              {.:None})
            (,, (template.with [<read> <as> <write>]
                  [(when (<read> it)
                     {.:Some :sub:}
                     (<write> (as (-> (Type Value) (Type <as>)) (of :sub:)))
                     
                     {.:None})]

                  [[projection.array? Value jvm.array]
                   [projection.lower? Class jvm.lower]
                   [projection.upper? Class jvm.upper]]))
            it))))

(the (check_method aliasing class method_name method_style inputsJT method)
  (-> Aliasing (java/lang/Class java/lang/Object) Text Method_Style (List (Type Value)) java/lang/reflect/Method
      (Operation Bit))
  (monad.let phase.monad
    [parameters (|> method
                    (java/lang/reflect/Method:getGenericParameterTypes [])
                    (list.of_array {.:None})
                    (list.each' try.monad reflection!.type)
                    phase.of_try)
     .let [modifiers (java/lang/reflect/Method:getModifiers [] method)
           correct_class? (|> method
                              (java/lang/reflect/Method:getDeclaringClass [])
                              (java/lang/Class:isAssignableFrom [class])
                              ffi.of_boolean)
           correct_method? (|> method
                               (java/lang/reflect/Method:getName [])
                               ffi.of_string
                               (text.= method_name))
           same_static? (when method_style
                          {:Static}
                          (ffi.of_boolean (java/lang/reflect/Modifier:isStatic [modifiers]))

                          _
                          true)
           same_special? (when method_style
                           {:Special}
                           (not (or (ffi.of_boolean (java/lang/reflect/Modifier:isInterface [(java/lang/Class:getModifiers [] class)]))
                                    (ffi.of_boolean (java/lang/reflect/Modifier:isAbstract [modifiers]))))

                           _
                           true)
           same_inputs? (and (n.= (list.size inputsJT)
                                  (list.size parameters))
                             (list.every? (function (_ [expectedJC actualJC])
                                            (jvm.= expectedJC (de_aliased aliasing actualJC)))
                                          (list.zipped_2 parameters inputsJT)))]]
    (pure (and correct_class?
               correct_method?
               same_static?
               same_special?
               same_inputs?))))

(the (check_constructor aliasing class inputsJT constructor)
  (-> Aliasing (java/lang/Class java/lang/Object) (List (Type Value)) (java/lang/reflect/Constructor java/lang/Object)
      (Operation Bit))
  (monad.let phase.monad
    [parameters (|> constructor
                    (java/lang/reflect/Constructor:getGenericParameterTypes [])
                    (list.of_array {.:None})
                    (list.each' try.monad reflection!.type)
                    phase.of_try)]
    (pure (and (ffi.of_boolean (|> constructor
                                   (java/lang/reflect/Constructor:getDeclaringClass [])
                                   (java/lang/Object:equals [class])))
               (n.= (list.size inputsJT) (list.size parameters))
               (list.every? (function (_ [expectedJC actualJC])
                              (jvm.= expectedJC (de_aliased aliasing actualJC)))
                            (list.zipped_2 parameters inputsJT))))))

(the index_parameter
  (-> Natural
      .Type)
  (|>> {.:Parameter .argument}))

(the (jvm_type_var_mapping owner_tvars method_tvars)
  (-> (List Text) (List Text)
      [(List .Type) Mapping])
  (let [jvm_tvars (list:composite owner_tvars method_tvars)
        lux_tvars (|> jvm_tvars
                      list.in_reverse
                      list.enumeration
                      (list:each (function (_ [idx name])
                                   [name (index_parameter idx)]))
                      list.in_reverse)
        num_owner_tvars (list.size owner_tvars)
        owner_tvarsT (|> lux_tvars
                         (list.first num_owner_tvars)
                         (list:each product.right))
        mapping (dictionary.of_list text.hash lux_tvars)]
    [owner_tvarsT mapping]))

(the (lux_class it)
  (-> (java/lang/Class java/lang/Object)
      (Type Class))
  (jvm.class (list) (ffi.of_string (java/lang/Class:getName [] it))))

(template.with [<name> <type> <params>]
  [(`` (the <name>
         (-> (<type> (,, (template.spliced <params>)))
             (List (Type Class)))
         (|>> ((,, (template.name [<type> ":getExceptionTypes"])) [])
              (list.of_array {.:None})
              (list:each ..lux_class))))]

  [[concrete_method_exceptions java/lang/reflect/Method []]
   [concrete_constructor_exceptions java/lang/reflect/Constructor [java/lang/Object]]])

(the (return_type it)
  (-> java/lang/reflect/Method
      (Try (Type Return)))
  (reflection!.return
   (when (java/lang/reflect/Method:getGenericReturnType [] it)
     {.:Some it}
     it
     
     {.:None}
     (|> it
         (java/lang/reflect/Method:getReturnType [])
         (ffi.is java/lang/reflect/Type)))))

(the (method_signature method_style method)
  (-> Method_Style java/lang/reflect/Method
      (Operation Method_Signature))
  (let [owner (java/lang/reflect/Method:getDeclaringClass [] method)
        owner_tvars (is (List Text)
                        (when method_style
                          {:Static}
                          (list)

                          _
                          (|> owner
                              (java/lang/Class:getTypeParameters [])
                              (list.of_array {.:None})
                              (list:each (|>> (java/lang/reflect/TypeVariable:getName [])
                                              ffi.of_string)))))
        method_tvars (is (List Text)
                         (|> method
                             (java/lang/reflect/Method:getTypeParameters [])
                             (list.of_array {.:None})
                             (list:each (|>> (java/lang/reflect/TypeVariable:getName [])
                                             ffi.of_string))))
        [owner_tvarsT mapping] (jvm_type_var_mapping owner_tvars method_tvars)]
    (monad.let [! phase.monad]
      [inputsT' (|> method
                    (java/lang/reflect/Method:getGenericParameterTypes [])
                    (list.of_array {.:None})
                    (list.each' ! (|>> reflection!.type phase.of_try)))
       inputsT (list.each' ! (..reflection_type mapping) inputsT')
       outputT' (|> method
                    ..return_type
                    phase.of_try)
       outputT (..reflection_return mapping outputT')
       .let [concrete_exceptions (..concrete_method_exceptions method)]
       concrete_exceptions (list.each' ! (..reflection_type mapping) concrete_exceptions)
       generic_exceptions (|> method
                              (java/lang/reflect/Method:getGenericExceptionTypes [])
                              (list.of_array {.:None})
                              (list.each' ! (|>> reflection!.type phase.of_try))
                              (phase:each (list.each' ! (..reflection_type mapping)))
                              phase:conjoint)
       .let [methodT (<| (type.univ_q (dictionary.size mapping))
                         (type.function (when method_style
                                          {:Static}
                                          inputsT

                                          _
                                          (list:composite (list {.:Nominal (ffi.of_string (java/lang/Class:getName [] owner))
                                                                           (list:each (|>> [.co_variant])
                                                                                      owner_tvarsT)})
                                                          inputsT)))
                         outputT)]]
      (pure [:method methodT
             :inputs inputsT'
             :output outputT'
             :deprecated? (|> method
                              (java/lang/reflect/Method:getDeclaredAnnotations [])
                              reflection!.deprecated?)
             :throws (if (list.empty? generic_exceptions)
                         concrete_exceptions
                         generic_exceptions)]))))

(the (constructor_signature constructor)
  (-> (java/lang/reflect/Constructor java/lang/Object)
      (Operation Method_Signature))
  (let [owner (java/lang/reflect/Constructor:getDeclaringClass [] constructor)
        owner_tvars (is (List Text)
                        (|> owner
                            (java/lang/Class:getTypeParameters [])
                            (list.of_array {.:None})
                            (list:each (|>> (java/lang/reflect/TypeVariable:getName [])
                                            ffi.of_string))))
        method_tvars (is (List Text)
                         (|> constructor
                             (java/lang/reflect/Constructor:getTypeParameters [])
                             (list.of_array {.:None})
                             (list:each (|>> (java/lang/reflect/TypeVariable:getName [])
                                             ffi.of_string))))
        [owner_tvarsT mapping] (jvm_type_var_mapping owner_tvars method_tvars)]
    (monad.let [! phase.monad]
      [inputsT' (|> constructor
                    (java/lang/reflect/Constructor:getGenericParameterTypes [])
                    (list.of_array {.:None})
                    (list.each' ! (|>> reflection!.type phase.of_try)))
       inputsT (list.each' ! (reflection_type mapping) inputsT')
       .let [concrete_exceptions (..concrete_constructor_exceptions constructor)]
       concrete_exceptions (list.each' ! (..reflection_type mapping) concrete_exceptions)
       generic_exceptions (|> constructor
                              (java/lang/reflect/Constructor:getGenericExceptionTypes [])
                              (list.of_array {.:None})
                              (list.each' ! (|>> reflection!.type phase.of_try))
                              (phase:each (list.each' ! (reflection_type mapping)))
                              phase:conjoint)
       .let [objectT {.:Nominal (ffi.of_string (java/lang/Class:getName [] owner))
                                (list:each (|>> [.co_variant])
                                           owner_tvarsT)}
             constructorT (<| (type.univ_q (dictionary.size mapping))
                              (type.function inputsT)
                              objectT)]]
      (pure [:method constructorT
             :inputs inputsT'
             :output jvm.void
             :deprecated? (|> constructor
                              (java/lang/reflect/Constructor:getDeclaredAnnotations [])
                              reflection!.deprecated?)
             :throws (if (list.empty? generic_exceptions)
                         concrete_exceptions
                         generic_exceptions)]))))

(.every Evaluation
  (Variant
   {:Pass Method_Signature}
   {:Hint Method_Signature}))

(template.with [<name> <tag>]
  [(the <name>
     (-> Evaluation
         (Maybe Method_Signature))
     (|>> (|.when
            {<tag> output}
            {.:Some output}

            _
            {.:None})))]

  [[pass :Pass]
   [hint :Hint]])

(template.with [<name> <type> <method>]
  [(the <name>
     (-> <type>
         (List (Type Var)))
     (|>> (<method> [])
          (list.of_array {.:None})
          (list:each (|>> (java/lang/reflect/TypeVariable:getName [])
                          ffi.of_string
                          jvm.var))))]

  [[class_type_variables (java/lang/Class java/lang/Object) java/lang/Class:getTypeParameters]
   [constructor_type_variables (java/lang/reflect/Constructor java/lang/Object) java/lang/reflect/Constructor:getTypeParameters]
   [method_type_variables java/lang/reflect/Method java/lang/reflect/Method:getTypeParameters]])

(the (aliasing expected actual)
  (-> (List (Type Var)) (List (Type Var))
      Aliasing)
  (|> (list.zipped_2 (list:each projection.name actual)
                     (list:each projection.name expected))
      (dictionary.of_list text.hash)))

(the (family_tree' it)
  (-> (java/lang/Class java/lang/Object)
      (List (java/lang/Class java/lang/Object)))
  (let [interfaces (|> (java/lang/Class:getInterfaces [] it)
                       (list.of_array {.:None}))
        supers (when (java/lang/Class:getSuperclass [] it)
                 {.:Some class}
                 (list:composite (list class) interfaces)
                 
                 {.:None}
                 interfaces)]
    (|> supers
        (list:each family_tree')
        list:conjoint
        (list:composite (list it)))))

(the family_tree
  (-> (java/lang/Class java/lang/Object)
      (List (java/lang/Class java/lang/Object)))
  (|>> ..family_tree'
       ... De-duplication
       (list:mix (function (_ class all)
                   (dictionary.has (ffi.of_string (java/lang/Class:getName [] class)) class all))
                 (dictionary.empty text.hash))
       dictionary.values))

(the (all_declared_methods it)
  (-> (java/lang/Class java/lang/Object)
      (List java/lang/reflect/Method))
  (|> it
      ..family_tree
      (list:each (|>> (java/lang/Class:getDeclaredMethods [])
                      (list.of_array {.:None})))
      list:conjoint))

(the (method_candidate allow_inheritance? class_loader actual_class_tvars class_name actual_method_tvars method_name method_style inputsJT)
  (-> Bit java/lang/ClassLoader (List (Type Var)) external.Name (List (Type Var)) Text Method_Style (List (Type Value))
      (Operation Method_Signature))
  (monad.let [! phase.monad]
    [class (phase.of_try (reflection!.load class_loader class_name))
     .let [expected_class_tvars (class_type_variables class)]
     candidates (|> (if allow_inheritance?
                        (all_declared_methods class)
                        (|> (java/lang/Class:getDeclaredMethods [] class)
                            (list.of_array {.:None})))
                    (list.only (|>> (java/lang/reflect/Method:getName [])
                                    ffi.of_string
                                    (text.= method_name)))
                    (list.each' ! (is (-> java/lang/reflect/Method (Operation Evaluation))
                                      (function (_ method)
                                        (monad.let !
                                          [.let [expected_method_tvars (method_type_variables method)
                                                 aliasing (dictionary.composite (..aliasing expected_class_tvars actual_class_tvars)
                                                                                (..aliasing expected_method_tvars actual_method_tvars))]
                                           passes? (check_method aliasing class method_name method_style inputsJT method)]
                                          (by ! each (if passes?
                                                         (|>> {:Pass})
                                                         (|>> {:Hint}))
                                              (method_signature method_style method)))))))]
    (when (list.all pass candidates)
      (list)
      (analysis.except ..no_candidates [actual_class_tvars class_name method_name actual_method_tvars inputsJT (list.all hint candidates)])
      
      (list method)
      (pure method)
      
      every_valid_candidate
      (if allow_inheritance?
          (pure (.list_item# 0 every_valid_candidate))
          (analysis.except ..too_many_candidates [actual_class_tvars class_name method_name actual_method_tvars inputsJT every_valid_candidate])))))

(the constructor_method
  "<init>")

(the (constructor_candidate class_loader actual_class_tvars class_name actual_method_tvars inputsJT)
  (-> java/lang/ClassLoader (List (Type Var)) external.Name (List (Type Var)) (List (Type Value))
      (Operation Method_Signature))
  (monad.let [! phase.monad]
    [class (phase.of_try (reflection!.load class_loader class_name))
     .let [expected_class_tvars (class_type_variables class)]
     candidates (|> class
                    (java/lang/Class:getConstructors [])
                    (list.of_array {.:None})
                    (list.each' ! (function (_ constructor)
                                    (monad.let !
                                      [.let [expected_method_tvars (constructor_type_variables constructor)
                                             aliasing (dictionary.composite (..aliasing expected_class_tvars actual_class_tvars)
                                                                            (..aliasing expected_method_tvars actual_method_tvars))]
                                       passes? (check_constructor aliasing class inputsJT constructor)]
                                      (by ! each
                                          (if passes?
                                              (|>> {:Pass})
                                              (|>> {:Hint}))
                                          (constructor_signature constructor))))))]
    (when (list.all pass candidates)
      (list constructor)
      (pure constructor)

      (list)
      (analysis.except ..no_candidates [actual_class_tvars class_name ..constructor_method actual_method_tvars inputsJT (list.all hint candidates)])
      
      candidates
      (analysis.except ..too_many_candidates [actual_class_tvars class_name ..constructor_method actual_method_tvars inputsJT candidates]))))

(template.with [<name> <category> <projection>]
  [(the .public <name>
     (<code>.Projection (Type <category>))
     (<text>.then <projection> <code>.text))]

  [[var Var projection.var]
   [class Class projection.class]
   [type Value projection.value]
   [return Return projection.return]])

(the input
  (<code>.Projection (Typed @type.Code))
  (<code>.tuple (<>.and ..type ?list.any)))

(the (decorate_inputs @ typesT inputsA)
  (-> Provenance (List (Type Value)) (List analysis.Term)
      (List analysis.Term))
  (|> inputsA
      (list.zipped_2 (list:each (|>> ..signature (analysis.text @)) typesT))
      (list:each (function (_ [type value])
                   (analysis.tuple @ (list type value))))))

(the type_vars
  (<code>.tuple (<>.some ..var)))

(the (invoke:static class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [(all <>.and ..type_vars ..member ..type_vars (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class method] method_tvars argsTC])
      (monad.let phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         .let [argsT (list:each product.left argsTC)]
         method_candidate (..method_candidate false class_loader class_tvars class method_tvars method {:Static} argsT)
         .let [method_type (its :method method_candidate)]
         _ (phase.assertion ..deprecated_method [class method method_type]
                            (not (its :deprecated? method_candidate)))
         [outputT argsA] (inference.general archive analyse method_type (view.as list.stack (list:each product.right argsTC)))
         outputJT (check_return outputT)
         @ analysis.provenance]
        (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                (list:composite (list (analysis.text @ (..signature (jvm.class (list) class)))
                                                      (analysis.text @ method)
                                                      (analysis.text @ (..signature outputJT)))
                                                (decorate_inputs @ argsT (view.of list.stack argsA)))})))]))

(the (invoke:virtual class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [(all <>.and ..type_vars ..member ..type_vars ?list.any (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class method] method_tvars objectC argsTC])
      (monad.let phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         .let [argsT (list:each product.left argsTC)]
         method_candidate (..method_candidate true class_loader class_tvars class method_tvars method {:Virtual} argsT)
         .let [method_type (its :method method_candidate)]
         _ (phase.assertion ..deprecated_method [class method method_type]
                            (not (its :deprecated? method_candidate)))
         [outputT allA] (inference.general archive analyse method_type (stack.partial objectC (view.as list.stack (list:each product.right argsTC))))
         .let [[objectA argsA] (when allA
                                 {.:Top objectA argsA}
                                 [objectA argsA]

                                 _
                                 (undefined))]
         outputJT (check_return outputT)
         @ analysis.provenance]
        (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                (list:composite (list (analysis.text @ (..signature (jvm.class (list) class)))
                                                      (analysis.text @ method)
                                                      (analysis.text @ (..signature outputJT))
                                                      objectA)
                                                (decorate_inputs @ argsT (view.of list.stack argsA)))})))]))

(the (invoke:special class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [(all <>.and ..type_vars ..member ..type_vars ?list.any (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class method] method_tvars objectC argsTC])
      (monad.let phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         .let [argsT (list:each product.left argsTC)]
         method_candidate (..method_candidate false class_loader class_tvars class method_tvars method {:Special} argsT)
         .let [method_type (its :method method_candidate)]
         _ (phase.assertion ..deprecated_method [class method method_type]
                            (not (its :deprecated? method_candidate)))
         [outputT allA] (inference.general archive analyse method_type (stack.partial objectC (view.as list.stack (list:each product.right argsTC))))
         .let [[objectA argsA] (when allA
                                 {.:Top objectA argsA}
                                 [objectA argsA]

                                 _
                                 (undefined))]
         outputJT (check_return outputT)
         @ analysis.provenance]
        (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                (list:composite (list (analysis.text @ (..signature (jvm.class (list) class)))
                                                      (analysis.text @ method)
                                                      (analysis.text @ (..signature outputJT))
                                                      objectA)
                                                (decorate_inputs @ argsT (view.of list.stack argsA)))})))]))

(the (invoke:interface class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [(all <>.and ..type_vars ..member ..type_vars ?list.any (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class_name method] method_tvars objectC argsTC])
      (monad.let phase.monad
        [_ (..ensure_fresh_class! class_loader class_name)
         .let [argsT (list:each product.left argsTC)]
         class (phase.of_try (reflection!.load class_loader class_name))
         _ (phase.assertion non_interface class_name
                            (|> class
                                (java/lang/Class:getModifiers [])
                                [] java/lang/reflect/Modifier:isInterface
                                ffi.of_boolean))
         method_candidate (..method_candidate true class_loader class_tvars class_name method_tvars method {:Interface} argsT)
         .let [method_type (its :method method_candidate)]
         _ (phase.assertion ..deprecated_method [class_name method method_type]
                            (not (its :deprecated? method_candidate)))
         [outputT allA] (inference.general archive analyse method_type (stack.partial objectC (view.as list.stack (list:each product.right argsTC))))
         .let [[objectA argsA] (when allA
                                 {.:Top objectA argsA}
                                 [objectA argsA]

                                 _
                                 (undefined))]
         outputJT (check_return outputT)
         @ analysis.provenance]
        (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                (list:composite (list (analysis.text @ (..signature (jvm.class (list) class_name)))
                                                      (analysis.text @ method)
                                                      (analysis.text @ (..signature outputJT))
                                                      objectA)
                                                (decorate_inputs @ argsT (view.of list.stack argsA)))})))]))

(the (invoke:constructor class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [(all <>.and ..type_vars <code>.text ..type_vars (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars class method_tvars argsTC])
      (monad.let phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         .let [argsT (list:each product.left argsTC)]
         method_candidate (..constructor_candidate class_loader class_tvars class method_tvars argsT)
         .let [method_type (its :method method_candidate)]
         _ (phase.assertion ..deprecated_method [class ..constructor_method method_type]
                            (not (its :deprecated? method_candidate)))
         [outputT argsA] (inference.general archive analyse method_type (view.as list.stack (list:each product.right argsTC)))
         @ analysis.provenance]
        (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                (list:composite (list (analysis.text @ (..signature (jvm.class (list) class))))
                                                (decorate_inputs @ argsT (view.of list.stack argsA)))})))]))

(the (with_member class_loader)
  (-> java/lang/ClassLoader
      (Change Bundle))
  (|>> (with extension/jvm.member_get_static (get:static class_loader))
       (with extension/jvm.member_get_virtual (get:virtual class_loader))
       
       (with extension/jvm.member_put_static (put:static class_loader))
       (with extension/jvm.member_put_virtual (put:virtual class_loader))
       
       (with extension/jvm.member_invoke_static (invoke:static class_loader))
       (with extension/jvm.member_invoke_virtual (invoke:virtual class_loader))
       (with extension/jvm.member_invoke_special (invoke:special class_loader))
       (with extension/jvm.member_invoke_interface (invoke:interface class_loader))
       (with extension/jvm.member_invoke_constructor (invoke:constructor class_loader))
       ))

(.every .public (Annotation_Parameter a)
  [Text a])

(the annotation_parameter
  (<code>.Projection (Annotation_Parameter @type.Code))
  (<code>.tuple (<>.and <code>.text ?list.any)))

(.every .public (Annotation a)
  [Text (List (Annotation_Parameter a))])

(the .public annotation
  (<code>.Projection (Annotation @type.Code))
  (<code>.form (<>.and <code>.text (<>.some ..annotation_parameter))))

(the .public argument
  (<code>.Projection Argument)
  (<code>.tuple (<>.and <code>.text ..type)))

(the (annotation_parameter_analysis @ [name value])
  (-> Provenance (Annotation_Parameter analysis.Term)
      analysis.Term)
  (analysis.tuple @ (list (analysis.text @ name) value)))

(the (annotation_analysis @ [name parameters])
  (-> Provenance (Annotation analysis.Term)
      analysis.Term)
  (analysis.tuple @ (list:composite (list (analysis.text @ name))
                                    (list:each (annotation_parameter_analysis @) parameters))))

(template.with [<name> <category>]
  [(the (<name> @)
     (-> Provenance (Type <category>)
         analysis.Term)
     (|>> ..signature
          (analysis.text @)))]

  [[var_analysis Var]
   [class_analysis Class]
   [value_analysis Value]
   [return_analysis Return]])

(the (typed_analysis @ [type term])
  (-> Provenance (Typed analysis.Term)
      analysis.Term)
  (analysis.tuple @ (list (value_analysis @ type) term)))

(the (argument_analysis @ [argument argumentJT])
  (-> Provenance Argument
      analysis.Term)
  (<| (analysis.tuple @)
      (list (analysis.text @ argument)
            (value_analysis @ argumentJT))))

(template.with [<name> <only> <methods>]
  [(the (<name> [type class])
     (-> [(Type Class) (java/lang/Class java/lang/Object)]
         (Try (List [(Type Class) Text (Type Method)])))
     (|> class
         <methods>
         (list.only (|>> (java/lang/reflect/Method:getModifiers [])
                         (predicate.or (|>> [] java/lang/reflect/Modifier:isPublic ffi.of_boolean)
                                       (|>> [] java/lang/reflect/Modifier:isProtected ffi.of_boolean))))
         <only>
         (list.each' try.monad
                     (function (_ method)
                       (monad.let [! try.monad]
                         [.let [type_variables (|> method
                                                   (java/lang/reflect/Method:getTypeParameters [])
                                                   (list.of_array {.:None})
                                                   (list:each (|>> (java/lang/reflect/TypeVariable:getName [])
                                                                   ffi.of_string
                                                                   jvm.var)))]
                          inputs (|> method
                                     (java/lang/reflect/Method:getGenericParameterTypes [])
                                     (list.of_array {.:None})
                                     (list.each' ! reflection!.type))
                          return (..return_type method)
                          .let [concrete_exceptions (..concrete_method_exceptions method)]
                          generic_exceptions (|> method
                                                 (java/lang/reflect/Method:getGenericExceptionTypes [])
                                                 (list.of_array {.:None})
                                                 (list.each' ! reflection!.class))]
                         (pure [type
                                (ffi.of_string (java/lang/reflect/Method:getName [] method))
                                (jvm.method [type_variables inputs return (if (list.empty? generic_exceptions)
                                                                              concrete_exceptions
                                                                              generic_exceptions)])]))))))]

  [[abstract_methods (list.only (|>> (java/lang/reflect/Method:getModifiers [])
                                     [] java/lang/reflect/Modifier:isAbstract
                                     ffi.of_boolean))
    (<| (list.of_array {.:None})
        (java/lang/Class:getDeclaredMethods []))]
   [methods (<|)
    ..all_declared_methods]])

... https://en.wikipedia.org/wiki/Delimiter
(the jvm_package_delimiter ".")

(template.with [<name> <methods>]
  [(the (<name> class_loader)
     (-> java/lang/ClassLoader (List (Type Class))
         (Try (List [(Type Class) Text (Type Method)])))
     (|>> (list.each' try.monad (function (_ type)
                                  (|> type
                                      ..reflection
                                      (reflection!.load class_loader)
                                      (try:each (|>> [type])))))
          (try:each (list.each' try.monad <methods>))
          try:conjoint
          (try:each list:conjoint)))]

  [[all_abstract_methods ..abstract_methods]
   [all_methods ..methods]])

(template.with [<name>]
  [(exception.the .public (<name> [expected actual])
     (exception.Exception [(List [(Type Class) Text (Type Method)])
                           (List [(Type Class) Text (Type Method)])])
     (let [%method (is (text.Injection [(Type Class) Text (Type Method)])
                       (function (_ [super name type])
                         (text (..signature super) " : " (%.text name) " " (..signature type))))]
       (exception.report
        (list ["Expected methods" (exception.listing %method expected)]
              ["Actual methods" (exception.listing %method actual)]))))]

  [[missing_abstract_methods]
   [invalid_overriden_methods]])

(.every .public Visibility
  (Variant
   {:Public}
   {:Private}
   {:Protected}
   {:Default}))

(.every .public Finality Bit)
(.every .public Strictness Bit)

(the .public public_tag "public")
(the .public private_tag "private")
(the .public protected_tag "protected")
(the .public default_tag "default")

(the .public visibility'
  (<text>.Projection Visibility)
  (all <>.or
       (<text>.this ..public_tag)
       (<text>.this ..private_tag)
       (<text>.this ..protected_tag)
       (<text>.this ..default_tag)
       ))

(the .public visibility
  (<code>.Projection Visibility)
  (<text>.then ..visibility' <code>.text))

(the .public (visibility_analysis @ visibility)
  (-> Provenance Visibility
      analysis.Term)
  (analysis.text @ (when visibility
                     {:Public} ..public_tag
                     {:Private} ..private_tag
                     {:Protected} ..protected_tag
                     {:Default} ..default_tag)))

(.every Exception
  (Type Class))

(the .public parameter_types
  (-> (List (Type Var))
      (Check (List [(Type Var) .Type])))
  (list.each' check.monad
              (function (_ parameterJ)
                (monad.let check.monad
                  [[_ parameterT] check.existential]
                  (pure [parameterJ parameterT])))))

(.every .public (Abstract_Method a)
  [Text
   Visibility
   (List (Annotation a))
   (List (Type Var))
   (List Argument)
   (Type Return)
   (List Exception)])

(the .public abstract_tag "abstract")

(the .public abstract_method_definition
  (<code>.Projection (Abstract_Method @type.Code))
  (<| <code>.form
      (<>.after (<code>.this_text ..abstract_tag))
      (all <>.and
           <code>.text
           ..visibility
           (<code>.tuple (<>.some ..annotation))
           (<code>.tuple (<>.some ..var))
           (<code>.tuple (<>.some ..argument))
           ..return
           (<code>.tuple (<>.some ..class)))))

(the (method_mapping of_class parameters)
  (-> Mapping (List (Type Var))
      (Check Mapping))
  (|> parameters
      ..parameter_types
      (check:each (list:mix (function (_ [parameterJ parameterT] mapping)
                              (dictionary.has (projection.name parameterJ) parameterT mapping))
                            of_class))))

(the class_mapping
  (-> (List (Type Var))
      (Check Mapping))
  (..method_mapping luxT.fresh))

(the .public (analyse_abstract_method analyse archive method)
  (-> Phase Archive (Abstract_Method @type.Code)
      (Operation analysis.Term))
  (let [[method_name visibility annotations vars arguments return exceptions] method]
    (monad.let [! phase.monad]
      [mapping (typeA.check (method_mapping luxT.fresh vars))
       annotationsA (list.each' ! (function (_ [name parameters])
                                    (monad.let !
                                      [parametersA (list.each' ! (function (_ [name value])
                                                                   (monad.let !
                                                                     [valueA (analyse archive value)]
                                                                     (pure [name valueA])))
                                                               parameters)]
                                      (pure [name parametersA])))
                                annotations)
       @ analysis.provenance]
      (pure (analysis.tuple @ (list (analysis.text @ ..abstract_tag)
                                    (analysis.text @ method_name)
                                    (visibility_analysis @ visibility)
                                    (analysis.tuple @ (list:each (annotation_analysis @) annotationsA))
                                    (analysis.tuple @ (list:each (var_analysis @) vars))
                                    (analysis.tuple @ (list:each (..argument_analysis @) arguments))
                                    (return_analysis @ return)
                                    (analysis.tuple @ (list:each (class_analysis @) exceptions))
                                    ))))))

(.every .public (Constructor a)
  [Visibility
   Strictness
   (List (Annotation a))
   (List (Type Var))
   (List Exception)
   Text
   (List Argument)
   (List (Typed a))
   a])

(the .public constructor_tag "init")

(the .public constructor_definition
  (<code>.Projection (Constructor @type.Code))
  (<| <code>.form
      (<>.after (<code>.this_text ..constructor_tag))
      (all <>.and
           ..visibility
           <code>.bit
           (<code>.tuple (<>.some ..annotation))
           (<code>.tuple (<>.some ..var))
           (<code>.tuple (<>.some ..class))
           <code>.text
           (<code>.tuple (<>.some ..argument))
           (<code>.tuple (<>.some ..input))
           ?list.any)))

(the (with_fake_parameter:pattern it)
  (Change @type.Pattern)
  (when it
    {@type.:Simple_Pattern _}
    it
    
    {@type.:Complex_Pattern it}
    {@type.:Complex_Pattern
     (when it
       {@type.:Complex_Variant it}
       {@type.:Complex_Variant (revised @type.:choice with_fake_parameter:pattern it)}

       {@type.:Complex_Tuple it}
       {@type.:Complex_Tuple (list:each with_fake_parameter:pattern it)})}

    {@type.:List_Pattern it}
    {@type.:List_Pattern (list:each with_fake_parameter:pattern it)}
    
    {@type.:Bind_Pattern it}
    {@type.:Bind_Pattern (++ it)}))

(the (with_fake_parameter it)
  (-> analysis.Term
      analysis.Term)
  (when it
    {@type.:Simple @ _}
    it

    {@type.:Complex @ it}
    {@type.:Complex @
                    (when it
                      {@type.:Complex_Variant it}
                      {@type.:Complex_Variant (revised @type.:choice with_fake_parameter it)}

                      {@type.:Complex_Tuple it}
                      {@type.:Complex_Tuple (list:each with_fake_parameter it)})}

    {@type.:Reference @ it}
    {@type.:Reference @
                      (when it
                        {@type.:Variable_Reference it}
                        {@type.:Variable_Reference
                         (when it
                           {@type.:Local it}
                           {@type.:Local (++ it)}
                           
                           {@type.:Foreign _}
                           it)}
                        
                        {@type.:Constant_Reference _}
                        it)}
    
    {@type.:When @ value [head tail]}
    {@type.:When @ (with_fake_parameter value)
                 (let [with_fake_parameter (is (-> analysis.Branch analysis.Branch)
                                               (|>> (revised @type.:when with_fake_parameter:pattern)
                                                    (revised @type.:then with_fake_parameter)))]
                   [(with_fake_parameter head)
                    (list:each with_fake_parameter tail)])}
    
    {@type.:Abstraction @ environment body}
    {@type.:Abstraction @
                        (list:each with_fake_parameter environment)
                        body}
    
    {@type.:Application @ parameter abstraction}
    {@type.:Application @
                        (with_fake_parameter parameter)
                        (with_fake_parameter abstraction)}
    
    {@type.:Extension @ name parameters}
    {@type.:Extension @ name (list:each with_fake_parameter parameters)}))

(the .public (hidden_method_body @ arity bodyA)
  (-> Provenance Natural analysis.Term
      analysis.Term)
  (<| (analysis.tuple @)
      (list (analysis.unit @))
      (when arity
        (^.or 0 1)
        bodyA
        
        2
        (let [forced_refencing (is analysis.Term
                                   (analysis.tuple @ (is (List analysis.Term)
                                                         (list:each (is (-> Natural
                                                                            analysis.Term)
                                                                        (|>> (analysis.local @)))
                                                                    (list.domain (++ arity))))))]
          {@type.:When @ (analysis.unit @)
                       [[@type.:when
                         {@type.:Bind_Pattern 2}
                         
                         @type.:then
                         (analysis.tuple @ (list forced_refencing bodyA))]
                        (list)]})

        _
        (let [forced_refencing (is analysis.Term
                                   (analysis.tuple @ (is (List analysis.Term)
                                                         (list:each (is (-> Natural analysis.Term)
                                                                        (|>> (analysis.local @)))
                                                                    (list.domain (++ arity))))))]
          {@type.:When @ (analysis.unit @)
                       [[@type.:when
                         {@type.:Complex_Pattern
                          {@type.:Complex_Tuple
                           (|> (-- arity)
                               list.domain
                               (list:each (|>> (n.+ 2) {@type.:Bind_Pattern})))}}
                         
                         @type.:then
                         (analysis.tuple @ (list forced_refencing bodyA))]
                        (list)]}))))

(the .public (analyse_constructor_method analyse archive selfT mapping method)
  (-> Phase Archive .Type Mapping (Constructor @type.Code)
      (Operation analysis.Term))
  (let [[visibility strict_fp?
         annotations vars exceptions
         self_name arguments super_arguments body] method]
    (monad.let [! phase.monad]
      [mapping (typeA.check (method_mapping mapping vars))
       annotationsA (list.each' ! (function (_ [name parameters])
                                    (monad.let !
                                      [parametersA (list.each' ! (function (_ [name value])
                                                                   (monad.let !
                                                                     [valueA (analyse archive value)]
                                                                     (pure [name valueA])))
                                                               parameters)]
                                      (pure [name parametersA])))
                                annotations)
       super_arguments (list.each' ! (function (_ [jvmT super_argC])
                                       (monad.let !
                                         [luxT (reflection_type mapping jvmT)
                                          super_argA (<| (typeA.with luxT)
                                                         (analyse archive super_argC))]
                                         (pure [jvmT super_argA])))
                                   super_arguments)
       arguments' (list.each' !
                              (function (_ [name jvmT])
                                (monad.let !
                                  [luxT (boxed_reflection_type mapping jvmT)]
                                  (pure [name luxT])))
                              arguments)
       [scope bodyA] (|> arguments'
                         (list:composite (list [self_name selfT]))
                         list.in_reverse
                         (list:mix scope.with_local (analyse archive body))
                         (typeA.with .Any)
                         scope.with)
       .let [arity (list.size arguments)]
       @ analysis.provenance]
      (pure (analysis.tuple @ (list (analysis.text @ ..constructor_tag)
                                    (visibility_analysis @ visibility)
                                    (analysis.bit @ strict_fp?)
                                    (analysis.tuple @ (list:each (annotation_analysis @) annotationsA))
                                    (analysis.tuple @ (list:each (var_analysis @) vars))
                                    (analysis.tuple @ (list:each (class_analysis @) exceptions))
                                    (analysis.text @ self_name)
                                    (analysis.tuple @ (list:each (..argument_analysis @) arguments))
                                    (analysis.tuple @ (list:each (typed_analysis @) super_arguments))
                                    {@type.:Abstraction @
                                                        (list:each (|>> (analysis.variable @))
                                                                   (scope.environment scope))
                                                        (<| (..hidden_method_body @ arity)
                                                            (when arity
                                                              0 (with_fake_parameter bodyA)
                                                              _ bodyA))}
                                    ))))))

(.every .public (Virtual_Method a)
  [Text
   Visibility
   Finality
   Strictness
   (List (Annotation a))
   (List (Type Var))
   Text
   (List Argument)
   (Type Return)
   (List Exception)
   a])

(the .public virtual_tag "virtual")

(the .public virtual_method_definition
  (<code>.Projection (Virtual_Method @type.Code))
  (<| <code>.form
      (<>.after (<code>.this_text ..virtual_tag))
      (all <>.and
           <code>.text
           ..visibility
           <code>.bit
           <code>.bit
           (<code>.tuple (<>.some ..annotation))
           (<code>.tuple (<>.some ..var))
           <code>.text
           (<code>.tuple (<>.some ..argument))
           ..return
           (<code>.tuple (<>.some ..class))
           ?list.any)))

(.every .public (Method_Declaration a)
  (Record
   [:name Text
    :annotations (List (Annotation a))
    :type_variables (List (Type Var))
    :exceptions (List (Type Class))
    :arguments (List (Type Value))
    :return (Type Return)]))

(the .public method_declaration
  (<code>.Projection (Method_Declaration @type.Code))
  (<code>.form
   (all <>.and
        <code>.text
        (<code>.tuple (<>.some ..annotation))
        (<code>.tuple (<>.some ..var))
        (<code>.tuple (<>.some ..class))
        (<code>.tuple (<>.some ..type))
        ..return
        )))

(the .public (analyse_virtual_method analyse archive selfT mapping method)
  (-> Phase Archive .Type Mapping (Virtual_Method @type.Code)
      (Operation analysis.Term))
  (let [[method_name visibility
         final? strict_fp? annotations vars
         self_name arguments return exceptions
         body] method]
    (monad.let [! phase.monad]
      [mapping (typeA.check (method_mapping mapping vars))
       annotationsA (list.each' ! (function (_ [name parameters])
                                    (monad.let !
                                      [parametersA (list.each' ! (function (_ [name value])
                                                                   (monad.let !
                                                                     [valueA (analyse archive value)]
                                                                     (pure [name valueA])))
                                                               parameters)]
                                      (pure [name parametersA])))
                                annotations)
       :return: (boxed_reflection_return mapping return)
       arguments' (list.each' !
                              (function (_ [name jvmT])
                                (monad.let !
                                  [luxT (boxed_reflection_type mapping jvmT)]
                                  (pure [name luxT])))
                              arguments)
       [scope bodyA] (|> arguments'
                         (list:composite (list [self_name selfT]))
                         list.in_reverse
                         (list:mix scope.with_local (analyse archive body))
                         (typeA.with :return:)
                         scope.with)
       .let [arity (list.size arguments)]
       @ analysis.provenance]
      (pure (analysis.tuple @ (list (analysis.text @ ..virtual_tag)
                                    (analysis.text @ method_name)
                                    (visibility_analysis @ visibility)
                                    (analysis.bit @ final?)
                                    (analysis.bit @ strict_fp?)
                                    (analysis.tuple @ (list:each (annotation_analysis @) annotationsA))
                                    (analysis.tuple @ (list:each (var_analysis @) vars))
                                    (analysis.text @ self_name)
                                    (analysis.tuple @ (list:each (..argument_analysis @) arguments))
                                    (return_analysis @ return)
                                    (analysis.tuple @ (list:each (class_analysis @) exceptions))
                                    {@type.:Abstraction @
                                                        (list:each (|>> (analysis.variable @))
                                                                   (scope.environment scope))
                                                        (<| (..hidden_method_body @ arity)
                                                            (when arity
                                                              0 (with_fake_parameter bodyA)
                                                              _ bodyA))}
                                    ))))))

(.every .public (Static_Method a)
  [Text
   Visibility
   Strictness
   (List (Annotation a))
   (List (Type Var))
   (List Argument)
   (Type Return)
   (List Exception)
   a])

(the .public static_tag "static")

(the .public static_method_definition
  (<code>.Projection (Static_Method @type.Code))
  (<| <code>.form
      (<>.after (<code>.this_text ..static_tag))
      (all <>.and
           <code>.text
           ..visibility
           <code>.bit
           (<code>.tuple (<>.some ..annotation))
           (<code>.tuple (<>.some ..var))
           (<code>.tuple (<>.some ..argument))
           ..return
           (<code>.tuple (<>.some ..class))
           ?list.any)))

(the .public (analyse_static_method analyse archive mapping method)
  (-> Phase Archive Mapping (Static_Method @type.Code)
      (Operation analysis.Term))
  (let [[method_name visibility
         strict_fp? annotations vars
         arguments return exceptions
         body] method]
    (monad.let [! phase.monad]
      [mapping (typeA.check (method_mapping mapping vars))
       annotationsA (list.each' ! (function (_ [name parameters])
                                    (monad.let !
                                      [parametersA (list.each' ! (function (_ [name value])
                                                                   (monad.let !
                                                                     [valueA (analyse archive value)]
                                                                     (pure [name valueA])))
                                                               parameters)]
                                      (pure [name parametersA])))
                                annotations)
       :return: (boxed_reflection_return mapping return)
       arguments' (list.each' !
                              (function (_ [name jvmT])
                                (monad.let !
                                  [luxT (boxed_reflection_type mapping jvmT)]
                                  (pure [name luxT])))
                              arguments)
       [scope bodyA] (|> arguments'
                         list.in_reverse
                         (list:mix scope.with_local (analyse archive body))
                         (typeA.with :return:)
                         scope.with)
       @ analysis.provenance]
      (pure (analysis.tuple @ (list (analysis.text @ ..static_tag)
                                    (analysis.text @ method_name)
                                    (visibility_analysis @ visibility)
                                    (analysis.bit @ strict_fp?)
                                    (analysis.tuple @ (list:each (annotation_analysis @) annotationsA))
                                    (analysis.tuple @ (list:each (var_analysis @) vars))
                                    (analysis.tuple @ (list:each (..argument_analysis @) arguments))
                                    (return_analysis @ return)
                                    (analysis.tuple @ (list:each (class_analysis @) exceptions))
                                    {@type.:Abstraction @
                                                        (list:each (|>> (analysis.variable @))
                                                                   (scope.environment scope))
                                                        (analysis.tuple @ (list bodyA))}
                                    ))))))

(.every .public (Overriden_Method a)
  [(Type Class)
   Text
   Bit
   (List (Annotation a))
   (List (Type Var))
   Text
   (List Argument)
   (Type Return)
   (List (Type Class))
   a])

(the .public overriden_tag "override")

(the .public overriden_method_definition
  (<code>.Projection (Overriden_Method @type.Code))
  (<| <code>.form
      (<>.after (<code>.this_text ..overriden_tag))
      (all <>.and
           ..class
           <code>.text
           <code>.bit
           (<code>.tuple (<>.some ..annotation))
           (<code>.tuple (<>.some ..var))
           <code>.text
           (<code>.tuple (<>.some ..argument))
           ..return
           (<code>.tuple (<>.some ..class))
           ?list.any
           )))

(exception.the .public (unknown_super [name supers])
  (exception.Exception [Text (List (Type Class))])
  (exception.report
   (list ["Name" (%.text name)]
         ["Available" (exception.listing (|>> projection.read_class product.right)
                                         supers)])))

(exception.the .public (mismatched_super_parameters [name expected actual])
  (exception.Exception [Text Natural Natural])
  (exception.report
   (list ["Name" (%.text name)]
         ["Expected" (%.natural expected)]
         ["Actual" (%.natural actual)])))

(the (override_mapping mapping supers parent_type)
  (-> Mapping (List (Type Class)) (Type Class)
      (Operation (List [Text .Type])))
  (let [[parent_parameters parent_name] (projection.read_class parent_type)]
    (when (list.one (function (_ super)
                      (let [[super_parameters super_name] (projection.read_class super)]
                        (if (text.= parent_name super_name)
                            {.:Some super_parameters}
                            {.:None})))
                    supers)
      {try.:Success super_parameters}
      (let [expected_count (list.size parent_parameters)
            actual_count (list.size super_parameters)]
        (if (n.= expected_count actual_count)
            (monad.let [! phase.monad]
              [parent_parameters (|> parent_parameters
                                     (list.each' maybe.monad projection.var?)
                                     (try.of_maybe "Not all parameters are type variables.")
                                     phase.of_try)]
              (|> super_parameters
                  (list.each' ! (..reflection_type mapping))
                  (by ! each (|>> (list.zipped_2 parent_parameters)))))
            (phase.of_try (exception.except ..mismatched_super_parameters [parent_name expected_count actual_count]))))
      
      {try.:Failure _}
      (phase.of_try (exception.except ..unknown_super [parent_name supers])))))

(the .public (with_override_mapping supers parent_type mapping)
  (-> (List (Type Class)) (Type Class) Mapping
      (Operation Mapping))
  (monad.let phase.monad
    [override_mapping (..override_mapping mapping supers parent_type)]
    (pure (list:mix (function (_ [super_var bound_type] mapping)
                      (dictionary.has super_var bound_type mapping))
                    mapping
                    override_mapping))))

(the .public (analyse_overriden_method analyse archive selfT mapping supers method)
  (-> Phase Archive .Type Mapping (List (Type Class)) (Overriden_Method @type.Code)
      (Operation analysis.Term))
  (let [[parent_type method_name
         strict_fp? annotations vars
         self_name arguments return exceptions
         body] method]
    (monad.let [! phase.monad]
      [mapping (..with_override_mapping supers parent_type mapping)
       mapping (typeA.check (method_mapping mapping vars))
       annotationsA (list.each' ! (function (_ [name parameters])
                                    (monad.let !
                                      [parametersA (list.each' ! (function (_ [name value])
                                                                   (monad.let !
                                                                     [valueA (analyse archive value)]
                                                                     (pure [name valueA])))
                                                               parameters)]
                                      (pure [name parametersA])))
                                annotations)
       arguments' (list.each' !
                              (function (_ [name jvmT])
                                (monad.let !
                                  [luxT (boxed_reflection_type mapping jvmT)]
                                  (pure [name luxT])))
                              arguments)
       :return: (boxed_reflection_return mapping return)
       [scope bodyA] (|> arguments'
                         (list:composite (list [self_name selfT]))
                         list.in_reverse
                         (list:mix scope.with_local (analyse archive body))
                         (typeA.with :return:)
                         scope.with)
       .let [arity (list.size arguments)]
       @ analysis.provenance]
      (pure (analysis.tuple @ (list (analysis.text @ ..overriden_tag)
                                    (class_analysis @ parent_type)
                                    (analysis.text @ method_name)
                                    (analysis.bit @ strict_fp?)
                                    (analysis.tuple @ (list:each (annotation_analysis @) annotationsA))
                                    (analysis.tuple @ (list:each (var_analysis @) vars))
                                    (analysis.text @ self_name)
                                    (analysis.tuple @ (list:each (..argument_analysis @) arguments))
                                    (return_analysis @ return)
                                    (analysis.tuple @ (list:each (class_analysis @) exceptions))
                                    {@type.:Abstraction @
                                                        (list:each (|>> (analysis.variable @))
                                                                   (scope.environment scope))
                                                        (<| (..hidden_method_body @ arity)
                                                            (when arity
                                                              0 (with_fake_parameter bodyA)
                                                              _ bodyA))}
                                    ))))))

(the (matched? [sub sub_method subJT] [super super_method superJT])
  (-> [(Type Class) Text (Type Method)] [(Type Class) Text (Type Method)]
      Bit)
  (and (by descriptor.equivalence = (jvm.descriptor super) (jvm.descriptor sub))
       (text.= super_method sub_method)
       (jvm.= superJT subJT)))

(the (mismatched_methods super_set sub_set)
  (-> (List [(Type Class) Text (Type Method)]) (List [(Type Class) Text (Type Method)])
      (List [(Type Class) Text (Type Method)]))
  (list.only (function (_ sub)
               (not (list.any? (matched? sub) super_set)))
             sub_set))

(exception.the .public (class_parameter_mismatch [name declaration expected actual])
  (exception.Exception [Text (Type Class) (List Text) (List (Type Parameter))])
  (exception.report
   (list ["Class" (%.text name)]
         ["Declaration" (signature.signature (jvm.signature declaration))]
         ["Expected (amount)" (%.natural (list.size expected))]
         ["Expected (parameters)" (exception.listing %.text expected)]
         ["Actual (amount)" (%.natural (list.size actual))]
         ["Actual (parameters)" (exception.listing ..signature actual)])))

(the (super_aliasing class_loader class)
  (-> java/lang/ClassLoader (Type Class)
      (Operation Aliasing))
  (monad.let phase.monad
    [.let [[actual_parameters name] (projection.read_class class)]
     jvm_class (phase.of_try (reflection!.load class_loader name))
     .let [expected_parameters (|> jvm_class
                                   (java/lang/Class:getTypeParameters [])
                                   (list.of_array {.:None})
                                   (list:each (|>> (java/lang/reflect/TypeVariable:getName [])
                                                   ffi.of_string)))]
     _ (phase.assertion ..class_parameter_mismatch [name class expected_parameters actual_parameters]
                        (n.= (list.size expected_parameters)
                             (list.size actual_parameters)))]
    (pure (|> (list.zipped_2 expected_parameters actual_parameters)
              (list:mix (function (_ [expected actual] mapping)
                          (when (projection.var? actual)
                            {.:Some actual}
                            (dictionary.has actual expected mapping)
                            
                            {.:None}
                            mapping))
                        alias.fresh)))))

(the (anonymous_class_name module id)
  (-> Module Natural
      Text)
  (let [global (text.replaced .module_delimiter ..jvm_package_delimiter module)
        local (text "anonymous-class" (%.natural id))]
    (text global ..jvm_package_delimiter local)))

(the .public (require_complete_method_concretion class_loader supers methods)
  (-> java/lang/ClassLoader (List (Type Class)) (List (Overriden_Method @type.Code))
      (Operation Any))
  (monad.let [! phase.monad]
    [required_abstract_methods (phase.of_try (all_abstract_methods class_loader supers))
     available_methods (phase.of_try (all_methods class_loader supers))
     overriden_methods (list.each' ! (function (_ [parent_type method_name
                                                   strict_fp? annotations type_vars
                                                   self_name arguments return exceptions
                                                   body])
                                       (monad.let !
                                         [aliasing (super_aliasing class_loader parent_type)]
                                         (pure (|> (jvm.method [type_vars
                                                                (list:each product.right arguments)
                                                                return
                                                                exceptions])
                                                   (alias.method aliasing)
                                                   [parent_type method_name]))))
                                   methods)
     .let [missing_abstract_methods (mismatched_methods overriden_methods required_abstract_methods)
           invalid_overriden_methods (mismatched_methods available_methods overriden_methods)]
     _ (phase.assertion ..missing_abstract_methods [required_abstract_methods overriden_methods]
                        (list.empty? missing_abstract_methods))
     _ (phase.assertion ..invalid_overriden_methods [available_methods invalid_overriden_methods]
                        (list.empty? invalid_overriden_methods))]
    (pure [])))

(.every Declaration
  [Text (List (Type Var))])

(.every Constant
  [Text (List Annotation) (Type Value) @type.Code])

(.every Variable
  [Text (Modifier field.Field) (Modifier field.Field) (List Annotation) (Type Value)])

(.every Field
  (Variant
   {:Constant Constant}
   {:Variable Variable}))

(.every (Method_Definition a)
  (Variant
   {:Constructor (..Constructor a)}
   {:Virtual_Method (..Virtual_Method a)}
   {:Static_Method (..Static_Method a)}
   {:Overriden_Method (..Overriden_Method a)}
   {:Abstract_Method (..Abstract_Method a)}))

(the class_name
  (|>> projection.read_class
       product.right
       internal.name))

(the (mock_class [name parameters] super interfaces fields methods modifier)
  (-> Declaration (Type Class) (List (Type Class))
      (List (Resource field.Field)) (List (Resource method.Method)) (Modifier class.Class)
      (Try [external.Name Binary]))
  (let [signature (signature.inheritance (list:each jvm.signature parameters)
                                         (jvm.signature super)
                                         (list:each jvm.signature interfaces))]
    (try:each (|>> (\\injection.value class.as_binary)
                   [name])
              (class.class version.v6_0
                           (all modifier:composite
                                class.public
                                modifier)
                           (internal.name name)
                           {.:Some signature}
                           (..class_name super)
                           (list:each ..class_name interfaces)
                           fields
                           methods
                           (list)))))

(the constant:modifier
  (Modifier field.Field)
  (all modifier:composite
       field.public
       field.static
       field.final
       ))

(the (field_definition field)
  (-> Field
      (Resource field.Field))
  (when field
    ... TODO: Handle annotations.
    {:Constant [name annotations type value]}
    (`` (when value
          (,, (template.with [<tag> <type> <constant>]
                [{<tag> _ value}
                 (monad.let pool.monad
                   [constant (`` (|> value (,, (template.spliced <constant>))))
                    attribute (attribute.constant constant)]
                   (field.field ..constant:modifier name true <type> (sequence.sequence attribute)))]

                [[@type.:Bit jvm.boolean [(|.when 0b +0 1b +1) i/32.of pool.integer]]
                 ... [@type.:Integer jvm.byte [.i64 i/32.of pool.integer]]
                 ... [@type.:Integer jvm.short [.i64 i/32.of pool.integer]]
                 ... [@type.:Integer jvm.int [.i64 i/32.of pool.integer]]
                 [@type.:Integer jvm.long [pool.long]]
                 ... [@type.:Decimal jvm.float [ffi.as_double ffi.double_to_float pool.float]]
                 [@type.:Decimal jvm.double [pool.double]]
                 [@type.:Natural jvm.char [.i64 i/32.of pool.integer]]
                 [@type.:Text (jvm.class (list) "java.lang.String") [pool.string]]]))

          ... TODO: Tighten this pattern-matching so this catch-all clause isn't necessary.
          _
          (undefined)))

    ... TODO: Handle annotations.
    {:Variable [name visibility state annotations type]}
    (field.field (modifier:composite visibility state)
                 name true type sequence.empty)))

(the method_privacy
  (-> ffi.Privacy
      (Modifier method.Method))
  (|>> (|.when
         {ffi.:PublicP} method.public
         {ffi.:PrivateP} method.private
         {ffi.:ProtectedP} method.protected
         {ffi.:DefaultP} modifier.empty)))

(the constructor_name
  "<init>")

(the (mock_value valueT)
  (-> (Type Value)
      (Bytecode Any))
  (when (jvm.primitive? valueT)
    {.:Left classT}
    _.aconst_null
    
    {.:Right primitiveT}
    (if (by jvm.equivalence = jvm.long primitiveT)
        _.lconst_0

        (by jvm.equivalence = jvm.float primitiveT)
        _.fconst_0

        (by jvm.equivalence = jvm.double primitiveT)
        _.dconst_0

        ... jvm.boolean jvm.byte jvm.short jvm.int jvm.char
        _.iconst_0)))

(the (mock_return :return:)
  (-> (Type Return)
      (Bytecode Any))
  (when (jvm.void? :return:)
    {.:Right :return:}
    _.return

    {.:Left valueT}
    (all _.composite
         (mock_value valueT)
         (when (jvm.primitive? valueT)
           {.:Left classT}
           _.areturn
           
           {.:Right primitiveT}
           (if (by jvm.equivalence = jvm.long primitiveT)
               _.lreturn

               (by jvm.equivalence = jvm.float primitiveT)
               _.freturn

               (by jvm.equivalence = jvm.double primitiveT)
               _.dreturn

               ... jvm.boolean jvm.byte jvm.short jvm.int jvm.char
               _.ireturn)))))

(the (mock_method super method)
  (-> (Type Class) (Method_Definition @type.Code)
      (Resource method.Method))
  (when method
    {:Constructor [privacy strict_floating_point? annotations variables exceptions
                   self arguments constructor_arguments
                   body]}
    (method.method (all modifier:composite
                        (..method_privacy privacy)
                        (if strict_floating_point?
                            method.strict
                            modifier.empty))
      ..constructor_name
      false (jvm.method [variables (list:each product.right arguments) jvm.void exceptions])
      (list)
      {.:Some (all _.composite
                   (_.aload 0)
                   (|> constructor_arguments
                       (list:each (|>> product.left ..mock_value))
                       (list.complete _.monad))
                   (|> (jvm.method [(list) (list:each product.left constructor_arguments) jvm.void (list)])
                       (_.invokespecial super ..constructor_name))
                   _.return
                   )})

    {:Overriden_Method [super name strict_floating_point? annotations variables
                        self arguments return exceptions
                        body]}
    (method.method (all modifier:composite
                        method.public
                        (if strict_floating_point?
                            method.strict
                            modifier.empty))
      name
      false (jvm.method [variables (list:each product.right arguments) return exceptions])
      (list)
      {.:Some (..mock_return return)})

    {:Virtual_Method [name privacy final? strict_floating_point? annotations variables
                      self arguments return exceptions
                      body]}
    (method.method (all modifier:composite
                        (..method_privacy privacy)
                        (if strict_floating_point?
                            method.strict
                            modifier.empty)
                        (if final?
                            method.final
                            modifier.empty))
      name
      false (jvm.method [variables (list:each product.right arguments) return exceptions])
      (list)
      {.:Some (..mock_return return)})

    {:Static_Method [name privacy strict_floating_point? annotations
                     variables arguments return exceptions
                     body]}
    (method.method (all modifier:composite
                        method.static
                        (..method_privacy privacy)
                        (if strict_floating_point?
                            method.strict
                            modifier.empty))
      name
      false (jvm.method [variables (list:each product.right arguments) return exceptions])
      (list)
      {.:Some (..mock_return return)})

    {:Abstract_Method [name privacy annotations
                       variables arguments return exceptions]}
    (method.method (all modifier:composite
                        method.abstract
                        (..method_privacy privacy))
      name
      false (jvm.method [variables (list:each product.right arguments) return exceptions])
      (list)
      {.:None})
    ))

(the (mock declaration super interfaces inheritance fields methods)
  (-> Declaration
      (Type Class) (List (Type Class))
      (Modifier class.Class) (List ..Field) (List (Method_Definition @type.Code))
      (Try [external.Name Binary]))
  (mock_class declaration super interfaces
              (list:each ..field_definition fields)
              (list:each (..mock_method super) methods)
              inheritance))

(the (class:anonymous class_loader host)
  (-> java/lang/ClassLoader runtime.Host
      (-> Text Handler))
  (..custom
   [(all <>.and
         (<code>.tuple (<>.some ..var))
         ..class
         (<code>.tuple (<>.some ..class))
         (<code>.tuple (<>.some ..input))
         (<code>.tuple (<>.some ..overriden_method_definition)))
    (function (_ extension_name analyse archive [parameters
                                                 super_class
                                                 super_interfaces
                                                 constructor_args
                                                 methods])
      (monad.let [! phase.monad]
        [_ (..ensure_fresh_class! class_loader (..reflection super_class))
         _ (list.each' ! (|>> ..reflection (..ensure_fresh_class! class_loader)) super_interfaces)

         self_name (monad.let !
                     [where phase.name_of_current_module
                      id analysis.seed]
                     (pure (..anonymous_class_name where id)))
         .let [selfT {.:Nominal self_name (list)}]
         mock (<| phase.of_try
                  (..mock [self_name parameters]
                          super_class
                          super_interfaces
                          class.final
                          (list)
                          (list:each (|>> {:Overriden_Method}) methods)))
         ... Necessary for reflection to work properly during analysis.
         _ (phase.of_try (by host execute mock))

         mapping (typeA.check (..class_mapping parameters))
         super_classT (typeA.check (luxT.check (luxT.class mapping) (..signature super_class)))
         super_interfaceT+ (typeA.check (list.each' check.monad
                                                    (|>> ..signature (luxT.check (luxT.class mapping)))
                                                    super_interfaces))
         _ (typeA.inference selfT)
         constructor_argsA+ (list.each' ! (function (_ [type term])
                                            (monad.let !
                                              [argT (reflection_type mapping type)
                                               termA (<| (typeA.with argT)
                                                         (analyse archive term))]
                                              (pure [type termA])))
                                        constructor_args)
         .let [supers (list:composite (list super_class) super_interfaces)]
         _ (..require_complete_method_concretion class_loader supers methods)
         methodsA (list.each' ! (analyse_overriden_method analyse archive selfT mapping supers)
                              methods)
         @ analysis.provenance]
        (pure {@type.:Extension @ [.prelude (extension.synthesis extension_name)]
                                (list (class_analysis @ super_class)
                                      (analysis.tuple @ (list:each (class_analysis @) super_interfaces))
                                      (analysis.tuple @ (list:each (typed_analysis @) constructor_argsA+))
                                      (analysis.tuple @ methodsA))})))]))

(the (with_class class_loader host)
  (-> java/lang/ClassLoader runtime.Host
      (Change Bundle))
  (with extension/jvm.class_anonymous (class:anonymous class_loader host)))

(the .public (bundle class_loader host)
  (-> java/lang/ClassLoader runtime.Host
      Bundle)
  (<| with_conversion

      with_int
      with_long
      
      with_float
      with_double
      
      with_char
      with_array
      
      (with_object class_loader)
      (with_member class_loader)
      (with_class class_loader host)

      ///.empty
      ))
