... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except list with)
   [abstract
    ["<>" projection]
    ["[0]" monad]]
   [error
    ["[0]" try]]
   [data
    [collection
     ["[0]" list (.use "[1]:[0]" functor mix)
      ["?[1]" \\projection]]
     ["[0]" dictionary]]]
   ["[0]" function]
   [macro
    ["[0]" template]]
   ["[0]" target (.only)
    ["_" js (.only Literal)]]
   [compiler
    [meta
     [archive (.only Archive)]]
    ["[0]" extension (.only)
     ["[1]/[0]" lux]]]
   [meta
    ["[0]" static]]]]
 [/////
  ["//" extension]
  [translation
   [extension (.only Nullary Unary Binary Trinary Variadic
                     nullary unary binary trinary variadic)]
   ["//" js
    ["[0]" runtime (.only Operation Phase Phase! Handler Bundle)]
    ["[0]" when]
    ["[0]" loop]
    ["[1][0]" function]]]
  [//
   ["[0]" phase (.use "[1]:[0]" monad)]
   ["[0]" synthesis (.only)
    ["?[1]" \\projection (.only Projection)]]]])

(the .public (custom [projection handler])
  (for_any (_ s)
    (-> [(Projection s)
         (-> Phase Archive s (Operation _.Expression))]
        Handler))
  (function (_ phase archive input)
    (when (?list.value input projection)
      {try.:Success input'}
      (handler phase archive input')

      {try.:Failure error}
      (phase.failure error))))

... [Procedures]
... [[Bits]]
(template.with [<name> <op>]
  [(the (<name> [paramG subjectG])
     (Binary _.Expression)
     (<op> subjectG (runtime.i64:number paramG)))]

  [[i64:<< runtime.i64:<<]
   [i64:>> runtime.i64:>>]])

... [[Numbers]]
(the (i64:char it)
  (Unary _.Expression)
  (_.of (.list (runtime.i64:number it))
        (_.var "String.fromCharCode")))

... [[Text]]
(the (text//composite it)
  (Variadic _.Expression)
  (when it
    (.list)
    (_.string "")

    (.list single)
    single

    (.list left right)
    (|> left (_.+ right))

    rights
    (|> (text//composite (.list))
        (_.do "concat" rights))))

(the (text//clip [startG endG subjectG])
  (Trinary _.Expression)
  (runtime.text//clip startG endG subjectG))

(the (text//index [startG partG subjectG])
  (Trinary _.Expression)
  (runtime.text//index startG partG subjectG))

... [[IO]]
(the (io//log messageG)
  (Unary _.Expression)
  (all _.,
       (runtime.io//log messageG)
       runtime.unit))

(the .public (statement expression archive synthesis)
  Phase!
  (`` (when synthesis
        ... TODO: Get rid of this ASAP
        [@ {synthesis.:Extension [.prelude (,, (static.text (extension.synthesis extension/lux.when_char)))] parameters}]
        (monad.let phase.monad
          [body (expression archive synthesis)]
          (pure (as (-> _.Expression _.Statement)
                    body)))

        (,, (template.with [<tag>]
              [(<tag> @ value)
               (phase:each _.return
                           (expression archive synthesis))]

              [[synthesis.bit]
               [synthesis.i64]
               [synthesis.f64]
               [synthesis.text]
               [synthesis.variant]
               [synthesis.tuple]
               [synthesis.reification]]
              ))

        (,, (template.with [<tag>]
              [[@ {<tag> value}]
               (phase:each _.return
                           (expression archive synthesis))]

              [[synthesis.:Reference]
               [synthesis.:Extension]]
              ))

        (synthesis.let @ register input body)
        (when.let! statement expression archive [register input body])

        (synthesis.exec @ before after)
        (when.exec! statement expression archive [before after])

        (synthesis.when @ it)
        (<| (,, (template.with [,synthesis]
                  [(when (,synthesis it)
                     {.:Some it}
                     (phase:each _.return
                                 (expression archive synthesis))

                     else)]

                  [[synthesis.its]]
                  ))
            (,, (template.with [,synthesis ,translation]
                  [(when (,synthesis it)
                     {.:Some it}
                     (,translation statement expression archive it)

                     else)]

                  [[synthesis.variant_if when.variant_if!]
                   [synthesis.if when.if!]
                   [synthesis.when_i64 when.when_i64!]
                   [synthesis.when_f64 when.when_f64!]
                   [synthesis.when_text when.when_text!]
                   [synthesis.multi_let when.multi_let!]]
                  ))
            (when.when! statement expression archive it))

        (synthesis.tail_recursion @ tail_recursion)
        (loop.tail_recursion! statement expression archive tail_recursion)

        (synthesis.tail_iteration @ updates)
        (loop.tail_iteration! statement expression archive updates)

        (synthesis.abstraction @ abstraction)
        (phase:each _.return (//function.function statement expression archive abstraction))
        )))

... TODO: Get rid of this ASAP
(the lux:syntax_char_case!
  (..custom [(all <>.and
                  ?list.any
                  ?list.any
                  (<>.some (?synthesis.tuple (all <>.and
                                                  (?synthesis.tuple (<>.many ?synthesis.i64))
                                                  ?list.any))))
             (function (_ phase archive [input else conditionals])
               (monad.let [! phase.monad]
                 [inputG (phase archive input)
                  else! (..statement phase archive else)
                  conditionals! (is (Operation (List [(List Literal)
                                                      _.Statement]))
                                    (list.each' ! (function (_ [chars branch])
                                                    (monad.let !
                                                      [branch! (..statement phase archive branch)]
                                                      (pure [(list:each (|>> .integer _.int)
                                                                        chars)
                                                             branch!])))
                                                conditionals))]
                 ... (pure (|> (_.switch (_.its runtime.i64_low_field inputG)
                 ...                   conditionals!
                 ...                   {.:Some (_.return else!)})
                 ...         (_.closure (list))
                 ...         (_.of (list))))
                 (pure (<| (as (-> _.Statement
                                   _.Expression))
                           (_.switch (_.its runtime.i64_low_field inputG)
                                     conditionals!
                                     {.:Some else!})))))]))

... [Bundles]
(the .public (with name anonymous)
  (-> extension.Name Handler
      (Change Bundle))
  (dictionary.has (extension.synthesis name) anonymous))

(the with_basic
  (Change Bundle)
  (|>> (with extension/lux.when_char lux:syntax_char_case!)
       (with extension/lux.is? (binary (function.uncurried _.=)))
       (with extension/lux.try (unary runtime.lux//try))))

(the with_i64
  (Change Bundle)
  (|>> (with extension/lux.i64_and (binary (function.uncurried runtime.i64:and)))
       (with extension/lux.i64_or (binary (function.uncurried runtime.i64:or)))
       (with extension/lux.i64_xor (binary (function.uncurried runtime.i64:xor)))
       (with extension/lux.i64_left (binary i64:<<))
       (with extension/lux.i64_right (binary i64:>>))

       (with extension/lux.i64_= (binary (function.uncurried runtime.i64:=)))
       (with extension/lux.i64_+ (binary (function.uncurried runtime.i64:+)))
       (with extension/lux.i64_- (binary (function.uncurried runtime.i64:-)))
       ))

(the with_integer
  (Change Bundle)
  (|>> (with extension/lux.int_< (binary (function.uncurried runtime.i64:<)))
       
       (with extension/lux.int_x (binary (function.uncurried runtime.i64:x)))
       (with extension/lux.int_/ (binary (function.uncurried runtime.i64:/)))
       (with extension/lux.int_% (binary (function.uncurried runtime.i64:%)))
       
       (with extension/lux.int_f64 (unary runtime.i64:number))
       (with extension/lux.int_char (unary i64:char))
       ))

(the with_f64
  (Change Bundle)
  (|>> (with extension/lux.f64_+ (binary (function.uncurried _.+)))
       (with extension/lux.f64_- (binary (function.uncurried _.-)))
       (with extension/lux.f64_x (binary (function.uncurried _.*)))
       (with extension/lux.f64_/ (binary (function.uncurried _./)))
       (with extension/lux.f64_% (binary (function.uncurried _.%)))

       (with extension/lux.f64_= (binary (function.uncurried _.=)))
       (with extension/lux.f64_< (binary (function.uncurried _.<)))
       
       (with extension/lux.f64_int (unary runtime.i64:of_number))
       ))

(the with_text
  (Change Bundle)
  (|>> (with extension/lux.text_= (binary (function.uncurried _.=)))
       (with extension/lux.text_< (binary (function.uncurried _.<)))
       
       (with extension/lux.text_composite (variadic text//composite))
       (with extension/lux.text_index (trinary text//index))
       (with extension/lux.text_size (unary (|>> (_.its "length") runtime.i64:of_number)))
       (with extension/lux.text_char (binary (function.uncurried runtime.text//char)))
       (with extension/lux.text_clip (trinary text//clip))
       ))

(the with_io
  (Change Bundle)
  (|>> (with extension/lux.log! (unary io//log))
       (with extension/lux.error (unary runtime.io//error))))

(the list
  (Variadic _.Expression)
  _.array)

(the list_size
  (Unary _.Expression)
  (|>> (_.its "length")
       runtime.i64:of_number))

(the (list_item [address it])
  (Binary _.Expression)
  (_.at (_.its runtime.i64_low_field address)
        it))

(the (list_composite [left right])
  (Binary _.Expression)
  (target.if target.js
             (|> left
                 (_.do "concat" (.list right)))
             
             ... else
             (let [as_array (is (Change _.Expression)
                                (function (as_array it)
                                  (_.do "slice" (.list) it)))
                   as_array (is (Change _.Expression)
                                (target.if target.js
                                           (|>>)
                                           
                                           ... else
                                           as_array))]
               (_.of (.list (_.array (.list)) (as_array left) (as_array right))
                     (let [it (_.var "it")
                           left (_.var "left")
                           right (_.var "right")
                           item (_.var "item")]
                       (_.closure (.list it left right)
                                  (all _.then
                                       (_.for item (_.int +0)
                                              (_.< (_.its "length" left)
                                                   item)
                                              (_.++ item)
                                              (_.; (_.do "push" (.list (_.at item left)) it)))
                                       (_.for item (_.int +0)
                                              (_.< (_.its "length" right)
                                                   item)
                                              (_.++ item)
                                              (_.; (_.do "push" (.list (_.at item right)) it)))
                                       (_.return it)
                                       )))))))

(the with_list
  (Change Bundle)
  (|>> (with extension/lux.list (variadic ..list))
       (with extension/lux.list_size (unary ..list_size))
       (with extension/lux.list_item (binary ..list_item))
       (with extension/lux.list_composite (binary ..list_composite))
       ))

(the array
  (Unary _.Expression)
  (|>> (_.its runtime.i64_low_field)
       .list
       (_.new (_.var "Array"))))

(the array_size
  (Unary _.Expression)
  ..list_size)

(the array_its
  (Binary _.Expression)
  ..list_item)

(the (array_has [address value it])
  (Trinary _.Expression)
  (runtime.array//write address value it))

(the (array_lacks [address it])
  (Binary _.Expression)
  (runtime.array//delete address it))

(the (array_lacks? [address it])
  (Binary _.Expression)
  (|> (array_its [address it])
      (_.= _.undefined)))

(the with_array
  (Change Bundle)
  (|>> (with extension/lux.array (unary ..array))
       (with extension/lux.array_size (unary ..array_size))
       (with extension/lux.array_its (binary ..array_its))
       (with extension/lux.array_has (trinary ..array_has))
       (with extension/lux.array_lacks (binary ..array_lacks))
       (with extension/lux.array_lacks? (binary ..array_lacks?))
       ))

(the .public bundle
  Bundle
  (|> //.empty
      with_basic
      with_i64
      with_integer
      with_f64
      with_text
      with_io
      with_list
      with_array
      ))
