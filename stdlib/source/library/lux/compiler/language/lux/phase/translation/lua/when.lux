... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except when exec let if its
                or and)
   [abstract
    ["[0]" monad]]
   [data
    ["[0]" text]
    [collection
     ["[0]" list (.use "[1]:[0]" functor mix monoid)]
     ["[0]" set]]]
   [macro
    ["[0]" template]]
   [target
    ["_" lua (.only Var)]]
   [compiler
    ["@[0]" type (.only Register)]]]]
 ["[0]" //
  ["[1][0]" runtime (.only Operation Phase Phase! Expression Statement)]
  ["[1][0]" reference]
  ["[1][0]" primitive]
  ["/[1]" //
   ["[1][0]" reference]
   ["/[1]" //
    ["[1][0]" synthesis
     ["[1]/[0]" when]]
    ["/[1]" //
     ["[0]" phase (.use "[1]:[0]" monad)]
     ["[1][0]" translation]
     ["[0]" synthesis (.only)
      ["[0]" path]
      [access
       ["[0]" member (.only Member)]]]
     ["//[1]" ///
      [meta
       [archive (.only Archive)]]]]]]])

(the .public register
  (-> Register
      Var)
  (|>> (///reference.local //reference.system) as_expected))

(the .public capture
  (-> Register
      Var)
  (|>> (///reference.foreign //reference.system) as_expected))

(the .public (exec expression archive it)
  (Expression synthesis.Exec)
  (monad.let [! phase.monad]
    [.let [[tail after] (synthesis.flat_exec (.its synthesis.:exec_after it))]
     all_before (list.each' ! (expression archive)
                            (list:composite (list (.its synthesis.:exec_before it))
                                            tail))
     after (expression archive after)]
    (pure (_.item (_.int +2)
                  (_.array (list (_.array all_before)
                                 after))))))

(the .public (exec! statement expression archive [this that])
  (Statement synthesis.Exec)
  (monad.let [! phase.monad]
    [this (expression archive this)
     that (statement expression archive that)
     $dummy (by ! each _.var (/////translation.name "_exec"))]
    (pure (all _.then
               (_.local/1 $dummy this)
               that))))

(the .public (let expression archive [head_binding head_value body])
  (Expression synthesis.Let)
  (monad.let [! phase.monad]
    [.let [[tail body] (synthesis.flat_let body)]
     bindings (list.each' ! (function (_ [binding value])
                              (phase:each (_.local/1 (..register binding))
                                          (expression archive value)))
                          (list:composite (list [head_binding head_value])
                                          tail))
     body (expression archive body)]
    ... TODO: Find some way to do 'let' without paying the price of the closure.
    (pure (<| (_.of (list))
              (_.closure (list))
              (list:mix _.then
                        (_.return body)
                        (list.in_reverse bindings))))))

(the .public (let! statement expression archive [register valueS bodyS])
  (Statement synthesis.Let)
  (monad.let phase.monad
    [valueO (expression archive valueS)
     bodyO (statement expression archive bodyS)]
    (pure (all _.then
               (_.local/1 (..register register) valueO)
               bodyO))))

(the (projection it)
  (.if (.its member.:right? it)
       (//runtime.tuple//right (_.int (.integer (.its member.:lefts it))))
       (//runtime.tuple//left (_.int (.integer (.its member.:lefts it))))))

(the .public (its expression archive [pathP valueS])
  (Expression synthesis.Its)
  (monad.let phase.monad
    [valueO (expression archive valueS)]
    (pure (list:mix ..projection
                    valueO
                    pathP))))

(the .public (if! statement expression archive [testS thenS elseS])
  (Statement (synthesis.If synthesis.Term))
  (monad.let phase.monad
    [testO (expression archive testS)
     thenO (statement expression archive thenS)
     elseO (statement expression archive elseS)]
    (pure (_.if testO
                thenO
                elseO))))

(the .public (if expression archive [testS thenS elseS])
  (Expression (synthesis.If synthesis.Term))
  (monad.let phase.monad
    [testO (expression archive testS)
     thenO (expression archive thenS)
     elseO (expression archive elseS)]
    (pure (|> (_.if testO
                    (_.return thenO)
                    (_.return elseO))
              (_.closure (list))
              (_.of (list))))))

(the .public (variant_if! statement expression archive [test [the_then then] [the_else else]])
  (Statement (synthesis.If [(Maybe Register) synthesis.Term]))
  (monad.let [! phase.monad]
    [test (expression archive test)
     then (statement expression archive then)
     else (statement expression archive else)

     $test (by ! each _.var (/////translation.name "_test"))]
    (pure (.when [the_then the_else]
            [{.:Some the_then} {.:Some the_else}]
            (all _.then
                 (_.local/1 $test test)
                 (_.if (_.its //runtime.variant_flag_field $test)
                       (all _.then
                            (_.local/1 (..register the_else) (//runtime.sum//get $test //runtime.unit (_.int +0)))
                            else)
                       (all _.then
                            (_.local/1 (..register the_then) (_.its //runtime.variant_value_field $test))
                            then)))
            
            [{.:None} {.:Some the_else}]
            (all _.then
                 (_.local/1 $test test)
                 (_.if (_.its //runtime.variant_flag_field $test)
                       (all _.then
                            (_.local/1 (..register the_else) (//runtime.sum//get $test //runtime.unit (_.int +0)))
                            else)
                       then))
            
            [{.:Some the_then} {.:None}]
            (all _.then
                 (_.local/1 $test test)
                 (_.if (_.its //runtime.variant_flag_field $test)
                       else
                       (all _.then
                            (_.local/1 (..register the_then) (_.its //runtime.variant_value_field $test))
                            then)))
            
            [{.:None} {.:None}]
            (_.if (_.its //runtime.variant_flag_field test)
                  else
                  then)))))

(the .public (variant_if statement expression archive)
  (-> Phase!
      (Expression (synthesis.If [(Maybe Register) synthesis.Term])))
  (|>> (variant_if! statement expression archive)
       (phase:each (|>> (_.closure (list))
                        (_.of (list))))))

(the @savepoint (_.var "lux_pm_savepoint"))
(the @cursor (_.var "lux_pm_cursor"))
(the @temp (_.var "lux_pm_temp"))

(the (push! value)
  (-> _.Expression
      _.Statement)
  (_.; (|> (_.var "table.insert") (_.of (list @cursor value)))))

(the peek_and_pop
  _.Expression
  (|> (_.var "table.remove") (_.of (list @cursor))))

(the pop!
  _.Statement
  (_.; ..peek_and_pop))

(the peek
  _.Expression
  (_.item (_.length @cursor) @cursor))

(the save!
  _.Statement
  (_.; (|> (_.var "table.insert")
           (_.of (list @savepoint
                       (_.of (list @cursor
                                   (_.int +1)
                                   (_.length @cursor)
                                   (_.int +1)
                                   (_.table (list)))
                             (_.var "table.move")))))))

(the restore!
  _.Statement
  (_.local/1 @cursor (|> (_.var "table.remove") (_.of (list @savepoint)))))

(the fail! _.break)

(template.with [<name> <flag>]
  [(the (<name> simple? idx)
     (-> Bit Natural
         _.Statement)
     (all _.then
          (_.local/1 @temp (//runtime.sum//get ..peek <flag>
                                               (|> idx .integer _.int)))
          (.if simple?
               (_.when (_.= _.nil @temp)
                 fail!)
               (_.if (_.= _.nil @temp)
                     fail!
                     (..push! @temp)))))]

  [[left_choice  _.nil]
   [right_choice //runtime.unit]])

(the (alternation pre! post!)
  (-> _.Statement _.Statement
      _.Statement)
  (all _.then
       (_.while (_.boolean true)
                (all _.then
                     ..save!
                     pre!))
       (all _.then
            ..restore!
            post!)))

(the (pattern_matching' statement expression archive)
  (-> Phase! Phase Archive (path.Path synthesis.Term)
      (Operation _.Statement))
  (function (of pathP)
    (`` (.when pathP
          {path.:Then bodyS}
          (statement expression archive bodyS)

          {path.:Pop}
          (phase:pure ..pop!)

          {path.:Bind register}
          (phase:pure (_.local/1 (..register register) ..peek))

          {path.:Bit_Fork when thenP elseP}
          (monad.let [! phase.monad]
            [then! (of thenP)
             else! (.when elseP
                     {.:Some elseP}
                     (of elseP)

                     {.:None}
                     (pure ..fail!))]
            (pure (.if when
                       (_.if ..peek
                             then!
                             else!)
                       (_.if ..peek
                             else!
                             then!))))

          (,, (template.with [<tag> <injection>]
                [{<tag> [head tail]}
                 (monad.let [! phase.monad]
                   ['input (phase:each _.var (/////translation.name "input"))
                    clauses (list.each' ! (function (_ [match then])
                                            (monad.let !
                                              [then! (of then)]
                                              (pure [(_.= (<injection> match)
                                                          'input)
                                                     then!])))
                                        (list:composite (list head) tail))]
                   (pure (all _.then
                              (_.local/1 'input ..peek)
                              (list:mix (function (_ [when then!] else!)
                                          (_.if when then! else!))
                                        ..fail!
                                        (list.in_reverse clauses)))))]

                [[path.:I64_Fork //primitive.i64]
                 [path.:F64_Fork //primitive.f64]
                 [path.:Text_Fork //primitive.text]]))

          (,, (template.with [<complex> <simple> <choice>]
                [(<complex> idx)
                 (phase:pure (<choice> false idx))

                 (<simple> idx nextP)
                 (phase:each (_.then (<choice> true idx)) (of nextP))]

                [[path.left_side  path.simple_left_side  ..left_choice]
                 [path.right_side path.simple_right_side ..right_choice]]))

          (path.left_member 0)
          (phase:pure (|> ..peek (_.item (_.int +1)) ..push!))
          
          (,, (template.with [<pm> <getter>]
                [(<pm> lefts)
                 (phase:pure (|> ..peek (<getter> (_.int (.integer lefts))) ..push!))]

                [[path.left_member  //runtime.tuple//left]
                 [path.right_member //runtime.tuple//right]]))

          {path.:List size}
          (phase:pure (_.when (_.not (_.= (_.int (.integer size))
                                          (_.length ..peek)))
                        ..fail!))

          (path.item index)
          (phase:pure (..push! (_.item (_.int (.integer (++ index))) ..peek)))

          (path.bind_top register thenP)
          (monad.let phase.monad
            [then! (of thenP)]
            (phase:pure (all _.then
                             (_.local/1 (..register register) ..peek_and_pop)
                             then!)))

          (,, (template.with [<tag> <combinator>]
                [{<tag> preP postP}
                 (monad.let phase.monad
                   [pre! (of preP)
                    post! (of postP)]
                   (pure (<combinator> pre! post!)))]

                [[path.:And _.then]
                 [path.:Or ..alternation]]))))))

(the (pattern_matching statement expression archive pathP)
  (-> Phase! Phase Archive (path.Path synthesis.Term)
      (Operation _.Statement))
  (monad.let phase.monad
    [pattern_matching! (pattern_matching' statement expression archive pathP)]
    (pure (all _.then
               (_.while (_.boolean true)
                        pattern_matching!)
               (_.; (|> (_.var "error") (_.of (list (_.string ////synthesis/when.pattern_matching_error)))))))))

(the .public dependencies
  (-> (path.Path synthesis.Term)
      (List Var))
  (|>> ////synthesis/when.storage
       (.its ////synthesis/when.:dependencies)
       set.as_list
       (list:each (function (_ variable)
                    (.when variable
                      {@type.:Local register}
                      (..register register)
                      
                      {@type.:Foreign register}
                      (..capture register))))))

(the .public (when! statement expression archive [valueS pathP])
  (Statement [synthesis.Term (path.Path synthesis.Term)])
  (monad.let phase.monad
    [start (expression archive valueS)
     pattern_matching! (pattern_matching statement expression archive pathP)]
    (pure (all _.then
               (_.local (list @temp))
               (_.local/1 @cursor (_.array (list start)))
               (_.local/1 @savepoint (_.array (list)))
               pattern_matching!))))

(the .public (when statement expression archive [valueS pathP])
  (-> Phase!
      (Expression [synthesis.Term (path.Path synthesis.Term)]))
  (|> [valueS pathP]
      (..when! statement expression archive)
      (phase:each (|>> (_.closure (list))
                       (_.of (list))))))

(the .public (multi_let! statement expression archive [input bindings body])
  (Statement synthesis.Multi_Let)
  (monad.let phase.monad
    [input (expression archive input)
     body (statement expression archive body)
     'tuple (phase:each _.var (/////translation.name "tuple"))]
    (pure (all _.then
               (list:mix (function (_ [register member] left)
                           (all _.then
                                left
                                (_.local/1 (..register register) (..projection member 'tuple))))
                         (_.local/1 'tuple input)
                         bindings)
               body))))

(the .public (multi_let statement expression archive)
  (-> Phase!
      (Expression synthesis.Multi_Let))
  (|>> (multi_let! statement expression archive)
       (phase:each (|>> (_.closure (list))
                        (_.of (list))))))

(template.with [,lux ,host]
  [(the .public (,lux expression archive [parameter subject])
     (Expression [synthesis.Term synthesis.Term])
     (monad.let phase.monad
       [parameter (expression archive parameter)
        subject (expression archive subject)]
       (pure (,host parameter subject))))]

  [[or _.or]
   [and _.and]])

(template.with [,expression ,statement ,type ,injection]
  [(the .public (,statement statement expression archive [input clauses else])
     (Statement [synthesis.Term (List [,type synthesis.Term]) synthesis.Term])
     (monad.let [! phase.monad]
       [input (expression archive input)
        'input (phase:each _.var (/////translation.name "input"))
        clauses (list.each' ! (function (_ [when then])
                                (by ! each (|>> [when]) (statement expression archive then)))
                            clauses)
        else (statement expression archive else)]
       (pure (all _.then
                  (_.local/1 'input input)
                  (list:mix (function (_ [when then] else)
                              (_.if (_.= (,injection when)
                                         'input)
                                    then
                                    else))
                            else
                            (list.in_reverse clauses))))))

   (the .public (,expression statement expression archive)
     (-> Phase!
         (Expression [synthesis.Term (List [,type synthesis.Term]) synthesis.Term]))
     (|>> (,statement statement expression archive)
          (phase:each (|>> (_.closure (list))
                           (_.of (list))))))]

  [[when_i64 when_i64! I64 //primitive.i64]
   [when_f64 when_f64! F64 //primitive.f64]
   [when_text when_text! Text //primitive.text]])
