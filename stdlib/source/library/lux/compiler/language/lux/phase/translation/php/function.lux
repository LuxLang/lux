... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except Global
                function)
   [abstract
    ["[0]" monad (.only do)]]
   [control
    pipe]
   [data
    ["[0]" product]
    ["[0]" text (.only)
     ["%" \\injection]]
    [collection
     ["[0]" stack (.use "[1]#[0]" functor mix)]]]
   [meta
    [target
     ["_" php (.only Var Global Argument Label)]]]]]
 ["[0]" //
  ["[1][0]" runtime (.only Operation Phase Phase! Expression)]
  ["[1][0]" reference]
  ["[1][0]" when]
  ["/[1]" //
   ["[1][0]" reference]
   ["//[1]" ///
    [analysis (.only Variant Tuple Abstraction Application Analysis)]
    [synthesis (.only Synthesis)]
    ["[1][0]" translation (.only Context)]
    ["//[1]" ///
     [arity (.only Arity)]
     ["[1][0]" phase (.use "[1]#[0]" monad)]
     [reference
      [variable (.only Register Variable)]]]]]])

(the .public (reification expression archive [functionS argsS+])
  (Expression (Application Synthesis))
  (do [! ///////phase.monad]
    [functionG (expression archive functionS)
     argsG+ (monad.each ! (expression archive) argsS+)]
    (in (_.apply' argsG+ functionG))))

(the capture
  (-> Register Var)
  (|>> (///reference.foreign //reference.system) as_expected))

(the input
  (|>> ++ //when.register))

(the (@scope function_name)
  (-> Context Label)
  (_.label (text (///reference.artifact function_name) "_scope")))

(the (with_closure inits @selfG @selfL body!)
  (-> (Stack _.Expression) Global Var _.Statement
      [_.Statement _.Expression])
  (when inits
    {.#Empty}
    [(all _.then
          (_.set! @selfL (_.closure (stack (_.reference @selfL)) (stack) body!))
          (_.set! @selfG @selfL))
     @selfG]

    _
    (let [@inits (|> (stack.enumeration inits)
                     (stack#each (|>> product.left ..capture)))]
      [(_.set! @selfG (_.closure (stack) (stack#each _.parameter @inits)
                                 (all _.then
                                      (_.set! @selfL (_.closure (stack.partial (_.reference @selfL) (stack#each _.reference @inits))
                                                                (stack)
                                                                body!))
                                      (_.return @selfL))))
       (_.apply inits @selfG)])))

(the .public (function statement expression archive [environment arity bodyS])
  (-> Phase!
      (Expression (Abstraction Synthesis)))
  (do [! ///////phase.monad]
    [[function_name body!] (/////translation.with_new_context archive
                             (do !
                               [@scope (by ! each ..@scope
                                           (/////translation.context archive))]
                               (/////translation.with_anchor [1 @scope]
                                 (statement expression archive bodyS))))
     closureG+ (monad.each ! (expression archive) environment)
     .let [@curried (_.var "curried")
           arityG (|> arity .integer _.int)
           @num_args (_.var "num_args")
           @scope (..@scope function_name)
           @selfG (_.global (///reference.artifact function_name))
           @selfL (_.var (///reference.artifact function_name))
           initialize_self! (_.set! (//when.register 0) @selfL)
           initialize! (stack#mix (.function (_ post pre!)
                                    (all _.then
                                         pre!
                                         (_.set! (..input post) (_.item (|> post .integer _.int) @curried))))
                                  initialize_self!
                                  (stack.indices arity))]
     .let [[definition instantiation] (..with_closure closureG+ @selfG @selfL
                                        (all _.then
                                             (_.set! @num_args (_.func_num_args/0 []))
                                             (_.set! @curried (_.func_get_args/0 []))
                                             (_.cond (stack [(|> @num_args (_.=== arityG))
                                                             (all _.then
                                                                  initialize!
                                                                  (_.set_label @scope)
                                                                  body!)]
                                                            [(|> @num_args (_.> arityG))
                                                             (let [arity_inputs (_.array_slice/3 [@curried (_.int +0) arityG])
                                                                   extra_inputs (_.array_slice/2 [@curried arityG])
                                                                   next (_.call_user_func_array/2 [@selfL arity_inputs])]
                                                               (_.return (_.call_user_func_array/2 [next extra_inputs])))])
                                                     ... (|> @num_args (_.< arityG))
                                                     (let [@missing (_.var "missing")]
                                                       (_.return (<| (_.closure (stack (_.reference @selfL) (_.reference @curried)) (stack))
                                                                     (all _.then
                                                                          (_.set! @missing (_.func_get_args/0 []))
                                                                          (_.return (_.call_user_func_array/2 [@selfL (_.array_merge/+ @curried (stack @missing))])))))))
                                             ))]
     _ (/////translation.execute! definition)
     _ (/////translation.save! (product.right function_name) definition)]
    (in instantiation)))
