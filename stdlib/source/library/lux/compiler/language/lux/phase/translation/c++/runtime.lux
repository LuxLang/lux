... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except Type Declaration
                Bit I64 F64 Text Variant Tuple
                variant tuple function false true left right)
   [abstract
    [monad (.only do)]]
   [data
    ["[0]" product]
    [text
     ["%" \\injection]
     [encoding
      ["[0]" utf8]]]
    [collection
     ["[0]" list]
     ["[0]" sequence]]]
   [macro
    ["[0]" syntax]
    ["[0]" expansion]
    ["[0]" template]]
   ["[0]" meta (.use "[1]#[0]" functor)
    ["[0]" code]]
   [target
    ["_" c++ (.only)
     ["[0]" type]]]]]
 ["[0]" //
  ["[1][0]" type]]
 [/////
  ["[0]" phase]
  ["[0]" synthesis]
  ["[0]" translation]
  [///
   [reference
    [register (.only Register)]]
   [meta
    [archive (.only Output Archive)
     ["[0]" registry (.only Registry)]
     ["[0]" artifact]
     ["[0]" unit]]]]])

(every .public Anchor
  [Register _.Label])

(every .public Value
  _.Expression)

(every .public Declaration
  _.Declaration)

(template.with [<name> <base>]
  [(every .public <name>
     (<base> Anchor Value Declaration))]

  [Operation translation.Operation]
  [Phase translation.Phase]
  [Handler translation.Handler]
  [Bundle translation.Bundle]
  )

(every .public Host
  (translation.Host Value Declaration))

(every .public (Expression it)
  (-> Phase Archive (it synthesis.Term)
      (Operation Value)))

(every .public Phase'
  (-> Phase Archive synthesis.Term
      (Operation _.Statement)))

(every .public (Statement it)
  (-> Phase' Phase Archive (it synthesis.Term)
      (Operation _.Statement)))

(the .public namespace
  _.Namespace
  "lux")

(the name
  (syntax.macro (_ [])
    (|> meta.seed
        (meta#each (|>> %.natural_16
                        (text "_")
                        code.text
                        list)))))

(expansion.let [<clean_up> (..name)

                <Text> (..name)
                <Text#data> (..name)
                <Text#length> (..name)
                <Text#dynamic?> (..name)

                <Variant> (..name)
                <Variant#lefts> (..name)
                <Variant#right?> (..name)
                <Variant#choice> (..name)

                <Tuple> (..name)
                <Tuple#arity> (..name)
                <Tuple#values> (..name)

                <Function> (..name)

                <Tag> (..name)
                <Tag#Bit> (..name)
                <Tag#I64> (..name)
                <Tag#F64> (..name)
                <Tag#Text> (..name)
                <Tag#Variant> (..name)
                <Tag#Tuple> (..name)
                <Tag#Function> (..name)

                <Object> (..name)
                <Object#tag> (..name)
                <Object#value> (..name)

                <object_tag> (..name)
                <lux_bit> (..name)
                <lux_i64> (..name)
                <lux_text> (..name)

                <variant::lefts> (..name)
                <variant::right?> (..name)
                <variant::choice> (..name)

                <tuple::arity> (..name)
                <tuple::member> (..name)

                <function::on> (..name)

                <Stack> (..name)
                <Stack#top> (..name)
                <Stack#bottom> (..name)
                <stack::pop> (..name)]
  (these (template.with [<code> <name>]
           [(the .public <name>
              Natural
              <code>)]

           [0 bit_tag]
           [1 i64_tag]
           [2 f64_tag]
           [3 text_tag]
           [4 variant_tag]
           [5 tuple_tag]
           [6 function_tag]
           )

         (template.with [<lux> <rt>]
           [(the .public <lux>
              .Text
              <rt>)]

           [object_tag <object_tag>]
           [lux_bit <lux_bit>]
           [lux_i64 <lux_i64>]
           [lux_text <lux_text>]

           [variant::lefts <variant::lefts>]
           [variant::right? <variant::right?>]
           [variant::choice <variant::choice>]

           [tuple::arity <tuple::arity>]
           [tuple::member <tuple::member>]
           )
         
         (the object_type
           _.Type
           (_.type (_.global [(list ..namespace) <Object>] (list))))

         (the .public value_type
           _.Type
           (type.shared_ptr object_type))

         (the .public arguments_type
           _.Type
           (type.constant (type.array ..value_type)))

         (the .public partials_type
           _.Type
           ..arguments_type)

         (the closure_type
           _.Type
           (type.lambda (list value_type ..arguments_type) value_type))
         
         (the .public clean_up
           (-> _.Type
               _.Expression)
           (|>> (list)
                (_.global [(list ..namespace) <clean_up>])))

         (every .public Type
           [_.Expression _.Type])

         (the text_data_type
           (type.constant (type.array //type.char)))

         (the .public text_type
           (_.type (_.global [(list ..namespace) <Text>] (list))))

         (the variant_type
           (_.type (_.global [(list ..namespace) <Variant>] (list))))

         (the .public tuple_type
           (_.type (_.global [(list ..namespace) <Tuple>] (list))))

         (the function_type
           _.Type
           (_.type (_.global [(list ..namespace) <Function>] (list))))

         (template.with [<name> <tag> <type>]
           [(the .public <name>
              ..Type
              [(_.global [(list ..namespace <Tag>) <tag>] (list))
               <type>])]

           [Bit <Tag#Bit> //type.bit]
           [I64 <Tag#I64> //type.i64]
           [F64 <Tag#F64> //type.f64]
           [Text <Tag#Text> ..text_type]
           [Variant <Tag#Variant> ..variant_type]
           [Tuple <Tag#Tuple> ..tuple_type]
           [Function <Tag#Function> ..function_type]
           )

         (the (lux_value [tag of] it)
           (-> ..Type _.Expression
               _.Expression)
           (_.of (list (_.new (_.structure object_type (list tag it)))
                       (clean_up of))
                 (_.global [(list _.standard) "shared_ptr"] (list object_type))))

         (the (std::data it)
           (-> _.Expression
               _.Expression)
           (_.of (list it)
                 (_.global [(list _.standard) "data"] (list))))

         (the .public (of arguments abstraction)
           (-> (List _.Expression) _.Expression
               _.Expression)
           (_.of (list (|> arguments list.size .integer _.int)
                       (std::data (_.structure (type.initializer_list ..value_type) arguments))
                       abstraction)
                 (_.global [(list ..namespace) <function::on>] (list))))

         (the .public (host_value of it)
           (-> _.Type _.Expression
               _.Expression)
           (|> it
               (_.its* <Object#value>)
               (_.is (type.address of))))

         (the .public (simple [tag of] it)
           (-> ..Type _.Expression
               _.Expression)
           (lux_value [tag of]
                      (_.new (_.of (list it) of))))

         (template.with [<dynamic?> <name>]
           [(the .public (<name> length data)
              (-> _.Expression _.Expression
                  _.Expression)
              (|> (list data length (_.bool <dynamic?>))
                  (_.structure ..text_type)))]

           [0b static_text]
           [1b dynamic_text]
           )

         (the text_length
           (-> _.Expression
               _.Expression)
           (_.its <Text#length>))

         (the text_data
           (-> _.Expression
               _.Expression)
           (_.its <Text#data>))

         (the .public (variant lefts right? choice)
           (-> _.Expression _.Expression _.Expression
               _.Expression)
           (|> (list lefts right? choice)
               (_.structure ..variant_type)
               _.new
               (lux_value ..Variant)))

         (the .public (tuple values)
           (-> (List _.Expression)
               _.Expression)
           (let [arity (_.int (.integer (list.size values)))]
             (|> (list arity
                       (_.new (_.array value_type arity values)))
                 (_.structure ..tuple_type)
                 _.new
                 (lux_value ..Tuple))))

         (the .public (function' partiality partials arity it)
           (-> _.Expression _.Expression _.Expression _.Expression
               _.Expression)
           (|> (list arity
                     partiality
                     partials
                     it)
               (_.structure ..function_type)
               _.new
               (lux_value ..Function)))

         (the .public (function arity it)
           (-> _.Expression _.Expression
               _.Expression)
           (let [partiality (_.int +0)]
             (function' partiality
                        (_.new (_.array value_type partiality (list)))
                        arity
                        it)))

         (the .public (stack of)
           (-> _.Type
               _.Type)
           (_.type (_.global [(list ..namespace) <Stack>] (list of))))

         (the .public road
           _.Type
           (..stack ..value_type))

         (the .public fork
           _.Type
           (..stack (type.address ..road)))

         (the .public (pop it)
           (-> _.Expression
               _.Expression)
           (_.of (list it)
                 (_.global [(list ..namespace) <stack::pop>] (list))))

         (the .public (push of top bottom)
           (-> _.Type _.Expression _.Expression
               _.Expression)
           (_.new (_.structure (..stack of) (list top bottom))))

         (the .public peek
           (-> _.Expression
               _.Expression)
           (_.its* <Stack#top>))

         (the tag (_.local <Tag>))
         
         (the tag_definition
           _.Declaration
           (<| (_.enum_definition tag)
               (list (_.local <Tag#Bit>)
                     (_.local <Tag#I64>)
                     (_.local <Tag#F64>)
                     (_.local <Tag#Text>)
                     (_.local <Tag#Variant>)
                     (_.local <Tag#Tuple>)
                     (_.local <Tag#Function>))))

         (the object_definition
           _.Declaration
           (let [$Object (_.local <Object>)
                 :Object (_.type $Object)]
             (all _.also
                  (<| (_.structure_definition $Object (list))
                      [(list [(_.local <Object#tag>) (_.type tag)]
                             [(_.local <Object#value>) (type.address type.void)])
                       (list)])
                  
                  (let [of (_.type_name (..name))
                        it (_.local (..name))]
                    (_.function (_.local <clean_up>)
                      (list of)
                      (list [it (type.address :Object)])
                      type.void
                      (all _.then
                           (_.delete (host_value of it))
                           (_.delete it)
                           )))
                  )))

         (expansion.let [<null> (..name)
                         <unit> (..name)
                         <false> (..name)
                         <true> (..name)]
           (these (the constant_definition
                    _.Declaration
                    (`` (all _.also
                             (_.constant (_.local <null>)
                                         value_type
                                         (_.of (list _.null)
                                               (_.global [(list _.standard) "shared_ptr"] (list object_type))))

                             (_.constant (_.local <unit>)
                                         value_type
                                         (..simple ..Text
                                                   (static_text (_.int +0) (_.u32_string ""))))

                             (,, (template.with [<bit> <name>]
                                   [(_.constant (_.local <name>)
                                                value_type
                                                (..simple ..Bit (_.bool <bit>)))]

                                   [0b <false>]
                                   [1b <true>]
                                   ))
                             )))

                  (template.with [<lux> <runtime>]
                    [(the .public <lux>
                       _.Expression
                       (_.global [(list ..namespace) <runtime>] (list)))]

                    [null <null>]
                    [unit <unit>]
                    
                    [false <false>]
                    [true <true>]
                    )))

         (expansion.let [<composite> (..name)
                         <=> (..name)]
           (these (the (copy_text! from to)
                    (-> _.Expression _.Expression
                        _.Statement)
                    (let [item (_.local (..name))]
                      (_.for (list [item type.int (_.int +0)])
                             (_.< (text_length from) item)
                             (_.; (_.:= item (_.+ (_.int +1) item)))
                             (_.; (_.:= (_.item item to)
                                        (_.item item (text_data from)))))))

                  (the text_definition
                    _.Declaration
                    (all _.also
                         (let [$Text (_.local <Text>)
                               $Text/data (_.local <Text#data>)
                               $Text/dynamic? (_.local <Text#dynamic?>)]
                           (<| (_.structure_definition $Text (list))
                               [(list [$Text/data text_data_type]
                                      [(_.local <Text#length>) //type.i64]
                                      [$Text/dynamic? //type.bit])
                                (list (<| _.destructor
                                          (_.if $Text/dynamic?
                                                (_.delete_array $Text/data)
                                                {.#None})))]))

                         (let [it (_.local (..name))
                               length (_.local (..name))
                               part (_.local (..name))
                               data (_.local (..name))
                               offset (_.local (..name))]
                           (_.function (_.local <composite>)
                             (list)
                             (list [it (type.initializer_list ..text_type)])
                             ..text_type
                             (all _.then
                                  (_.variable length //type.i64 (_.int64_t (_.int +0)))
                                  (<| (_.for_each part it)
                                      (_.; (_.:= length (_.+ length (text_length part)))))
                                  
                                  (_.constant data
                                              (type.array //type.char)
                                              (_.new (_.array //type.char length (list))))
                                  
                                  (_.variable offset //type.i64 (_.int64_t (_.int +0)))
                                  (<| (_.for_each part it)
                                      (all _.then
                                           (copy_text! part (_.+ offset data))
                                           (_.; (_.:= offset (_.+ offset (text_length part))))
                                           ))
                                  (_.return (..dynamic_text length data)))))

                         (let [reference (_.local (..name))
                               it (_.local (..name))
                               item (_.local (..name))]
                           (_.function (_.local <=>)
                             (list)
                             (list [reference ..text_type]
                                   [it ..text_type])
                             //type.bit
                             (_.if (_.= (_.its <Text#length> reference)
                                        (_.its <Text#length> it))
                                   (all _.then
                                        (_.for (list [item //type.i64 (_.int +0)])
                                               (_.< (_.its <Text#length> reference)
                                                    item)
                                               (_.; (_.:= item (_.+ (_.int +1) item)))
                                               (_.if (_.not (_.= (_.item item (_.its <Text#data> reference))
                                                                 (_.item item (_.its <Text#data> it))))
                                                     (_.return (_.bool .false))
                                                     {.#None}))
                                        (_.return (_.bool .true)))
                                   {.#Some (_.return (_.bool .false))})))
                         ))

                  (the .public (text_composite it)
                    (-> (List _.Expression)
                        _.Expression)
                    (|> (_.of (list (_.structure (type.initializer_list ..text_type) it))
                              (_.global [(list ..namespace) <composite>] (list)))
                        (..simple ..Text)))

                  (the .public (text_= reference it)
                    (-> _.Expression _.Expression
                        _.Expression)
                    (_.of (list reference it)
                          (_.global [(list ..namespace) <=>] (list)))))
           )

         (expansion.let [<choice> (..name)]
           (these (the variant_definition
                    _.Declaration
                    (all _.also
                         (<| (_.structure_definition (_.local <Variant>) (list))
                             [(list [(_.local <Variant#lefts>) //type.lefts]
                                    [(_.local <Variant#right?>) //type.right?]
                                    [(_.local <Variant#choice>) value_type])
                              (list)])

                         (let [expected_lefts (_.local (..name))
                               expected_right? (_.local (..name))
                               it (_.local (..name))]
                           (_.function (_.local <choice>)
                             (list)
                             (list [expected_lefts //type.lefts]
                                   [expected_right? //type.right?]
                                   [it ..value_type])
                             ..value_type
                             (let [real_value (host_value ..variant_type it)
                                   it (_.local (..name))
                                   
                                   mismatch! (_.return ..null)
                                   actual_lefts (_.its* <Variant#lefts> it)
                                   actual_right? (_.its* <Variant#right?> it)
                                   actual_value (_.its* <Variant#choice> it)

                                   @loop (_.label (..name))
                                   next! (all _.then
                                              (_.; (_.:= expected_lefts (|> expected_lefts
                                                                            (_.- actual_lefts)
                                                                            (_.- (_.int +1)))))
                                              (_.; (_.:= it (host_value ..variant_type actual_value)))
                                              (_.go_to @loop))]
                               (<| _.block
                                   (all _.then
                                        (_.variable it (type.address ..variant_type) real_value)
                                        (_.set_label @loop)
                                        (<| (_.if (_.= expected_lefts actual_lefts)
                                                  (_.if (_.= expected_right? actual_right?)
                                                        (_.return actual_value)
                                                        {.#Some mismatch!}))
                                            {.#Some}
                                            (_.if (_.< expected_lefts actual_lefts)
                                                  (_.if actual_right?
                                                        mismatch!
                                                        {.#Some next!}))
                                            {.#Some}
                                            (_.if expected_right?
                                                  mismatch!
                                                  {.#Some (_.return (..variant (|> actual_lefts
                                                                                   (_.- expected_lefts)
                                                                                   (_.- (_.int +1))
                                                                                   (_.is //type.lefts))
                                                                               actual_right?
                                                                               actual_value))})))))))
                         ))

                  (the .public (choice lefts right? it)
                    (-> Natural .Bit _.Expression
                        _.Expression)
                    (_.of (list (_.int (.integer lefts)) (_.bool right?) it)
                          (_.global [(list ..namespace) <choice>] (list)))))
           )

         (expansion.let [<skip> (..name)

                         <left> (..name)
                         <right> (..name)]
           (these (the length
                    (-> _.Expression
                        _.Expression)
                    (_.its <Tuple#arity>))

                  (the last_index
                    (-> _.Expression
                        _.Expression)
                    (|>> ..length
                         (_.- (_.int +1))))

                  (the (last_element it)
                    (-> _.Expression
                        _.Expression)
                    (_.item (..last_index it)
                            it))

                  (the (skip lefts it)
                    (-> _.Expression _.Expression
                        _.Expression)
                    (_.of (list lefts it)
                          (_.global [(list ..namespace) <skip>] (list))))

                  (template.with [<lux> <runtime>]
                    [(the .public (<lux> lefts it)
                       (-> _.Expression _.Expression
                           _.Expression)
                       (_.of (list lefts it)
                             (_.global [(list ..namespace) <runtime>] (list))))]

                    [left <left>]
                    [right <right>]
                    )

                  (the tuple_definition
                    _.Declaration
                    (let [values (_.local <Tuple#values>)

                          lefts (_.local (..name))
                          it (_.local (..name))

                          last_index_right (_.local (..name))
                          @loop (_.label (..name))
                          next! (these (all _.then
                                            (_.; (_.:= lefts (_.- last_index_right lefts)))
                                            (_.; (_.:= it (|> it
                                                              (_.its <Tuple#values>)
                                                              (_.item last_index_right)
                                                              (host_value ..tuple_type)
                                                              _.at)))
                                            (_.go_to @loop)))]
                      (all _.also
                           (<| (_.structure_definition (_.local <Tuple>) (list))
                               [(list [(_.local <Tuple#arity>) //type.arity]
                                      [values (type.array ..value_type)])
                                (list (<| _.destructor
                                          (_.delete_array values)))])

                           (_.function (_.local <left>)
                             (list)
                             (list [lefts //type.lefts]
                                   [it ..tuple_type])
                             ..value_type
                             (<| _.block
                                 (all _.then
                                      (_.constant last_index_right //type.lefts (..last_index it))
                                      (_.set_label @loop)
                                      (_.if (_.> lefts last_index_right)
                                            ... No need for recursion
                                            (_.return (_.item lefts (_.its <Tuple#values> it)))
                                            ... Needs recursion
                                            {.#Some next!}))))

                           (let [new_length (_.local (..name))
                                 output (_.local (..name))
                                 item (_.local (..name))]
                             (_.function (_.local <skip>)
                               (list)
                               (list [lefts //type.lefts]
                                     [it ..tuple_type])
                               ..value_type
                               (<| _.block
                                   (all _.then
                                        (_.constant new_length
                                                    //type.lefts
                                                    (_.- lefts (..length it)))
                                        (_.constant output
                                                    (type.array ..value_type)
                                                    (_.new (_.array ..value_type new_length (list))))
                                        (_.for (list [item //type.lefts (_.int +0)])
                                               (_.< new_length item)
                                               (_.; (_.:= item (_.+ (_.int +1) item)))
                                               (_.; (_.:= (_.item item output)
                                                          (_.item (_.+ lefts item)
                                                                  (_.its <Tuple#values> it)))))
                                        (_.return (|> (list new_length output)
                                                      (_.structure ..tuple_type)
                                                      _.new
                                                      (lux_value ..Tuple)))))))

                           (let [right_index (_.local (..name))]
                             (_.function (_.local <right>)
                               (list)
                               (list [lefts //type.lefts]
                                     [it ..tuple_type])
                               ..value_type
                               (<| _.block
                                   (all _.then
                                        (_.constant last_index_right //type.lefts (..last_index it))
                                        (_.constant right_index //type.lefts (_.+ (_.int +1) lefts))
                                        (_.set_label @loop)
                                        (<| (_.if (_.= last_index_right right_index)
                                                  (_.return (_.item right_index (_.its <Tuple#values> it))))
                                            {.#Some}
                                            (_.if (_.> last_index_right right_index)
                                                  ... Needs recursion.
                                                  next!)
                                            {.#Some}
                                            (_.return (skip right_index it)))))))
                           )))))

         (expansion.let [<arity> (..name)
                         <partiality> (..name)
                         <partials> (..name)
                         <closure> (..name)]
           (the function_definition
             _.Declaration
             (all _.also
                  (let [partials (_.local <partials>)]
                    (<| (_.structure_definition (_.local <Function>) (list))
                        [(list [(_.local <arity>) //type.arity]
                               [(_.local <partiality>) //type.arity]
                               [partials ..partials_type]
                               [(_.local <closure>) ..closure_type])
                         (list (<| _.destructor
                                   (_.delete_array partials)))]))

                  (let [function::on (_.local <function::on>)
                        
                        current_arity (_.local (..name))
                        arguments (_.local (..name))
                        it (_.local (..name))

                        partiality (_.local (..name))
                        expected_arity (_.local (..name))
                        actual_arity (_.local (..name))

                        partials (is (-> _.Local _.Local _.Local _.Local
                                         _.Local
                                         _.Statement)
                                     (.function (_ old_partiality old_values new_partiality new_values
                                                   output)
                                       (let [full_partiality (_.local (..name))
                                             item (_.local (..name))]
                                         (all _.then
                                              (_.constant full_partiality
                                                          //type.arity
                                                          (_.+ old_partiality new_partiality))
                                              (_.constant output
                                                          (type.array ..value_type)
                                                          (_.new (_.array value_type full_partiality (list))))
                                              (_.for (list [item type.int (_.int +0)])
                                                     (_.< old_partiality item)
                                                     (_.; (_.:= item (_.+ (_.int +1) item)))
                                                     (_.; (_.:= (_.item item output)
                                                                (_.item item old_values))))
                                              (_.for (list [item type.int (_.int +0)])
                                                     (_.< new_partiality item)
                                                     (_.; (_.:= item (_.+ (_.int +1) item)))
                                                     (_.; (_.:= (_.item (_.+ old_partiality item) output)
                                                                (_.item item new_values))))
                                              ))))
                        on#exact (is (-> _.Local _.Local _.Local
                                         _.Local
                                         _.Statement)
                                     (.function (_ current_arity arguments it
                                                   partiality)
                                       (let [output (_.local (..name))
                                             all_arguments (_.local (..name))
                                             old_partials (_.local (..name))]
                                         (_.if (_.= (_.int +0) partiality)
                                               (all _.then
                                                    (_.constant output
                                                                ..value_type
                                                                (|> it
                                                                    (host_value function_type)
                                                                    (_.its* <closure>)
                                                                    (_.of (list it arguments))))
                                                    (_.return output))
                                               {.#Some (all _.then
                                                            (_.constant old_partials
                                                                        ..partials_type
                                                                        (|> it
                                                                            (host_value function_type)
                                                                            (_.its* <partials>)))
                                                            (partials partiality old_partials current_arity arguments
                                                                      all_arguments)
                                                            (_.constant output
                                                                        ..value_type
                                                                        (|> it
                                                                            (host_value function_type)
                                                                            (_.its* <closure>)
                                                                            (_.of (list it all_arguments))))
                                                            (_.delete_array all_arguments)
                                                            (_.return output))}))))
                        on#under (is (-> _.Local _.Local _.Local
                                         _.Local _.Local _.Local
                                         _.Statement)
                                     (.function (_ current_arity arguments it
                                                   partiality expected_arity actual_arity)
                                       (let [all_partials (_.local (..name))
                                             old_partials (_.local (..name))]
                                         (all _.then
                                              (_.constant old_partials
                                                          ..partials_type
                                                          (|> it
                                                              (host_value function_type)
                                                              (_.its* <partials>)))
                                              (partials partiality old_partials current_arity arguments
                                                        all_partials)
                                              (_.return (|> it
                                                            (host_value function_type)
                                                            (_.its* <closure>)
                                                            (function' actual_arity all_partials expected_arity)))
                                              ))))
                        on#over (is (-> _.Local _.Local _.Local
                                        _.Local _.Local
                                        _.Statement)
                                    (.function (_ current_arity arguments it
                                                  old_partiality expected_arity)
                                      (let [old_values (_.local (..name))
                                            cap_arity (_.local (..name))
                                            complete_arguments (_.local (..name))
                                            temporary (_.local (..name))
                                            new_partiality (_.local (..name))
                                            new_partials (_.local (..name))
                                            item (_.local (..name))
                                            output (_.local (..name))

                                            assemble_all_arguments!
                                            (all _.then
                                                 (_.constant old_values
                                                             ..partials_type
                                                             (|> it
                                                                 (host_value function_type)
                                                                 (_.its* <partials>)))
                                                 (_.constant cap_arity
                                                             //type.arity
                                                             (_.- old_partiality expected_arity))
                                                 (partials old_partiality old_values cap_arity arguments
                                                           complete_arguments))

                                            calculate_intermediate_result!
                                            (all _.then
                                                 (_.constant temporary
                                                             ..value_type
                                                             (|> it
                                                                 (host_value function_type)
                                                                 (_.its* <closure>)
                                                                 (_.of (list it complete_arguments))))
                                                 (_.delete_array complete_arguments))

                                            prepare_next_arguments!
                                            (all _.then
                                                 (_.constant new_partiality
                                                             //type.arity
                                                             (_.- cap_arity current_arity))
                                                 (_.constant new_partials
                                                             (type.array ..value_type)
                                                             (_.new (_.array value_type new_partiality (list))))
                                                 (_.for (list [item type.int (_.int +0)])
                                                        (_.< new_partiality item)
                                                        (_.; (_.:= item (_.+ (_.int +1) item)))
                                                        (_.; (_.:= (_.item item new_partials)
                                                                   (_.item (_.+ cap_arity item) arguments)))))]
                                        (all _.then
                                             assemble_all_arguments!
                                             calculate_intermediate_result!
                                             prepare_next_arguments!

                                             (_.constant output
                                                         ..value_type
                                                         (_.of (list new_partiality new_partials temporary)
                                                               function::on))
                                             (_.delete_array new_partials)
                                             (_.return output)))))]
                    (_.function function::on
                      (list)
                      (list [current_arity //type.arity]
                            [arguments ..arguments_type]
                            [it ..value_type])
                      ..value_type
                      (all _.then
                           (_.constant partiality
                                       //type.arity
                                       (_.its* <partiality> (host_value function_type it)))
                           (_.constant expected_arity
                                       //type.arity
                                       (_.its* <arity> (host_value function_type it)))
                           (_.constant actual_arity
                                       //type.arity
                                       (_.+ current_arity partiality))
                           (<| (_.if (_.= expected_arity actual_arity)
                                     (on#exact current_arity arguments it
                                               partiality))
                               {.#Some}
                               (_.if (_.< expected_arity actual_arity)
                                     (on#under current_arity arguments it
                                               partiality expected_arity actual_arity))
                               {.#Some}
                               (on#over current_arity arguments it
                                        partiality expected_arity))
                           )
                      ))
                  )))

         (the stack_definition
           _.Declaration
           (let [of (_.type_name (..name))
                 $Stack/bottom (_.local <Stack#bottom>)]
             (all _.also
                  (<| (_.structure_definition (_.local <Stack>) (list of))
                      [(list [(_.local <Stack#top>) of]
                             [$Stack/bottom (type.address (..stack of))])
                       (list (<| _.destructor
                                 (_.if $Stack/bottom
                                       (_.delete $Stack/bottom)
                                       {.#None})))])

                  (let [stack (type.address (..stack of))
                        it (_.local (..name))
                        bottom (_.local (..name))]
                    (_.function (_.local <stack::pop>)
                      (list of)
                      (list [it stack])
                      stack
                      (all _.then
                           (_.constant bottom stack (_.its* <Stack#bottom> it))
                           (_.delete it)
                           (_.return bottom)
                           )))
                  )))

         (the .public declaration
           _.Declaration
           (all _.also
                (_.include "memory")
                (_.include "codecvt")
                (_.include "locale")
                (_.include "functional")

                (<| (_.namespace {.#Some ..namespace})
                    (`` (all _.also
                             text_definition

                             tag_definition
                             object_definition
                             constant_definition
                             
                             variant_definition
                             tuple_definition
                             function_definition

                             stack_definition

                             ... Out functions
                             (let [it (_.local (..name))]
                               (_.function (_.local <object_tag>)
                                 (list)
                                 (list [it ..value_type])
                                 //type.i64
                                 (_.return (_.its* <Object#tag> it))))

                             (,, (template.with [<name> <type>]
                                   [(let [it (_.local (..name))]
                                      (_.function (_.local <name>)
                                        (list)
                                        (list [it ..value_type])
                                        <type>
                                        (_.return (_.at (host_value <type> it)))))]

                                   [<lux_bit> //type.bit]
                                   [<lux_i64> //type.i64]
                                   ))

                             (let [it (_.local (..name))
                                   value (_.local (..name))
                                   data (_.local (..name))
                                   converter (_.local (..name))
                                   converter_type (_.type (_.global [(list _.standard) "wstring_convert"]
                                                                    (list (_.type (_.global [(list _.standard) "codecvt_utf8"]
                                                                                            (list type.char_32)))
                                                                          type.char_32)))]
                               (_.function (_.local <lux_text>)
                                 (list)
                                 (list [it ..value_type])
                                 type.string
                                 (all _.then
                                      (_.constant value (type.address text_type) (host_value text_type it))
                                      (_.constant data text_data_type (_.its* <Text#data> value))
                                      (_.var_declaration converter converter_type)
                                      (_.return (_.do "to_bytes"
                                                  (list)
                                                  (list data
                                                        (_.+ data
                                                             (_.its* <Text#length> value)))
                                                  converter)))))

                             (,, (template.with [<name> <field> <type>]
                                   [(let [it (_.local (..name))]
                                      (_.function (_.local <name>)
                                        (list)
                                        (list [it ..value_type])
                                        <type>
                                        (_.return (_.its* <field> (host_value ..variant_type it)))))]

                                   [<variant::lefts> <Variant#lefts> //type.i64]
                                   [<variant::right?> <Variant#right?> //type.bit]
                                   [<variant::choice> <Variant#choice> ..value_type]
                                   ))

                             (let [it (_.local (..name))]
                               (_.function (_.local <tuple::arity>)
                                 (list)
                                 (list [it ..value_type])
                                 //type.i64
                                 (_.return (_.its* <Tuple#arity> (host_value ..tuple_type it)))))

                             (let [item (_.local (..name))
                                   it (_.local (..name))]
                               (_.function (_.local <tuple::member>)
                                 (list)
                                 (list [item //type.i64]
                                       [it ..value_type])
                                 ..value_type
                                 (_.return (_.item item (_.its* <Tuple#values> (host_value ..tuple_type it))))))
                             )))))

         (the .public tuple_values
           (-> _.Expression
               _.Expression)
           (|>> (..host_value ..tuple_type)
                (_.its* <Tuple#values>))))
  )

(the .public id
  artifact.ID
  0)

(the .public translation
  (Operation [Registry Output])
  (do phase.monad
    [_ (translation.execute! ..declaration)
     _ (translation.save! ..id {.#None} ..declaration)]
    (pure [(|> registry.empty
               (registry.resource .true unit.none)
               product.right)
           (sequence.sequence [..id {.#None}
                               (by utf8.binary as (_.code ..declaration))])])))
