... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except Module Name
                Bit
                Text text
                Decimal
                I64 i64
                Natural natural
                Integer integer
                Revolution revolution
                Label Tag Slot
                List list
                Macro macro Macro'

                Type
                #Nominal #Sum #Product #Function
                #Parameter #Variable #Opaque
                #Universal #Existential
                #Reification
                #Named

                Provenance
                Code
                #Bit #Natural #Integer #Revolution #Decimal #Text #Name #Form #Variant #Tuple

                Maybe
                Info
                #target #version #mode #configuration
                Definition Default Alias
                Global
                #Definition #Alias #Default
                Module
                #module_hash #module_aliases #definitions #imports #module_state
                Bindings
                #counter #mappings
                Scope
                #locals #captured
                Type_Context
                #ex_counter #var_counter #var_bindings
                Lux
                #info #source #provenance
                #current_module #modules #scopes
                #type_context #expected #seed
                #eval

                Meta)
   [control
    ["[0]" maybe (.use "[1]#[0]" functor)]]
   [data
    ["[0]" product]
    [collection
     ["[0]" list (.use "[1]#[0]" functor)
      ["[0]" property (.use "[1]#[0]" functor)]]
     ["[0]" stack (.use "[1]#[0]" functor)]]]
   [meta
    ["[0]" name]]
   ["[0]" function]]])

(the prefix
  name.delimiter)

(every .public Identity
  (Record
   [#alias .Text
    #name .Text]))

(the expansion#let (.in_module# .prelude .expansion#let))
(the with_template (.in_module# .prelude .with_template))

(expansion#let [,each_simple (these [bit Bit]
                                    [decimal Decimal]
                                    [text Text]
                                    [tag Tag]
                                    [slot Slot]
                                    [macro Macro]
                                    [eval Eval])
                ,each_complex (these [i64 I64]
                                     [list List])
                ,each_integer (these [natural Natural]
                                     [integer Integer]
                                     [revolution Revolution])
                ,each (these ,each_simple
                             ,each_complex
                             ,each_integer)
                ,each_name (with_template [,name ,type]
                             [,name]
                             
                             ,each
                             )]
               (these (with_template [,name ,type]
                        [(the .public ,name
                           Identity
                           (let [proper (name.proper (.name ,name))]
                             [#alias proper
                              #name (.text ..prefix proper)]))]

                        ,each
                        )
                      (with_template [,name ,type]
                        [(the .public ,type
                           .Type
                           {.#Nominal (its #name ,name) (stack)})]

                        ,each_simple
                        )
                      (with_template [,name ,type]
                        [(the .public ,type
                           .Type
                           (for_any (_ it)
                             {.#Nominal (its #name ,name) (stack it)}))]

                        ,each_complex
                        )
                      (with_template [,name ,type]
                        [(the .public ,type
                           .Type
                           {.#Nominal (its #name ..i64)
                                      (stack {.#Nominal (its #name ,name) (stack)})})]

                        ,each_integer
                        )
                      (the .public each_name
                        (property.List .Text)
                        (.list ,each_name))
                      ))

(the .public Name_Of_Module
  ..Text)

(the .public Name
  (And ..Name_Of_Module ..Text))

(the template#macro (.in_module# .prelude .template#macro))

(the List'
  (<| (template#macro (_ ,it))
      [{.#Nominal (its #name ..list) (stack ,it)}]))

... https://en.wikipedia.org/wiki/Quantifier_(logic)
(the Quantification
  (<| (template#macro (_ ,it))
      [[(.Stack ,it)
        ,it]]))

... https://ncatlab.org/nlab/show/polarity+in+type+theory
(the .public Polarity
  ..Bit)

(the contra_variant
  Polarity
  false)

(the co_variant
  Polarity
  true)

(every .public (Type _)
  (Variant
   {#Nominal ..Text (..List' [..Polarity (Type _)])}
   {#Sum (Type _) (Type _)}
   {#Product (Type _) (Type _)}
   {#Function (Type _) (Type _)}
   {#Parameter ..Natural}
   {#Variable ..Natural}
   {#Opaque ..Natural}
   {#Universal (Quantification (Type _))}
   {#Existential (Quantification (Type _))}
   {#Reification (Type _) (Type _)}
   {#Named ..Name (Type _)}))

(the .public (old it)
  (-> ..Type
      .Type)
  (`` (when it
        {#Nominal name parameters}
        {.#Nominal name (|> parameters
                            (list#each (function (_ [polarity it])
                                         (old it)))
                            list.as_stack)}
        
        (,, (with_template [,new ,old]
              [{,new left right}
               {,old (old left) (old right)}]

              [#Sum .#Sum]
              [#Product .#Product]
              [#Function .#Function]
              [#Reification .#Reification]
              ))

        (,, (with_template [,new ,old]
              [{,new it}
               {,old it}]

              [#Parameter .#Parameter]
              [#Variable .#Variable]
              [#Opaque .#Opaque]
              ))

        (,, (with_template [,new ,old]
              [{,new environment body}
               {,old (stack#each old environment) (old body)}]

              [#Universal .#Universal]
              [#Existential .#Existential]
              ))

        (,, (with_template [,new ,old]
              [{,new name body}
               {,old name (old body)}]

              [#Named .#Named]
              ))
        )))

(the .public (new it)
  (-> .Type
      ..Type)
  (`` (when it
        {.#Nominal name parameters}
        {#Nominal name (|> parameters
                           list.of_stack
                           (list#each (function (_ it)
                                        [..co_variant (new it)])))}
        
        (,, (with_template [,new ,old]
              [{,old left right}
               {,new (new left) (new right)}]

              [#Sum .#Sum]
              [#Product .#Product]
              [#Function .#Function]
              [#Reification .#Reification]
              ))

        (,, (with_template [,new ,old]
              [{,old it}
               {,new it}]

              [#Parameter .#Parameter]
              [#Variable .#Variable]
              [#Opaque .#Opaque]
              ))

        (,, (with_template [,new ,old]
              [{,old environment body}
               {,new (stack#each new environment) (new body)}]

              [#Universal .#Universal]
              [#Existential .#Existential]
              ))

        (,, (with_template [,new ,old]
              [{,old name body}
               {,new name (new body)}]

              [#Named .#Named]
              )))))

(the .public Character
  .Type
  ..Natural)

(the .public Provenance
  .Type
  (And ..Name_Of_Module ..Natural ..Natural))

(the Code'
  (<| (template#macro (_ ,it))
      [(And ..Provenance ,it)]))

(every .public (Code _)
  (let [Code (type (Code _))]
    (Or
     ... #Bit
     (Code' ..Bit)
     ... #Natural
     (Code' ..Natural)
     ... #Integer
     (Code' ..Integer)
     ... #Revolution
     (Code' ..Revolution)
     ... #Decimal
     (Code' ..Decimal)
     ... #Text
     (Code' ..Text)
     ... #Name
     (Code' ..Name)
     ... #Form
     (Code' (List' Code))
     ... #Variant
     (Code' (List' Code))
     ... #Tuple
     (Code' (List' Code)))))

(with_template [,right? ,lefts ,tag]
  [(the .public ,tag
     (<| (template#macro (_ ,where ,it))
         [{,lefts ,right? [,where ,it]}]))]
  
  [#0 0 #Bit]
  [#0 1 #Natural]
  [#0 2 #Integer]
  [#0 3 #Revolution]
  [#0 4 #Decimal]
  [#0 5 #Text]
  [#0 6 #Name]
  [#0 7 #Form]
  [#0 8 #Variant]
  [#1 8 #Tuple]
  )

(the Maybe
  (<| (template#macro (_ ,it))
      [(.Or .Any ,it)]))

(every .public Label
  [(..Maybe [..Natural ..Bit (.Stack ..Name)])
   ..Type])

(the Try
  (<| (template#macro (_ ,it))
      [(.Or ..Text ,it)]))

(the Property_List
  (<| (template#macro (_ ,it))
      [(..List' (And ..Text ,it))]))

(every .public Info
  (Record
   [#target ..Text
    #version ..Text
    #mode .Mode
    #configuration (..Property_List ..Text)]))

(the .public Definition
  (And ..Type .Any))

(the .public Default
  Definition)

(the .public Alias
  ..Name)

(every .public Global
  (Variant
   {#Definition Definition}
   {#Alias Alias}
   {#Default Default}))

(the (old_global it)
  (-> ..Global
      .Global)
  (when it
    {#Definition [type it]}
    {.#Definition [(..old type) it]}
    
    {#Default [type it]}
    {.#Default [(..old type) it]}
    
    {#Alias it}
    {.#Alias it}))

(the (new_global it)
  (-> .Global
      ..Global)
  (when it
    {.#Definition [type it]}
    {#Definition [(..new type) it]}
    
    {.#Default [type it]}
    {#Default [(..new type) it]}
    
    {.#Alias it}
    {#Alias it}))

(every .public Module
  (Record
   [#module_hash ..Natural
    #module_aliases (..Property_List ..Text)
    #definitions (..Property_List [..Bit ..Global])
    #imports (..List' ..Text)
    #module_state .Module_State]))

(the .public old_module
  (-> ..Module
      .Module)
  (revised #definitions (property#each (product.then function.identity ..old_global))))

(the .public new_module
  (-> .Module
      ..Module)
  (revised #definitions (property#each (product.then function.identity ..new_global))))

(every .public (Bindings it)
  (Record
   [#counter ..Natural
    #mappings (..Property_List it)]))

(every .public Scope
  (Record
   [#locals (..Bindings [..Type ..Natural])
    #captured (..Bindings [..Type .Ref])]))

(every .public Type_Context
  (Record
   [#ex_counter ..Natural
    #var_counter ..Natural
    #var_bindings (..List' [..Natural (..Maybe ..Type)])]))

(the .public old_type_context
  (-> ..Type_Context
      .Type_Context)
  (revised ..#var_bindings (list#each (product.then function.identity (maybe#each ..old)))))

(the .public new_type_context
  (-> .Type_Context
      ..Type_Context)
  (revised .#var_bindings (list#each (product.then function.identity (maybe#each ..new)))))

(every .public Lux
  (Record
   [#info ..Info
    #source .Source
    #provenance ..Provenance
    #current_module (Maybe ..Name_Of_Module)
    #modules (..Property_List ..Module)
    #scopes (.Stack ..Scope)
    #type_context ..Type_Context
    #expected (Maybe ..Type)
    #seed ..Natural
    #eval ..Eval]))

(the Meta
  (<| (template#macro (_ ,it))
      [(-> ..Lux
           (Try (.And ..Lux ,it)))]))

(the .public Eval'
  (-> ..Type ..Code
      (Meta Any)))

(the code#bit (.in_module# .prelude .code#bit))
(the code#natural (.in_module# .prelude .code#natural))
(the code#text (.in_module# .prelude .code#text))
(the code#tuple (.in_module# .prelude .code#tuple))
(the code#variant (.in_module# .prelude .code#variant))

(the empty
  ..Code
  (code#variant (.list (code#bit #0))))

(the (top head tail)
  (-> ..Code ..Code
      ..Code)
  (code#variant (.list (code#bit #1)
                       head
                       tail)))

(every (Injection it)
  (-> it
      ..Code))

(the (code#stack code it)
  (for_any (_ it)
    (-> (Injection it)
        (Injection (Stack it))))
  (when it
    {.#Empty}
    empty

    {.#Top head tail}
    (top (code head) (code#stack code tail))))

(the (code#argument code it)
  (for_any (_ it)
    (-> (Injection it)
        (Injection it)))
  (code#tuple (.list (code#bit ..co_variant)
                     (code it))))

(the (code#list code it)
  (for_any (_ it)
    (-> (Injection it)
        (Injection (Stack it))))
  (` (.list# (,* (list#each code (list.of_stack it))))))

(the (code it)
  (Injection .Type)
  (`` (when it
        {.#Nominal name parameters}
        (code#variant (.list (code#natural 0)
                             (code#bit #0)
                             (code#tuple (.list (code#text name)
                                                (code#list (code#argument code) parameters)))))

        (,, (with_template [,lefts ,tag]
              [{,tag left right}
               (code#variant (.list (code#natural ,lefts)
                                    (code#bit #0)
                                    (code#tuple (.list (code left)
                                                       (code right)))))]

              [1 .#Sum]
              [2 .#Product]
              [3 .#Function]
              [9 .#Reification]
              ))

        (,, (with_template [,lefts ,tag]
              [{,tag it}
               (code#variant (.list (code#natural ,lefts)
                                    (code#bit #0)
                                    (code#natural it)))]

              [4 .#Parameter]
              [5 .#Variable]
              [6 .#Opaque]
              ))

        (,, (with_template [,lefts ,tag]
              [{,tag closure body}
               (code#variant (.list (code#natural ,lefts)
                                    (code#bit #0)
                                    (code#tuple (.list (code#stack code closure)
                                                       (code body)))))]

              [7 .#Universal]
              [8 .#Existential]
              ))
        
        {.#Named [module proper] anonymous}
        (code#variant (.list (code#natural 9)
                             (code#bit #1)
                             (code#tuple (.list (code#tuple (.list (code#text module)
                                                                   (code#text proper)))
                                                (code anonymous)))))
        )))

(the .public each_type
  (property.List ..Code)
  (|> (.list ["label" ..Label]
             ["name_of_module" ..Name_Of_Module]
             ["name" ..Name]
             ["provenance" ..Provenance]
             ["code" ..Code]
             ["type" ..Type]
             ["info" ..Info]
             ["definition" ..Definition]
             ["default" ..Default]
             ["alias" ..Alias]
             ["global" ..Global]
             ["module" ..Module]
             ["bindings" ..Bindings]
             ["scope" ..Scope]
             ["type_context" ..Type_Context]
             ["lux" ..Lux]
             ["eval" ..Eval'])
      (is (property.List .Type))
      (list#each (function (_ [name type])
                   [name (..code type)]))))

(the .public Macro'
  .Type
  (type (-> (List' ..Code)
            (Meta (List' ..Code)))))
