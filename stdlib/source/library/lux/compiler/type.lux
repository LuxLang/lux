... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except Module Name Type
                Bit
                Text text
                Decimal
                I64 i64
                Natural natural
                Integer integer
                Revolution revolution
                Tag Slot
                List list
                Macro macro Macro'

                Provenance
                Code
                #Bit #Natural #Integer #Revolution #Decimal #Text #Name #Form #Variant #Tuple

                Maybe
                Info
                #target #version #mode #configuration
                Module
                #module_hash #module_aliases #definitions #imports #module_state
                Type_Context
                #ex_counter #var_counter #var_bindings
                Lux
                #info #source #provenance
                #current_module #modules #scopes
                #type_context #expected #seed
                #eval

                Meta)
   [data
    [collection
     ["[0]" list (.use "[1]#[0]" functor)
      ["[0]" property]]]]
   [meta
    ["[0]" name]]]])

(the prefix
  name.delimiter)

(every .public Identity
  (Record
   [#alias .Text
    #name .Text]))

(the expansion#let (.in_module# .prelude .expansion#let))
(the with_template (.in_module# .prelude .with_template))

(expansion#let [,each_simple (these [bit Bit]
                                    [decimal Decimal]
                                    [text Text]
                                    [tag Tag]
                                    [slot Slot]
                                    [macro Macro]
                                    [eval Eval])
                ,each_complex (these [i64 I64]
                                     [list List])
                ,each_integer (these [natural Natural]
                                     [integer Integer]
                                     [revolution Revolution])
                ,each (these ,each_simple
                             ,each_complex
                             ,each_integer)
                ,each_name (with_template [,name ,type]
                             [,name]
                             
                             ,each
                             )]
               (these (with_template [,name ,type]
                        [(the .public ,name
                           Identity
                           (let [proper (name.proper (.name ,name))]
                             [#alias proper
                              #name (.text ..prefix proper)]))]

                        ,each
                        )
                      (with_template [,name ,type]
                        [(the .public ,type
                           .Type
                           {.#Nominal (its #name ,name) (stack)})]

                        ,each_simple
                        )
                      (with_template [,name ,type]
                        [(the .public ,type
                           .Type
                           (for_any (_ it)
                             {.#Nominal (its #name ,name) (stack it)}))]

                        ,each_complex
                        )
                      (with_template [,name ,type]
                        [(the .public ,type
                           .Type
                           {.#Nominal (its #name ..i64)
                                      (stack {.#Nominal (its #name ,name) (stack)})})]

                        ,each_integer
                        )
                      (the .public each_name
                        (property.List .Text)
                        (.list ,each_name))
                      ))

(the .public Name_Of_Module
  ..Text)

(the .public Name
  (And ..Name_Of_Module ..Text))

(the template#macro (.in_module# .prelude .template#macro))

... https://en.wikipedia.org/wiki/Quantifier_(logic)
(the Quantification
  (<| (template#macro (_ ,it))
      [[(.Stack ,it)
        ,it]]))

(every .public (Type _)
  (let [Type (type (Type _))]
    (Or
     ... #Nominal
     (And ..Text (type (.Stack Type)))
     ... #Sum
     (And Type Type)
     ... #Product
     (And Type Type)
     ... #Function
     (And Type Type)
     ... #Parameter
     ..Natural
     ... #Variable
     ..Natural
     ... #Opaque
     ..Natural
     ... #Universal
     (Quantification Type)
     ... #Existential
     (Quantification Type)
     ... #Reification
     (And Type Type)
     ... #Named
     (And ..Name Type))))

(the .public Character
  ..Type
  ..Natural)

(the .public Provenance
  ..Type
  (And ..Name_Of_Module ..Natural ..Natural))

(the List'
  (<| (template#macro (_ ,it))
      [{.#Nominal (its #name ..list) (stack ,it)}]))

(the Code'
  (<| (template#macro (_ ,it))
      [(And ..Provenance ,it)]))

(every .public (Code _)
  (let [Code (type (Code _))]
    (Or
     ... #Bit
     (Code' ..Bit)
     ... #Natural
     (Code' ..Natural)
     ... #Integer
     (Code' ..Integer)
     ... #Revolution
     (Code' ..Revolution)
     ... #Decimal
     (Code' ..Decimal)
     ... #Text
     (Code' ..Text)
     ... #Name
     (Code' ..Name)
     ... #Form
     (Code' (List' Code))
     ... #Variant
     (Code' (List' Code))
     ... #Tuple
     (Code' (List' Code)))))

(with_template [,right? ,lefts ,tag]
  [(the .public ,tag
     (<| (template#macro (_ ,where ,it))
         [{,lefts ,right? [,where ,it]}]))]
  
  [#0 0 #Bit]
  [#0 1 #Natural]
  [#0 2 #Integer]
  [#0 3 #Revolution]
  [#0 4 #Decimal]
  [#0 5 #Text]
  [#0 6 #Name]
  [#0 7 #Form]
  [#0 8 #Variant]
  [#1 8 #Tuple]
  )

(the Maybe
  (<| (template#macro (_ ,it))
      [(.Or .Any ,it)]))

(the Try
  (<| (template#macro (_ ,it))
      [(.Or ..Text ,it)]))

(the Property_List
  (<| (template#macro (_ ,it))
      [(..List' (And ..Text ,it))]))

(every .public Info
  (Record
   [#target ..Text
    #version ..Text
    #mode .Mode
    #configuration (..Property_List ..Text)]))

(every .public Module
  (Record
   [#module_hash ..Natural
    #module_aliases (..Property_List ..Text)
    #definitions (..Property_List [..Bit .Global])
    #imports (..List' ..Text)
    #module_state .Module_State]))

(every .public Type_Context
  (Record
   [#ex_counter ..Natural
    #var_counter ..Natural
    #var_bindings (..List' [..Natural (..Maybe ..Type)])]))

(every .public Lux
  (Record
   [#info ..Info
    #source .Source
    #provenance ..Provenance
    #current_module (Maybe ..Name_Of_Module)
    #modules (..Property_List ..Module)
    #scopes (.Stack .Scope)
    #type_context ..Type_Context
    #expected (Maybe ..Type)
    #seed ..Natural
    #eval ..Eval]))

(the Meta
  (<| (template#macro (_ ,it))
      [(-> ..Lux
           (Try (.And ..Lux ,it)))]))

(the .public Eval'
  (-> ..Type ..Code
      (Meta Any)))

(the code#bit (.in_module# .prelude .code#bit))
(the code#natural (.in_module# .prelude .code#natural))
(the code#text (.in_module# .prelude .code#text))
(the code#tuple (.in_module# .prelude .code#tuple))
(the code#variant (.in_module# .prelude .code#variant))

(the empty
  ..Code
  (code#variant (.list (code#bit #0))))

(the (top head tail)
  (-> ..Code ..Code
      ..Code)
  (code#variant (.list (code#bit #1)
                       head
                       tail)))

(every (Injection it)
  (-> it
      ..Code))

(the (code#stack code it)
  (for_any (_ it)
    (-> (Injection it)
        (Injection (Stack it))))
  (when it
    {.#Empty}
    empty

    {.#Top head tail}
    (top (code head) (code#stack code tail))))

(the (code it)
  (Injection ..Type)
  (`` (when it
        {.#Nominal name parameters}
        (code#variant (.list (code#natural 0)
                             (code#bit #0)
                             (code#tuple (.list (code#text name)
                                                (code#stack code parameters)))))

        (,, (with_template [,lefts ,tag]
              [{,tag left right}
               (code#variant (.list (code#natural ,lefts)
                                    (code#bit #0)
                                    (code#tuple (.list (code left)
                                                       (code right)))))]

              [1 .#Sum]
              [2 .#Product]
              [3 .#Function]
              [9 .#Reification]
              ))

        (,, (with_template [,lefts ,tag]
              [{,tag it}
               (code#variant (.list (code#natural ,lefts)
                                    (code#bit #0)
                                    (code#natural it)))]

              [4 .#Parameter]
              [5 .#Variable]
              [6 .#Opaque]
              ))

        (,, (with_template [,lefts ,tag]
              [{,tag closure body}
               (code#variant (.list (code#natural ,lefts)
                                    (code#bit #0)
                                    (code#tuple (.list (code#stack code closure)
                                                       (code body)))))]

              [7 .#Universal]
              [8 .#Existential]
              ))
        
        {.#Named [module proper] anonymous}
        (code#variant (.list (code#natural 9)
                             (code#bit #1)
                             (code#tuple (.list (code#tuple (.list (code#text module)
                                                                   (code#text proper)))
                                                (code anonymous)))))
        )))

(the .public each_type
  (property.List ..Code)
  (|> (.list ["name_of_module" ..Name_Of_Module]
             ["name" ..Name]
             ["provenance" ..Provenance]
             ["code" ..Code]
             ["type" ..Type]
             ["info" ..Info]
             ["type_context" ..Type_Context]
             ["module" ..Module]
             ["lux" ..Lux]
             ["eval" ..Eval'])
      (is (property.List ..Type))
      (list#each (function (_ [name type])
                   [name (..code type)]))))

(the .public Macro'
  ..Type
  (type (-> (List' ..Code)
            (Meta (List' ..Code)))))
