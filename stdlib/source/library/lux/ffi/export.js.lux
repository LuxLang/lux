(.require
 [library
  [lux (.except)
   [extension (.only declaration)]
   ["[0]" meta]
   ["[0]" static]
   [abstract
    ["[0]" monad (.only do)]]
   [control
    ["<>" parser]]
   [data
    [text
     ["%" \\format]]
    [collection
     ["[0]" list (.use "[1]#[0]" monad mix)]
     ["[0]" set]]]
   ["[0]" macro (.only)
    [syntax (.only syntax)]
    ["[0]" code (.only)
     ["<[1]>" \\parser]]]
   [math
    ["[0]" random]]
   [target
    ["/" js]]
   [tool
    [compiler
     ["[0]" phase]
     [meta
      [cache
       ["[0]" dependency
        ["[1]" artifact]]]]
     [language
      [lux
       ["[0]" generation]
       ["[0]" declaration]
       [analysis
        ["[0]" type]]]]]]]])

(def definition
  (-> Code (Meta [Text Code]))
  (|>> (list)
       (<code>.result (<| <code>.form
                          (<>.after (<code>.this_text "lux def"))
                          (<>.before <code>.any)
                          (all <>.and
                               <code>.local
                               <code>.any)))
       meta.lifted))

(with_expansions [<extension> (static.random (|>> %.nat (%.format "lua export ") code.text)
                                             random.nat)]
  (declaration (<extension> self phase archive [name <code>.text
                                                term <code>.any])
               (do [! phase.monad]
                 [next declaration.analysis
                  [_ term] (<| declaration.lifted_analysis
                               type.inferring
                               (next archive term))

                  next declaration.synthesis
                  term (declaration.lifted_synthesis
                        (next archive term))

                  dependencies (declaration.lifted_generation
                                (dependency.dependencies archive term))

                  next declaration.generation
                  [interim_artifacts term] (declaration.lifted_generation
                                            (generation.with_interim_artifacts archive
                                              (next archive term)))

                  _ (declaration.lifted_generation
                     (do !
                       [@self (generation.learn_custom name (list#mix set.has dependencies interim_artifacts))
                        .let [$module (/.var "module")
                              $exports (/.the "exports" $module)
                              definition (/.define (/.var name) term)
                              export (/.when (/.not (/.= (/.string "undefined") (/.type_of $module)))
                                             (/.set (/.the name $exports) (/.var name)))
                              code (all /.then
                                        definition
                                        export)]
                        _ (generation.execute! definition)
                        _ (generation.save! @self {.#None} code)]
                       (generation.log! (%.format "Export " (%.text name)))))]
                 (in declaration.no_requirements)))

  (def .public export
    (syntax (_ [exports (<>.many <code>.any)])
      (let [! meta.monad]
        (|> exports
            (monad.each ! macro.expansion)
            (at ! each (|>> list#conjoint
                            (monad.each ! ..definition)))
            (at ! conjoint)
            (at ! each (list#each (function (_ [name term])
                                    (` (<extension> (~ (code.text name)) (~ term)))))))))))
