... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except Definition Module Declaration
                #Definition #module
                comment alias)
   ["[0]" debug]
   [abstract
    [monad (.only do)]
    ["[0]" enum]]
   [control
    ["<>" projection (.use "[1]#[0]" monad)]
    ["[0]" maybe]
    ["[0]" try]
    ["[0]" exception (.only Exception)]]
   [data
    ["[0]" bit]
    ["[0]" sum]
    ["[0]" product]
    ["[0]" text (.only \n) (.use "[1]#[0]" order)
     ["%" \\injection]]
    [collection
     ["[0]" list (.use "[1]#[0]" monad mix monoid)]
     ["[0]" set (.only Set)]
     ["[0]" stream (.only Stream)]
     ["[0]" dictionary (.only Dictionary)]]
    [format
     ["md" markdown (.only Markdown Block)]]]
   [math
    [number
     ["n" natural]]]
   ["[0]" meta (.only)
    ["[0]" binding]
    ["[0]" symbol]
    ["[0]" label]
    ["[0]" type]
    [module
     ["[0]" import]]
    ["[0]" code (.only)
     ["<[1]>" \\projection (.only Projection)]]
    ["[0]" macro (.only)
     ["[0]" syntax]
     ["[0]" template]
     ["[0]" expansion]]
    [compiler
     [language
      ["[0]" lux
       ["[1]/[0]" syntax]]]
     [meta
      [archive
       [module
        ["[0]" descriptor]]]]]]]])

(the |recursion_dummy|
  (template.macro (_)
    [{.#Nominal "" {.#End}}]))

(.every Fragment
  (Variant
   {#Comment Text}
   {#Code Code}))

(the fragment
  (Projection Fragment)
  (<>.or <code>.text
         <code>.any))

(the (reference_column code)
  (-> Code
      Natural)
  (`` (when code
        (,, (template.with [<tag>]
              [[[_ _ column] {<tag> _}]
               column]

              [.#Bit]
              [.#Natural]
              [.#Integer]
              [.#Revolution]
              [.#Decimal]
              [.#Text]
              [.#Symbol]))

        (,, (template.with [<tag>]
              [[[_ _ column] {<tag> members}]
               (|> members
                   (list#each reference_column)
                   (list#mix n.minor column))]

              [.#Form]
              [.#Variant]
              [.#Tuple]))
        )))

(the (padding reference_column [_ old_line old_column] [_ new_line new_column])
  (-> Natural Location Location
      Text)
  (if (n.= old_line new_line)
    (if (n.< old_column new_column)
      ""
      (text.together (list.repeated (n.- old_column new_column) " ")))
    (%.message (if (n.< old_line new_line)
                 ""
                 (text.together (list.repeated (n.- old_line new_line) \n)))
               (if (n.< reference_column new_column)
                 ""
                 (text.together (list.repeated (n.- reference_column new_column) " "))))))

(the (code_documentation expected_module old_location reference_column example)
  (-> Text Location Natural Code
      [Location Text])
  (`` (when example
        [new_location {.#Symbol [module short]}]
        (let [documentation (if (text.= expected_module module)
                              short

                              (text.= .prelude module)
                              (%.message "." short)
                              
                              ... else
                              (symbol.as_text [module short]))]
          [(revised .#column (n.+ (text.size documentation)) new_location)
           (%.message (padding reference_column old_location new_location)
                      documentation)])
        
        (,, (template.with [<tag> <injection>]
              [[new_location {<tag> value}]
               (let [documentation (`` (|> value (,, (template.spliced <injection>))))]
                 [(revised .#column (n.+ (text.size documentation)) new_location)
                  (%.message (padding reference_column old_location new_location)
                             documentation)])]

              [.#Bit [bit.as_text]]
              [.#Natural [%.natural]]
              [.#Integer [%.integer]]
              [.#Revolution [%.revolution]]
              [.#Decimal [%.decimal]]
              [.#Text [%.text]]))

        (,, (template.with [|<| |>| <tag>]
              [[group_location {<tag> members}]
               (let [[group_location' members_documentation] (list#mix (function (_ part [last_location text_accum])
                                                                         (let [[member_location member_documentation] (code_documentation expected_module last_location reference_column part)]
                                                                           [member_location (%.message text_accum member_documentation)]))
                                                                       [(revised .#column ++ group_location) ""]
                                                                       members)]
                 [(revised .#column ++ group_location')
                  (%.message (padding reference_column old_location group_location)
                             |<| members_documentation |>|)])]

              [lux/syntax.open_form    lux/syntax.close_form    .#Form]
              [lux/syntax.open_variant lux/syntax.close_variant .#Variant]
              [lux/syntax.open_tuple   lux/syntax.close_tuple   .#Tuple]))
        )))

(the .public (comment it module)
  (-> Text
      (-> Text
          (Markdown Block)))
  (<| (md.code "clojure")
      (%.message "... " it)))

(the .public (example it module)
  (-> Code
      (-> Text
          (Markdown Block)))
  (<| (md.code "clojure")
      (let [reference_column (..reference_column it)
            [location _] it]
        (|> it
            (..code_documentation module (has .#column reference_column location) reference_column)
            product.right))))

(the .public (deprecated when module)
  (-> Text
      (-> Text
          (Markdown Block)))
  (md.paragraph (md.text (%.message "Deprecated: " when))))

(the parameter_type_name
  (-> Natural
      Text)
  (|>> %.natural (%.message "_")))

(the type_variable_names
  (Stream Text)
  (stream.iterations (product.forked ++ parameter_type_name)
                     0))

(template.with [<name> <partition>]
  [(the (<name> id)
     (-> Natural
         Bit)
     (<partition> id))]

  [type_function? n.even?]
  [type_parameter? n.odd?]
  )

(the (parameter_id level id)
  (-> Natural Natural
      Natural)
  (n.- (n./ 2 id) level))

(the (parameter_name [type_function_name type_function_arguments] level id)
  (-> [Text (List Text)] Natural Natural
      Text)
  (if (type_parameter? id)
    (let [parameter_id (..parameter_id level id)]
      (when (list.item parameter_id type_function_arguments)
        {try.#Success found}
        found

        _
        (let [parameter_id (n.- (list.size type_function_arguments) parameter_id)]
          (|> type_variable_names
              (stream.only (function (_ var_name)
                             (not (list.member? text.equivalence type_function_arguments var_name))))
              (stream.item parameter_id)))))      
    type_function_name))

(the (level_parameters offset level)
  (-> Natural Natural
      (List Text))
  (if (n.= 0 level)
    (list)
    (|> level
        --
        (enum.range n.enum 0)
        (list#each (|>> (n.+ (++ offset)) parameter_type_name)))))

(the (nested line_prefix body)
  (-> Text Text
      Text)
  (|> body
      (text.all_split_by \n)
      (list#each (text.prefix line_prefix))
      (text.interposed \n)))

(the (link [module short])
  (-> Symbol
      Text)
  (%.message "#" module ":" short))

(the (type_link module it)
  (-> Text Symbol
      Text)
  (let [[_module _name] it
        label (if (text.= module _module)
                _name

                (text.= .prelude _module)
                (%.message "." _name)

                ... else
                (symbol.as_text it))]
    (%.message "<a href=" (..link it) ">" label "</a>")))

(the (%type' level type_function_name nestable? module type)
  (-> Natural Text Bit Text Type
      Text)
  (`` (when type
        {.#Nominal name params}
        (|> params
            (list#each (|>> (%type' level type_function_name false module)
                            (%.message " ")))
            {.#Item (%.text name)}
            text.together
            (text.enclosed ["(Nominal " ")"]))

        {.#Sum _}
        (|> type
            type.flat_variant
            (list#each (%type' level type_function_name false module))
            (text.interposed " ")
            (text.enclosed ["(Or " ")"]))

        {.#Product _}
        (|> type
            type.flat_tuple
            (list#each (%type' level type_function_name false module))
            (text.interposed " ")
            (text.enclosed ["[" "]"]))

        {.#Function input output}
        (let [[ins out] (type.flat_function type)]
          (%.message  "(-> "
                      (|> ins (list#each (%type' level type_function_name false module)) (text.interposed " "))
                      " "
                      (%type' level type_function_name false module out)
                      ")"))

        {.#Parameter idx}
        (parameter_name [type_function_name (list)] level idx)

        (,, (template.with [<tag>]
              [{<tag> id}
               (type.as_text type)]

              [.#Variable]
              [.#Opaque]))

        (,, (template.with [<tag> <name> <flat>]
              [{<tag> _}
               (let [[level' body] (<flat> type)
                     args (level_parameters level level')
                     body_doc (%type' (n.+ level level') type_function_name nestable? module body)]
                 (%.message "(" <name> " " "(_ " (|> args (text.interposed " ")) ")"
                            (if nestable?
                              (%.message \n (nested "  " body_doc))
                              (%.message " " body_doc))
                            ")"))]

              [.#Universal "All" type.flat_univ_q]
              [.#Existential "Ex" type.flat_ex_q]))

        {.#Reification (|recursion_dummy|) {.#Parameter 0}}
        type_function_name

        {.#Reification (|recursion_dummy|) {.#Universal _ body}}
        (%.message "(Rec " type_function_name
                   \n (nested " " (%type' level type_function_name nestable? module body))
                   ")")

        {.#Reification param fun}
        (let [[type_func type_arguments] (type.flat_application type)]
          (%.message  "(" (%type' level type_function_name false module type_func)
                      " " (|> type_arguments
                              (list#each (%type' level type_function_name false module))
                              (text.interposed " "))
                      ")"))

        {.#Named it type}
        (type_link module it)
        )))

(the type_documentation
  (-> Text Type
      Text)
  (%type' (-- 0) "?" true))

(the (parameterized_type arity type)
  (-> Natural Type
      (Maybe Type))
  (when arity
    0 {.#Some type}
    _ (when type
        {.#Universal _env _type}
        (parameterized_type (-- arity) _type)

        _
        {.#None})))

(the (type_definition' nestable? level arity type_function_info tags module type)
  (-> Bit Natural Natural [Text (List Text)] (List Text) Text Type
      Text)
  (`` (when tags
        (list single_tag)
        (%.message "(Record" \n
                   " [#" single_tag " " (type_definition' false level arity type_function_info {.#None} module type) "])")

        _
        (when type
          {.#Nominal name params}
          (when params
            {.#End}
            (%.message "(Nominal " (%.text name) ")")

            _
            (%.message "(Nominal " (%.text name) " " (|> params (list#each (type_definition' false level arity type_function_info {.#None} module)) (text.interposed " ")) ")"))

          {.#Sum _}
          (let [members (type.flat_variant type)]
            (when tags
              {.#End}
              (%.message "(Or "
                         (|> members
                             (list#each (type_definition' false level arity type_function_info {.#None} module))
                             (text.interposed " "))
                         ")")

              _
              (|> members
                  (list.zipped_2 tags)
                  (list#each (function (_ [t_name type])
                               (when type
                                 {.#Product _}
                                 (let [types (type.flat_tuple type)]
                                   (%.message " {" t_name " "
                                              (|> types
                                                  (list#each (type_definition' false level arity type_function_info {.#None} module))
                                                  (text.interposed " "))
                                              "}"))

                                 _
                                 (%.message " {" t_name " " (type_definition' false level arity type_function_info {.#None} module type) "}"))))
                  (text.interposed \n)
                  (text.enclosed [(%.message "(Variant" \n) ")"]))))

          {.#Product _}
          (let [members (type.flat_tuple type)]
            (when tags
              {.#End}
              (%.message "[" (|> members (list#each (type_definition' false level arity type_function_info {.#None} module)) (text.interposed " ")) "]")

              _
              (|> members
                  (list.zipped_2 tags)
                  (list#each (function (_ [t_name type])
                               (%.message t_name " " (type_definition' false level arity type_function_info {.#None} module type))))
                  (text.interposed (%.message \n "  "))
                  (text.enclosed [" [" "]"])
                  (text.enclosed [(%.message "(Record" \n) ")"]))))

          {.#Function input output}
          (let [[ins out] (type.flat_function type)]
            (%.message  "(-> " (|> ins (list#each (type_definition' false level arity type_function_info {.#None} module)) (text.interposed " "))
                        " "
                        (type_definition' false level arity type_function_info {.#None} module out)
                        ")"))

          {.#Parameter idx}
          (parameter_name type_function_info level idx)

          (,, (template.with [<pre> <tag>]
                [{<tag> id}
                 (%.message <pre> (%.natural id))]

                ["-" .#Variable]
                ["+" .#Opaque]))

          (,, (template.with [<tag> <name> <flat>]
                [{<tag> _}
                 (let [[level' body] (<flat> type)
                       args (level_parameters (n.- arity level) level')
                       body_doc (type_definition' nestable? (n.+ level level') arity type_function_info tags module body)
                       fn_name (when type_function_info
                                 [fn_name {.#End}] fn_name
                                 _ "_")]
                   (%.message "(" <name> " " "(" fn_name " " (text.interposed " " args) ")"
                              (if nestable?
                                (%.message \n (..nested "  " body_doc))
                                (%.message " " body_doc))
                              ")"))]

                [.#Universal "All" type.flat_univ_q]
                [.#Existential "Ex" type.flat_ex_q]))

          ... Recursive call
          {.#Reification (|recursion_dummy|) {.#Parameter 0}}
          (product.left type_function_info)

          {.#Reification (|recursion_dummy|) {.#Universal _ body}}
          (|> (type_definition' nestable? level arity type_function_info tags module body)
              (text.all_split_by \n)
              (list#each (text.prefix " "))
              (text.interposed \n)
              (text.enclosed [(%.message "(Rec " (product.left type_function_info) \n)
                              ")"]))

          {.#Reification param fun}
          (let [[type_func type_arguments] (type.flat_application type)]
            (%.message  "(" (type_definition' false level arity type_function_info tags module type_func)
                        " " (|> type_arguments
                                (list#each (type_definition' false level arity type_function_info {.#None} module))
                                (text.interposed " "))
                        ")"))

          {.#Named it type}
          (type_link module it)
          ))))

(the (type_definition module [name parameters] tags type)
  (-> Text [Text (List Text)] (List Text) Type
      Text)
  (let [arity (list.size parameters)]
    (when (parameterized_type arity type)
      {.#Some type}
      (type_definition' true (-- arity) arity [name parameters] tags module type)

      {.#None}
      (type_documentation module type))))

(the description
  (Projection (Maybe Code))
  (<>.or (<code>.this_text "")
         <code>.any))

(exception.the .public (unqualified_symbol name)
  (Exception Symbol)
  (exception.report
   (list ["Name" (symbol.as_text name)])))

(the qualified_symbol
  (Projection Symbol)
  (do <>.monad
    [name <code>.symbol]
    (when name
      ["" _]
      (<>.failure (exception.error ..unqualified_symbol [name]))
      
      _
      (in name))))

(.every Declaration
  [Symbol (List Text)])

(the declaration
  (Projection Declaration)
  (<>.either (<>.and ..qualified_symbol (<>#in (list)))
             (<code>.form (<>.and ..qualified_symbol
                                  (<>.some (<code>.local))))))

(the minimal_definition_documentation
  (syntax.macro (_ [[name parameters] ..declaration])
    (do meta.monad
      [.let [g!module (code.text (product.left name))]
       [def_type def_value] (binding.export name)
       tags (meta.try
             (meta.either (label.tags name)
                          (label.slots name)))]
      (macro.with_symbols [g!type]
        (in (list (` (all md.then
                          ... Name
                          (<| md.heading/4
                              (md.and (md.anchor (, (let [[module short] name]
                                                      (code.text (%.message module ":" short))))))
                              md.text
                              (, (code.text (code.as_text (let [g!name (|> name product.right code.local)]
                                                            (when parameters
                                                              {.#End}
                                                              g!name

                                                              _
                                                              (` ((, g!name) (,* (list#each code.local parameters))))))))))
                          ... Type
                          (let [(, g!type) (.in_module#
                                            (, g!module)
                                            (.type_of (, (code.symbol name))))]
                            (, (if (type.= .Type def_type)
                                 (` (|> (, (code.symbol name))
                                        (as .Type)
                                        type.anonymous
                                        ((debug.private ..type_definition)
                                         (, g!module)
                                         [(, (code.text (product.right name))) (list (,* (list#each code.text parameters)))]
                                         (.list (,* (|> tags
                                                        (try.else (list))
                                                        (list#each (|>> symbol.short code.text))))))
                                        (%.message "... " ((debug.private ..type_documentation) (, g!module) (, g!type)) text.\n)
                                        md.raw_code))
                                 (` (md.raw_code ((debug.private ..type_documentation) (, g!module) (, g!type))))))))
                     )))))))

(the alias_documentation
  (syntax.macro (_ [name ..qualified_symbol])
    (do meta.monad
      [original (binding.alias name)]
      (in (list (` (all md.then
                        ... Name
                        (md.heading/4 (md.and (md.anchor (, (let [[module short] name]
                                                              (code.text (%.message module ":" short)))))
                                              (md.text (, (code.text (code.as_text (|> name product.right code.local)))))))
                        (md.paragraph
                         (all md.and
                              (md.text (, (code.text "Alias for")))
                              (md.link (md.text (, (code.text (symbol.as_text original))))
                                       (, (code.text (..link original)))))))
                   ))))))

(the definition_documentation
  (syntax.macro (_ [[name parameters] ..declaration
                    description ..description
                    examples (<>.some <code>.any)])
    (do meta.monad
      [.let [module (product.left name)]
       minimal (expansion.single (` (..minimal_definition_documentation
                                     ((, (code.symbol name))
                                      (,* (list#each code.local parameters))))))]
      (in (list (` (all md.then
                        (,* minimal)
                        ... Description
                        (,* (when description
                              {.#Some description}
                              (list (` (<| md.paragraph
                                           md.text
                                           (, description))))
                              
                              {.#None}
                              (list)))
                        ... Examples
                        (,* (when examples
                              {.#End}
                              (list)
                              
                              _
                              (list (` (all md.then
                                            (,* (list#each (function (_ example)
                                                             (` ((, example) (, (code.text module)))))
                                                           examples))
                                            ))))))
                   ))))))

(.every .public Definition
  (Record
   [#global Symbol
    #documentation (Markdown Block)]))

(.every .public Module
  (Record
   [#module Text
    #description Text
    ... https://en.wiktionary.org/wiki/dependee
    #dependees (Set descriptor.Module)
    #coverage (Set Text)]))

(.every .public Documentation
  (Variant
   {#Definition Definition}
   {#Module Module}))

(the .public definition
  (syntax.macro (_ [[name parameters] ..declaration
                    extra (<>.some <code>.any)])
    (do meta.monad
      [documentation (expansion.single (` ((, (when extra
                                                (list)
                                                (` ..minimal_definition_documentation)

                                                _
                                                (` ..definition_documentation)))
                                           ((, (code.symbol name))
                                            (,* (list#each code.local parameters)))
                                           (,* extra))))]
      (macro.with_symbols [g!_]
        (let [[module short] name]
          (in (list (` (.let [(, g!_) (.is (.-> .Any
                                                ..Documentation)
                                           (.function ((, g!_) (, g!_))
                                             {#Definition [..#global [(, (code.text module)) (, (code.text short))]
                                                           ..#documentation (,* documentation)]}))]
                         ((, g!_) []))))))))))

(the .public alias
  (syntax.macro (_ [name ..qualified_symbol])
    (do meta.monad
      [documentation (expansion.single (` (..alias_documentation (, (code.symbol name)))))]
      (macro.with_symbols [g!_]
        (let [[module short] name]
          (in (list (` (.let [(, g!_) (.is (.-> .Any
                                                ..Documentation)
                                           (.function ((, g!_) (, g!_))
                                             {#Definition [..#global [(, (code.text module)) (, (code.text short))]
                                                           ..#documentation (,* documentation)]}))]
                         ((, g!_) []))))))))))

(the (definition#< left right)
  (-> Definition Definition
      Bit)
  (text#< (symbol.short (its #global right))
          (symbol.short (its #global left))))

(the definitions_documentation
  (-> (List Definition)
      (Markdown Block))
  (|>> (list.sorted ..definition#<)
       (list#each (its #documentation))
       (list#mix md.then md.empty)))

... https://en.wikipedia.org/wiki/Delimiter
(the coverage_delimiter
  Text
  (text.of_character 31))

(the coverage_injection
  (-> (List Text)
      Text)
  (list#mix (function (_ short aggregate)
              (when aggregate
                "" short
                _ (%.message aggregate ..coverage_delimiter short)))
            ""))

(the (exported_non_default? [name [exported? global]])
  (-> [Text [Bit Global]]
      Bit)
  (when global
    {.#Default _}
    false

    _
    exported?))

(`` (the .public module
      (syntax.macro (_ [[name _] ..qualified_symbol
                        description <code>.any])
        (do [! meta.monad]
          [coverage (|> (binding.globals name)
                        (by ! each (|>> (list.only exported_non_default?)
                                        (list#each product.left))))
           dependees (import.all name)]
          (in (list (` (is Documentation
                           {#Module [..#module (, (code.text name))
                                     ..#description (, description)
                                     ..#dependees (|> (list (,* (list#each code.text dependees)))
                                                      (set.of_list text.hash))
                                     ..#coverage (|> (, (code.text (..coverage_injection coverage)))
                                                     (text.all_split_by (,, (static ..coverage_delimiter)))
                                                     (set.of_list text.hash))]}))))))))

(the listing
  (-> (List Text)
      (Markdown Block))
  (|>> (list.sorted text#<)
       (list#each (function (_ definition)
                    [(md.snippet definition)
                     {.#None}]))
       md.numbered_list))

(the (dependencies heading it)
  (-> descriptor.Module (Set descriptor.Module)
      (Markdown Block))
  (if (set.empty? it)
    md.empty
    (all md.then
         (md.heading/3 (md.text heading))
         (|> (set.list it)
             (list.only (|>> (text.= descriptor.runtime) not))
             (list.sorted text#<)
             (list#each (function (_ it)
                          [(md.link (md.text it) (%.message "#" it))
                           {.#None}]))
             md.bullet_list)
         )))

(the (module_documentation dependers [module definitions])
  (-> (Dictionary descriptor.Module (Set descriptor.Module))
      [Module (List Definition)]
      (Markdown Block))
  (let [(open "_[0]") module]
    (all md.then
         ... Name
         (md.heading/2 (md.and (md.anchor (its #module module))
                               (md.text (its #module module))))
         
         ... Description
         (when (its #description module)
           "" md.empty
           description (<| md.paragraph
                           md.text
                           description))

         (dependencies "Dependees" (its #dependees module))
         (dependencies "Dependers" (|> (dictionary.value (its #module module) dependers)
                                       (try.else (set.empty text.hash))))
         
         (md.heading/3 (md.text "Definitions"))
         (|> definitions
             (list.only (|>> (its #global)
                             symbol.short
                             (set.member? _#coverage)))
             ..definitions_documentation)

         ... Missing documentation
         (when (|> definitions
                   (list#mix (function (_ definition missing)
                               (set.lacks (symbol.short (its #global definition)) missing))
                             _#coverage)
                   set.list)
           {.#End}
           md.empty

           missing
           (all md.then
                (md.heading/3 (md.text "Missing documentation"))
                (..listing missing)))
         
         ... Un-expected documentation
         (when (|> definitions
                   (list.only (|>> (its #global)
                                   symbol.short
                                   (set.member? _#coverage)
                                   not))
                   (list#each (|>> (its #global)
                                   symbol.short)))
           {.#End}
           md.empty
           
           un_expected
           (all md.then
                (md.heading/3 (md.text "Un-expected documentation"))
                (..listing un_expected)))
         )))

... https://en.wiktionary.org/wiki/depender
(the dependers
  (-> (List [descriptor.Module Module])
      (Dictionary descriptor.Module (Set descriptor.Module)))
  (list#mix (function (_ [name module] it)
              (list#mix (function (_ import it)
                          (dictionary.revised' import (set.empty text.hash) (set.has name) it))
                        it
                        (set.list (its #dependees module))))
            (dictionary.empty text.hash)))

(the index
  (-> (List [Module (List Definition)])
      (Markdown Block))
  (|>> (list#each (function (_ [module defs])
                    (all md.then
                         (md.heading/5 (let [it (its #module module)]
                                         (md.link (md.text it) (%.message "#" it))))
                         (|> defs
                             (list.sorted ..definition#<)
                             (list#each (function (_ it)
                                          (let [[module short] (its #global it)]
                                            [(md.link (md.text short) (..link (its #global it)))
                                             {.#None}])))
                             md.bullet_list)
                         )))
       (list#mix (function (_ right left)
                   (md.then left right))
                 (md.heading/1 (md.text "Index")))))

(the .public (markdown it)
  (-> (List Documentation)
      Text)
  (let [with_modules (list#mix (function (_ doc it)
                                 (if (dictionary.key? it (its #module doc))
                                   it
                                   (dictionary.has (its #module doc) [doc (list)] it)))
                               (is (Dictionary Text [Module (List Definition)])
                                   (dictionary.empty text.hash))
                               (sum.rights it))
        with_definitions (list#mix (function (_ doc it)
                                     (let [module (symbol.module (its #global doc))]
                                       (if (dictionary.key? it module)
                                         (dictionary.revised module
                                                             (function (_ [module defs])
                                                               [module (list.partial doc defs)])
                                                             it)
                                         it)))
                                   with_modules
                                   (sum.lefts it))
        dependers (|> with_modules
                      dictionary.entries
                      (list#each (function (_ [name [module definitons]])
                                   [name module]))
                      ..dependers)
        it (|> with_definitions
               dictionary.values
               (list.sorted (function (_ left right)
                              (text#< (its #module (product.left right))
                                      (its #module (product.left left))))))]
    (md.markdown
     (all md.then
          (index it)
          (md.heading/1 (md.text "Documentation"))
          (|> it
              (list#each (..module_documentation dependers))
              (list.interposed md.horizontal_rule)
              (list#mix md.then (is (Markdown Block) md.empty)))
          ))))
