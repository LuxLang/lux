... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except Pattern let if)
   [abstract
    ["?" projection]
    ["[0]" monad]]
   [data
    ["[0]" product]
    [collection
     ["[0]" list (.use "[1]:[0]" monad monoid)
      ["?[1]" \\projection]]]]
   ["[0]" meta (.only)
    ["[0]" extension]
    ["[0]" name]
    ["[0]" provenance]
    ["[0]" code (.only)
     ["?[1]" \\projection (.only Projection)]]]
   [compiler
    ["@[0]" type (.only Simple Complex Pattern)]
    [language
     [lux
      ["[0]" phase]
      ["[0]" analysis (.only)
       ["[1]/[0]" type]
       ["[0]" scope]]]]
    [meta
     [archive (.only Archive)]]]
   ["[0]" type]
   [macro
    ["[0]" template]
    ["[0]" syntax]]
   [math
    [number
     [/64
      ["n" natural]]]]]])

... https://en.wikipedia.org/wiki/Identity_(mathematics)
(every .public Identity
  [analysis.Term analysis.Term])

(.the .public in_reverse
  (Change Identity)
  product.in_reverse)

(the (code_of_name it)
  (code.Injection Name)
  (code.tuple (.list (code.text (name.module it))
                     (code.text (name.proper it)))))

(the (code_of_provenance it)
  (code.Injection Provenance)
  (` [(, (code.text (its .:module it)))
      (, (code.natural (its .:line it)))
      (, (code.natural (its .:column it)))]))

(the (code_of_simple it)
  (code.Injection Simple)
  (`` (when it
        {@type.:Simple_Unit}
        (` {@type.:Simple_Unit})

        (,, (template.with [,tag ,code]
              [{,tag it}
               (` {,tag (, (,code it))})]

              [[@type.:Simple_Bit code.bit]
               [@type.:Simple_Natural code.natural]
               [@type.:Simple_Integer code.integer]
               [@type.:Simple_Revolution code.revolution]
               [@type.:Simple_Decimal code.decimal]
               [@type.:Simple_Text code.text]])))))

(the (code_of_complex code it)
  (for_any (_ it)
    (-> (code.Injection it)
        (code.Injection (Complex it))))
  (when it
    {@type.:Complex_Variant it}
    (` {@type.:Complex_Variant [@type.:lefts (, (code.natural (its @type.:lefts it)))
                                @type.:right? (, (code.bit (its @type.:right? it)))
                                @type.:choice (, (code (its @type.:choice it)))]})
    
    {@type.:Complex_Tuple it}
    (` {@type.:Complex_Tuple (.list (,* (list:each code it)))})))

(the (code_of_pattern it)
  (code.Injection Pattern)
  (when it
    {@type.:Simple_Pattern it}
    (` {@type.:Simple_Pattern (, (code_of_simple it))})
    
    {@type.:Complex_Pattern it}
    (` {@type.:Complex_Pattern (, (code_of_complex code_of_pattern it))})
    
    {@type.:List_Pattern it}
    (` {@type.:List_Pattern (.list (,* (list:each code_of_pattern it)))})
    
    {@type.:Bind_Pattern it}
    (` {@type.:Bind_Pattern (, (code.natural it))})))

(the (code_of_branch code_of_analysis it)
  (-> (code.Injection analysis.Term)
      (code.Injection analysis.Branch))
  (` [@type.:when (, (code_of_pattern (its @type.:when it)))
      @type.:then (, (code_of_analysis (its @type.:then it)))]))

(the (code_of_match code_of_analysis [head tail])
  (-> (code.Injection analysis.Term)
      (code.Injection analysis.Match))
  (` [(, (code_of_branch code_of_analysis head))
      (.list (,* (list:each (code_of_branch code_of_analysis) tail)))]))

(the .public (code_of_analysis it)
  (code.Injection analysis.Term)
  (when it
    {@type.:Simple @ it}
    (` {@type.:Simple (, (code_of_provenance @))
                      (, (code_of_simple it))})
    
    {@type.:Complex @ it}
    (` {@type.:Complex (, (code_of_provenance @))
                       (, (code_of_complex code_of_analysis it))})
    
    {@type.:Reference @ it}
    (` {@type.:Reference (, (code_of_provenance @))
                         (, (when it
                              {@type.:Variable_Reference it}
                              (` {@type.:Variable_Reference (, (when it
                                                                 {@type.:Local it}
                                                                 (` {@type.:Local (, (code.natural it))})
                                                                 
                                                                 {@type.:Foreign it}
                                                                 (` {@type.:Foreign (, (code.natural it))})))})
                              
                              {@type.:Constant_Reference it}
                              (` {@type.:Constant_Reference (, (code_of_name it))})))})
    
    {@type.:When @ input output}
    (` {@type.:When (, (code_of_provenance @))
                    (, (code_of_analysis input))
                    (, (code_of_match code_of_analysis output))})
    
    {@type.:Abstraction @ environment body}
    (` {@type.:Abstraction (, (code_of_provenance @))
                           (.list (,* (list:each code_of_analysis environment)))
                           (, (code_of_analysis body))})
    
    {@type.:Application @ parameter abstraction}
    (` {@type.:Application (, (code_of_provenance @))
                           (, (code_of_analysis parameter))
                           (, (code_of_analysis abstraction))})
    
    {@type.:Extension @ name parameters}
    (` {@type.:Extension (, (code_of_provenance @))
                         (, (code_of_name name))
                         (.list (,* (list:each code_of_analysis parameters)))})))

(every Variable
  [Text Code])

(the each_variable
  (Projection (List Variable))
  (?code.tuple (?.some (?.and ?code.local ?list.any))))

(every Body
  Code)

(the body
  (Projection Body)
  ?list.any)

(every Simple_Let
  [(List Variable)
   Body])

(the simple_let
  (Projection Simple_Let)
  (?.and each_variable
         body))

(the each_type_variable
  (Projection (List Text))
  (?code.tuple (?.some ?code.local)))

(every Type_Variable
  Text)

(every Complex_Let
  [(List Type_Variable)
   Simple_Let])

(the complex_let
  (Projection Complex_Let)
  (?.and each_type_variable
         simple_let))

(every Any_Let
  (Variant
   {:Complex Complex_Let}
   {:Simple Simple_Let}))

(the any_let
  (Projection Any_Let)
  (all ?.or
       complex_let
       simple_let))

(every .public Context
  (Record [:each_type (List [Text Code])
           :each_local (List [Text Code])]))

(every .public (Proposition it)
  (-> Context
      (-> analysis.Phase Archive
          (analysis.Operation it))))

(the (let' to_add it
           context)
  (for_any (_ it)
    (-> Context
        (Change (Proposition it))))
  (it [:each_type (list:composite (its :each_type context) (its :each_type to_add))
       :each_local (list:composite (its :each_local context) (its :each_local to_add))]))

(the (every_parameter it)
  (-> (List [Text Code])
      Code)
  (` (.list (,* (list:each (function (_ [name type])
                             (` [(, (code.text name))
                                 ((,' .') (, type))]))
                           it)))))

(syntax.the .public (let [it any_let])
  (when it
    {:Complex [each_type each_local body]}
    (monad.let [! meta.monad]
      [each_type (list.each' ! (function (_ name)
                                 (monad.let !
                                   [type analysis/type.existential]
                                   (pure [name (type.code type)])))
                             each_type)
       .let ['each_type (|> each_type
                            (list:each (function (_ [name type])
                                         (list (code.local name) type)))
                            list:conjoint)
             each_local (list:each (function (_ [name type])
                                     [name (` (.let [(,* 'each_type)]
                                                (.type (, type))))])
                                   each_local)]]
      (pure (list (` (..let' [..:each_type (, (every_parameter each_type))
                              ..:each_local (, (every_parameter each_local))]
                             (, body))))))
    
    {:Simple [each_local body]}
    (monad.let [! meta.monad]
      [.let [each_local (list:each (function (_ [name type])
                                     [name (` (.type (, type)))])
                                   each_local)]]
      (pure (list (` (..let' [..:each_type (.list)
                              ..:each_local (, (every_parameter each_local))]
                             (, body))))))))

(the current_module
  (name.module (name .._)))

(`` (template.the .public (variable ,@ ,identity)
      [{@type.:Extension ,@ [(,, (static ..current_module)) "variable"]
                         (.list (analysis.natural ,@ ,identity))}]))

(`` (template.the .public (term ,@ ,identity)
      [{@type.:Extension ,@ [(,, (static ..current_module)) "term"]
                         (.list (analysis.natural ,@ ,identity))}]))

(the (analysis it)
  (Change analysis.Term)
  (when it
    {@type.:Simple @ _}
    it
    
    {@type.:Complex @ it}
    {@type.:Complex @ (when it
                        {@type.:Complex_Variant it}
                        {@type.:Complex_Variant (revised @type.:choice analysis it)}
                        
                        {@type.:Complex_Tuple it}
                        {@type.:Complex_Tuple (list:each analysis it)})}
    
    {@type.:Reference @ it'}
    (when it'
      {@type.:Variable_Reference it'}
      (when it'
        {@type.:Local local}
        (variable provenance.dummy local)
        
        {@type.:Foreign _}
        it)
      
      {@type.:Constant_Reference _}
      it)
    
    {@type.:When @ input [head tail]}
    {@type.:When @ (analysis input) [(revised @type.:then analysis head)
                                     (list:each (revised @type.:then analysis) tail)]}
    
    {@type.:Abstraction @ environment body}
    {@type.:Abstraction @ (list:each analysis environment) body}
    
    {@type.:Application @ parameter abstraction}
    {@type.:Application @ (analysis parameter) (analysis abstraction)}
    
    {@type.:Extension @ name parameters}
    {@type.:Extension @ name (list:each analysis parameters)}))

(the simple_=
  (Projection [Code Code])
  (?.and ?list.any
         ?list.any))

(the complex_=
  (Projection [Code Code Code])
  (?.and ?list.any
         simple_=))

(the any_=
  (Projection (Or [Code Code Code]
                  [Code Code]))
  (?.or complex_=
        simple_=))

(the (clean_term nesting it)
  (-> Natural
      (Change analysis.Term))
  (.if (n.= 0 nesting)
       it
       (when it
         {@type.:When @ input [[_ it] (list)]}
         (clean_term (-- nesting) it)

         else
         (undefined))))

(the (='' type left right
          [each_type each_local]
          analysis archive)
  (-> Type Code Code
      (Proposition Identity))
  (.let [nesting (list.size each_local)
         each_local (|> each_local
                        (list:each (function (_ [name type])
                                     (list (code.local name)
                                           (` (.as (.-> .Any (, type)) [])))))
                        list:conjoint)]
    (monad.let [! phase.monad]
      [left (analysis/type.with type
              (analysis archive (` (.let [(,* each_local)]
                                     (, left)))))
       right (analysis/type.with type
               (analysis archive (` (.let [(,* each_local)]
                                      (, right)))))]
      (pure [(..analysis (clean_term nesting left))
             (..analysis (clean_term nesting right))]))))

(the (=' it
         [each_type each_local]
         analysis archive)
  (-> (Or [Code Code Code]
          [Code Code])
      (Proposition Identity))
  (when it
    {.:Left [type left right]}
    (monad.let [! phase.monad]
      [type (meta.eval Type (` (.let [(,* (|> each_type
                                              (list:each (function (_ [name type])
                                                           (list (code.local name) type)))
                                              list:conjoint))]
                                 (.type (, type)))))]
      (='' (as (-> Any Type) type) left right
           [each_type each_local]
           analysis archive))
    
    {.:Right [left right]}
    (='' Any left right
         [each_type each_local]
         analysis archive)))

(syntax.the .public (= [it any_=])
  (pure (list (when it
                {.:Left [type left right]}
                (` (..=' {.:Left [((,' .') (, type))
                                  ((,' .') (, left))
                                  ((,' .') (, right))]}))
                
                {.:Right [left right]}
                (` (..=' {.:Right [((,' .') (, left))
                                   ((,' .') (, right))]}))))))

... https://en.wikipedia.org/wiki/Logical_consequence
(every .public Entailment
  (Record [:every_premise (List Identity)
           :conclusion Identity]))

(the .public (if every_premise conclusion
                 context analysis archive)
  (-> (List (Proposition Identity)) (Proposition Identity)
      (Proposition Entailment))
  (monad.let [! phase.monad]
    [every_premise (list.each' ! (function (_ premise)
                                   (premise context analysis archive))
                               every_premise)
     conclusion (conclusion context analysis archive)]
    (pure [:every_premise every_premise
           :conclusion conclusion])))
