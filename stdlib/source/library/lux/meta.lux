... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except try or and)
   [abstract
    [functor (.only Functor)]
    [apply (.only Apply)]
    ["[0]" monad (.only Monad
                        do)]]
   [control
    ["[0]" maybe]
    ["[0]" try (.only Try)]]
   [data
    ["[0]" product]
    ["[0]" text (.use "[1]#[0]" monoid order)]
    [collection
     ["[0]" list (.use "[1]#[0]" monoid monad mix)
      ["[0]" property]]]]
   [math
    [number
     ["n" nat]
     ["i" int]]]]]
 [/
  ["[0]" location]
  ["[0]" symbol (.use "[1]#[0]" absolute equivalence)]
  ["[0]" code]])

(the with_template' (.in_module# .prelude .with_template))

... (.every (Meta of)
...   (-> Lux
...       (Try [Lux of])))

(the .public functor
  (Functor Meta)
  (implementation
   (the (each f fa)
     (function (_ lux)
       (when (fa lux)
         {try.#Success [lux' a]}
         {try.#Success [lux' (f a)]}

         {try.#Failure msg}
         {try.#Failure msg})))))

(the .public apply
  (Apply Meta)
  (implementation
   (the functor ..functor)

   (the (on fa ff)
     (function (_ lux)
       (when (ff lux)
         {try.#Success [lux' f]}
         (when (fa lux')
           {try.#Success [lux'' a]}
           {try.#Success [lux'' (f a)]}

           {try.#Failure msg}
           {try.#Failure msg})

         {try.#Failure msg}
         {try.#Failure msg})))))

(the .public monad
  (Monad Meta)
  (implementation
   (the functor ..functor)

   (the (in x)
     (function (_ lux)
       {try.#Success [lux x]}))
   
   (the (conjoint mma)
     (function (_ lux)
       (when (mma lux)
         {try.#Success [lux' ma]}
         (ma lux')

         {try.#Failure msg}
         {try.#Failure msg})))))

(the .public (value' lux action)
  (for_any (_ of)
    (-> Lux (Meta of)
        (Try [Lux of])))
  (action lux))

(the .public (value lux action)
  (for_any (_ of)
    (-> Lux (Meta of)
        (Try of)))
  (when (action lux)
    {try.#Success [_ output]}
    {try.#Success output}

    {try.#Failure error}
    {try.#Failure error}))

(the .public (or left right)
  (for_any (_ left right)
    (-> (Meta left) (Meta right)
        (Meta (Or left right))))
  (function (_ lux)
    (when (left lux)
      {try.#Success [lux it]}
      {try.#Success [lux {.#Left it}]}

      {try.#Failure error}
      (when (right lux)
        {try.#Success [lux it]}
        {try.#Success [lux {.#Right it}]}

        {try.#Failure error}
        {try.#Failure error}))))

(the .public (either left right)
  (for_any (_ of)
    (-> (Meta of) (Meta of)
        (Meta of)))
  (function (_ lux)
    (when (left lux)
      {try.#Failure error}
      (right lux)
      
      success
      success)))

(the .public (and left right)
  (for_any (_ left right)
    (-> (Meta left) (Meta right)
        (Meta (And left right))))
  (function (_ lux)
    (do try.monad
      [[lux left] (left lux)
       [lux right] (right lux)]
      (in [lux [left right]]))))

(the .public (assertion message test)
  (-> Text Bit
      (Meta Any))
  (function (_ lux)
    (if test
      {try.#Success [lux []]}
      {try.#Failure message})))

(the .public (failure error)
  (for_any (_ of)
    (-> Text
        (Meta of)))
  (function (_ lux)
    {try.#Failure (location.with (its .#location lux) error)}))

(the .public (module name)
  (-> Text
      (Meta Module))
  (function (_ lux)
    (when (property.value name (its .#modules lux))
      {try.#Success module}
      {try.#Success [lux module]}

      failure
      {try.#Failure (all text#composite "Unknown module: " name)})))

(the .public no_current_module
  Error
  (location.with (location.here)
    "No current module."))

(the .public current_module_name
  (Meta Text)
  (function (_ lux)
    (when (its .#current_module lux)
      {.#Some current_module}
      {try.#Success [lux current_module]}

      _
      {try.#Failure ..no_current_module})))

(the .public current_module
  (Meta Module)
  (let [(open "/#[0]") ..monad]
    (|> ..current_module_name
        (/#each ..module)
        /#conjoint)))

(the .public seed
  (Meta Nat)
  (function (_ lux)
    {try.#Success [(revised .#seed ++ lux)
                   (its .#seed lux)]}))

(the .public (module_exists? module)
  (-> Text
      (Meta Bit))
  (function (_ lux)
    {try.#Success [lux (when (property.value module (its .#modules lux))
                         {try.#Success _}
                         true
                         
                         failure
                         false)]}))

(with_template' [<name> <slot> <type>]
  [(the .public <name>
     (Meta <type>)
     (function (_ lux)
       {try.#Success [lux (its <slot> lux)]}))]

  [compiler_state [] Lux]
  
  [type_context .#type_context Type_Context]
  
  [target [.#info .#target] Text]
  [version [.#info .#version] Text]
  [configuration [.#info .#configuration] (List [Text Text])]
  )

(the .public modules
  (Meta (List [Text Module]))
  (function (_ lux)
    (|> lux
        (its .#modules)
        [lux]
        {try.#Success})))

(the type#=
  (.in_module# .prelude .type#=))

(the type#injection
  (.in_module# .prelude .type#injection))

(the .public location
  (Meta Location)
  (function (_ lux)
    {try.#Success [lux (its .#location lux)]}))

(the .public not_expecting_any_type
  Error
  (location.with (location.here)
    "Not expecting any type."))

(the .public expected_type
  (Meta Type)
  (function (_ lux)
    (when (its .#expected lux)
      {.#Some type}
      {try.#Success [lux type]}

      {.#None}
      {try.#Failure ..not_expecting_any_type})))

(the .public (tag_lists module)
  (-> Text
      (Meta (List [(List Symbol) Type])))
  (do ..monad
    [=module (..module module)
     this_module_name ..current_module_name]
    (in (property.values
         (list#mix (function (_ [short [exported? global]] output)
                     (when global
                       {.#Definition [type value]}
                       (if (.and (type#= Slot type)
                                 (.or exported?
                                      (text#= this_module_name module)))
                         (let [[label type] (as Label value)]
                           (when label
                             {.#Some [lefts right? family]}
                             (when family
                               (list.partial [_ short] _)
                               (property.has short [family type] output)

                               (list)
                               (property.has short [(list [module short]) type] output))
                             
                             {.#None}
                             (property.has short [(list [module short]) type] output)))
                         output)

                       _
                       output))
                   (is (property.List [(List Symbol) Type])
                       (list))
                   (its .#definitions =module))))))

(the .public (of_try it)
  (for_any (_ of)
    (-> (Try of)
        (Meta of)))
  (when it
    {try.#Success output}
    (of ..monad in output)

    {try.#Failure error}
    (..failure error)))

(the .public (eval type code)
  (-> Type Code
      (Meta Any))
  (do [! ..monad]
    [eval (of ! each (its .#eval)
              ..compiler_state)]
    (eval type code)))

(the .public (try computation)
  (for_any (_ of)
    (-> (Meta of)
        (Meta (Try of))))
  (function (_ lux)
    {try.#Success
     (when (computation lux)
       {try.#Success [lux' output]}
       [lux' {try.#Success output}]

       {try.#Failure error}
       [lux {try.#Failure error}])}))
