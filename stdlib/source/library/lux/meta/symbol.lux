(.using
 [library
  [lux (.except)
   [abstract
    [equivalence (.only Equivalence)]
    [hash (.only Hash)]
    [order (.only Order)]
    [codec (.only Codec)]]
   [data
    ["[0]" text (.open: "[1]#[0]" equivalence monoid)]
    ["[0]" product]]]])

... (type: Symbol
...   [Text Text])

(template [<name>]
  [(def: .public (<name> [module short])
     (-> Symbol Text)
     <name>)]

  [module]
  [short]
  )

(def: .public hash
  (Hash Symbol)
  (product.hash text.hash text.hash))

(def: .public equivalence
  (Equivalence Symbol)
  (at ..hash equivalence))

(implementation: .public order
  (Order Symbol)
  
  (def: equivalence ..equivalence)
  (def: (< [moduleP shortP] [moduleS shortS])
    (if (text#= moduleP moduleS)
      (at text.order < shortP shortS)
      (at text.order < moduleP moduleS))))

(def: .public separator
  ".")

(implementation: .public codec
  (Codec Text Symbol)
  
  (def: (encoded [module short])
    (case module
      "" short
      _ (all text#composite module ..separator short)))
  
  (def: (decoded input)
    (case (text.all_split_by ..separator input)
      (pattern (list short))
      {.#Right ["" short]}

      (pattern (list module short))
      {.#Right [module short]}

      _
      {.#Left (text#composite "Invalid format for Symbol: " input)})))
