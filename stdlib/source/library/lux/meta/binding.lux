... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except type alias old_macro macro)
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" maybe]]
   [error (.only error)
    ["[0]" try (.only Try)]]
   [data
    ["[0]" product]
    ["[0]" text (.only \n) (.use "[1]#[0]" order)]
    [collection
     ["[0]" stack (.use "[1]#[0]" functor)
      ["[0]" property]]
     ["[0]" list]]]
   [math
    [number
     ["n" natural]]]]]
 [/
  ["[0]" local]]
 ["[0]" // (.only)
  ["[0]" module]
  ["[0]" name (.use "[1]#[0]" absolute)]
  ["[0]" code]])

(the with_template' (.in_module# .prelude .with_template))

(the .public (normal name)
  (-> Name
      (Meta Name))
  (when name
    ["" name]
    (do //.monad
      [[module_name _] module.current]
      (in [module_name name]))

    _
    (by //.monad in name)))

(the (type_variable idx bindings)
  (-> Natural (Stack [Natural (Maybe Type)])
      (Maybe Type))
  (when bindings
    {.#Empty}
    {.#None}
    
    {.#Top [var bound] bindings'}
    (if (n.= idx var)
      bound
      (type_variable idx bindings'))))

(`` (the (clean_type type)
      (-> Type
          (Meta Type))
      (when type
        {.#Variable var}
        (function (_ lux)
          (when (|> lux
                    (its [.#type_context .#var_bindings])
                    (type_variable var))
            (,, (with_template' [<pattern>]
                  [<pattern>
                   {try.#Success [lux type]}]

                  [{.#None}]
                  [{.#Some {.#Variable _}}]))
            

            {.#Some type'}
            {try.#Success [lux type']}))

        _
        (by //.monad in type))))

(the without_lux_runtime
  (-> (Stack module.Name)
      (Stack module.Name))
  ... The Lux runtime shows up as ""
  ... so I'm excluding it.
  (stack.only (|>> (text.= module.runtime) not)))

... https://en.wikipedia.org/wiki/Delimiter
(the listing_delimiter
  Text
  (text \n "                    "))

(the module_listing
  (-> (Stack module.Name)
      Text)
  (|>> ..without_lux_runtime
       (stack.sorted text#<)
       list.of_stack
       (text.interposed ..listing_delimiter)))

(with_template' [<name> <yes>]
  [(the .public (<name> name)
     (-> Name
         (Meta [Bit Global]))
     (do //.monad
       [name (..normal name)
        .let [[normal_module normal_proper] name]]
       (function (_ lux)
         (when (is (Maybe [Bit Global])
                   (do maybe.monad
                     [(open "[0]") (|> lux
                                       (its .#modules)
                                       (property.value normal_module))]
                     (property.value normal_proper #definitions)))
           {.#Some exported?,definition}
           {try.#Success [lux exported?,definition]}

           _
           (let [current_module (|> lux (its .#current_module) (maybe.else "???"))
                 all_known_modules (|> lux
                                       (its .#modules)
                                       (stack#each product.left)
                                       ..module_listing)]
             {try.#Failure (text " All known modules: " all_known_modules \n
                                 (when (property.value current_module (its .#modules lux))
                                   {try.#Success this_module}
                                   (let [candidates (|> lux
                                                        (its .#modules)
                                                        (stack#each (function (_ [module_name module])
                                                                      (|> module
                                                                          (its .#definitions)
                                                                          (stack.all (function (_ [def_name [exported? global]])
                                                                                       (`` (when global
                                                                                             {<yes> _}
                                                                                             (if (.and exported?
                                                                                                       (text.= normal_proper def_name))
                                                                                               {.#Some (name#as [module_name def_name])}
                                                                                               {.#None})

                                                                                             _
                                                                                             {.#None})))))))
                                                        stack.together
                                                        (stack.sorted text#<)
                                                        list.of_stack
                                                        (text.interposed ..listing_delimiter))
                                         imports (|> this_module
                                                     (its .#imports)
                                                     ..module_listing)
                                         aliases (|> this_module
                                                     (its .#module_aliases)
                                                     (stack#each (function (_ [alias real]) (text alias " => " real)))
                                                     (stack.sorted text#<)
                                                     list.of_stack
                                                     (text.interposed ..listing_delimiter))]
                                     (text "           Aliases: " aliases \n
                                           "           Imports: " imports \n
                                           "        Candidates: " candidates \n))

                                   failure
                                   "")
                                 "    Current module: " current_module \n
                                 "Unknown definition: " (name#as name) \n
                                 )})))))]

  [definition .#Definition]
  [default' .#Default]
  [alias' .#Alias]
  )

(the .public (export name)
  (-> Name
      (Meta Definition))
  (do [! //.monad]
    [name (..normal name)
     .let [[expected _] name]
     [exported? definition] (..definition name)
     [actual _] module.current]
    (when definition
      {.#Definition it}
      (if (.or exported?
               (text.= expected actual))
        (in it)
        (//.failure (text "Definition is not an export: " (name#as name))))

      {.#Alias it}
      (if (.or exported?
               (text.= expected actual))
        (export it)
        (//.failure (text "Alias is not an export: " (name#as name))))

      {.#Default _}
      (//.failure (text "Defaults are not considered exports: "
                        (name#as name))))))

(the .public (default name)
  (-> Name
      (Meta Default))
  (do [! //.monad]
    [name (..normal name)
     [exported? definition] (..default' name)]
    (when definition
      {.#Definition _}
      (//.failure (text "Definitions are not considered defaults: "
                        (name#as name)))

      {.#Alias de_aliased}
      (//.failure (text "Aliases are not considered defaults: "
                        (name#as name)))

      {.#Default it}
      (if exported?
        (in it)
        (do !
          [.let [[expected _] name]
           [actual _] module.current]
          (if (text.= expected actual)
            (in it)
            (//.failure (text "Default is not an export: " (name#as name)))))))))

(the .public (alias name)
  (-> Name
      (Meta Name))
  (do [! //.monad]
    [name (..normal name)
     [exported? it] (..alias' name)]
    (when it
      {.#Alias it}
      (in it)

      _
      (undefined))))

(the .public (definition_type name)
  (-> Name
      (Meta Type))
  (do //.monad
    [[exported? definition] (definition name)]
    (when definition
      {.#Alias de_aliased}
      (definition_type de_aliased)
      
      {.#Definition [def_type def_value]}
      (clean_type def_type)

      {.#Default _}
      (//.failure (text "Defaults are not considered definitions: "
                        (name#as name))))))

(the .public (type name)
  (-> Name
      (Meta Type))
  (when name
    ["" _name]
    (//.either (local.type _name)
               (definition_type name))

    _
    (definition_type name)))

(the .public (type_definition name)
  (-> Name
      (Meta Type))
  (do //.monad
    [[exported? definition] (definition name)]
    (when definition
      {.#Alias de_aliased}
      (type_definition de_aliased)
      
      {.#Definition [def_type def_value]}
      (let [type_code (.in_module# .prelude .type_code)]
        (if (.or (same? .Type def_type)
                 (by code.equivalence =
                     (type_code .Type)
                     (type_code def_type)))
          (in (as Type def_value))
          (//.failure (text "Definition is not a type: " (name#as name)))))

      {.#Default _}
      (//.failure (text "Default is not a type: " (name#as name))))))

(the .public (globals module)
  (-> module.Name
      (Meta (Stack [Text [Bit Global]])))
  (function (_ lux)
    (when (property.value module (its .#modules lux))
      {try.#Success module}
      {try.#Success [lux (its .#definitions module)]}

      failure
      {try.#Failure (text "Unknown module: " module)})))

(the .public (definitions module)
  (-> module.Name
      (Meta (Stack [Text [Bit Definition]])))
  (by //.monad each
      (stack.all (function (_ [name [exported? global]])
                   (when global
                     {.#Alias de_aliased}
                     {.#None}
                     
                     {.#Definition definition}
                     {.#Some [name [exported? definition]]}

                     {.#Default _}
                     {.#None})))
      (..globals module)))

(the .public cannot_de-alias_a_default
  (error "Cannot de-alias a default global."))

(the .public (resolved_globals module)
  (-> module.Name
      (Meta (Stack [Text [Bit Definition]])))
  (do [! //.monad]
    [it (..globals module)
     .let [input (is (Stack [Text Bit (Either Name Definition)])
                     (stack.all (function (_ [name [exported? global]])
                                  (when global
                                    {.#Alias de_aliased}
                                    {.#Some [name exported? {.#Left de_aliased}]}
                                    
                                    {.#Definition definition}
                                    {.#Some [name exported? {.#Right definition}]}

                                    {.#Default _}
                                    {.#None}))
                                it))]]
    (function (_ lux)
      (loop (next [input input
                   output (is (Stack [Text [Bit Definition]])
                              (stack))])
        (when input
          (stack)
          {try.#Success [lux output]}

          (stack.partial [name exported? it] input)
          (let [real_definition (is (Try Definition)
                                    (loop (again [it it])
                                      (when it
                                        {.#Left de_aliased}
                                        (when (..definition de_aliased lux)
                                          {try.#Success [_ [_ definition]]}
                                          (when definition
                                            {.#Alias de_aliased}
                                            (again {.#Left de_aliased})
                                            
                                            {.#Definition definition}
                                            {try.#Success definition}

                                            {.#Default _}
                                            {try.#Failure ..cannot_de-alias_a_default})
                                          
                                          {try.#Failure error}
                                          {try.#Failure error})
                                        
                                        {.#Right definition}
                                        {try.#Success definition})))]
            (when real_definition
              {try.#Success it}
              (next input (stack.partial [name [exported? it]] output))
              
              {try.#Failure error}
              {try.#Failure error})))))))

(the .public (exports module_name)
  (-> module.Name
      (Meta (Stack [Text Definition])))
  (do //.monad
    [constants (..definitions module_name)]
    (in (do stack.monad
          [[name [exported? [def_type def_value]]] constants]
          (if exported?
            (in [name [def_type def_value]])
            (stack))))))

(the .public (de_aliased def_name)
  (-> Name
      (Meta Name))
  (do //.monad
    [[exported? constant] (..definition def_name)]
    (in (when constant
          {.#Alias real_def_name}
          real_def_name

          {.#Definition _}
          def_name

          {.#Default _}
          def_name))))

(the (old_macro_type? type)
  (-> Type
      Bit)
  (when type
    {.#Named [.prelude "Macro"]
             {.#Nominal "#Macro" {.#Empty}}}
    true

    _
    false))

(the .public not_a_macro
  (error "Not a macro."))

(the .public (old_macro full_name)
  (-> Name
      (Meta Old_Macro))
  (do //.monad
    [full_name (..normal full_name)]
    (is (Meta Old_Macro)
        (function (_ lux)
          (when (module.current lux)
            {try.#Success [_ [this_module _]]}
            (let [modules (its .#modules lux)]
              (loop (old_macro [[module name] full_name])
                (do try.monad
                  [$module (property.value module modules)
                   [exported? definition] (|> $module
                                              (is Module)
                                              (its .#definitions)
                                              (property.value name))]
                  (when definition
                    {.#Alias de_aliased}
                    (old_macro de_aliased)
                    
                    {.#Definition [def_type def_value]}
                    (if (old_macro_type? def_type)
                      {try.#Success [lux (as Old_Macro def_value)]}
                      {try.#Failure ..not_a_macro})

                    {.#Default _}
                    {try.#Failure ..not_a_macro}))))

            {try.#Failure error}
            {try.#Failure error})))))

(the (macro_type? type)
  (-> Type
      Bit)
  (when type
    {.#Named [.prelude "Macro"]
             {.#Nominal ".Macro" {.#Empty}}}
    true

    _
    false))

(the .public (macro full_name)
  (-> Name
      (Meta {.#Nominal ".Macro" {.#Empty}}))
  (do //.monad
    [full_name (..normal full_name)]
    (is (Meta {.#Nominal ".Macro" {.#Empty}})
        (function (_ lux)
          (when (module.current lux)
            {try.#Success [_ [this_module _]]}
            (let [modules (its .#modules lux)]
              (loop (macro [[module name] full_name])
                (do try.monad
                  [$module (property.value module modules)
                   [exported? definition] (|> $module
                                              (is Module)
                                              (its .#definitions)
                                              (property.value name))]
                  (when definition
                    {.#Alias de_aliased}
                    (macro de_aliased)
                    
                    {.#Definition [def_type def_value]}
                    (if (macro_type? def_type)
                      {try.#Success [lux (as {.#Nominal ".Macro" {.#Empty}} def_value)]}
                      {try.#Failure ..not_a_macro})

                    {.#Default _}
                    {try.#Failure ..not_a_macro}))))

            {try.#Failure error}
            {try.#Failure error})))))
