... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except try except with)
   [abstract
    [functor (.only Functor)]
    [apply (.only Apply)]
    ["[0]" monad (.only Monad do)]]
   [control
    ["[0]" maybe]
    ["[0]" try (.only Try)]
    ["[0]" exception (.only Exception)]
    [function
     ["[0]" mixin (.only Mixin)]]]
   [data
    ["[0]" product]
    ["[0]" text (.use "[1]#[0]" monoid)]
    [collection
     ["[0]" list (.use "[1]#[0]" mix)]
     ["[0]" set (.only Set)]]]
   [math
    [number
     ["n" natural (.use "[1]#[0]" base_10)]]]
   [meta
    [macro
     ["^" pattern]
     ["[0]" template]]]]]
 ["[0]" //])

(the !n#=
  (template.macro (_ super sub)
    [(.i64_=# super sub)]))

(the !text#=
  (template.macro (_ super sub)
    [(.text_=# super sub)]))

(every .public Variable
  Natural)

(template.with [<name>]
  [(exception.the .public (<name> [it])
     (Exception Variable)
     (exception.report
      (list ["Variable" (n#injection it)])))]

  [unknown_type_var]
  [unbound_type_var]
  )

(exception.the .public (invalid_type_application [funcT argT])
  (Exception [Type Type])
  (exception.report
   (list ["Type function" (//.absolute_injection funcT)]
         ["Type argument" (//.absolute_injection argT)])))

(exception.the .public (cannot_rebind_var [id type bound])
  (Exception [Variable Type Type])
  (exception.report
   (list ["Variable" (n#injection id)]
         ["Wanted type" (//.absolute_injection type)]
         ["Current type" (//.absolute_injection bound)])))

(exception.the .public (type_check_failed [super sub])
  (Exception [Type Type])
  (exception.report
   (list ["Super" (//.absolute_injection super)]
         ["Sub" (//.absolute_injection sub)])))

(every Assumption
  (Record
   [#super Type
    #sub Type]))

(every .public (Check of)
  (-> Type_Context
      (Try [Type_Context of])))

... https://en.wikipedia.org/wiki/Subsumption
(every (Subsumption of)
  (Mixin [(List Assumption) of of]
         (Check (List Assumption))))

(every (Checker of)
  (-> [(List Assumption) of of]
      (Check (List Assumption))))

(every Environment
  (List [Variable (Maybe Type)]))

(the .public functor
  (Functor Check)
  (implementation
   (the (each f fa)
     (function (_ context)
       (when (fa context)
         {try.#Success [context' output]}
         {try.#Success [context' (f output)]}

         {try.#Failure error}
         {try.#Failure error})))))

(the .public apply
  (Apply Check)
  (implementation
   (the functor ..functor)

   (the (on fa ff)
     (function (_ context)
       (when (ff context)
         {try.#Success [context' f]}
         (when (fa context')
           {try.#Success [context'' a]}
           {try.#Success [context'' (f a)]}

           {try.#Failure error}
           {try.#Failure error})

         {try.#Failure error}
         {try.#Failure error})))
   ))

(the .public monad
  (Monad Check)
  (implementation
   (the functor ..functor)

   (the (in x)
     (function (_ context)
       {try.#Success [context x]}))

   (the (conjoint ffa)
     (function (_ context)
       (when (ffa context)
         {try.#Success [context' fa]}
         (fa context')

         {try.#Failure error}
         {try.#Failure error})))))

(use "check#[0]" ..monad)

(the (var::new id it)
  (-> Variable Environment
      Environment)
  {.#Item [id {.#None}] it})

(the (var::get id it)
  (-> Variable Environment
      (Maybe (Maybe Type)))
  (when it
    {.#Item [var_id var_type]
            it'}
    (if (!n#= id var_id)
      {.#Some var_type}
      (var::get id it'))

    {.#End}
    {.#None}))

(the (var::put id value it)
  (-> Variable (Maybe Type) Environment
      Environment)
  (when it
    {.#End}
    (list [id value])

    {.#Item [var_id var_type]
            it'}
    (if (!n#= id var_id)
      {.#Item [var_id value]
              it'}
      {.#Item [var_id var_type]
              (var::put id value it')})))

(the .public (value context proc)
  (for_any (_ of)
    (-> Type_Context (Check of)
        (Try of)))
  (when (proc context)
    {try.#Success [context' output]}
    {try.#Success output}

    {try.#Failure error}
    {try.#Failure error}))

(the .public (failure message)
  (for_any (_ of)
    (-> Text
        (Check of)))
  (function (_ context)
    {try.#Failure message}))

(the .public (assertion message test)
  (-> Text Bit
      (Check Any))
  (function (_ context)
    (if test
      {try.#Success [context []]}
      {try.#Failure message})))

(the .public (except exception message)
  (for_any (_ ex of)
    (-> (Exception ex) ex
        (Check of)))
  (..failure (exception.error exception message)))

(the .public existential
  (Check [Natural Type])
  (function (_ context)
    (let [id (its .#ex_counter context)]
      {try.#Success [(revised .#ex_counter ++ context)
                     [id {.#Opaque id}]]})))

(template.with [<name> <outputT> <fail> <succeed>]
  [(the .public (<name> id)
     (-> Variable
         (Check <outputT>))
     (function (_ context)
       (when (|> context (its .#var_bindings) (var::get id))
         (^.or {.#Some {.#Some {.#Variable _}}}
               {.#Some {.#None}})
         {try.#Success [context <fail>]}
         
         {.#Some {.#Some bound}}
         {try.#Success [context <succeed>]}

         {.#None}
         (exception.except ..unknown_type_var id))))]

  [bound? Bit          false    true]
  [peek   (Maybe Type) {.#None} {.#Some bound}]
  )

(the .public (read id)
  (-> Variable
      (Check Type))
  (do ..monad
    [?type (peek id)]
    (when ?type
      {.#Some type}
      (in type)

      {.#None}
      (..except ..unbound_type_var id))))

(the (bound id)
  (-> Variable
      (Check Type))
  (function (_ context)
    (when (|> context (its .#var_bindings) (var::get id))
      {.#Some {.#Some bound}}
      {try.#Success [context bound]}

      {.#Some _}
      (exception.except ..unbound_type_var id)

      _
      (exception.except ..unknown_type_var id))))

(the .public (bind type id)
  (-> Type Variable
      (Check Any))
  (function (_ context)
    (when (|> context (its .#var_bindings) (var::get id))
      {.#Some {.#None}}
      {try.#Success [(revised .#var_bindings (var::put id {.#Some type}) context)
                     []]}

      {.#Some {.#Some bound}}
      (exception.except ..cannot_rebind_var [id type bound])
      
      _
      (exception.except ..unknown_type_var id))))

(the (re_bind' ?type id)
  (-> (Maybe Type) Variable
      (Check Any))
  (function (_ context)
    (when (|> context (its .#var_bindings) (var::get id))
      {.#Some _}
      {try.#Success [(revised .#var_bindings (var::put id ?type) context)
                     []]}
      
      _
      (exception.except ..unknown_type_var id))))

(the (re_bind type id)
  (-> Type Variable
      (Check Any))
  (re_bind' {.#Some type} id))

(the .public var
  (Check [Variable Type])
  (function (_ context)
    (let [id (its .#var_counter context)]
      {try.#Success [(|> context
                         (revised .#var_counter ++)
                         (revised .#var_bindings (var::new id)))
                     [id {.#Variable id}]]})))

(the (on argT funcT)
  (-> Type Type
      (Check Type))
  (when funcT
    {.#Variable func_id}
    (do ..monad
      [?funcT' (peek func_id)]
      (when ?funcT'
        {.#Some funcT'}
        (on argT funcT')

        _
        (except ..invalid_type_application [funcT argT])))

    {.#Apply argT' funcT'}
    (do ..monad
      [funcT'' (on argT' funcT')]
      (on argT funcT''))

    _
    (when (//.applied (list argT) funcT)
      {.#Some output}
      (check#in output)

      _
      (except ..invalid_type_application [funcT argT]))))

(the .public (ring' start)
  (-> Variable
      (Check (List Variable)))
  (function (_ context)
    (loop (again [current start
                  output (list start)])
      (when (|> context (its .#var_bindings) (var::get current))
        {.#Some {.#Some type}}
        (when type
          {.#Variable next}
          (if (!n#= start next)
            {try.#Success [context output]}
            (again next (list.partial next output)))
          
          _
          {try.#Success [context (list)]})

        {.#Some {.#None}}
        {try.#Success [context output]}
        
        {.#None}
        (exception.except ..unknown_type_var current)))))

... TODO: Optimize this by not using sets anymore.
(the ring
  (-> Variable
      (Check (Set Variable)))
  (|>> ..ring'
       (check#each (set.of_list n.hash))))

(the .public (linked? @0 @1)
  (-> Variable Variable
      (Check Bit))
  (check#each (function (_ it)
                (set.member? it @1))
              (..ring @0)))

(exception.the .public (cannot_identify var)
  (Exception Variable)
  (exception.report
   (list ["Variable" (n#injection var)])))

(the .public (identity aliases @)
  (-> (List Variable) Variable
      (Check Type))
  (do [! ..monad]
    [:bound: (..peek @)]
    (when :bound:
      {.#Some :bound:}
      (in :bound:)

      {.#None}
      (do !
        [existing_aliases (..ring @)]
        (if (n.< 2 (set.size existing_aliases))
          (..except ..cannot_identify [@])
          (do !
            [.let [forbidden_aliases (set.of_list n.hash (list.partial @ aliases))
                   allowed_aliases (set.difference forbidden_aliases existing_aliases)]]
            (when (set.list allowed_aliases)
              {.#Item identity _}
              (in {.#Variable identity})
              
              {.#None}
              (..except ..cannot_identify [@]))))))))

(the (erase! @)
  (-> Variable
      (Check Any))
  (function (_ context)
    {try.#Success [(revised .#var_bindings
                            (list#mix (is (//.let [binding [Natural (Maybe Type)]]
                                            (-> binding
                                                (List binding)
                                                (List binding)))
                                          (function (_ in out)
                                            (let [[@var :var:] in]
                                              (if (n.= @ @var)
                                                out
                                                (list.partial in out)))))
                                      (is (List [Natural (Maybe Type)])
                                          (list)))
                            context)
                   []]}))

(the .public (forget! @)
  (-> Variable
      (Check Any))
  (do [! ..monad]
    [ring (..ring' @)]
    (when ring
      (list)
      (in [])
      
      (list @me)
      (erase! @me)
      
      (list @other @me)
      (do !
        [_ (re_bind' {.#None} @other)]
        (erase! @me))
      
      (list.partial @prev _)
      (when (list.reversed ring)
        (list.partial @me @next _)
        (do !
          [_ (re_bind {.#Variable @next} @prev)
           _ (re_bind {.#Variable @prev} @next)]
          (erase! @me))

        _
        (undefined)))))

(the .public (try it)
  (for_any (_ of)
    (-> (Check of)
        (Check (Try of))))
  (function (_ context)
    (when (it context)
      {try.#Success [context' output]}
      {try.#Success [context' {try.#Success output}]}

      {try.#Failure error}
      {try.#Success [context {try.#Failure error}]})))

(the .public fresh_context
  Type_Context
  [.#var_counter 0
   .#ex_counter 0
   .#var_bindings (list)])

(the (either left right)
  (for_any (_ of)
    (-> (Check of) (Check of)
        (Check of)))
  (function (_ context)
    (when (left context)
      {try.#Failure _}
      (right context)

      output
      output)))

(the (assumed? [e a] assumptions)
  (-> Assumption (List Assumption)
      Bit)
  (list.any? (function (_ [e' a'])
               (and (//.= e e')
                    (//.= a a')))
             assumptions))

... TODO: "if_can_bind" can be optimized...
(the (if_can_bind id type then else)
  (for_any (_ of)
    (-> Variable Type (Check of) (-> Type (Check of))
        (Check of)))
  (all either
       (do ..monad
         [_ (..bind type id)]
         then)
       (do [! ..monad]
         [ring (..ring id)
          _ (..assertion "" (n.> 1 (set.size ring)))
          _ (monad.each ! (re_bind type) (set.list ring))]
         then)
       (do ..monad
         [?bound (peek id)]
         (else (maybe.else {.#Variable id} ?bound)))))

... TODO: "link/2" can be optimized...
(the (link/2 left right)
  (-> Variable Variable
      (Check Any))
  (do ..monad
    [_ (..bind {.#Variable right} left)]
    (..bind {.#Variable left} right)))

... TODO: "link/3" can be optimized...
(the (link/3 interpose to from)
  (-> Variable Variable Variable
      (Check Any))
  (do ..monad
    [_ (re_bind {.#Variable interpose} from)]
    (re_bind {.#Variable to} interpose)))

... TODO: "check_vars" can be optimized...
(the (check_vars complete [assumptions idE idA])
  (-> (Checker Type)
      (Checker Variable))
  (if (!n#= idE idA)
    (check#in assumptions)
    (do [! ..monad]
      [ebound (..try (..bound idE))
       abound (..try (..bound idA))]
      (when [ebound abound]
        ... Link the 2 variables circularly
        [{try.#Failure _} {try.#Failure _}]
        (do !
          [_ (link/2 idE idA)]
          (in assumptions))

        ... Interpose new variable between 2 existing links
        [{try.#Success etype} {try.#Failure _}]
        (when etype
          {.#Variable targetE}
          (do !
            [_ (link/3 idA targetE idE)]
            (in assumptions))

          _
          (complete [assumptions etype {.#Variable idA}]))

        ... Interpose new variable between 2 existing links
        [{try.#Failure _} {try.#Success atype}]
        (when atype
          {.#Variable targetA}
          (do !
            [_ (link/3 idE targetA idA)]
            (in assumptions))

          _
          (complete [assumptions {.#Variable idE} atype]))

        [{try.#Success etype} {try.#Success atype}]
        (`` (when [etype atype]
              [{.#Variable targetE} {.#Variable targetA}]
              (do !
                [ringE (..ring idE)
                 ringA (..ring idA)]
                (if (of set.equivalence = ringE ringA)
                  (in assumptions)
                  ... Fuse 2 rings
                  (do !
                    [_ (monad.mix ! (function (_ interpose to)
                                      (do !
                                        [_ (link/3 interpose to idE)]
                                        (in interpose)))
                                  targetE
                                  (set.list ringA))]
                    (in assumptions))))

              (,, (template.with [<pattern> <id> <type>]
                    [<pattern>
                     (do !
                       [ring (..ring <id>)
                        _ (monad.each ! (re_bind <type>) (set.list ring))]
                       (in assumptions))]

                    [[{.#Variable _} _] idE atype]
                    [[_ {.#Variable _}] idA etype]))
              
              _
              (complete [assumptions etype atype])))))))

(the silent_failure!
  Check
  (..failure ""))

... TODO: "check_apply" can be optimized...
(the (check_apply complete [assumptions super sub])
  (-> (Checker Type)
      (Checker [Type Type]))
  (let [[super_input super_function] super
        [sub_input sub_function] sub]
    (when [super_function sub_function]
      [{.#Opaque exE} {.#Opaque exA}]
      (if (!n#= exE exA)
        (complete [assumptions super_input sub_input])
        ..silent_failure!)

      [{.#Universal _ _} {.#Opaque _}]
      (do ..monad
        [super' (..on super_input super_function)]
        (complete [assumptions super' {.#Apply sub}]))

      [{.#Opaque _} {.#Universal _ _}]
      (do ..monad
        [sub' (..on sub_input sub_function)]
        (complete [assumptions {.#Apply super} sub']))

      [{.#Apply [super_input' super_function']} {.#Opaque _}]
      (do ..monad
        [super_function'' (..on super_input' super_function')]
        (complete [assumptions {.#Apply [super_input super_function'']} {.#Apply sub}]))

      [{.#Opaque _} {.#Apply [sub_input' sub_function']}]
      (do ..monad
        [sub_function'' (..on sub_input' sub_function')]
        (complete [assumptions {.#Apply super} {.#Apply [sub_input sub_function'']}]))

      (^.or [{.#Opaque _} _] [_ {.#Opaque _}])
      (do ..monad
        [assumptions (complete [assumptions super_function sub_function])]
        (complete [assumptions super_input sub_input]))

      [{.#Variable id} _]
      (function (_ context)
        (when ((do ..monad
                 [super_function' (..read id)]
                 (complete [assumptions {.#Apply super_input super_function'} {.#Apply sub}]))
               context)
          {try.#Success output}
          {try.#Success output}

          {try.#Failure _}
          (when sub_function
            {.#Universal _ _}
            ((do ..monad
               [sub' (..on sub_input sub_function)]
               (complete [assumptions {.#Apply super} sub']))
             context)
            
            {.#Opaque exA}
            ((do ..monad
               [assumptions (complete [assumptions super_function sub_function])]
               (complete [assumptions super_input sub_input]))
             context)

            _
            ((do ..monad
               [assumptions (complete [assumptions super_function sub_function])
                super' (..on super_input sub_function)
                sub' (..on sub_input sub_function)]
               (complete [assumptions super' sub']))
             context))))

      [_ {.#Variable id}]
      (function (_ context)
        (when ((do ..monad
                 [sub_function' (read id)]
                 (complete [assumptions {.#Apply super} {.#Apply sub_input sub_function'}]))
               context)
          {try.#Success output}
          {try.#Success output}

          _
          ((do ..monad
             [assumptions (complete [assumptions super_function sub_function])
              super' (..on super_input super_function)
              sub' (..on sub_input super_function)]
             (complete [assumptions super' sub']))
           context)))

      _
      ..silent_failure!)))

(the same
  (Subsumption Type)
  (function (_ partial complete it)
    (let [[assumptions super sub] it]
      (if (for .php
               ... TODO: Remove this once JPHP is gone.
               false
               (or (same? super sub)
                   (//.= super sub)))
        (check#in assumptions)
        (<<| (exception.with ..type_check_failed [super sub])
             (partial it))))))

(the composite
  (Subsumption Type)
  (function (_ partial complete it)
    (let [[assumptions super sub] it]
      (`` (when [super sub]
            (,, (template.with [<composite>]
                  [[{<composite> eL eR} {<composite> aL aR}]
                   (do ..monad
                     [assumptions (complete [assumptions eL aL])]
                     (complete [assumptions eR aR]))]

                  [.#Sum]
                  [.#Product]))
            
            [{.#Function eI eO} {.#Function aI aO}]
            (do ..monad
              [assumptions (complete [assumptions aI eI])]
              (complete [assumptions eO aO]))

            _
            (partial it))))))

(the variable
  (Subsumption Type)
  (function (_ partial complete it)
    (let [[assumptions super sub] it]
      (when [super sub]
        [{.#Variable idE} {.#Variable idA}]
        (check_vars complete [assumptions idE idA])
        
        [{.#Variable id} _]
        (if_can_bind id sub
                     (check#in assumptions)
                     (function (_ bound)
                       (complete [assumptions bound sub])))
        
        [_ {.#Variable id}]
        (if_can_bind id super
                     (check#in assumptions)
                     (function (_ bound)
                       (complete [assumptions super bound])))

        _
        (partial it)))))

(the opaque
  (Subsumption Type)
  (function (_ partial complete it)
    (let [[assumptions super sub] it]
      (when [super sub]
        [{.#Nominal e_name e_params} {.#Nominal a_name a_params}]
        (if (!text#= e_name a_name)
          (loop (again [assumptions assumptions
                        e_params e_params
                        a_params a_params])
            (when [e_params a_params]
              [{.#End} {.#End}]
              (check#in assumptions)
              
              [{.#Item e_head e_tail} {.#Item a_head a_tail}]
              (do ..monad
                [assumptions' (complete [assumptions e_head a_head])]
                (again assumptions' e_tail a_tail))

              _
              ..silent_failure!))
          ..silent_failure!)

        [{.#Opaque e!id} {.#Opaque a!id}]
        (if (!n#= e!id a!id)
          (check#in assumptions)
          ..silent_failure!)

        [{.#Named _ ?etype} _]
        (complete [assumptions ?etype sub])

        [_ {.#Named _ ?atype}]
        (complete [assumptions super ?atype])

        _
        (partial it)))))

(the application
  (Subsumption Type)
  (function (_ partial complete it)
    (let [[assumptions super sub] it]
      (`` (when [super sub]
            (,, (template.with [<fE> <fA>]
                  [[{.#Apply aE <fE>} {.#Apply aA <fA>}]
                   (check_apply complete [assumptions [aE <fE>] [aA <fA>]])]

                  [F1 {.#Opaque ex}]
                  [{.#Opaque exE} fA]
                  [fE {.#Variable idA}]
                  [{.#Variable idE} fA]))
            
            [{.#Apply A F} _]
            (let [new_assumption [super sub]]
              (if (assumed? new_assumption assumptions)
                (check#in assumptions)
                (do ..monad
                  [super' (..on A F)]
                  (complete [{.#Item new_assumption assumptions} super' sub]))))

            [_ {.#Apply A F}]
            (do ..monad
              [sub' (..on A F)]
              (complete [assumptions super sub']))

            _
            (partial it))))))

(the quantification
  (Subsumption Type)
  (function (_ partial complete it)
    (let [[assumptions super sub] it]
      (`` (when [super sub]
            ... TODO: Refactor-away as cold-code
            (,, (template.with [<tag> <instancer>]
                  [[{<tag> _} _]
                   (do ..monad
                     [[_ paramT] <instancer>
                      super' (..on paramT super)]
                     (complete [assumptions super' sub]))]

                  [.#Universal ..existential]
                  [.#Existential ..var]))

            ... TODO: Refactor-away as cold-code
            (,, (template.with [<tag> <instancer>]
                  [[_ {<tag> _}]
                   (do ..monad
                     [[_ paramT] <instancer>
                      sub' (..on paramT sub)]
                     (complete [assumptions super sub']))]

                  [.#Universal ..var]
                  [.#Existential ..existential]))

            _
            (partial it))))))

(the else
  (Subsumption Type)
  (function (_ partial complete it)
    ..silent_failure!))

(the subsumption
  (Checker Type)
  (<| mixin.fixed
      (all mixin.mixed
           ..same
           ..composite
           ..variable
           ..opaque
           ..application
           ..quantification
           ..else
           )))

(the .public (check super sub)
  (-> Type Type
      (Check Any))
  (..subsumption [(list) super sub]))

(the .public (subsumed? super sub)
  (-> Type Type
      Bit)
  (when (..value ..fresh_context
                 (..check super sub))
    {try.#Failure _}
    false

    {try.#Success _}
    true))

(the .public context
  (Check Type_Context)
  (function (_ context)
    {try.#Success [context context]}))

(the .public (with context)
  (-> Type_Context
      (Check Any))
  (function (_ _)
    {try.#Success [context []]}))

(the .public (clean aliases inputT)
  (-> (List Variable) Type
      (Check Type))
  (`` (when inputT
        {.#Nominal name paramsT+}
        (|> paramsT+
            (monad.each ..monad (clean aliases))
            (check#each (|>> {.#Nominal name})))

        (^.or {.#Parameter _}
              {.#Opaque _}
              {.#Named _})
        (check#in inputT)

        (,, (template.with [<tag>]
              [{<tag> leftT rightT}
               (do ..monad
                 [leftT' (clean aliases leftT)]
                 (|> (clean aliases rightT)
                     (check#each (|>> {<tag> leftT'}))))]

              [.#Sum]
              [.#Product]
              [.#Function]
              [.#Apply]))

        {.#Variable @it}
        (when aliases
          (list)
          (do ..monad
            [?subT (..peek @it)]
            (when ?subT
              {.#Some subT}
              (clean aliases subT)

              _
              (in inputT)))

          _
          (do ..monad
            [:it: (..try (..identity aliases @it))]
            (when :it:
              {try.#Success :it:}
              (when :it:
                {.#Variable _}
                (in inputT)

                _
                (clean aliases :it:))

              failure
              (in inputT))))

        (,, (template.with [<tag>]
              [{<tag> envT+ unquantifiedT}
               (do [! ..monad]
                 [envT+' (monad.each ! (clean aliases) envT+)
                  unquantifiedT' (clean aliases unquantifiedT)]
                 (in {<tag> envT+' unquantifiedT'}))]

              [.#Universal]
              [.#Existential]))
        )))
