... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

... https://en.wikipedia.org/wiki/Row_polymorphism
(.require
 [library
  [lux (.except Slot
                macro type its has revised record)
   [abstract
    ["[0]" monad (.only do)]]
   [control
    ["?" projection (.use "[1]#[0]" monad)]
    ["[0]" maybe (.use "[1]#[0]" monad)]
    ["[0]" try]
    ["[0]" exception (.only Exception)]]
   [data
    ["[0]" product]
    ["[0]" text (.only)
     ["%" \\injection]]
    [collection
     ["[0]" list (.use "[1]#[0]" monad mix)]
     ["[0]" dictionary (.only Dictionary)]
     ["[0]" set]]]
   [math
    [number
     ["n" natural]]]
   ["[0]" meta (.only)
    ["[0]" symbol]
    ["[0]" type]
    ["[0]" code (.only)
     ["?[1]" \\projection (.only Projection)]]
    ["[0]" macro (.only with_symbols)
     ["[0]" vocabulary]
     ["[0]" syntax (.only)
      ["[0]" export]]]]]])

(vocabulary.def
 [.public Slot]
 [.public slot]
 [.private macro]
 [.private by_name])

(.every .public (Row content extra)
  (Record
   [#content content
    #extra extra]))

(the declaration
  (Projection [Text (List Text)])
  (all ?.either
       (?.and ?code.local (?#in (list)))
       (?code.form (?.and ?code.local (?.some ?code.local)))
       ))

(the un_paired
  (for_any (_ value)
    (-> (List [value value])
        (List value)))
  (|>> (list#each (function (_ [left right])
                    (list left right)))
       list#conjoint))

(the record
  (Projection (List [Text Code]))
  (?code.tuple (?.many (?.and ?code.local ?code.any))))

(the super
  (Projection Code)
  ?code.any)

(the definition
  (Projection [(Maybe Code) (List [Text Code])])
  (all ?.either
       (?.and (?#in {.#None}) ..record)
       (?.and (?#each maybe#in ..super) ..record)
       ))

(the row_module (symbol.module (symbol ..Row)))
(the row_short (symbol.short (symbol ..Row)))

(the (nesting it)
  (-> Type Natural)
  (when it
    {.#Named _ it}
    (nesting it)

    {.#Existential (list) un_quantified}
    (when (type.flat_application un_quantified)
      [{.#Named [..row_module ..row_short] _} _]
      1

      [super _]
      (++ (nesting super)))

    _
    0))

(exception.the .public (cannot_repeat_slot_names slots)
  (Exception (List Text))
  (exception.report
   (list ["Slots" (exception.listing %.text slots)])))

(the (unique_slots? it)
  (-> (List Text) Bit)
  (|> it
      (set.of_list text.hash)
      set.size
      (n.= (list.size it))))

(the .public type
  (syntax.macro (_ [[export_policy [name parameters]] (export.with ..declaration)
                    [super slots] ..definition])
    (let [slot_names (list#each product.left slots)]
      (if (unique_slots? slot_names)
        (do [! meta.monad]
          [.let [parameters (list#each code.local parameters)]
           name' (macro.symbol name)
           slots' (monad.each ! (function (_ [slot type])
                                  (do !
                                    [slot' (macro.symbol slot)]
                                    (in [slot' type])))
                              slots)
           :super: (when super
                     {.#Some super}
                     (do !
                       [super (meta.eval Type
                                         (` (.type (, super))))]
                       (in {.#Some (as Type super)}))

                     _
                     (in {.#None}))]
          (with_symbols [g!_ g!&]
            (let [self (` (Row ((, name') (,* parameters))
                               (, g!&)))]
              (in (list.partial (` (.every (, export_policy) ((, name') (,* parameters))
                                     (Record
                                      [(,* (un_paired slots'))])))
                                (` (.every (, export_policy) ((, (code.local name)) (,* parameters))
                                     (for_some ((, g!_) (, g!&))
                                       (, (when super
                                            {.#Some super}
                                            (` ((, super) (, self)))

                                            _
                                            self)))))
                                (list#each (function (_ [[row_slot _] [record_slot _]])
                                             (` (the (, export_policy) (, (code.local row_slot))
                                                  (..slot
                                                   (syntax.macro ((, g!_) [])
                                                     (of meta.monad (,' in)
                                                         (list (,* (list.repeated (|> :super:
                                                                                      (maybe#each nesting)
                                                                                      (maybe.else 0))
                                                                                  (` (` ..#extra))))
                                                               (` ..#content)
                                                               (` (, record_slot)))))))))
                                           (list.zipped_2 slots slots'))
                                )))))
        (meta.of_try (exception.except ..cannot_repeat_slot_names [slot_names]))))))

(the .public its
  (syntax.macro (_ [slot ?code.symbol
                    row ?code.any])
    (do meta.monad
      [slot (by_name slot)
       path ((macro.function slot) (list))]
      (in (list (` (.its [(,* path)] (, row))))))))

(the .public has
  (syntax.macro (_ [slot ?code.symbol
                    value ?code.any
                    row ?code.any])
    (do meta.monad
      [slot (by_name slot)
       path ((macro.function slot) (list))]
      (in (list (` (.has [(,* path)] (, value) (, row))))))))

(the .public revised
  (syntax.macro (_ [slot ?code.symbol
                    revision ?code.any
                    row ?code.any])
    (do meta.monad
      [slot (by_name slot)
       path ((macro.function slot) (list))]
      (in (list (` (.revised [(,* path)] (, revision) (, row))))))))

(exception.the .public (missing_level it)
  (Exception Natural)
  (exception.report
   (list ["Level" (%.natural it)])))

(the .public row
  (syntax.macro (_ [slots (?code.tuple (?.many (?.and ?code.symbol ?code.any)))])
    (do [! meta.monad]
      [record (monad.each ! (function (_ [slot value])
                              (do !
                                [slot (by_name slot)
                                 path ((macro.function slot) (list))
                                 .let [nesting (n.- 2 (list.size path))
                                       slot (maybe.trusted (list.last path))]]
                                (in [nesting [slot value]])))
                          slots)
       .let [levels (list#mix (function (_ [nesting slot,value] levels)
                                (dictionary.revised' nesting
                                                     (list)
                                                     (|>> (list.partial slot,value))
                                                     levels))
                              (is (Dictionary Natural (List [Code Code]))
                                  (dictionary.empty n.hash))
                              record)]
       row (monad.mix ! (function (_ level extra)
                          (when (dictionary.value level levels)
                            {try.#Success record}
                            (in (` [..#content [(,* (un_paired record))]
                                    ..#extra (, extra)]))
                            
                            failure
                            (meta.of_try (exception.except ..missing_level [level]))))
                      (` [])
                      (|> (dictionary.size levels)
                          list.indices
                          list.reversed))]
      (in (list row)))))
