(.require
 [library
  [lux (.except except with)
   [abstract
    [functor (.only Functor)]
    [monad (.only Monad do)]]
   [control
    ["[0]" state]
    ["[0]" try (.only Try) (.use "[1]#[0]" functor)]
    ["[0]" exception (.only Exception)]
    ["[0]" io]]
   [data
    ["[0]" product]
    [text
     ["%" \\format (.only format)]]]
   [world
    [time
     ["[0]" instant]
     ["[0]" duration]]]]]
 [//
  [meta
   [archive (.only Archive)]]])

(type .public (Operation s o)
  (state.+State Try s o))

(def .public functor
  (All (_ s) (Functor (Operation s)))
  (implementation
   (def (each f it)
     (function (_ state)
       (case (it state)
         {try.#Success [state' output]}
         {try.#Success [state' (f output)]}
         
         {try.#Failure error}
         {try.#Failure error})))))

(def .public monad
  (All (_ s) (Monad (Operation s)))
  (implementation
   (def functor ..functor)
   
   (def (in it)
     (function (_ state)
       {try.#Success [state it]}))

   (def (conjoint it)
     (function (_ state)
       (case (it state)
         {try.#Success [state' it']}
         (it' state')
         
         {try.#Failure error}
         {try.#Failure error})))))

(type .public (Phase s i o)
  (-> Archive i (Operation s o)))

(type .public Wrapper
  (All (_ s i o) (-> (Phase s i o) Any)))

(def .public (result' state operation)
  (All (_ s o)
    (-> s (Operation s o) (Try [s o])))
  (operation state))

(def .public (result state operation)
  (All (_ s o)
    (-> s (Operation s o) (Try o)))
  (|> state
      operation
      (at try.monad each product.right)))

(def .public state
  (All (_ s o)
    (Operation s s))
  (function (_ state)
    {try.#Success [state state]}))

(def .public (with state)
  (All (_ s o)
    (-> s (Operation s Any)))
  (function (_ _)
    {try.#Success [state []]}))

(def .public (sub [get set] operation)
  (All (_ s s' o)
    (-> [(-> s s') (-> s' s s)]
        (Operation s' o)
        (Operation s o)))
  (function (_ state)
    (do try.monad
      [[state' output] (operation (get state))]
      (in [(set state' state) output]))))

(def .public failure
  (-> Text Operation)
  (|>> {try.#Failure} (state.lifted try.monad)))

(def .public (except exception parameters)
  (All (_ e) (-> (Exception e) e Operation))
  (..failure (exception.error exception parameters)))

(def .public (lifted error)
  (All (_ s a) (-> (Try a) (Operation s a)))
  (function (_ state)
    (try#each (|>> [state]) error)))

(def .public assertion
  (template (assertion exception message test)
    [(if test
       (at ..monad in [])
       (..except exception message))]))

(def .public identity
  (All (_ s a) (Phase s a a))
  (function (_ archive input state)
    {try.#Success [state input]}))

(def .public (composite pre post)
  (All (_ s0 s1 i t o)
    (-> (Phase s0 i t)
        (Phase s1 t o)
        (Phase [s0 s1] i o)))
  (function (_ archive input [pre/state post/state])
    (do try.monad
      [[pre/state' temp] (pre archive input pre/state)
       [post/state' output] (post archive temp post/state)]
      (in [[pre/state' post/state'] output]))))
