... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except Type Declaration)
   [abstract
    [equivalence (.only Equivalence)]
    [hash (.only Hash)]]
   [control
    ["[0]" maybe]]
   [data
    ["[0]" text (.only Injection)
     ["%" \\injection]]
    [collection
     ["[0]" list (.use "[1]#[0]" functor)]]]
   [math
    [number
     ["n" natural]]]
   [meta
    [type
     ["[0]" nominal]]
    [macro
     ["[0]" template]]]]]
 ["[0]" //
  [encoding
   ["[1][0]" name (.only External)]]]
 ["[0]" /
  ["[0]" category]
  ["[1][0]" signature (.only Signature)]
  ["[1][0]" descriptor (.only Descriptor)]
  ["[1][0]" reflection (.only Reflection)]])

(nominal.every .public (Type category)
  [(Signature category)
   (Descriptor category)
   (Reflection category)]

  (template.with [,name]
    [(`` (every .public ,name
           (Type (,, (template.symbol [category._] [,name])))))]

    [Void]
    [Primitive]
    
    [Array]
    [Class]
    [Object]

    [Var]
    [Parameter]

    [Value]
    [Return]

    [Declaration]
    [Method]
    )

  (every .public Argument
    [Text ..Value])

  (every .public (Typed of)
    (Record
     [#type ..Value
      #term of]))

  (every .public Constraint
    (Record
     [#name Text
      #super_class ..Class
      #super_interfaces (List ..Class)]))
  
  (template.with [<name> <style>]
    [(the .public (<name> type)
       (for_any (_ category)
         (-> (Type category)
             (<style> category)))
       (let [[signature descriptor reflection] (nominal.representation type)]
         <name>))]

    [signature Signature]
    [descriptor Descriptor]
    )

  (the .public (reflection type)
    (for_any (_ category)
      (-> (Type (category.Value category))
          (Reflection (category.Value category))))
    (let [[signature descriptor reflection] (nominal.representation type)]
      reflection))

  (template.with [<category> <name> <signature> <descriptor> <reflection>]
    [(the .public <name>
       <category>
       (nominal.abstraction
        [<signature>
         <descriptor>
         <reflection>]))]

    [..Void void /signature.void /descriptor.void /reflection.void]
    [..Primitive boolean /signature.boolean /descriptor.boolean /reflection.boolean]
    [..Primitive byte /signature.byte /descriptor.byte /reflection.byte]
    [..Primitive short /signature.short /descriptor.short /reflection.short]
    [..Primitive int /signature.int /descriptor.int /reflection.int]
    [..Primitive long /signature.long /descriptor.long /reflection.long]
    [..Primitive float /signature.float /descriptor.float /reflection.float]
    [..Primitive double /signature.double /descriptor.double /reflection.double]
    [..Primitive char /signature.char /descriptor.char /reflection.char]
    )

  (the .public (array type)
    (-> ..Value
        ..Array)
    (nominal.abstraction
     [(/signature.array (..signature type))
      (/descriptor.array (..descriptor type))
      (/reflection.array (..reflection type))]))

  (the .public (class parameters name)
    (-> (List ..Parameter) External
        ..Class)
    (nominal.abstraction
     [(/signature.class (list#each ..signature parameters) name)
      (/descriptor.class name)
      (/reflection.class name)]))

  (the .public (declaration variables name)
    (-> (List ..Var) External
        ..Declaration)
    (nominal.abstraction
     [(/signature.declaration (list#each ..signature variables) name)
      (/descriptor.declaration name)
      (/reflection.declaration name)]))

  (the .public (as_class type)
    (-> ..Declaration
        ..Class)
    (nominal.abstraction
     (let [[signature descriptor reflection] (nominal.representation type)]
       [(/signature.as_class signature)
        (/descriptor.as_class descriptor)
        (/reflection.as_class reflection)])))

  (the .public wildcard
    ..Parameter
    (nominal.abstraction
     [/signature.wildcard
      /descriptor.wildcard
      /reflection.wildcard]))

  (the .public (var name)
    (-> Text
        ..Var)
    (nominal.abstraction
     [(/signature.var name)
      /descriptor.var
      /reflection.var]))

  (the .public (lower bound)
    (-> ..Parameter
        ..Parameter)
    (nominal.abstraction
     (let [[signature descriptor reflection] (nominal.representation bound)]
       [(/signature.lower signature)
        (/descriptor.lower descriptor)
        (/reflection.lower reflection)])))

  (the .public (upper bound)
    (-> ..Parameter
        ..Parameter)
    (nominal.abstraction
     (let [[signature descriptor reflection] (nominal.representation bound)]
       [(/signature.upper signature)
        (/descriptor.upper descriptor)
        (/reflection.upper reflection)])))

  (the .public (method [type_variables inputs output exceptions])
    (-> [(List ..Var)
         (List ..Value)
         ..Return
         (List ..Class)]
        ..Method)
    (nominal.abstraction
     [(/signature.method [(list#each ..signature type_variables)
                          (list#each ..signature inputs)
                          (..signature output)
                          (list#each ..signature exceptions)])
      (/descriptor.method [(list#each ..descriptor inputs)
                           (..descriptor output)])
      (as_expected ..void)]))

  (the .public equivalence
    (for_any (_ category)
      (Equivalence (Type category)))
    (implementation
     (the (= parameter subject)
       (by /signature.equivalence =
           (..signature parameter)
           (..signature subject)))))

  (alias [=]
         ..equivalence)

  (the .public hash
    (for_any (_ category)
      (Hash (Type category)))
    (implementation
     (the equivalence ..equivalence)
     (the hash (|>> ..signature (by /signature.hash hash)))))

  (the .public (primitive? type)
    (-> ..Value
        (Either ..Object
                ..Primitive))
    (if (`` (or (,, (template.with [<type>]
                      [(by ..equivalence = (is ..Value <type>) type)]
                      
                      [..boolean]
                      [..byte]
                      [..short]
                      [..int]
                      [..long]
                      [..float]
                      [..double]
                      [..char]))))
      (|> type (as ..Primitive) {.#Right})
      (|> type (as ..Object) {.#Left})))

  (the .public (void? type)
    (-> ..Return
        (Either ..Value
                ..Void))
    (if (`` (or (,, (template.with [<type>]
                      [(by ..equivalence = (is ..Return <type>) type)]
                      
                      [..void]))))
      (|> type (as ..Void) {.#Right})
      (|> type (as ..Value) {.#Left})))
  )

(the .public (class? type)
  (-> ..Value
      (Maybe External))
  (let [repr (|> type ..descriptor /descriptor.descriptor)]
    (if (and (text.starts_with? /descriptor.class_prefix repr)
             (text.ends_with? /descriptor.class_suffix repr))
      (let [prefix_size (text.size /descriptor.class_prefix)
            suffix_size (text.size /descriptor.class_suffix)
            name_size (|> (text.size repr)
                          (n.- prefix_size)
                          (n.- suffix_size))]
        (|> repr
            (text.clip prefix_size name_size)
            (by maybe.monad each (|>> //name.internal //name.external))))
      {.#None})))

(the .public as_text
  (for_any (_ of)
    (Injection (Type of)))
  (|>> ..signature
       /signature.signature))
