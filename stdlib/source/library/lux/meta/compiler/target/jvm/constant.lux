... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except Integer Double
                #Integer
                integer)
   ["[0]" ffi (.only import)]
   [abstract
    [monad (.only do)]
    ["[0]" equivalence (.only Equivalence)]]
   [data
    ["[0]" sum]
    ["[0]" product]
    ["[0]" text]
    ["[0]" binary
     ["[1]F" \\injection (.only Injection) (.use "[1]#[0]" monoid)]]]
   [math
    [number
     ["[0]" i32 (.only I32)]
     ["[0]" i64]
     ["[0]" integer]
     ["[0]" decimal]]]
   [meta
    [macro
     ["^" pattern]
     ["[0]" template]
     ["[0]" expansion]]
    [type
     ["[0]" nominal]]]]]
 ["[0]" /
  ["[1][0]" tag]
  ["[1][0]" utf8 (.only UTF8)]
  ["[0]" class (.only Class)]
  ["[0]" name_and_type (.only Name_And_Type)]
  ["[0]" reference (.only Reference)]
  ["[1][0]" integer (.only Integer)]
  ["/[1]" //
   ["[1][0]" index (.only Index)]
   [type
    ["[1][0]" category]
    ["[1][0]" descriptor (.only Descriptor)]]
   [encoding
    ["[1][0]" unsigned]]]])

(import java/lang/Float
  "[1]::[0]"
  ("static" floatToRawIntBits "manual" [float] int))

(the .public float_equivalence
  (Equivalence java/lang/Float)
  (implementation
   (the (= parameter subject)
     (.jvm_float_=# (.jvm_object_cast# parameter)
                    (.jvm_object_cast# subject)))))

(import java/lang/Double
  "[1]::[0]"
  ("static" doubleToRawLongBits [double] long))

(nominal.every .public (Value kind)
  kind

  (the .public value
    (for_any (_ kind)
      (-> (Value kind)
          kind))
    (|>> nominal.representation))

  (the .public (value_equivalence Equivalence<kind>)
    (for_any (_ kind)
      (-> (Equivalence kind)
          (Equivalence (Value kind))))
    (of equivalence.functor each
        (|>> nominal.representation)
        Equivalence<kind>))

  (template.with [<constructor> <type> <marker>]
    [(every .public <type>
       (Value <marker>))

     (the .public <constructor>
       (-> <marker> <type>)
       (|>> nominal.abstraction))]

    [float   Float   java/lang/Float]
    [long    Long    .Integer]
    [double  Double  Decimal]
    [string  String  (Index UTF8)]
    )

  (template.with [<injection_name> <type> <write> <injection>]
    [(the <injection_name>
       (Injection <type>)
       (`` (|>> nominal.representation
                (,, (template.spliced <write>))
                (,, (template.spliced <injection>)))))]

    [float_injection Float [[] java/lang/Float::floatToRawIntBits ffi.of_int .i64] [i32.i32 binaryF.bits_32]]
    [long_injection Long [] [binaryF.bits_64]]
    [double_injection Double [[] java/lang/Double::doubleToRawLongBits ffi.of_long] [binaryF.bits_64]]
    [string_injection String [] [//index.injection]]
    )
  )

(every .public Constant
  (Variant
   {#UTF8 UTF8}
   {#Integer Integer}
   {#Float Float}
   {#Long Long}
   {#Double Double}
   {#Class Class}
   {#String String}
   {#Field (Reference //category.Value)}
   {#Method (Reference //category.Method)}
   {#Interface_Method (Reference //category.Method)}
   {#Name_And_Type (Name_And_Type Any)}))

(the .public (size constant)
  (-> Constant Natural)
  (when constant
    (^.or {#Long _}
          {#Double _})
    2

    _
    1))

(the .public equivalence
  (Equivalence Constant)
  ... TODO: Delete the explicit "implementation" and use the combinator
  ... version below as soon as the new format for variants is implemented.
  (implementation
   (the (= expected actual)
     (`` (when [expected actual]
           (,, (template.with [<tag> <equivalence>]
                 [[{<tag> expected} {<tag> actual}]
                  (of <equivalence> = expected actual)]

                 [#UTF8 text.equivalence]
                 [#Integer /integer.equivalence]
                 [#Long (..value_equivalence integer.equivalence)]
                 [#Float (..value_equivalence float_equivalence)]
                 [#Double (..value_equivalence decimal.equivalence)]
                 [#Class class.equivalence]
                 [#String (..value_equivalence //index.equivalence)]
                 [#Field reference.equivalence]
                 [#Method reference.equivalence]
                 [#Interface_Method reference.equivalence]
                 [#Name_And_Type name_and_type.equivalence]))
           
           _
           false))))
  ... (all sum.equivalence
  ...     ... #UTF8
  ...     text.equivalence
  ...     ... #Long
  ...     (..value_equivalence integer.equivalence)
  ...     ... #Double
  ...     (..value_equivalence decimal.equivalence)
  ...     ... #Class
  ...     class.equivalence
  ...     ... #String
  ...     (..value_equivalence //index.equivalence)
  ...     ... #Field
  ...     reference.equivalence
  ...     ... #Method
  ...     reference.equivalence
  ...     ... #Interface_Method
  ...     reference.equivalence
  ...     ... #Name_And_Type
  ...     name_and_type.equivalence
  ...     )
  )

(alias [=]
       ..equivalence)

(the .public injection
  (Injection Constant)
  (expansion.let [<constants> (these [#UTF8             /tag.utf8             /utf8.injection]
                                     [#Integer          /tag.integer          /integer.as_binary]
                                     [#Float            /tag.float            ..float_injection]
                                     [#Long             /tag.long             ..long_injection]
                                     [#Double           /tag.double           ..double_injection]
                                     [#Class            /tag.class            class.as_binary]
                                     [#String           /tag.string           ..string_injection]
                                     [#Field            /tag.field            reference.as_binary]
                                     [#Method           /tag.method           reference.as_binary]
                                     [#Interface_Method /tag.interface_method reference.as_binary]
                                     [#Name_And_Type    /tag.name_and_type    name_and_type.as_binary]
                                     ... TODO: Method_Handle
                                     ... TODO: Method_Type
                                     ... TODO: Invoke_Dynamic
                                     )]
    (function (_ value)
      (`` (when value
            (,, (template.with [<case> <tag> <injection>]
                  [{<case> value}
                   (binaryF#composite (/tag.injection <tag>)
                                      (<injection> value))]

                  <constants>))
            )))))
