... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except #Integer)
   ["[0]" ffi (.only import)]
   [abstract
    [monad (.only do)]
    ["[0]" equivalence (.only Equivalence)]]
   [data
    ["[0]" sum]
    ["[0]" product]
    ["[0]" text]
    ["[0]" binary
     ["[1]F" \\injection (.only Injection) (.use "[1]#[0]" monoid)]]]
   [math
    [number
     ["[0]" i32 (.only I32)]
     ["[0]" i64]
     ["[0]" integer]
     ["[0]" decimal]]]
   [meta
    [macro
     ["^" pattern]
     ["[0]" template]
     ["[0]" expansion]]
    [type
     ["[0]" nominal]]]]]
 ["[0]" /
  ["[1][0]" tag]
  ["[1][0]" utf8 (.only UTF8)]
  ["[0]" class (.only Class)]
  ["[0]" name_and_type (.only Name_And_Type)]
  ["[0]" reference (.only Reference)]
  ["[1][0]" integer]
  ["[1][0]" float]
  ["[1][0]" long]
  ["[1][0]" double]
  ["/[1]" //
   ["[1][0]" index (.only Index)]
   [type
    ["[1][0]" category]
    ["[1][0]" descriptor (.only Descriptor)]]
   [encoding
    ["[1][0]" unsigned]]]])

(template.with [<type> <marker>]
  [(every .public <type>
     <marker>)]

  [String  (Index UTF8)]
  )

(template.with [<injection_name> <type> <write> <injection>]
  [(the <injection_name>
     (Injection <type>)
     (`` (|>> (,, (template.spliced <write>))
              (,, (template.spliced <injection>)))))]

  [string_injection String [] [//index.injection]]
  )

(every .public Constant
  (Variant
   {#UTF8 UTF8}
   {#Integer /integer.Integer}
   {#Float /float.Float}
   {#Long /long.Long}
   {#Double /double.Double}
   {#Class Class}
   {#String String}
   {#Field (Reference //category.Value)}
   {#Method (Reference //category.Method)}
   {#Interface_Method (Reference //category.Method)}
   {#Name_And_Type (Name_And_Type Any)}))

(the .public (size constant)
  (-> Constant Natural)
  (when constant
    (^.or {#Long _}
          {#Double _})
    2

    _
    1))

(the .public equivalence
  (Equivalence Constant)
  ... TODO: Delete the explicit "implementation" and use the combinator
  ... version below as soon as the new format for variants is implemented.
  (implementation
   (the (= expected actual)
     (`` (when [expected actual]
           (,, (template.with [<tag> <equivalence>]
                 [[{<tag> expected} {<tag> actual}]
                  (of <equivalence> = expected actual)]

                 [#UTF8 text.equivalence]
                 [#Integer /integer.equivalence]
                 [#Long /long.equivalence]
                 [#Float /float.equivalence]
                 [#Double /double.equivalence]
                 [#Class class.equivalence]
                 [#String //index.equivalence]
                 [#Field reference.equivalence]
                 [#Method reference.equivalence]
                 [#Interface_Method reference.equivalence]
                 [#Name_And_Type name_and_type.equivalence]))
           
           _
           false))))
  ... (all sum.equivalence
  ...     ... #UTF8
  ...     text.equivalence
  ...     ... #Long
  ...     /long.equivalence
  ...     ... #Double
  ...     /double.equivalence
  ...     ... #Class
  ...     class.equivalence
  ...     ... #String
  ...     //index.equivalence
  ...     ... #Field
  ...     reference.equivalence
  ...     ... #Method
  ...     reference.equivalence
  ...     ... #Interface_Method
  ...     reference.equivalence
  ...     ... #Name_And_Type
  ...     name_and_type.equivalence
  ...     )
  )

(alias [=]
       ..equivalence)

(the .public injection
  (Injection Constant)
  (expansion.let [<constants> (these [#UTF8             /tag.utf8             /utf8.injection]
                                     [#Integer          /tag.integer          /integer.as_binary]
                                     [#Float            /tag.float            /float.as_binary]
                                     [#Long             /tag.long             /long.as_binary]
                                     [#Double           /tag.double           /double.as_binary]
                                     [#Class            /tag.class            class.as_binary]
                                     [#String           /tag.string           ..string_injection]
                                     [#Field            /tag.field            reference.as_binary]
                                     [#Method           /tag.method           reference.as_binary]
                                     [#Interface_Method /tag.interface_method reference.as_binary]
                                     [#Name_And_Type    /tag.name_and_type    name_and_type.as_binary]
                                     ... TODO: Method_Handle
                                     ... TODO: Method_Type
                                     ... TODO: Invoke_Dynamic
                                     )]
    (function (_ value)
      (`` (when value
            (,, (template.with [<case> <tag> <injection>]
                  [{<case> value}
                   (binaryF#composite (/tag.injection <tag>)
                                      (<injection> value))]

                  <constants>))
            )))))
