(.require
 [library
  [lux (.except)
   [abstract
    ["[0]" monad (.only do)]]
   [control
    ["[0]" try]
    ["[0]" exception (.only Exception)]]
   [data
    [text
     ["%" \\format (.only format)]]
    [collection
     ["[0]" list (.use "[1]#[0]" mix monoid)]]]
   ["[0]" meta (.only)
    [type
     ["[0]" check]]]]]
 ["[0]" //
  ["[1][0]" extension]
  ["[1][0]" analysis]
  ["/[1]" //
   ["/" declaration (.only Operation Phase Extender)]
   ["[1][0]" analysis (.only)
    ["[0]" evaluation]
    ["[1]/[0]" macro (.only Expander)]
    ["[1]/[0]" type]]
   [///
    ["//" phase]
    [reference (.only)
     [variable (.only)]]
    [meta
     [archive (.only Archive)]]]]])

(exception.def .public (not_a_declaration code)
  (Exception Code)
  (exception.report
   (list ["Declaration" (%.code code)])))

(exception.def .public (invalid_macro_call code)
  (Exception Code)
  (exception.report
   (list ["Code" (%.code code)])))

(exception.def .public (macro_was_not_found name)
  (Exception Symbol)
  (exception.report
   (list ["Name" (%.symbol name)])))

(type Eval
  (-> Type Code (Meta Any)))

(def (meta_eval archive bundle compiler_eval)
  (-> Archive ///analysis.Bundle evaluation.Eval
      Eval)
  (function (_ type code lux)
    (when (compiler_eval archive type code [bundle lux])
      {try.#Success [[_bundle lux'] value]}
      {try.#Success [lux' value]}
      
      {try.#Failure error}
      {try.#Failure error})))

(def (requiring phase archive expansion)
  (All (_ anchor expression declaration)
    (-> (Phase anchor expression declaration) Archive (List Code)
        (Operation anchor expression declaration /.Requirements)))
  (function (_ state)
    (loop (again [state state
                  input expansion
                  output /.no_requirements])
      (when input
        {.#End}
        {try.#Success [state output]}
        
        {.#Item head tail}
        (when (phase archive head state)
          {try.#Success [state' head']}
          (again state' tail (/.merge_requirements head' output))
          
          {try.#Failure error}
          {try.#Failure error})))))

(exception.def .public (not_an_extension [name expected actual])
  (Exception [Symbol Type Type])
  (exception.report
   (list ["Name" (%.symbol name)]
         ["Expected" (%.type expected)]
         ["Actual" (%.type actual)])))

(def (extension_application extender
                            phase archive
                            name parameters)
  (All (_ anchor expression declaration)
    (-> (Extender anchor expression declaration)
        (Phase anchor expression declaration) Archive
        Symbol (List Code)
        (Operation anchor expression declaration /.Requirements)))
  (do //.monad
    [[exported? type value] (<| /.lifted_analysis
                                //extension.lifted
                                (meta.export name))]
    (if (check.subsumes? .Declaration type)
      ((extender value) "" phase archive parameters)
      (//.except ..not_an_extension [name .Declaration type]))))

(type Outcome
  (Variant
   {#More (List Code)}
   {#Done /.Requirements}))

(with_expansions [<lux_def_module> (these [|form_location| {.#Form (list.partial [|text_location| {.#Text "lux def module"}] annotations)}])]
  (def .public (phase wrapper extender expander)
    (All (_ anchor expression declaration)
      (-> //.Wrapper (Extender anchor expression declaration) Expander (Phase anchor expression declaration)))
    (function (again archive code)
      (do [! //.monad]
        [state //.state
         .let [analysis (the [//extension.#state /.#analysis /.#phase] state)
               compiler_eval (meta_eval archive
                                        (the [//extension.#state /.#analysis /.#state //extension.#bundle] state)
                                        (let [analysis_state (the [//extension.#state /.#analysis /.#state //extension.#state] state)]
                                          (evaluation.evaluator analysis
                                                                [(the [//extension.#state /.#synthesis /.#state] state)
                                                                 ((the [//extension.#state /.#synthesis /.#phase] state) analysis_state)]
                                                                [(the [//extension.#state /.#generation /.#state] state)
                                                                 ((the [//extension.#state /.#generation /.#phase] state) analysis_state)])))
               extension_eval (as Eval (wrapper (as_expected compiler_eval)))]
         _ (//.with (has [//extension.#state /.#analysis /.#state //extension.#state .#eval] extension_eval state))]
        (when code
          [_ {.#Form (list.partial [_ {.#Text name}] inputs)}]
          (//extension.apply archive again [name inputs])

          [_ {.#Form (list.partial macro|extension inputs)}]
          (do !
            [expansion|requirements (do !
                                      [[def_type def_analysis] (<| /.lifted_analysis
                                                                   ///analysis/type.inferring
                                                                   (analysis archive macro|extension))]
                                      (when def_analysis
                                        (///analysis.constant def_name)
                                        (cond (check.subsumes? Macro def_type)
                                              (/.lifted_analysis
                                               (do !
                                                 [?macro (//extension.lifted (meta.macro def_name))
                                                  macro (when ?macro
                                                          {.#Some macro}
                                                          (in macro)
                                                          
                                                          {.#None}
                                                          (//.except ..macro_was_not_found def_name))
                                                  expansion (//extension.lifted (///analysis/macro.expansion expander def_name macro inputs))]
                                                 (in {#More expansion})))

                                              (check.subsumes? .Declaration def_type)
                                              (do !
                                                [requirements (extension_application extender again archive def_name inputs)]
                                                (in {#Done requirements}))
                                              
                                              ... else
                                              (//.except ..invalid_macro_call [code]))
                                        
                                        _
                                        (//.except ..invalid_macro_call [code])))]
            (when expansion|requirements
              {.#Left expansion}
              (when expansion
                (list.partial <lux_def_module> referrals)
                (|> (again archive <lux_def_module>)
                    (at ! each (revised /.#referrals (list#composite referrals))))

                _
                (..requiring again archive expansion))

              {.#Right requirements}
              (in requirements)))

          _
          (//.except ..not_a_declaration code))))))
