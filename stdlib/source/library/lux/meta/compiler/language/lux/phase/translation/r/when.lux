... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except when let if)
   [abstract
    ["[0]" monad (.only do)]]
   [data
    ["[0]" product]
    ["[0]" text]
    [collection
     ["[0]" stack (.use "[1]#[0]" functor mix)]
     ["[0]" set]]]
   [math
    [number
     ["i" integer]]]
   [macro
    ["[0]" template]]
   [meta
    [target
     ["_" r (.only SVar)]]]]]
 ["[0]" //
  ["[1][0]" runtime (.only Operation Phase Expression)]
  ["[1][0]" reference]
  ["[1][0]" primitive]
  ["/[1]" //
   ["[1][0]" reference]
   ["/[1]" //
    ["[1][0]" synthesis
     ["[1]/[0]" when]]
    ["/[1]" //
     ["[1][0]" synthesis (.only Member Synthesis Path)]
     ["[1][0]" translation]
     ["//[1]" ///
      [reference
       ["[1][0]" variable (.only Register)]]
      ["[1][0]" phase (.use "[1]#[0]" monad)]
      [meta
       [archive (.only Archive)]]]]]]])

(the .public register
  (-> Register SVar)
  (|>> (///reference.local //reference.system) as_expected))

(the .public capture
  (-> Register SVar)
  (|>> (///reference.foreign //reference.system) as_expected))

(the .public (let expression archive [valueS register bodyS])
  (Expression [Synthesis Register Synthesis])
  (do ///////phase.monad
    [valueO (expression archive valueS)
     bodyO (expression archive bodyS)]
    (in (_.block
         (all _.then
              (_.set! (..register register) valueO)
              bodyO)))))

(the .public (if expression archive [testS thenS elseS])
  (Expression [Synthesis Synthesis Synthesis])
  (do ///////phase.monad
    [testO (expression archive testS)
     thenO (expression archive thenS)
     elseO (expression archive elseS)]
    (in (_.if testO thenO elseO))))

(the .public (get expression archive [pathP valueS])
  (Expression [(Stack Member) Synthesis])
  (do ///////phase.monad
    [valueO (expression archive valueS)]
    (in (stack#mix (function (_ side source)
                     (.let [method (`` (.when side
                                         (,, (template.with [<side> <accessor>]
                                               [(<side> lefts)
                                                (<accessor> (_.int (.integer lefts)))]

                                               [.#Left  //runtime.tuple::left]
                                               [.#Right //runtime.tuple::right]))))]
                       (method source)))
                   valueO
                   pathP))))

(the $savepoint (_.var "lux_pm_cursor_savepoint"))
(the $cursor (_.var "lux_pm_cursor"))
(the $temp (_.var "lux_pm_temp"))
(the $alt_error (_.var "alt_error"))

(the top
  _.length)

(the next
  (|>> _.length (_.+ (_.int +1))))

(the (push! value var)
  (-> _.Expression SVar _.Expression)
  (_.set_item! (next var) value var))

(the (pop! var)
  (-> SVar _.Expression)
  (_.set_item! (top var) _.null var))

(the (push_cursor! value)
  (-> _.Expression _.Expression)
  (push! value $cursor))

(the save_cursor!
  _.Expression
  (push! (_.slice (_.float +1.0) (_.length $cursor) $cursor)
         $savepoint))

(the restore_cursor!
  _.Expression
  (_.set! $cursor (_.item (top $savepoint) $savepoint)))

(the peek
  _.Expression
  (|> $cursor (_.item (top $cursor))))

(the pop_cursor!
  _.Expression
  (pop! $cursor))

(the error
  (_.string (template.with_locals [error]
              (template.text [error]))))

(the fail!
  (_.stop ..error))

(the (catch handler)
  (-> _.Expression
      _.Expression)
  (_.function (stack $alt_error)
    (_.if (|> $alt_error (_.= ..error))
      handler
      (_.stop $alt_error))))

(the (pattern_matching' expression archive)
  (Expression Path)
  (function (again pathP)
    (`` (.when pathP
          {/////synthesis.#Then bodyS}
          (expression archive bodyS)

          {/////synthesis.#Pop}
          (///////phase#in ..pop_cursor!)

          {/////synthesis.#Bind register}
          (///////phase#in (_.set! (..register register) ..peek))

          {/////synthesis.#Bit_Fork when thenP elseP}
          (do [! ///////phase.monad]
            [then! (again thenP)
             else! (.when elseP
                     {.#Some elseP}
                     (again elseP)

                     {.#None}
                     (in ..fail!))]
            (in (.if when
                  (_.if ..peek
                    then!
                    else!)
                  (_.if ..peek
                    else!
                    then!))))

          (,, (template.with [<tag> <injection> <=>]
                [{<tag> item}
                 (do [! ///////phase.monad]
                   [clauses (monad.each ! (function (_ [match then])
                                            (do !
                                              [then! (again then)]
                                              (in [(<=> (|> match <injection>)
                                                        ..peek)
                                                   then!])))
                                        {.#Top item})]
                   (in (stack#mix (function (_ [when then] else)
                                    (_.if when then else))
                                  ..fail!
                                  clauses)))]

                [/////synthesis.#I64_Fork //primitive.i64 //runtime.i64::=]
                [/////synthesis.#F64_Fork //primitive.f64 _.=]
                [/////synthesis.#Text_Fork //primitive.text _.=]))

          (,, (template.with [<pm> <flag> <prep>]
                [(<pm> idx)
                 (///////phase#in (all _.then
                                       (_.set! $temp (|> idx <prep> .integer _.int (//runtime.sum::get ..peek (//runtime.flag <flag>))))
                                       (_.if (_.= _.null $temp)
                                         ..fail!
                                         (..push_cursor! $temp))))]

                [/////synthesis.side/left  false (<|)]
                [/////synthesis.side/right true  ++]))

          (/////synthesis.member/left 0)
          (///////phase#in (_.item (_.int +1) ..peek))

          (,, (template.with [<pm> <getter>]
                [(<pm> lefts)
                 (///////phase#in (|> ..peek (<getter> (_.int (.integer lefts))) ..push_cursor!))]

                [/////synthesis.member/left  //runtime.tuple::left]
                [/////synthesis.member/right //runtime.tuple::right]))

          (/////synthesis.path/seq leftP rightP)
          (do ///////phase.monad
            [leftO (again leftP)
             rightO (again rightP)]
            (in (all _.then
                     leftO
                     rightO)))

          (/////synthesis.path/alt leftP rightP)
          (do [! ///////phase.monad]
            [leftO (again leftP)
             rightO (again rightP)]
            (in (_.try (all _.then
                            ..save_cursor!
                            leftO)
                       {.#None}
                       {.#Some (..catch (all _.then
                                             ..restore_cursor!
                                             rightO))}
                       {.#None})))
          ))))

(the (pattern_matching expression archive pathP)
  (Expression Path)
  (do ///////phase.monad
    [pattern_matching! (pattern_matching' expression archive pathP)]
    (in (_.try pattern_matching!
               {.#None}
               {.#Some (..catch (_.stop (_.string "Invalid expression for pattern-matching.")))}
               {.#None}))))

(the .public (when expression archive [valueS pathP])
  (Expression [Synthesis Path])
  (do [! ///////phase.monad]
    [valueO (expression archive valueS)]
    (<| (by ! each (|>> (all _.then
                             (_.set! $cursor (_.list (stack valueO)))
                             (_.set! $savepoint (_.list (stack))))
                        _.block))
        (pattern_matching expression archive pathP))))
