(.require
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" maybe]
    ["[0]" try]
    ["[0]" io]
    [concurrency
     ["[0]" atom (.only Atom)]]]
   [data
    [collection
     ["[0]" dictionary (.only Dictionary)]]]
   [math
    [number
     ["n" nat]
     ["[0]" i64]]]
   ["[0]" meta (.only)
    [type (.only sharing)]]]]
 ["[0]" // (.only Operation)
  ["[1][0]" type]
  ["[1][0]" scope]
  [//
   [phase
    ["[0]P" analysis]
    ["[0]" extension]
    [//
     ["[0]" synthesis]
     ["[0]" generation]
     [///
      ["[0]" phase]
      [meta
       ["[0]" archive (.only Archive)
        ["[0]" module]]]]]]]])

(type .public Eval
  (-> Archive Type Code (Operation Any)))

(def evals
  (Atom (Dictionary module.ID Nat))
  (atom.atom (dictionary.empty n.hash)))

(def .public (evaluator analysis
                        [synthesis_state synthesis]
                        [generation_state generation])
  (All (_ anchor expression artifact)
    (-> //.Phase
        [synthesis.State+
         (-> Lux synthesis.Phase)]
        [(generation.State+ anchor expression artifact)
         (-> Lux (generation.Phase anchor expression artifact))]
        Eval))
  (function (eval archive type exprC)
    (do phase.monad
      [exprA (<| (//type.expecting type)
                 //scope.reset
                 (analysis archive exprC))
       module (extension.lifted
               meta.current_module_name)
       lux (extension.lifted
            meta.compiler_state)]
      (<| phase.lifted
          (do try.monad
            [exprS (|> exprA
                       (synthesis lux archive)
                       (phase.result synthesis_state))])
          (phase.result generation_state)
          (do phase.monad
            [@module (sharing [anchor expression artifact]
                       (is (-> Lux (generation.Phase anchor expression artifact))
                           generation)
                       (is (generation.Operation anchor expression artifact module.ID)
                           (generation.module_id module archive)))
             .let [[evals _] (io.run! (atom.update! (dictionary.revised' @module 0 ++) ..evals))
                   @eval (maybe.else 0 (dictionary.value @module evals))]
             exprO (<| (generation.with_registry_shift (|> @module
                                                           (i64.left_shifted 16)
                                                           (i64.or @eval)
                                                           (i64.left_shifted 32)))
                       (generation lux archive exprS))]
            (generation.evaluate! [@module @eval] [{.#None} exprO]))))))
