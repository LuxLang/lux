... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except Type)
   [abstract
    ["<>" projection]
    ["[0]" monad (.only do)]]
   [control
    ["[0]" maybe (.use "[1]#[0]" functor)]
    ["[0]" try]
    ["[0]" exception (.only Exception)]]
   [data
    ["[0]" product]
    [binary
     ["[0]" \\injection]]
    ["[0]" text (.only)
     ["%" \\injection]
     ["<[1]>" \\projection]]
    [collection
     ["[0]" list (.use "[1]#[0]" monad mix monoid)]
     ["[0]" dictionary (.only Dictionary)]
     ["[0]" set (.only Set)]
     ["[0]" sequence]]]
   [math
    [number
     ["n" natural]
     [integer
      ["i[0]" /32]]]]
   [macro
    ["^" pattern]
    ["[0]" template]
    ["[0]" expansion]]
   [meta
    ["[0]" provenance]
    [compiler
     [target
      [jvm
       ["[0]" version]
       ["[0]" modifier (.use "[1]#[0]" monoid)]
       ["[0]" method (.only Method)]
       ["[0]" class (.only Class)]
       [constant
        [pool (.only Resource)]]
       [encoding
        [name
         ["[0]" internal]]]
       ["_" bytecode (.only Bytecode) (.use "[1]#[0]" monad)
        ["__" instruction (.only Primitive_Array_Type)]]
       ["[0]" type (.only Type Typed Argument)
        ["[0]" category (.only Void Value Return Primitive Object Array Var Parameter)]
        ["[0]" box]
        ["[0]" reflection]
        ["[0]" signature]
        ["[0]" projection]]]]]]]]
 ["[0]" //
  [common (.only custom)]
  ["///[1]" ////
   [translation
    [extension (.only Nullary Unary Binary Trinary Variadic
                      nullary unary binary trinary variadic)]
    ["///" jvm (.only)
     ["[1][0]" runtime (.only Operation Bundle Phase Handler)]
     ["[1][0]" reference]
     ["[1][0]" value]
     [function
      [field
       [variable
        ["[0]" foreign]]]]]]
   ["[0]" extension (.only)
    [analysis
     ["/" jvm]]]
   ["/[1]" //
    ["[0]" phase]
    ["[1][0]" translation]
    ["[0]" synthesis (.only Path)
     ["<[1]>" \\projection (.only Projection)]]
    [analysis (.only Environment)
     ["[0]" complex]]
    [///
     ["[1][0]" reference (.only)
      [register (.only Register)]
      ["[2][0]" variable (.only Variable)]]
     [meta
      ["[0]" archive (.only Archive)
       ["[0]" artifact]
       ["[0]" unit]]
      ["[0]" cache
       [dependency
        ["[1]/[0]" artifact]]]]]]]])

(template.with [<name> <0>]
  [(the <name>
     (Bytecode Any)
     (all _.composite
          _.l2i
          <0>))]

  [l2s _.i2s]
  [l2b _.i2b]
  [l2c _.i2c]
  )

(template.with [<conversion> <name>]
  [(the (<name> inputG)
     (Unary (Bytecode Any))
     (if (same? _.nop <conversion>)
       inputG
       (all _.composite
            inputG
            <conversion>)))]
  
  [_.d2f conversion::double_to_float]
  [_.d2i conversion::double_to_int]
  [_.d2l conversion::double_to_long]
  
  [_.f2d conversion::float_to_double]
  [_.f2i conversion::float_to_int]
  [_.f2l conversion::float_to_long]
  
  [_.i2b conversion::int_to_byte]
  [_.i2c conversion::int_to_char]
  [_.i2d conversion::int_to_double]
  [_.i2f conversion::int_to_float]
  [_.i2l conversion::int_to_long]
  [_.i2s conversion::int_to_short]
  
  [_.l2d conversion::long_to_double]
  [_.l2f conversion::long_to_float]
  [_.l2i conversion::long_to_int]
  [..l2s conversion::long_to_short]
  [..l2b conversion::long_to_byte]
  [..l2c conversion::long_to_char]
  
  [_.i2b conversion::char_to_byte]
  [_.i2s conversion::char_to_short]
  [_.nop conversion::char_to_int]
  [_.i2l conversion::char_to_long]
  
  [_.i2l conversion::byte_to_long]
  
  [_.i2l conversion::short_to_long]
  )

(the with_conversion_extensions
  (-> Bundle
      Bundle)
  (|>> (dictionary.has (text "jvm_" "conversion_" "double_to_float" "#" "|translation") (unary conversion::double_to_float))
       (dictionary.has (text "jvm_" "conversion_" "double_to_int" "#" "|translation") (unary conversion::double_to_int))
       (dictionary.has (text "jvm_" "conversion_" "double_to_long" "#" "|translation") (unary conversion::double_to_long))
       
       (dictionary.has (text "jvm_" "conversion_" "float_to_double" "#" "|translation") (unary conversion::float_to_double))
       (dictionary.has (text "jvm_" "conversion_" "float_to_int" "#" "|translation") (unary conversion::float_to_int))
       (dictionary.has (text "jvm_" "conversion_" "float_to_long" "#" "|translation") (unary conversion::float_to_long))
       
       (dictionary.has (text "jvm_" "conversion_" "int_to_byte" "#" "|translation") (unary conversion::int_to_byte))
       (dictionary.has (text "jvm_" "conversion_" "int_to_char" "#" "|translation") (unary conversion::int_to_char))
       (dictionary.has (text "jvm_" "conversion_" "int_to_double" "#" "|translation") (unary conversion::int_to_double))
       (dictionary.has (text "jvm_" "conversion_" "int_to_float" "#" "|translation") (unary conversion::int_to_float))
       (dictionary.has (text "jvm_" "conversion_" "int_to_long" "#" "|translation") (unary conversion::int_to_long))
       (dictionary.has (text "jvm_" "conversion_" "int_to_short" "#" "|translation") (unary conversion::int_to_short))
       
       (dictionary.has (text "jvm_" "conversion_" "long_to_double" "#" "|translation") (unary conversion::long_to_double))
       (dictionary.has (text "jvm_" "conversion_" "long_to_float" "#" "|translation") (unary conversion::long_to_float))
       (dictionary.has (text "jvm_" "conversion_" "long_to_int" "#" "|translation") (unary conversion::long_to_int))
       (dictionary.has (text "jvm_" "conversion_" "long_to_short" "#" "|translation") (unary conversion::long_to_short))
       (dictionary.has (text "jvm_" "conversion_" "long_to_byte" "#" "|translation") (unary conversion::long_to_byte))
       (dictionary.has (text "jvm_" "conversion_" "long_to_char" "#" "|translation") (unary conversion::long_to_char))
       
       (dictionary.has (text "jvm_" "conversion_" "char_to_byte" "#" "|translation") (unary conversion::char_to_byte))
       (dictionary.has (text "jvm_" "conversion_" "char_to_short" "#" "|translation") (unary conversion::char_to_short))
       (dictionary.has (text "jvm_" "conversion_" "char_to_int" "#" "|translation") (unary conversion::char_to_int))
       (dictionary.has (text "jvm_" "conversion_" "char_to_long" "#" "|translation") (unary conversion::char_to_long))
       
       (dictionary.has (text "jvm_" "conversion_" "byte_to_long" "#" "|translation") (unary conversion::byte_to_long))
       
       (dictionary.has (text "jvm_" "conversion_" "short_to_long" "#" "|translation") (unary conversion::short_to_long))
       ))

(template.with [<name> <op>]
  [(the (<name> [parameter! subject!])
     (Binary (Bytecode Any))
     (all _.composite
          subject!
          parameter!
          <op>))]

  [int::+ _.iadd]
  [int::- _.isub]
  [int::* _.imul]
  [int::/ _.idiv]
  [int::% _.irem]
  [int::and _.iand]
  [int::or _.ior]
  [int::xor _.ixor]
  [int::shl _.ishl]
  [int::shr _.ishr]
  [int::ushr _.iushr]
  
  [long::+ _.ladd]
  [long::- _.lsub]
  [long::* _.lmul]
  [long::/ _.ldiv]
  [long::% _.lrem]
  [long::and _.land]
  [long::or _.lor]
  [long::xor _.lxor]
  [long::shl _.lshl]
  [long::shr _.lshr]
  [long::ushr _.lushr]

  [float::+ _.fadd]
  [float::- _.fsub]
  [float::* _.fmul]
  [float::/ _.fdiv]
  [float::% _.frem]
  
  [double::+ _.dadd]
  [double::- _.dsub]
  [double::* _.dmul]
  [double::/ _.ddiv]
  [double::% _.drem]
  )

(the $Boolean (type.class (list) box.boolean))
(the falseG (_.getstatic ..$Boolean "FALSE" ..$Boolean))
(the trueG (_.getstatic ..$Boolean "TRUE" ..$Boolean))

(template.with [<name> <op>]
  [(the (<name> [expected actual])
     (Binary (Bytecode Any))
     (do _.monad
       [@then _.new_label
        @end _.new_label]
       (all _.composite
            actual
            expected
            (<op> @then)
            falseG
            (_.goto @end)
            (_.set_label @then)
            trueG
            (_.set_label @end))))]

  [int::= _.if_icmpeq]
  [int::< _.if_icmplt]

  [char::= _.if_icmpeq]
  [char::< _.if_icmplt]
  )

(template.with [<name> <op> <expected>]
  [(the (<name> [expected actual])
     (Binary (Bytecode Any))
     (do _.monad
       [@then _.new_label
        @end _.new_label]
       (all _.composite
            actual
            expected
            <op>
            (_.int (i/32.of <expected>))
            (_.if_icmpeq @then)
            falseG
            (_.goto @end)
            (_.set_label @then)
            trueG
            (_.set_label @end))))]

  [long::= _.lcmp +0]
  [long::< _.lcmp -1]
  
  [float::= _.fcmpg +0]
  [float::< _.fcmpg -1]

  [double::= _.dcmpg +0]
  [double::< _.dcmpg -1]
  )

(the with_int_extensions
  (-> Bundle
      Bundle)
  (let [type (reflection.reflection reflection.int)]
    (|>> (dictionary.has (text "jvm_" type "_" "+" "#" "|translation") (binary int::+))
         (dictionary.has (text "jvm_" type "_" "-" "#" "|translation") (binary int::-))
         (dictionary.has (text "jvm_" type "_" "*" "#" "|translation") (binary int::*))
         (dictionary.has (text "jvm_" type "_" "/" "#" "|translation") (binary int::/))
         (dictionary.has (text "jvm_" type "_" "%" "#" "|translation") (binary int::%))
         (dictionary.has (text "jvm_" type "_" "=" "#" "|translation") (binary int::=))
         (dictionary.has (text "jvm_" type "_" "<" "#" "|translation") (binary int::<))
         (dictionary.has (text "jvm_" type "_" "and" "#" "|translation") (binary int::and))
         (dictionary.has (text "jvm_" type "_" "or" "#" "|translation") (binary int::or))
         (dictionary.has (text "jvm_" type "_" "xor" "#" "|translation") (binary int::xor))
         (dictionary.has (text "jvm_" type "_" "shl" "#" "|translation") (binary int::shl))
         (dictionary.has (text "jvm_" type "_" "shr" "#" "|translation") (binary int::shr))
         (dictionary.has (text "jvm_" type "_" "ushr" "#" "|translation") (binary int::ushr))
         )))

(the with_long_extensions
  (-> Bundle
      Bundle)
  (let [type (reflection.reflection reflection.long)]
    (|>> (dictionary.has (text "jvm_" type "_" "+" "#" "|translation") (binary long::+))
         (dictionary.has (text "jvm_" type "_" "-" "#" "|translation") (binary long::-))
         (dictionary.has (text "jvm_" type "_" "*" "#" "|translation") (binary long::*))
         (dictionary.has (text "jvm_" type "_" "/" "#" "|translation") (binary long::/))
         (dictionary.has (text "jvm_" type "_" "%" "#" "|translation") (binary long::%))
         (dictionary.has (text "jvm_" type "_" "=" "#" "|translation") (binary long::=))
         (dictionary.has (text "jvm_" type "_" "<" "#" "|translation") (binary long::<))
         (dictionary.has (text "jvm_" type "_" "and" "#" "|translation") (binary long::and))
         (dictionary.has (text "jvm_" type "_" "or" "#" "|translation") (binary long::or))
         (dictionary.has (text "jvm_" type "_" "xor" "#" "|translation") (binary long::xor))
         (dictionary.has (text "jvm_" type "_" "shl" "#" "|translation") (binary long::shl))
         (dictionary.has (text "jvm_" type "_" "shr" "#" "|translation") (binary long::shr))
         (dictionary.has (text "jvm_" type "_" "ushr" "#" "|translation") (binary long::ushr))
         )))

(the with_float_extensions
  (-> Bundle
      Bundle)
  (let [type (reflection.reflection reflection.float)]
    (|>> (dictionary.has (text "jvm_" type "_" "+" "#" "|translation") (binary float::+))
         (dictionary.has (text "jvm_" type "_" "-" "#" "|translation") (binary float::-))
         (dictionary.has (text "jvm_" type "_" "*" "#" "|translation") (binary float::*))
         (dictionary.has (text "jvm_" type "_" "/" "#" "|translation") (binary float::/))
         (dictionary.has (text "jvm_" type "_" "%" "#" "|translation") (binary float::%))
         (dictionary.has (text "jvm_" type "_" "=" "#" "|translation") (binary float::=))
         (dictionary.has (text "jvm_" type "_" "<" "#" "|translation") (binary float::<))
         )))

(the with_double_extensions
  (-> Bundle
      Bundle)
  (let [type (reflection.reflection reflection.double)]
    (|>> (dictionary.has (text "jvm_" type "_" "+" "#" "|translation") (binary double::+))
         (dictionary.has (text "jvm_" type "_" "-" "#" "|translation") (binary double::-))
         (dictionary.has (text "jvm_" type "_" "*" "#" "|translation") (binary double::*))
         (dictionary.has (text "jvm_" type "_" "/" "#" "|translation") (binary double::/))
         (dictionary.has (text "jvm_" type "_" "%" "#" "|translation") (binary double::%))
         (dictionary.has (text "jvm_" type "_" "=" "#" "|translation") (binary double::=))
         (dictionary.has (text "jvm_" type "_" "<" "#" "|translation") (binary double::<))
         )))

(the with_char_extensions
  (-> Bundle
      Bundle)
  (let [type (reflection.reflection reflection.char)]
    (|>> (dictionary.has (text "jvm_" type "_" "=" "#" "|translation") (binary char::=))
         (dictionary.has (text "jvm_" type "_" "<" "#" "|translation") (binary char::<))
         )))

(template.with [<name> <category> <projection>]
  [(the .public <name>
     (Projection (Type <category>))
     (<text>.then <projection> <synthesis>.text))]

  [var Var projection.var]
  [class category.Class projection.class]
  [object Object projection.object]
  [value Value projection.value]
  [return Return projection.return]
  )

(the reflection
  (for_any (_ category)
    (-> (Type (Value category))
        Text))
  (|>> type.reflection reflection.reflection))

(the signature
  (for_any (_ category)
    (-> (Type category)
        Text))
  (|>> type.signature signature.signature))

(exception.the .public (not_an_object_array arrayJT)
  (Exception (Type Array))
  (exception.report
   (list ["JVM type" (..signature arrayJT)])))

(the .public object_array
  (Projection (Type Object))
  (do <>.monad
    [arrayJT (<text>.then projection.array <synthesis>.text)]
    (when (projection.array? arrayJT)
      {.#Some elementJT}
      (when (projection.object? elementJT)
        {.#Some elementJT}
        (in elementJT)

        {.#None}
        (<>.failure (exception.error ..not_an_object_array [arrayJT])))
      
      {.#None}
      (undefined))))

(the (primitive_array_length_handler jvm_primitive)
  (-> (Type Primitive)
      Handler)
  (..custom
   [<synthesis>.any
    (function (_ translate archive arrayS)
      (do phase.monad
        [arrayG (translate archive arrayS)]
        (in (all _.composite
                 arrayG
                 (_.checkcast (type.array jvm_primitive))
                 _.arraylength))))]))

(the array::length::object
  Handler
  (..custom
   [(all <>.and ..object_array <synthesis>.any)
    (function (_ translate archive [elementJT arrayS])
      (do phase.monad
        [arrayG (translate archive arrayS)]
        (in (all _.composite
                 arrayG
                 (_.checkcast (type.array elementJT))
                 _.arraylength))))]))

(the (new_primitive_array_handler jvm_primitive)
  (-> Primitive_Array_Type
      Handler)
  (..custom
   [<synthesis>.any
    (function (_ translate archive [lengthS])
      (do phase.monad
        [lengthG (translate archive lengthS)]
        (in (all _.composite
                 lengthG
                 (_.newarray jvm_primitive)))))]))

(the array::new::object
  Handler
  (..custom
   [(all <>.and ..object <synthesis>.any)
    (function (_ translate archive [objectJT lengthS])
      (do phase.monad
        [lengthG (translate archive lengthS)]
        (in (all _.composite
                 lengthG
                 (_.anewarray objectJT)))))]))

(the (read_primitive_array_handler jvm_primitive loadG)
  (-> (Type Primitive) (Bytecode Any)
      Handler)
  (..custom
   [(all <>.and <synthesis>.any <synthesis>.any)
    (function (_ translate archive [idxS arrayS])
      (do phase.monad
        [arrayG (translate archive arrayS)
         idxG (translate archive idxS)]
        (in (all _.composite
                 arrayG
                 (_.checkcast (type.array jvm_primitive))
                 idxG
                 loadG))))]))

(the array::read::object
  Handler
  (..custom
   [(all <>.and ..object_array <synthesis>.any <synthesis>.any)
    (function (_ translate archive [elementJT idxS arrayS])
      (do phase.monad
        [arrayG (translate archive arrayS)
         idxG (translate archive idxS)]
        (in (all _.composite
                 arrayG
                 (_.checkcast (type.array elementJT))
                 idxG
                 _.aaload))))]))

(the (write_primitive_array_handler jvm_primitive storeG)
  (-> (Type Primitive) (Bytecode Any)
      Handler)
  (..custom
   [(all <>.and <synthesis>.any <synthesis>.any <synthesis>.any)
    (function (_ translate archive [idxS valueS arrayS])
      (do phase.monad
        [arrayG (translate archive arrayS)
         idxG (translate archive idxS)
         valueG (translate archive valueS)]
        (in (all _.composite
                 arrayG
                 (_.checkcast (type.array jvm_primitive))
                 _.dup
                 idxG
                 valueG
                 storeG))))]))

(the array::write::object
  Handler
  (..custom
   [(all <>.and ..object_array <synthesis>.any <synthesis>.any <synthesis>.any)
    (function (_ translate archive [elementJT idxS valueS arrayS])
      (do phase.monad
        [arrayG (translate archive arrayS)
         idxG (translate archive idxS)
         valueG (translate archive valueS)]
        (in (all _.composite
                 arrayG
                 (_.checkcast (type.array elementJT))
                 _.dup
                 idxG
                 valueG
                 _.aastore))))]))

(the with_array_extensions
  (-> Bundle
      Bundle)
  (|>> (dictionary.has (text "jvm_" "array_" "length_" (reflection.reflection reflection.boolean) "#" "|translation") (primitive_array_length_handler type.boolean))
       (dictionary.has (text "jvm_" "array_" "length_" (reflection.reflection reflection.byte) "#" "|translation") (primitive_array_length_handler type.byte))
       (dictionary.has (text "jvm_" "array_" "length_" (reflection.reflection reflection.short) "#" "|translation") (primitive_array_length_handler type.short))
       (dictionary.has (text "jvm_" "array_" "length_" (reflection.reflection reflection.int) "#" "|translation") (primitive_array_length_handler type.int))
       (dictionary.has (text "jvm_" "array_" "length_" (reflection.reflection reflection.long) "#" "|translation") (primitive_array_length_handler type.long))
       (dictionary.has (text "jvm_" "array_" "length_" (reflection.reflection reflection.float) "#" "|translation") (primitive_array_length_handler type.float))
       (dictionary.has (text "jvm_" "array_" "length_" (reflection.reflection reflection.double) "#" "|translation") (primitive_array_length_handler type.double))
       (dictionary.has (text "jvm_" "array_" "length_" (reflection.reflection reflection.char) "#" "|translation") (primitive_array_length_handler type.char))
       (dictionary.has (text "jvm_" "array_" "length_" "object" "#" "|translation") array::length::object)

       (dictionary.has (text "jvm_" "array_" "new_" (reflection.reflection reflection.boolean) "#" "|translation") (new_primitive_array_handler __.t_boolean))
       (dictionary.has (text "jvm_" "array_" "new_" (reflection.reflection reflection.byte) "#" "|translation") (new_primitive_array_handler __.t_byte))
       (dictionary.has (text "jvm_" "array_" "new_" (reflection.reflection reflection.short) "#" "|translation") (new_primitive_array_handler __.t_short))
       (dictionary.has (text "jvm_" "array_" "new_" (reflection.reflection reflection.int) "#" "|translation") (new_primitive_array_handler __.t_int))
       (dictionary.has (text "jvm_" "array_" "new_" (reflection.reflection reflection.long) "#" "|translation") (new_primitive_array_handler __.t_long))
       (dictionary.has (text "jvm_" "array_" "new_" (reflection.reflection reflection.float) "#" "|translation") (new_primitive_array_handler __.t_float))
       (dictionary.has (text "jvm_" "array_" "new_" (reflection.reflection reflection.double) "#" "|translation") (new_primitive_array_handler __.t_double))
       (dictionary.has (text "jvm_" "array_" "new_" (reflection.reflection reflection.char) "#" "|translation") (new_primitive_array_handler __.t_char))
       (dictionary.has (text "jvm_" "array_" "new_" "object" "#" "|translation") array::new::object)

       (dictionary.has (text "jvm_" "array_" "read_" (reflection.reflection reflection.boolean) "#" "|translation") (read_primitive_array_handler type.boolean _.baload))
       (dictionary.has (text "jvm_" "array_" "read_" (reflection.reflection reflection.byte) "#" "|translation") (read_primitive_array_handler type.byte _.baload))
       (dictionary.has (text "jvm_" "array_" "read_" (reflection.reflection reflection.short) "#" "|translation") (read_primitive_array_handler type.short _.saload))
       (dictionary.has (text "jvm_" "array_" "read_" (reflection.reflection reflection.int) "#" "|translation") (read_primitive_array_handler type.int _.iaload))
       (dictionary.has (text "jvm_" "array_" "read_" (reflection.reflection reflection.long) "#" "|translation") (read_primitive_array_handler type.long _.laload))
       (dictionary.has (text "jvm_" "array_" "read_" (reflection.reflection reflection.float) "#" "|translation") (read_primitive_array_handler type.float _.faload))
       (dictionary.has (text "jvm_" "array_" "read_" (reflection.reflection reflection.double) "#" "|translation") (read_primitive_array_handler type.double _.daload))
       (dictionary.has (text "jvm_" "array_" "read_" (reflection.reflection reflection.char) "#" "|translation") (read_primitive_array_handler type.char _.caload))
       (dictionary.has (text "jvm_" "array_" "read_" "object" "#" "|translation") array::read::object)

       (dictionary.has (text "jvm_" "array_" "write_" (reflection.reflection reflection.boolean) "#" "|translation") (write_primitive_array_handler type.boolean _.bastore))
       (dictionary.has (text "jvm_" "array_" "write_" (reflection.reflection reflection.byte) "#" "|translation") (write_primitive_array_handler type.byte _.bastore))
       (dictionary.has (text "jvm_" "array_" "write_" (reflection.reflection reflection.short) "#" "|translation") (write_primitive_array_handler type.short _.sastore))
       (dictionary.has (text "jvm_" "array_" "write_" (reflection.reflection reflection.int) "#" "|translation") (write_primitive_array_handler type.int _.iastore))
       (dictionary.has (text "jvm_" "array_" "write_" (reflection.reflection reflection.long) "#" "|translation") (write_primitive_array_handler type.long _.lastore))
       (dictionary.has (text "jvm_" "array_" "write_" (reflection.reflection reflection.float) "#" "|translation") (write_primitive_array_handler type.float _.fastore))
       (dictionary.has (text "jvm_" "array_" "write_" (reflection.reflection reflection.double) "#" "|translation") (write_primitive_array_handler type.double _.dastore))
       (dictionary.has (text "jvm_" "array_" "write_" (reflection.reflection reflection.char) "#" "|translation") (write_primitive_array_handler type.char _.castore))
       (dictionary.has (text "jvm_" "array_" "write_" "object" "#" "|translation") array::write::object)
       ))

(the (object::null _)
  (Nullary (Bytecode Any))
  _.aconst_null)

(the (object::null? objectG)
  (Unary (Bytecode Any))
  (do _.monad
    [@then _.new_label
     @end _.new_label]
    (all _.composite
         objectG
         (_.ifnull @then)
         ..falseG
         (_.goto @end)
         (_.set_label @then)
         ..trueG
         (_.set_label @end))))

(the (object::synchronized [monitorG exprG])
  (Binary (Bytecode Any))
  (all _.composite
       monitorG
       _.dup
       _.monitorenter
       exprG
       _.swap
       _.monitorexit))

(the unitG
  (_.string synthesis.unit))

(the (object::throw exceptionG)
  (Unary (Bytecode Any))
  (all _.composite
       exceptionG
       (_.checkcast (type.class (list) "java.lang.Throwable"))
       ///runtime.throw
       unitG))

(the $Class (type.class (list) "java.lang.Class"))
(the $String (type.class (list) "java.lang.String"))

(the object::class
  Handler
  (..custom
   [<synthesis>.text
    (function (_ translate archive [class])
      (do phase.monad
        []
        (in (all _.composite
                 (_.string class)
                 (_.invokestatic ..$Class "forName" (type.method [(list) (list ..$String) ..$Class (list)]))))))]))

(the object::instance?
  Handler
  (..custom
   [(all <>.and <synthesis>.text <synthesis>.any)
    (function (_ translate archive [class objectS])
      (do phase.monad
        [objectG (translate archive objectS)]
        (in (all _.composite
                 objectG
                 (_.instanceof (type.class (list) class))
                 (///value.boxed type.boolean)))))]))

(the object::cast
  Handler
  (..custom
   [(all <>.and <synthesis>.text <synthesis>.text <synthesis>.any)
    (function (_ translate archive [from to valueS])
      (do phase.monad
        [valueG (translate archive valueS)]
        (in (`` (if (,, (template.with [<object> <type>]
                          [(and (text.= (..reflection <type>) from)
                                (text.= <object> to))
                           (all _.composite
                                valueG
                                (///value.boxed <type>))

                           (and (text.= <object> from)
                                (text.= (..reflection <type>) to))
                           (all _.composite
                                valueG
                                (///value.primitive <type>))]
                          
                          [box.boolean type.boolean]
                          [box.byte    type.byte]
                          [box.short   type.short]
                          [box.int     type.int]
                          [box.long    type.long]
                          [box.char    type.char]
                          [box.float   type.float]
                          [box.double  type.double]))
                  ... else
                  valueG)))))]))

(the with_object_extensions
  (-> Bundle
      Bundle)
  (|>> (dictionary.has (text "jvm_" "object_" "null" "#" "|translation") (nullary object::null))
       (dictionary.has (text "jvm_" "object_" "null?" "#" "|translation") (unary object::null?))
       (dictionary.has (text "jvm_" "object_" "synchronized" "#" "|translation") (binary object::synchronized))
       (dictionary.has (text "jvm_" "object_" "throw" "#" "|translation") (unary object::throw))
       (dictionary.has (text "jvm_" "object_" "class" "#" "|translation") object::class)
       (dictionary.has (text "jvm_" "object_" "instance?" "#" "|translation") object::instance?)
       (dictionary.has (text "jvm_" "object_" "cast" "#" "|translation") object::cast)
       ))

(the get::static
  Handler
  (..custom
   [(all <>.and <synthesis>.text <synthesis>.text ..value)
    (function (_ translate archive [class field :unboxed:])
      (by phase.monad in (_.getstatic (type.class (list) class) field :unboxed:)))]))

(the put::static
  Handler
  (..custom
   [(all <>.and <synthesis>.text <synthesis>.text ..value <synthesis>.any)
    (function (_ translate archive [class field :unboxed: valueS])
      (do phase.monad
        [valueG (translate archive valueS)]
        (in (all _.composite
                 valueG
                 (when (projection.object? :unboxed:)
                   {.#Some :unboxed:}
                   (_.checkcast :unboxed:)
                   
                   {.#None}
                   (_#in []))
                 (_.putstatic (type.class (list) class) field :unboxed:)
                 ..unitG))))]))

(the get::virtual
  Handler
  (..custom
   [(all <>.and <synthesis>.text <synthesis>.text ..value <synthesis>.any)
    (function (_ translate archive [class field :unboxed: objectS])
      (do phase.monad
        [objectG (translate archive objectS)
         .let [:class: (type.class (list) class)
               getG (_.getfield :class: field :unboxed:)]]
        (in (all _.composite
                 objectG
                 (_.checkcast :class:)
                 getG))))]))

(the put::virtual
  Handler
  (..custom
   [(all <>.and <synthesis>.text <synthesis>.text ..value <synthesis>.any <synthesis>.any)
    (function (_ translate archive [class field :unboxed: valueS objectS])
      (do phase.monad
        [valueG (translate archive valueS)
         objectG (translate archive objectS)
         .let [:class: (type.class (list) class)
               putG (when (projection.object? :unboxed:)
                      {.#Some :unboxed:}
                      (all _.composite
                           (_.checkcast :unboxed:)
                           (_.putfield :class: field :unboxed:))
                      
                      {.#None}
                      (_.putfield :class: field :unboxed:))]]
        (in (all _.composite
                 objectG
                 (_.checkcast :class:)
                 _.dup
                 valueG
                 putG))))]))

(every Input
  (Typed synthesis.Term))

(the input
  (Projection Input)
  (<synthesis>.tuple (<>.and ..value <synthesis>.any)))

(the (translate_input translate archive [valueT valueS])
  (-> Phase Archive Input
      (Operation (Typed (Bytecode Any))))
  (do phase.monad
    [valueG (translate archive valueS)]
    (when (type.primitive? valueT)
      {.#Right valueT}
      (in [valueT valueG])
      
      {.#Left valueT}
      (in [valueT (all _.composite
                       valueG
                       (_.checkcast valueT))]))))

(the (prepare_output outputT)
  (-> (Type Return)
      (Bytecode Any))
  (when (type.void? outputT)
    {.#Right outputT}
    ..unitG
    
    {.#Left outputT}
    (_#in [])))

(the invoke::static
  Handler
  (..custom
   [(all <>.and ..class <synthesis>.text ..return (<>.some ..input))
    (function (_ translate archive [class method outputT inputsTS])
      (do [! phase.monad]
        [inputsTG (monad.each ! (translate_input translate archive) inputsTS)]
        (in (all _.composite
                 (monad.each _.monad product.right inputsTG)
                 (_.invokestatic class method (type.method [(list) (list#each product.left inputsTG) outputT (list)]))
                 (prepare_output outputT)))))]))

(template.with [<check_cast?> <name> <invoke>]
  [(the <name>
     Handler
     (..custom
      [(all <>.and ..class <synthesis>.text ..return <synthesis>.any (<>.some ..input))
       (function (_ translate archive [class method outputT objectS inputsTS])
         (do [! phase.monad]
           [objectG (translate archive objectS)
            inputsTG (monad.each ! (translate_input translate archive) inputsTS)]
           (in (all _.composite
                    objectG
                    (if <check_cast?>
                      (_.checkcast class)
                      (_#in []))
                    (monad.each _.monad product.right inputsTG)
                    (<invoke> class method (type.method [(list) (list#each product.left inputsTG) outputT (list)]))
                    (prepare_output outputT)))))]))]

  [#1 invoke::virtual _.invokevirtual]
  [#0 invoke::special _.invokespecial]
  [#1 invoke::interface _.invokeinterface]
  )

(the invoke::constructor
  Handler
  (..custom
   [(all <>.and ..class (<>.some ..input))
    (function (_ translate archive [class inputsTS])
      (do [! phase.monad]
        [inputsTG (monad.each ! (translate_input translate archive) inputsTS)]
        (in (all _.composite
                 (_.new class)
                 _.dup
                 (monad.each _.monad product.right inputsTG)
                 (_.invokespecial class "<init>" (type.method [(list) (list#each product.left inputsTG) type.void (list)]))))))]))

(the with_member_extensions
  (-> Bundle
      Bundle)
  (|>> (dictionary.has (text "jvm_" "member_" "get_" "static" "#" "|translation") get::static)
       (dictionary.has (text "jvm_" "member_" "get_" "virtual" "#" "|translation") get::virtual)
       
       (dictionary.has (text "jvm_" "member_" "put_" "static" "#" "|translation") put::static)
       (dictionary.has (text "jvm_" "member_" "put_" "virtual" "#" "|translation") put::virtual)
       
       (dictionary.has (text "jvm_" "member_" "invoke_" "static" "#" "|translation") invoke::static)
       (dictionary.has (text "jvm_" "member_" "invoke_" "virtual" "#" "|translation") invoke::virtual)
       (dictionary.has (text "jvm_" "member_" "invoke_" "special" "#" "|translation") invoke::special)
       (dictionary.has (text "jvm_" "member_" "invoke_" "interface" "#" "|translation") invoke::interface)
       (dictionary.has (text "jvm_" "member_" "invoke_" "constructor" "#" "|translation") invoke::constructor)
       ))

(the annotation_parameter
  (Projection (/.Annotation_Parameter synthesis.Term))
  (<synthesis>.tuple (<>.and <synthesis>.text <synthesis>.any)))

(the annotation
  (Projection (/.Annotation synthesis.Term))
  (<synthesis>.tuple (<>.and <synthesis>.text (<>.some ..annotation_parameter))))

(the argument
  (Projection Argument)
  (<synthesis>.tuple (<>.and <synthesis>.text ..value)))

(the .public (hidden_method_body arity body)
  (-> Natural synthesis.Term
      synthesis.Term)
  (expansion.let [<oops> (halt! (text (%.natural arity) " " (synthesis.as_text body)))]
    (when [arity body]
      (^.or [0 _]
            [1 _])
      body
      
      [_ [@ {synthesis.#Control {synthesis.#When _ path}}]]
      (loop (again [path (is Path path)])
        (when path
          {synthesis.#Seq _ next}
          (again next)
          
          {synthesis.#Then (synthesis.tuple @ (list _ hidden))}
          hidden
          
          _
          <oops>))

      _
      <oops>)))

(the (without_fake_parameter#path without_fake_parameter)
  (-> (-> synthesis.Term synthesis.Term)
      (-> Path Path))
  (function (again it)
    (`` (when it
          (^.or {synthesis.#Pop}
                {synthesis.#Access _})
          it
          
          {synthesis.#Bind it}
          {synthesis.#Bind (-- it)}
          
          {synthesis.#Bit_Fork when then else}
          {synthesis.#Bit_Fork when
                               (again then)
                               (maybe#each again else)}

          (,, (template.with [<tag>]
                [{<tag> [head tail]}
                 {<tag> [(revised synthesis.#then again head)
                         (list#each (revised synthesis.#then again) tail)]}]

                [synthesis.#I64_Fork]
                [synthesis.#F64_Fork]
                [synthesis.#Text_Fork]))
          
          (,, (template.with [<tag>]
                [{<tag> left right}
                 {<tag> (again left) (again right)}]

                [synthesis.#Seq]
                [synthesis.#Alt]))
          
          {synthesis.#Then it}
          {synthesis.#Then (without_fake_parameter it)}))))

(the .public (without_fake_parameter it)
  (-> synthesis.Term
      synthesis.Term)
  (when it
    [@ {synthesis.#Simple _}]
    it
    
    [@ {synthesis.#Structure it}]
    [@ {synthesis.#Structure
        (when it
          {complex.#Variant it}
          {complex.#Variant (revised complex.#value without_fake_parameter it)}

          {complex.#Tuple it}
          {complex.#Tuple (list#each without_fake_parameter it)})}]
    
    [@ {synthesis.#Reference it}]
    [@ {synthesis.#Reference
        (when it
          {//////reference.#Variable it}
          {//////reference.#Variable
           (when it
             {//////variable.#Local it}
             {//////variable.#Local (-- it)}
             
             {//////variable.#Foreign _}
             it)}
          
          {//////reference.#Constant _}
          it)}]
    
    [@ {synthesis.#Control it}]
    [@ {synthesis.#Control
        (when it
          {synthesis.#When value path}
          {synthesis.#When (without_fake_parameter value)
                           (without_fake_parameter#path without_fake_parameter path)}
          
          {synthesis.#Loop it}
          {synthesis.#Loop
           (when it
             {synthesis.#Tail_Recursion [synthesis.#start start
                                         synthesis.#inits inits
                                         synthesis.#iteration iteration]}
             {synthesis.#Tail_Recursion [synthesis.#start (-- start)
                                         synthesis.#inits (list#each without_fake_parameter inits)
                                         synthesis.#iteration iteration]}
             
             {synthesis.#Tail_Iteration _}
             it)}
          
          {synthesis.#Function it}
          {synthesis.#Function
           (when it
             {synthesis.#Abstraction [synthesis.#environment environment
                                      synthesis.#arity arity
                                      synthesis.#body body]}
             {synthesis.#Abstraction [synthesis.#environment (list#each without_fake_parameter environment)
                                      synthesis.#arity arity
                                      synthesis.#body body]}
             
             {synthesis.#Reification [synthesis.#function function
                                      synthesis.#arguments arguments]}
             {synthesis.#Reification [synthesis.#function (without_fake_parameter function)
                                      synthesis.#arguments (list#each without_fake_parameter arguments)]})})}]

    [@ {synthesis.#Extension name parameters}]
    [@ {synthesis.#Extension name (list#each without_fake_parameter parameters)}]))

(the overriden_method_definition
  (Projection [(Environment synthesis.Term) (/.Overriden_Method synthesis.Term)])
  (<synthesis>.tuple (do <>.monad
                       [_ (<synthesis>.this_text /.overriden_tag)
                        ownerT ..class
                        name <synthesis>.text
                        strict_fp? <synthesis>.bit
                        annotations (<synthesis>.tuple (<>.some ..annotation))
                        vars (<synthesis>.tuple (<>.some ..var))
                        self_name <synthesis>.text
                        arguments (<synthesis>.tuple (<>.some ..argument))
                        returnT ..return
                        exceptionsT (<synthesis>.tuple (<>.some ..class))
                        [environment _ _ body] (<| (<synthesis>.function 1)
                                                   (<synthesis>.loop (<>.exactly 0 <synthesis>.any))
                                                   <synthesis>.tuple
                                                   (<>.after <synthesis>.any)
                                                   <synthesis>.any)
                        .let [arity (list.size arguments)]]
                       (in [environment
                            [ownerT name
                             strict_fp? annotations vars
                             self_name arguments returnT exceptionsT
                             (<| (..hidden_method_body arity)
                                 (when arity
                                   0 (without_fake_parameter body)
                                   _ body))]]))))

(the (normalize_path normalize)
  (-> (-> synthesis.Term synthesis.Term)
      (-> Path Path))
  (function (again path)
    (`` (when path
          (synthesis.path/then bodyS)
          (synthesis.path/then (normalize bodyS))

          (,, (template.with [<tag>]
                [{<tag> leftP rightP}
                 {<tag> (again leftP) (again rightP)}]

                [synthesis.#Alt]
                [synthesis.#Seq]))

          (,, (template.with [<tag>]
                [{<tag> _}
                 path]

                [synthesis.#Pop]
                [synthesis.#Bind]
                [synthesis.#Access]))

          {synthesis.#Bit_Fork when then else}
          {synthesis.#Bit_Fork when (again then) (maybe#each again else)}

          (,, (template.with [<tag>]
                [{<tag> [[exampleH nextH] tail]}
                 {<tag> [[exampleH (again nextH)]
                         (list#each (function (_ [example next])
                                      [example (again next)])
                                    tail)]}]

                [synthesis.#I64_Fork]
                [synthesis.#F64_Fork]
                [synthesis.#Text_Fork]))))))

(every Mapping
  (Dictionary synthesis.Term Variable))

(the (normalize_method_body mapping)
  (-> Mapping synthesis.Term
      synthesis.Term)
  (function (again body)
    (`` (when body
          (,, (template.with [<tag>]
                [<tag>
                 body]

                [[@ {synthesis.#Simple _}]]
                [(synthesis.constant @ _)]))

          (synthesis.variant @ [lefts right? sub])
          (synthesis.variant @ [lefts right? (again sub)])

          (synthesis.tuple @ members)
          (synthesis.tuple @ (list#each again members))

          (synthesis.variable @ var)
          (|> mapping
              (dictionary.value body)
              (try.else var)
              (synthesis.variable @))

          (synthesis.when @ [inputS pathS])
          (synthesis.when @ [(again inputS) (normalize_path again pathS)])

          (synthesis.tail_recursion @ [offset initsS+ bodyS])
          (synthesis.tail_recursion @ [offset (list#each again initsS+) (again bodyS)])

          (synthesis.tail_iteration @ updatesS+)
          (synthesis.tail_iteration @ (list#each again updatesS+))

          (synthesis.abstraction @ [environment arity bodyS])
          (synthesis.abstraction @ [(list#each (function (_ captured)
                                                 (when captured
                                                   (synthesis.variable @ var)
                                                   (|> mapping
                                                       (dictionary.value captured)
                                                       (try.else var)
                                                       (synthesis.variable @))

                                                   _
                                                   captured))
                                               environment)
                                    arity
                                    bodyS])

          (synthesis.reification @ [functionS inputsS+])
          (synthesis.reification @ [(again functionS) (list#each again inputsS+)])

          [@ {synthesis.#Extension [name inputsS+]}]
          [@ {synthesis.#Extension [name (list#each again inputsS+)]}]))))

(the $Object
  (type.class (list) "java.lang.Object"))

(the (anonymous_init_method env inputsTI)
  (-> (Environment synthesis.Term) (List (Typed (Bytecode Any)))
      (Type category.Method))
  (type.method [(list)
                (list.repeated (n.+ (list.size inputsTI) (list.size env)) ..$Object)
                type.void
                (list)]))

(the (with_anonymous_init class env super_class inputsTG)
  (-> (Type category.Class) (Environment synthesis.Term) (Type category.Class) (List (Typed (Bytecode Any)))
      (Resource Method))
  (let [inputs_offset (list.size inputsTG)
        inputs! (|> inputsTG
                    list.enumeration
                    (list#each (function (_ [register [type term]])
                                 (let [then! (when (type.primitive? type)
                                               {.#Right type}
                                               (///value.primitive type)
                                               
                                               {.#Left type}
                                               (_.checkcast type))]
                                   (all _.composite
                                        (_.aload (++ register))
                                        then!))))
                    list.reversed
                    (list#mix _.composite (_#in [])))
        store_captured! (|> env
                            list.size
                            list.indices
                            (monad.each _.monad (.function (_ register)
                                                  (all _.composite
                                                       (_.aload 0)
                                                       (_.aload (n.+ inputs_offset (++ register)))
                                                       (_.putfield class (///reference.foreign_name register) $Object)))))]
    (method.method method.public "<init>"
      true (anonymous_init_method env inputsTG)
      (list)
      {.#Some (all _.composite
                   (_.aload 0)
                   inputs!
                   (_.invokespecial super_class "<init>" (type.method [(list) (list#each product.left inputsTG) type.void (list)]))
                   store_captured!
                   _.return)})))

(the (anonymous_instance translate archive class env inputsTI)
  (-> Phase Archive (Type category.Class) (Environment synthesis.Term) (List (Typed (Bytecode Any)))
      (Operation (Bytecode Any)))
  (do [! phase.monad]
    [captureG+ (monad.each ! (translate archive) env)]
    (in (all _.composite
             (_.new class)
             _.dup
             (|> inputsTI
                 (list#each product.right)
                 list.reversed
                 (list#mix _.composite (_#in [])))
             (monad.all _.monad captureG+)
             (_.invokespecial class "<init>" (anonymous_init_method env inputsTI))))))

(the (returnG returnT)
  (-> (Type Return)
      (Bytecode Any))
  (when (type.void? returnT)
    {.#Right returnT}
    _.return

    {.#Left returnT}
    (when (type.primitive? returnT)
      {.#Left returnT}
      (when (type.class? returnT)
        {.#Some class_name}
        (all _.composite
             (_.checkcast returnT)
             _.areturn)

        {.#None}
        _.areturn)
      
      {.#Right returnT}
      (template.let [(unwrap_primitive <return> <type>)
                     [(all _.composite
                           (///value.primitive <type>)
                           <return>)]]
        (`` (if (,, (template.with [<return> <type>]
                      [(by type.equivalence = <type> returnT)
                       (unwrap_primitive <return> <type>)]

                      [_.ireturn type.boolean]
                      [_.ireturn type.byte]
                      [_.ireturn type.short]
                      [_.ireturn type.int]
                      [_.ireturn type.char]
                      [_.freturn type.float]
                      [_.lreturn type.long]))

              ... (by type.equivalence = type.double returnT)
              (unwrap_primitive _.dreturn type.double)))))))

(the (method_dependencies archive method)
  (-> Archive (/.Overriden_Method synthesis.Term)
      (Operation (Set unit.ID)))
  (let [[_super _name _strict_fp? _annotations
         _t_vars _this _arguments _return _exceptions
         bodyS] method]
    (cache/artifact.dependencies archive bodyS)))

(the (anonymous_dependencies archive inputsTS overriden_methods)
  (-> Archive (List Input) (List [(Environment synthesis.Term) (/.Overriden_Method synthesis.Term)])
      (Operation (Set unit.ID)))
  (do [! phase.monad]
    [all_input_dependencies (monad.each ! (|>> product.right (cache/artifact.dependencies archive)) inputsTS)
     all_closure_dependencies (|> overriden_methods
                                  (list#each product.left)
                                  list.together
                                  (monad.each ! (cache/artifact.dependencies archive)))
     all_method_dependencies (monad.each ! (|>> product.right (method_dependencies archive)) overriden_methods)]
    (in (cache/artifact.all (all list#composite
                                 all_input_dependencies
                                 all_closure_dependencies
                                 all_method_dependencies)))))

(the (prepare_argument lux_register argumentT jvm_register)
  (-> Register (Type Value) Register
      [Register (Bytecode Any)])
  (when (type.primitive? argumentT)
    {.#Left argumentT}
    [(n.+ 1 jvm_register)
     (if (n.= lux_register jvm_register)
       (_#in [])
       (all _.composite
            (_.aload jvm_register)
            (_.astore lux_register)))]
    
    {.#Right argumentT}
    (template.let [(wrap_primitive <shift> <load> <type>)
                   [[(n.+ <shift> jvm_register)
                     (all _.composite
                          (<load> jvm_register)
                          (///value.boxed <type>)
                          (_.astore lux_register))]]]
      (`` (if (,, (template.with [<shift> <load> <type>]
                    [(by type.equivalence = <type> argumentT)
                     (wrap_primitive <shift> <load> <type>)]

                    [1 _.iload type.boolean]
                    [1 _.iload type.byte]
                    [1 _.iload type.short]
                    [1 _.iload type.int]
                    [1 _.iload type.char]
                    [1 _.fload type.float]
                    [2 _.lload type.long]))

            ... (by type.equivalence = type.double argumentT)
            (wrap_primitive 2 _.dload type.double))))))

(the .public (prepare_arguments offset types)
  (-> Natural (List (Type Value))
      (Bytecode Any))
  (|> types
      list.enumeration
      (list#mix (function (_ [lux_register type] [jvm_register before])
                  (let [[jvm_register' after] (prepare_argument (n.+ offset lux_register) type jvm_register)]
                    [jvm_register'
                     (all _.composite
                          before
                          after)]))
                (is [Register (Bytecode Any)]
                    [offset
                     (_#in [])]))
      product.right))

(the (normalized_method global_mapping [environment method])
  (-> Mapping [(Environment synthesis.Term) (/.Overriden_Method synthesis.Term)]
      (/.Overriden_Method synthesis.Term))
  (let [[ownerT name strict_fp? annotations vars self_name arguments returnT exceptionsT body] method
        local_mapping (|> environment
                          list.enumeration
                          (list#each (function (_ [foreign_id capture])
                                       [(synthesis.foreign provenance.dummy foreign_id)
                                        (|> global_mapping
                                            (dictionary.value capture)
                                            try.trusted)]))
                          (dictionary.of_list synthesis.hash))]
    [ownerT name
     strict_fp? annotations vars
     self_name arguments returnT exceptionsT
     (normalize_method_body local_mapping body)]))

(the (total_environment overriden_methods)
  (-> (List [(Environment synthesis.Term) (/.Overriden_Method synthesis.Term)])
      (List synthesis.Term))
  (|> overriden_methods
      ... Get all the environments.
      (list#each product.left)
      ... Combine them.
      list#conjoint
      ... Remove duplicates.
      (set.of_list synthesis.hash)
      set.list))

(the (global_mapping total_environment)
  (-> (List synthesis.Term)
      Mapping)
  (|> total_environment
      ... Give them names as "foreign" variables.
      list.enumeration
      (list#each (function (_ [id capture])
                   [capture {//////variable.#Foreign id}]))
      (dictionary.of_list synthesis.hash)))

(the (method_definition phase archive artifact_id method)
  (-> Phase Archive artifact.ID (/.Overriden_Method synthesis.Term)
      (Operation (Resource Method)))
  (let [[ownerT name strict_fp? annotations vars self_name arguments returnT exceptionsT bodyS] method]
    (do phase.monad
      [bodyG (//////translation.with_context artifact_id
               (phase archive bodyS))
       .let [argumentsT (list#each product.right arguments)
             methodT (type.method [vars argumentsT returnT exceptionsT])]]
      (in (method.method (all modifier#composite
                              method.public
                              method.final
                              (if strict_fp?
                                method.strict
                                modifier#identity))
            name
            true methodT
            (list)
            {.#Some (all _.composite
                         (prepare_arguments 1 argumentsT)
                         bodyG
                         (returnG returnT))})))))

(the class::anonymous
  Handler
  (..custom
   [(all <>.and
         ..class
         (<synthesis>.tuple (<>.some ..class))
         (<synthesis>.tuple (<>.some ..input))
         (<synthesis>.tuple (<>.some ..overriden_method_definition)))
    (function (_ translate archive [super_class
                                    super_interfaces
                                    inputsTS
                                    overriden_methods])
      (do [! phase.monad]
        [all_dependencies (anonymous_dependencies archive inputsTS overriden_methods)
         [context _] (//////translation.with_new_context archive all_dependencies (in []))
         .let [[module_id artifact_id] context
               anonymous_class_name (///runtime.class_name context)
               class (type.class (list) anonymous_class_name)
               total_environment (..total_environment overriden_methods)
               global_mapping (..global_mapping total_environment)]
         inputsTI (monad.each ! (translate_input translate archive) inputsTS)
         methods! (|> overriden_methods
                      (list#each (normalized_method global_mapping))
                      (monad.each ! (method_definition translate archive artifact_id)))
         bytecode (<| (by ! each (\\injection.value class.as_binary))
                      phase.of_try
                      (class.class version.v6_0 (all modifier#composite class.public class.final)
                        (internal.name anonymous_class_name)
                        {.#None}
                        (internal.name (..reflection super_class))
                        (list#each (|>> ..reflection internal.name) super_interfaces)
                        (foreign.variables total_environment)
                        (list.partial (..with_anonymous_init class total_environment super_class inputsTI)
                                      methods!)
                        (list)))
         .let [artifact [anonymous_class_name bytecode]]
         _ (//////translation.execute! artifact)
         _ (//////translation.save! artifact_id {.#None} artifact)]
        (anonymous_instance translate archive class total_environment inputsTI)))]))

(the with_class_extensions
  (-> Bundle
      Bundle)
  (dictionary.has (text "jvm_" "class_" "anonymous" "#" "|translation") class::anonymous))

(the .public bundle
  Bundle
  (<| with_conversion_extensions
      with_int_extensions
      with_long_extensions
      with_float_extensions
      with_double_extensions
      with_char_extensions
      with_array_extensions
      with_object_extensions
      with_member_extensions
      with_class_extensions
      extension.empty
      ))
