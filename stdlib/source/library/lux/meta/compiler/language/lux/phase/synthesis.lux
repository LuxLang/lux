(.require
 [library
  [lux (.except Synthesis Analysis)
   [abstract
    ["[0]" monad (.only do)]]
   [control
    ["[0]" pipe]
    ["[0]" try]
    ["[0]" exception (.only Exception)]]
   [data
    [text
     ["%" \\format]]
    [collection
     ["[0]" list (.use "[1]#[0]" functor)]
     ["[0]" dictionary (.only Dictionary)]]]
   ["[0]" meta (.only)
    [macro
     ["^" pattern]]
    [type
     ["[0]" check]]]]]
 ["[0]" /
  ["[1][0]" function]
  ["[1][0]" when]
  ["[1][0]" variable]
  ["//[1]" ///
   ["/" synthesis (.only Synthesis Operation Phase Extender Handler)
    ["[1][0]" simple]]
   ["[1][0]" analysis (.only Analysis)
    ["[2][0]" simple]
    ["[2][0]" complex]]
   [///
    ["[0]" phase (.use "[1]#[0]" monad)]
    [reference (.only)
     [variable (.only)]]
    [meta
     [archive (.only Archive)]]]]])

(def (simple analysis)
  (-> ///simple.Simple /simple.Simple)
  (when analysis
    {///simple.#Unit}
    {/simple.#Text /.unit}
    
    (^.with_template [<analysis> <synthesis>]
      [{<analysis> value}
       {<synthesis> value}])
    ([///simple.#Bit  /simple.#Bit]
     [///simple.#Frac /simple.#F64]
     [///simple.#Text /simple.#Text])

    (^.with_template [<analysis> <synthesis>]
      [{<analysis> value}
       {<synthesis> (.i64 value)}])
    ([///simple.#Nat /simple.#I64]
     [///simple.#Int /simple.#I64]
     [///simple.#Rev /simple.#I64])))

(exception.def .public (not_an_extension [name expected actual])
  (Exception [Symbol Type Type])
  (exception.report
   (list ["Name" (%.symbol name)]
         ["Expected" (%.type expected)]
         ["Actual" (%.type actual)])))

(def (extension_application extender lux
                            phase archive
                            name parameters)
  (-> Extender Lux
      Phase Archive
      Symbol (List Analysis)
      (Operation Synthesis))
  (when (|> (do [! meta.monad]
              [definition (meta.try (meta.export name))]
              (when definition
                {try.#Success [exported? type definition]}
                (in [type {.#Left definition}])
                
                {try.#Failure error}
                (do !
                  [[exported? type default] (meta.default name)]
                  (in [type {.#Right default}]))))
            (is (Meta [Type (Either Any Any)]))
            (meta.result lux))
    {try.#Success [type value]}
    (if (check.subsumes? .Synthesis type)
      (when value
        {.#Left definition}
        ((extender definition) phase archive parameters)

        {.#Right default}
        ((as Handler default) phase archive parameters))
      ... (phase.except ..not_an_extension [name .Synthesis type])
      (|> parameters
          (monad.each phase.monad (phase archive))
          (phase#each (|>> [name] {/.#Extension}))))

    {try.#Failure error}
    (|> parameters
        (monad.each phase.monad (phase archive))
        (phase#each (|>> [name] {/.#Extension})))))

(def (optimization extender lux)
  (-> Extender Lux Phase)
  (function (phase archive analysis)
    (when analysis
      {///analysis.#Simple analysis'}
      (phase#in {/.#Simple (..simple analysis')})

      {///analysis.#Reference reference}
      (phase#in {/.#Reference reference})

      {///analysis.#Structure structure}
      (/.with_currying? false
        (when structure
          {///complex.#Variant variant}
          (phase#each
           (function (_ valueS)
             (/.variant (has ///complex.#value valueS variant)))
           (phase archive (the ///complex.#value variant)))

          {///complex.#Tuple tuple}
          (|> tuple
              (monad.each phase.monad (phase archive))
              (phase#each (|>> /.tuple)))))
      
      {///analysis.#When inputA branchesAB+}
      (/.with_currying? false
        (/when.synthesize phase branchesAB+ archive inputA))

      (///analysis.no_op value)
      (phase archive value)

      {///analysis.#Apply _}
      (/.with_currying? false
        (/function.apply phase archive analysis))

      {///analysis.#Function environmentA bodyA}
      (/function.abstraction phase environmentA archive bodyA)

      {///analysis.#Extension name parameters}
      (extension_application extender lux
                             phase archive
                             name parameters)
      )))

(def .public (phase extender lux archive analysis)
  (-> Extender Lux Phase)
  (do phase.monad
    [synthesis (..optimization extender lux archive analysis)]
    (phase.lifted (/variable.optimization synthesis))))
