(.require
 [library
  [lux (.except Synthesis)
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" try]
    ["[0]" exception (.only Exception)]]
   [data
    [text
     ["%" \\format]]]
   ["[0]" meta (.only)
    [macro
     ["^" pattern]]
    [target
     [jvm
      [bytecode (.only Bytecode)]]]
    [type
     ["[0]" check]]
    [compiler
     [meta
      ["[0]" archive (.only Archive)]
      ["[0]" cache
       [dependency
        ["[1]/[0]" artifact]]]]]]]]
 ["[0]" /
  [runtime (.only Operation Phase Handler)]
  ["[1][0]" primitive]
  ["[1][0]" structure]
  ["[1][0]" reference]
  ["[1][0]" function]
  ["[1][0]" when]
  ["[1][0]" loop]
  ["//[1]" ///
   ["[0]" extension]
   [//
    ["[0]" synthesis (.only Synthesis)]
    [///
     ["[0]" reference]
     ["[1]" phase (.use "[1]#[0]" monad)]]]]])

(exception.def .public (not_an_extension [name expected actual])
  (Exception [Symbol Type Type])
  (exception.report
   (list ["Name" (%.symbol name)]
         ["Expected" (%.type expected)]
         ["Actual" (%.type actual)])))

(exception.def .public (extension_error error)
  (Exception Text)
  error)

(def (extension_application extender lux
                            phase archive
                            name parameters)
  (-> extension.Extender Lux
      Phase Archive
      Symbol (List Synthesis)
      (Operation (Bytecode Any)))
  (when (|> (do [! meta.monad]
              [definition (meta.try (meta.export name))]
              (when definition
                {try.#Success [exported? type definition]}
                (in [type {.#Left definition}])
                
                {try.#Failure error}
                (do !
                  [[exported? type default] (meta.default name)]
                  (in [type {.#Right default}]))))
            (is (Meta [Type (Either Any Any)]))
            (meta.result lux))
    {try.#Success [type value]}
    (if (check.subsumes? .Generation type)
      (when value
        {.#Left definition}
        ((extender definition) phase archive parameters)

        {.#Right default}
        ((as Handler default) phase archive parameters))
      (///.except ..not_an_extension [name .Generation type]))

    {try.#Failure error}
    (///.except ..extension_error [error])))

(def .public (generate extender lux)
  (-> extension.Extender Lux Phase)
  (function (phase archive synthesis)
    (when synthesis
      (^.with_template [<tag> <generator>]
        [(<tag> value)
         (///#in (<generator> value))])
      ([synthesis.bit  /primitive.bit]
       [synthesis.i64  /primitive.i64]
       [synthesis.f64  /primitive.f64]
       [synthesis.text /primitive.text])

      (synthesis.variant variantS)
      (/structure.variant phase archive variantS)

      (synthesis.tuple members)
      (/structure.tuple phase archive members)

      {synthesis.#Reference reference}
      (when reference
        {reference.#Variable variable}
        (/reference.variable archive variable)
        
        {reference.#Constant constant}
        (/reference.constant archive constant))

      (synthesis.branch/when [valueS pathS])
      (/when.when phase archive [valueS pathS])

      (synthesis.branch/exec [this that])
      (/when.exec phase archive [this that])

      (synthesis.branch/let [inputS register bodyS])
      (/when.let phase archive [inputS register bodyS])

      (synthesis.branch/if [conditionS thenS elseS])
      (/when.if phase archive [conditionS thenS elseS])

      (synthesis.branch/get [path recordS])
      (/when.get phase archive [path recordS])

      (synthesis.loop/scope scope)
      (/loop.scope phase archive scope)

      (synthesis.loop/again updates)
      (/loop.again phase archive updates)

      (synthesis.function/abstraction abstraction)
      (/function.abstraction phase archive abstraction)

      (synthesis.function/apply application)
      (/function.apply phase archive application)

      {synthesis.#Extension [name parameters]}
      (extension_application extender lux phase archive name parameters)
      )))
