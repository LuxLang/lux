... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except #Function #Reification
                #locals #source
                i64 local
                let exec when its variant tuple
                if or and)
   [abstract
    [equivalence (.only Equivalence)]
    [hash (.only Hash)]
    ["[0]" monad (.only do)]]
   [control
    ["[0]" maybe]]
   [data
    ["[0]" sum]
    ["[0]" product]
    ["[0]" bit]
    ["[0]" text (.only)
     ["%" \\injection]]
    [collection
     ["[0]" list (.use "[1]#[0]" functor)]
     ["[0]" dictionary (.only Dictionary)]]]
   [math
    [number
     ["n" natural]
     ["i" integer]
     ["d" decimal]
     ["[0]" i64]]]
   [macro
    ["^" pattern]
    ["[0]" expansion]
    ["[0]" template]]]]
 ["[0]" /
  ["[1][0]" simple (.only Simple)]
  ["[1][0]" access (.only Access)
   ["[2][0]" side (.only Side)]
   ["[2][0]" member (.only Member)]]
  [//
   ["[0]" analysis (.only Environment)
    ["[1]/[0]" complex (.only Complex)]]
   ["[0]" phase (.only)
    ["[0]" extension (.only Extension)]]
   [///
    [arity (.only Arity)]
    ["[0]" reference (.only Reference)
     [register (.only Register)]
     ["[0]" variable (.only Variable)]]]]])

(every .public Resolver
  (Dictionary Variable Variable))

(every .public State
  (Record
   [#locals Natural
    ... https://en.wikipedia.org/wiki/Currying
    #currying? Bit]))

(the .public init
  State
  [#locals 0
   #currying? false])

(the .public fresh_resolver
  Resolver
  (dictionary.empty variable.hash))

(every .public (Road value next)
  (Record
   [#when value
    #then next]))

(every .public (Fork value next)
  [(Road value next)
   (List (Road value next))])

(every .public (Path' of)
  (Variant
   {#Pop}
   {#Bind Register}
   {#Access Access}
   {#Bit_Fork Bit (Path' of) (Maybe (Path' of))}
   {#I64_Fork (Fork I64 (Path' of))}
   {#F64_Fork (Fork F64 (Path' of))}
   {#Text_Fork (Fork Text (Path' of))}
   {#Seq (Path' of) (Path' of)}
   {#Alt (Path' of) (Path' of)}
   {#Then of}))

(every .public (Abstraction' of)
  (Record
   [#environment (Environment of)
    #arity Arity
    #body of]))

(every .public (Reification' of)
  (Record
   [#function of
    #arguments (List of)]))

(every .public (When of)
  (Record
   [#input of
    #output (Path' of)]))

(every .public (Tail_Recursion of)
  (Record
   [#start Register
    #inits (List of)
    #iteration of]))

(every .public (Loop of)
  (Variant
   {#Tail_Recursion (Tail_Recursion of)}
   {#Tail_Iteration (List of)}))

(every .public (Function of)
  (Variant
   {#Abstraction (Abstraction' of)}
   {#Reification (Reification' of)}))

(every .public (Control of)
  (Variant
   {#When (When of)}
   {#Loop (Loop of)}
   {#Function (Function of)}))

(expansion.let [@ ($ (Term' $))]
  (every .public (Term' $)
    (Variant
     {#Simple Simple}
     {#Structure (Complex @)}
     {#Reference Reference}
     {#Control (Control @)}
     {#Extension (Extension @)})))

(every .public Term
  (Annotated Provenance
             (Term' (Annotated Provenance))))

(every .public Operation
  (phase.Operation State))

(every .public Phase
  (phase.Phase State analysis.Term Term))

(template.with [<special> <general>]
  [(every .public <special>
     (<general> ..State analysis.Term Term))]

  [Handler  extension.Handler]
  [Bundle   extension.Bundle]
  [Extender extension.Extender]
  )

(every .public Path
  (Path' Term))

(the .public path/pop
  Path
  {#Pop})

(template.with [<name> <kind>]
  [(the .public <name>
     (template.macro (<name> content)
       [(.<| {..#Access}
             {<kind>}
             content)]))]

  [path/side   /access.#Side]
  [path/member /access.#Member]
  )

(template.with [<name> <access> <lefts> <right?>]
  [(the .public <name>
     (template.macro (<name> lefts right?)
       [(.<| {..#Access}
             {<access>}
             [<lefts> lefts
              <right?> right?])]))]

  [side /access.#Side /side.#lefts /side.#right?]
  [member /access.#Member /member.#lefts /member.#right?]
  )

(template.with [<access> <side> <name>]
  [(the .public <name>
     (template.macro (<name> lefts)
       [(<access> lefts <side>)]))]

  [..side #0 side/left]
  [..side #1 side/right]

  [..member #0 member/left]
  [..member #1 member/right]
  )

(template.with [<name> <tag>]
  [(the .public <name>
     (template.macro (<name> content)
       [{<tag> content}]))]

  [path/bind ..#Bind]
  [path/then ..#Then]
  )

(template.with [<name> <tag>]
  [(the .public <name>
     (template.macro (<name> left right)
       [{<tag> left right}]))]

  [path/alt  ..#Alt]
  [path/seq  ..#Seq]
  )

(every .public Abstraction
  (Abstraction' Term))

(every .public Reification
  (Reification' Term))

(the .public unit
  Text
  "")

(template.with [<with> <query> <tag> <type>]
  [(the .public (<with> value)
     (-> <type>
         (for_any (_ of)
           (-> (Operation of)
               (Operation of))))
     (phase.temporary (has <tag> value)))

   (the .public <query>
     (Operation <type>)
     (phase.read (.its <tag>)))]

  [with_locals    locals    #locals    Natural]
  [with_currying? currying? #currying? Bit]
  )

(the .public with_new_local
  (for_any (_ of)
    (-> (Operation of)
        (Operation of)))
  (<<| (do phase.monad
         [locals ..locals])
       (..with_locals (++ locals))))

(template.with [<name> <tag>]
  [(the .public <name>
     (template.macro (<name> <@> content)
       [[<@> {..#Simple {<tag> content}}]]))]

  [bit  /simple.#Bit]
  [i64  /simple.#I64]
  [f64  /simple.#F64]
  [text /simple.#Text]
  )

(template.with [<name> <tag>]
  [(the .public <name>
     (template.macro (<name> <@> content)
       [(.<| [<@>]
             {..#Structure}
             {<tag>}
             content)]))]

  [variant analysis/complex.#Variant]
  [tuple   analysis/complex.#Tuple]
  )

(template.with [<name> <tag>]
  [(the .public <name>
     (template.macro (<name> <@> content)
       [(.<| [<@>]
             {..#Reference}
             <tag>
             content)]))]

  [variable reference.variable]
  [constant reference.constant]
  [local    reference.local]
  [foreign  reference.foreign]
  )

(the .public when
  (template.macro (<name> <@> content)
    [(.<| [<@>]
          {..#Control}
          {..#When}
          content)]))

(template.with [<name> <family> <tag>]
  [(the .public <name>
     (template.macro (<name> <@> content)
       [(.<| [<@>]
             {..#Control}
             {<family>}
             {<tag>}
             content)]))]

  [tail_iteration ..#Loop ..#Tail_Iteration]
  [tail_recursion ..#Loop ..#Tail_Recursion]

  [abstraction ..#Function ..#Abstraction]
  [reification ..#Function ..#Reification]
  )

(the .public (%path' %then value)
  (for_any (_ of)
    (-> (text.Injection of)
        (text.Injection (Path' of))))
  (`` (.when value
        {#Pop}
        "_"

        {#Bit_Fork test then else}
        (%.message "(?"
                   " " (bit.as_text test) " " (%path' %then then)
                   (.when else
                     {.#Some else}
                     (%.message " " (bit.as_text (not test)) " " (%path' %then else))

                     {.#None}
                     "")
                   ")")
        
        (,, (template.with [<tag> <injection>]
              [{<tag> item}
               (|> {.#Item item}
                   (list#each (function (_ [test then])
                                (%.message (<injection> test) " " (%path' %then then))))
                   (text.interposed " ")
                   (text.enclosed ["(? " ")"]))]

              [#I64_Fork (|>> .integer %.integer)]
              [#F64_Fork %.decimal]
              [#Text_Fork %.text]))
        
        {#Access it}
        (/access.injection it)
        
        {#Bind register}
        (%.message "(@ " (%.natural register) ")")
        
        {#Alt left right}
        (%.message "(| " (%path' %then left) " " (%path' %then right) ")")
        
        {#Seq left right}
        (%.message "(& " (%path' %then left) " " (%path' %then right) ")")
        
        {#Then then}
        (|> (%then then)
            (text.enclosed ["(! " ")"])))))

(the .public (injection [_ value])
  (text.Injection Term)
  (.when value
    {#Simple it}
    (/simple.injection it)

    {#Structure structure}
    (.when structure
      {analysis/complex.#Variant [lefts right? content]}
      (|> (injection content)
          (%.message (%.natural lefts) " " (bit.as_text right?) " ")
          (text.enclosed ["{" "}"]))
      
      {analysis/complex.#Tuple members}
      (|> members
          (list#each injection)
          (text.interposed " ")
          (text.enclosed ["[" "]"])))

    {#Reference reference}
    (reference.injection reference)

    {#Control control}
    (.when control
      {#Function function}
      (.when function
        {#Abstraction [environment arity body]}
        (.let [environment' (|> environment
                                (list#each injection)
                                (text.interposed " ")
                                (text.enclosed ["[" "]"]))]
          (|> (%.message environment' " " (%.natural arity) " " (injection body))
              (text.enclosed ["{#function " "}"])))
        
        {#Reification func args}
        (|> args
            (list#each injection)
            (text.interposed " ")
            (%.message (injection func) " ")
            (text.enclosed ["(" ")"])))

      {#When input path}
      (|> (%.message (injection input) " " (%path' injection path))
          (text.enclosed ["{#when " "}"]))
      
      {#Loop loop}
      (.when loop
        {#Tail_Recursion tail_recursion}
        (|> (%.message (%.natural (.its #start tail_recursion))
                       " " (|> (.its #inits tail_recursion)
                               (list#each injection)
                               (text.interposed " ")
                               (text.enclosed ["[" "]"]))
                       " " (injection (.its #iteration tail_recursion)))
            (text.enclosed ["{#loop " "}"]))
        
        {#Tail_Iteration args}
        (|> args
            (list#each injection)
            (text.interposed " ")
            (text.enclosed ["{#tail_iteration " "}"]))))

    {#Extension [[_ name] args]}
    (|> (list#each injection args)
        (text.interposed " ")
        (%.message (%.text name) " ")
        (text.enclosed ["(" ")"]))))

(the .public %path
  (text.Injection Path)
  (%path' ..injection))

(the .public (path'_equivalence equivalence)
  (for_any (_ of)
    (-> (Equivalence of)
        (Equivalence (Path' of))))
  (implementation
   (the (= expected actual)
     (`` (.when [expected actual]
           [{#Pop} {#Pop}]
           true

           [{#Bit_Fork expected_when expected_then expected_else}
            {#Bit_Fork actual_when actual_then actual_else}]
           (.and (bit.= expected_when actual_when)
                 (= expected_then actual_then)
                 (by (maybe.equivalence =) = expected_else actual_else))

           (,, (template.with [<tag> <equivalence>]
                 [[{<tag> expected_item}
                   {<tag> actual_item}]
                  (by (list.equivalence (product.equivalence <equivalence> =)) =
                      {.#Item expected_item}
                      {.#Item actual_item})]

                 [#I64_Fork (is (Equivalence I64) i64.equivalence)]
                 [#F64_Fork d.equivalence]
                 [#Text_Fork text.equivalence]))
           
           (,, (template.with [<tag> <equivalence>]
                 [[{<tag> expected'} {<tag> actual'}]
                  (by <equivalence> = expected' actual')]

                 [#Access /access.equivalence]
                 [#Then   equivalence]))
           
           [{#Bind expected'} {#Bind actual'}]
           (n.= expected' actual')

           (,, (template.with [<tag>]
                 [[{<tag> leftR rightR} {<tag> leftS rightS}]
                  (.and (= leftR leftS)
                        (= rightR rightS))]

                 [#Alt]
                 [#Seq]))

           _
           false)))))

(the (path'_hash super)
  (for_any (_ of)
    (-> (Hash of)
        (Hash (Path' of))))
  (implementation
   (the equivalence
     (..path'_equivalence (by super equivalence)))
   
   (the (hash value)
     (`` (.when value
           {#Pop}
           2

           {#Access access}
           (n.* 3 (by /access.hash hash access))

           {#Bind register}
           (n.* 5 (by n.hash hash register))

           {#Bit_Fork when then else}
           (all n.* 7
                (by bit.hash hash when)
                (hash then)
                (by (maybe.hash (path'_hash super)) hash else))

           (,, (template.with [<factor> <tag> <hash>]
                 [{<tag> item}
                  (.let [when_hash (product.hash <hash>
                                                 (path'_hash super))
                         item_hash (product.hash when_hash (list.hash when_hash))]
                    (n.* <factor> (by item_hash hash item)))]

                 [11 #I64_Fork i64.hash]
                 [13 #F64_Fork d.hash]
                 [17 #Text_Fork text.hash]))

           (,, (template.with [<factor> <tag>]
                 [{<tag> fork}
                  (.let [again_hash (path'_hash super)
                         fork_hash (product.hash again_hash again_hash)]
                    (n.* <factor> (by fork_hash hash fork)))]

                 [19 #Alt]
                 [23 #Seq]))

           {#Then body}
           (n.* 29 (by super hash body))
           )))))

(the (when_equivalence (open "/#[0]"))
  (for_any (_ of)
    (-> (Equivalence of)
        (Equivalence (When of))))
  (implementation
   (the (= [expected_input expected_path] [actual_input actual_path])
     (.and (/#= expected_input actual_input)
           (by (path'_equivalence /#=) = expected_path actual_path)))))

(the (loop_equivalence (open "/#[0]"))
  (for_any (_ of)
    (-> (Equivalence of)
        (Equivalence (Loop of))))
  (implementation
   (the (= expected actual)
     (.when [expected actual]
       [{#Tail_Recursion [expected_start expected_inits expected_iteration]}
        {#Tail_Recursion [actual_start actual_inits actual_iteration]}]
       (.and (n.= expected_start actual_start)
             (by (list.equivalence /#=) = expected_inits actual_inits)
             (/#= expected_iteration actual_iteration))

       [{#Tail_Iteration expected} {#Tail_Iteration actual}]
       (by (list.equivalence /#=) = expected actual)
       
       _
       false))))

(the (loop_hash super)
  (for_any (_ of)
    (-> (Hash of)
        (Hash (Loop of))))
  (implementation
   (the equivalence
     (..loop_equivalence (by super equivalence)))
   
   (the (hash value)
     (.when value
       {#Tail_Recursion [start inits iteration]}
       (all n.* 2
            (by n.hash hash start)
            (by (list.hash super) hash inits)
            (by super hash iteration))

       {#Tail_Iteration resets}
       (all n.* 3
            (by (list.hash super) hash resets))
       ))))

(the (function_equivalence (open "/#[0]"))
  (for_any (_ of)
    (-> (Equivalence of)
        (Equivalence (Function of))))
  (implementation
   (the (= expected actual)
     (.when [expected actual]
       [{#Abstraction [expected_environment expected_arity expected_body]}
        {#Abstraction [actual_environment actual_arity actual_body]}]
       (.and (by (list.equivalence /#=) = expected_environment actual_environment)
             (n.= expected_arity actual_arity)
             (/#= expected_body actual_body))
       
       [{#Reification [expected_abstraction expected_arguments]}
        {#Reification [actual_abstraction actual_arguments]}]
       (.and (/#= expected_abstraction actual_abstraction)
             (by (list.equivalence /#=) = expected_arguments actual_arguments))
       
       _
       false))))

(the (function_hash super)
  (for_any (_ of)
    (-> (Hash of)
        (Hash (Function of))))
  (implementation
   (the equivalence
     (..function_equivalence (by super equivalence)))
   
   (the (hash value)
     (.when value
       {#Abstraction [environment arity body]}
       (all n.* 2
            (by (list.hash super) hash environment)
            (by n.hash hash arity)
            (by super hash body))
       
       {#Reification [abstraction arguments]}
       (all n.* 3
            (by super hash abstraction)
            (by (list.hash super) hash arguments))
       ))))

(the (control_equivalence (open "/#[0]"))
  (for_any (_ of)
    (-> (Equivalence of)
        (Equivalence (Control of))))
  (implementation
   (the (= expected actual)
     (`` (.when [expected actual]
           (,, (template.with [<tag> <equivalence>]
                 [[{<tag> expected} {<tag> actual}]
                  (by (<equivalence> /#=) = expected actual)]

                 [#When ..when_equivalence]
                 [#Loop ..loop_equivalence]
                 [#Function ..function_equivalence]))
           
           _
           false)))))

(the (control_hash super)
  (for_any (_ of)
    (-> (Hash of)
        (Hash (Control of))))
  (implementation
   (the equivalence
     (..control_equivalence (by super equivalence)))

   (the (hash value)
     (`` (.when value
           {#When [input path]}
           (all n.* 2
                (by super hash input)
                (by (..path'_hash super) hash path))
           
           (,, (template.with [<factor> <tag> <hash>]
                 [{<tag> value}
                  (n.* <factor> (by (<hash> super) hash value))]

                 [3 #Loop ..loop_hash]
                 [5 #Function ..function_hash]))
           )))))

(the .public equivalence
  (Equivalence Term)
  (implementation
   (the (= [_ expected] [_ actual])
     (`` (.when [expected actual]
           (,, (template.with [<tag> <equivalence>]
                 [[{<tag> expected'} {<tag> actual'}]
                  (by <equivalence> = expected' actual')]

                 [#Simple /simple.equivalence]
                 [#Structure (analysis/complex.equivalence =)]
                 [#Reference reference.equivalence]
                 [#Control (control_equivalence =)]
                 [#Extension (extension.equivalence =)]))

           _
           false)))))

(alias [=]
       ..equivalence)

(the .public path_equivalence
  (Equivalence Path)
  (path'_equivalence equivalence))

(the .public hash
  (Hash Term)
  (implementation
   (the equivalence ..equivalence)

   (the (hash value)
     (.let [again_hash [..equivalence hash]]
       (`` (.when value
             (,, (template.with [<factor> <tag> <hash>]
                   [[_ {<tag> value}]
                    (n.* <factor> (by <hash> hash value))]

                   [02 #Simple /simple.hash]
                   [03 #Structure (analysis/complex.hash again_hash)]
                   [05 #Reference reference.hash]
                   [07 #Control (..control_hash again_hash)]
                   [11 #Extension (extension.hash again_hash)]))))))))

(the .public !bind_top
  (template.macro (_ register thenP)
    [(all ..path/seq
          {..#Bind register}
          {..#Pop}
          thenP)]))

(the .public !multi_pop
  (template.macro (_ nextP)
    [(all ..path/seq
          {..#Pop}
          {..#Pop}
          nextP)]))

... TODO: There are sister patterns to the simple side checks for tuples.
... These correspond to the situation where tuple members are accessed
... and bound to variables, but those variables are never used, so they
... become POPs.
... After re-implementing unused-variable-elimination, must add those
... pattern-optimizations again, since a lot of BINDs will become POPs
... and thus will result in useless code being translated.
(template.with [<name> <side>]
  [(the .public <name>
     (template.macro (<name> idx nextP)
       [(all ..path/seq
             (<side> idx)
             {..#Pop}
             nextP)]))]

  [simple_left_side ..side/left]
  [simple_right_side ..side/right]
  )

(the Projection
  (type [Register Member]))

(every .public Multi_Let
  [Term
   (List Projection)
   Term])

(the .public (multi_let [input output])
  (-> (When Term)
      (Maybe Multi_Let))
  (loop (next [bindings (is (List Projection)
                            (list))
               output output])
    (.when output
      {#Seq {#Access {/access.#Member member}}
            {#Seq {#Bind register}
                  then}}
      (.let [bindings {.#Item [register member] bindings}]
        (.when then
          {#Seq {#Pop} then}
          (next bindings then)

          {#Then body}
          {.#Some [input (list.reversed bindings) body]}

          _
          {.#None}))

      _
      {.#None})))

(every .public If
  (Record
   [#if_when Term
    #if_then Term
    #if_else Term]))

(the .public (if [input output])
  (-> (When Term)
      (Maybe If))
  (.when output
    (^.or {#Bit_Fork .true {#Then then} {.#Some {#Then else}}}
          {#Bit_Fork .false {#Then else} {.#Some {#Then then}}})
    {.#Some [#if_when input
             #if_then then
             #if_else else]}

    _
    {.#None}))

(template.with [,name ,static ,value ,dynamic]
  [(the .public (,name it)
     (-> If
         (Maybe [Term Term]))
     (.when (.its ,static it)
       (..bit _ ,value)
       {.#Some [(.its ,dynamic it)
                (.its #if_when it)]}

       else
       {.#None}))]

  [or #if_then .true #if_else]
  [and #if_else .false #if_then]
  )

(template.with [,name ,type ,path]
  [(the .public (,name [input output])
     (-> (When Term)
         (Maybe [Term (List [,type Term]) Term]))
     (.when output
       {#Alt {,path head tail}
             {#Then else}}
       (do [! maybe.monad]
         [cases (monad.each ! (function (_ road)
                                (.when (.its #then road)
                                  {#Then then}
                                  {.#Some [(.its #when road) then]}

                                  _
                                  {.#None}))
                            (list.partial head tail))]
         (in [input cases else]))

       _
       {.#None}))]

  [when_i64 I64 #I64_Fork]
  [when_f64 F64 #F64_Fork]
  [when_text Text #Text_Fork]
  )

(the .public let
  (template.macro (_ ,@ ,register ,value ,body)
    [(<| [,@]
         {..#Control}
         {..#When}
         [..#input ,value
          ..#output]
         {..#Seq {..#Bind ,register}
                 {..#Then ,body}})]))

(every .public Let
  (Record
   [#let_binding Register
    #let_input Term
    #let_body Term]))

(the .public (flat_let body)
  (-> Term
      [(List [Register Term]) Term])
  (.when body
    (..let @ register value body)
    (.let [[tail body] (flat_let body)]
      [(list.partial [register value] tail) body])

    _
    [(list) body]))

(every .public Exec
  (Record
   [#exec_before Term
    #exec_after Term]))

(the .public exec
  (template.macro (_ ,@ ,before ,after)
    [(<| [,@]
         {..#Control}
         {..#When}
         [..#input ,before
          ..#output]
         {..#Then ,after})]))

(the .public (flat_exec after)
  (-> Term
      [(List Term) Term])
  (.when after
    (..exec @ before after)
    (.let [[tail after] (flat_exec after)]
      [(list.partial before tail) after])

    _
    [(list) after]))

(every .public Its
  (Record
   [#its_path (List Member)
    #its_source Term]))

(the .public (its [source pattern_matching])
  (-> (When Term)
      (Maybe Its))
  (loop (its [path (is (List Member)
                       (list))
              pattern_matching pattern_matching])
    (.when pattern_matching
      (<| {#Seq {#Access {/access.#Member member}}}
          {#Seq {#Pop}}
          tail)
      (its path tail)

      (<| {#Seq {#Access {/access.#Member member}}}
          {#Seq {#Bind expected}}
          {#Then (..local @ actual)})
      (.if (n.= expected actual)
        {.#Some [#its_path (list.reversed {.#Item member path})
                 #its_source source]}
        {.#None})

      (<| {#Seq {#Access {/access.#Member member}}}
          tail)
      (its {.#Item member path}
           tail)

      _
      {.#None})))
