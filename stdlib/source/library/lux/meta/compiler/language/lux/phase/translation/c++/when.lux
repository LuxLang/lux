... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except Type Label if let exec when int)
   [abstract
    ["[0]" monad (.only do)]]
   [control
    ["[0]" function]]
   [data
    [collection
     ["[0]" list (.use "[1]#[0]" mix)]]
    ["[0]" text (.use "[1]#[0]" equivalence)
     ["%" \\format (.only format)]]]
   [math
    [number
     ["n" nat]
     ["[0]" i32]]]
   [meta
    [macro
     ["^" pattern]]
    [compiler
     [target
      ["_" c++]]]]]]
 ["[0]" //
  ["[1][0]" type]
  ["[1][0]" reference]
  ["[1][0]" runtime (.only Operation Phase Term)]
  [////
   ["[0]" phase (.use "[1]#[0]" functor)]
   ["[0]" translation]
   ["[0]" synthesis (.only Path Fork)
    [access
     ["[0]" member (.only Member)]]]
   [///
    [reference
     [variable (.only Register)]]]]])

(type (If of)
  (Record
   [#when of
    #then of
    #else of]))

(def .public (if next archive it)
  (Term If)
  (do phase.monad
    [when (next archive (the #when it))
     then (next archive (the #then it))
     else (next archive (the #else it))]
    (in (_.? when then else))))

(type (Let of)
  (Record
   [#input of
    #register Register
    #body of]))

(def (sub_bindings body)
  (-> synthesis.Term
      [(List [Register synthesis.Term]) synthesis.Term])
  (.when body
    (synthesis.branch/let @ [input register body])
    (.let [[tail body] (sub_bindings body)]
      [(list.partial [register input] tail) body])

    _
    [(list) body]))

(def .public (let next archive it)
  (Term Let)
  (do [! phase.monad]
    [.let [[tail body] (sub_bindings (the #body it))
           head_binding (the #register it)]
     bindings (monad.each ! (function (_ [binding value])
                              (do !
                                [value (next archive value)]
                                (in (_.variable (//reference.local binding) //type.value value))))
                          (list.partial [head_binding (the #input it)]
                                        tail))
     body (next archive body)]
    (in (_.on (list)
              (_.lambda (.when head_binding
                          0 (list)
                          _ (list _.all_by_value))
                        (list)
                        {.#Some //type.value}
                        (list#mix _.then
                                  (_.return body)
                                  (list.reversed bindings))
                        )))))

(type (Exec of)
  (Record
   [#before of
    #after of]))

(def (sub_statements after)
  (-> synthesis.Term
      [(List synthesis.Term) synthesis.Term])
  (.when after
    (synthesis.branch/exec @ [before after])
    (.let [[tail after] (sub_statements after)]
      [(list.partial before tail) after])

    _
    [(list) after]))

(def .public (exec next archive it)
  (Term Exec)
  (do [! phase.monad]
    [.let [[tail after] (sub_statements (the #after it))]
     all_before (monad.each ! (|>> (next archive)
                                   (phase#each _.;))
                            (list.partial (the #before it) tail))
     after (next archive after)]
    (in (_.on (list)
              (_.lambda (list _.all_by_value)
                        (list)
                        {.#Some //type.value}
                        (list#mix _.then
                                  (_.return after)
                                  (list.reversed all_before)))))))
