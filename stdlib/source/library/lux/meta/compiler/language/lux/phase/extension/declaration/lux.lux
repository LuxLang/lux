(.require
 [library
  [lux (.except Synthesis)
   [abstract
    ["[0]" monad (.only do)]]
   [control
    [io (.only IO)]
    ["<>" parser]
    ["[0]" maybe (.use "[1]#[0]" functor)]
    ["[0]" try]
    ["[0]" exception (.only Exception)]]
   [data
    ["[0]" binary]
    ["[0]" product]
    ["[0]" text
     ["%" \\format (.only format)]]
    [collection
     ["[0]" dictionary]
     ["[0]" array]
     ["[0]" list (.use "[1]#[0]" functor mix)]
     ["[0]" set (.only Set)]]]
   [math
    [number
     ["n" nat]]]
   ["[0]" meta (.only)
    ["@" target]
    ["[0]" code
     ["<[1]>" \\parser (.only Parser)]]
    [macro
     ["^" pattern]]
    ["[0]" type (.only sharing) (.use "[1]#[0]" equivalence)
     ["[0]" check]]]]]
 ["[0]" /// (.only)
  ["[1][0]" analysis]
  ["/[1]" //
   ["/[1]" //
    ["[1][0]" analysis (.only)
     [macro (.only Expander)]
     ["[1]/[0]" evaluation]
     ["[0]A" type]
     ["[0]A" module]
     ["[0]" scope]]
    ["[1][0]" synthesis (.only Synthesis)]
    ["[1][0]" generation]
    ["[1][0]" declaration (.only Import Requirements Phase Operation Handler Extender Bundle)]
    [phase
     [extension
      ["[0]E" analysis
       ["[1]" lux]]]]
    ["[1][0]" program (.only Program)]
    [///
     ["[0]" phase]
     [meta
      ["[0]" archive (.only Archive)
       ["[0]" artifact]
       ["[0]" module]
       ["[0]" unit]]
      ["[0]" cache
       [dependency
        ["[1]/[0]" artifact]]]]]]]])

(def .public (custom [syntax handler])
  (All (_ anchor expression declaration s)
    (-> [(Parser s)
         (-> (Phase anchor expression declaration)
             Archive
             s
             (Operation anchor expression declaration Requirements))]
        (Handler anchor expression declaration)))
  (function (_ phase archive inputs)
    (when (<code>.result syntax inputs)
      {try.#Success inputs}
      (handler phase archive inputs)

      {try.#Failure error}
      (phase.failure error))))

(def (context [@module @artifact])
  (-> unit.ID unit.ID)
  ... TODO: Find a better way that doesn't rely on clever tricks.
  [@module (n.- (++ @artifact) 0)])

... TODO: Inline "evaluate!'" into "evaluate!" ASAP
(def (evaluate!' archive generation code//type codeS)
  (All (_ anchor expression declaration)
    (-> Archive
        (/////generation.Phase anchor expression declaration)
        Type
        Synthesis
        (Operation anchor expression declaration [Type expression Any])))
  (/////declaration.lifted_generation
   (do phase.monad
     [module /////generation.module
      id /////generation.next
      codeG (generation archive codeS)
      @module (/////generation.module_id module archive)
      codeV (/////generation.evaluate! (..context [@module id]) [{.#None} codeG])]
     (in [code//type codeG codeV]))))

(def .public (evaluate! archive type codeC)
  (All (_ anchor expression declaration)
    (-> Archive Type Code (Operation anchor expression declaration [Type expression Any])))
  (do phase.monad
    [state phase.state
     .let [analysis_state (the [/////declaration.#analysis /////declaration.#state] state)
           analysis (the [/////declaration.#analysis /////declaration.#phase] state)
           synthesis ((the [/////declaration.#synthesis /////declaration.#phase] state) analysis_state)
           generation ((the [/////declaration.#generation /////declaration.#phase] state) analysis_state)]
     [_ codeA] (<| /////declaration.lifted_analysis
                   scope.with
                   typeA.fresh
                   (typeA.expecting type)
                   (analysis archive codeC))
     codeS (/////declaration.lifted_synthesis
            (synthesis archive codeA))]
    (evaluate!' archive generation type codeS)))

... TODO: Inline "definition'" into "definition" ASAP
(def (definition' archive generation [module name] code//type codeS)
  (All (_ anchor expression declaration)
    (-> Archive
        (/////generation.Phase anchor expression declaration)
        Symbol
        Type
        Synthesis
        (Operation anchor expression declaration [Type expression Any])))
  (/////declaration.lifted_generation
   (do phase.monad
     [dependencies (cache/artifact.dependencies archive codeS)
      [interim_artifacts codeG] (/////generation.with_interim_artifacts archive
                                  (generation archive codeS))
      .let [@abstraction (when codeS
                           (/////synthesis.function/abstraction [env arity body])
                           (|> interim_artifacts
                               list.last
                               (maybe#each (|>> [arity])))

                           _
                           {.#None})]
      @module (phase.lifted (archive.id module archive))
      @self (/////generation.learn [name @abstraction] false (list#mix set.has dependencies interim_artifacts))
      [target_name value declaration] (/////generation.define! [@module @self] {.#None} [(maybe#each product.right @abstraction) codeG])
      _ (/////generation.save! @self {.#None} declaration)]
     (in [code//type codeG value]))))

(def (definition archive name expected codeC)
  (All (_ anchor expression declaration)
    (-> Archive Symbol (Maybe Type) Code
        (Operation anchor expression declaration [Type expression Any])))
  (do [! phase.monad]
    [state phase.state
     .let [analysis_state (the [/////declaration.#analysis /////declaration.#state] state)
           analysis (the [/////declaration.#analysis /////declaration.#phase] state)
           synthesis ((the [/////declaration.#synthesis /////declaration.#phase] state) analysis_state)
           generation ((the [/////declaration.#generation /////declaration.#phase] state) analysis_state)]
     [_ code//type codeA] (/////declaration.lifted_analysis
                           (scope.with
                             (typeA.fresh
                              (when expected
                                {.#None}
                                (do !
                                  [[code//type codeA] (typeA.inferring
                                                       (analysis archive codeC))
                                   code//type (typeA.check (check.clean (list) code//type))]
                                  (in [code//type codeA]))

                                {.#Some expected}
                                (do !
                                  [codeA (<| (typeA.expecting expected)
                                             (analysis archive codeC))]
                                  (in [expected codeA]))))))
     codeS (/////declaration.lifted_synthesis
            (synthesis archive codeA))]
    (definition' archive generation name code//type codeS)))

(with_template [<full> <partial> <learn>]
  [... TODO: Inline "<partial>" into "<full>" ASAP
   (def (<partial> archive generation extension codeT codeS)
     (All (_ anchor expression declaration)
       (-> Archive
           (/////generation.Phase anchor expression declaration)
           Text
           Type
           Synthesis
           (Operation anchor expression declaration [expression Any])))
     (do phase.monad
       [current_module (/////declaration.lifted_analysis meta.current_module_name)]
       (/////declaration.lifted_generation
        (do phase.monad
          [dependencies (cache/artifact.dependencies archive codeS)
           [interim_artifacts codeG] (/////generation.with_interim_artifacts archive
                                       (generation archive codeS))
           @module (phase.lifted (archive.id current_module archive))
           @self (<learn> extension (list#mix set.has dependencies interim_artifacts))
           [target_name value declaration] (/////generation.define! [@module @self] {.#None} [{.#None} codeG])
           _ (/////generation.save! @self {.#None} declaration)]
          (in [codeG value])))))

   (def .public (<full> archive extension codeT codeC)
     (All (_ anchor expression declaration)
       (-> Archive Text Type Code
           (Operation anchor expression declaration [expression Any])))
     (do phase.monad
       [state phase.state
        .let [analysis_state (the [/////declaration.#analysis /////declaration.#state] state)
              analysis (the [/////declaration.#analysis /////declaration.#phase] state)
              synthesis ((the [/////declaration.#synthesis /////declaration.#phase] state) analysis_state)
              generation ((the [/////declaration.#generation /////declaration.#phase] state) analysis_state)]
        [_ codeA] (<| /////declaration.lifted_analysis
                      scope.with
                      typeA.fresh
                      (typeA.expecting codeT)
                      (analysis archive codeC))
        codeS (/////declaration.lifted_synthesis
               (synthesis archive codeA))]
       (<partial> archive generation extension codeT codeS)))]

  [analyser analyser' /////generation.learn_analyser]
  [synthesizer synthesizer' /////generation.learn_synthesizer]
  [generator generator' /////generation.learn_generator]
  [declaration declaration' /////generation.learn_declaration]
  )

... TODO: Get rid of this function ASAP.
(def refresh
  (All (_ anchor expression declaration)
    (Operation anchor expression declaration Any))
  (do [! phase.monad]
    [state phase.state
     .let [eval (/////analysis/evaluation.evaluator (the [/////declaration.#analysis /////declaration.#phase] state)
                                                    [(the [/////declaration.#synthesis /////declaration.#state] state)
                                                     (the [/////declaration.#synthesis /////declaration.#phase] state)]
                                                    [(the [/////declaration.#generation /////declaration.#state] state)
                                                     (the [/////declaration.#generation /////declaration.#phase] state)])]
     _ (/////declaration.lifted_analysis
        (do !
          [_ (moduleA.override_definition [.prelude "is#"] {.#Default [true .Analysis (analysisE.is#_extension eval "is#")]})
           _ (moduleA.override_definition [.prelude "as#"] {.#Default [true .Analysis (analysisE.as#_extension eval "as#")]})]
          (in [])))]
    (in [])))

(def (announce_definition! short type)
  (All (_ anchor expression declaration)
    (-> Text Type (Operation anchor expression declaration Any)))
  (/////declaration.lifted_generation
   (/////generation.log! (format short " : " (%.type type)))))

(def lux::def
  Handler
  (..custom
   [(all <>.and <code>.local <code>.any <code>.any)
    (function (_ phase archive [short_name valueC exported?C])
      (do phase.monad
        [_ ..refresh
         current_module (/////declaration.lifted_analysis meta.current_module_name)
         .let [full_name [current_module short_name]]
         [type valueT value] (..definition archive full_name {.#None} valueC)
         [_ _ exported?] (evaluate! archive Bit exported?C)
         _ (/////declaration.lifted_analysis
            (moduleA.define short_name {.#Definition [(as Bit exported?) type value]}))
         _ (..announce_definition! short_name type)]
        (in /////declaration.no_requirements)))]))

(def imports
  (Parser (List Import))
  (|> (<code>.tuple (<>.and <code>.text <code>.text))
      <>.some
      <code>.tuple))

(def def_module
  Handler
  (..custom
   [..imports
    (function (_ phase archive imports)
      (do [! phase.monad]
        [_ (/////declaration.lifted_analysis
            (monad.each ! (function (_ [module alias])
                            (do !
                              [_ (moduleA.import module)]
                              (when alias
                                "" (in [])
                                _ (moduleA.alias alias module))))
                        imports))]
        (in [/////declaration.#imports imports
             /////declaration.#referrals (list)])))]))

(exception.def .public (cannot_alias_an_alias [local foreign target])
  (Exception [Alias Alias Symbol])
  (exception.report
   (list ["Local alias" (%.symbol local)]
         ["Foreign alias" (%.symbol foreign)]
         ["Target definition" (%.symbol target)])))

(def (define_alias alias original)
  (-> Text Symbol (/////analysis.Operation Any))
  (do phase.monad
    [current_module meta.current_module_name
     constant (meta.definition original)]
    (when constant
      {.#Alias de_aliased}
      (phase.except ..cannot_alias_an_alias [[current_module alias] original de_aliased])
      
      {.#Definition _}
      (moduleA.define alias {.#Alias original}))))

(def def_alias
  Handler
  (..custom
   [(all <>.and <code>.local <code>.symbol)
    (function (_ phase archive [alias def_name])
      (do phase.monad
        [_ (phase.sub [(the [/////declaration.#analysis /////declaration.#state])
                       (has [/////declaration.#analysis /////declaration.#state])]
                      (define_alias alias def_name))]
        (in /////declaration.no_requirements)))]))

... TODO: Stop requiring these types and the "swapped" function below to make types line-up.
(with_template [<name> <anonymous>]
  [(def <name>
     Type
     (with_expansions [<original> binary.Binary]
       (let [_ <original>]
         {.#Named (symbol <original>)
                  <anonymous>})))]

  [Binary|Python (Primitive "bytearray")]
  [Binary|DEFAULT (type_literal (array.Array (I64 Any)))]
  )

(def (swapped original replacement)
  (-> Type Type Type Type)
  (function (again type)
    (if (type#= original type)
      replacement
      (when type
        {.#Primitive name parameters}
        {.#Primitive name (list#each again parameters)}

        (^.with_template [<tag>]
          [{<tag> left right}
           {<tag> (again left) (again right)}])
        ([.#Sum]
         [.#Product]
         [.#Function]
         [.#Apply])
        
        (^.or {.#Parameter _}
              {.#Var _}
              {.#Ex _})
        type

        (^.with_template [<tag>]
          [{<tag> closure body}
           {<tag> closure (again body)}])
        ([.#UnivQ]
         [.#ExQ])
        
        {.#Named name anonymous}
        {.#Named name (again anonymous)}))))

(def .public bundle
  Bundle
  (|> ///.empty
      (dictionary.has "def#" lux::def)
      (dictionary.has "module#" def_module)
      (dictionary.has "alias#" def_alias)))
