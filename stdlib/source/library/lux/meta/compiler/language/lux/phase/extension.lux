(.require
 [library
  [lux (.except with)
   [abstract
    [equivalence (.only Equivalence)]
    [hash (.only Hash)]
    ["[0]" monad (.only do)]]
   [control
    ["[0]" function]
    ["[0]" try (.only Try)]
    ["[0]" exception (.only Exception)]]
   [data
    ["[0]" product]
    ["[0]" text (.use "[1]#[0]" order)
     ["%" \\format (.only Format format)]]
    [collection
     ["[0]" list]
     ["[0]" dictionary (.only Dictionary)]]]
   [meta
    [macro
     ["^" pattern]]]]]
 [/////
  ["//" phase]
  [meta
   [archive (.only Archive)]]])

(type .public Name
  Text)

(type .public (Extension a)
  [Name (List a)])

(def .public equivalence
  (All (_ a) (-> (Equivalence a) (Equivalence (Extension a))))
  (|>> list.equivalence
       (product.equivalence text.equivalence)))

(def .public hash
  (All (_ a) (-> (Hash a) (Hash (Extension a))))
  (|>> list.hash
       (product.hash text.hash)))

(type .public (Handler s i o)
  (-> Name
      (//.Phase s i o)
      (//.Phase s (List i) o)))

(type .public (Bundle s i o)
  (Dictionary Name (Handler s i o)))

(def .public empty
  Bundle
  (dictionary.empty text.hash))

(type .public (State s i o)
  s)

(type .public (Operation s i o v)
  (//.Operation (State s i o) v))

(type .public (Phase s i o)
  (//.Phase (State s i o) i o))

(exception.def .public (cannot_overwrite name)
  (Exception Name)
  (exception.report
   (list ["Extension" (%.text name)])))

(exception.def .public (incorrect_arity [name arity args])
  (Exception [Name Nat Nat])
  (exception.report
   (list ["Extension" (%.text name)]
         ["Expected" (%.nat arity)]
         ["Actual" (%.nat args)])))

(exception.def .public (invalid_syntax [name %format inputs])
  (All (_ a) (Exception [Name (Format a) (List a)]))
  (exception.report
   (list ["Extension" (%.text name)]
         ["Inputs" (exception.listing %format inputs)])))

(exception.def .public (unknown [name bundle])
  (All (_ s i o) (Exception [Name (Bundle s i o)]))
  (exception.report
   (list ["Extension" (%.text name)]
         ["Available" (|> bundle
                          dictionary.keys
                          (list.sorted text#<)
                          (exception.listing %.text))])))

(type .public (Extender s i o)
  (-> Any (Handler s i o)))

(def .public (localized get set transform)
  (All (_ s s' i o v)
    (-> (-> s s') (-> s' s s) (-> s' s')
        (-> (Operation s i o v) (Operation s i o v))))
  (function (_ operation)
    (function (_ state)
      (let [old (get state)]
        (when (operation (set (transform old) state))
          {try.#Success [state' output]}
          {try.#Success [(set old state') output]}

          failure
          failure)))))

(def .public (temporary transform)
  (All (_ s i o v)
    (-> (-> s s)
        (-> (Operation s i o v) (Operation s i o v))))
  (function (_ operation)
    (function (_ state)
      (when (operation (transform state))
        {try.#Success [state' output]}
        {try.#Success [state output]}

        failure
        failure))))

(def .public (with_state state)
  (All (_ s i o v)
    (-> s (-> (Operation s i o v) (Operation s i o v))))
  (..temporary (function.constant state)))

(def .public (read get)
  (All (_ s i o v)
    (-> (-> s v) (Operation s i o v)))
  (function (_ state)
    {try.#Success [state (get state)]}))

(def .public (update transform)
  (All (_ s i o)
    (-> (-> s s) (Operation s i o Any)))
  (function (_ state)
    {try.#Success [(transform state) []]}))

(def .public (lifted action)
  (All (_ s i o v)
    (-> (//.Operation s v) (Operation s i o v)))
  (function (_ state)
    (when (action state)
      {try.#Success [state' output]}
      {try.#Success [state' output]}

      {try.#Failure error}
      {try.#Failure error})))

(def .public (up it)
  (All (_ s i o v)
    (-> (Operation s i o v) (//.Operation s v)))
  (function (_ state)
    (when (it state)
      {try.#Success [state' output]}
      {try.#Success [state' output]}

      {try.#Failure error}
      {try.#Failure error})))
