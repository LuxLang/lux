... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except Type Module Declaration Integer Double
                #Default #Variable
                type)
   ["[0]" ffi (.only import)]
   [abstract
    ["[0]" monad (.only do)]]
   [control
    ["<>" projection]
    ["|" pipe]
    ["[0]" maybe]
    ["[0]" try (.only Try) (.use "[1]#[0]" monad)]
    ["[0]" exception]
    [function
     ["[0]" predicate]]]
   [data
    ["[0]" bit]
    ["[0]" product]
    [binary (.only Binary)
     ["[0]" \\injection]]
    ["[0]" text (.only)
     ["%" \\injection]
     ["<[1]>" \\projection]]
    [collection
     ["[0]" list (.use "[1]#[0]" mix monad monoid)]
     ["[0]" array]
     ["[0]" dictionary (.only Dictionary)]
     ["[0]" sequence]]]
   [math
    [number
     ["n" natural]
     ["[0]" i32]]]
   ["[0]" meta (.only)
    ["[0]" module]
    ["[0]" code (.only)
     ["<[1]>" \\projection (.only Projection)]]
    [macro
     ["^" pattern]
     ["[0]" template]]
    ["[0]" type (.only)
     ["[0]" check (.only Check) (.use "[1]#[0]" monad)]]
    [compiler
     [target
      ["[0]" jvm
       ["_" bytecode (.only Bytecode) (.use "[1]#[0]" monad)]
       ["[0]!" reflection]
       ["[0]" modifier (.only Modifier) (.use "[1]#[0]" monoid)]
       ["[0]" attribute]
       ["[0]" field]
       ["[0]" version]
       ["[0]" method]
       ["[0]" class]
       [constant
        ["[0]" pool (.only Resource)]]
       [encoding
        [name
         ["[0]" external]
         ["[0]" internal]]]
       ["[1]" type (.only Type Argument Typed)
        ["[0]" category (.only Void Value Return Primitive Object Class Array Var Parameter Method)]
        ["[0]" box]
        ["[0]" reflection]
        ["[0]" descriptor]
        ["[0]" signature]
        ["[0]" projection]
        ["[0]" alias (.only Aliasing)]
        ["[0]T" lux (.only Mapping)]]]]]]]]
 ["[0]" //
  ["[1][0]" lux (.only custom install)]
  ["/[1]" // (.only)
   ["/[1]" //
    [translation
     [jvm
      ["[0]" runtime]
      ["[0]" function
       ["[1]" abstract]]]]
    ["/[1]" //
     ["[0]" phase (.use "[1]#[0]" monad)]
     ["[0]" translation]
     ["[0]" declaration]
     ["[0]" analysis (.only Operation Phase Handler Bundle)
      ["[0]" complex]
      ["[0]" pattern]
      ["[0]" inference]
      ["[0]A" type]
      ["[0]" scope]]
     [///
      ["[0]" reference (.only)
       ["[0]" variable]]
      [meta
       [archive (.only Archive)
        [module
         [descriptor (.only Module)]]]]]]]]])

(import java/lang/ClassLoader
  "[1]::[0]")

(import java/lang/Object
  "[1]::[0]"
  (equals [java/lang/Object] boolean))

(import java/lang/reflect/Type
  "[1]::[0]")

(import (java/lang/reflect/TypeVariable d)
  "[1]::[0]"
  (getName [] java/lang/String)
  (getBounds [] [java/lang/reflect/Type]))

(import java/lang/reflect/Modifier
  "[1]::[0]"
  ("static" isStatic [int] boolean)
  ("static" isFinal [int] boolean)
  ("static" isInterface [int] boolean)
  ("static" isAbstract [int] boolean)
  ("static" isPublic [int] boolean)
  ("static" isProtected [int] boolean))

(import java/lang/annotation/Annotation
  "[1]::[0]")

(import java/lang/reflect/Method
  "[1]::[0]"
  (getName [] java/lang/String)
  (getModifiers [] int)
  (getDeclaringClass [] (java/lang/Class java/lang/Object))
  (getTypeParameters [] [(java/lang/reflect/TypeVariable java/lang/reflect/Method)])
  (getGenericParameterTypes [] [java/lang/reflect/Type])
  (getDeclaredAnnotations [] [java/lang/annotation/Annotation])
  
  (getReturnType [] (java/lang/Class java/lang/Object))
  (getGenericReturnType [] "?" java/lang/reflect/Type)
  
  (getExceptionTypes [] [(java/lang/Class java/lang/Object)])
  (getGenericExceptionTypes [] [java/lang/reflect/Type]))

(import (java/lang/reflect/Constructor c)
  "[1]::[0]"
  (getModifiers [] int)
  (getDeclaringClass [] (java/lang/Class c))
  (getTypeParameters [] [(java/lang/reflect/TypeVariable (java/lang/reflect/Constructor c))])
  (getGenericParameterTypes [] [java/lang/reflect/Type])
  (getExceptionTypes [] [(java/lang/Class java/lang/Object)])
  (getGenericExceptionTypes [] [java/lang/reflect/Type])
  (getDeclaredAnnotations [] [java/lang/annotation/Annotation]))

(import (java/lang/Class c)
  "[1]::[0]"
  ("static" forName [java/lang/String] "try" (java/lang/Class java/lang/Object))
  (getName [] java/lang/String)
  (getModifiers [] int)
  (isAssignableFrom [(java/lang/Class [? < java/lang/Object])] boolean)
  (getTypeParameters [] [(java/lang/reflect/TypeVariable (java/lang/Class c))])
  (getGenericInterfaces [] [java/lang/reflect/Type])
  (getGenericSuperclass [] "?" java/lang/reflect/Type)
  (getDeclaredField [java/lang/String] "try" java/lang/reflect/Field)
  (getConstructors [] [(java/lang/reflect/Constructor java/lang/Object)])
  (getDeclaredMethods [] [java/lang/reflect/Method])
  (getDeclaredAnnotations [] [java/lang/annotation/Annotation])
  (getSuperclass [] "?" (java/lang/Class java/lang/Object))
  (getInterfaces [] [(java/lang/Class java/lang/Object)]))

(template.with [<name>]
  [(exception.the .public (<name> [class field])
     (exception.Exception [external.Name Text])
     (exception.report
      (list ["Class" (%.text class)]
            ["Field" (%.text field)])))]

  [cannot_set_a_final_field]
  [deprecated_field]
  )

(exception.the .public (deprecated_method [class method type])
  (exception.Exception [external.Name Text .Type])
  (exception.report
   (list ["Class" (%.text class)]
         ["Method" (%.text method)]
         ["Type" (type.as_text type)])))

(exception.the .public (deprecated_class class)
  (exception.Exception external.Name)
  (exception.report
   (list ["Class" (%.text class)])))

(the (ensure_fresh_class! class_loader name)
  (-> java/lang/ClassLoader external.Name
      (Operation Any))
  (do phase.monad
    [class (phase.of_try (reflection!.load class_loader name))]
    (phase.assertion ..deprecated_class [name]
                     (|> class
                         (java/lang/Class::getDeclaredAnnotations [])
                         reflection!.deprecated?
                         not))))

(the reflection
  (for_any (_ category)
    (-> (Type (Value category))
        Text))
  (|>> jvm.reflection
       reflection.reflection))

(the signature
  (for_any (_ of)
    (-> (Type of)
        Text))
  (|>> jvm.signature
       signature.signature))

(the object_class
  external.Name
  "java.lang.Object")

... TODO: Get rid of this template.with block and use the definition in
... lux/ffi.jvm.lux ASAP
(template.with [<name> <class>]
  [(the .public <name>
     .Type
     {.#Nominal <class> {.#End}})]

  ... Boxes
  [Boolean   box.boolean]
  [Byte      box.byte]
  [Short     box.short]
  [Integer   box.int]
  [Long      box.long]
  [Float     box.float]
  [Double    box.double]
  [Character box.char]
  [String    "java.lang.String"]

  ... Primitives
  [boolean   (reflection.reflection reflection.boolean)]
  [byte      (reflection.reflection reflection.byte)]
  [short     (reflection.reflection reflection.short)]
  [int       (reflection.reflection reflection.int)]
  [long      (reflection.reflection reflection.long)]
  [float     (reflection.reflection reflection.float)]
  [double    (reflection.reflection reflection.double)]
  [char      (reflection.reflection reflection.char)]
  )

(.every Member
  (Record
   [#class external.Name
    #member Text]))

(the member
  (Projection Member)
  (all <>.and <code>.text <code>.text))

(.every Method_Signature
  (Record
   [#method .Type
    #inputs (List (Type Value))
    #output (Type Return)
    #deprecated? Bit
    #throws (List .Type)]))

(template.with [<name>]
  [(exception.the .public (<name> type)
     (exception.Exception .Type)
     (exception.report
      (list ["Type" (type.as_text type)])))]

  [non_object]
  [non_array]
  [non_parameter]
  [non_jvm_type]
  )

(template.with [<name>]
  [(exception.the .public (<name> class)
     (exception.Exception external.Name)
     (exception.report
      (list ["Class/type" (%.text class)])))]

  [non_interface]
  [non_throwable]
  [primitives_are_not_objects]
  )

(the (method_signature_injection it)
  (text.Injection Method_Signature)
  (exception.report
   (list ["Type" (type.as_text (its #method it))]
         ["Arguments" (exception.listing jvm.as_text (its #inputs it))]
         ["Return" (jvm.as_text (its #output it))]
         ["Deprecated?" (bit.as_text (its #deprecated? it))]
         ["Throws" (exception.listing type.as_text (its #throws it))])))

(template.with [<name>]
  [(exception.the .public (<name> [class_variables class method method_variables inputsJT hints])
     (exception.Exception [(List (Type Var))
                           external.Name
                           Text
                           (List (Type Var))
                           (List (Type Value))
                           (List Method_Signature)])
     (exception.report
      (list ["Class variables" (exception.listing ..signature class_variables)]
            ["Class" class]
            ["Method" method]
            ["Method variables" (exception.listing ..signature method_variables)]
            ["Arguments" (exception.listing ..signature inputsJT)]
            ["Hints" (exception.listing ..method_signature_injection hints)])))]

  [no_candidates]
  [too_many_candidates]
  )

(exception.the .public (cannot_cast [module from to value])
  (exception.Exception [Text (Type Value) (Type Value) Code])
  (exception.report
   (list ["From" (..signature from)]
         ["To" (..signature to)]
         ["Value" (code.relative module value)])))

(template.with [<name>]
  [(exception.the .public (<name> message)
     (exception.Exception Text)
     message)]

  [primitives_cannot_have_type_parameters]
  [cannot_possibly_be_an_instance]
  [unknown_type_var]
  )

(the with_conversion_extensions
  (-> Bundle
      Bundle)
  (|>> (install "jvm_conversion_double_to_float#" (//lux.unary ..double ..float))
       (install "jvm_conversion_double_to_int#" (//lux.unary ..double ..int))
       (install "jvm_conversion_double_to_long#" (//lux.unary ..double ..long))
       (install "jvm_conversion_float_to_double#" (//lux.unary ..float ..double))
       (install "jvm_conversion_float_to_int#" (//lux.unary ..float ..int))
       (install "jvm_conversion_float_to_long#" (//lux.unary ..float ..long))
       (install "jvm_conversion_int_to_byte#" (//lux.unary ..int ..byte))
       (install "jvm_conversion_int_to_char#" (//lux.unary ..int ..char))
       (install "jvm_conversion_int_to_double#" (//lux.unary ..int ..double))
       (install "jvm_conversion_int_to_float#" (//lux.unary ..int ..float))
       (install "jvm_conversion_int_to_long#" (//lux.unary ..int ..long))
       (install "jvm_conversion_int_to_short#" (//lux.unary ..int ..short))
       (install "jvm_conversion_long_to_double#" (//lux.unary ..long ..double))
       (install "jvm_conversion_long_to_float#" (//lux.unary ..long ..float))
       (install "jvm_conversion_long_to_int#" (//lux.unary ..long ..int))
       (install "jvm_conversion_long_to_short#" (//lux.unary ..long ..short))
       (install "jvm_conversion_long_to_byte#" (//lux.unary ..long ..byte))
       (install "jvm_conversion_char_to_byte#" (//lux.unary ..char ..byte))
       (install "jvm_conversion_char_to_short#" (//lux.unary ..char ..short))
       (install "jvm_conversion_char_to_int#" (//lux.unary ..char ..int))
       (install "jvm_conversion_char_to_long#" (//lux.unary ..char ..long))
       (install "jvm_conversion_byte_to_long#" (//lux.unary ..byte ..long))
       (install "jvm_conversion_short_to_long#" (//lux.unary ..short ..long))
       ))

(template.with [<name> <prefix> <type>]
  [(the <name>
     (-> Bundle
         Bundle)
     (let [type (reflection.reflection <prefix>)]
       (|>> (install (%.message "jvm_" type "_" "+" "#") (//lux.binary <type> <type> <type>))
            (install (%.message "jvm_" type "_" "-" "#") (//lux.binary <type> <type> <type>))
            (install (%.message "jvm_" type "_" "*" "#") (//lux.binary <type> <type> <type>))
            (install (%.message "jvm_" type "_" "/" "#") (//lux.binary <type> <type> <type>))
            (install (%.message "jvm_" type "_" "%" "#") (//lux.binary <type> <type> <type>))
            (install (%.message "jvm_" type "_" "=" "#") (//lux.binary <type> <type> Bit))
            (install (%.message "jvm_" type "_" "<" "#") (//lux.binary <type> <type> Bit))
            (install (%.message "jvm_" type "_" "and" "#") (//lux.binary <type> <type> <type>))
            (install (%.message "jvm_" type "_" "or" "#") (//lux.binary <type> <type> <type>))
            (install (%.message "jvm_" type "_" "xor" "#") (//lux.binary <type> <type> <type>))
            (install (%.message "jvm_" type "_" "shl" "#") (//lux.binary ..int <type> <type>))
            (install (%.message "jvm_" type "_" "shr" "#") (//lux.binary ..int <type> <type>))
            (install (%.message "jvm_" type "_" "ushr" "#") (//lux.binary ..int <type> <type>))
            )))]

  [with_int_extensions  reflection.int  ..int]
  [with_long_extensions reflection.long ..long]
  )

(template.with [<name> <prefix> <type>]
  [(the <name>
     (-> Bundle
         Bundle)
     (let [type (reflection.reflection <prefix>)]
       (|>> (install (%.message "jvm_" type "_" "+" "#") (//lux.binary <type> <type> <type>))
            (install (%.message "jvm_" type "_" "-" "#") (//lux.binary <type> <type> <type>))
            (install (%.message "jvm_" type "_" "*" "#") (//lux.binary <type> <type> <type>))
            (install (%.message "jvm_" type "_" "/" "#") (//lux.binary <type> <type> <type>))
            (install (%.message "jvm_" type "_" "%" "#") (//lux.binary <type> <type> <type>))
            (install (%.message "jvm_" type "_" "=" "#") (//lux.binary <type> <type> Bit))
            (install (%.message "jvm_" type "_" "<" "#") (//lux.binary <type> <type> Bit))
            )))]

  [with_float_extensions  reflection.float  ..float]
  [with_double_extensions reflection.double ..double]
  )

(the with_char_extensions
  (-> Bundle
      Bundle)
  (let [type (reflection.reflection reflection.char)]
    (|>> (install (%.message "jvm_" type "_" "=" "#") (//lux.binary ..char ..char Bit))
         (install (%.message "jvm_" type "_" "<" "#") (//lux.binary ..char ..char Bit))
         )))

(the .public boxes
  (Dictionary external.Name [external.Name (Type Primitive)])
  (|> (list [(reflection.reflection reflection.boolean) [box.boolean jvm.boolean]]
            [(reflection.reflection reflection.byte)    [box.byte jvm.byte]]
            [(reflection.reflection reflection.short)   [box.short jvm.short]]
            [(reflection.reflection reflection.int)     [box.int jvm.int]]
            [(reflection.reflection reflection.long)    [box.long jvm.long]]
            [(reflection.reflection reflection.float)   [box.float jvm.float]]
            [(reflection.reflection reflection.double)  [box.double jvm.double]]
            [(reflection.reflection reflection.char)    [box.char jvm.char]])
      (dictionary.of_list text.hash)))

(the lux_array_type
  (template.macro (_ :read: :write:)
    [{.#Nominal array.nominal (list {.#Reification :write: {.#Reification :read: _Mutable}})}]))

(the (jvm_type luxT)
  (-> .Type (Operation (Type Value)))
  (when luxT
    {.#Named name anonymousT}
    (jvm_type anonymousT)
    
    {.#Reification inputT abstractionT}
    (when (type.applied (list inputT) abstractionT)
      {.#Some outputT}
      (jvm_type outputT)

      {.#None}
      (analysis.except ..non_jvm_type luxT))

    (lux_array_type elemT _)
    (phase#each jvm.array (jvm_type elemT))

    {.#Nominal class parametersT}
    (when (dictionary.value class ..boxes)
      {try.#Success [_ primitive_type]}
      (when parametersT
        {.#End}
        (phase#in primitive_type)

        _
        (analysis.except ..primitives_cannot_have_type_parameters class))

      {try.#Failure _}
      (do [! phase.monad]
        [parametersJT (is (Operation (List (Type Parameter)))
                          (monad.each !
                                      (function (_ parameterT)
                                        (do phase.monad
                                          [parameterJT (jvm_type parameterT)]
                                          (when (projection.parameter? parameterJT)
                                            {.#Some parameterJT}
                                            (in parameterJT)
                                            
                                            {.#None}
                                            (analysis.except ..non_parameter parameterT))))
                                      parametersT))]
        (in (jvm.class parametersJT class))))

    {.#Opaque _}
    (phase#in (jvm.class (list) ..object_class))

    {.#Function _}
    (phase#in function.class)
    
    _
    (analysis.except ..non_jvm_type luxT)))

(the (jvm_array_type objectT)
  (-> .Type
      (Operation (Type Array)))
  (do phase.monad
    [objectJ (jvm_type objectT)]
    (|> objectJ
        ..signature
        (<text>.value projection.array)
        phase.of_try)))

(the (primitive_array_length_handler primitive_type)
  (-> (Type Primitive)
      (-> Text Handler))
  (..custom
   [<code>.any
    (function (_ extension_name analyse archive [arrayC])
      (do phase.monad
        [_ (typeA.inference ..int)
         arrayA (<| (typeA.expecting {.#Nominal (|> (jvm.array primitive_type)
                                                    ..reflection)
                                                (list)})
                    (analyse archive arrayC))
         @ meta.provenance]
        (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                    (list arrayA)}])))]))

(the array::length::object
  (-> Text Handler)
  (..custom
   [<code>.any
    (function (_ extension_name analyse archive [arrayC])
      (<| typeA.with_var
          (function (_ [@read :read:]))
          typeA.with_var
          (function (_ [@write :write:]))
          (do phase.monad
            [_ (typeA.inference ..int)
             arrayA (<| (typeA.expecting (.type (array.Array' :read: :write:)))
                        (analyse archive arrayC))
             :read: (typeA.check (check.clean (list) :read:))
             :write: (typeA.check (check.clean (list) :write:))
             arrayJT (jvm_array_type (.type (array.Array' :read: :write:)))
             @ meta.provenance]
            (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                        (list (analysis.text @ (..signature arrayJT))
                                              arrayA)}]))))]))

(the (new_primitive_array_handler primitive_type)
  (-> (Type Primitive)
      (-> Text Handler))
  (..custom
   [<code>.any
    (function (_ extension_name analyse archive [lengthC])
      (do phase.monad
        [lengthA (<| (typeA.expecting ..int)
                     (analyse archive lengthC))
         _ (typeA.inference {.#Nominal (|> (jvm.array primitive_type) ..reflection)
                                       (list)})
         @ meta.provenance]
        (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                    (list lengthA)}])))]))

(the array::new::object
  (-> Text Handler)
  (..custom
   [<code>.any
    (function (_ extension_name analyse archive [lengthC])
      (do phase.monad
        [lengthA (<| (typeA.expecting ..int)
                     (analyse archive lengthC))
         expectedT meta.expected_type
         expectedJT (jvm_array_type expectedT)
         elementJT (when (projection.array? expectedJT)
                     {.#Some elementJT}
                     (in elementJT)
                     
                     {.#None}
                     (analysis.except ..non_array expectedT))
         @ meta.provenance]
        (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                    (list (analysis.text @ (..signature elementJT))
                                          lengthA)}])))]))

(the (check_parameter objectT)
  (-> .Type
      (Operation (Type Parameter)))
  (`` (when objectT
        (lux_array_type elementT _)
        (analysis.except ..non_parameter objectT)
        
        {.#Nominal name parameters}
        (`` (if (or (,, (template.with [<type>]
                          [(text.= (..reflection <type>) name)]

                          [jvm.boolean]
                          [jvm.byte]
                          [jvm.short]
                          [jvm.int]
                          [jvm.long]
                          [jvm.float]
                          [jvm.double]
                          [jvm.char]))
                    (text.starts_with? descriptor.array_prefix name))
              (analysis.except ..non_parameter objectT)

              ... else
              (phase#in (jvm.class (list) name))))

        {.#Named name anonymous}
        (check_parameter anonymous)

        {.#Variable @var}
        (do phase.monad
          [:var: (phase.try (typeA.check (check.type @var)))]
          (when :var:
            {try.#Success :var:}
            (check_parameter :var:)
            
            un_bound!
            (in (jvm.class (list) ..object_class))))

        (^.or {.#Opaque id}
              {.#Parameter id})
        (phase#in (jvm.class (list) ..object_class))

        (,, (template.with [<tag>]
              [{<tag> env unquantified}
               (check_parameter unquantified)]

              [.#Universal]
              [.#Existential]))

        {.#Reification inputT abstractionT}
        (when (type.applied (list inputT) abstractionT)
          {.#Some outputT}
          (check_parameter outputT)

          {.#None}
          (analysis.except ..non_parameter objectT))

        {.#Function _}
        (phase#in function.class)

        _
        (analysis.except ..non_parameter objectT))))

(the (check_jvm objectT)
  (-> .Type
      (Operation (Type Value)))
  (`` (when objectT
        {.#Nominal name {.#End}}
        (`` (if (,, (template.with [<type>]
                      [(text.= (..reflection <type>) name)
                       (phase#in <type>)]

                      [jvm.boolean]
                      [jvm.byte]
                      [jvm.short]
                      [jvm.int]
                      [jvm.long]
                      [jvm.float]
                      [jvm.double]
                      [jvm.char]))

              (,, (template.with [<type>]
                    [(text.= (..reflection (jvm.array <type>)) name)
                     (phase#in (jvm.array <type>))]

                    [jvm.boolean]
                    [jvm.byte]
                    [jvm.short]
                    [jvm.int]
                    [jvm.long]
                    [jvm.float]
                    [jvm.double]
                    [jvm.char]))

              (text.starts_with? descriptor.array_prefix name)
              (let [[_ unprefixed] (maybe.trusted (text.split_by descriptor.array_prefix name))]
                (by phase.monad each jvm.array
                    (check_jvm {.#Nominal unprefixed (list)})))

              ... else
              (phase#in (jvm.class (list) name))))

        (lux_array_type elementT _)
        (|> elementT
            check_jvm
            (phase#each jvm.array))
        
        {.#Nominal name parameters}
        (do [! phase.monad]
          [parameters (monad.each ! check_parameter parameters)]
          (phase#in (jvm.class parameters name)))

        {.#Named name anonymous}
        (check_jvm anonymous)

        (,, (template.with [<tag>]
              [{<tag> env unquantified}
               (check_jvm unquantified)]

              [.#Universal]
              [.#Existential]))

        {.#Reification inputT abstractionT}
        (when (type.applied (list inputT) abstractionT)
          {.#Some outputT}
          (check_jvm outputT)

          {.#None}
          (analysis.except ..non_object objectT))

        _
        (check_parameter objectT))))

(template.with [<name> <category> <projection>]
  [(the .public (<name> mapping typeJ)
     (-> Mapping (Type <category>)
         (Operation .Type))
     (when (|> typeJ ..signature (<text>.value (<projection> mapping)))
       {try.#Success check}
       (typeA.check check)
       
       {try.#Failure error}
       (phase.failure error)))]

  [boxed_reflection_type Value luxT.boxed_type]
  [reflection_type Value luxT.type]
  [boxed_reflection_return Return luxT.boxed_return]
  [reflection_return Return luxT.return]
  )

(the (check_object objectT)
  (-> .Type
      (Operation [external.Name .Type]))
  (do [! phase.monad]
    [:object: (check_jvm objectT)
     .let [name (..reflection :object:)]]
    (if (dictionary.key? ..boxes name)
      (analysis.except ..primitives_are_not_objects [name])
      (do !
        [:object: (reflection_type luxT.fresh :object:)]
        (phase#in [name :object:])))))

(the (check_return type)
  (-> .Type
      (Operation (Type Return)))
  (if (same? .Any type)
    (phase#in jvm.void)
    (check_jvm type)))

(the (read_primitive_array_handler lux_type jvm_type)
  (-> .Type (Type Primitive)
      (-> Text Handler))
  (..custom
   [(<>.and <code>.any <code>.any)
    (function (_ extension_name analyse archive [idxC arrayC])
      (do phase.monad
        [_ (typeA.inference lux_type)
         idxA (<| (typeA.expecting ..int)
                  (analyse archive idxC))
         arrayA (<| (typeA.expecting {.#Nominal (|> (jvm.array jvm_type) ..reflection)
                                                (list)})
                    (analyse archive arrayC))
         @ meta.provenance]
        (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                    (list idxA arrayA)}])))]))

(the array::read::object
  (-> Text Handler)
  (..custom
   [(<>.and <code>.any <code>.any)
    (function (_ extension_name analyse archive [idxC arrayC])
      (<| typeA.with_var
          (function (_ [@read :read:]))
          typeA.with_var
          (function (_ [@write :write:]))
          (do phase.monad
            [_ (typeA.inference :read:)
             arrayA (<| (typeA.expecting (.type (array.Array' :read: :write:)))
                        (analyse archive arrayC))
             idxA (<| (typeA.expecting ..int)
                      (analyse archive idxC))
             :read: (typeA.check (check.clean (list) :read:))
             :write: (typeA.check (check.clean (list) :write:))
             arrayJT (jvm_array_type (.type (array.Array' :read: :write:)))
             @ meta.provenance]
            (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                        (list (analysis.text @ (..signature arrayJT))
                                              idxA
                                              arrayA)}]))))]))

(the (write_primitive_array_handler lux_type jvm_type)
  (-> .Type (Type Primitive)
      (-> Text Handler))
  (let [array_type {.#Nominal (|> (jvm.array jvm_type) ..reflection)
                              (list)}]
    (..custom
     [(all <>.and <code>.any <code>.any <code>.any)
      (function (_ extension_name analyse archive [idxC valueC arrayC])
        (do phase.monad
          [_ (typeA.inference array_type)
           idxA (<| (typeA.expecting ..int)
                    (analyse archive idxC))
           valueA (<| (typeA.expecting lux_type)
                      (analyse archive valueC))
           arrayA (<| (typeA.expecting array_type)
                      (analyse archive arrayC))
           @ meta.provenance]
          (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                      (list idxA
                                            valueA
                                            arrayA)}])))])))

(the array::write::object
  (-> Text Handler)
  (..custom
   [(all <>.and <code>.any <code>.any <code>.any)
    (function (_ extension_name analyse archive [idxC valueC arrayC])
      (<| typeA.with_var
          (function (_ [@read :read:]))
          typeA.with_var
          (function (_ [@write :write:]))
          (do phase.monad
            [_ (typeA.inference (.type (array.Array' :read: :write:)))
             arrayA (<| (typeA.expecting (.type (array.Array' :read: :write:)))
                        (analyse archive arrayC))
             idxA (<| (typeA.expecting ..int)
                      (analyse archive idxC))
             valueA (<| (typeA.expecting :write:)
                        (analyse archive valueC))
             :read: (typeA.check (check.clean (list) :read:))
             :write: (typeA.check (check.clean (list) :write:))
             arrayJT (jvm_array_type (.type (array.Array' :read: :write:)))
             @ meta.provenance]
            (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                        (list (analysis.text @ (..signature arrayJT))
                                              idxA
                                              valueA
                                              arrayA)}]))))]))

(the with_array_extensions
  (-> Bundle
      Bundle)
  (|>> (install (%.message "jvm_" "array_" "length_" (reflection.reflection reflection.boolean) "#") (primitive_array_length_handler jvm.boolean))
       (install (%.message "jvm_" "array_" "length_" (reflection.reflection reflection.byte) "#") (primitive_array_length_handler jvm.byte))
       (install (%.message "jvm_" "array_" "length_" (reflection.reflection reflection.short) "#") (primitive_array_length_handler jvm.short))
       (install (%.message "jvm_" "array_" "length_" (reflection.reflection reflection.int) "#") (primitive_array_length_handler jvm.int))
       (install (%.message "jvm_" "array_" "length_" (reflection.reflection reflection.long) "#") (primitive_array_length_handler jvm.long))
       (install (%.message "jvm_" "array_" "length_" (reflection.reflection reflection.float) "#") (primitive_array_length_handler jvm.float))
       (install (%.message "jvm_" "array_" "length_" (reflection.reflection reflection.double) "#") (primitive_array_length_handler jvm.double))
       (install (%.message "jvm_" "array_" "length_" (reflection.reflection reflection.char) "#") (primitive_array_length_handler jvm.char))
       (install (%.message "jvm_" "array_" "length_" "object" "#") array::length::object)

       (install (%.message "jvm_" "array_" "new_" (reflection.reflection reflection.boolean) "#") (new_primitive_array_handler jvm.boolean))
       (install (%.message "jvm_" "array_" "new_" (reflection.reflection reflection.byte) "#") (new_primitive_array_handler jvm.byte))
       (install (%.message "jvm_" "array_" "new_" (reflection.reflection reflection.short) "#") (new_primitive_array_handler jvm.short))
       (install (%.message "jvm_" "array_" "new_" (reflection.reflection reflection.int) "#") (new_primitive_array_handler jvm.int))
       (install (%.message "jvm_" "array_" "new_" (reflection.reflection reflection.long) "#") (new_primitive_array_handler jvm.long))
       (install (%.message "jvm_" "array_" "new_" (reflection.reflection reflection.float) "#") (new_primitive_array_handler jvm.float))
       (install (%.message "jvm_" "array_" "new_" (reflection.reflection reflection.double) "#") (new_primitive_array_handler jvm.double))
       (install (%.message "jvm_" "array_" "new_" (reflection.reflection reflection.char) "#") (new_primitive_array_handler jvm.char))
       (install (%.message "jvm_" "array_" "new_" "object" "#") array::new::object)

       (install (%.message "jvm_" "array_" "read_" (reflection.reflection reflection.boolean) "#") (read_primitive_array_handler ..boolean jvm.boolean))
       (install (%.message "jvm_" "array_" "read_" (reflection.reflection reflection.byte) "#") (read_primitive_array_handler ..byte jvm.byte))
       (install (%.message "jvm_" "array_" "read_" (reflection.reflection reflection.short) "#") (read_primitive_array_handler ..short jvm.short))
       (install (%.message "jvm_" "array_" "read_" (reflection.reflection reflection.int) "#") (read_primitive_array_handler ..int jvm.int))
       (install (%.message "jvm_" "array_" "read_" (reflection.reflection reflection.long) "#") (read_primitive_array_handler ..long jvm.long))
       (install (%.message "jvm_" "array_" "read_" (reflection.reflection reflection.float) "#") (read_primitive_array_handler ..float jvm.float))
       (install (%.message "jvm_" "array_" "read_" (reflection.reflection reflection.double) "#") (read_primitive_array_handler ..double jvm.double))
       (install (%.message "jvm_" "array_" "read_" (reflection.reflection reflection.char) "#") (read_primitive_array_handler ..char jvm.char))
       (install (%.message "jvm_" "array_" "read_" "object" "#") array::read::object)

       (install (%.message "jvm_" "array_" "write_" (reflection.reflection reflection.boolean) "#") (write_primitive_array_handler ..boolean jvm.boolean))
       (install (%.message "jvm_" "array_" "write_" (reflection.reflection reflection.byte) "#") (write_primitive_array_handler ..byte jvm.byte))
       (install (%.message "jvm_" "array_" "write_" (reflection.reflection reflection.short) "#") (write_primitive_array_handler ..short jvm.short))
       (install (%.message "jvm_" "array_" "write_" (reflection.reflection reflection.int) "#") (write_primitive_array_handler ..int jvm.int))
       (install (%.message "jvm_" "array_" "write_" (reflection.reflection reflection.long) "#") (write_primitive_array_handler ..long jvm.long))
       (install (%.message "jvm_" "array_" "write_" (reflection.reflection reflection.float) "#") (write_primitive_array_handler ..float jvm.float))
       (install (%.message "jvm_" "array_" "write_" (reflection.reflection reflection.double) "#") (write_primitive_array_handler ..double jvm.double))
       (install (%.message "jvm_" "array_" "write_" (reflection.reflection reflection.char) "#") (write_primitive_array_handler ..char jvm.char))
       (install (%.message "jvm_" "array_" "write_" "object" "#") array::write::object)
       ))

(the object::null
  (-> Text Handler)
  (..custom
   [<code>.end
    (function (_ extension_name analyse archive [])
      (do phase.monad
        [expectedT meta.expected_type
         [_ :object:] (check_object expectedT)
         _ (typeA.inference :object:)
         @ meta.provenance]
        (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                    (list)}])))]))

(the object::null?
  (-> Text Handler)
  (..custom
   [<code>.any
    (function (_ extension_name analyse archive [objectC])
      (do phase.monad
        [_ (typeA.inference .Bit)
         [objectT objectA] (typeA.inferring
                            (analyse archive objectC))
         _ (check_object objectT)
         @ meta.provenance]
        (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                    (list objectA)}])))]))

(the object::synchronized
  (-> Text Handler)
  (..custom
   [(<>.and <code>.any <code>.any)
    (function (_ extension_name analyse archive [monitorC exprC])
      (do phase.monad
        [[monitorT monitorA] (typeA.inferring
                              (analyse archive monitorC))
         _ (check_object monitorT)
         exprA (analyse archive exprC)
         @ meta.provenance]
        (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                    (list monitorA exprA)}])))]))

(the (object::throw class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [<code>.any
    (function (_ extension_name analyse archive [exceptionC])
      (do phase.monad
        [_ (typeA.inference Nothing)
         [exceptionT exceptionA] (typeA.inferring
                                  (analyse archive exceptionC))
         [exception_class _] (check_object exceptionT)
         ? (phase.of_try (reflection!.sub? class_loader "java.lang.Throwable" exception_class))
         _ (is (Operation Any)
               (if ?
                 (in [])
                 (analysis.except non_throwable exception_class)))
         @ meta.provenance]
        (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                    (list exceptionA)}])))]))

(the (object::class class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [<code>.text
    (function (_ extension_name analyse archive [class])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         _ (typeA.inference {.#Nominal "java.lang.Class" (list {.#Nominal class (list)})})
         _ (phase.of_try (reflection!.load class_loader class))
         @ meta.provenance]
        (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                    (list (analysis.text @ class))}])))]))

(the (object::instance? class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [(all <>.and <code>.text <code>.any)
    (function (_ extension_name analyse archive [sub_class objectC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader sub_class)
         _ (typeA.inference Bit)
         [objectT objectA] (typeA.inferring
                            (analyse archive objectC))
         [object_class _] (check_object objectT)
         ? (phase.of_try (reflection!.sub? class_loader object_class sub_class))
         @ meta.provenance]
        (if ?
          (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                      (list (analysis.text @ sub_class) objectA)}])
          (analysis.except cannot_possibly_be_an_instance (%.message sub_class " !<= "  object_class)))))]))

(the (class_candidate_parents class_loader from_name fromT to_name to_class)
  (-> java/lang/ClassLoader external.Name .Type external.Name (java/lang/Class java/lang/Object)
      (Operation (List [[Text .Type] Bit])))
  (do [! phase.monad]
    [from_class (phase.of_try (reflection!.load class_loader from_name))
     mapping (phase.of_try (reflection!.correspond from_class fromT))]
    (monad.each !
                (function (_ superJT)
                  (do !
                    [superJT (phase.of_try (reflection!.type superJT))
                     .let [super_name (..reflection superJT)]
                     super_class (phase.of_try (reflection!.load class_loader super_name))
                     superT (reflection_type mapping superJT)]
                    (in [[super_name superT]
                         (ffi.of_boolean (java/lang/Class::isAssignableFrom [super_class] to_class))])))
                (when (java/lang/Class::getGenericSuperclass [] from_class)
                  {.#Some super}
                  (list.partial super (array.list {.#None} (java/lang/Class::getGenericInterfaces [] from_class)))

                  {.#None}
                  (if (|> from_class
                          (java/lang/Class::getModifiers [])
                          [] java/lang/reflect/Modifier::isInterface
                          ffi.of_boolean)
                    {.#Item (as java/lang/reflect/Type (ffi.class_for java/lang/Object))
                            (array.list {.#None} (java/lang/Class::getGenericInterfaces [] from_class))}
                    (array.list {.#None} (java/lang/Class::getGenericInterfaces [] from_class)))))))

(the (object::cast class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [<code>.any
    (function (_ extension_name analyse archive [fromC])
      (do [! phase.monad]
        [toT meta.expected_type
         toJT (check_jvm toT)
         [fromT fromA] (typeA.inferring
                        (analyse archive fromC))
         fromJT (check_jvm fromT)
         .let [from_name (..reflection fromJT)
               to_name (..reflection toJT)]
         can_cast? (is (Operation Bit)
                       (`` (if (,, (template.with [<primitive> <object>]
                                     [(let [=primitive (reflection.reflection <primitive>)]
                                        (or (and (text.= =primitive from_name)
                                                 (or (text.= <object> to_name)
                                                     (text.= =primitive to_name)))
                                            (and (text.= <object> from_name)
                                                 (text.= =primitive to_name))))
                                      (in true)]

                                     [reflection.boolean box.boolean]
                                     [reflection.byte    box.byte]
                                     [reflection.short   box.short]
                                     [reflection.int     box.int]
                                     [reflection.long    box.long]
                                     [reflection.float   box.float]
                                     [reflection.double  box.double]
                                     [reflection.char    box.char]))

                             ... else
                             (do !
                               [_ (phase.assertion ..primitives_are_not_objects [from_name]
                                                   (not (dictionary.key? ..boxes from_name)))
                                _ (phase.assertion ..primitives_are_not_objects [to_name]
                                                   (not (dictionary.key? ..boxes to_name)))
                                to_class (phase.of_try (reflection!.load class_loader to_name))
                                from_class (phase.of_try (reflection!.load class_loader from_name))]
                               (if (ffi.of_boolean (java/lang/Class::isAssignableFrom [from_class] to_class))
                                 (loop (again [[current_name currentT] [from_name fromT]])
                                   (if (text.= to_name current_name)
                                     (in true)
                                     (do !
                                       [candidate_parents (is (Operation (List [[Text .Type] Bit]))
                                                              (class_candidate_parents class_loader current_name currentT to_name to_class))]
                                       (when (|> candidate_parents
                                                 (list.only product.right)
                                                 (list#each product.left))
                                         {.#Item [next_name nextT] _}
                                         (again [next_name nextT])

                                         {.#End}
                                         (in false)))))
                                 (in (when [(type.= java/lang/Object fromT)
                                            (projection.array? toJT)]
                                       [.true {.#Some _}]
                                       true
                                       
                                       _
                                       false)))))))
         @ meta.provenance]
        (if can_cast?
          (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                      (list (analysis.text @ from_name)
                                            (analysis.text @ to_name)
                                            fromA)}])
          (do !
            [[here _] module.current]
            (analysis.except ..cannot_cast [here fromJT toJT fromC])))))]))

(the (with_object_extensions class_loader)
  (-> java/lang/ClassLoader
      (-> Bundle Bundle))
  (|>> (install (%.message "jvm_" "object_" "null" "#") object::null)
       (install (%.message "jvm_" "object_" "null?" "#") object::null?)
       (install (%.message "jvm_" "object_" "synchronized" "#") object::synchronized)
       (install (%.message "jvm_" "object_" "throw" "#") (object::throw class_loader))
       (install (%.message "jvm_" "object_" "class" "#") (object::class class_loader))
       (install (%.message "jvm_" "object_" "instance?" "#") (object::instance? class_loader))
       (install (%.message "jvm_" "object_" "cast" "#") (object::cast class_loader))
       ))

(the (get::static class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [..member
    (function (_ extension_name analyse archive [class field])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         [final? deprecated? fieldJT] (phase.of_try
                                       (do try.monad
                                         [class (reflection!.load class_loader class)]
                                         (reflection!.static_field field class)))
         _ (phase.assertion ..deprecated_field [class field]
                            (not deprecated?))
         fieldT (reflection_type luxT.fresh fieldJT)
         _ (typeA.inference fieldT)
         @ meta.provenance]
        (in (<| [@] {analysis.#Extension [.prelude (%.message extension_name "|translation")]}
                (list (analysis.text @ class)
                      (analysis.text @ field)
                      (analysis.text @ (..signature fieldJT)))))))]))

(the (put::static class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [(all <>.and ..member <code>.any)
    (function (_ extension_name analyse archive [[class field] valueC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         _ (typeA.inference Any)
         [final? deprecated? fieldJT] (phase.of_try
                                       (do try.monad
                                         [class (reflection!.load class_loader class)]
                                         (reflection!.static_field field class)))
         _ (phase.assertion ..deprecated_field [class field]
                            (not deprecated?))
         ... _ (phase.assertion ..cannot_set_a_final_field [class field]
         ...                    (not final?))
         fieldT (reflection_type luxT.fresh fieldJT)
         valueA (<| (typeA.expecting fieldT)
                    (analyse archive valueC))
         @ meta.provenance]
        (in (<| [@] {analysis.#Extension [.prelude (%.message extension_name "|translation")]}
                (list (analysis.text @ class)
                      (analysis.text @ field)
                      (analysis.text @ (..signature fieldJT))
                      valueA)))))]))

(the (get::virtual class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [(all <>.and ..member <code>.any)
    (function (_ extension_name analyse archive [[class field] objectC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         [objectT objectA] (typeA.inferring
                            (analyse archive objectC))
         [deprecated? mapping fieldJT] (phase.of_try
                                        (do try.monad
                                          [class (reflection!.load class_loader class)
                                           [final? deprecated? fieldJT] (reflection!.virtual_field field class)
                                           mapping (reflection!.correspond class objectT)]
                                          (in [deprecated? mapping fieldJT])))
         _ (phase.assertion ..deprecated_field [class field]
                            (not deprecated?))
         fieldT (reflection_type mapping fieldJT)
         _ (typeA.inference fieldT)
         @ meta.provenance]
        (in (<| [@] {analysis.#Extension [.prelude (%.message extension_name "|translation")]}
                (list (analysis.text @ class)
                      (analysis.text @ field)
                      (analysis.text @ (..signature fieldJT))
                      objectA)))))]))

(the (put::virtual class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [(all <>.and ..member <code>.any <code>.any)
    (function (_ extension_name analyse archive [[class field] valueC objectC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         [objectT objectA] (typeA.inferring
                            (analyse archive objectC))
         _ (typeA.inference objectT)
         [final? deprecated? mapping fieldJT] (phase.of_try
                                               (do try.monad
                                                 [class (reflection!.load class_loader class)
                                                  [final? deprecated? fieldJT] (reflection!.virtual_field field class)
                                                  mapping (reflection!.correspond class objectT)]
                                                 (in [final? deprecated? mapping fieldJT])))
         _ (phase.assertion ..deprecated_field [class field]
                            (not deprecated?))
         _ (phase.assertion ..cannot_set_a_final_field [class field]
                            (not final?))
         fieldT (reflection_type mapping fieldJT)
         valueA (<| (typeA.expecting fieldT)
                    (analyse archive valueC))
         @ meta.provenance]
        (in (<| [@] {analysis.#Extension [.prelude (%.message extension_name "|translation")]}
                (list (analysis.text @ class)
                      (analysis.text @ field)
                      (analysis.text @ (..signature fieldJT))
                      valueA
                      objectA)))))]))

(.every Method_Style
  (Variant
   {#Static}
   {#Abstract}
   {#Virtual}
   {#Special}
   {#Interface}))

(the (de_aliased aliasing)
  (-> Aliasing (Type Value)
      (Type Value))
  (function (again it)
    (`` (<| (when (projection.var? it)
              {.#Some name}
              (|> aliasing
                  (dictionary.value name)
                  (try#each jvm.var)
                  (try.else it))
              
              {.#None})
            (when (projection.class? it)
              {.#Some [parameters name]}
              (|> parameters
                  (list#each (|>> again (as (Type Parameter))))
                  (|.let parameters (jvm.class parameters name)))
              
              {.#None})
            (,, (template.with [<read> <as> <write>]
                  [(when (<read> it)
                     {.#Some :sub:}
                     (<write> (as (Type <as>) (again :sub:)))
                     
                     {.#None})]

                  [projection.array? Value jvm.array]
                  [projection.lower? Class jvm.lower]
                  [projection.upper? Class jvm.upper]
                  ))
            it))))

(the (check_method aliasing class method_name method_style inputsJT method)
  (-> Aliasing (java/lang/Class java/lang/Object) Text Method_Style (List (Type Value)) java/lang/reflect/Method
      (Operation Bit))
  (do phase.monad
    [parameters (|> method
                    (java/lang/reflect/Method::getGenericParameterTypes [])
                    (array.list {.#None})
                    (monad.each try.monad reflection!.type)
                    phase.of_try)
     .let [modifiers (java/lang/reflect/Method::getModifiers [] method)
           correct_class? (|> method
                              (java/lang/reflect/Method::getDeclaringClass [])
                              (java/lang/Class::isAssignableFrom [class])
                              ffi.of_boolean)
           correct_method? (|> method
                               (java/lang/reflect/Method::getName [])
                               ffi.of_string
                               (text.= method_name))
           same_static? (when method_style
                          {#Static}
                          (ffi.of_boolean (java/lang/reflect/Modifier::isStatic [modifiers]))

                          _
                          true)
           same_special? (when method_style
                           {#Special}
                           (not (or (ffi.of_boolean (java/lang/reflect/Modifier::isInterface [(java/lang/Class::getModifiers [] class)]))
                                    (ffi.of_boolean (java/lang/reflect/Modifier::isAbstract [modifiers]))))

                           _
                           true)
           same_inputs? (and (n.= (list.size inputsJT)
                                  (list.size parameters))
                             (list.every? (function (_ [expectedJC actualJC])
                                            (jvm.= expectedJC (de_aliased aliasing actualJC)))
                                          (list.zipped_2 parameters inputsJT)))]]
    (in (and correct_class?
             correct_method?
             same_static?
             same_special?
             same_inputs?))))

(the (check_constructor aliasing class inputsJT constructor)
  (-> Aliasing (java/lang/Class java/lang/Object) (List (Type Value)) (java/lang/reflect/Constructor java/lang/Object)
      (Operation Bit))
  (do phase.monad
    [parameters (|> constructor
                    (java/lang/reflect/Constructor::getGenericParameterTypes [])
                    (array.list {.#None})
                    (monad.each try.monad reflection!.type)
                    phase.of_try)]
    (in (and (ffi.of_boolean (|> constructor
                                 (java/lang/reflect/Constructor::getDeclaringClass [])
                                 (java/lang/Object::equals [class])))
             (n.= (list.size inputsJT) (list.size parameters))
             (list.every? (function (_ [expectedJC actualJC])
                            (jvm.= expectedJC (de_aliased aliasing actualJC)))
                          (list.zipped_2 parameters inputsJT))))))

(the index_parameter
  (-> Natural
      .Type)
  (|>> (n.* 2)
       ++
       {.#Parameter}))

(the (jvm_type_var_mapping owner_tvars method_tvars)
  (-> (List Text) (List Text)
      [(List .Type) Mapping])
  (let [jvm_tvars (list#composite owner_tvars method_tvars)
        lux_tvars (|> jvm_tvars
                      list.reversed
                      list.enumeration
                      (list#each (function (_ [idx name])
                                   [name (index_parameter idx)]))
                      list.reversed)
        num_owner_tvars (list.size owner_tvars)
        owner_tvarsT (|> lux_tvars (list.first num_owner_tvars) (list#each product.right))
        mapping (dictionary.of_list text.hash lux_tvars)]
    [owner_tvarsT mapping]))

(the (lux_class it)
  (-> (java/lang/Class java/lang/Object)
      (Type Class))
  (jvm.class (list) (ffi.of_string (java/lang/Class::getName [] it))))

(template.with [<name> <type> <params>]
  [(`` (the <name>
         (-> (<type> (,, (template.spliced <params>)))
             (List (Type Class)))
         (|>> ((,, (template.name [<type> "::getExceptionTypes"])) [])
              (array.list {.#None})
              (list#each ..lux_class))))]

  [concrete_method_exceptions java/lang/reflect/Method []]
  [concrete_constructor_exceptions java/lang/reflect/Constructor [java/lang/Object]]
  )

(the (return_type it)
  (-> java/lang/reflect/Method
      (Try (Type Return)))
  (reflection!.return
   (when (java/lang/reflect/Method::getGenericReturnType [] it)
     {.#Some it}
     it
     
     {.#None}
     (|> it
         (java/lang/reflect/Method::getReturnType [])
         (ffi.is java/lang/reflect/Type)))))

(the (method_signature method_style method)
  (-> Method_Style java/lang/reflect/Method
      (Operation Method_Signature))
  (let [owner (java/lang/reflect/Method::getDeclaringClass [] method)
        owner_tvars (when method_style
                      {#Static}
                      (list)

                      _
                      (|> owner
                          (java/lang/Class::getTypeParameters [])
                          (array.list {.#None})
                          (list#each (|>> (java/lang/reflect/TypeVariable::getName [])
                                          ffi.of_string))))
        method_tvars (|> method
                         (java/lang/reflect/Method::getTypeParameters [])
                         (array.list {.#None})
                         (list#each (|>> (java/lang/reflect/TypeVariable::getName [])
                                         ffi.of_string)))
        [owner_tvarsT mapping] (jvm_type_var_mapping owner_tvars method_tvars)]
    (do [! phase.monad]
      [inputsT' (|> method
                    (java/lang/reflect/Method::getGenericParameterTypes [])
                    (array.list {.#None})
                    (monad.each ! (|>> reflection!.type phase.of_try)))
       inputsT (monad.each ! (..reflection_type mapping) inputsT')
       outputT' (|> method
                    ..return_type
                    phase.of_try)
       outputT (..reflection_return mapping outputT')
       .let [concrete_exceptions (..concrete_method_exceptions method)]
       concrete_exceptions (monad.each ! (..reflection_type mapping) concrete_exceptions)
       generic_exceptions (|> method
                              (java/lang/reflect/Method::getGenericExceptionTypes [])
                              (array.list {.#None})
                              (monad.each ! (|>> reflection!.type phase.of_try))
                              (phase#each (monad.each ! (..reflection_type mapping)))
                              phase#conjoint)
       .let [methodT (<| (type.univ_q (dictionary.size mapping))
                         (type.function (when method_style
                                          {#Static}
                                          inputsT

                                          _
                                          (list.partial {.#Nominal (ffi.of_string (java/lang/Class::getName [] owner))
                                                                   owner_tvarsT}
                                                        inputsT)))
                         outputT)]]
      (in [#method methodT
           #inputs inputsT'
           #output outputT'
           #deprecated? (|> method
                            (java/lang/reflect/Method::getDeclaredAnnotations [])
                            reflection!.deprecated?)
           #throws (if (list.empty? generic_exceptions)
                     concrete_exceptions
                     generic_exceptions)]))))

(the (constructor_signature constructor)
  (-> (java/lang/reflect/Constructor java/lang/Object)
      (Operation Method_Signature))
  (let [owner (java/lang/reflect/Constructor::getDeclaringClass [] constructor)
        owner_tvars (|> owner
                        (java/lang/Class::getTypeParameters [])
                        (array.list {.#None})
                        (list#each (|>> (java/lang/reflect/TypeVariable::getName [])
                                        ffi.of_string)))
        method_tvars (|> constructor
                         (java/lang/reflect/Constructor::getTypeParameters [])
                         (array.list {.#None})
                         (list#each (|>> (java/lang/reflect/TypeVariable::getName [])
                                         ffi.of_string)))
        [owner_tvarsT mapping] (jvm_type_var_mapping owner_tvars method_tvars)]
    (do [! phase.monad]
      [inputsT' (|> constructor
                    (java/lang/reflect/Constructor::getGenericParameterTypes [])
                    (array.list {.#None})
                    (monad.each ! (|>> reflection!.type phase.of_try)))
       inputsT (monad.each ! (reflection_type mapping) inputsT')
       .let [concrete_exceptions (..concrete_constructor_exceptions constructor)]
       concrete_exceptions (monad.each ! (..reflection_type mapping) concrete_exceptions)
       generic_exceptions (|> constructor
                              (java/lang/reflect/Constructor::getGenericExceptionTypes [])
                              (array.list {.#None})
                              (monad.each ! (|>> reflection!.type phase.of_try))
                              (phase#each (monad.each ! (reflection_type mapping)))
                              phase#conjoint)
       .let [objectT {.#Nominal (ffi.of_string (java/lang/Class::getName [] owner))
                                owner_tvarsT}
             constructorT (<| (type.univ_q (dictionary.size mapping))
                              (type.function inputsT)
                              objectT)]]
      (in [#method constructorT
           #inputs inputsT'
           #output jvm.void
           #deprecated? (|> constructor
                            (java/lang/reflect/Constructor::getDeclaredAnnotations [])
                            reflection!.deprecated?)
           #throws (if (list.empty? generic_exceptions)
                     concrete_exceptions
                     generic_exceptions)]))))

(.every Evaluation
  (Variant
   {#Pass Method_Signature}
   {#Hint Method_Signature}))

(template.with [<name> <tag>]
  [(the <name>
     (-> Evaluation
         (Maybe Method_Signature))
     (|>> (|.when
            {<tag> output}
            {.#Some output}

            _
            {.#None})))]

  [pass #Pass]
  [hint #Hint]
  )

(template.with [<name> <type> <method>]
  [(the <name>
     (-> <type>
         (List (Type Var)))
     (|>> (<method> [])
          (array.list {.#None})
          (list#each (|>> (java/lang/reflect/TypeVariable::getName [])
                          ffi.of_string
                          jvm.var))))]

  [class_type_variables (java/lang/Class java/lang/Object) java/lang/Class::getTypeParameters]
  [constructor_type_variables (java/lang/reflect/Constructor java/lang/Object) java/lang/reflect/Constructor::getTypeParameters]
  [method_type_variables java/lang/reflect/Method java/lang/reflect/Method::getTypeParameters]
  )

(the (aliasing expected actual)
  (-> (List (Type Var)) (List (Type Var))
      Aliasing)
  (|> (list.zipped_2 (list#each projection.name actual)
                     (list#each projection.name expected))
      (dictionary.of_list text.hash)))

(the (family_tree' it)
  (-> (java/lang/Class java/lang/Object)
      (List (java/lang/Class java/lang/Object)))
  (let [interfaces (array.list {.#None} (java/lang/Class::getInterfaces [] it))
        supers (when (java/lang/Class::getSuperclass [] it)
                 {.#Some class}
                 (list.partial class interfaces)
                 
                 {.#None}
                 interfaces)]
    (|> supers
        (list#each family_tree')
        list#conjoint
        (list.partial it))))

(the family_tree
  (-> (java/lang/Class java/lang/Object)
      (List (java/lang/Class java/lang/Object)))
  (|>> ..family_tree'
       ... De-duplication
       (list#mix (function (_ class all)
                   (dictionary.has (ffi.of_string (java/lang/Class::getName [] class)) class all))
                 (dictionary.empty text.hash))
       dictionary.values))

(the (all_declared_methods it)
  (-> (java/lang/Class java/lang/Object)
      (List java/lang/reflect/Method))
  (|> it
      ..family_tree
      (list#each (|>> (java/lang/Class::getDeclaredMethods [])
                      (array.list {.#None})))
      list#conjoint))

(the (method_candidate allow_inheritance? class_loader actual_class_tvars class_name actual_method_tvars method_name method_style inputsJT)
  (-> Bit java/lang/ClassLoader (List (Type Var)) external.Name (List (Type Var)) Text Method_Style (List (Type Value))
      (Operation Method_Signature))
  (do [! phase.monad]
    [class (phase.of_try (reflection!.load class_loader class_name))
     .let [expected_class_tvars (class_type_variables class)]
     candidates (|> (if allow_inheritance?
                      (all_declared_methods class)
                      (array.list {.#None} (java/lang/Class::getDeclaredMethods [] class)))
                    (list.only (|>> (java/lang/reflect/Method::getName [])
                                    ffi.of_string
                                    (text.= method_name)))
                    (monad.each ! (is (-> java/lang/reflect/Method (Operation Evaluation))
                                      (function (_ method)
                                        (do !
                                          [.let [expected_method_tvars (method_type_variables method)
                                                 aliasing (dictionary.composite (..aliasing expected_class_tvars actual_class_tvars)
                                                                                (..aliasing expected_method_tvars actual_method_tvars))]
                                           passes? (check_method aliasing class method_name method_style inputsJT method)]
                                          (by ! each (if passes?
                                                       (|>> {#Pass})
                                                       (|>> {#Hint}))
                                              (method_signature method_style method)))))))]
    (when (list.all pass candidates)
      {.#Item method {.#End}}
      (in method)

      {.#End}
      (analysis.except ..no_candidates [actual_class_tvars class_name method_name actual_method_tvars inputsJT (list.all hint candidates)])
      
      {.#Item method alternatives}
      (if allow_inheritance?
        (in method)
        (analysis.except ..too_many_candidates [actual_class_tvars class_name method_name actual_method_tvars inputsJT (list.partial method alternatives)])))))

(the constructor_method
  "<init>")

(the (constructor_candidate class_loader actual_class_tvars class_name actual_method_tvars inputsJT)
  (-> java/lang/ClassLoader (List (Type Var)) external.Name (List (Type Var)) (List (Type Value))
      (Operation Method_Signature))
  (do [! phase.monad]
    [class (phase.of_try (reflection!.load class_loader class_name))
     .let [expected_class_tvars (class_type_variables class)]
     candidates (|> class
                    (java/lang/Class::getConstructors [])
                    (array.list {.#None})
                    (monad.each ! (function (_ constructor)
                                    (do !
                                      [.let [expected_method_tvars (constructor_type_variables constructor)
                                             aliasing (dictionary.composite (..aliasing expected_class_tvars actual_class_tvars)
                                                                            (..aliasing expected_method_tvars actual_method_tvars))]
                                       passes? (check_constructor aliasing class inputsJT constructor)]
                                      (by ! each
                                          (if passes?
                                            (|>> {#Pass})
                                            (|>> {#Hint}))
                                          (constructor_signature constructor))))))]
    (when (list.all pass candidates)
      {.#Item constructor {.#End}}
      (in constructor)

      {.#End}
      (analysis.except ..no_candidates [actual_class_tvars class_name ..constructor_method actual_method_tvars inputsJT (list.all hint candidates)])
      
      candidates
      (analysis.except ..too_many_candidates [actual_class_tvars class_name ..constructor_method actual_method_tvars inputsJT candidates]))))

(template.with [<name> <category> <projection>]
  [(the .public <name>
     (Projection (Type <category>))
     (<text>.then <projection> <code>.text))]

  [var Var projection.var]
  [class Class projection.class]
  [type Value projection.value]
  [return Return projection.return]
  )

(the input
  (Projection (Typed Code))
  (<code>.tuple (<>.and ..type <code>.any)))

(the (decorate_inputs @ typesT inputsA)
  (-> Provenance (List (Type Value)) (List analysis.Term)
      (List analysis.Term))
  (|> inputsA
      (list.zipped_2 (list#each (|>> ..signature (analysis.text @)) typesT))
      (list#each (function (_ [type value])
                   (analysis.tuple @ (list type value))))))

(the type_vars
  (<code>.tuple (<>.some ..var)))

(the (invoke::static class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [(all <>.and ..type_vars ..member ..type_vars (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class method] method_tvars argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         .let [argsT (list#each product.left argsTC)]
         method_candidate (..method_candidate false class_loader class_tvars class method_tvars method {#Static} argsT)
         .let [method_type (its #method method_candidate)]
         _ (phase.assertion ..deprecated_method [class method method_type]
                            (not (its #deprecated? method_candidate)))
         [outputT argsA] (inference.general archive analyse method_type (list#each product.right argsTC))
         outputJT (check_return outputT)
         @ meta.provenance]
        (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                    (list.partial (analysis.text @ (..signature (jvm.class (list) class)))
                                                  (analysis.text @ method)
                                                  (analysis.text @ (..signature outputJT))
                                                  (decorate_inputs @ argsT argsA))}])))]))

(the (invoke::virtual class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [(all <>.and ..type_vars ..member ..type_vars <code>.any (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class method] method_tvars objectC argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         .let [argsT (list#each product.left argsTC)]
         method_candidate (..method_candidate true class_loader class_tvars class method_tvars method {#Virtual} argsT)
         .let [method_type (its #method method_candidate)]
         _ (phase.assertion ..deprecated_method [class method method_type]
                            (not (its #deprecated? method_candidate)))
         [outputT allA] (inference.general archive analyse method_type (list.partial objectC (list#each product.right argsTC)))
         .let [[objectA argsA] (when allA
                                 {.#Item objectA argsA}
                                 [objectA argsA]

                                 _
                                 (undefined))]
         outputJT (check_return outputT)
         @ meta.provenance]
        (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                    (list.partial (analysis.text @ (..signature (jvm.class (list) class)))
                                                  (analysis.text @ method)
                                                  (analysis.text @ (..signature outputJT))
                                                  objectA
                                                  (decorate_inputs @ argsT argsA))}])))]))

(the (invoke::special class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [(all <>.and ..type_vars ..member ..type_vars <code>.any (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class method] method_tvars objectC argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         .let [argsT (list#each product.left argsTC)]
         method_candidate (..method_candidate false class_loader class_tvars class method_tvars method {#Special} argsT)
         .let [method_type (its #method method_candidate)]
         _ (phase.assertion ..deprecated_method [class method method_type]
                            (not (its #deprecated? method_candidate)))
         [outputT allA] (inference.general archive analyse method_type (list.partial objectC (list#each product.right argsTC)))
         .let [[objectA argsA] (when allA
                                 {.#Item objectA argsA}
                                 [objectA argsA]

                                 _
                                 (undefined))]
         outputJT (check_return outputT)
         @ meta.provenance]
        (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                    (list.partial (analysis.text @ (..signature (jvm.class (list) class)))
                                                  (analysis.text @ method)
                                                  (analysis.text @ (..signature outputJT))
                                                  objectA
                                                  (decorate_inputs @ argsT argsA))}])))]))

(the (invoke::interface class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [(all <>.and ..type_vars ..member ..type_vars <code>.any (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class_name method] method_tvars objectC argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class_name)
         .let [argsT (list#each product.left argsTC)]
         class (phase.of_try (reflection!.load class_loader class_name))
         _ (phase.assertion non_interface class_name
                            (|> class
                                (java/lang/Class::getModifiers [])
                                [] java/lang/reflect/Modifier::isInterface
                                ffi.of_boolean))
         method_candidate (..method_candidate true class_loader class_tvars class_name method_tvars method {#Interface} argsT)
         .let [method_type (its #method method_candidate)]
         _ (phase.assertion ..deprecated_method [class_name method method_type]
                            (not (its #deprecated? method_candidate)))
         [outputT allA] (inference.general archive analyse method_type (list.partial objectC (list#each product.right argsTC)))
         .let [[objectA argsA] (when allA
                                 {.#Item objectA argsA}
                                 [objectA argsA]

                                 _
                                 (undefined))]
         outputJT (check_return outputT)
         @ meta.provenance]
        (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                    (list.partial (analysis.text @ (..signature (jvm.class (list) class_name)))
                                                  (analysis.text @ method)
                                                  (analysis.text @ (..signature outputJT))
                                                  objectA
                                                  (decorate_inputs @ argsT argsA))}])))]))

(the (invoke::constructor class_loader)
  (-> java/lang/ClassLoader
      (-> Text Handler))
  (..custom
   [(all <>.and ..type_vars <code>.text ..type_vars (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars class method_tvars argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         .let [argsT (list#each product.left argsTC)]
         method_candidate (..constructor_candidate class_loader class_tvars class method_tvars argsT)
         .let [method_type (its #method method_candidate)]
         _ (phase.assertion ..deprecated_method [class ..constructor_method method_type]
                            (not (its #deprecated? method_candidate)))
         [outputT argsA] (inference.general archive analyse method_type (list#each product.right argsTC))
         @ meta.provenance]
        (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                    (list.partial (analysis.text @ (..signature (jvm.class (list) class)))
                                                  (decorate_inputs @ argsT argsA))}])))]))

(the (with_member_extensions class_loader)
  (-> java/lang/ClassLoader
      (-> Bundle Bundle))
  (|>> (install "jvm_member_get_static#" (get::static class_loader))
       (install "jvm_member_get_virtual#" (get::virtual class_loader))
       
       (install "jvm_member_put_static#" (put::static class_loader))
       (install "jvm_member_put_virtual#" (put::virtual class_loader))
       
       (install "jvm_member_invoke_static#" (invoke::static class_loader))
       (install "jvm_member_invoke_virtual#" (invoke::virtual class_loader))
       (install "jvm_member_invoke_special#" (invoke::special class_loader))
       (install "jvm_member_invoke_interface#" (invoke::interface class_loader))
       (install "jvm_member_invoke_constructor#" (invoke::constructor class_loader))
       ))

(.every .public (Annotation_Parameter a)
  [Text a])

(the annotation_parameter
  (Projection (Annotation_Parameter Code))
  (<code>.tuple (<>.and <code>.text <code>.any)))

(.every .public (Annotation a)
  [Text (List (Annotation_Parameter a))])

(the .public annotation
  (Projection (Annotation Code))
  (<code>.form (<>.and <code>.text (<>.some ..annotation_parameter))))

(the .public argument
  (Projection Argument)
  (<code>.tuple (<>.and <code>.text ..type)))

(the (annotation_parameter_analysis @ [name value])
  (-> Provenance (Annotation_Parameter analysis.Term)
      analysis.Term)
  (analysis.tuple @ (list (analysis.text @ name) value)))

(the (annotation_analysis @ [name parameters])
  (-> Provenance (Annotation analysis.Term)
      analysis.Term)
  (analysis.tuple @ (list.partial (analysis.text @ name)
                                  (list#each (annotation_parameter_analysis @) parameters))))

(template.with [<name> <category>]
  [(the (<name> @)
     (-> Provenance (Type <category>)
         analysis.Term)
     (|>> ..signature (analysis.text @)))]

  [var_analysis Var]
  [class_analysis Class]
  [value_analysis Value]
  [return_analysis Return]
  )

(the (typed_analysis @ [type term])
  (-> Provenance (Typed analysis.Term)
      analysis.Term)
  (analysis.tuple @ (list (value_analysis @ type) term)))

(the (argument_analysis @ [argument argumentJT])
  (-> Provenance Argument
      analysis.Term)
  (<| (analysis.tuple @)
      (list (analysis.text @ argument)
            (value_analysis @ argumentJT))))

(template.with [<name> <only> <methods>]
  [(the (<name> [type class])
     (-> [(Type Class) (java/lang/Class java/lang/Object)]
         (Try (List [(Type Class) Text (Type Method)])))
     (|> class
         <methods>
         (list.only (|>> (java/lang/reflect/Method::getModifiers [])
                         (predicate.or (|>> [] java/lang/reflect/Modifier::isPublic ffi.of_boolean)
                                       (|>> [] java/lang/reflect/Modifier::isProtected ffi.of_boolean))))
         <only>
         (monad.each try.monad
                     (function (_ method)
                       (do [! try.monad]
                         [.let [type_variables (|> method
                                                   (java/lang/reflect/Method::getTypeParameters [])
                                                   (array.list {.#None})
                                                   (list#each (|>> (java/lang/reflect/TypeVariable::getName [])
                                                                   ffi.of_string
                                                                   jvm.var)))]
                          inputs (|> method
                                     (java/lang/reflect/Method::getGenericParameterTypes [])
                                     (array.list {.#None})
                                     (monad.each ! reflection!.type))
                          return (..return_type method)
                          .let [concrete_exceptions (..concrete_method_exceptions method)]
                          generic_exceptions (|> method
                                                 (java/lang/reflect/Method::getGenericExceptionTypes [])
                                                 (array.list {.#None})
                                                 (monad.each ! reflection!.class))]
                         (in [type
                              (ffi.of_string (java/lang/reflect/Method::getName [] method))
                              (jvm.method [type_variables inputs return (if (list.empty? generic_exceptions)
                                                                          concrete_exceptions
                                                                          generic_exceptions)])]))))))]

  [abstract_methods (list.only (|>> (java/lang/reflect/Method::getModifiers [])
                                    [] java/lang/reflect/Modifier::isAbstract
                                    ffi.of_boolean))
   (<| (array.list {.#None}) (java/lang/Class::getDeclaredMethods []))]
  [methods (<|)
   ..all_declared_methods]
  )

... https://en.wikipedia.org/wiki/Delimiter
(the jvm_package_delimiter ".")

(template.with [<name> <methods>]
  [(the (<name> class_loader)
     (-> java/lang/ClassLoader (List (Type Class))
         (Try (List [(Type Class) Text (Type Method)])))
     (|>> (monad.each try.monad (function (_ type)
                                  (|> type
                                      ..reflection
                                      (reflection!.load class_loader)
                                      (try#each (|>> [type])))))
          (try#each (monad.each try.monad <methods>))
          try#conjoint
          (try#each list#conjoint)))]

  [all_abstract_methods ..abstract_methods]
  [all_methods ..methods]
  )

(template.with [<name>]
  [(exception.the .public (<name> [expected actual])
     (exception.Exception [(List [(Type Class) Text (Type Method)])
                           (List [(Type Class) Text (Type Method)])])
     (let [%method (is (text.Injection [(Type Class) Text (Type Method)])
                       (function (_ [super name type])
                         (%.message (..signature super) " :: " (%.text name) " " (..signature type))))]
       (exception.report
        (list ["Expected methods" (exception.listing %method expected)]
              ["Actual methods" (exception.listing %method actual)]))))]

  [missing_abstract_methods]
  [invalid_overriden_methods]
  )

(.every .public Visibility
  (Variant
   {#Public}
   {#Private}
   {#Protected}
   {#Default}))

(.every .public Finality Bit)
(.every .public Strictness Bit)

(the .public public_tag "public")
(the .public private_tag "private")
(the .public protected_tag "protected")
(the .public default_tag "default")

(the .public visibility'
  (<text>.Projection Visibility)
  (all <>.or
       (<text>.this ..public_tag)
       (<text>.this ..private_tag)
       (<text>.this ..protected_tag)
       (<text>.this ..default_tag)
       ))

(the .public visibility
  (Projection Visibility)
  (<text>.then ..visibility' <code>.text))

(the .public (visibility_analysis @ visibility)
  (-> Provenance Visibility
      analysis.Term)
  (analysis.text @ (when visibility
                     {#Public} ..public_tag
                     {#Private} ..private_tag
                     {#Protected} ..protected_tag
                     {#Default} ..default_tag)))

(.every Exception
  (Type Class))

(the .public parameter_types
  (-> (List (Type Var))
      (Check (List [(Type Var) .Type])))
  (monad.each check.monad
              (function (_ parameterJ)
                (do check.monad
                  [[_ parameterT] check.existential]
                  (in [parameterJ parameterT])))))

(.every .public (Abstract_Method a)
  [Text
   Visibility
   (List (Annotation a))
   (List (Type Var))
   (List Argument)
   (Type Return)
   (List Exception)])

(the .public abstract_tag "abstract")

(the .public abstract_method_definition
  (Projection (Abstract_Method Code))
  (<| <code>.form
      (<>.after (<code>.this_text ..abstract_tag))
      (all <>.and
           <code>.text
           ..visibility
           (<code>.tuple (<>.some ..annotation))
           (<code>.tuple (<>.some ..var))
           (<code>.tuple (<>.some ..argument))
           ..return
           (<code>.tuple (<>.some ..class)))))

(the (method_mapping of_class parameters)
  (-> Mapping (List (Type Var))
      (Check Mapping))
  (|> parameters
      ..parameter_types
      (check#each (list#mix (function (_ [parameterJ parameterT] mapping)
                              (dictionary.has (projection.name parameterJ) parameterT mapping))
                            of_class))))

(the class_mapping
  (-> (List (Type Var))
      (Check Mapping))
  (..method_mapping luxT.fresh))

(the .public (analyse_abstract_method analyse archive method)
  (-> Phase Archive (Abstract_Method Code)
      (Operation analysis.Term))
  (let [[method_name visibility annotations vars arguments return exceptions] method]
    (do [! phase.monad]
      [mapping (typeA.check (method_mapping luxT.fresh vars))
       annotationsA (monad.each ! (function (_ [name parameters])
                                    (do !
                                      [parametersA (monad.each ! (function (_ [name value])
                                                                   (do !
                                                                     [valueA (analyse archive value)]
                                                                     (in [name valueA])))
                                                               parameters)]
                                      (in [name parametersA])))
                                annotations)
       @ meta.provenance]
      (in (analysis.tuple @ (list (analysis.text @ ..abstract_tag)
                                  (analysis.text @ method_name)
                                  (visibility_analysis @ visibility)
                                  (analysis.tuple @ (list#each (annotation_analysis @) annotationsA))
                                  (analysis.tuple @ (list#each (var_analysis @) vars))
                                  (analysis.tuple @ (list#each (..argument_analysis @) arguments))
                                  (return_analysis @ return)
                                  (analysis.tuple @ (list#each (class_analysis @) exceptions))
                                  ))))))

(.every .public (Constructor a)
  [Visibility
   Strictness
   (List (Annotation a))
   (List (Type Var))
   (List Exception)
   Text
   (List Argument)
   (List (Typed a))
   a])

(the .public constructor_tag "init")

(the .public constructor_definition
  (Projection (Constructor Code))
  (<| <code>.form
      (<>.after (<code>.this_text ..constructor_tag))
      (all <>.and
           ..visibility
           <code>.bit
           (<code>.tuple (<>.some ..annotation))
           (<code>.tuple (<>.some ..var))
           (<code>.tuple (<>.some ..class))
           <code>.text
           (<code>.tuple (<>.some ..argument))
           (<code>.tuple (<>.some ..input))
           <code>.any)))

(the (with_fake_parameter#pattern it)
  (-> pattern.Pattern
      pattern.Pattern)
  (when it
    {pattern.#Simple _}
    it
    
    {pattern.#Complex it}
    {pattern.#Complex
     (when it
       {complex.#Variant it}
       {complex.#Variant (revised complex.#value with_fake_parameter#pattern it)}

       {complex.#Tuple it}
       {complex.#Tuple (list#each with_fake_parameter#pattern it)})}
    
    {pattern.#Bind it}
    {pattern.#Bind (++ it)}))

(the (with_fake_parameter [@ it])
  (-> analysis.Term
      analysis.Term)
  [@ (when it
       {analysis.#Simple _}
       it

       {analysis.#Structure it}
       {analysis.#Structure
        (when it
          {complex.#Variant it}
          {complex.#Variant (revised complex.#value with_fake_parameter it)}

          {complex.#Tuple it}
          {complex.#Tuple (list#each with_fake_parameter it)})}

       {analysis.#Reference it}
       {analysis.#Reference
        (when it
          {reference.#Variable it}
          {reference.#Variable
           (when it
             {variable.#Local it}
             {variable.#Local (++ it)}
             
             {variable.#Foreign _}
             it)}
          
          {reference.#Constant _}
          it)}
       
       {analysis.#When value [head tail]}
       {analysis.#When (with_fake_parameter value)
                       (let [with_fake_parameter (is (-> analysis.Branch analysis.Branch)
                                                     (|>> (revised analysis.#when with_fake_parameter#pattern)
                                                          (revised analysis.#then with_fake_parameter)))]
                         [(with_fake_parameter head)
                          (list#each with_fake_parameter tail)])}
       
       {analysis.#Abstraction environment body}
       {analysis.#Abstraction (list#each with_fake_parameter environment)
                              body}
       
       {analysis.#Reification parameter abstraction}
       {analysis.#Reification (with_fake_parameter parameter)
                              (with_fake_parameter abstraction)}
       
       {analysis.#Extension name parameters}
       {analysis.#Extension name (list#each with_fake_parameter parameters)})])

(the .public (hidden_method_body @ arity bodyA)
  (-> Provenance Natural analysis.Term
      analysis.Term)
  (<| (analysis.tuple @)
      (list (analysis.unit @))
      (when arity
        (^.or 0 1)
        bodyA
        
        2
        (let [forced_refencing (is analysis.Term
                                   (analysis.tuple @ (is (List analysis.Term)
                                                         (list#each (is (-> Natural
                                                                            analysis.Term)
                                                                        (|>> (analysis.local @)))
                                                                    (list.indices (++ arity))))))]
          [@ {analysis.#When (analysis.unit @)
                             [[analysis.#when
                               {pattern.#Bind 2}
                               
                               analysis.#then
                               (analysis.tuple @ (list forced_refencing bodyA))]
                              (list)]}])

        _
        (let [forced_refencing (is analysis.Term
                                   (analysis.tuple @ (is (List analysis.Term)
                                                         (list#each (is (-> Natural analysis.Term)
                                                                        (|>> (analysis.local @)))
                                                                    (list.indices (++ arity))))))]
          [@ {analysis.#When (analysis.unit @)
                             [[analysis.#when
                               {pattern.#Complex
                                {complex.#Tuple
                                 (|> (-- arity)
                                     list.indices
                                     (list#each (|>> (n.+ 2) {pattern.#Bind})))}}
                               
                               analysis.#then
                               (analysis.tuple @ (list forced_refencing bodyA))]
                              (list)]}]))))

(the .public (analyse_constructor_method analyse archive selfT mapping method)
  (-> Phase Archive .Type Mapping (Constructor Code)
      (Operation analysis.Term))
  (let [[visibility strict_fp?
         annotations vars exceptions
         self_name arguments super_arguments body] method]
    (do [! phase.monad]
      [mapping (typeA.check (method_mapping mapping vars))
       annotationsA (monad.each ! (function (_ [name parameters])
                                    (do !
                                      [parametersA (monad.each ! (function (_ [name value])
                                                                   (do !
                                                                     [valueA (analyse archive value)]
                                                                     (in [name valueA])))
                                                               parameters)]
                                      (in [name parametersA])))
                                annotations)
       super_arguments (monad.each ! (function (_ [jvmT super_argC])
                                       (do !
                                         [luxT (reflection_type mapping jvmT)
                                          super_argA (<| (typeA.expecting luxT)
                                                         (analyse archive super_argC))]
                                         (in [jvmT super_argA])))
                                   super_arguments)
       arguments' (monad.each !
                              (function (_ [name jvmT])
                                (do !
                                  [luxT (boxed_reflection_type mapping jvmT)]
                                  (in [name luxT])))
                              arguments)
       [scope bodyA] (|> arguments'
                         {.#Item [self_name selfT]}
                         list.reversed
                         (list#mix scope.with_local (analyse archive body))
                         (typeA.expecting .Any)
                         scope.with)
       .let [arity (list.size arguments)]
       @ meta.provenance]
      (in (analysis.tuple @ (list (analysis.text @ ..constructor_tag)
                                  (visibility_analysis @ visibility)
                                  (analysis.bit @ strict_fp?)
                                  (analysis.tuple @ (list#each (annotation_analysis @) annotationsA))
                                  (analysis.tuple @ (list#each (var_analysis @) vars))
                                  (analysis.tuple @ (list#each (class_analysis @) exceptions))
                                  (analysis.text @ self_name)
                                  (analysis.tuple @ (list#each (..argument_analysis @) arguments))
                                  (analysis.tuple @ (list#each (typed_analysis @) super_arguments))
                                  [@ {analysis.#Abstraction
                                      (list#each (|>> (analysis.variable @))
                                                 (scope.environment scope))
                                      (<| (..hidden_method_body @ arity)
                                          (when arity
                                            0 (with_fake_parameter bodyA)
                                            _ bodyA))}]
                                  ))))))

(.every .public (Virtual_Method a)
  [Text
   Visibility
   Finality
   Strictness
   (List (Annotation a))
   (List (Type Var))
   Text
   (List Argument)
   (Type Return)
   (List Exception)
   a])

(the .public virtual_tag "virtual")

(the .public virtual_method_definition
  (Projection (Virtual_Method Code))
  (<| <code>.form
      (<>.after (<code>.this_text ..virtual_tag))
      (all <>.and
           <code>.text
           ..visibility
           <code>.bit
           <code>.bit
           (<code>.tuple (<>.some ..annotation))
           (<code>.tuple (<>.some ..var))
           <code>.text
           (<code>.tuple (<>.some ..argument))
           ..return
           (<code>.tuple (<>.some ..class))
           <code>.any)))

(.every .public (Method_Declaration a)
  (Record
   [#name Text
    #annotations (List (Annotation a))
    #type_variables (List (Type Var))
    #exceptions (List (Type Class))
    #arguments (List (Type Value))
    #return (Type Return)]))

(the .public method_declaration
  (Projection (Method_Declaration Code))
  (<code>.form
   (all <>.and
        <code>.text
        (<code>.tuple (<>.some ..annotation))
        (<code>.tuple (<>.some ..var))
        (<code>.tuple (<>.some ..class))
        (<code>.tuple (<>.some ..type))
        ..return
        )))

(the .public (analyse_virtual_method analyse archive selfT mapping method)
  (-> Phase Archive .Type Mapping (Virtual_Method Code)
      (Operation analysis.Term))
  (let [[method_name visibility
         final? strict_fp? annotations vars
         self_name arguments return exceptions
         body] method]
    (do [! phase.monad]
      [mapping (typeA.check (method_mapping mapping vars))
       annotationsA (monad.each ! (function (_ [name parameters])
                                    (do !
                                      [parametersA (monad.each ! (function (_ [name value])
                                                                   (do !
                                                                     [valueA (analyse archive value)]
                                                                     (in [name valueA])))
                                                               parameters)]
                                      (in [name parametersA])))
                                annotations)
       :return: (boxed_reflection_return mapping return)
       arguments' (monad.each !
                              (function (_ [name jvmT])
                                (do !
                                  [luxT (boxed_reflection_type mapping jvmT)]
                                  (in [name luxT])))
                              arguments)
       [scope bodyA] (|> arguments'
                         {.#Item [self_name selfT]}
                         list.reversed
                         (list#mix scope.with_local (analyse archive body))
                         (typeA.expecting :return:)
                         scope.with)
       .let [arity (list.size arguments)]
       @ meta.provenance]
      (in (analysis.tuple @ (list (analysis.text @ ..virtual_tag)
                                  (analysis.text @ method_name)
                                  (visibility_analysis @ visibility)
                                  (analysis.bit @ final?)
                                  (analysis.bit @ strict_fp?)
                                  (analysis.tuple @ (list#each (annotation_analysis @) annotationsA))
                                  (analysis.tuple @ (list#each (var_analysis @) vars))
                                  (analysis.text @ self_name)
                                  (analysis.tuple @ (list#each (..argument_analysis @) arguments))
                                  (return_analysis @ return)
                                  (analysis.tuple @ (list#each (class_analysis @) exceptions))
                                  [@ {analysis.#Abstraction
                                      (list#each (|>> (analysis.variable @))
                                                 (scope.environment scope))
                                      (<| (..hidden_method_body @ arity)
                                          (when arity
                                            0 (with_fake_parameter bodyA)
                                            _ bodyA))}]
                                  ))))))

(.every .public (Static_Method a)
  [Text
   Visibility
   Strictness
   (List (Annotation a))
   (List (Type Var))
   (List Argument)
   (Type Return)
   (List Exception)
   a])

(the .public static_tag "static")

(the .public static_method_definition
  (Projection (Static_Method Code))
  (<| <code>.form
      (<>.after (<code>.this_text ..static_tag))
      (all <>.and
           <code>.text
           ..visibility
           <code>.bit
           (<code>.tuple (<>.some ..annotation))
           (<code>.tuple (<>.some ..var))
           (<code>.tuple (<>.some ..argument))
           ..return
           (<code>.tuple (<>.some ..class))
           <code>.any)))

(the .public (analyse_static_method analyse archive mapping method)
  (-> Phase Archive Mapping (Static_Method Code)
      (Operation analysis.Term))
  (let [[method_name visibility
         strict_fp? annotations vars
         arguments return exceptions
         body] method]
    (do [! phase.monad]
      [mapping (typeA.check (method_mapping mapping vars))
       annotationsA (monad.each ! (function (_ [name parameters])
                                    (do !
                                      [parametersA (monad.each ! (function (_ [name value])
                                                                   (do !
                                                                     [valueA (analyse archive value)]
                                                                     (in [name valueA])))
                                                               parameters)]
                                      (in [name parametersA])))
                                annotations)
       :return: (boxed_reflection_return mapping return)
       arguments' (monad.each !
                              (function (_ [name jvmT])
                                (do !
                                  [luxT (boxed_reflection_type mapping jvmT)]
                                  (in [name luxT])))
                              arguments)
       [scope bodyA] (|> arguments'
                         list.reversed
                         (list#mix scope.with_local (analyse archive body))
                         (typeA.expecting :return:)
                         scope.with)
       @ meta.provenance]
      (in (analysis.tuple @ (list (analysis.text @ ..static_tag)
                                  (analysis.text @ method_name)
                                  (visibility_analysis @ visibility)
                                  (analysis.bit @ strict_fp?)
                                  (analysis.tuple @ (list#each (annotation_analysis @) annotationsA))
                                  (analysis.tuple @ (list#each (var_analysis @) vars))
                                  (analysis.tuple @ (list#each (..argument_analysis @) arguments))
                                  (return_analysis @ return)
                                  (analysis.tuple @ (list#each (class_analysis @)
                                                               exceptions))
                                  [@ {analysis.#Abstraction
                                      (list#each (|>> (analysis.variable @))
                                                 (scope.environment scope))
                                      (analysis.tuple @ (list bodyA))}]
                                  ))))))

(.every .public (Overriden_Method a)
  [(Type Class)
   Text
   Bit
   (List (Annotation a))
   (List (Type Var))
   Text
   (List Argument)
   (Type Return)
   (List (Type Class))
   a])

(the .public overriden_tag "override")

(the .public overriden_method_definition
  (Projection (Overriden_Method Code))
  (<| <code>.form
      (<>.after (<code>.this_text ..overriden_tag))
      (all <>.and
           ..class
           <code>.text
           <code>.bit
           (<code>.tuple (<>.some ..annotation))
           (<code>.tuple (<>.some ..var))
           <code>.text
           (<code>.tuple (<>.some ..argument))
           ..return
           (<code>.tuple (<>.some ..class))
           <code>.any
           )))

(exception.the .public (unknown_super [name supers])
  (exception.Exception [Text (List (Type Class))])
  (exception.report
   (list ["Name" (%.text name)]
         ["Available" (exception.listing (|>> projection.read_class product.right) supers)])))

(exception.the .public (mismatched_super_parameters [name expected actual])
  (exception.Exception [Text Natural Natural])
  (exception.report
   (list ["Name" (%.text name)]
         ["Expected" (%.natural expected)]
         ["Actual" (%.natural actual)])))

(the (override_mapping mapping supers parent_type)
  (-> Mapping (List (Type Class)) (Type Class)
      (Operation (List [Text .Type])))
  (let [[parent_parameters parent_name] (projection.read_class parent_type)]
    (when (list.one (function (_ super)
                      (let [[super_parameters super_name] (projection.read_class super)]
                        (if (text.= parent_name super_name)
                          {.#Some super_parameters}
                          {.#None})))
                    supers)
      {try.#Success super_parameters}
      (let [expected_count (list.size parent_parameters)
            actual_count (list.size super_parameters)]
        (if (n.= expected_count actual_count)
          (do [! phase.monad]
            [parent_parameters (|> parent_parameters
                                   (monad.each maybe.monad projection.var?)
                                   (try.of_maybe "Not all parameters are type variables.")
                                   phase.of_try)]
            (|> super_parameters
                (monad.each ! (..reflection_type mapping))
                (by ! each (|>> (list.zipped_2 parent_parameters)))))
          (phase.of_try (exception.except ..mismatched_super_parameters [parent_name expected_count actual_count]))))
      
      {try.#Failure _}
      (phase.of_try (exception.except ..unknown_super [parent_name supers])))))

(the .public (with_override_mapping supers parent_type mapping)
  (-> (List (Type Class)) (Type Class) Mapping
      (Operation Mapping))
  (do phase.monad
    [override_mapping (..override_mapping mapping supers parent_type)]
    (in (list#mix (function (_ [super_var bound_type] mapping)
                    (dictionary.has super_var bound_type mapping))
                  mapping
                  override_mapping))))

(the .public (analyse_overriden_method analyse archive selfT mapping supers method)
  (-> Phase Archive .Type Mapping (List (Type Class)) (Overriden_Method Code)
      (Operation analysis.Term))
  (let [[parent_type method_name
         strict_fp? annotations vars
         self_name arguments return exceptions
         body] method]
    (do [! phase.monad]
      [mapping (..with_override_mapping supers parent_type mapping)
       mapping (typeA.check (method_mapping mapping vars))
       annotationsA (monad.each ! (function (_ [name parameters])
                                    (do !
                                      [parametersA (monad.each ! (function (_ [name value])
                                                                   (do !
                                                                     [valueA (analyse archive value)]
                                                                     (in [name valueA])))
                                                               parameters)]
                                      (in [name parametersA])))
                                annotations)
       arguments' (monad.each !
                              (function (_ [name jvmT])
                                (do !
                                  [luxT (boxed_reflection_type mapping jvmT)]
                                  (in [name luxT])))
                              arguments)
       :return: (boxed_reflection_return mapping return)
       [scope bodyA] (|> arguments'
                         {.#Item [self_name selfT]}
                         list.reversed
                         (list#mix scope.with_local (analyse archive body))
                         (typeA.expecting :return:)
                         scope.with)
       .let [arity (list.size arguments)]
       @ meta.provenance]
      (in (analysis.tuple @ (list (analysis.text @ ..overriden_tag)
                                  (class_analysis @ parent_type)
                                  (analysis.text @ method_name)
                                  (analysis.bit @ strict_fp?)
                                  (analysis.tuple @ (list#each (annotation_analysis @) annotationsA))
                                  (analysis.tuple @ (list#each (var_analysis @) vars))
                                  (analysis.text @ self_name)
                                  (analysis.tuple @ (list#each (..argument_analysis @) arguments))
                                  (return_analysis @ return)
                                  (analysis.tuple @ (list#each (class_analysis @)
                                                               exceptions))
                                  [@ {analysis.#Abstraction
                                      (list#each (|>> (analysis.variable @))
                                                 (scope.environment scope))
                                      (<| (..hidden_method_body @ arity)
                                          (when arity
                                            0 (with_fake_parameter bodyA)
                                            _ bodyA))}]
                                  ))))))

(the (matched? [sub sub_method subJT] [super super_method superJT])
  (-> [(Type Class) Text (Type Method)] [(Type Class) Text (Type Method)]
      Bit)
  (and (by descriptor.equivalence = (jvm.descriptor super) (jvm.descriptor sub))
       (text.= super_method sub_method)
       (jvm.= superJT subJT)))

(the (mismatched_methods super_set sub_set)
  (-> (List [(Type Class) Text (Type Method)]) (List [(Type Class) Text (Type Method)])
      (List [(Type Class) Text (Type Method)]))
  (list.only (function (_ sub)
               (not (list.any? (matched? sub) super_set)))
             sub_set))

(exception.the .public (class_parameter_mismatch [name declaration expected actual])
  (exception.Exception [Text (Type Class) (List Text) (List (Type Parameter))])
  (exception.report
   (list ["Class" (%.text name)]
         ["Declaration" (signature.signature (jvm.signature declaration))]
         ["Expected (amount)" (%.natural (list.size expected))]
         ["Expected (parameters)" (exception.listing %.text expected)]
         ["Actual (amount)" (%.natural (list.size actual))]
         ["Actual (parameters)" (exception.listing ..signature actual)])))

(the (super_aliasing class_loader class)
  (-> java/lang/ClassLoader (Type Class)
      (Operation Aliasing))
  (do phase.monad
    [.let [[actual_parameters name] (projection.read_class class)]
     jvm_class (phase.of_try (reflection!.load class_loader name))
     .let [expected_parameters (|> jvm_class
                                   (java/lang/Class::getTypeParameters [])
                                   (array.list {.#None})
                                   (list#each (|>> (java/lang/reflect/TypeVariable::getName [])
                                                   ffi.of_string)))]
     _ (phase.assertion ..class_parameter_mismatch [name class expected_parameters actual_parameters]
                        (n.= (list.size expected_parameters)
                             (list.size actual_parameters)))]
    (in (|> (list.zipped_2 expected_parameters actual_parameters)
            (list#mix (function (_ [expected actual] mapping)
                        (when (projection.var? actual)
                          {.#Some actual}
                          (dictionary.has actual expected mapping)
                          
                          {.#None}
                          mapping))
                      alias.fresh)))))

(the (anonymous_class_name module id)
  (-> Module Natural
      Text)
  (let [global (text.replaced .module_delimiter ..jvm_package_delimiter module)
        local (%.message "anonymous-class" (%.natural id))]
    (%.message global ..jvm_package_delimiter local)))

(the .public (require_complete_method_concretion class_loader supers methods)
  (-> java/lang/ClassLoader (List (Type Class)) (List (Overriden_Method Code))
      (Operation Any))
  (do [! phase.monad]
    [required_abstract_methods (phase.of_try (all_abstract_methods class_loader supers))
     available_methods (phase.of_try (all_methods class_loader supers))
     overriden_methods (monad.each ! (function (_ [parent_type method_name
                                                   strict_fp? annotations type_vars
                                                   self_name arguments return exceptions
                                                   body])
                                       (do !
                                         [aliasing (super_aliasing class_loader parent_type)]
                                         (in (|> (jvm.method [type_vars
                                                              (list#each product.right arguments)
                                                              return
                                                              exceptions])
                                                 (alias.method aliasing)
                                                 [parent_type method_name]))))
                                   methods)
     .let [missing_abstract_methods (mismatched_methods overriden_methods required_abstract_methods)
           invalid_overriden_methods (mismatched_methods available_methods overriden_methods)]
     _ (phase.assertion ..missing_abstract_methods [required_abstract_methods overriden_methods]
                        (list.empty? missing_abstract_methods))
     _ (phase.assertion ..invalid_overriden_methods [available_methods invalid_overriden_methods]
                        (list.empty? invalid_overriden_methods))]
    (in [])))

(.every Declaration
  [Text (List (Type Var))])

(.every Constant
  [Text (List Annotation) (Type Value) Code])

(.every Variable
  [Text (Modifier field.Field) (Modifier field.Field) (List Annotation) (Type Value)])

(.every Field
  (Variant
   {#Constant Constant}
   {#Variable Variable}))

(.every (Method_Definition a)
  (Variant
   {#Constructor (..Constructor a)}
   {#Virtual_Method (..Virtual_Method a)}
   {#Static_Method (..Static_Method a)}
   {#Overriden_Method (..Overriden_Method a)}
   {#Abstract_Method (..Abstract_Method a)}))

(the class_name
  (|>> projection.read_class
       product.right
       internal.name))

(the (mock_class [name parameters] super interfaces fields methods modifier)
  (-> Declaration (Type Class) (List (Type Class))
      (List (Resource field.Field)) (List (Resource method.Method)) (Modifier class.Class)
      (Try [external.Name Binary]))
  (let [signature (signature.inheritance (list#each jvm.signature parameters)
                                         (jvm.signature super)
                                         (list#each jvm.signature interfaces))]
    (try#each (|>> (\\injection.value class.injection)
                   [name])
              (class.class version.v6_0
                (all modifier#composite
                     class.public
                     modifier)
                (internal.name name)
                {.#Some signature}
                (..class_name super)
                (list#each ..class_name interfaces)
                fields
                methods
                (list)))))

(the constant::modifier
  (Modifier field.Field)
  (all modifier#composite
       field.public
       field.static
       field.final
       ))

(the (field_definition field)
  (-> Field
      (Resource field.Field))
  (when field
    ... TODO: Handle annotations.
    {#Constant [name annotations type value]}
    (`` (when value
          (,, (template.with [<tag> <type> <constant>]
                [[_ {<tag> value}]
                 (do pool.monad
                   [constant (`` (|> value (,, (template.spliced <constant>))))
                    attribute (attribute.constant constant)]
                   (field.field ..constant::modifier name true <type> (sequence.sequence attribute)))]

                [.#Bit jvm.boolean [(|.when #0 +0 #1 +1) .i64 i32.i32 pool.integer]]
                ... [.#Integer jvm.byte [.i64 i32.i32 pool.integer]]
                ... [.#Integer jvm.short [.i64 i32.i32 pool.integer]]
                ... [.#Integer jvm.int [.i64 i32.i32 pool.integer]]
                [.#Integer jvm.long [pool.long]]
                ... [.#Decimal jvm.float [ffi.as_double ffi.double_to_float pool.float]]
                [.#Decimal jvm.double [pool.double]]
                [.#Natural jvm.char [.i64 i32.i32 pool.integer]]
                [.#Text (jvm.class (list) "java.lang.String") [pool.string]]
                ))

          ... TODO: Tighten this pattern-matching so this catch-all clause isn't necessary.
          _
          (undefined)))

    ... TODO: Handle annotations.
    {#Variable [name visibility state annotations type]}
    (field.field (modifier#composite visibility state)
                 name true type sequence.empty)))

(the method_privacy
  (-> ffi.Privacy
      (Modifier method.Method))
  (|>> (|.when
         {ffi.#PublicP} method.public
         {ffi.#PrivateP} method.private
         {ffi.#ProtectedP} method.protected
         {ffi.#DefaultP} modifier.empty)))

(the constructor_name
  "<init>")

(the (mock_value valueT)
  (-> (Type Value)
      (Bytecode Any))
  (when (jvm.primitive? valueT)
    {.#Left classT}
    _.aconst_null
    
    {.#Right primitiveT}
    (if (by jvm.equivalence = jvm.long primitiveT)
      _.lconst_0

      (by jvm.equivalence = jvm.float primitiveT)
      _.fconst_0

      (by jvm.equivalence = jvm.double primitiveT)
      _.dconst_0

      ... jvm.boolean jvm.byte jvm.short jvm.int jvm.char
      _.iconst_0)))

(the (mock_return :return:)
  (-> (Type Return)
      (Bytecode Any))
  (when (jvm.void? :return:)
    {.#Right :return:}
    _.return

    {.#Left valueT}
    (all _.composite
         (mock_value valueT)
         (when (jvm.primitive? valueT)
           {.#Left classT}
           _.areturn
           
           {.#Right primitiveT}
           (if (by jvm.equivalence = jvm.long primitiveT)
             _.lreturn

             (by jvm.equivalence = jvm.float primitiveT)
             _.freturn

             (by jvm.equivalence = jvm.double primitiveT)
             _.dreturn

             ... jvm.boolean jvm.byte jvm.short jvm.int jvm.char
             _.ireturn)))))

(the (mock_method super method)
  (-> (Type Class) (Method_Definition Code)
      (Resource method.Method))
  (when method
    {#Constructor [privacy strict_floating_point? annotations variables exceptions
                   self arguments constructor_arguments
                   body]}
    (method.method (all modifier#composite
                        (..method_privacy privacy)
                        (if strict_floating_point?
                          method.strict
                          modifier.empty))
      ..constructor_name
      false (jvm.method [variables (list#each product.right arguments) jvm.void exceptions])
      (list)
      {.#Some (all _.composite
                   (_.aload 0)
                   (|> constructor_arguments
                       (list#each (|>> product.left ..mock_value))
                       (monad.all _.monad))
                   (|> (jvm.method [(list) (list#each product.left constructor_arguments) jvm.void (list)])
                       (_.invokespecial super ..constructor_name))
                   _.return
                   )})

    {#Overriden_Method [super name strict_floating_point? annotations variables
                        self arguments return exceptions
                        body]}
    (method.method (all modifier#composite
                        method.public
                        (if strict_floating_point?
                          method.strict
                          modifier.empty))
      name
      false (jvm.method [variables (list#each product.right arguments) return exceptions])
      (list)
      {.#Some (..mock_return return)})

    {#Virtual_Method [name privacy final? strict_floating_point? annotations variables
                      self arguments return exceptions
                      body]}
    (method.method (all modifier#composite
                        (..method_privacy privacy)
                        (if strict_floating_point?
                          method.strict
                          modifier.empty)
                        (if final?
                          method.final
                          modifier.empty))
      name
      false (jvm.method [variables (list#each product.right arguments) return exceptions])
      (list)
      {.#Some (..mock_return return)})

    {#Static_Method [name privacy strict_floating_point? annotations
                     variables arguments return exceptions
                     body]}
    (method.method (all modifier#composite
                        method.static
                        (..method_privacy privacy)
                        (if strict_floating_point?
                          method.strict
                          modifier.empty))
      name
      false (jvm.method [variables (list#each product.right arguments) return exceptions])
      (list)
      {.#Some (..mock_return return)})

    {#Abstract_Method [name privacy annotations
                       variables arguments return exceptions]}
    (method.method (all modifier#composite
                        method.abstract
                        (..method_privacy privacy))
      name
      false (jvm.method [variables (list#each product.right arguments) return exceptions])
      (list)
      {.#None})
    ))

(the (mock declaration super interfaces inheritance fields methods)
  (-> Declaration
      (Type Class) (List (Type Class))
      (Modifier class.Class) (List ..Field) (List (Method_Definition Code))
      (Try [external.Name Binary]))
  (mock_class declaration super interfaces
              (list#each ..field_definition fields)
              (list#each (..mock_method super) methods)
              inheritance))

(the (class::anonymous class_loader host)
  (-> java/lang/ClassLoader runtime.Host
      (-> Text Handler))
  (..custom
   [(all <>.and
         (<code>.tuple (<>.some ..var))
         ..class
         (<code>.tuple (<>.some ..class))
         (<code>.tuple (<>.some ..input))
         (<code>.tuple (<>.some ..overriden_method_definition)))
    (function (_ extension_name analyse archive [parameters
                                                 super_class
                                                 super_interfaces
                                                 constructor_args
                                                 methods])
      (do [! phase.monad]
        [_ (..ensure_fresh_class! class_loader (..reflection super_class))
         _ (monad.each ! (|>> ..reflection (..ensure_fresh_class! class_loader)) super_interfaces)

         self_name (do meta.monad
                     [[where _] module.current
                      id meta.seed]
                     (in (..anonymous_class_name where id)))
         .let [selfT {.#Nominal self_name (list)}]
         mock (<| phase.of_try
                  (..mock [self_name parameters]
                          super_class
                          super_interfaces
                          class.final
                          (list)
                          (list#each (|>> {#Overriden_Method}) methods)))
         ... Necessary for reflection to work properly during analysis.
         _ (phase.of_try (by host execute mock))

         mapping (typeA.check (..class_mapping parameters))
         super_classT (typeA.check (luxT.check (luxT.class mapping) (..signature super_class)))
         super_interfaceT+ (typeA.check (monad.each check.monad
                                                    (|>> ..signature (luxT.check (luxT.class mapping)))
                                                    super_interfaces))
         _ (typeA.inference selfT)
         constructor_argsA+ (monad.each ! (function (_ [type term])
                                            (do !
                                              [argT (reflection_type mapping type)
                                               termA (<| (typeA.expecting argT)
                                                         (analyse archive term))]
                                              (in [type termA])))
                                        constructor_args)
         .let [supers {.#Item super_class super_interfaces}]
         _ (..require_complete_method_concretion class_loader supers methods)
         methodsA (monad.each ! (analyse_overriden_method analyse archive selfT mapping supers) methods)
         @ meta.provenance]
        (in [@ {analysis.#Extension [.prelude (%.message extension_name "|translation")]
                                    (list (class_analysis @ super_class)
                                          (analysis.tuple @ (list#each (class_analysis @) super_interfaces))
                                          (analysis.tuple @ (list#each (typed_analysis @) constructor_argsA+))
                                          (analysis.tuple @ methodsA))}])))]))

(the (with_class_extensions class_loader host)
  (-> java/lang/ClassLoader runtime.Host
      (-> Bundle Bundle))
  (install (%.message "jvm_" "class_" "anonymous" "#") (class::anonymous class_loader host)))

(the .public (bundle class_loader host)
  (-> java/lang/ClassLoader runtime.Host
      Bundle)
  (<| with_conversion_extensions
      with_int_extensions
      with_long_extensions
      with_float_extensions
      with_double_extensions
      with_char_extensions
      with_array_extensions
      (with_object_extensions class_loader)
      (with_member_extensions class_loader)
      (with_class_extensions class_loader host)
      ///.empty
      ))
