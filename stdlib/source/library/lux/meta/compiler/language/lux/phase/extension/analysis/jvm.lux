(.require
 [library
  [lux (.except Type Module Primitive Analysis Declaration Double #Default char int type)
   ["[0]" ffi (.only import)]
   [abstract
    ["[0]" monad (.only do)]]
   [control
    ["<>" parser]
    ["[0]" pipe]
    ["[0]" maybe (.use "[1]#[0]" functor)]
    ["[0]" try (.only Try) (.use "[1]#[0]" monad)]
    ["[0]" exception]
    [function
     ["[0]" predicate]]]
   [data
    [binary (.only Binary)
     ["[0]" \\format]]
    ["[0]" product]
    ["[0]" text (.use "[1]#[0]" equivalence)
     ["%" \\format (.only format)]
     ["<[1]>" \\parser]]
    [collection
     ["[0]" list (.use "[1]#[0]" mix monad monoid)]
     ["[0]" array]
     ["[0]" dictionary (.only Dictionary)]
     ["[0]" sequence]]]
   [math
    [number
     ["n" nat]
     ["[0]" i32]]]
   ["[0]" meta (.only)
    ["[0]" code
     ["<[1]>" \\parser (.only Parser)]]
    [macro
     ["^" pattern]
     ["[0]" template]]
    [target
     ["[0]" jvm
      ["_" bytecode (.only Bytecode) (.use "[1]#[0]" monad)]
      ["[0]!" reflection]
      ["[0]" modifier (.only Modifier) (.use "[1]#[0]" monoid)]
      ["[0]" attribute]
      ["[0]" field]
      ["[0]" version]
      ["[0]" method]
      ["[0]" class]
      ["[0]" constant (.only)
       ["[0]" pool (.only Resource)]]
      [encoding
       ["[0]" name (.only External)]]
      ["[1]" type (.only Type Argument Typed) (.use "[1]#[0]" equivalence)
       ["[0]" category (.only Void Value' Value Return' Return Primitive Object Class Array Var Parameter Method)]
       ["[0]" box]
       ["[0]" reflection]
       ["[0]" descriptor]
       ["[0]" signature]
       ["[0]" parser]
       ["[0]" alias (.only Aliasing)]
       ["[0]T" lux (.only Mapping)]]]]
    ["[0]" type (.use "[1]#[0]" equivalence)
     ["[0]" check (.only Check) (.use "[1]#[0]" monad)]]]]]
 ["[0]" //
  ["[1][0]" lux (.only custom install)]
  ["/[1]" // (.only)
   ["/[1]" //
    [generation
     [jvm
      ["[0]" runtime]
      ["[0]" function
       ["[1]" abstract]]]]
    ["/[1]" //
     ["[0]" generation]
     ["[0]" declaration]
     ["[1][0]" analysis (.only Analysis Operation Phase Handler Bundle)
      ["[0]" complex]
      ["[0]" pattern]
      ["[0]" inference]
      ["[0]A" type]
      ["[0]" scope]]
     [///
      ["[0]" phase (.use "[1]#[0]" monad)]
      ["[0]" reference (.only)
       ["[0]" variable]]
      [meta
       [archive (.only Archive)
        [module
         [descriptor (.only Module)]]]]]]]]])

(import java/lang/ClassLoader
  "[1]::[0]")

(import java/lang/Object
  "[1]::[0]"
  (equals [java/lang/Object] boolean)
  (toString [] java/lang/String))

(import java/lang/reflect/Type
  "[1]::[0]")

(import (java/lang/reflect/TypeVariable d)
  "[1]::[0]"
  (getName [] java/lang/String)
  (getBounds [] [java/lang/reflect/Type]))

(import java/lang/reflect/Modifier
  "[1]::[0]"
  ("static" isStatic [int] boolean)
  ("static" isFinal [int] boolean)
  ("static" isInterface [int] boolean)
  ("static" isAbstract [int] boolean)
  ("static" isPublic [int] boolean)
  ("static" isProtected [int] boolean))

(import java/lang/annotation/Annotation
  "[1]::[0]")

(import java/lang/reflect/Method
  "[1]::[0]"
  (getName [] java/lang/String)
  (getModifiers [] int)
  (getDeclaringClass [] (java/lang/Class java/lang/Object))
  (getTypeParameters [] [(java/lang/reflect/TypeVariable java/lang/reflect/Method)])
  (getGenericParameterTypes [] [java/lang/reflect/Type])
  (getDeclaredAnnotations [] [java/lang/annotation/Annotation])
  
  (getReturnType [] (java/lang/Class java/lang/Object))
  (getGenericReturnType [] "?" java/lang/reflect/Type)
  
  (getExceptionTypes [] [(java/lang/Class java/lang/Object)])
  (getGenericExceptionTypes [] [java/lang/reflect/Type]))

(import (java/lang/reflect/Constructor c)
  "[1]::[0]"
  (getModifiers [] int)
  (getDeclaringClass [] (java/lang/Class c))
  (getTypeParameters [] [(java/lang/reflect/TypeVariable (java/lang/reflect/Constructor c))])
  (getGenericParameterTypes [] [java/lang/reflect/Type])
  (getExceptionTypes [] [(java/lang/Class java/lang/Object)])
  (getGenericExceptionTypes [] [java/lang/reflect/Type])
  (getDeclaredAnnotations [] [java/lang/annotation/Annotation]))

(import (java/lang/Class c)
  "[1]::[0]"
  ("static" forName [java/lang/String] "try" (java/lang/Class java/lang/Object))
  (getName [] java/lang/String)
  (getModifiers [] int)
  (isAssignableFrom [(java/lang/Class java/lang/Object)] boolean)
  (getTypeParameters [] [(java/lang/reflect/TypeVariable (java/lang/Class c))])
  (getGenericInterfaces [] [java/lang/reflect/Type])
  (getGenericSuperclass [] "?" java/lang/reflect/Type)
  (getDeclaredField [java/lang/String] "try" java/lang/reflect/Field)
  (getConstructors [] [(java/lang/reflect/Constructor java/lang/Object)])
  (getDeclaredMethods [] [java/lang/reflect/Method])
  (getDeclaredAnnotations [] [java/lang/annotation/Annotation])
  (getSuperclass [] "?" (java/lang/Class java/lang/Object))
  (getInterfaces [] [(java/lang/Class java/lang/Object)]))

(with_template [<name>]
  [(exception.def .public (<name> [class field])
     (exception.Exception [External Text])
     (exception.report
      (list ["Class" (%.text class)]
            ["Field" (%.text field)])))]

  [cannot_set_a_final_field]
  [deprecated_field]
  )

(exception.def .public (deprecated_method [class method type])
  (exception.Exception [External Text .Type])
  (exception.report
   (list ["Class" (%.text class)]
         ["Method" (%.text method)]
         ["Type" (%.type type)])))

(exception.def .public (deprecated_class class)
  (exception.Exception External)
  (exception.report
   (list ["Class" (%.text class)])))

(def (ensure_fresh_class! class_loader name)
  (-> java/lang/ClassLoader External (Operation Any))
  (do phase.monad
    [class (phase.lifted (reflection!.load class_loader name))]
    (phase.assertion ..deprecated_class [name]
                     (|> class
                         java/lang/Class::getDeclaredAnnotations
                         reflection!.deprecated?
                         not))))

(def reflection
  (All (_ category) (-> (Type (<| Return' Value' category)) Text))
  (|>> jvm.reflection reflection.reflection))

(def signature (|>> jvm.signature signature.signature))

(def object_class
  External
  "java.lang.Object")

... TODO: Get rid of this with_template block and use the definition in
... lux/ffi.jvm.lux ASAP
(with_template [<name> <class>]
  [(def .public <name>
     .Type
     {.#Primitive <class> {.#End}})]

  ... Boxes
  [Boolean   box.boolean]
  [Byte      box.byte]
  [Short     box.short]
  [Integer   box.int]
  [Long      box.long]
  [Float     box.float]
  [Double    box.double]
  [Character box.char]
  [String    "java.lang.String"]

  ... Primitives
  [boolean   (reflection.reflection reflection.boolean)]
  [byte      (reflection.reflection reflection.byte)]
  [short     (reflection.reflection reflection.short)]
  [int       (reflection.reflection reflection.int)]
  [long      (reflection.reflection reflection.long)]
  [float     (reflection.reflection reflection.float)]
  [double    (reflection.reflection reflection.double)]
  [char      (reflection.reflection reflection.char)]
  )

(.type Member
  (Record
   [#class External
    #member Text]))

(def member
  (Parser Member)
  (all <>.and <code>.text <code>.text))

(.type Method_Signature
  (Record
   [#method .Type
    #deprecated? Bit
    #throws (List .Type)]))

(with_template [<name>]
  [(exception.def .public (<name> type)
     (exception.Exception .Type)
     (exception.report
      (list ["Type" (%.type type)])))]

  [non_object]
  [non_array]
  [non_parameter]
  [non_jvm_type]
  )

(with_template [<name>]
  [(exception.def .public (<name> class)
     (exception.Exception External)
     (exception.report
      (list ["Class/type" (%.text class)])))]

  [non_interface]
  [non_throwable]
  [primitives_are_not_objects]
  )

(with_template [<name>]
  [(exception.def .public (<name> [class_variables class method method_variables inputsJT hints])
     (exception.Exception [(List (Type Var)) External Text (List (Type Var)) (List (Type Value)) (List Method_Signature)])
     (exception.report
      (list ["Class Variables" (exception.listing ..signature class_variables)]
            ["Class" class]
            ["Method" method]
            ["Method Variables" (exception.listing ..signature method_variables)]
            ["Arguments" (exception.listing ..signature inputsJT)]
            ["Hints" (exception.listing %.type (list#each product.left hints))])))]

  [no_candidates]
  [too_many_candidates]
  )

(exception.def .public (cannot_cast [from to value])
  (exception.Exception [(Type Value) (Type Value) Code])
  (exception.report
   (list ["From" (..signature from)]
         ["To" (..signature to)]
         ["Value" (%.code value)])))

(with_template [<name>]
  [(exception.def .public (<name> message)
     (exception.Exception Text)
     message)]

  [primitives_cannot_have_type_parameters]
  [cannot_possibly_be_an_instance]
  [unknown_type_var]
  )

(def with_conversion_extensions
  (-> Bundle Bundle)
  (|>> (install "jvm_conversion_double_to_float#" (//lux.unary ..double ..float))
       (install "jvm_conversion_double_to_int#" (//lux.unary ..double ..int))
       (install "jvm_conversion_double_to_long#" (//lux.unary ..double ..long))
       (install "jvm_conversion_float_to_double#" (//lux.unary ..float ..double))
       (install "jvm_conversion_float_to_int#" (//lux.unary ..float ..int))
       (install "jvm_conversion_float_to_long#" (//lux.unary ..float ..long))
       (install "jvm_conversion_int_to_byte#" (//lux.unary ..int ..byte))
       (install "jvm_conversion_int_to_char#" (//lux.unary ..int ..char))
       (install "jvm_conversion_int_to_double#" (//lux.unary ..int ..double))
       (install "jvm_conversion_int_to_float#" (//lux.unary ..int ..float))
       (install "jvm_conversion_int_to_long#" (//lux.unary ..int ..long))
       (install "jvm_conversion_int_to_short#" (//lux.unary ..int ..short))
       (install "jvm_conversion_long_to_double#" (//lux.unary ..long ..double))
       (install "jvm_conversion_long_to_float#" (//lux.unary ..long ..float))
       (install "jvm_conversion_long_to_int#" (//lux.unary ..long ..int))
       (install "jvm_conversion_long_to_short#" (//lux.unary ..long ..short))
       (install "jvm_conversion_long_to_byte#" (//lux.unary ..long ..byte))
       (install "jvm_conversion_char_to_byte#" (//lux.unary ..char ..byte))
       (install "jvm_conversion_char_to_short#" (//lux.unary ..char ..short))
       (install "jvm_conversion_char_to_int#" (//lux.unary ..char ..int))
       (install "jvm_conversion_char_to_long#" (//lux.unary ..char ..long))
       (install "jvm_conversion_byte_to_long#" (//lux.unary ..byte ..long))
       (install "jvm_conversion_short_to_long#" (//lux.unary ..short ..long))
       ))

(with_template [<name> <prefix> <type>]
  [(def <name>
     (-> Bundle Bundle)
     (let [type (reflection.reflection <prefix>)]
       (|>> (install (%.format "jvm_" type "_" "+" "#") (//lux.binary <type> <type> <type>))
            (install (%.format "jvm_" type "_" "-" "#") (//lux.binary <type> <type> <type>))
            (install (%.format "jvm_" type "_" "*" "#") (//lux.binary <type> <type> <type>))
            (install (%.format "jvm_" type "_" "/" "#") (//lux.binary <type> <type> <type>))
            (install (%.format "jvm_" type "_" "%" "#") (//lux.binary <type> <type> <type>))
            (install (%.format "jvm_" type "_" "=" "#") (//lux.binary <type> <type> Bit))
            (install (%.format "jvm_" type "_" "<" "#") (//lux.binary <type> <type> Bit))
            (install (%.format "jvm_" type "_" "and" "#") (//lux.binary <type> <type> <type>))
            (install (%.format "jvm_" type "_" "or" "#") (//lux.binary <type> <type> <type>))
            (install (%.format "jvm_" type "_" "xor" "#") (//lux.binary <type> <type> <type>))
            (install (%.format "jvm_" type "_" "shl" "#") (//lux.binary ..int <type> <type>))
            (install (%.format "jvm_" type "_" "shr" "#") (//lux.binary ..int <type> <type>))
            (install (%.format "jvm_" type "_" "ushr" "#") (//lux.binary ..int <type> <type>))
            )))]

  [with_int_extensions  reflection.int  ..int]
  [with_long_extensions reflection.long ..long]
  )

(with_template [<name> <prefix> <type>]
  [(def <name>
     (-> Bundle Bundle)
     (let [type (reflection.reflection <prefix>)]
       (|>> (install (%.format "jvm_" type "_" "+" "#") (//lux.binary <type> <type> <type>))
            (install (%.format "jvm_" type "_" "-" "#") (//lux.binary <type> <type> <type>))
            (install (%.format "jvm_" type "_" "*" "#") (//lux.binary <type> <type> <type>))
            (install (%.format "jvm_" type "_" "/" "#") (//lux.binary <type> <type> <type>))
            (install (%.format "jvm_" type "_" "%" "#") (//lux.binary <type> <type> <type>))
            (install (%.format "jvm_" type "_" "=" "#") (//lux.binary <type> <type> Bit))
            (install (%.format "jvm_" type "_" "<" "#") (//lux.binary <type> <type> Bit))
            )))]

  [with_float_extensions  reflection.float  ..float]
  [with_double_extensions reflection.double ..double]
  )

(def with_char_extensions
  (-> Bundle Bundle)
  (let [type (reflection.reflection reflection.char)]
    (|>> (install (%.format "jvm_" type "_" "=" "#") (//lux.binary ..char ..char Bit))
         (install (%.format "jvm_" type "_" "<" "#") (//lux.binary ..char ..char Bit))
         )))

(def .public boxes
  (Dictionary External [External (Type Primitive)])
  (|> (list [(reflection.reflection reflection.boolean) [box.boolean jvm.boolean]]
            [(reflection.reflection reflection.byte)    [box.byte jvm.byte]]
            [(reflection.reflection reflection.short)   [box.short jvm.short]]
            [(reflection.reflection reflection.int)     [box.int jvm.int]]
            [(reflection.reflection reflection.long)    [box.long jvm.long]]
            [(reflection.reflection reflection.float)   [box.float jvm.float]]
            [(reflection.reflection reflection.double)  [box.double jvm.double]]
            [(reflection.reflection reflection.char)    [box.char jvm.char]])
      (dictionary.of_list text.hash)))

(def lux_array_type
  (template (_ :read: :write:)
    [{.#Primitive array.primitive (list {.#Apply :write: {.#Apply :read: _Mutable}})}]))

(def (jvm_type luxT)
  (-> .Type (Operation (Type Value)))
  (when luxT
    {.#Named name anonymousT}
    (jvm_type anonymousT)
    
    {.#Apply inputT abstractionT}
    (when (type.applied (list inputT) abstractionT)
      {.#Some outputT}
      (jvm_type outputT)

      {.#None}
      (/////analysis.except ..non_jvm_type luxT))

    (lux_array_type elemT _)
    (phase#each jvm.array (jvm_type elemT))

    {.#Primitive class parametersT}
    (when (dictionary.value class ..boxes)
      {.#Some [_ primitive_type]}
      (when parametersT
        {.#End}
        (phase#in primitive_type)

        _
        (/////analysis.except ..primitives_cannot_have_type_parameters class))

      {.#None}
      (do [! phase.monad]
        [parametersJT (is (Operation (List (Type Parameter)))
                          (monad.each !
                                      (function (_ parameterT)
                                        (do phase.monad
                                          [parameterJT (jvm_type parameterT)]
                                          (when (parser.parameter? parameterJT)
                                            {.#Some parameterJT}
                                            (in parameterJT)
                                            
                                            {.#None}
                                            (/////analysis.except ..non_parameter parameterT))))
                                      parametersT))]
        (in (jvm.class class parametersJT))))

    {.#Ex _}
    (phase#in (jvm.class ..object_class (list)))

    {.#Function _}
    (phase#in function.class)
    
    _
    (/////analysis.except ..non_jvm_type luxT)))

(def (jvm_array_type objectT)
  (-> .Type (Operation (Type Array)))
  (do phase.monad
    [objectJ (jvm_type objectT)]
    (|> objectJ
        ..signature
        (<text>.result parser.array)
        phase.lifted)))

(def (primitive_array_length_handler primitive_type)
  (-> (Type Primitive) (-> Text Handler))
  (..custom
   [<code>.any
    (function (_ extension_name analyse archive [arrayC])
      (do phase.monad
        [_ (typeA.inference ..int)
         arrayA (<| (typeA.expecting {.#Primitive (|> (jvm.array primitive_type)
                                                      ..reflection)
                                                  (list)})
                    (analyse archive arrayC))]
        (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                      (list arrayA)})))]))

(def array::length::object
  (-> Text Handler)
  (..custom
   [<code>.any
    (function (_ extension_name analyse archive [arrayC])
      (<| typeA.with_var
          (function (_ [@read :read:]))
          typeA.with_var
          (function (_ [@write :write:]))
          (do phase.monad
            [_ (typeA.inference ..int)
             arrayA (<| (typeA.expecting (.type_literal (array.Array' :read: :write:)))
                        (analyse archive arrayC))
             :read: (typeA.check (check.clean (list) :read:))
             :write: (typeA.check (check.clean (list) :write:))
             arrayJT (jvm_array_type (.type_literal (array.Array' :read: :write:)))]
            (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                          (list (/////analysis.text (..signature arrayJT))
                                                arrayA)}))))]))

(def (new_primitive_array_handler primitive_type)
  (-> (Type Primitive) (-> Text Handler))
  (..custom
   [<code>.any
    (function (_ extension_name analyse archive [lengthC])
      (do phase.monad
        [lengthA (<| (typeA.expecting ..int)
                     (analyse archive lengthC))
         _ (typeA.inference {.#Primitive (|> (jvm.array primitive_type) ..reflection)
                                         (list)})]
        (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                      (list lengthA)})))]))

(def array::new::object
  (-> Text Handler)
  (..custom
   [<code>.any
    (function (_ extension_name analyse archive [lengthC])
      (do phase.monad
        [lengthA (<| (typeA.expecting ..int)
                     (analyse archive lengthC))
         expectedT meta.expected_type
         expectedJT (jvm_array_type expectedT)
         elementJT (when (parser.array? expectedJT)
                     {.#Some elementJT}
                     (in elementJT)
                     
                     {.#None}
                     (/////analysis.except ..non_array expectedT))]
        (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                      (list (/////analysis.text (..signature elementJT))
                                            lengthA)})))]))

(def (check_parameter objectT)
  (-> .Type (Operation (Type Parameter)))
  (when objectT
    (lux_array_type elementT _)
    (/////analysis.except ..non_parameter objectT)
    
    {.#Primitive name parameters}
    (`` (cond (or (,, (with_template [<type>]
                        [(text#= (..reflection <type>) name)]

                        [jvm.boolean]
                        [jvm.byte]
                        [jvm.short]
                        [jvm.int]
                        [jvm.long]
                        [jvm.float]
                        [jvm.double]
                        [jvm.char]))
                  (text.starts_with? descriptor.array_prefix name))
              (/////analysis.except ..non_parameter objectT)

              ... else
              (phase#in (jvm.class name (list)))))

    {.#Named name anonymous}
    (check_parameter anonymous)

    {.#Var @var}
    (do phase.monad
      [:var: (typeA.check (check.peek @var))]
      (when :var:
        {.#Some :var:}
        (check_parameter :var:)
        
        {.#None}
        (in (jvm.class ..object_class (list)))))

    (^.or {.#Ex id}
          {.#Parameter id})
    (phase#in (jvm.class ..object_class (list)))

    (^.with_template [<tag>]
      [{<tag> env unquantified}
       (check_parameter unquantified)])
    ([.#UnivQ]
     [.#ExQ])

    {.#Apply inputT abstractionT}
    (when (type.applied (list inputT) abstractionT)
      {.#Some outputT}
      (check_parameter outputT)

      {.#None}
      (/////analysis.except ..non_parameter objectT))

    {.#Function _}
    (phase#in function.class)

    _
    (/////analysis.except ..non_parameter objectT)))

(def (check_jvm objectT)
  (-> .Type (Operation (Type Value)))
  (when objectT
    {.#Primitive name {.#End}}
    (`` (cond (,, (with_template [<type>]
                    [(text#= (..reflection <type>) name)
                     (phase#in <type>)]

                    [jvm.boolean]
                    [jvm.byte]
                    [jvm.short]
                    [jvm.int]
                    [jvm.long]
                    [jvm.float]
                    [jvm.double]
                    [jvm.char]))

              (,, (with_template [<type>]
                    [(text#= (..reflection (jvm.array <type>)) name)
                     (phase#in (jvm.array <type>))]

                    [jvm.boolean]
                    [jvm.byte]
                    [jvm.short]
                    [jvm.int]
                    [jvm.long]
                    [jvm.float]
                    [jvm.double]
                    [jvm.char]))

              (text.starts_with? descriptor.array_prefix name)
              (let [[_ unprefixed] (maybe.trusted (text.split_by descriptor.array_prefix name))]
                (at phase.monad each jvm.array
                    (check_jvm {.#Primitive unprefixed (list)})))

              ... else
              (phase#in (jvm.class name (list)))))

    (lux_array_type elementT _)
    (|> elementT
        check_jvm
        (phase#each jvm.array))
    
    {.#Primitive name parameters}
    (do [! phase.monad]
      [parameters (monad.each ! check_parameter parameters)]
      (phase#in (jvm.class name parameters)))

    {.#Named name anonymous}
    (check_jvm anonymous)

    (^.with_template [<tag>]
      [{<tag> env unquantified}
       (check_jvm unquantified)])
    ([.#UnivQ]
     [.#ExQ])

    {.#Apply inputT abstractionT}
    (when (type.applied (list inputT) abstractionT)
      {.#Some outputT}
      (check_jvm outputT)

      {.#None}
      (/////analysis.except ..non_object objectT))

    _
    (check_parameter objectT)))

(with_template [<name> <category> <parser>]
  [(def .public (<name> mapping typeJ)
     (-> Mapping (Type <category>) (Operation .Type))
     (when (|> typeJ ..signature (<text>.result (<parser> mapping)))
       {try.#Success check}
       (typeA.check check)
       
       {try.#Failure error}
       (phase.failure error)))]

  [boxed_reflection_type Value luxT.boxed_type]
  [reflection_type Value luxT.type]
  [boxed_reflection_return Return luxT.boxed_return]
  [reflection_return Return luxT.return]
  )

(def (check_object objectT)
  (-> .Type (Operation [External .Type]))
  (do [! phase.monad]
    [:object: (check_jvm objectT)
     .let [name (..reflection :object:)]]
    (if (dictionary.key? ..boxes name)
      (/////analysis.except ..primitives_are_not_objects [name])
      (do !
        [:object: (reflection_type luxT.fresh :object:)]
        (phase#in [name :object:])))))

(def (check_return type)
  (-> .Type (Operation (Type Return)))
  (if (same? .Any type)
    (phase#in jvm.void)
    (check_jvm type)))

(def (read_primitive_array_handler lux_type jvm_type)
  (-> .Type (Type Primitive) (-> Text Handler))
  (..custom
   [(<>.and <code>.any <code>.any)
    (function (_ extension_name analyse archive [idxC arrayC])
      (do phase.monad
        [_ (typeA.inference lux_type)
         idxA (<| (typeA.expecting ..int)
                  (analyse archive idxC))
         arrayA (<| (typeA.expecting {.#Primitive (|> (jvm.array jvm_type) ..reflection)
                                                  (list)})
                    (analyse archive arrayC))]
        (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                      (list idxA arrayA)})))]))

(def array::read::object
  (-> Text Handler)
  (..custom
   [(<>.and <code>.any <code>.any)
    (function (_ extension_name analyse archive [idxC arrayC])
      (<| typeA.with_var
          (function (_ [@read :read:]))
          typeA.with_var
          (function (_ [@write :write:]))
          (do phase.monad
            [_ (typeA.inference :read:)
             arrayA (<| (typeA.expecting (.type_literal (array.Array' :read: :write:)))
                        (analyse archive arrayC))
             idxA (<| (typeA.expecting ..int)
                      (analyse archive idxC))
             :read: (typeA.check (check.clean (list) :read:))
             :write: (typeA.check (check.clean (list) :write:))
             arrayJT (jvm_array_type (.type_literal (array.Array' :read: :write:)))]
            (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                          (list (/////analysis.text (..signature arrayJT))
                                                idxA
                                                arrayA)}))))]))

(def (write_primitive_array_handler lux_type jvm_type)
  (-> .Type (Type Primitive) (-> Text Handler))
  (let [array_type {.#Primitive (|> (jvm.array jvm_type) ..reflection)
                                (list)}]
    (..custom
     [(all <>.and <code>.any <code>.any <code>.any)
      (function (_ extension_name analyse archive [idxC valueC arrayC])
        (do phase.monad
          [_ (typeA.inference array_type)
           idxA (<| (typeA.expecting ..int)
                    (analyse archive idxC))
           valueA (<| (typeA.expecting lux_type)
                      (analyse archive valueC))
           arrayA (<| (typeA.expecting array_type)
                      (analyse archive arrayC))]
          (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                        (list idxA
                                              valueA
                                              arrayA)})))])))

(def array::write::object
  (-> Text Handler)
  (..custom
   [(all <>.and <code>.any <code>.any <code>.any)
    (function (_ extension_name analyse archive [idxC valueC arrayC])
      (<| typeA.with_var
          (function (_ [@read :read:]))
          typeA.with_var
          (function (_ [@write :write:]))
          (do phase.monad
            [_ (typeA.inference (.type_literal (array.Array' :read: :write:)))
             arrayA (<| (typeA.expecting (.type_literal (array.Array' :read: :write:)))
                        (analyse archive arrayC))
             idxA (<| (typeA.expecting ..int)
                      (analyse archive idxC))
             valueA (<| (typeA.expecting :write:)
                        (analyse archive valueC))
             :read: (typeA.check (check.clean (list) :read:))
             :write: (typeA.check (check.clean (list) :write:))
             arrayJT (jvm_array_type (.type_literal (array.Array' :read: :write:)))]
            (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                          (list (/////analysis.text (..signature arrayJT))
                                                idxA
                                                valueA
                                                arrayA)}))))]))

(def with_array_extensions
  (-> Bundle Bundle)
  (|>> (install (%.format "jvm_" "array_" "length_" (reflection.reflection reflection.boolean) "#") (primitive_array_length_handler jvm.boolean))
       (install (%.format "jvm_" "array_" "length_" (reflection.reflection reflection.byte) "#") (primitive_array_length_handler jvm.byte))
       (install (%.format "jvm_" "array_" "length_" (reflection.reflection reflection.short) "#") (primitive_array_length_handler jvm.short))
       (install (%.format "jvm_" "array_" "length_" (reflection.reflection reflection.int) "#") (primitive_array_length_handler jvm.int))
       (install (%.format "jvm_" "array_" "length_" (reflection.reflection reflection.long) "#") (primitive_array_length_handler jvm.long))
       (install (%.format "jvm_" "array_" "length_" (reflection.reflection reflection.float) "#") (primitive_array_length_handler jvm.float))
       (install (%.format "jvm_" "array_" "length_" (reflection.reflection reflection.double) "#") (primitive_array_length_handler jvm.double))
       (install (%.format "jvm_" "array_" "length_" (reflection.reflection reflection.char) "#") (primitive_array_length_handler jvm.char))
       (install (%.format "jvm_" "array_" "length_" "object" "#") array::length::object)

       (install (%.format "jvm_" "array_" "new_" (reflection.reflection reflection.boolean) "#") (new_primitive_array_handler jvm.boolean))
       (install (%.format "jvm_" "array_" "new_" (reflection.reflection reflection.byte) "#") (new_primitive_array_handler jvm.byte))
       (install (%.format "jvm_" "array_" "new_" (reflection.reflection reflection.short) "#") (new_primitive_array_handler jvm.short))
       (install (%.format "jvm_" "array_" "new_" (reflection.reflection reflection.int) "#") (new_primitive_array_handler jvm.int))
       (install (%.format "jvm_" "array_" "new_" (reflection.reflection reflection.long) "#") (new_primitive_array_handler jvm.long))
       (install (%.format "jvm_" "array_" "new_" (reflection.reflection reflection.float) "#") (new_primitive_array_handler jvm.float))
       (install (%.format "jvm_" "array_" "new_" (reflection.reflection reflection.double) "#") (new_primitive_array_handler jvm.double))
       (install (%.format "jvm_" "array_" "new_" (reflection.reflection reflection.char) "#") (new_primitive_array_handler jvm.char))
       (install (%.format "jvm_" "array_" "new_" "object" "#") array::new::object)

       (install (%.format "jvm_" "array_" "read_" (reflection.reflection reflection.boolean) "#") (read_primitive_array_handler ..boolean jvm.boolean))
       (install (%.format "jvm_" "array_" "read_" (reflection.reflection reflection.byte) "#") (read_primitive_array_handler ..byte jvm.byte))
       (install (%.format "jvm_" "array_" "read_" (reflection.reflection reflection.short) "#") (read_primitive_array_handler ..short jvm.short))
       (install (%.format "jvm_" "array_" "read_" (reflection.reflection reflection.int) "#") (read_primitive_array_handler ..int jvm.int))
       (install (%.format "jvm_" "array_" "read_" (reflection.reflection reflection.long) "#") (read_primitive_array_handler ..long jvm.long))
       (install (%.format "jvm_" "array_" "read_" (reflection.reflection reflection.float) "#") (read_primitive_array_handler ..float jvm.float))
       (install (%.format "jvm_" "array_" "read_" (reflection.reflection reflection.double) "#") (read_primitive_array_handler ..double jvm.double))
       (install (%.format "jvm_" "array_" "read_" (reflection.reflection reflection.char) "#") (read_primitive_array_handler ..char jvm.char))
       (install (%.format "jvm_" "array_" "read_" "object" "#") array::read::object)

       (install (%.format "jvm_" "array_" "write_" (reflection.reflection reflection.boolean) "#") (write_primitive_array_handler ..boolean jvm.boolean))
       (install (%.format "jvm_" "array_" "write_" (reflection.reflection reflection.byte) "#") (write_primitive_array_handler ..byte jvm.byte))
       (install (%.format "jvm_" "array_" "write_" (reflection.reflection reflection.short) "#") (write_primitive_array_handler ..short jvm.short))
       (install (%.format "jvm_" "array_" "write_" (reflection.reflection reflection.int) "#") (write_primitive_array_handler ..int jvm.int))
       (install (%.format "jvm_" "array_" "write_" (reflection.reflection reflection.long) "#") (write_primitive_array_handler ..long jvm.long))
       (install (%.format "jvm_" "array_" "write_" (reflection.reflection reflection.float) "#") (write_primitive_array_handler ..float jvm.float))
       (install (%.format "jvm_" "array_" "write_" (reflection.reflection reflection.double) "#") (write_primitive_array_handler ..double jvm.double))
       (install (%.format "jvm_" "array_" "write_" (reflection.reflection reflection.char) "#") (write_primitive_array_handler ..char jvm.char))
       (install (%.format "jvm_" "array_" "write_" "object" "#") array::write::object)
       ))

(def object::null
  (-> Text Handler)
  (..custom
   [<code>.end
    (function (_ extension_name analyse archive [])
      (do phase.monad
        [expectedT meta.expected_type
         [_ :object:] (check_object expectedT)
         _ (typeA.inference :object:)]
        (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                      (list)})))]))

(def object::null?
  (-> Text Handler)
  (..custom
   [<code>.any
    (function (_ extension_name analyse archive [objectC])
      (do phase.monad
        [_ (typeA.inference .Bit)
         [objectT objectA] (typeA.inferring
                            (analyse archive objectC))
         _ (check_object objectT)]
        (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                      (list objectA)})))]))

(def object::synchronized
  (-> Text Handler)
  (..custom
   [(<>.and <code>.any <code>.any)
    (function (_ extension_name analyse archive [monitorC exprC])
      (do phase.monad
        [[monitorT monitorA] (typeA.inferring
                              (analyse archive monitorC))
         _ (check_object monitorT)
         exprA (analyse archive exprC)]
        (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                      (list monitorA exprA)})))]))

(def (object::throw class_loader)
  (-> java/lang/ClassLoader (-> Text Handler))
  (..custom
   [<code>.any
    (function (_ extension_name analyse archive [exceptionC])
      (do phase.monad
        [_ (typeA.inference Nothing)
         [exceptionT exceptionA] (typeA.inferring
                                  (analyse archive exceptionC))
         [exception_class _] (check_object exceptionT)
         ? (phase.lifted (reflection!.sub? class_loader "java.lang.Throwable" exception_class))
         _ (is (Operation Any)
               (if ?
                 (in [])
                 (/////analysis.except non_throwable exception_class)))]
        (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                      (list exceptionA)})))]))

(def (object::class class_loader)
  (-> java/lang/ClassLoader (-> Text Handler))
  (..custom
   [<code>.text
    (function (_ extension_name analyse archive [class])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         _ (typeA.inference {.#Primitive "java.lang.Class" (list {.#Primitive class (list)})})
         _ (phase.lifted (reflection!.load class_loader class))]
        (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                      (list (/////analysis.text class))})))]))

(def (object::instance? class_loader)
  (-> java/lang/ClassLoader (-> Text Handler))
  (..custom
   [(all <>.and <code>.text <code>.any)
    (function (_ extension_name analyse archive [sub_class objectC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader sub_class)
         _ (typeA.inference Bit)
         [objectT objectA] (typeA.inferring
                            (analyse archive objectC))
         [object_class _] (check_object objectT)
         ? (phase.lifted (reflection!.sub? class_loader object_class sub_class))]
        (if ?
          (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                        (list (/////analysis.text sub_class) objectA)})
          (/////analysis.except cannot_possibly_be_an_instance (format sub_class " !<= "  object_class)))))]))

(def (class_candidate_parents class_loader from_name fromT to_name to_class)
  (-> java/lang/ClassLoader External .Type External (java/lang/Class java/lang/Object) (Operation (List [[Text .Type] Bit])))
  (do [! phase.monad]
    [from_class (phase.lifted (reflection!.load class_loader from_name))
     mapping (phase.lifted (reflection!.correspond from_class fromT))]
    (monad.each !
                (function (_ superJT)
                  (do !
                    [superJT (phase.lifted (reflection!.type superJT))
                     .let [super_name (..reflection superJT)]
                     super_class (phase.lifted (reflection!.load class_loader super_name))
                     superT (reflection_type mapping superJT)]
                    (in [[super_name superT] (java/lang/Class::isAssignableFrom super_class to_class)])))
                (when (java/lang/Class::getGenericSuperclass from_class)
                  {.#Some super}
                  (list.partial super (array.list {.#None} (java/lang/Class::getGenericInterfaces from_class)))

                  {.#None}
                  (if (java/lang/reflect/Modifier::isInterface (java/lang/Class::getModifiers from_class))
                    {.#Item (as java/lang/reflect/Type (ffi.class_for java/lang/Object))
                            (array.list {.#None} (java/lang/Class::getGenericInterfaces from_class))}
                    (array.list {.#None} (java/lang/Class::getGenericInterfaces from_class)))))))

(def (object::cast class_loader)
  (-> java/lang/ClassLoader (-> Text Handler))
  (..custom
   [<code>.any
    (function (_ extension_name analyse archive [fromC])
      (do [! phase.monad]
        [toT meta.expected_type
         toJT (check_jvm toT)
         [fromT fromA] (typeA.inferring
                        (analyse archive fromC))
         fromJT (check_jvm fromT)
         .let [from_name (..reflection fromJT)
               to_name (..reflection toJT)]
         can_cast? (is (Operation Bit)
                       (`` (cond (,, (with_template [<primitive> <object>]
                                       [(let [=primitive (reflection.reflection <primitive>)]
                                          (or (and (text#= =primitive from_name)
                                                   (or (text#= <object> to_name)
                                                       (text#= =primitive to_name)))
                                              (and (text#= <object> from_name)
                                                   (text#= =primitive to_name))))
                                        (in true)]

                                       [reflection.boolean box.boolean]
                                       [reflection.byte    box.byte]
                                       [reflection.short   box.short]
                                       [reflection.int     box.int]
                                       [reflection.long    box.long]
                                       [reflection.float   box.float]
                                       [reflection.double  box.double]
                                       [reflection.char    box.char]))

                                 ... else
                                 (do !
                                   [_ (phase.assertion ..primitives_are_not_objects [from_name]
                                                       (not (dictionary.key? ..boxes from_name)))
                                    _ (phase.assertion ..primitives_are_not_objects [to_name]
                                                       (not (dictionary.key? ..boxes to_name)))
                                    to_class (phase.lifted (reflection!.load class_loader to_name))
                                    from_class (phase.lifted (reflection!.load class_loader from_name))]
                                   (if (java/lang/Class::isAssignableFrom from_class to_class)
                                     (loop (again [[current_name currentT] [from_name fromT]])
                                       (if (text#= to_name current_name)
                                         (in true)
                                         (do !
                                           [candidate_parents (is (Operation (List [[Text .Type] Bit]))
                                                                  (class_candidate_parents class_loader current_name currentT to_name to_class))]
                                           (when (|> candidate_parents
                                                     (list.only product.right)
                                                     (list#each product.left))
                                             {.#Item [next_name nextT] _}
                                             (again [next_name nextT])

                                             {.#End}
                                             (in false)))))
                                     (in (when [(type#= java/lang/Object fromT)
                                                (parser.array? toJT)]
                                           [.true {.#Some _}]
                                           true
                                           
                                           _
                                           false)))))))]
        (if can_cast?
          (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                        (list (/////analysis.text from_name)
                                              (/////analysis.text to_name)
                                              fromA)})
          (/////analysis.except ..cannot_cast [fromJT toJT fromC]))))]))

(def (with_object_extensions class_loader)
  (-> java/lang/ClassLoader (-> Bundle Bundle))
  (|>> (install (%.format "jvm_" "object_" "null" "#") object::null)
       (install (%.format "jvm_" "object_" "null?" "#") object::null?)
       (install (%.format "jvm_" "object_" "synchronized" "#") object::synchronized)
       (install (%.format "jvm_" "object_" "throw" "#") (object::throw class_loader))
       (install (%.format "jvm_" "object_" "class" "#") (object::class class_loader))
       (install (%.format "jvm_" "object_" "instance?" "#") (object::instance? class_loader))
       (install (%.format "jvm_" "object_" "cast" "#") (object::cast class_loader))
       ))

(def (get::static class_loader)
  (-> java/lang/ClassLoader (-> Text Handler))
  (..custom
   [..member
    (function (_ extension_name analyse archive [class field])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         [final? deprecated? fieldJT] (phase.lifted
                                       (do try.monad
                                         [class (reflection!.load class_loader class)]
                                         (reflection!.static_field field class)))
         _ (phase.assertion ..deprecated_field [class field]
                            (not deprecated?))
         fieldT (reflection_type luxT.fresh fieldJT)
         _ (typeA.inference fieldT)]
        (in (<| {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]}
                (list (/////analysis.text class)
                      (/////analysis.text field)
                      (/////analysis.text (..signature fieldJT)))))))]))

(def (put::static class_loader)
  (-> java/lang/ClassLoader (-> Text Handler))
  (..custom
   [(all <>.and ..member <code>.any)
    (function (_ extension_name analyse archive [[class field] valueC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         _ (typeA.inference Any)
         [final? deprecated? fieldJT] (phase.lifted
                                       (do try.monad
                                         [class (reflection!.load class_loader class)]
                                         (reflection!.static_field field class)))
         _ (phase.assertion ..deprecated_field [class field]
                            (not deprecated?))
         ... _ (phase.assertion ..cannot_set_a_final_field [class field]
         ...                    (not final?))
         fieldT (reflection_type luxT.fresh fieldJT)
         valueA (<| (typeA.expecting fieldT)
                    (analyse archive valueC))]
        (in (<| {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]}
                (list (/////analysis.text class)
                      (/////analysis.text field)
                      (/////analysis.text (..signature fieldJT))
                      valueA)))))]))

(def (get::virtual class_loader)
  (-> java/lang/ClassLoader (-> Text Handler))
  (..custom
   [(all <>.and ..member <code>.any)
    (function (_ extension_name analyse archive [[class field] objectC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         [objectT objectA] (typeA.inferring
                            (analyse archive objectC))
         [deprecated? mapping fieldJT] (phase.lifted
                                        (do try.monad
                                          [class (reflection!.load class_loader class)
                                           [final? deprecated? fieldJT] (reflection!.virtual_field field class)
                                           mapping (reflection!.correspond class objectT)]
                                          (in [deprecated? mapping fieldJT])))
         _ (phase.assertion ..deprecated_field [class field]
                            (not deprecated?))
         fieldT (reflection_type mapping fieldJT)
         _ (typeA.inference fieldT)]
        (in (<| {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]}
                (list (/////analysis.text class)
                      (/////analysis.text field)
                      (/////analysis.text (..signature fieldJT))
                      objectA)))))]))

(def (put::virtual class_loader)
  (-> java/lang/ClassLoader (-> Text Handler))
  (..custom
   [(all <>.and ..member <code>.any <code>.any)
    (function (_ extension_name analyse archive [[class field] valueC objectC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         [objectT objectA] (typeA.inferring
                            (analyse archive objectC))
         _ (typeA.inference objectT)
         [final? deprecated? mapping fieldJT] (phase.lifted
                                               (do try.monad
                                                 [class (reflection!.load class_loader class)
                                                  [final? deprecated? fieldJT] (reflection!.virtual_field field class)
                                                  mapping (reflection!.correspond class objectT)]
                                                 (in [final? deprecated? mapping fieldJT])))
         _ (phase.assertion ..deprecated_field [class field]
                            (not deprecated?))
         _ (phase.assertion ..cannot_set_a_final_field [class field]
                            (not final?))
         fieldT (reflection_type mapping fieldJT)
         valueA (<| (typeA.expecting fieldT)
                    (analyse archive valueC))]
        (in (<| {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]}
                (list (/////analysis.text class)
                      (/////analysis.text field)
                      (/////analysis.text (..signature fieldJT))
                      valueA
                      objectA)))))]))

(.type Method_Style
  (Variant
   {#Static}
   {#Abstract}
   {#Virtual}
   {#Special}
   {#Interface}))

(def (de_aliased aliasing)
  (-> Aliasing (Type Value) (Type Value))
  (function (again it)
    (`` (<| (when (parser.var? it)
              {.#Some name}
              (|> aliasing
                  (dictionary.value name)
                  (maybe#each jvm.var)
                  (maybe.else it))
              {.#None})
            (when (parser.class? it)
              {.#Some [name parameters]}
              (|> parameters
                  (list#each (|>> again (as (Type Parameter))))
                  (jvm.class name))
              {.#None})
            (,, (with_template [<read> <as> <write>]
                  [(when (<read> it)
                     {.#Some :sub:}
                     (<write> (as (Type <as>) (again :sub:)))
                     {.#None})]

                  [parser.array? Value jvm.array]
                  [parser.lower? Class jvm.lower]
                  [parser.upper? Class jvm.upper]
                  ))
            it))))

(def (check_method aliasing class method_name method_style inputsJT method)
  (-> Aliasing (java/lang/Class java/lang/Object) Text Method_Style (List (Type Value)) java/lang/reflect/Method (Operation Bit))
  (do phase.monad
    [parameters (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                    (array.list {.#None})
                    (monad.each try.monad reflection!.type)
                    phase.lifted)
     .let [modifiers (java/lang/reflect/Method::getModifiers method)
           correct_class? (java/lang/Class::isAssignableFrom class (java/lang/reflect/Method::getDeclaringClass method))
           correct_method? (text#= method_name (java/lang/reflect/Method::getName method))
           same_static? (when method_style
                          {#Static}
                          (java/lang/reflect/Modifier::isStatic modifiers)

                          _
                          true)
           same_special? (when method_style
                           {#Special}
                           (not (or (java/lang/reflect/Modifier::isInterface (java/lang/Class::getModifiers class))
                                    (java/lang/reflect/Modifier::isAbstract modifiers)))

                           _
                           true)
           same_inputs? (and (n.= (list.size inputsJT)
                                  (list.size parameters))
                             (list.every? (function (_ [expectedJC actualJC])
                                            (jvm#= expectedJC (de_aliased aliasing actualJC)))
                                          (list.zipped_2 parameters inputsJT)))]]
    (in (and correct_class?
             correct_method?
             same_static?
             same_special?
             same_inputs?))))

(def (check_constructor aliasing class inputsJT constructor)
  (-> Aliasing (java/lang/Class java/lang/Object) (List (Type Value)) (java/lang/reflect/Constructor java/lang/Object) (Operation Bit))
  (do phase.monad
    [parameters (|> (java/lang/reflect/Constructor::getGenericParameterTypes constructor)
                    (array.list {.#None})
                    (monad.each try.monad reflection!.type)
                    phase.lifted)]
    (in (and (java/lang/Object::equals class (java/lang/reflect/Constructor::getDeclaringClass constructor))
             (n.= (list.size inputsJT) (list.size parameters))
             (list.every? (function (_ [expectedJC actualJC])
                            (jvm#= expectedJC (de_aliased aliasing actualJC)))
                          (list.zipped_2 parameters inputsJT))))))

(def index_parameter
  (-> Nat .Type)
  (|>> (n.* 2) ++ {.#Parameter}))

(def (jvm_type_var_mapping owner_tvars method_tvars)
  (-> (List Text) (List Text) [(List .Type) Mapping])
  (let [jvm_tvars (list#composite owner_tvars method_tvars)
        lux_tvars (|> jvm_tvars
                      list.reversed
                      list.enumeration
                      (list#each (function (_ [idx name])
                                   [name (index_parameter idx)]))
                      list.reversed)
        num_owner_tvars (list.size owner_tvars)
        owner_tvarsT (|> lux_tvars (list.first num_owner_tvars) (list#each product.right))
        mapping (dictionary.of_list text.hash lux_tvars)]
    [owner_tvarsT mapping]))

(def (lux_class it)
  (-> (java/lang/Class java/lang/Object) (Type Class))
  (jvm.class (java/lang/Class::getName it) (list)))

(with_template [<name> <type> <params>]
  [(`` (def <name>
         (-> (<type> (,, (template.spliced <params>))) (List (Type Class)))
         (|>> (,, (template.symbol [<type> "::getExceptionTypes"]))
              (array.list {.#None})
              (list#each ..lux_class))))]

  [concrete_method_exceptions java/lang/reflect/Method []]
  [concrete_constructor_exceptions java/lang/reflect/Constructor [java/lang/Object]]
  )

(def (return_type it)
  (-> java/lang/reflect/Method (Try (Type Return)))
  (reflection!.return
   (when (java/lang/reflect/Method::getGenericReturnType it)
     {.#Some it}
     it
     
     {.#None}
     (java/lang/reflect/Method::getReturnType it))))

(def (method_signature method_style method)
  (-> Method_Style java/lang/reflect/Method (Operation Method_Signature))
  (let [owner (java/lang/reflect/Method::getDeclaringClass method)
        owner_tvars (when method_style
                      {#Static}
                      (list)

                      _
                      (|> (java/lang/Class::getTypeParameters owner)
                          (array.list {.#None})
                          (list#each (|>> java/lang/reflect/TypeVariable::getName))))
        method_tvars (|> (java/lang/reflect/Method::getTypeParameters method)
                         (array.list {.#None})
                         (list#each (|>> java/lang/reflect/TypeVariable::getName)))
        [owner_tvarsT mapping] (jvm_type_var_mapping owner_tvars method_tvars)]
    (do [! phase.monad]
      [inputsT (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                   (array.list {.#None})
                   (monad.each ! (|>> reflection!.type phase.lifted))
                   (phase#each (monad.each ! (..reflection_type mapping)))
                   phase#conjoint)
       outputT (|> method
                   ..return_type
                   phase.lifted
                   (phase#each (..reflection_return mapping))
                   phase#conjoint)
       .let [concrete_exceptions (..concrete_method_exceptions method)]
       concrete_exceptions (monad.each ! (..reflection_type mapping) concrete_exceptions)
       generic_exceptions (|> (java/lang/reflect/Method::getGenericExceptionTypes method)
                              (array.list {.#None})
                              (monad.each ! (|>> reflection!.type phase.lifted))
                              (phase#each (monad.each ! (..reflection_type mapping)))
                              phase#conjoint)
       .let [methodT (<| (type.univ_q (dictionary.size mapping))
                         (type.function (when method_style
                                          {#Static}
                                          inputsT

                                          _
                                          (list.partial {.#Primitive (java/lang/Class::getName owner) owner_tvarsT}
                                                        inputsT)))
                         outputT)]]
      (in [methodT
           (reflection!.deprecated? (java/lang/reflect/Method::getDeclaredAnnotations method))
           (if (list.empty? generic_exceptions)
             concrete_exceptions
             generic_exceptions)]))))

(def (constructor_signature constructor)
  (-> (java/lang/reflect/Constructor java/lang/Object) (Operation Method_Signature))
  (let [owner (java/lang/reflect/Constructor::getDeclaringClass constructor)
        owner_tvars (|> (java/lang/Class::getTypeParameters owner)
                        (array.list {.#None})
                        (list#each (|>> java/lang/reflect/TypeVariable::getName)))
        method_tvars (|> (java/lang/reflect/Constructor::getTypeParameters constructor)
                         (array.list {.#None})
                         (list#each (|>> java/lang/reflect/TypeVariable::getName)))
        [owner_tvarsT mapping] (jvm_type_var_mapping owner_tvars method_tvars)]
    (do [! phase.monad]
      [inputsT (|> (java/lang/reflect/Constructor::getGenericParameterTypes constructor)
                   (array.list {.#None})
                   (monad.each ! (|>> reflection!.type phase.lifted))
                   (phase#each (monad.each ! (reflection_type mapping)))
                   phase#conjoint)
       .let [concrete_exceptions (..concrete_constructor_exceptions constructor)]
       concrete_exceptions (monad.each ! (..reflection_type mapping) concrete_exceptions)
       generic_exceptions (|> (java/lang/reflect/Constructor::getGenericExceptionTypes constructor)
                              (array.list {.#None})
                              (monad.each ! (|>> reflection!.type phase.lifted))
                              (phase#each (monad.each ! (reflection_type mapping)))
                              phase#conjoint)
       .let [objectT {.#Primitive (java/lang/Class::getName owner) owner_tvarsT}
             constructorT (<| (type.univ_q (dictionary.size mapping))
                              (type.function inputsT)
                              objectT)]]
      (in [constructorT
           (reflection!.deprecated? (java/lang/reflect/Constructor::getDeclaredAnnotations constructor))
           (if (list.empty? generic_exceptions)
             concrete_exceptions
             generic_exceptions)]))))

(.type Evaluation
  (Variant
   {#Pass Method_Signature}
   {#Hint Method_Signature}))

(with_template [<name> <tag>]
  [(def <name>
     (-> Evaluation (Maybe Method_Signature))
     (|>> (pipe.when
            {<tag> output}
            {.#Some output}

            _
            {.#None})))]

  [pass #Pass]
  [hint #Hint]
  )

(with_template [<name> <type> <method>]
  [(def <name>
     (-> <type> (List (Type Var)))
     (|>> <method>
          (array.list {.#None})
          (list#each (|>> java/lang/reflect/TypeVariable::getName jvm.var))))]

  [class_type_variables (java/lang/Class java/lang/Object) java/lang/Class::getTypeParameters]
  [constructor_type_variables (java/lang/reflect/Constructor java/lang/Object) java/lang/reflect/Constructor::getTypeParameters]
  [method_type_variables java/lang/reflect/Method java/lang/reflect/Method::getTypeParameters]
  )

(def (aliasing expected actual)
  (-> (List (Type Var)) (List (Type Var)) Aliasing)
  (|> (list.zipped_2 (list#each parser.name actual)
                     (list#each parser.name expected))
      (dictionary.of_list text.hash)))

(def (family_tree' it)
  (-> (java/lang/Class java/lang/Object)
      (List (java/lang/Class java/lang/Object)))
  (let [interfaces (array.list {.#None} (java/lang/Class::getInterfaces it))
        supers (when (java/lang/Class::getSuperclass it)
                 {.#Some class}
                 (list.partial class interfaces)
                 
                 {.#None}
                 interfaces)]
    (|> supers
        (list#each family_tree')
        list#conjoint
        (list.partial it))))

(def family_tree
  (-> (java/lang/Class java/lang/Object)
      (List (java/lang/Class java/lang/Object)))
  (|>> ..family_tree'
       ... De-duplication
       (list#mix (function (_ class all)
                   (dictionary.has (java/lang/Class::getName class) class all))
                 (dictionary.empty text.hash))
       dictionary.values))

(def (all_declared_methods it)
  (-> (java/lang/Class java/lang/Object)
      (List java/lang/reflect/Method))
  (|> it
      ..family_tree
      (list#each (|>> java/lang/Class::getDeclaredMethods (array.list {.#None})))
      list#conjoint))

(def (method_candidate allow_inheritance? class_loader actual_class_tvars class_name actual_method_tvars method_name method_style inputsJT)
  (-> Bit java/lang/ClassLoader (List (Type Var)) External (List (Type Var)) Text Method_Style (List (Type Value)) (Operation Method_Signature))
  (do [! phase.monad]
    [class (phase.lifted (reflection!.load class_loader class_name))
     .let [expected_class_tvars (class_type_variables class)]
     candidates (|> (if allow_inheritance?
                      (all_declared_methods class)
                      (array.list {.#None} (java/lang/Class::getDeclaredMethods class)))
                    (list.only (|>> java/lang/reflect/Method::getName (text#= method_name)))
                    (monad.each ! (is (-> java/lang/reflect/Method (Operation Evaluation))
                                      (function (_ method)
                                        (do !
                                          [.let [expected_method_tvars (method_type_variables method)
                                                 aliasing (dictionary.composite (..aliasing expected_class_tvars actual_class_tvars)
                                                                                (..aliasing expected_method_tvars actual_method_tvars))]
                                           passes? (check_method aliasing class method_name method_style inputsJT method)]
                                          (at ! each (if passes?
                                                       (|>> {#Pass})
                                                       (|>> {#Hint}))
                                              (method_signature method_style method)))))))]
    (when (list.all pass candidates)
      {.#Item method {.#End}}
      (in method)

      {.#End}
      (/////analysis.except ..no_candidates [actual_class_tvars class_name method_name actual_method_tvars inputsJT (list.all hint candidates)])
      
      {.#Item method alternatives}
      (if allow_inheritance?
        (in method)
        (/////analysis.except ..too_many_candidates [actual_class_tvars class_name method_name actual_method_tvars inputsJT (list.partial method alternatives)])))))

(def constructor_method
  "<init>")

(def (constructor_candidate class_loader actual_class_tvars class_name actual_method_tvars inputsJT)
  (-> java/lang/ClassLoader (List (Type Var)) External (List (Type Var)) (List (Type Value)) (Operation Method_Signature))
  (do [! phase.monad]
    [class (phase.lifted (reflection!.load class_loader class_name))
     .let [expected_class_tvars (class_type_variables class)]
     candidates (|> class
                    java/lang/Class::getConstructors
                    (array.list {.#None})
                    (monad.each ! (function (_ constructor)
                                    (do !
                                      [.let [expected_method_tvars (constructor_type_variables constructor)
                                             aliasing (dictionary.composite (..aliasing expected_class_tvars actual_class_tvars)
                                                                            (..aliasing expected_method_tvars actual_method_tvars))]
                                       passes? (check_constructor aliasing class inputsJT constructor)]
                                      (at ! each
                                          (if passes?
                                            (|>> {#Pass})
                                            (|>> {#Hint}))
                                          (constructor_signature constructor))))))]
    (when (list.all pass candidates)
      {.#Item constructor {.#End}}
      (in constructor)

      {.#End}
      (/////analysis.except ..no_candidates [actual_class_tvars class_name ..constructor_method actual_method_tvars inputsJT (list.all hint candidates)])
      
      candidates
      (/////analysis.except ..too_many_candidates [actual_class_tvars class_name ..constructor_method actual_method_tvars inputsJT candidates]))))

(with_template [<name> <category> <parser>]
  [(def .public <name>
     (Parser (Type <category>))
     (<text>.then <parser> <code>.text))]

  [var Var parser.var]
  [class Class parser.class]
  [type Value parser.value]
  [return Return parser.return]
  )

(def input
  (Parser (Typed Code))
  (<code>.tuple (<>.and ..type <code>.any)))

(def (decorate_inputs typesT inputsA)
  (-> (List (Type Value)) (List Analysis) (List Analysis))
  (|> inputsA
      (list.zipped_2 (list#each (|>> ..signature /////analysis.text) typesT))
      (list#each (function (_ [type value])
                   (/////analysis.tuple (list type value))))))

(def type_vars
  (<code>.tuple (<>.some ..var)))

(def (invoke::static class_loader)
  (-> java/lang/ClassLoader (-> Text Handler))
  (..custom
   [(all <>.and ..type_vars ..member ..type_vars (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class method] method_tvars argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         .let [argsT (list#each product.left argsTC)]
         [methodT deprecated? exceptionsT] (..method_candidate false class_loader class_tvars class method_tvars method {#Static} argsT)
         _ (phase.assertion ..deprecated_method [class method methodT]
                            (not deprecated?))
         [outputT argsA] (inference.general archive analyse methodT (list#each product.right argsTC))
         outputJT (check_return outputT)]
        (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                      (list.partial (/////analysis.text (..signature (jvm.class class (list))))
                                                    (/////analysis.text method)
                                                    (/////analysis.text (..signature outputJT))
                                                    (decorate_inputs argsT argsA))})))]))

(def (invoke::virtual class_loader)
  (-> java/lang/ClassLoader (-> Text Handler))
  (..custom
   [(all <>.and ..type_vars ..member ..type_vars <code>.any (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class method] method_tvars objectC argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         .let [argsT (list#each product.left argsTC)]
         [methodT deprecated? exceptionsT] (..method_candidate true class_loader class_tvars class method_tvars method {#Virtual} argsT)
         _ (phase.assertion ..deprecated_method [class method methodT]
                            (not deprecated?))
         [outputT allA] (inference.general archive analyse methodT (list.partial objectC (list#each product.right argsTC)))
         .let [[objectA argsA] (when allA
                                 {.#Item objectA argsA}
                                 [objectA argsA]

                                 _
                                 (undefined))]
         outputJT (check_return outputT)]
        (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                      (list.partial (/////analysis.text (..signature (jvm.class class (list))))
                                                    (/////analysis.text method)
                                                    (/////analysis.text (..signature outputJT))
                                                    objectA
                                                    (decorate_inputs argsT argsA))})))]))

(def (invoke::special class_loader)
  (-> java/lang/ClassLoader (-> Text Handler))
  (..custom
   [(all <>.and ..type_vars ..member ..type_vars <code>.any (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class method] method_tvars objectC argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         .let [argsT (list#each product.left argsTC)]
         [methodT deprecated? exceptionsT] (..method_candidate false class_loader class_tvars class method_tvars method {#Special} argsT)
         _ (phase.assertion ..deprecated_method [class method methodT]
                            (not deprecated?))
         [outputT allA] (inference.general archive analyse methodT (list.partial objectC (list#each product.right argsTC)))
         .let [[objectA argsA] (when allA
                                 {.#Item objectA argsA}
                                 [objectA argsA]

                                 _
                                 (undefined))]
         outputJT (check_return outputT)]
        (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                      (list.partial (/////analysis.text (..signature (jvm.class class (list))))
                                                    (/////analysis.text method)
                                                    (/////analysis.text (..signature outputJT))
                                                    objectA
                                                    (decorate_inputs argsT argsA))})))]))

(def (invoke::interface class_loader)
  (-> java/lang/ClassLoader (-> Text Handler))
  (..custom
   [(all <>.and ..type_vars ..member ..type_vars <code>.any (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class_name method] method_tvars objectC argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class_name)
         .let [argsT (list#each product.left argsTC)]
         class (phase.lifted (reflection!.load class_loader class_name))
         _ (phase.assertion non_interface class_name
                            (java/lang/reflect/Modifier::isInterface (java/lang/Class::getModifiers class)))
         [methodT deprecated? exceptionsT] (..method_candidate true class_loader class_tvars class_name method_tvars method {#Interface} argsT)
         _ (phase.assertion ..deprecated_method [class_name method methodT]
                            (not deprecated?))
         [outputT allA] (inference.general archive analyse methodT (list.partial objectC (list#each product.right argsTC)))
         .let [[objectA argsA] (when allA
                                 {.#Item objectA argsA}
                                 [objectA argsA]

                                 _
                                 (undefined))]
         outputJT (check_return outputT)]
        (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                      (list.partial (/////analysis.text (..signature (jvm.class class_name (list))))
                                                    (/////analysis.text method)
                                                    (/////analysis.text (..signature outputJT))
                                                    objectA
                                                    (decorate_inputs argsT argsA))})))]))

(def (invoke::constructor class_loader)
  (-> java/lang/ClassLoader (-> Text Handler))
  (..custom
   [(all <>.and ..type_vars <code>.text ..type_vars (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars class method_tvars argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         .let [argsT (list#each product.left argsTC)]
         [methodT deprecated? exceptionsT] (..constructor_candidate class_loader class_tvars class method_tvars argsT)
         _ (phase.assertion ..deprecated_method [class ..constructor_method methodT]
                            (not deprecated?))
         [outputT argsA] (inference.general archive analyse methodT (list#each product.right argsTC))]
        (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                      (list.partial (/////analysis.text (..signature (jvm.class class (list))))
                                                    (decorate_inputs argsT argsA))})))]))

(def (with_member_extensions class_loader)
  (-> java/lang/ClassLoader (-> Bundle Bundle))
  (|>> (install "jvm_member_get_static#" (get::static class_loader))
       (install "jvm_member_get_virtual#" (get::virtual class_loader))
       
       (install "jvm_member_put_static#" (put::static class_loader))
       (install "jvm_member_put_virtual#" (put::virtual class_loader))
       
       (install "jvm_member_invoke_static#" (invoke::static class_loader))
       (install "jvm_member_invoke_virtual#" (invoke::virtual class_loader))
       (install "jvm_member_invoke_special#" (invoke::special class_loader))
       (install "jvm_member_invoke_interface#" (invoke::interface class_loader))
       (install "jvm_member_invoke_constructor#" (invoke::constructor class_loader))
       ))

(.type .public (Annotation_Parameter a)
  [Text a])

(def annotation_parameter
  (Parser (Annotation_Parameter Code))
  (<code>.tuple (<>.and <code>.text <code>.any)))

(.type .public (Annotation a)
  [Text (List (Annotation_Parameter a))])

(def .public annotation
  (Parser (Annotation Code))
  (<code>.form (<>.and <code>.text (<>.some ..annotation_parameter))))

(def .public argument
  (Parser Argument)
  (<code>.tuple (<>.and <code>.text ..type)))

(def (annotation_parameter_analysis [name value])
  (-> (Annotation_Parameter Analysis) Analysis)
  (/////analysis.tuple (list (/////analysis.text name) value)))

(def (annotation_analysis [name parameters])
  (-> (Annotation Analysis) Analysis)
  (/////analysis.tuple (list.partial (/////analysis.text name)
                                     (list#each annotation_parameter_analysis parameters))))

(with_template [<name> <category>]
  [(def <name>
     (-> (Type <category>) Analysis)
     (|>> ..signature /////analysis.text))]

  [var_analysis Var]
  [class_analysis Class]
  [value_analysis Value]
  [return_analysis Return]
  )

(def (typed_analysis [type term])
  (-> (Typed Analysis) Analysis)
  (/////analysis.tuple (list (value_analysis type) term)))

(def (argument_analysis [argument argumentJT])
  (-> Argument Analysis)
  (/////analysis.tuple
   (list (/////analysis.text argument)
         (value_analysis argumentJT))))

(with_template [<name> <only> <methods>]
  [(def (<name> [type class])
     (-> [(Type Class) (java/lang/Class java/lang/Object)]
         (Try (List [(Type Class) Text (Type Method)])))
     (|> class
         <methods>
         (list.only (|>> java/lang/reflect/Method::getModifiers
                         (predicate.or (|>> java/lang/reflect/Modifier::isPublic)
                                       (|>> java/lang/reflect/Modifier::isProtected))))
         <only>
         (monad.each try.monad
                     (function (_ method)
                       (do [! try.monad]
                         [.let [type_variables (|> (java/lang/reflect/Method::getTypeParameters method)
                                                   (array.list {.#None})
                                                   (list#each (|>> java/lang/reflect/TypeVariable::getName
                                                                   jvm.var)))]
                          inputs (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                                     (array.list {.#None})
                                     (monad.each ! reflection!.type))
                          return (..return_type method)
                          .let [concrete_exceptions (..concrete_method_exceptions method)]
                          generic_exceptions (|> (java/lang/reflect/Method::getGenericExceptionTypes method)
                                                 (array.list {.#None})
                                                 (monad.each ! reflection!.class))]
                         (in [type
                              (java/lang/reflect/Method::getName method)
                              (jvm.method [type_variables inputs return (if (list.empty? generic_exceptions)
                                                                          concrete_exceptions
                                                                          generic_exceptions)])]))))))]

  [abstract_methods (list.only (|>> java/lang/reflect/Method::getModifiers java/lang/reflect/Modifier::isAbstract))
   (<| (array.list {.#None}) java/lang/Class::getDeclaredMethods)]
  [methods (<|)
   ..all_declared_methods]
  )

(def jvm_package_separator ".")

(with_template [<name> <methods>]
  [(def (<name> class_loader)
     (-> java/lang/ClassLoader (List (Type Class)) (Try (List [(Type Class) Text (Type Method)])))
     (|>> (monad.each try.monad (function (_ type)
                                  (|> type
                                      ..reflection
                                      (reflection!.load class_loader)
                                      (try#each (|>> [type])))))
          (try#each (monad.each try.monad <methods>))
          try#conjoint
          (try#each list#conjoint)))]

  [all_abstract_methods ..abstract_methods]
  [all_methods ..methods]
  )

(with_template [<name>]
  [(exception.def .public (<name> [expected actual])
     (exception.Exception [(List [(Type Class) Text (Type Method)])
                           (List [(Type Class) Text (Type Method)])])
     (let [%method (is (%.Format [(Type Class) Text (Type Method)])
                       (function (_ [super name type])
                         (format (..signature super) " :: " (%.text name) " " (..signature type))))]
       (exception.report
        (list ["Expected methods" (exception.listing %method expected)]
              ["Actual methods" (exception.listing %method actual)]))))]

  [missing_abstract_methods]
  [invalid_overriden_methods]
  )

(.type .public Visibility
  (Variant
   {#Public}
   {#Private}
   {#Protected}
   {#Default}))

(.type .public Finality Bit)
(.type .public Strictness Bit)

(def .public public_tag "public")
(def .public private_tag "private")
(def .public protected_tag "protected")
(def .public default_tag "default")

(def .public visibility'
  (<text>.Parser Visibility)
  (all <>.or
       (<text>.this ..public_tag)
       (<text>.this ..private_tag)
       (<text>.this ..protected_tag)
       (<text>.this ..default_tag)
       ))

(def .public visibility
  (Parser Visibility)
  (<text>.then ..visibility' <code>.text))

(def .public (visibility_analysis visibility)
  (-> Visibility Analysis)
  (/////analysis.text (when visibility
                        {#Public} ..public_tag
                        {#Private} ..private_tag
                        {#Protected} ..protected_tag
                        {#Default} ..default_tag)))

(.type Exception
  (Type Class))

(def .public parameter_types
  (-> (List (Type Var)) (Check (List [(Type Var) .Type])))
  (monad.each check.monad
              (function (_ parameterJ)
                (do check.monad
                  [[_ parameterT] check.existential]
                  (in [parameterJ parameterT])))))

(.type .public (Abstract_Method a)
  [Text
   Visibility
   (List (Annotation a))
   (List (Type Var))
   (List Argument)
   (Type Return)
   (List Exception)])

(def .public abstract_tag "abstract")

(def .public abstract_method_definition
  (Parser (Abstract_Method Code))
  (<| <code>.form
      (<>.after (<code>.this_text ..abstract_tag))
      (all <>.and
           <code>.text
           ..visibility
           (<code>.tuple (<>.some ..annotation))
           (<code>.tuple (<>.some ..var))
           (<code>.tuple (<>.some ..argument))
           ..return
           (<code>.tuple (<>.some ..class)))))

(def (method_mapping of_class parameters)
  (-> Mapping (List (Type Var)) (Check Mapping))
  (|> parameters
      ..parameter_types
      (check#each (list#mix (function (_ [parameterJ parameterT] mapping)
                              (dictionary.has (parser.name parameterJ) parameterT mapping))
                            of_class))))

(def class_mapping
  (-> (List (Type Var)) (Check Mapping))
  (..method_mapping luxT.fresh))

(def .public (analyse_abstract_method analyse archive method)
  (-> Phase Archive (Abstract_Method Code) (Operation Analysis))
  (let [[method_name visibility annotations vars arguments return exceptions] method]
    (do [! phase.monad]
      [mapping (typeA.check (method_mapping luxT.fresh vars))
       annotationsA (monad.each ! (function (_ [name parameters])
                                    (do !
                                      [parametersA (monad.each ! (function (_ [name value])
                                                                   (do !
                                                                     [valueA (analyse archive value)]
                                                                     (in [name valueA])))
                                                               parameters)]
                                      (in [name parametersA])))
                                annotations)]
      (in (/////analysis.tuple (list (/////analysis.text ..abstract_tag)
                                     (/////analysis.text method_name)
                                     (visibility_analysis visibility)
                                     (/////analysis.tuple (list#each annotation_analysis annotationsA))
                                     (/////analysis.tuple (list#each var_analysis vars))
                                     (/////analysis.tuple (list#each ..argument_analysis arguments))
                                     (return_analysis return)
                                     (/////analysis.tuple (list#each class_analysis exceptions))
                                     ))))))

(.type .public (Constructor a)
  [Visibility
   Strictness
   (List (Annotation a))
   (List (Type Var))
   (List Exception)
   Text
   (List Argument)
   (List (Typed a))
   a])

(def .public constructor_tag "init")

(def .public constructor_definition
  (Parser (Constructor Code))
  (<| <code>.form
      (<>.after (<code>.this_text ..constructor_tag))
      (all <>.and
           ..visibility
           <code>.bit
           (<code>.tuple (<>.some ..annotation))
           (<code>.tuple (<>.some ..var))
           (<code>.tuple (<>.some ..class))
           <code>.text
           (<code>.tuple (<>.some ..argument))
           (<code>.tuple (<>.some ..input))
           <code>.any)))

(def (with_fake_parameter#pattern it)
  (-> pattern.Pattern pattern.Pattern)
  (when it
    {pattern.#Simple _}
    it
    
    {pattern.#Complex it}
    {pattern.#Complex
     (when it
       {complex.#Variant it}
       {complex.#Variant (revised complex.#value with_fake_parameter#pattern it)}

       {complex.#Tuple it}
       {complex.#Tuple (list#each with_fake_parameter#pattern it)})}
    
    {pattern.#Bind it}
    {pattern.#Bind (++ it)}))

(def (with_fake_parameter it)
  (-> Analysis Analysis)
  (when it
    {/////analysis.#Simple _}
    it

    {/////analysis.#Structure it}
    {/////analysis.#Structure
     (when it
       {complex.#Variant it}
       {complex.#Variant (revised complex.#value with_fake_parameter it)}

       {complex.#Tuple it}
       {complex.#Tuple (list#each with_fake_parameter it)})}

    {/////analysis.#Reference it}
    {/////analysis.#Reference
     (when it
       {reference.#Variable it}
       {reference.#Variable
        (when it
          {variable.#Local it}
          {variable.#Local (++ it)}
          
          {variable.#Foreign _}
          it)}
       
       {reference.#Constant _}
       it)}
    
    {/////analysis.#When value [head tail]}
    {/////analysis.#When (with_fake_parameter value)
                         (let [with_fake_parameter (is (-> /////analysis.Branch /////analysis.Branch)
                                                       (|>> (revised /////analysis.#when with_fake_parameter#pattern)
                                                            (revised /////analysis.#then with_fake_parameter)))]
                           [(with_fake_parameter head)
                            (list#each with_fake_parameter tail)])}
    
    {/////analysis.#Function environment body}
    {/////analysis.#Function (list#each with_fake_parameter environment)
                             body}
    
    {/////analysis.#Apply parameter abstraction}
    {/////analysis.#Apply (with_fake_parameter parameter)
                          (with_fake_parameter abstraction)}
    
    {/////analysis.#Extension name parameters}
    {/////analysis.#Extension name (list#each with_fake_parameter parameters)}))

(def .public (hidden_method_body arity bodyA)
  (-> Nat Analysis Analysis)
  (<| /////analysis.tuple
      (list (/////analysis.unit))
      (when arity
        (^.or 0 1)
        bodyA
        
        2
        (let [forced_refencing (/////analysis.tuple (list#each (|>> /////analysis.local) (list.indices (++ arity))))]
          {/////analysis.#When (/////analysis.unit)
                               [[/////analysis.#when
                                 {pattern.#Bind 2}
                                 
                                 /////analysis.#then
                                 (/////analysis.tuple (list forced_refencing bodyA))]
                                (list)]})

        _
        (let [forced_refencing (/////analysis.tuple (list#each (|>> /////analysis.local) (list.indices (++ arity))))]
          {/////analysis.#When (/////analysis.unit)
                               [[/////analysis.#when
                                 {pattern.#Complex
                                  {complex.#Tuple
                                   (|> (-- arity)
                                       list.indices
                                       (list#each (|>> (n.+ 2) {pattern.#Bind})))}}
                                 
                                 /////analysis.#then
                                 (/////analysis.tuple (list forced_refencing bodyA))]
                                (list)]}))))

(def .public (analyse_constructor_method analyse archive selfT mapping method)
  (-> Phase Archive .Type Mapping (Constructor Code) (Operation Analysis))
  (let [[visibility strict_fp?
         annotations vars exceptions
         self_name arguments super_arguments body] method]
    (do [! phase.monad]
      [mapping (typeA.check (method_mapping mapping vars))
       annotationsA (monad.each ! (function (_ [name parameters])
                                    (do !
                                      [parametersA (monad.each ! (function (_ [name value])
                                                                   (do !
                                                                     [valueA (analyse archive value)]
                                                                     (in [name valueA])))
                                                               parameters)]
                                      (in [name parametersA])))
                                annotations)
       super_arguments (monad.each ! (function (_ [jvmT super_argC])
                                       (do !
                                         [luxT (reflection_type mapping jvmT)
                                          super_argA (<| (typeA.expecting luxT)
                                                         (analyse archive super_argC))]
                                         (in [jvmT super_argA])))
                                   super_arguments)
       arguments' (monad.each !
                              (function (_ [name jvmT])
                                (do !
                                  [luxT (boxed_reflection_type mapping jvmT)]
                                  (in [name luxT])))
                              arguments)
       [scope bodyA] (|> arguments'
                         {.#Item [self_name selfT]}
                         list.reversed
                         (list#mix scope.with_local (analyse archive body))
                         (typeA.expecting .Any)
                         scope.with)
       .let [arity (list.size arguments)]]
      (in (/////analysis.tuple (list (/////analysis.text ..constructor_tag)
                                     (visibility_analysis visibility)
                                     (/////analysis.bit strict_fp?)
                                     (/////analysis.tuple (list#each annotation_analysis annotationsA))
                                     (/////analysis.tuple (list#each var_analysis vars))
                                     (/////analysis.tuple (list#each class_analysis exceptions))
                                     (/////analysis.text self_name)
                                     (/////analysis.tuple (list#each ..argument_analysis arguments))
                                     (/////analysis.tuple (list#each typed_analysis super_arguments))
                                     {/////analysis.#Function
                                      (list#each (|>> /////analysis.variable)
                                                 (scope.environment scope))
                                      (<| (..hidden_method_body arity)
                                          (when arity
                                            0 (with_fake_parameter bodyA)
                                            _ bodyA))}
                                     ))))))

(.type .public (Virtual_Method a)
  [Text
   Visibility
   Finality
   Strictness
   (List (Annotation a))
   (List (Type Var))
   Text
   (List Argument)
   (Type Return)
   (List Exception)
   a])

(def .public virtual_tag "virtual")

(def .public virtual_method_definition
  (Parser (Virtual_Method Code))
  (<| <code>.form
      (<>.after (<code>.this_text ..virtual_tag))
      (all <>.and
           <code>.text
           ..visibility
           <code>.bit
           <code>.bit
           (<code>.tuple (<>.some ..annotation))
           (<code>.tuple (<>.some ..var))
           <code>.text
           (<code>.tuple (<>.some ..argument))
           ..return
           (<code>.tuple (<>.some ..class))
           <code>.any)))

(.type .public (Method_Declaration a)
  (Record
   [#name Text
    #annotations (List (Annotation a))
    #type_variables (List (Type Var))
    #exceptions (List (Type Class))
    #arguments (List (Type Value))
    #return (Type Return)]))

(def .public method_declaration
  (Parser (Method_Declaration Code))
  (<code>.form
   (all <>.and
        <code>.text
        (<code>.tuple (<>.some ..annotation))
        (<code>.tuple (<>.some ..var))
        (<code>.tuple (<>.some ..class))
        (<code>.tuple (<>.some ..type))
        ..return
        )))

(def .public (analyse_virtual_method analyse archive selfT mapping method)
  (-> Phase Archive .Type Mapping (Virtual_Method Code) (Operation Analysis))
  (let [[method_name visibility
         final? strict_fp? annotations vars
         self_name arguments return exceptions
         body] method]
    (do [! phase.monad]
      [mapping (typeA.check (method_mapping mapping vars))
       annotationsA (monad.each ! (function (_ [name parameters])
                                    (do !
                                      [parametersA (monad.each ! (function (_ [name value])
                                                                   (do !
                                                                     [valueA (analyse archive value)]
                                                                     (in [name valueA])))
                                                               parameters)]
                                      (in [name parametersA])))
                                annotations)
       :return: (boxed_reflection_return mapping return)
       arguments' (monad.each !
                              (function (_ [name jvmT])
                                (do !
                                  [luxT (boxed_reflection_type mapping jvmT)]
                                  (in [name luxT])))
                              arguments)
       [scope bodyA] (|> arguments'
                         {.#Item [self_name selfT]}
                         list.reversed
                         (list#mix scope.with_local (analyse archive body))
                         (typeA.expecting :return:)
                         scope.with)
       .let [arity (list.size arguments)]]
      (in (/////analysis.tuple (list (/////analysis.text ..virtual_tag)
                                     (/////analysis.text method_name)
                                     (visibility_analysis visibility)
                                     (/////analysis.bit final?)
                                     (/////analysis.bit strict_fp?)
                                     (/////analysis.tuple (list#each annotation_analysis annotationsA))
                                     (/////analysis.tuple (list#each var_analysis vars))
                                     (/////analysis.text self_name)
                                     (/////analysis.tuple (list#each ..argument_analysis arguments))
                                     (return_analysis return)
                                     (/////analysis.tuple (list#each class_analysis exceptions))
                                     {/////analysis.#Function
                                      (list#each (|>> /////analysis.variable)
                                                 (scope.environment scope))
                                      (<| (..hidden_method_body arity)
                                          (when arity
                                            0 (with_fake_parameter bodyA)
                                            _ bodyA))}
                                     ))))))

(.type .public (Static_Method a)
  [Text
   Visibility
   Strictness
   (List (Annotation a))
   (List (Type Var))
   (List Argument)
   (Type Return)
   (List Exception)
   a])

(def .public static_tag "static")

(def .public static_method_definition
  (Parser (Static_Method Code))
  (<| <code>.form
      (<>.after (<code>.this_text ..static_tag))
      (all <>.and
           <code>.text
           ..visibility
           <code>.bit
           (<code>.tuple (<>.some ..annotation))
           (<code>.tuple (<>.some ..var))
           (<code>.tuple (<>.some ..argument))
           ..return
           (<code>.tuple (<>.some ..class))
           <code>.any)))

(def .public (analyse_static_method analyse archive mapping method)
  (-> Phase Archive Mapping (Static_Method Code) (Operation Analysis))
  (let [[method_name visibility
         strict_fp? annotations vars
         arguments return exceptions
         body] method]
    (do [! phase.monad]
      [mapping (typeA.check (method_mapping mapping vars))
       annotationsA (monad.each ! (function (_ [name parameters])
                                    (do !
                                      [parametersA (monad.each ! (function (_ [name value])
                                                                   (do !
                                                                     [valueA (analyse archive value)]
                                                                     (in [name valueA])))
                                                               parameters)]
                                      (in [name parametersA])))
                                annotations)
       :return: (boxed_reflection_return mapping return)
       arguments' (monad.each !
                              (function (_ [name jvmT])
                                (do !
                                  [luxT (boxed_reflection_type mapping jvmT)]
                                  (in [name luxT])))
                              arguments)
       [scope bodyA] (|> arguments'
                         list.reversed
                         (list#mix scope.with_local (analyse archive body))
                         (typeA.expecting :return:)
                         scope.with)]
      (in (/////analysis.tuple (list (/////analysis.text ..static_tag)
                                     (/////analysis.text method_name)
                                     (visibility_analysis visibility)
                                     (/////analysis.bit strict_fp?)
                                     (/////analysis.tuple (list#each annotation_analysis annotationsA))
                                     (/////analysis.tuple (list#each var_analysis vars))
                                     (/////analysis.tuple (list#each ..argument_analysis arguments))
                                     (return_analysis return)
                                     (/////analysis.tuple (list#each class_analysis
                                                                     exceptions))
                                     {/////analysis.#Function
                                      (list#each (|>> /////analysis.variable)
                                                 (scope.environment scope))
                                      (/////analysis.tuple (list bodyA))}
                                     ))))))

(.type .public (Overriden_Method a)
  [(Type Class)
   Text
   Bit
   (List (Annotation a))
   (List (Type Var))
   Text
   (List Argument)
   (Type Return)
   (List (Type Class))
   a])

(def .public overriden_tag "override")

(def .public overriden_method_definition
  (Parser (Overriden_Method Code))
  (<| <code>.form
      (<>.after (<code>.this_text ..overriden_tag))
      (all <>.and
           ..class
           <code>.text
           <code>.bit
           (<code>.tuple (<>.some ..annotation))
           (<code>.tuple (<>.some ..var))
           <code>.text
           (<code>.tuple (<>.some ..argument))
           ..return
           (<code>.tuple (<>.some ..class))
           <code>.any
           )))

(exception.def .public (unknown_super [name supers])
  (exception.Exception [Text (List (Type Class))])
  (exception.report
   (list ["Name" (%.text name)]
         ["Available" (exception.listing (|>> parser.read_class product.left) supers)])))

(exception.def .public (mismatched_super_parameters [name expected actual])
  (exception.Exception [Text Nat Nat])
  (exception.report
   (list ["Name" (%.text name)]
         ["Expected" (%.nat expected)]
         ["Actual" (%.nat actual)])))

(def (override_mapping mapping supers parent_type)
  (-> Mapping (List (Type Class)) (Type Class) (Operation (List [Text .Type])))
  (let [[parent_name parent_parameters] (parser.read_class parent_type)]
    (when (list.one (function (_ super)
                      (let [[super_name super_parameters] (parser.read_class super)]
                        (if (text#= parent_name super_name)
                          {.#Some super_parameters}
                          {.#None})))
                    supers)
      {.#Some super_parameters}
      (let [expected_count (list.size parent_parameters)
            actual_count (list.size super_parameters)]
        (if (n.= expected_count actual_count)
          (do [! phase.monad]
            [parent_parameters (|> parent_parameters
                                   (monad.each maybe.monad parser.var?)
                                   try.of_maybe
                                   phase.lifted)]
            (|> super_parameters
                (monad.each ! (..reflection_type mapping))
                (at ! each (|>> (list.zipped_2 parent_parameters)))))
          (phase.lifted (exception.except ..mismatched_super_parameters [parent_name expected_count actual_count]))))
      
      {.#None}
      (phase.lifted (exception.except ..unknown_super [parent_name supers])))))

(def .public (with_override_mapping supers parent_type mapping)
  (-> (List (Type Class)) (Type Class) Mapping (Operation Mapping))
  (do phase.monad
    [override_mapping (..override_mapping mapping supers parent_type)]
    (in (list#mix (function (_ [super_var bound_type] mapping)
                    (dictionary.has super_var bound_type mapping))
                  mapping
                  override_mapping))))

(def .public (analyse_overriden_method analyse archive selfT mapping supers method)
  (-> Phase Archive .Type Mapping (List (Type Class)) (Overriden_Method Code) (Operation Analysis))
  (let [[parent_type method_name
         strict_fp? annotations vars
         self_name arguments return exceptions
         body] method]
    (do [! phase.monad]
      [mapping (..with_override_mapping supers parent_type mapping)
       mapping (typeA.check (method_mapping mapping vars))
       annotationsA (monad.each ! (function (_ [name parameters])
                                    (do !
                                      [parametersA (monad.each ! (function (_ [name value])
                                                                   (do !
                                                                     [valueA (analyse archive value)]
                                                                     (in [name valueA])))
                                                               parameters)]
                                      (in [name parametersA])))
                                annotations)
       arguments' (monad.each !
                              (function (_ [name jvmT])
                                (do !
                                  [luxT (boxed_reflection_type mapping jvmT)]
                                  (in [name luxT])))
                              arguments)
       :return: (boxed_reflection_return mapping return)
       [scope bodyA] (|> arguments'
                         {.#Item [self_name selfT]}
                         list.reversed
                         (list#mix scope.with_local (analyse archive body))
                         (typeA.expecting :return:)
                         scope.with)
       .let [arity (list.size arguments)]]
      (in (/////analysis.tuple (list (/////analysis.text ..overriden_tag)
                                     (class_analysis parent_type)
                                     (/////analysis.text method_name)
                                     (/////analysis.bit strict_fp?)
                                     (/////analysis.tuple (list#each annotation_analysis annotationsA))
                                     (/////analysis.tuple (list#each var_analysis vars))
                                     (/////analysis.text self_name)
                                     (/////analysis.tuple (list#each ..argument_analysis arguments))
                                     (return_analysis return)
                                     (/////analysis.tuple (list#each class_analysis
                                                                     exceptions))
                                     {/////analysis.#Function
                                      (list#each (|>> /////analysis.variable)
                                                 (scope.environment scope))
                                      (<| (..hidden_method_body arity)
                                          (when arity
                                            0 (with_fake_parameter bodyA)
                                            _ bodyA))}
                                     ))))))

(def (matched? [sub sub_method subJT] [super super_method superJT])
  (-> [(Type Class) Text (Type Method)] [(Type Class) Text (Type Method)] Bit)
  (and (at descriptor.equivalence = (jvm.descriptor super) (jvm.descriptor sub))
       (text#= super_method sub_method)
       (jvm#= superJT subJT)))

(def (mismatched_methods super_set sub_set)
  (-> (List [(Type Class) Text (Type Method)])
      (List [(Type Class) Text (Type Method)])
      (List [(Type Class) Text (Type Method)]))
  (list.only (function (_ sub)
               (not (list.any? (matched? sub) super_set)))
             sub_set))

(exception.def .public (class_parameter_mismatch [name declaration expected actual])
  (exception.Exception [Text (Type Class) (List Text) (List (Type Parameter))])
  (exception.report
   (list ["Class" (%.text name)]
         ["Declaration" (signature.signature (jvm.signature declaration))]
         ["Expected (amount)" (%.nat (list.size expected))]
         ["Expected (parameters)" (exception.listing %.text expected)]
         ["Actual (amount)" (%.nat (list.size actual))]
         ["Actual (parameters)" (exception.listing ..signature actual)])))

(def (super_aliasing class_loader class)
  (-> java/lang/ClassLoader (Type Class) (Operation Aliasing))
  (do phase.monad
    [.let [[name actual_parameters] (parser.read_class class)]
     jvm_class (phase.lifted (reflection!.load class_loader name))
     .let [expected_parameters (|> (java/lang/Class::getTypeParameters jvm_class)
                                   (array.list {.#None})
                                   (list#each (|>> java/lang/reflect/TypeVariable::getName)))]
     _ (phase.assertion ..class_parameter_mismatch [name class expected_parameters actual_parameters]
                        (n.= (list.size expected_parameters)
                             (list.size actual_parameters)))]
    (in (|> (list.zipped_2 expected_parameters actual_parameters)
            (list#mix (function (_ [expected actual] mapping)
                        (when (parser.var? actual)
                          {.#Some actual}
                          (dictionary.has actual expected mapping)
                          
                          {.#None}
                          mapping))
                      alias.fresh)))))

(def (anonymous_class_name module id)
  (-> Module Nat Text)
  (let [global (text.replaced .module_separator ..jvm_package_separator module)
        local (format "anonymous-class" (%.nat id))]
    (format global ..jvm_package_separator local)))

(def .public (require_complete_method_concretion class_loader supers methods)
  (-> java/lang/ClassLoader (List (Type Class)) (List (Overriden_Method Code)) (Operation Any))
  (do [! phase.monad]
    [required_abstract_methods (phase.lifted (all_abstract_methods class_loader supers))
     available_methods (phase.lifted (all_methods class_loader supers))
     overriden_methods (monad.each ! (function (_ [parent_type method_name
                                                   strict_fp? annotations type_vars
                                                   self_name arguments return exceptions
                                                   body])
                                       (do !
                                         [aliasing (super_aliasing class_loader parent_type)]
                                         (in (|> (jvm.method [type_vars
                                                              (list#each product.right arguments)
                                                              return
                                                              exceptions])
                                                 (alias.method aliasing)
                                                 [parent_type method_name]))))
                                   methods)
     .let [missing_abstract_methods (mismatched_methods overriden_methods required_abstract_methods)
           invalid_overriden_methods (mismatched_methods available_methods overriden_methods)]
     _ (phase.assertion ..missing_abstract_methods [required_abstract_methods overriden_methods]
                        (list.empty? missing_abstract_methods))
     _ (phase.assertion ..invalid_overriden_methods [available_methods invalid_overriden_methods]
                        (list.empty? invalid_overriden_methods))]
    (in [])))

(.type Declaration
  [Text (List (Type Var))])

(.type Constant
  [Text (List Annotation) (Type Value) Code])

(.type Variable
  [Text (Modifier field.Field) (Modifier field.Field) (List Annotation) (Type Value)])

(.type Field
  (Variant
   {#Constant Constant}
   {#Variable Variable}))

(.type (Method_Definition a)
  (Variant
   {#Constructor (..Constructor a)}
   {#Virtual_Method (..Virtual_Method a)}
   {#Static_Method (..Static_Method a)}
   {#Overriden_Method (..Overriden_Method a)}
   {#Abstract_Method (..Abstract_Method a)}))

(def class_name
  (|>> parser.read_class product.left name.internal))

(def (mock_class [name parameters] super interfaces fields methods modifier)
  (-> Declaration (Type Class) (List (Type Class))
      (List (Resource field.Field)) (List (Resource method.Method)) (Modifier class.Class)
      (Try [External Binary]))
  (let [signature (signature.inheritance (list#each jvm.signature parameters)
                                         (jvm.signature super)
                                         (list#each jvm.signature interfaces))]
    (try#each (|>> (\\format.result class.format)
                   [name])
              (class.class version.v6_0
                (all modifier#composite
                     class.public
                     modifier)
                (name.internal name)
                {.#Some signature}
                (..class_name super)
                (list#each ..class_name interfaces)
                fields
                methods
                (list)))))

(def constant::modifier
  (Modifier field.Field)
  (all modifier#composite
       field.public
       field.static
       field.final
       ))

(def (field_definition field)
  (-> Field (Resource field.Field))
  (when field
    ... TODO: Handle annotations.
    {#Constant [name annotations type value]}
    (when value
      (^.with_template [<tag> <type> <constant>]
        [[_ {<tag> value}]
         (do pool.monad
           [constant (`` (|> value (,, (template.spliced <constant>))))
            attribute (attribute.constant constant)]
           (field.field ..constant::modifier name true <type> (sequence.sequence attribute)))])
      ([.#Bit jvm.boolean [(pipe.when #0 +0 #1 +1) .i64 i32.i32 constant.integer pool.integer]]
       [.#Int jvm.byte [.i64 i32.i32 constant.integer pool.integer]]
       [.#Int jvm.short [.i64 i32.i32 constant.integer pool.integer]]
       [.#Int jvm.int [.i64 i32.i32 constant.integer pool.integer]]
       [.#Int jvm.long [constant.long pool.long]]
       [.#Frac jvm.float [ffi.double_to_float constant.float pool.float]]
       [.#Frac jvm.double [constant.double pool.double]]
       [.#Nat jvm.char [.i64 i32.i32 constant.integer pool.integer]]
       [.#Text (jvm.class "java.lang.String" (list)) [pool.string]]
       )

      ... TODO: Tighten this pattern-matching so this catch-all clause isn't necessary.
      _
      (undefined))

    ... TODO: Handle annotations.
    {#Variable [name visibility state annotations type]}
    (field.field (modifier#composite visibility state)
                 name true type sequence.empty)))

(def method_privacy
  (-> ffi.Privacy (Modifier method.Method))
  (|>> (pipe.when
         {ffi.#PublicP} method.public
         {ffi.#PrivateP} method.private
         {ffi.#ProtectedP} method.protected
         {ffi.#DefaultP} modifier.empty)))

(def constructor_name
  "<init>")

(def (mock_value valueT)
  (-> (Type Value) (Bytecode Any))
  (when (jvm.primitive? valueT)
    {.#Left classT}
    _.aconst_null
    
    {.#Right primitiveT}
    (cond (at jvm.equivalence = jvm.long primitiveT)
          _.lconst_0

          (at jvm.equivalence = jvm.float primitiveT)
          _.fconst_0

          (at jvm.equivalence = jvm.double primitiveT)
          _.dconst_0

          ... jvm.boolean jvm.byte jvm.short jvm.int jvm.char
          _.iconst_0)))

(def (mock_return :return:)
  (-> (Type Return) (Bytecode Any))
  (when (jvm.void? :return:)
    {.#Right :return:}
    _.return

    {.#Left valueT}
    (all _.composite
         (mock_value valueT)
         (when (jvm.primitive? valueT)
           {.#Left classT}
           _.areturn
           
           {.#Right primitiveT}
           (cond (at jvm.equivalence = jvm.long primitiveT)
                 _.lreturn

                 (at jvm.equivalence = jvm.float primitiveT)
                 _.freturn

                 (at jvm.equivalence = jvm.double primitiveT)
                 _.dreturn

                 ... jvm.boolean jvm.byte jvm.short jvm.int jvm.char
                 _.ireturn)))))

(def (mock_method super method)
  (-> (Type Class) (Method_Definition Code) (Resource method.Method))
  (when method
    {#Constructor [privacy strict_floating_point? annotations variables exceptions
                   self arguments constructor_arguments
                   body]}
    (method.method (all modifier#composite
                        (..method_privacy privacy)
                        (if strict_floating_point?
                          method.strict
                          modifier.empty))
      ..constructor_name
      false (jvm.method [variables (list#each product.right arguments) jvm.void exceptions])
      (list)
      {.#Some (all _.composite
                   (_.aload 0)
                   (|> constructor_arguments
                       (list#each (|>> product.left ..mock_value))
                       (monad.all _.monad))
                   (|> (jvm.method [(list) (list#each product.left constructor_arguments) jvm.void (list)])
                       (_.invokespecial super ..constructor_name))
                   _.return
                   )})

    {#Overriden_Method [super name strict_floating_point? annotations variables
                        self arguments return exceptions
                        body]}
    (method.method (all modifier#composite
                        method.public
                        (if strict_floating_point?
                          method.strict
                          modifier.empty))
      name
      false (jvm.method [variables (list#each product.right arguments) return exceptions])
      (list)
      {.#Some (..mock_return return)})

    {#Virtual_Method [name privacy final? strict_floating_point? annotations variables
                      self arguments return exceptions
                      body]}
    (method.method (all modifier#composite
                        (..method_privacy privacy)
                        (if strict_floating_point?
                          method.strict
                          modifier.empty)
                        (if final?
                          method.final
                          modifier.empty))
      name
      false (jvm.method [variables (list#each product.right arguments) return exceptions])
      (list)
      {.#Some (..mock_return return)})

    {#Static_Method [name privacy strict_floating_point? annotations
                     variables arguments return exceptions
                     body]}
    (method.method (all modifier#composite
                        method.static
                        (..method_privacy privacy)
                        (if strict_floating_point?
                          method.strict
                          modifier.empty))
      name
      false (jvm.method [variables (list#each product.right arguments) return exceptions])
      (list)
      {.#Some (..mock_return return)})

    {#Abstract_Method [name privacy annotations
                       variables arguments return exceptions]}
    (method.method (all modifier#composite
                        method.abstract
                        (..method_privacy privacy))
      name
      false (jvm.method [variables (list#each product.right arguments) return exceptions])
      (list)
      {.#None})
    ))

(def (mock declaration super interfaces inheritance fields methods)
  (-> Declaration
      (Type Class) (List (Type Class))
      (Modifier class.Class) (List ..Field) (List (Method_Definition Code))
      (Try [External Binary]))
  (mock_class declaration super interfaces
              (list#each ..field_definition fields)
              (list#each (..mock_method super) methods)
              inheritance))

(def (class::anonymous class_loader host)
  (-> java/lang/ClassLoader runtime.Host (-> Text Handler))
  (..custom
   [(all <>.and
         (<code>.tuple (<>.some ..var))
         ..class
         (<code>.tuple (<>.some ..class))
         (<code>.tuple (<>.some ..input))
         (<code>.tuple (<>.some ..overriden_method_definition)))
    (function (_ extension_name analyse archive [parameters
                                                 super_class
                                                 super_interfaces
                                                 constructor_args
                                                 methods])
      (do [! phase.monad]
        [_ (..ensure_fresh_class! class_loader (..reflection super_class))
         _ (monad.each ! (|>> ..reflection (..ensure_fresh_class! class_loader)) super_interfaces)

         self_name (do meta.monad
                     [where meta.current_module_name
                      id meta.seed]
                     (in (..anonymous_class_name where id)))
         .let [selfT {.#Primitive self_name (list)}]
         mock (<| phase.lifted
                  (..mock [self_name parameters]
                          super_class
                          super_interfaces
                          class.final
                          (list)
                          (list#each (|>> {#Overriden_Method}) methods)))
         ... Necessary for reflection to work properly during analysis.
         _ (phase.lifted (at host execute mock))

         mapping (typeA.check (..class_mapping parameters))
         super_classT (typeA.check (luxT.check (luxT.class mapping) (..signature super_class)))
         super_interfaceT+ (typeA.check (monad.each check.monad
                                                    (|>> ..signature (luxT.check (luxT.class mapping)))
                                                    super_interfaces))
         _ (typeA.inference selfT)
         constructor_argsA+ (monad.each ! (function (_ [type term])
                                            (do !
                                              [argT (reflection_type mapping type)
                                               termA (<| (typeA.expecting argT)
                                                         (analyse archive term))]
                                              (in [type termA])))
                                        constructor_args)
         .let [supers {.#Item super_class super_interfaces}]
         _ (..require_complete_method_concretion class_loader supers methods)
         methodsA (monad.each ! (analyse_overriden_method analyse archive selfT mapping supers) methods)]
        (in {/////analysis.#Extension [.prelude (%.format extension_name "|generation")]
                                      (list (class_analysis super_class)
                                            (/////analysis.tuple (list#each class_analysis super_interfaces))
                                            (/////analysis.tuple (list#each typed_analysis constructor_argsA+))
                                            (/////analysis.tuple methodsA))})))]))

(def (with_class_extensions class_loader host)
  (-> java/lang/ClassLoader runtime.Host (-> Bundle Bundle))
  (install (%.format "jvm_" "class_" "anonymous" "#") (class::anonymous class_loader host)))

(def .public (bundle class_loader host)
  (-> java/lang/ClassLoader runtime.Host Bundle)
  (<| with_conversion_extensions
      with_int_extensions
      with_long_extensions
      with_float_extensions
      with_double_extensions
      with_char_extensions
      with_array_extensions
      (with_object_extensions class_loader)
      (with_member_extensions class_loader)
      (with_class_extensions class_loader host)
      ///.empty))
