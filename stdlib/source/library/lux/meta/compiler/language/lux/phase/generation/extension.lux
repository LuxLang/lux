(.require
 [library
  [lux (.except)
   [abstract
    ["[0]" monad (.only do)]]
   [data
    [collection
     ["[0]" list (.use "[1]#[0]" functor)]]]
   ["[0]" meta (.only)
    ["[0]" code (.only)
     ["<[1]>" \\parser]]
    ["[0]" macro (.only with_symbols)
     [syntax (.only syntax)]]]]]
 ["[0]" ///
  ["[1][0]" extension]
  [//
   [synthesis (.only Synthesis)]
   ["[0]" generation]
   [///
    ["[1]" phase]]]])

(def Vector
  (syntax (_ [size <code>.nat
              elemT <code>.any])
    (in (list (` [(,* (list.repeated size elemT))])))))

(def Arity
  (template (_ arity)
    [(All (_ of)
       (-> (Vector arity of) of))]))

(def arity
  (syntax (_ [arity <code>.nat])
    (with_symbols [g!_ g!extension g!name g!phase g!archive g!inputs g!anchor g!expression g!declaration]
      (do [! meta.monad]
        [g!input+ (monad.all ! (list.repeated arity (macro.symbol "input")))]
        (in (list (` (is (All ((, g!_) (, g!anchor) (, g!expression) (, g!declaration))
                           (-> ((Arity (, (code.nat arity))) (, g!expression))
                               (generation.Handler (, g!anchor) (, g!expression) (, g!declaration))))
                         (function ((, g!_) (, g!extension))
                           (function ((, g!_) (, g!name) (, g!phase) (, g!archive) (, g!inputs))
                             (when (, g!inputs)
                               (list (,* g!input+))
                               (do ///.monad
                                 [(,* (|> g!input+
                                          (list#each (function (_ g!input)
                                                       (list g!input (` ((, g!phase) (, g!archive) (, g!input))))))
                                          list.together))]
                                 ((,' in) ((, g!extension) [(,* g!input+)])))

                               (, g!_)
                               (///.except ///extension.incorrect_arity [(, g!name)
                                                                         (, (code.nat arity))
                                                                         (list.size (, g!inputs))]))
                             ))))))))))

(with_template [<arity> <type> <term>]
  [(type .public <type> (Arity <arity>))
   (def .public <term> (arity <arity>))]

  [0 Nullary nullary]
  [1 Unary unary]
  [2 Binary binary]
  [3 Trinary trinary]
  )

(type .public (Variadic of)
  (-> (List of) of))

(def .public (variadic extension)
  (All (_ anchor expression declaration)
    (-> (Variadic expression) (generation.Handler anchor expression declaration)))
  (function (_ extension_name)
    (function (_ phase archive inputsS)
      (let [! ///.monad]
        (|> inputsS
            (monad.each ! (phase archive))
            (at ! each extension))))))
