(.require
 [library
  [lux (.except Code Type int)
   [control
    ["|"  pipe]]
   [data
    ["[0]" text (.only)
     ["%" \\format]]
    [collection
     ["[0]" list (.use "[1]#[0]" functor)]]]
   [math
    [number
     ["f" frac]]]
   [meta
    [macro
     ["[0]" template]]
    [type
     ["[0]" nominal]]]]])

(nominal.def .public (Code of)
  Text

  (def .public code
    (-> (Code Any)
        Text)
    (|>> nominal.representation))

  (with_template [<type> <super>+]
    [(with_expansions [<of> (template.symbol [<type> "'"])]
       (nominal.def (<of> of)
         Any)
       (`` (type .public <type>
             (|> Any <of> (,, (template.spliced <super>+))))))]

    [Type [Code]]
    [Expression [Code]]
    [Computation [Expression' Code]]
    )

  (with_template [<type> <super>+]
    [(with_expansions [<brand> (template.symbol [<type> "'"])]
       (nominal.def <brand> Any)
       (`` (type .public <type> (|> <brand> (,, (template.spliced <super>+))))))]

    [Literal [Computation' Expression' Code]]
    )

  (def .public bool
    (-> Bit
        Literal)
    (|>> (|.when
           .false "false"
           .true "true")
         nominal.abstraction))

  (def .public double
    (-> Frac
        Literal)
    (|>> (|.cond [(f.= f.positive_infinity)]
                 [(|.new "(+1.0/0.0)" [])]
                 
                 [(f.= f.negative_infinity)]
                 [(|.new "(-1.0/0.0)" [])]
                 
                 [(f.= f.not_a_number)]
                 [(|.new "(0.0/0.0)" [])]

                 ... else
                 [%.frac])
         nominal.abstraction))

  (def .public (cast type term)
    (-> Type Expression
        Computation)
    (nominal.abstraction
     (%.format "(" (nominal.representation type) ")"
               " " (nominal.representation term))))

  (def .public int
    (-> Int
        Literal)
    (|>> %.int
         nominal.abstraction))

  (def .public (on parameters function)
    (-> (List Expression) Expression
        Expression)
    (nominal.abstraction
     (%.format (nominal.representation function)
               "("
               (|> parameters
                   (list#each (|>> nominal.representation))
                   (text.interposed ", "))
               ")")))

  ... https://en.cppreference.com/w/cpp/types/integer
  (with_template [<name>]
    [(def .public (<name> it)
       (-> Expression
           Expression)
       (..on (list it)
             (nominal.abstraction (template.text [<name>]))))]

    [int64_t]
    )

  ... https://en.cppreference.com/w/cpp/string/basic_string
  (def .public u32string
    (-> Text
        Literal)
    (|>> %.text
         (%.format "U")
         nominal.abstraction))
  )
