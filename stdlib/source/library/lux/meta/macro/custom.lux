(.require
 [library
  [lux (.except local)
   [abstract
    [monad (.only do)]]
   [control
    ["?" parser (.use "[1]#[0]" functor)]
    ["[0]" exception (.only exception)]]]]
 ["[0]" // (.only)
  [syntax (.only syntax)
   ["[0]" export]]
  ["/[1]" // (.only)
   ["[0]" code (.only)
    ["?[1]" \\parser (.only Parser)]]
   ["[0]" type (.only)
    [primitive (.except)]]]])

(exception .public (invalid_type [expected Type
                                  actual Type])
  (exception.report
   (list ["Expected" (type.format expected)]
         ["Actual" (type.format actual)])))

(def local
  (Parser Code)
  (?#each code.local ?code.local))

(def .public custom
  (syntax (_ [[public|private <type> <in> <out> <by_name>]
              (export.parser (all ?.and
                                  ..local
                                  ..local
                                  ..local
                                  ..local))])
    (//.with_symbols [g!_ g!type g!value]
      (in (list (` (primitive (, public|private) (, <type>)
                     Macro))

                (` (def (, public|private) (, <in>)
                     (-> Macro (, <type>))
                     (|>> abstraction)))

                (` (def (, public|private) (, <out>)
                     (-> (, <type>) Macro)
                     (|>> representation)))

                (` (def (, public|private) ((, <by_name>) (, g!_))
                     (-> Symbol (Meta (, <type>)))
                     ((,! do) (,! ///.monad)
                      [[(, g!_) (, g!type) (, g!value)] ((,! ///.export) (, g!_))]
                      (if (at (,! type.equivalence) (,' =) (, <type>) (, g!type))
                        ((,' in) (as (, <type>) (, g!value)))
                        ((,! ///.failure) ((,! exception.except) ..invalid_type [(, <type>) (, g!type)])))))))))))
