(.module:
  [library
   [lux "*"
    [abstract
     [equivalence {"+" [Equivalence]}]]]])

(implementation: .public equivalence
  (Equivalence Location)

  (def: (= reference subject)
    (and ("lux text =" (value@ #.module reference) (value@ #.module subject))
         ("lux i64 =" (value@ #.line reference) (value@ #.line subject))
         ("lux i64 =" (value@ #.column reference) (value@ #.column subject)))))

(def: .public dummy
  Location
  [#.module ""
   #.line   0
   #.column 0])

(macro: .public (here tokens compiler)
  (case tokens
    #.End
    (let [location (value@ #.location compiler)]
      (#.Right [compiler
                (list (` (.: .Location
                             [(~ [..dummy (#.Text (value@ #.module location))])
                              (~ [..dummy (#.Nat (value@ #.line location))])
                              (~ [..dummy (#.Nat (value@ #.column location))])])))]))

    _
    (#.Left (`` (("lux in-module" (~~ (static .prelude_module)) wrong_syntax_error) (name_of ..here))))))

(def: .public (format it)
  (-> Location Text)
  (let [separator ","
        [file line column] it]
    ($_ "lux text concat"
        "@"
        (`` (("lux in-module" (~~ (static .prelude_module)) .text\encoded) file)) separator
        (`` (("lux in-module" (~~ (static .prelude_module)) .nat\encoded) line)) separator
        (`` (("lux in-module" (~~ (static .prelude_module)) .nat\encoded) column)))))

(def: \n
  ("lux i64 char" +10))

(def: .public (with location error)
  (-> Location Text Text)
  ($_ "lux text concat" (..format location) \n
      error))
