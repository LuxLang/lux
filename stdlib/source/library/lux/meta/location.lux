(.using
 [library
  [lux "*"
   [abstract
    [equivalence {"+" Equivalence}]]]])

(implementation: .public equivalence
  (Equivalence Location)

  (def: (= reference subject)
    (and ("lux text =" (the .#module reference) (the .#module subject))
         ("lux i64 =" (the .#line reference) (the .#line subject))
         ("lux i64 =" (the .#column reference) (the .#column subject)))))

(def: .public dummy
  Location
  [.#module ""
   .#line   0
   .#column 0])

(macro: .public (here tokens compiler)
  (case tokens
    {.#End}
    (let [location (the .#location compiler)]
      {.#Right [compiler
                (list (` (.: .Location
                             [.#module (~ [..dummy {.#Text (the .#module location)}])
                              .#line (~ [..dummy {.#Nat (the .#line location)}])
                              .#column (~ [..dummy {.#Nat (the .#column location)}])])))]})

    _
    {.#Left (`` (("lux in-module" (~~ (static .prelude_module)) wrong_syntax_error) (symbol ..here)))}))

(def: .public (format it)
  (-> Location Text)
  (let [separator ","
        [file line column] it]
    ($_ "lux text concat"
        "@"
        (`` (("lux in-module" (~~ (static .prelude_module)) .text#encoded) file)) separator
        (`` (("lux in-module" (~~ (static .prelude_module)) .nat#encoded) line)) separator
        (`` (("lux in-module" (~~ (static .prelude_module)) .nat#encoded) column)))))

(def: \n
  ("lux i64 char" +10))

(def: .public (with location error)
  (-> Location Text Text)
  ($_ "lux text concat" (..format location) \n
      error))
