(.require
 [library
  [lux (.except with)
   [abstract
    [equivalence (.only Equivalence)]]]])

(def .public equivalence
  (Equivalence Location)
  (implementation
   (def (= reference subject)
     (and ("lux text =" (the .#module reference) (the .#module subject))
          ("lux i64 =" (the .#line reference) (the .#line subject))
          ("lux i64 =" (the .#column reference) (the .#column subject))))))

(def .public dummy
  Location
  [.#module ""
   .#line   0
   .#column 0])

(def .public here
  (macro (_ tokens compiler)
    (when tokens
      {.#End}
      (let [location (the .#location compiler)]
        {.#Right [compiler
                  (list (` (.is .Location
                                [.#module (, [..dummy {.#Text (the .#module location)}])
                                 .#line (, [..dummy {.#Nat (the .#line location)}])
                                 .#column (, [..dummy {.#Nat (the .#column location)}])])))]})

      _
      {.#Left (`` (("lux in-module" (,, (static .prelude)) wrong_syntax_error) (symbol ..here)))})))

(def .public (format it)
  (-> Location Text)
  (let [separator ","
        [file line column] it]
    (all "lux text concat"
         "@"
         (`` (("lux in-module" (,, (static .prelude)) .text#encoded) file)) separator
         (`` (("lux in-module" (,, (static .prelude)) .nat#encoded) line)) separator
         (`` (("lux in-module" (,, (static .prelude)) .nat#encoded) column)))))

(def \n
  ("lux i64 char" +10))

(def .public (with location error)
  (-> Location Text Text)
  (all "lux text concat" (..format location) \n
       error))
