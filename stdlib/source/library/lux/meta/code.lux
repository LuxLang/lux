... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except text natural integer revolution local global name variant tuple with)
   [abstract
    [equivalence (.only Equivalence)]]
   [data
    ["[0]" product]
    ["[0]" bit]
    ["[0]" text]
    [collection
     ["[0]" list (.use "[1]#[0]" functor mix)]
     ["[0]" stack (.use "[1]#[0]" functor mix)]]]
   [math
    [number
     ["[0]" natural]
     ["[0]" integer]
     ["[0]" revolution]
     ["[0]" decimal]]]
   [meta
    ["[0]" provenance]
    ["[0]" name]]
   [compiler
    ["/" type]]]])

(the with_template (.in_module# .prelude .with_template))

(with_template [<name> <type> <tag>]
  [(the .public <name>
     (-> <type>
         /.Code)
     (|>> {<tag> provenance.dummy}))]
  
  [bit /.Bit /.#Bit]
  [natural /.Natural /.#Natural]
  [integer /.Integer /.#Integer]
  [revolution /.Revolution /.#Revolution]
  [decimal /.Decimal /.#Decimal]
  [text /.Text /.#Text]
  [name /.Name /.#Name]
  )

(with_template [<name> <type> <tag>]
  [(the .public <name>
     (-> <type>
         /.Code)
     (|>> {<tag> provenance.dummy}))]
  
  [form (/.List /.Code) /.#Form]
  [variant (/.List /.Code) /.#Variant]
  [tuple (/.List /.Code) /.#Tuple]
  )

(the .public local
  (-> /.Text
      /.Code)
  (|>> [""]
       {/.#Name provenance.dummy}))

(`` (the .public equivalence
      (Equivalence /.Code)
      (implementation
       (the (= x y)
         (when [x y]
           (,, (with_template [<tag> <eq>]
                 [[{<tag> _ x} {<tag> _ y}]
                  (by <eq> = x y)]

                 [/.#Bit bit.equivalence]
                 [/.#Natural natural.equivalence]
                 [/.#Integer integer.equivalence]
                 [/.#Revolution revolution.equivalence]
                 [/.#Decimal decimal.equivalence]
                 [/.#Text text.equivalence]
                 [/.#Name name.equivalence]))

           (,, (with_template [<tag>]
                 [[{<tag> _ xs} {<tag> _ ys}]
                  (by (list.equivalence =) = xs ys)]

                 [/.#Form]
                 [/.#Variant]
                 [/.#Tuple]))
           
           _
           false)))))

(alias [=]
       ..equivalence)

(the .public (absolute it)
  (text.Injection /.Code)
  (`` (when it
        (,, (with_template [<tag> <struct>]
              [{<tag> _ value}
               (by <struct> as value)]

              [/.#Bit bit.text]
              [/.#Natural natural.base_10]
              [/.#Integer integer.base_10]
              [/.#Revolution revolution.base_10]
              [/.#Decimal decimal.base_10]
              [/.#Name name.absolute]))

        {/.#Text _ value}
        (text.as_text value)

        (,, (with_template [<open> <close> <tag>]
              [{<tag> _ members}
               (.text <open>
                      (list#mix (function (_ next prev)
                                  (let [next (absolute next)]
                                    (if (text.= "" prev)
                                        next
                                        (.text prev " " next))))
                                ""
                                members)
                      <close>)]

              ["(" ")" /.#Form]
              ["{" "}" /.#Variant]
              ["[" "]" /.#Tuple]))
        )))

(the .public (relative module it)
  (-> Text
      (text.Injection /.Code))
  (`` (when it
        (,, (with_template [<tag> <struct>]
              [{<tag> _ value}
               (by <struct> as value)]

              [/.#Bit bit.text]
              [/.#Natural natural.base_10]
              [/.#Integer integer.base_10]
              [/.#Revolution revolution.base_10]
              [/.#Decimal decimal.base_10]
              [/.#Name (name.relative module)]))

        {/.#Text _ value}
        (text.as_text value)

        (,, (with_template [<open> <close> <tag>]
              [{<tag> _ members}
               (.text <open>
                      (list#mix (function (_ next prev)
                                  (let [next (relative module next)]
                                    (if (text.= "" prev)
                                        next
                                        (.text prev " " next))))
                                ""
                                members)
                      <close>)]

              ["(" ")" /.#Form]
              ["{" "}" /.#Variant]
              ["[" "]" /.#Tuple]))
        )))

(`` (the .public (replaced original substitute)
      (-> /.Code /.Code
          (Change /.Code))
      (function (replaced it)
        (if (by ..equivalence = original it)
            substitute
            (when it
              (,, (with_template [<tag>]
                    [{<tag> provenance parts}
                     {<tag> provenance (list#each replaced parts)}]

                    [/.#Form]
                    [/.#Variant]
                    [/.#Tuple]))

              _
              it)))))

(alias [as_text]
       ..absolute)

(the .public (provenance it)
  (-> /.Code
      /.Provenance)
  (`` (when it
        (,, (with_template [,tag]
              [{,tag it _}
               it]

              [/.#Bit]
              [/.#Natural]
              [/.#Integer]
              [/.#Revolution]
              [/.#Decimal]
              [/.#Text]
              [/.#Name]
              [/.#Form]
              [/.#Variant]
              [/.#Tuple]
              )))))

(the .public (with provenance it)
  (-> /.Provenance
      (Change /.Code))
  (`` (when it
        (,, (with_template [,tag]
              [{,tag _ it}
               {,tag provenance it}]

              [/.#Bit]
              [/.#Natural]
              [/.#Integer]
              [/.#Revolution]
              [/.#Decimal]
              [/.#Text]
              [/.#Name]
              [/.#Form]
              [/.#Variant]
              [/.#Tuple]
              )))))
