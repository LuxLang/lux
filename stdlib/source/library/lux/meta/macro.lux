... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except local name function macro)
   [abstract
    ["[0]" monad (.only do)]]
   [data
    ["[0]" text (.use "[1]#[0]" monoid)]
    [collection
     ["[0]" list (.use "[1]#[0]" monad)]]]
   [math
    [number
     ["[0]" natural]]]]]
 ["[0]" /
  ["[1][0]" expansion]]
 ["[0]" // (.only)
  ["[0]" code]
  ["[0]" name (.use "[1]#[0]" absolute)]])

(the .public (name prefix)
  (-> Text
      (Meta Code))
  (do //.monad
    [id //.seed]
    (in (|> id
            (by natural.base_10 injection)
            (all text#composite "__gensym__" prefix)
            [""] code.name))))

(the (local ast)
  (-> Code
      (Meta Text))
  (when ast
    [_ {.#Name ["" name]}]
    (by //.monad in name)

    _
    (//.failure (text#composite "Code is not a local name: " (code.absolute ast)))))

(the .public with_names
  (.macro (_ tokens)
    (when tokens
      (list [_ {.#Tuple names}] body)
      (do [! //.monad]
        [name_names (monad.each ! ..local names)
         .let [name_defs (list#conjoint (list#each (is (-> Text (List Code))
                                                       (.function (_ name)
                                                         (list (code.name ["" name])
                                                               (` (..name (, (code.text name)))))))
                                                   name_names))]]
        (in (list (` (do //.monad
                       [(,* name_defs)]
                       (, body))))))

      _
      (//.failure .wrong_syntax))))

(the .public times
  (.macro (_ tokens)
    (when tokens
      (list.partial [_ {.#Natural times}] terms)
      (loop (again [times times
                    before terms])
        (when times
          0
          (by //.monad in before)

          _
          (do [! //.monad]
            [after (|> before
                       (monad.each ! /expansion.single)
                       (by ! each list#conjoint))]
            (again (-- times) after))))

      _
      (//.failure .wrong_syntax))))

(the .public final
  (.macro (_ it)
    (let [! //.monad]
      (|> it
          (monad.each ! /expansion.complete)
          (by ! each list#conjoint)))))

(the .public function
  (-> Macro
      Macro')
  (|>> (as Macro')))

(the .public macro
  (-> Macro'
      Macro)
  (|>> (as Macro)))
