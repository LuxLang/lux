(.using
  [library
   [lux {"-" Primitive int char}
    [abstract
     [equivalence {"+" Equivalence}]
     [hash {"+" Hash}]]
    [data
     ["[0]" text ("[1]#[0]" hash)
      ["%" format {"+" format}]]
     [collection
      ["[0]" list ("[1]#[0]" functor)]]]
    [type
     abstract]]]
  ["[0]" // "_"
   [category {"+" Void Value Return Method Primitive Object Class Array Var Parameter Declaration}]
   ["[1][0]" descriptor]
   ["/[1]" // "_"
    [encoding
     ["[1][0]" name {"+" External}]]]])

(abstract: .public (Signature category)
  Text

  (def: .public signature
    (-> (Signature Any) Text)
    (|>> :representation))

  (template [<category> <name> <descriptor>]
    [(def: .public <name>
       (Signature <category>)
       (:abstraction (//descriptor.descriptor <descriptor>)))]

    [Void void //descriptor.void]
    [Primitive boolean //descriptor.boolean]
    [Primitive byte //descriptor.byte]
    [Primitive short //descriptor.short]
    [Primitive int //descriptor.int]
    [Primitive long //descriptor.long]
    [Primitive float //descriptor.float]
    [Primitive double //descriptor.double]
    [Primitive char //descriptor.char]
    )

  (def: .public array
    (-> (Signature Value) (Signature Array))
    (|>> :representation
         (format //descriptor.array_prefix)
         :abstraction))

  (def: .public wildcard
    (Signature Parameter)
    (:abstraction "*"))

  (def: .public var_prefix "T")
  
  (def: .public var
    (-> Text (Signature Var))
    (|>> (text.enclosed [..var_prefix //descriptor.class_suffix])
         :abstraction))

  (def: .public var_name
    (-> (Signature Var) Text)
    (|>> :representation
         (text.replaced ..var_prefix "")
         (text.replaced //descriptor.class_suffix "")))

  (def: .public lower_prefix "-")
  (def: .public upper_prefix "+")
  
  (template [<name> <prefix>]
    [(def: .public <name>
       (-> (Signature Class) (Signature Parameter))
       (|>> :representation (format <prefix>) :abstraction))]

    [lower ..lower_prefix]
    [upper ..upper_prefix]
    )

  (template [<char> <name>]
    [(def: .public <name>
       <char>)]

    ["<" parameters_start]
    [">" parameters_end]
    )

  (def: .public (class name parameters)
    (-> External (List (Signature Parameter)) (Signature Class))
    (:abstraction
     (format //descriptor.class_prefix
             (|> name ///name.internal ///name.read)
             (case parameters
               {.#End}
               ""

               _
               (format ..parameters_start
                       (|> parameters
                           (list#each ..signature)
                           text.together)
                       ..parameters_end))
             //descriptor.class_suffix)))

  (def: .public (declaration name variables)
    (-> External (List (Signature Var)) (Signature Declaration))
    (:transmutation (..class name variables)))

  (def: .public as_class
    (-> (Signature Declaration) (Signature Class))
    (|>> :transmutation))

  (def: .public arguments_start "(")
  (def: .public arguments_end ")")

  (def: .public exception_prefix "^")

  (def: class_bound
    (|> (..class "java.lang.Object" (list))
        ..signature
        (format ":")))

  (def: .public (method [type_variables inputs output exceptions])
    (-> [(List (Signature Var))
         (List (Signature Value))
         (Signature Return)
         (List (Signature Class))]
        (Signature Method))
    (:abstraction
     (format (case type_variables
               {.#End}
               ""
               _
               (|> type_variables
                   (list#each (|>> ..var_name
                                   (text.suffix ..class_bound)))
                   text.together
                   (text.enclosed [..parameters_start
                                   ..parameters_end])))
             (|> inputs
                 (list#each ..signature)
                 text.together
                 (text.enclosed [..arguments_start
                                 ..arguments_end]))
             (:representation output)
             (|> exceptions
                 (list#each (|>> :representation (format ..exception_prefix)))
                 text.together))))

  (implementation: .public equivalence
    (All (_ category) (Equivalence (Signature category)))
    
    (def: (= parameter subject)
      (text#= (:representation parameter)
              (:representation subject))))

  (implementation: .public hash
    (All (_ category) (Hash (Signature category)))

    (def: &equivalence ..equivalence)
    (def: hash (|>> :representation text#hash)))
  )
