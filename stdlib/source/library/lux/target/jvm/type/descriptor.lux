(.module:
  [library
   [lux (#- int char)
    [abstract
     [equivalence (#+ Equivalence)]]
    [control
     ["." maybe]]
    [data
     ["." text ("#\." equivalence)
      ["%" format (#+ format)]]
     [collection
      ["." list ("#\." functor)]]]
    [math
     [number
      ["n" nat]]]
    [type
     abstract]]]
  ["." // #_
   [category (#+ Void Value Return Method Primitive Object Class Array Var Parameter Declaration)]
   ["/#" // #_
    [encoding
     ["#." name (#+ Internal External)]]]])

(abstract: .public (Descriptor category)
  {}
  
  Text

  (def: .public descriptor
    (-> (Descriptor Any) Text)
    (|>> :representation))

  (template [<sigil> <category> <name>]
    [(def: .public <name>
       (Descriptor <category>)
       (:abstraction <sigil>))]

    ["V" Void void]
    ["Z" Primitive boolean]
    ["B" Primitive byte]
    ["S" Primitive short]
    ["I" Primitive int]
    ["J" Primitive long]
    ["F" Primitive float]
    ["D" Primitive double]
    ["C" Primitive char]
    )

  (def: .public class_prefix "L")
  (def: .public class_suffix ";")

  (def: .public class
    (-> External (Descriptor Class))
    (|>> ///name.internal
         ///name.read
         (text.enclosed [..class_prefix ..class_suffix])
         :abstraction))

  (def: .public (declaration name)
    (-> External (Descriptor Declaration))
    (:transmutation (..class name)))

  (def: .public as_class
    (-> (Descriptor Declaration) (Descriptor Class))
    (|>> :transmutation))

  (template [<name> <category>]
    [(def: .public <name>
       (Descriptor <category>)
       (:transmutation
        (..class "java.lang.Object")))]

    [var Var]
    [wildcard Parameter]
    )

  (def: .public (lower descriptor)
    (-> (Descriptor Class) (Descriptor Parameter))
    ..wildcard)

  (def: .public upper
    (-> (Descriptor Class) (Descriptor Parameter))
    (|>> :transmutation))
  
  (def: .public array_prefix "[")

  (def: .public array
    (-> (Descriptor Value)
        (Descriptor Array))
    (|>> :representation
         (format ..array_prefix)
         :abstraction))

  (def: .public (method [inputs output])
    (-> [(List (Descriptor Value))
         (Descriptor Return)]
        (Descriptor Method))
    (:abstraction
     (format (|> inputs
                 (list\map ..descriptor)
                 text.joined
                 (text.enclosed ["(" ")"]))
             (:representation output))))

  (implementation: .public equivalence
    (All [category] (Equivalence (Descriptor category)))
    
    (def: (= parameter subject)
      (text\= (:representation parameter) (:representation subject))))

  (def: .public class_name
    (-> (Descriptor Object) Internal)
    (let [prefix_size (text.size ..class_prefix)
          suffix_size (text.size ..class_suffix)]
      (function (_ descriptor)
        (let [repr (:representation descriptor)]
          (if (text.starts_with? ..array_prefix repr)
            (///name.internal repr)
            (|> repr
                (text.clip prefix_size
                           (|> (text.size repr)
                               (n.- prefix_size)
                               (n.- suffix_size)))
                (\ maybe.monad map ///name.internal)
                maybe.trusted))))))
  )
