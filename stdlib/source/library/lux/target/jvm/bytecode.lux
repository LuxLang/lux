... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except Stack stack
                Type Label Integer
                try except)
   ["[0]" ffi]
   [abstract
    [monoid (.only Monoid)]
    [functor (.only Functor)]
    ["[0]" monad (.only Monad)]]
   [control
    ["[0]" writer (.only Writer)]
    ["[0]" state]
    ["[0]" maybe]]
   [error
    ["[0]" try (.only Try) (.use "[1]:[0]" monad)]
    ["[0]" exception]]
   [data
    ["[0]" product]
    [text
     ["%" \\injection]]
    [collection
     ["[0]" list (.use "[1]:[0]" functor mix monoid)]
     ["[0]" stack (.use "[1]:[0]" functor mix)]
     ["[0]" dictionary (.only Dictionary)]
     ["[0]" sequence (.only Sequence)]]]
   [math
    [number
     ["n[0]" /08
      ["[1]" natural]]
     ["n[0]" /16
      ["[1]" natural]]
     ["[0]" /32
      ["[1]" integer]]
     [/64
      ["n" natural]
      ["i" integer]]]]
   [macro
    ["[0]" template]
    ["[0]" expansion]]
   [meta
    ["[0]" name]]]]
 ["[0]" /
  ["[1]" instruction (.only Primitive_Array_Type Instruction Estimator) (.use "[1]:[0]" monoid)]
  ["[0]" jump (.only Jump)]
  ["[1][0]" address (.only Address)]
  ["[1][0]" environment (.only Environment)
   [limit
    ["/[0]" registry (.only Register Registry)]
    ["/[0]" stack (.only Stack)]]]
  ["/[1]" //
   ["[1][0]" index (.only Index)]
   [encoding
    ["[1][0]" signed (.only S1 S2)]
    [name
     ["[0]" internal]]]
   [constant
    [utf8 (.only UTF8)]
    [integer (.only Integer)]
    [float (.only Float)]
    ["[0]" pool (.only Pool Resource)]]
   [attribute
    ["[0]" line_number_table (.only Line_Number_Table)]
    [code
     ["[1][0]" exception (.only Exception)]]]
   ["[0]" type (.only Type)
    [category (.only Class Object Value Return Method)]
    ["[0]" reflection]
    ["[0]" projection]]]])

(every .public Label
  Natural)

(every Resolver
  (Dictionary Label [Stack (Maybe Address)]))

(every Tracker
  (Record
   [#program_counter Address
    #next Label
    #known Resolver
    #line_number_table Line_Number_Table]))

(the fresh
  Tracker
  [#program_counter /address.start
   #next 0
   #known (dictionary.empty n.hash)
   #line_number_table line_number_table.empty])

(every Relative
  (-> Resolver
      (Try [(Sequence Exception)
            Instruction])))

(the no_exceptions
  (Sequence Exception)
  sequence.empty)

(the relative:identity
  Relative
  (function (_ _)
    {try.#Success [..no_exceptions /.empty]}))

(the try|do
  (template.macro (_ <binding> <term> <then>)
    [(.when <term>
       {try.#Success <binding>}
       <then>

       failure
       (as_expected failure))]))

(the try|in
  (template.macro (_ <it>)
    [{try.#Success <it>}]))

(the (relative:composite left right)
  (-> Relative Relative
      Relative)
  (if (identical? ..relative:identity left)
      right

      (identical? ..relative:identity right)
      left

      ... else
      (function (_ resolver)
        (<| (try|do [left_exceptions left_instruction] (left resolver))
            (try|do [right_exceptions right_instruction] (right resolver))
            (try|in [(by sequence.monoid composite left_exceptions right_exceptions)
                     (/:composite left_instruction right_instruction)])))))

(the relative_monoid
  (Monoid Relative)
  (implementation
   (the identity ..relative:identity)
   (the composite ..relative:composite)))

(every .public (Bytecode it)
  (state.With [Pool Environment Tracker] Try
    (Writer Relative it)))

(the .public new_label
  (Bytecode Label)
  (function (_ [pool environment tracker])
    {try.#Success
     [[pool
       environment
       (revised #next ++ tracker)]
      [..relative:identity
       (its #next tracker)]]}))

(exception.the .public (label_has_already_been_set label)
  (exception.Exception Label)
  (exception.report
   (list ["Label" (%.natural label)])))

(exception.the .public (mismatched_environments [instruction label address expected actual])
  (exception.Exception [Name Label Address Stack Stack])
  (exception.report
   (list ["Instruction" (name.as_text instruction)]
         ["Label" (%.natural label)]
         ["Address" (/address.as_text address)]
         ["Expected" (/stack.as_text expected)]
         ["Actual" (/stack.as_text actual)])))

(exception.the .public (unknown_label label)
  (exception.Exception Label)
  (exception.report
   (list ["Label" (%.natural label)])))

(the .public (set? label)
  (-> Label
      (Bytecode (Try [Stack Address])))
  (function (_ state)
    (let [[pool environment tracker] state]
      {try.#Success
       [state
        [..relative:identity
         (when (dictionary.value label (its #known tracker))
           {try.#Success [expected {.#Some address}]}
           {try.#Success [expected address]}
           
           failure
           (exception.except ..unknown_label [label]))]]})))

(the .public (acknowledged? label)
  (-> Label
      (Bytecode (Try Stack)))
  (function (_ state)
    (let [[pool environment tracker] state]
      {try.#Success
       [state
        [..relative:identity
         (when (dictionary.value label (its #known tracker))
           {try.#Success [expected {.#None}]}
           {try.#Success expected}

           failure
           (exception.except ..unknown_label [label]))]]})))

(the .public stack
  (Bytecode (Maybe Stack))
  (function (_ state)
    (let [[pool environment tracker] state]
      {try.#Success
       [state
        [..relative:identity
         (its /environment.#stack environment)]]})))

(expansion.let [<success> (these (try|in [[pool
                                           environment
                                           (revised #known
                                                    (dictionary.has label [actual {.#Some @here}])
                                                    tracker)]
                                          [..relative:identity
                                           []]]))]
  (the .public (set_label label)
    (-> Label
        (Bytecode Any))
    (function (_ [pool environment tracker])
      (let [@here (its #program_counter tracker)]
        (when (dictionary.value label (its #known tracker))
          {try.#Success [expected {.#Some address}]}
          (exception.except ..label_has_already_been_set [label])
          
          {try.#Success [expected {.#None}]}
          (<| (try|do [actual environment] (/environment.continue expected environment))
              <success>)

          failure
          (<| (try|do [actual environment] (/environment.continue (|> environment
                                                                      (its /environment.#stack)
                                                                      (maybe.else /stack.empty))
                                                                  environment))
              <success>))))))

(the .public functor
  (Functor Bytecode)
  (implementation
   (the (each $ it)
     (function (_ state)
       (when (it state)
         {try.#Success [state' [relative it]]}
         {try.#Success [state' [relative ($ it)]]}
         
         ... {try.#Failure error}
         failure
         (as_expected failure))))))

(the .public monad
  (Monad Bytecode)
  (implementation
   (the functor ..functor)

   (the (pure it)
     (function (_ state)
       {try.#Success [state [relative:identity it]]}))

   (the (conjoint ^^it)
     (function (_ state)
       (when (^^it state)
         {try.#Success [state' [left ^it]]}
         (when (^it state')
           {try.#Success [state'' [right it]]}
           {try.#Success [state'' [(relative:composite left right) it]]}
           
           ... {try.#Failure error}
           failure
           (as_expected failure))
         
         ... {try.#Failure error}
         failure
         (as_expected failure))))))

(the .public (when_continuous it)
  (-> (Bytecode Any)
      (Bytecode Any))
  (monad.let ..monad
    [stack ..stack]
    (.when stack
      {.#Some _}
      it

      ... {.#None}
      _
      (pure []))))

(the .public (when_acknowledged @ it)
  (-> Label (Bytecode Any)
      (Bytecode Any))
  (monad.let ..monad
    [?@ (..acknowledged? @)]
    (.when ?@
      {try.#Success _}
      it

      failure
      (pure []))))

(the .public (failure error)
  (-> Text
      Bytecode)
  (function (_ _)
    {try.#Failure error}))

(the .public (except exception value)
  (for_any (_ it)
    (-> (exception.Exception it) it
        Bytecode))
  (..failure (exception.error exception value)))

(the .public (resolve environment bytecode)
  (for_any (_ it)
    (-> Environment (Bytecode it)
        (Resource [Environment Line_Number_Table (Sequence Exception) Instruction it])))
  (function (_ pool)
    (<| (try|do [[pool environment tracker] [relative output]] (bytecode [pool environment ..fresh]))
        (try|do [exceptions instruction] (relative (its #known tracker)))
        (try|in [pool [environment
                       (its #line_number_table tracker)
                       exceptions
                       instruction
                       output]]))))

(the (step estimator counter)
  (-> Estimator Address
      Address)
  (/address.move (estimator counter) counter))

(the (bytecode consumption production registry [estimator bytecode] input)
  (for_any (_ it)
    (-> n/16.Number n/16.Number Registry [Estimator (-> it Instruction)] it
        (Bytecode Any)))
  (function (_ [pool environment tracker])
    (<| (try|do environment' (|> environment
                                 (/environment.consumes consumption)
                                 (monad.then try.monad (|>> (/environment.produces production)
                                                            (try:each (/environment.has registry))
                                                            try:conjoint))))
        (let [program_counter' (step estimator (its #program_counter tracker))])
        (try|in [[pool
                  environment'
                  (has #program_counter program_counter' tracker)]
                 [(function (_ _)
                    (try|in [..no_exceptions (bytecode input)]))
                  []]]))))

(template.with [<name> <frames>]
  [(the <name>
     n/16.Number
     (n/16.of <frames>))]

  [[$0 0]
   [$1 1]
   [$2 2]
   [$3 3]
   [$4 4]
   [$5 5]
   [$6 6]])

(template.with [<name> <registry>]
  [(the <name>
     Registry
     (|> <registry>
         n/16.of
         /registry.registry))]

  [[@_ 0]
   [@0 1]
   [@1 2]
   [@2 3]
   [@3 4]
   [@4 5]])

(template.with [<name> <consumption> <production> <registry> <instruction>]
  [(the .public <name>
     (Bytecode Any)
     (..bytecode <consumption>
                 <production>
                 <registry>
                 <instruction>
                 []))]

  [[nop $0 $0 @_ /.nop]
   
   [aconst_null $0 $1 @_ /.aconst_null]

   [iconst_m1 $0 $1 @_ /.iconst_m1]
   [iconst_0 $0 $1 @_ /.iconst_0]
   [iconst_1 $0 $1 @_ /.iconst_1]
   [iconst_2 $0 $1 @_ /.iconst_2]
   [iconst_3 $0 $1 @_ /.iconst_3]
   [iconst_4 $0 $1 @_ /.iconst_4]
   [iconst_5 $0 $1 @_ /.iconst_5]

   [lconst_0 $0 $2 @_ /.lconst_0]
   [lconst_1 $0 $2 @_ /.lconst_1]

   [fconst_0 $0 $1 @_ /.fconst_0]
   [fconst_1 $0 $1 @_ /.fconst_1]
   [fconst_2 $0 $1 @_ /.fconst_2]
   
   [dconst_0 $0 $2 @_ /.dconst_0]
   [dconst_1 $0 $2 @_ /.dconst_1]

   [pop $1 $0 @_ /.pop]
   [pop2 $2 $0 @_ /.pop2]
   
   [dup $1 $2 @_ /.dup]
   [dup_x1 $2 $3 @_ /.dup_x1]
   [dup_x2 $3 $4 @_ /.dup_x2]
   [dup2 $2 $4 @_ /.dup2]
   [dup2_x1 $3 $5 @_ /.dup2_x1]
   [dup2_x2 $4 $6 @_ /.dup2_x2]
   
   [swap $2 $2 @_ /.swap]

   [iaload $2 $1 @_ /.iaload]
   [laload $2 $2 @_ /.laload]
   [faload $2 $1 @_ /.faload]
   [daload $2 $2 @_ /.daload]
   [aaload $2 $1 @_ /.aaload]
   [baload $2 $1 @_ /.baload]
   [caload $2 $1 @_ /.caload]
   [saload $2 $1 @_ /.saload]

   [iload_0 $0 $1 @0 /.iload_0]
   [iload_1 $0 $1 @1 /.iload_1]
   [iload_2 $0 $1 @2 /.iload_2]
   [iload_3 $0 $1 @3 /.iload_3]

   [lload_0 $0 $2 @1 /.lload_0]
   [lload_1 $0 $2 @2 /.lload_1]
   [lload_2 $0 $2 @3 /.lload_2]
   [lload_3 $0 $2 @4 /.lload_3]
   
   [fload_0 $0 $1 @0 /.fload_0]
   [fload_1 $0 $1 @1 /.fload_1]
   [fload_2 $0 $1 @2 /.fload_2]
   [fload_3 $0 $1 @3 /.fload_3]
   
   [dload_0 $0 $2 @1 /.dload_0]
   [dload_1 $0 $2 @2 /.dload_1]
   [dload_2 $0 $2 @3 /.dload_2]
   [dload_3 $0 $2 @4 /.dload_3]
   
   [aload_0 $0 $1 @0 /.aload_0]
   [aload_1 $0 $1 @1 /.aload_1]
   [aload_2 $0 $1 @2 /.aload_2]
   [aload_3 $0 $1 @3 /.aload_3]

   [iastore $3 $0 @_ /.iastore]
   [lastore $4 $0 @_ /.lastore]
   [fastore $3 $0 @_ /.fastore]
   [dastore $4 $0 @_ /.dastore]
   [aastore $3 $0 @_ /.aastore]
   [bastore $3 $0 @_ /.bastore]
   [castore $3 $0 @_ /.castore]
   [sastore $3 $0 @_ /.sastore]

   [istore_0 $1 $0 @0 /.istore_0]
   [istore_1 $1 $0 @1 /.istore_1]
   [istore_2 $1 $0 @2 /.istore_2]
   [istore_3 $1 $0 @3 /.istore_3]

   [lstore_0 $2 $0 @1 /.lstore_0]
   [lstore_1 $2 $0 @2 /.lstore_1]
   [lstore_2 $2 $0 @3 /.lstore_2]
   [lstore_3 $2 $0 @4 /.lstore_3]

   [fstore_0 $1 $0 @0 /.fstore_0]
   [fstore_1 $1 $0 @1 /.fstore_1]
   [fstore_2 $1 $0 @2 /.fstore_2]
   [fstore_3 $1 $0 @3 /.fstore_3]

   [dstore_0 $2 $0 @1 /.dstore_0]
   [dstore_1 $2 $0 @2 /.dstore_1]
   [dstore_2 $2 $0 @3 /.dstore_2]
   [dstore_3 $2 $0 @4 /.dstore_3]
   
   [astore_0 $1 $0 @0 /.astore_0]
   [astore_1 $1 $0 @1 /.astore_1]
   [astore_2 $1 $0 @2 /.astore_2]
   [astore_3 $1 $0 @3 /.astore_3]

   [iadd $2 $1 @_ /.iadd]
   [isub $2 $1 @_ /.isub]
   [imul $2 $1 @_ /.imul]
   [idiv $2 $1 @_ /.idiv]
   [irem $2 $1 @_ /.irem]
   [ineg $1 $1 @_ /.ineg]
   [iand $2 $1 @_ /.iand]
   [ior $2 $1 @_ /.ior]
   [ixor $2 $1 @_ /.ixor]
   [ishl $2 $1 @_ /.ishl]
   [ishr $2 $1 @_ /.ishr]
   [iushr $2 $1 @_ /.iushr]

   [ladd $4 $2 @_ /.ladd]
   [lsub $4 $2 @_ /.lsub]
   [lmul $4 $2 @_ /.lmul]
   [ldiv $4 $2 @_ /.ldiv]
   [lrem $4 $2 @_ /.lrem]
   [lneg $2 $2 @_ /.lneg]
   [land $4 $2 @_ /.land]
   [lor $4 $2 @_ /.lor]
   [lxor $4 $2 @_ /.lxor]
   [lshl $3 $2 @_ /.lshl]
   [lshr $3 $2 @_ /.lshr]
   [lushr $3 $2 @_ /.lushr]
   
   [fadd $2 $1 @_ /.fadd]
   [fsub $2 $1 @_ /.fsub]
   [fmul $2 $1 @_ /.fmul]
   [fdiv $2 $1 @_ /.fdiv]
   [frem $2 $1 @_ /.frem]
   [fneg $1 $1 @_ /.fneg]
   
   [dadd $4 $2 @_ /.dadd]
   [dsub $4 $2 @_ /.dsub]
   [dmul $4 $2 @_ /.dmul]
   [ddiv $4 $2 @_ /.ddiv]
   [drem $4 $2 @_ /.drem]
   [dneg $2 $2 @_ /.dneg]

   [l2i $2 $1 @_ /.l2i]
   [l2f $2 $1 @_ /.l2f]
   [l2d $2 $2 @_ /.l2d]
   
   [f2i $1 $1 @_ /.f2i]
   [f2l $1 $2 @_ /.f2l]
   [f2d $1 $2 @_ /.f2d]
   
   [d2i $2 $1 @_ /.d2i]
   [d2l $2 $2 @_ /.d2l]
   [d2f $2 $1 @_ /.d2f]

   [i2l $1 $2 @_ /.i2l]
   [i2f $1 $1 @_ /.i2f]
   [i2d $1 $2 @_ /.i2d]
   [i2b $1 $1 @_ /.i2b]
   [i2c $1 $1 @_ /.i2c]
   [i2s $1 $1 @_ /.i2s]

   [lcmp $4 $1 @_ /.lcmp]
   
   [fcmpl $2 $1 @_ /.fcmpl]
   [fcmpg $2 $1 @_ /.fcmpg]

   [dcmpl $4 $1 @_ /.dcmpl]
   [dcmpg $4 $1 @_ /.dcmpg]

   [arraylength $1 $1 @_ /.arraylength]
   
   [monitorenter $1 $0 @_ /.monitorenter]
   [monitorexit $1 $0 @_ /.monitorexit]])

(the discontinuity!
  (Bytecode Any)
  (function (_ [pool environment tracker])
    (<| (try|do _ (/environment.stack environment))
        (try|in [[pool
                  (/environment.discontinue environment)
                  tracker]
                 [..relative:identity
                  []]]))))

(template.with [<name> <consumption> <instruction>]
  [(the .public <name>
     (Bytecode Any)
     (monad.let ..monad
       [_ (..bytecode <consumption> $0 @_ <instruction> [])]
       ..discontinuity!))]

  [[ireturn $1 /.ireturn]
   [lreturn $2 /.lreturn]
   [freturn $1 /.freturn]
   [dreturn $2 /.dreturn]
   [areturn $1 /.areturn]
   [return $0 /.return]

   [athrow $1 /.athrow]])

(the .public (bipush byte)
  (-> S1
      (Bytecode Any))
  (..bytecode $0 $1 @_ /.bipush [byte]))

(the (lifted resource)
  (for_any (_ it)
    (-> (Resource it)
        (Bytecode it)))
  (function (_ [pool environment tracker])
    (<| (try|do [pool' output] (resource pool))
        (try|in [[pool' environment tracker]
                 [..relative:identity
                  output]]))))

(the Small_Index
  n/08.Number)

(the (small_index it)
  (for_any (_ it)
    (-> (Index it)
        (Either (Index it)
                Small_Index)))
  (let [it' (|> it //index.value n/16.as)]
    (if (n/08.valid? it')
        {.#Right (n/08.of it')}
        {.#Left it})))

(the .public (string value)
  (-> UTF8
      (Bytecode Any))
  (monad.let [! ..monad]
    [index (..lifted (pool.string value))]
    (when (small_index index)
      {.#Right index}
      (..bytecode $0 $1 @_ /.ldc [index])

      {.#Left index}
      (..bytecode $0 $1 @_ /.ldc_w/string [index]))))

(ffi.the java/lang/Long
  "[1]::[0]")

(ffi.the java/lang/Float
  "[1]::[0]"
  ("static" floatToRawIntBits "manual" [float] int))

(ffi.the java/lang/Double
  "[1]::[0]"
  ("static" doubleToRawLongBits "manual" [double] long))

(template.with [<name> <type> <constant> <wide> <to_lux> <specializations>]
  [(the .public (<name> value)
     (-> <type>
         (Bytecode Any))
     (`` (when (|> value <to_lux>)
           (,, (template.with [<special> <instruction>]
                 [<special> (..bytecode $0 $1 @_ <instruction> [])]

                 <specializations>))
           
           _ (monad.let ..monad
               [index (..lifted (<constant> value))]
               (when (small_index index)
                 {.#Right index}
                 (..bytecode $0 $1 @_ /.ldc [index])

                 {.#Left index}
                 (..bytecode $0 $1 @_ <wide> [index]))))))]

  [[int Integer pool.integer /.ldc_w/integer
    (<| .integer /32.as)
    [[-1 /.iconst_m1]
     [+0 /.iconst_0]
     [+1 /.iconst_1]
     [+2 /.iconst_2]
     [+3 /.iconst_3]
     [+4 /.iconst_4]
     [+5 /.iconst_5]]]])

(template.with [<name> <type> <constant> <wide> <to_lux> <specializations>]
  [(the .public (<name> value)
     (-> <type>
         (Bytecode Any))
     (`` (when (|> value <to_lux>)
           (,, (template.with [<special> <instruction>]
                 [<special> (..bytecode $0 $2 @_ <instruction> [])]

                 <specializations>))
           
           _ (monad.let ..monad
               [index (..lifted (<constant> value))]
               (..bytecode $0 $2 @_ <wide> [index])))))]

  [[long .Integer pool.long /.ldc2_w/long
    (<|)
    [[+0 /.lconst_0]
     [+1 /.lconst_1]]]])

(the (arbitrary_float value)
  (-> Float
      (Bytecode Any))
  (monad.let ..monad
    [index (..lifted (pool.float value))]
    (when (small_index index)
      {.#Right index}
      (..bytecode $0 $1 @_ /.ldc [index])

      {.#Left index}
      (..bytecode $0 $1 @_ /.ldc_w/float [index]))))

(the float_bits
  (-> Float
      .Integer)
  (|>> [] java/lang/Float::floatToRawIntBits
       ffi.int_to_long
       (as (-> java/lang/Long .Integer))))

(the negative_zero_float_bits
  (|> -0.0
      (as (-> Decimal java/lang/Double))
      ffi.double_to_float
      ..float_bits))

(the .public (float value)
  (-> Float
      (Bytecode Any))
  (if (i.= ..negative_zero_float_bits
           (..float_bits value))
      (..arbitrary_float value)
      (`` (when (|> value
                    ffi.float_to_double
                    (as (-> java/lang/Double Decimal)))
            (,, (template.with [<special> <instruction>]
                  [<special> (..bytecode $0 $1 @_ <instruction> [])]

                  [[+0.0 /.fconst_0]
                   [+1.0 /.fconst_1]
                   [+2.0 /.fconst_2]]))
            
            _
            (..arbitrary_float value)))))

(the (arbitrary_double value)
  (-> Decimal
      (Bytecode Any))
  (monad.let ..monad
    [index (..lifted (pool.double value))]
    (..bytecode $0 $2 @_ /.ldc2_w/double [index])))

(the double_bits
  (-> Decimal
      .Integer)
  (|>> (as (-> Decimal java/lang/Double))
       [] java/lang/Double::doubleToRawLongBits
       (as (-> java/lang/Long .Integer))))

(the negative_zero_double_bits
  (..double_bits -0.0))

(the .public (double value)
  (-> Decimal
      (Bytecode Any))
  (if (i.= ..negative_zero_double_bits
           (..double_bits value))
      (..arbitrary_double value)
      (`` (when value
            (,, (template.with [<special> <instruction>]
                  [<special> (..bytecode $0 $2 @_ <instruction> [])]

                  [[+0.0 /.dconst_0]
                   [+1.0 /.dconst_1]]))
            
            _ (..arbitrary_double value)))))

(exception.the .public (invalid_register id)
  (exception.Exception Natural)
  (exception.report
   (list ["ID" (%.natural id)])))

(the (register id)
  (-> Natural
      (Bytecode Register))
  (if (n/08.valid? id)
      (by ..monad pure (n/08.of id))
      (..except ..invalid_register [id])))

(template.with [<for> <size> <name> <general> <specials>]
  [(the .public (<name> local)
     (-> Natural
         (Bytecode Any))
     (`` (when local
           (,, (template.with [<case> <instruction> <registry>]
                 [<case> (..bytecode $0 <size> <registry> <instruction> [])]
                 
                 <specials>))
           _ (monad.let ..monad
               [local (..register local)]
               (..bytecode $0 <size> (<for> local) <general> [local])))))]
  
  [[/registry.for $1 iload /.iload
    [[0 /.iload_0 @0]
     [1 /.iload_1 @1]
     [2 /.iload_2 @2]
     [3 /.iload_3 @3]]]
   [/registry.for_wide $2 lload /.lload
    [[0 /.lload_0 @1]
     [1 /.lload_1 @2]
     [2 /.lload_2 @3]
     [3 /.lload_3 @4]]]
   [/registry.for $1 fload /.fload
    [[0 /.fload_0 @0]
     [1 /.fload_1 @1]
     [2 /.fload_2 @2]
     [3 /.fload_3 @3]]]
   [/registry.for_wide $2 dload /.dload
    [[0 /.dload_0 @1]
     [1 /.dload_1 @2]
     [2 /.dload_2 @3]
     [3 /.dload_3 @4]]]
   [/registry.for $1 aload /.aload
    [[0 /.aload_0 @0]
     [1 /.aload_1 @1]
     [2 /.aload_2 @2]
     [3 /.aload_3 @3]]]])

(template.with [<for> <size> <name> <general> <specials>]
  [(the .public (<name> local)
     (-> Natural
         (Bytecode Any))
     (`` (when local
           (,, (template.with [<case> <instruction> <registry>]
                 [<case> (..bytecode <size> $0 <registry> <instruction> [])]
                 
                 <specials>))
           _ (monad.let ..monad
               [local (..register local)]
               (..bytecode <size> $0 (<for> local) <general> [local])))))]
  
  [[/registry.for $1 istore /.istore
    [[0 /.istore_0 @0]
     [1 /.istore_1 @1]
     [2 /.istore_2 @2]
     [3 /.istore_3 @3]]]
   [/registry.for_wide $2 lstore /.lstore
    [[0 /.lstore_0 @1]
     [1 /.lstore_1 @2]
     [2 /.lstore_2 @3]
     [3 /.lstore_3 @4]]]
   [/registry.for $1 fstore /.fstore
    [[0 /.fstore_0 @0]
     [1 /.fstore_1 @1]
     [2 /.fstore_2 @2]
     [3 /.fstore_3 @3]]]
   [/registry.for_wide $2 dstore /.dstore
    [[0 /.dstore_0 @1]
     [1 /.dstore_1 @2]
     [2 /.dstore_2 @3]
     [3 /.dstore_3 @4]]]
   [/registry.for $1 astore /.astore
    [[0 /.astore_0 @0]
     [1 /.astore_1 @1]
     [2 /.astore_2 @2]
     [3 /.astore_3 @3]]]])

(template.with [<consumption> <production> <name> <instruction> <input>]
  [(the .public <name>
     (-> <input>
         (Bytecode Any))
     (..bytecode <consumption> <production> @_ <instruction>))]
  
  [[$1 $1 newarray /.newarray Primitive_Array_Type]
   [$0 $1 sipush /.sipush S2]])

(exception.the .public (cannot_do_a_big_jump [label @from jump])
  (exception.Exception [Label Address jump.Big])
  (exception.report
   (list ["Label" (%.natural label)]
         ["Start" (|> @from /address.value n/16.as %.natural)]
         ["Target" (|> jump /32.as %.integer)])))

(every Any_Jump
  (Either jump.Big
          Jump))

(the (jump @from @to)
  (-> Address Address
      (Try Any_Jump))
  (let [jump (/32.as (/address.jump @from @to))
        big? (or (i.> (//signed.value //signed.maximum/2)
                      jump)
                 (i.< (//signed.value //signed.minimum/2)
                      jump))]
    (if big?
        {try.#Success {.#Left (/32.of jump)}}
        (try:each (|>> {.#Right}) (//signed.s2 jump)))))

(exception.the .public (unset_label label)
  (exception.Exception Label)
  (exception.report
   (list ["Label" (%.natural label)])))

(the (resolve_label label resolver)
  (-> Label Resolver
      (Try [Stack Address]))
  (when (dictionary.value label resolver)
    {try.#Success [actual {.#Some address}]}
    {try.#Success [actual address]}

    {try.#Success [actual {.#None}]}
    (exception.except ..unset_label [label])
    
    failure
    (exception.except ..unknown_label [label])))

(the (acknowledge_label stack label tracker)
  (-> Stack Label
      (Change Tracker))
  (when (dictionary.value label (its #known tracker))
    {try.#Success _}
    tracker

    failure
    (revised #known (dictionary.has label [stack {.#None}]) tracker)))

(template.with [<consumption> <name> <instruction>]
  [(the .public (<name> label)
     (-> Label
         (Bytecode Any))
     (let [[estimator bytecode] <instruction>]
       (function (_ [pool environment tracker])
         (<| (let [@here (its #program_counter tracker)])
             (try|do environment' (|> environment
                                      (/environment.consumes <consumption>)))
             (try|do actual (/environment.stack environment'))
             (let [program_counter' (step estimator @here)])
             (try|in (let [@from @here]
                       [[pool
                         environment'
                         (|> tracker
                             (..acknowledge_label actual label)
                             (has #program_counter program_counter'))]
                        [(function (_ resolver)
                           (<| (try|do [expected @to] (..resolve_label label resolver))
                               (try|do _ (exception.assertion ..mismatched_environments [(name <instruction>) label @here expected actual]
                                                              (by /stack.equivalence = expected actual)))
                               (try|do jump (..jump @from @to))
                               (when jump
                                 {.#Left jump}
                                 (exception.except ..cannot_do_a_big_jump [label @from jump])

                                 {.#Right jump}
                                 (try|in [..no_exceptions (bytecode jump)]))))
                         []]]))))))]

  [[$1 ifeq /.ifeq]
   [$1 ifne /.ifne]
   [$1 iflt /.iflt]
   [$1 ifge /.ifge]
   [$1 ifgt /.ifgt]
   [$1 ifle /.ifle]
   
   [$1 ifnull /.ifnull]
   [$1 ifnonnull /.ifnonnull]

   [$2 if_icmpeq /.if_icmpeq]
   [$2 if_icmpne /.if_icmpne]
   [$2 if_icmplt /.if_icmplt]
   [$2 if_icmpge /.if_icmpge]
   [$2 if_icmpgt /.if_icmpgt]
   [$2 if_icmple /.if_icmple]
   
   [$2 if_acmpeq /.if_acmpeq]
   [$2 if_acmpne /.if_acmpne]])

(template.with [<name> <instruction> <on_long_jump> <on_short_jump>]
  [(the .public (<name> label)
     (-> Label
         (Bytecode Any))
     (let [[estimator bytecode] <instruction>]
       (function (_ [pool environment tracker])
         (<| (try|do actual (/environment.stack environment))
             (let [@here (its #program_counter tracker)
                   program_counter' (step estimator @here)])
             (try|in (let [@from @here]
                       [[pool
                         (/environment.discontinue environment)
                         (|> tracker
                             (..acknowledge_label actual label)
                             (has #program_counter program_counter'))]
                        [(function (_ resolver)
                           (when (dictionary.value label resolver)
                             {try.#Success [expected {.#Some @to}]}
                             (<| (try|do _ (exception.assertion ..mismatched_environments [(name <instruction>) label @here expected actual]
                                                                (by /stack.equivalence = expected actual)))
                                 (try|do jump (..jump @from @to))
                                 (when jump
                                   {.#Left jump}
                                   <on_long_jump>

                                   {.#Right jump}
                                   <on_short_jump>))

                             {try.#Success [expected {.#None}]}
                             (exception.except ..unset_label [label])

                             failure
                             (exception.except ..unknown_label [label])))
                         []]]))))))]

  [[goto /.goto
    (exception.except ..cannot_do_a_big_jump [label @from jump])
    (try|in [..no_exceptions (bytecode jump)])]
   [goto_w /.goto_w
    (try|in [..no_exceptions (bytecode jump)])
    (try|in [..no_exceptions (bytecode (jump.big jump))])]])

(the (big_jump jump)
  (-> Any_Jump
      jump.Big)
  (when jump
    {.#Left big}
    big

    {.#Right small}
    (jump.big small)))

(exception.the .public invalid_tableswitch)

(the .public (tableswitch minimum default [at_minimum afterwards])
  (-> Integer Label [Label (List Label)]
      (Bytecode Any))
  (let [[estimator bytecode] /.tableswitch]
    (function (_ [pool environment tracker])
      (<| (try|do environment' (|> environment
                                   (/environment.consumes $1)))
          (try|do actual (/environment.stack environment'))
          (let [program_counter' (step (estimator (list.size afterwards)) (its #program_counter tracker))])
          (try|in (let [@from (its #program_counter tracker)]
                    [[pool
                      environment'
                      (|> (list:mix (..acknowledge_label actual) tracker (list:composite (list default at_minimum) afterwards))
                          (has #program_counter program_counter'))]
                     [(function (_ resolver)
                        (let [address (is (-> Label (Try Address))
                                          (function (_ label)
                                            (|> (dictionary.value label resolver)
                                                (monad.then try.monad (|>> product.right
                                                                           (try.of_maybe (exception.error ..unknown_label [label])))))))]
                          (when (monad.let [! try.monad]
                                  [@default (address default)
                                   @at_minimum (address at_minimum)]
                                  (|> afterwards
                                      (list.each' ! address)
                                      (by ! each (|>> [@default @at_minimum]))))
                            {try.#Success [@default @at_minimum @afterwards]}
                            (<| (try|do >default (try:each ..big_jump (..jump @from @default)))
                                (try|do >at_minimum (try:each ..big_jump (..jump @from @at_minimum)))
                                (try|do >afterwards (list.each' try.monad (|>> (..jump @from) (try:each ..big_jump))
                                                                @afterwards))
                                (try|in [..no_exceptions (bytecode minimum >default [>at_minimum >afterwards])]))

                            failure
                            (exception.except ..invalid_tableswitch []))))
                      []]]))))))

(exception.the .public invalid_lookupswitch)

(the .public (lookupswitch default cases)
  (-> Label (List [Integer Label])
      (Bytecode Any))
  (let [cases (list.in_order (function (_ [left _] [right _])
                               (i.< (/32.as left)
                                    (/32.as right)))
                             cases)
        [estimator bytecode] /.lookupswitch]
    (function (_ [pool environment tracker])
      (<| (try|do environment' (|> environment
                                   (/environment.consumes $1)))
          (try|do actual (/environment.stack environment'))
          (let [program_counter' (step (estimator (list.size cases)) (its #program_counter tracker))])
          (try|in (let [@from (its #program_counter tracker)]
                    [[pool
                      environment'
                      (|> (list:mix (..acknowledge_label actual) tracker (list:composite (list default) (list:each product.right cases)))
                          (has #program_counter program_counter'))]
                     [(function (_ resolver)
                        (let [address (is (-> Label (Try Address))
                                          (function (_ label)
                                            (|> (dictionary.value label resolver)
                                                (monad.then try.monad (|>> product.right
                                                                           (try.of_maybe (exception.error ..unknown_label [label])))))))]
                          (when (monad.let [! try.monad]
                                  [@default (address default)]
                                  (|> cases
                                      (list.each' ! (|>> product.right address))
                                      (by ! each (|>> [@default]))))
                            {try.#Success [@default @cases]}
                            (<| (try|do >default (try:each ..big_jump (..jump @from @default)))
                                (try|do >cases (|> @cases
                                                   (list.each' try.monad (|>> (..jump @from) (try:each ..big_jump)))
                                                   (try:each (|>> (list.zipped_2 (list:each product.left cases))))))
                                (try|in [..no_exceptions (bytecode >default >cases)]))

                            failure
                            (exception.except ..invalid_lookupswitch []))))
                      []]]))))))

(the reflection
  (for_any (_ category)
    (-> (Type (Value category))
        Text))
  (|>> type.reflection reflection.reflection))

(template.with [<consumption> <production> <name> <category> <instruction>]
  [(the .public (<name> class)
     (-> (Type <category>)
         (Bytecode Any))
     (monad.let ..monad
       [... TODO: Make sure it's impossible to have indexes greater than U2.
        index (..lifted (pool.class (internal.name (..reflection class))))]
       (..bytecode <consumption> <production> @_ <instruction> [index])))]

  [[$0 $1 new Class /.new]
   [$1 $1 anewarray Object /.anewarray]
   [$1 $1 checkcast Object /.checkcast]
   [$1 $1 instanceof Object /.instanceof]])

(the .public (iinc register increase)
  (-> Natural n/08.Number
      (Bytecode Any))
  (monad.let ..monad
    [register (..register register)]
    (..bytecode $0 $0 (/registry.for register) /.iinc [register increase])))

(exception.the .public (multiarray_cannot_be_zero_dimensional class)
  (exception.Exception (Type Object))
  (exception.report
   (list ["Class" (..reflection class)])))

(the .public (multianewarray class dimensions)
  (-> (Type Object) n/08.Number
      (Bytecode Any))
  (monad.let ..monad
    [_ (is (Bytecode Any)
           (when (n/08.as dimensions)
             0 (..except ..multiarray_cannot_be_zero_dimensional [class])
             _ (pure [])))
     index (..lifted (pool.class (internal.name (..reflection class))))]
    (..bytecode (|> dimensions n/08.as n/16.of) $1 @_ /.multianewarray [index dimensions])))

(the (type_size type)
  (-> (Type Return)
      Natural)
  (if (identical? type.void type)
      0

      (or (identical? type.long type)
          (identical? type.double type))
      2

      ... else
      1))

(template.with [<static?> <name> <instruction> <method>]
  [(the .public (<name> class method type)
     (-> (Type Class) Text (Type Method)
         (Bytecode Any))
     (let [[type_variables inputs output exceptions] (projection.method type)]
       (monad.let ..monad
         [index (<| ..lifted
                    (<method> (..reflection class))
                    [pool.#name method
                     pool.#descriptor (type.descriptor type)])
          .let [consumption (|> inputs
                                (list:each ..type_size)
                                (list:mix n.+ (if <static?> 0 1))
                                n/08.of)
                production (|> output ..type_size n/08.of)]]
         (..bytecode (|> consumption n/08.as n/16.of)
                     (|> production n/08.as n/16.of)
                     @_
                     <instruction> [index consumption production]))))]

  [[1b invokestatic /.invokestatic pool.method]
   [0b invokevirtual /.invokevirtual pool.method]
   [0b invokespecial /.invokespecial pool.method]
   [0b invokeinterface /.invokeinterface pool.interface_method]])

(template.with [<consumption> <name> <1> <2>]
  [(the .public (<name> class field type)
     (-> (Type Class) Text (Type Value)
         (Bytecode Any))
     (monad.let ..monad
       [index (<| ..lifted
                  (pool.field (..reflection class))
                  [pool.#name field
                   pool.#descriptor (type.descriptor type)])]
       (if (or (identical? type.long type)
               (identical? type.double type))
           (..bytecode <consumption> $2 @_ <2> [index])
           (..bytecode <consumption> $1 @_ <1> [index]))))]

  [[$0 getstatic /.getstatic/1 /.getstatic/2]
   [$1 getfield  /.getfield/1  /.getfield/2]])

(template.with [<name> <consumption/1> <1> <consumption/2> <2>]
  [(the .public (<name> class field type)
     (-> (Type Class) Text (Type Value)
         (Bytecode Any))
     (monad.let [! ..monad]
       [index (<| ..lifted
                  (pool.field (..reflection class))
                  [pool.#name field
                   pool.#descriptor (type.descriptor type)])]
       (if (or (identical? type.long type)
               (identical? type.double type))
           (..bytecode <consumption/2> $0 @_ <2> [index])
           (..bytecode <consumption/1> $0 @_ <1> [index]))))]

  [[putstatic $1 /.putstatic/1 $2 /.putstatic/2]
   [putfield  $2 /.putfield/1  $3 /.putfield/2]])

(exception.the .public (invalid_range_for_try [start end])
  (exception.Exception [Address Address])
  (exception.report
   (list ["Start" (|> start /address.value n/16.as %.natural)]
         ["End" (|> end /address.value n/16.as %.natural)])))

(the .public (try @start @end @handler catch)
  (-> Label Label Label (Type Class)
      (Bytecode Any))
  (monad.let ..monad
    [@catch (..lifted (pool.class (internal.name (..reflection catch))))]
    (function (_ [pool environment tracker])
      {try.#Success
       [[pool
         environment
         (..acknowledge_label /stack.catch @handler tracker)]
        [(function (_ resolver)
           (<| (try|do [_ @start] (..resolve_label @start resolver))
               (try|do [_ @end] (..resolve_label @end resolver))
               (try|do _ (if (/address.> @start @end)
                             (try|in [])
                             (exception.except ..invalid_range_for_try [@start @end])))
               (try|do [_ @handler] (..resolve_label @handler resolver))
               (try|in [(sequence.sequence
                         [//exception.#start @start
                          //exception.#end @end
                          //exception.#handler @handler
                          //exception.#catch @catch])
                        /.empty])))
         []]]})))

(the .public (composite pre post)
  (for_any (_ pre post)
    (-> (Bytecode pre) (Bytecode post)
        (Bytecode post)))
  (function (_ state)
    (when (pre state)
      {try.#Success [state' [left _]]}
      (when (post state')
        {try.#Success [state'' [right it]]}
        {try.#Success [state'' [(relative:composite left right) it]]}

        failure
        failure)
      
      failure
      (as_expected failure))))

(the .public (map line)
  (-> Natural
      (Bytecode Any))
  (function (_ [pool environment tracker])
    (let [instruction (/address.value (its #program_counter tracker))
          line (n/16.of line)]
      (try|in [[pool
                environment
                (revised #line_number_table
                         (sequence.suffix [line_number_table.#start_program_counter instruction
                                           line_number_table.#line_number line])
                         tracker)]
               [..relative:identity
                []]]))))
