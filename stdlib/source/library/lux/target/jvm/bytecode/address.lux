(.using
 [library
  [lux (.except)
   [abstract
    [equivalence (.only Equivalence)]
    [monad (.only do)]]
   [control
    ["[0]" try (.only Try)]]
   [data
    [binary
     [\\format (.only Writer)]]
    [text
     ["%" \\format (.only Format)]]]
   [math
    [number
     ["n" nat]]]
   [type
    [primitive (.except)]]]]
 ["[0]" //
  [jump (.only Big_Jump)]
  ["/[1]" //
   [encoding
    ["[1][0]" unsigned (.only U2)]
    ["[1][0]" signed (.only S4)]]]])

(primitive: .public Address
  U2

  (def: .public value
    (-> Address U2)
    (|>> representation))

  (def: .public start
    Address
    (|> 0 ///unsigned.u2 try.trusted abstraction))

  (def: .public (move distance)
    (-> U2 (-> Address (Try Address)))
    (|>> representation
         (///unsigned.+/2 distance)
         (at try.functor each (|>> abstraction))))

  (def: with_sign
    (-> Address (Try S4))
    (|>> representation ///unsigned.value .int ///signed.s4))

  (def: .public (jump from to)
    (-> Address Address (Try Big_Jump))
    (do try.monad
      [from (with_sign from)
       to (with_sign to)]
      (///signed.-/4 from to)))

  (def: .public (after? reference subject)
    (-> Address Address Bit)
    (n.> (|> reference representation ///unsigned.value)
         (|> subject representation ///unsigned.value)))

  (def: .public equivalence
    (Equivalence Address)
    (implementation
     (def: (= reference subject)
       (at ///unsigned.equivalence =
           (representation reference)
           (representation subject)))))

  (def: .public writer
    (Writer Address)
    (|>> representation ///unsigned.writer/2))

  (def: .public format
    (Format Address)
    (|>> representation ///unsigned.value %.nat))
  )
