(.module:
  [library
   [lux "*"
    [abstract
     [equivalence {"+" [Equivalence]}]
     [monad {"+" [do]}]]
    [control
     ["[0]" try {"+" [Try]}]]
    [data
     [format
      [binary {"+" [Writer]}]]
     [text
      ["%" format {"+" [Format]}]]]
    [math
     [number
      ["n" nat]]]
    [type
     abstract]]]
  ["[0]" // "_"
   [jump {"+" [Big_Jump]}]
   ["/[1]" // "_"
    [encoding
     ["[1][0]" unsigned {"+" [U2]}]
     ["[1][0]" signed {"+" [S4]}]]]])

(abstract: .public Address
  U2

  (def: .public value
    (-> Address U2)
    (|>> :representation))

  (def: .public start
    Address
    (|> 0 ///unsigned.u2 try.trusted :abstraction))

  (def: .public (move distance)
    (-> U2 (-> Address (Try Address)))
    (|>> :representation
         (///unsigned.+/2 distance)
         (# try.functor each (|>> :abstraction))))

  (def: with_sign
    (-> Address (Try S4))
    (|>> :representation ///unsigned.value .int ///signed.s4))

  (def: .public (jump from to)
    (-> Address Address (Try Big_Jump))
    (do try.monad
      [from (with_sign from)
       to (with_sign to)]
      (///signed.-/4 from to)))

  (def: .public (after? reference subject)
    (-> Address Address Bit)
    (n.> (|> reference :representation ///unsigned.value)
         (|> subject :representation ///unsigned.value)))

  (implementation: .public equivalence
    (Equivalence Address)
    
    (def: (= reference subject)
      (# ///unsigned.equivalence =
         (:representation reference)
         (:representation subject))))

  (def: .public writer
    (Writer Address)
    (|>> :representation ///unsigned.writer/2))

  (def: .public format
    (Format Address)
    (|>> :representation ///unsigned.value %.nat))
  )
