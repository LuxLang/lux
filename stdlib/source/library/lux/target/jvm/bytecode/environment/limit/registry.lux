... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except Type
                for static has)
   [abstract
    [monad (.only do)]
    ["[0]" equivalence (.only Equivalence)]]
   [error
    ["[0]" try (.only Try) (.use "[1]#[0]" functor)]]
   [data
    [binary
     [\\injection (.only Injection)]]
    [collection
     ["[0]" stack (.use "[1]#[0]" functor mix)]]]
   [math
    ["[0]" random (.only Random) (.use "[1]#[0]" monad)]
    [number
     ["n" natural]
     [natural
      ["[0]" /08]
      ["[0]" /16]]]]
   [macro
    ["[0]" template]]
   [type
    ["[0]" nominal]]]]
 [//
  ["[0]" datum]
  [////
   ["[0]" type (.only)
    ["[1]/[0]" projection]]]])

(every .public Register
  /08.Number)

(the Reification
  /16.Number)

(nominal.every .public Registry
  Reification

  (the .public registry
    (-> Reification
        Registry)
    (|>> nominal.abstraction))

  (the (minimal type)
    (-> type.Method
        Natural)
    (let [[type_variables inputs output exceptions] (type/projection.method type)]
      (|> inputs
          (stack#each (|>> datum.for /16.as))
          (stack#mix n.+ 0))))

  (template.with [<start> <name>]
    [(the .public <name>
       (-> type.Method
           Registry)
       (|>> ..minimal
            (n.+ <start>)
            /16.of
            nominal.abstraction))]

    [0 static]
    [1 virtual]
    )

  (the .public equivalence
    (Equivalence Registry)
    (by equivalence.functor each
        (|>> nominal.reification)
        /16.equivalence))

  (alias [=]
         ..equivalence)

  (the .public as_binary
    (Injection Registry)
    (|>> nominal.reification
         /16.as_binary))

  (the .public (has needed)
    (-> Registry Registry
        Registry)
    (|>> nominal.reification
         (/16.major (nominal.reification needed))
         nominal.abstraction))

  (template.with [<name> <extra>]
    [(the .public <name>
       (-> Register
           Registry)
       (|>> /08.as
            /16.of
            (/16.+ <extra>)
            nominal.abstraction))]

    [for datum.small]
    [for_wide datum.big]
    )

  (the .public random
    (Random Registry)
    (let [limit (++ (/16.as /16.maximum))]
      (random#each (|>> (n.% limit)
                        /16.of
                        nominal.abstraction)
                   random.natural)))
  )

(the .public length
  /16.size)
