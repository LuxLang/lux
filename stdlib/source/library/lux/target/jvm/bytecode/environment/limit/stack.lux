(.module:
  [library
   [lux #*
    [abstract
     ["." equivalence (#+ Equivalence)]]
    [control
     ["." try (#+ Try)]]
    [data
     ["." maybe]
     [text
      ["%" format (#+ Format)]]
     [format
      [binary (#+ Writer)]]]
    [type
     abstract]]]
  ["." ///// #_
   [encoding
    ["#." unsigned (#+ U2)]]])

(abstract: .public Stack
  {}
  
  U2

  (template [<frames> <name>]
    [(def: .public <name>
       Stack
       (|> <frames> /////unsigned.u2 maybe.assume :abstraction))]

    [0 empty]
    [1 catch]
    )

  (def: .public equivalence
    (Equivalence Stack)
    (\ equivalence.functor map
       (|>> :representation)
       /////unsigned.equivalence))

  (def: .public writer
    (Writer Stack)
    (|>> :representation /////unsigned.writer/2))

  (def: stack
    (-> U2 Stack)
    (|>> :abstraction))

  (template [<op> <name>]
    [(def: .public (<name> amount)
       (-> U2 (-> Stack (Try Stack)))
       (|>> :representation
            (<op> amount)
            (\ try.functor map ..stack)))]

    [/////unsigned.+/2 push]
    [/////unsigned.-/2 pop]
    )

  (def: .public (max left right)
    (-> Stack Stack Stack)
    (:abstraction
     (/////unsigned.max/2 (:representation left)
                          (:representation right))))

  (def: .public format
    (Format Stack)
    (|>> :representation /////unsigned.value %.nat))
  )

(def: .public length
  /////unsigned.bytes/2)
