(.module:
  [library
   [lux {"-" [Type static]}
    [abstract
     [monad {"+" [do]}]
     [monoid {"+" [Monoid]}]]
    [control
     ["." try {"+" [Try]}]
     ["." exception {"+" [exception:]}]]]]
  [/
   ["/." limit {"+" [Limit]}
    ["/." stack {"+" [Stack]}]
    ["/." registry {"+" [Registry]}]]
   [///
    [encoding
     [unsigned {"+" [U2]}]]
    [type {"+" [Type]}
     [category {"+" [Method]}]]]])

(type: .public Environment
  (Record
   [#limit Limit
    #stack (Maybe Stack)]))

(template [<name> <limit>]
  [(def: .public (<name> type)
     (-> (Type Method) (Try Environment))
     (do try.monad
       [limit (<limit> type)]
       (in [#limit limit
            #stack (#.Some /stack.empty)])))]

  [static /limit.static]
  [virtual /limit.virtual]
  )

(type: .public Condition
  (-> Environment (Try Environment)))

(implementation: .public monoid
  (Monoid Condition)

  (def: identity (|>> #try.Success))

  (def: (composite left right)
    (function (_ environment)
      (do try.monad
        [environment (left environment)]
        (right environment)))))

(exception: .public discontinuity)

(def: .public (stack environment)
  (-> Environment (Try Stack))
  (case (value@ #..stack environment)
    (#.Some stack)
    (#try.Success stack)

    #.None
    (exception.except ..discontinuity [])))

(def: .public discontinue
  (-> Environment Environment)
  (with@ #..stack #.None))

(exception: .public (mismatched_stacks {expected Stack}
                                       {actual Stack})
  (exception.report
   ["Expected" (/stack.format expected)]
   ["Actual" (/stack.format actual)]))

(def: .public (continue expected environment)
  (-> Stack Environment (Try [Stack Environment]))
  (case (value@ #..stack environment)
    (#.Some actual)
    (if (\ /stack.equivalence = expected actual)
      (#try.Success [actual environment])
      (exception.except ..mismatched_stacks [expected actual]))

    #.None
    (#try.Success [expected (with@ #..stack (#.Some expected) environment)])))

(def: .public (consumes amount)
  (-> U2 Condition)
  ... TODO: Revisit this definition once lenses/optics have been implemented,
  ... since it can probably be simplified with them.
  (function (_ environment)
    (do try.monad
      [previous (..stack environment)
       current (/stack.pop amount previous)]
      (in (with@ #..stack (#.Some current) environment)))))

(def: .public (produces amount)
  (-> U2 Condition)
  (function (_ environment)
    (do try.monad
      [previous (..stack environment)
       current (/stack.push amount previous)
       .let [limit (|> environment
                       (value@ [#..limit #/limit.stack])
                       (/stack.max current))]]
      (in (|> environment
              (with@ #..stack (#.Some current))
              (with@ [#..limit #/limit.stack] limit))))))

(def: .public (has registry)
  (-> Registry Condition)
  (|>> (revised@ [#..limit #/limit.registry] (/registry.has registry))
       #try.Success))
