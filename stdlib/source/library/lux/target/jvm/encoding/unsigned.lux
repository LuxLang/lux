(.using
  [library
   [lux {"-" nat}
    [abstract
     [equivalence {"+" Equivalence}]
     [order {"+" Order}]]
    [control
     ["[0]" try {"+" Try}]
     ["[0]" exception {"+" exception:}]]
    [data
     [text
      ["%" format {"+" format}]]
     ["[0]" format "_"
      ["[1]" binary {"+" Writer}]]]
    [macro
     ["[0]" template]]
    [math
     [number
      ["n" nat]
      ["[0]" i64]]]
    [type
     abstract]]])

(abstract: .public (Unsigned brand)
  Nat

  (def: .public value
    (-> (Unsigned Any) Nat)
    (|>> :representation))

  (implementation: .public equivalence
    (All (_ brand) (Equivalence (Unsigned brand)))
    (def: (= reference sample)
      (n.= (:representation reference)
           (:representation sample))))

  (implementation: .public order
    (All (_ brand) (Order (Unsigned brand)))
    
    (def: &equivalence ..equivalence)
    (def: (< reference sample)
      (n.< (:representation reference)
           (:representation sample))))

  (exception: .public (value_exceeds_the_maximum [type Symbol
                                                  value Nat
                                                  maximum (Unsigned Any)])
    (exception.report
     ["Type" (%.symbol type)]
     ["Value" (%.nat value)]
     ["Maximum" (%.nat (:representation maximum))]))

  (exception: .public [brand] (subtraction_cannot_yield_negative_value
                               [type Symbol
                                parameter (Unsigned brand)
                                subject (Unsigned brand)])
    (exception.report
     ["Type" (%.symbol type)]
     ["Parameter" (%.nat (:representation parameter))]
     ["Subject" (%.nat (:representation subject))]))

  (template [<bytes> <name> <size> <constructor> <maximum> <+> <-> <max>]
    [(with_expansions [<raw> (template.symbol [<name> "'"])]
       (abstract: .public <raw> Any)
       (type: .public <name> (Unsigned <raw>)))

     (def: .public <size> <bytes>)
     
     (def: .public <maximum>
       <name>
       (|> <bytes> (n.* i64.bits_per_byte) i64.mask :abstraction))
     
     (def: .public (<constructor> value)
       (-> Nat (Try <name>))
       (if (n.> (:representation <maximum>) value)
         (exception.except ..value_exceeds_the_maximum [(symbol <name>) value <maximum>])
         {try.#Success (:abstraction value)}))

     (def: .public (<+> parameter subject)
       (-> <name> <name> (Try <name>))
       (<constructor>
        (n.+ (:representation parameter)
             (:representation subject))))

     (def: .public (<-> parameter subject)
       (-> <name> <name> (Try <name>))
       (let [parameter' (:representation parameter)
             subject' (:representation subject)]
         (if (n.> subject' parameter')
           (exception.except ..subtraction_cannot_yield_negative_value [(symbol <name>) parameter subject])
           {try.#Success (:abstraction (n.- parameter' subject'))})))

     (def: .public (<max> left right)
       (-> <name> <name> <name>)
       (:abstraction (n.max (:representation left)
                            (:representation right))))]

    [1 U1 bytes/1 u1 maximum/1 +/1 -/1 max/1]
    [2 U2 bytes/2 u2 maximum/2 +/2 -/2 max/2]
    [4 U4 bytes/4 u4 maximum/4 +/4 -/4 max/4]
    )

  (template [<name> <from> <to>]
    [(def: .public <name>
       (-> <from> <to>)
       (|>> :transmutation))]

    [lifted/2 U1 U2]
    [lifted/4 U2 U4]
    )

  (template [<writer_name> <type> <writer>]
    [(def: .public <writer_name>
       (Writer <type>)
       (|>> :representation <writer>))]

    [writer/1 U1 format.bits/8]
    [writer/2 U2 format.bits/16]
    [writer/4 U4 format.bits/32]
    )
  )
