(.using
 [library
  [lux "*"
   ["[0]" ffi]
   [abstract
    [equivalence {"+" Equivalence}]
    [functor {"+" Functor}]
    [monad {"+" Monad do}]]
   [control
    ["[0]" pipe]
    ["[0]" state {"+" +State}]
    ["[0]" try {"+" Try}]]
   [data
    ["[0]" product]
    ["[0]" text]
    ["[0]" format "_"
     ["[1]" binary {"+" Writer} ("specification#[0]" monoid)]]
    [collection
     ["[0]" sequence {"+" Sequence} ("[1]#[0]" mix)]]]
   [math
    [number
     ["[0]" int]
     ["[0]" frac]
     ["[0]" i32]]]]]
 ["[0]" // {"+" UTF8 String Class Integer Float Long Double Constant Name_And_Type Reference}
  [//
   ["[1][0]" index {"+" Index}]
   [encoding
    ["[1][0]" name {"+" Internal External}]
    ["[1][0]" unsigned]]
   [type
    [category {"+" Value Method}]
    ["[1][0]" descriptor {"+" Descriptor}]]]])

(type: .public Pool
  [Index (Sequence [Index Constant])])

(def: .public equivalence
  (Equivalence Pool)
  (product.equivalence //index.equivalence
                       (sequence.equivalence (product.equivalence //index.equivalence
                                                                  //.equivalence))))

(type: .public (Resource a)
  (+State Try Pool a))

(implementation: .public functor
  (Functor Resource)

  (def: (each $ it)
    (|>> it
         (pipe.case
           {try.#Success [state output]}
           {try.#Success [state ($ output)]}
           
           ... {try.#Failure error}
           failure
           (as_expected failure)))))

(implementation: .public monad
  (Monad Resource)

  (def: functor ..functor)
  
  (def: (in it)
    (function (_ state)
      {try.#Success [state it]}))
  
  (def: (conjoint it)
    (function (_ state)
      (case (it state)
        {try.#Success [state' it']}
        (it' state')

        ... {try.#Failure error}
        failure
        (as_expected failure)))))

(template: (try|each <binding> <value> <body>)
  [(case <value>
     {try.#Success <binding>}
     <body>

     ... {try.#Failure error}
     failure
     (as_expected failure))])

(template: (try|in <it>)
  [{try.#Success <it>}])

(template: (!add <state> <tag> <equivalence> <value>)
  [(let [[current pool] <state>
         <value>' <value>]
     (with_expansions [<try_again> (these (again (.++ idx)))]
       (loop (again [idx 0])
         (case (sequence.item idx pool)
           {try.#Success entry}
           (case entry
             [index {<tag> reference}]
             (if (# <equivalence> = reference <value>')
               {try.#Success [[current pool]
                              index]}
               <try_again>)
             
             _
             <try_again>)
           
           {try.#Failure _}
           (<| (let [new {<tag> <value>'}])
               (try|each @new (//unsigned.u2 (//.size new)))
               (try|each next (is (Try Index)
                                  (|> current
                                      //index.value
                                      (//unsigned.+/2 @new)
                                      (# try.monad each //index.index))))
               (try|in [[next
                         (sequence.suffix [current new] pool)]
                        current]))))))])

(template: (/|do <state> <body>)
  [(function (_ <state>)
     <body>)])

(template: (/|each <state> <binding> <value> <body>)
  [(case (<value> <state>)
     {try.#Success [<state> <binding>]}
     <body>

     ... {try.#Failure error}
     failure
     (as_expected failure))])

(type: (Adder of)
  (-> of (Resource (Index of))))

(template [<name> <type> <tag> <equivalence>]
  [(def: .public (<name> value)
     (Adder <type>)
     (<| (/|do %)
         (!add % <tag> <equivalence> value)))]

  [integer Integer //.#Integer (//.value_equivalence i32.equivalence)]
  [float Float //.#Float (//.value_equivalence //.float_equivalence)]
  [long Long //.#Long (//.value_equivalence int.equivalence)]
  [double Double //.#Double (//.value_equivalence frac.equivalence)]
  [utf8 UTF8 //.#UTF8 text.equivalence]
  )

(def: .public (string value)
  (-> Text (Resource (Index String)))
  (<| (/|do %)
      (/|each % @value (utf8 value))
      (let [value (//.string @value)])
      (!add % //.#String (//.value_equivalence //index.equivalence) value)))

(def: .public (class name)
  (-> Internal (Resource (Index Class)))
  (<| (/|do %)
      (/|each % @name (utf8 (//name.read name)))
      (let [value (//.class @name)])
      (!add % //.#Class //.class_equivalence value)))

(def: .public (descriptor value)
  (All (_ kind)
    (-> (Descriptor kind)
        (Resource (Index (Descriptor kind)))))
  (<| (let [value (//descriptor.descriptor value)])
      (/|do %)
      (!add % //.#UTF8 text.equivalence value)))

(type: .public (Member of)
  (Record
   [#name UTF8
    #descriptor (Descriptor of)]))

(def: .public (name_and_type [name descriptor])
  (All (_ of)
    (-> (Member of) (Resource (Index (Name_And_Type of)))))
  (<| (/|do %)
      (/|each % @name (utf8 name))
      (/|each % @descriptor (..descriptor descriptor))
      (!add % //.#Name_And_Type //.name_and_type_equivalence [//.#name @name //.#descriptor @descriptor])))

(template [<name> <tag> <of>]
  [(def: .public (<name> class member)
     (-> External (Member <of>) (Resource (Index (Reference <of>))))
     (<| (/|do %)
         (/|each % @class (..class (//name.internal class)))
         (/|each % @name_and_type (name_and_type member))
         (!add % <tag> //.reference_equivalence [//.#class @class //.#name_and_type @name_and_type])))]

  [field //.#Field Value]
  [method //.#Method Method]
  [interface_method //.#Interface_Method Method]
  )

(template: (!index <index>)
  [(|> <index> //index.value //unsigned.value)])

(def: .public writer
  (Writer Pool)
  (function (_ [next pool])
    (sequence#mix (function (_ [_index post] pre)
                    (specification#composite pre (//.writer post)))
                  (format.bits_16 (!index next))
                  pool)))

(def: .public empty
  Pool
  [(|> 1 //unsigned.u2 try.trusted //index.index)
   sequence.empty])
