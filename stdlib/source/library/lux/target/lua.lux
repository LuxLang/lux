(.module:
  [library
   [lux (#- Location Code int if cond function or and not let ^ local)
    ["@" target]
    [abstract
     [equivalence (#+ Equivalence)]
     [hash (#+ Hash)]
     ["." enum]]
    [control
     [pipe (#+ case> cond> new>)]
     [parser
      ["<.>" code]]]
    [data
     ["." text
      ["%" format (#+ format)]]
     [collection
      ["." list ("#\." functor mix)]]]
    [macro
     [syntax (#+ syntax:)]
     ["." template]
     ["." code]]
    [math
     [number
      ["n" nat]
      ["i" int]
      ["f" frac]]]
    [type
     abstract]]])

(def: nested
  (-> Text Text)
  (.let [nested_new_line (format text.new_line text.tab)]
    (|>> (format text.new_line)
         (text.replaced text.new_line nested_new_line))))

(def: input_separator ", ")

(abstract: .public (Code brand)
  {}
  
  Text

  (implementation: .public equivalence
    (All [brand] (Equivalence (Code brand)))

    (def: (= reference subject)
      (\ text.equivalence = (:representation reference) (:representation subject))))

  (implementation: .public hash
    (All [brand] (Hash (Code brand)))

    (def: &equivalence ..equivalence)
    (def: hash (|>> :representation (\ text.hash hash))))

  (def: .public manual
    (-> Text Code)
    (|>> :abstraction))

  (def: .public code
    (-> (Code Any) Text)
    (|>> :representation))

  (template [<type> <super>+]
    [(with_expansions [<brand> (template.identifier [<type> "'"])]
       (abstract: (<brand> brand) {} Any)
       (`` (type: .public <type> (|> Any <brand> (~~ (template.spliced <super>+))))))]
    
    [Expression [Code]]
    [Computation [Expression' Code]]
    [Location [Computation' Expression' Code]]
    [Statement [Code]]
    )

  (template [<type> <super>+]
    [(with_expansions [<brand> (template.identifier [<type> "'"])]
       (abstract: .public <brand> {} Any)
       (`` (type: .public <type> (|> <brand> (~~ (template.spliced <super>+))))))]

    [Literal [Computation' Expression' Code]]
    [Var [Location' Computation' Expression' Code]]
    [Access [Location' Computation' Expression' Code]]
    [Label [Code]]
    )

  (def: .public nil
    Literal
    (:abstraction "nil"))

  (def: .public bool
    (-> Bit Literal)
    (|>> (case> #0 "false"
                #1 "true")
         :abstraction))

  (def: .public int
    (-> Int Literal)
    ... Integers must be turned into hexadecimal to avoid quirks in how Lua parses integers.
    ... In particular, the number -9223372036854775808 will be incorrectly parsed as a float by Lua.
    (.let [to_hex (\ n.hex encoded)]
      (|>> .nat
           to_hex
           (format "0x")
           :abstraction)))

  (def: .public float
    (-> Frac Literal)
    (|>> (cond> [(f.= f.positive_infinity)]
                [(new> "(1.0/0.0)" [])]
                
                [(f.= f.negative_infinity)]
                [(new> "(-1.0/0.0)" [])]
                
                [(f.= f.not_a_number)]
                [(new> "(0.0/0.0)" [])]

                ... else
                [%.frac (text.replaced "+" "")])
         :abstraction))

  (def: safe
    (-> Text Text)
    (`` (|>> (~~ (template [<find> <replace>]
                   [(text.replaced <find> <replace>)]

                   ["\" "\\"]
                   [text.tab "\t"]
                   [text.vertical_tab "\v"]
                   [text.null "\0"]
                   [text.back_space "\b"]
                   [text.form_feed "\f"]
                   [text.new_line "\n"]
                   [text.carriage_return "\r"]
                   [text.double_quote (format "\" text.double_quote)]
                   ))
             )))

  (def: .public string
    (-> Text Literal)
    (|>> ..safe (text.enclosed' text.double_quote) :abstraction))

  (def: .public multi
    (-> (List Expression) Literal)
    (|>> (list\map ..code)
         (text.interposed ..input_separator)
         :abstraction))

  (def: .public array
    (-> (List Expression) Literal)
    (|>> (list\map ..code)
         (text.interposed ..input_separator)
         (text.enclosed ["{" "}"])
         :abstraction))

  (def: .public table
    (-> (List [Text Expression]) Literal)
    (|>> (list\map (.function (_ [key value])
                     (format key " = " (:representation value))))
         (text.interposed ..input_separator)
         (text.enclosed ["{" "}"])
         :abstraction))

  (def: .public (nth idx array)
    (-> Expression Expression Access)
    (:abstraction (format (:representation array) "[" (:representation idx) "]")))

  (def: .public (the field table)
    (-> Text Expression Computation)
    (:abstraction (format (:representation table) "." field)))

  (def: .public length
    (-> Expression Computation)
    (|>> :representation
         (text.enclosed ["#(" ")"])
         :abstraction))

  (def: .public (apply/* args func)
    (-> (List Expression) Expression Computation)
    (|> args
        (list\map ..code)
        (text.interposed ..input_separator)
        (text.enclosed ["(" ")"])
        (format (:representation func))
        :abstraction))

  (def: .public (do method args table)
    (-> Text (List Expression) Expression Computation)
    (|> args
        (list\map ..code)
        (text.interposed ..input_separator)
        (text.enclosed ["(" ")"])
        (format (:representation table) ":" method)
        :abstraction))

  (template [<op> <name>]
    [(def: .public (<name> parameter subject)
       (-> Expression Expression Expression)
       (:abstraction (format "("
                             (:representation subject)
                             " " <op> " "
                             (:representation parameter)
                             ")")))]

    ["==" =]
    ["<"  <]
    ["<=" <=]
    [">"  >]
    [">=" >=]
    ["+"  +]
    ["-"  -]
    ["*"  *]
    ["^"  ^]
    ["/"  /]
    ["//" //]
    ["%"  %]
    [".." concat]

    ["or"  or]
    ["and" and]
    ["|"   bit_or]
    ["&"   bit_and]
    ["~"   bit_xor]

    ["<<" bit_shl]
    [">>" bit_shr]
    )

  (template [<name> <unary>]
    [(def: .public (<name> subject)
       (-> Expression Expression)
       (:abstraction (format "(" <unary> " " (:representation subject) ")")))]

    [not "not"]
    [opposite "-"]
    )

  (template [<name> <type>]
    [(def: .public <name>
       (-> Text <type>)
       (|>> :abstraction))]

    [var Var]
    [label Label]
    )

  (def: .public statement
    (-> Expression Statement)
    (|>> :representation :abstraction))

  (def: .public (then pre! post!)
    (-> Statement Statement Statement)
    (:abstraction
     (format (:representation pre!)
             text.new_line
             (:representation post!))))

  (def: locations
    (-> (List Location) Text)
    (|>> (list\map ..code)
         (text.interposed ..input_separator)))

  (def: .public (local vars)
    (-> (List Var) Statement)
    (:abstraction (format "local " (..locations vars))))

  (def: .public (set vars value)
    (-> (List Location) Expression Statement)
    (:abstraction (format (..locations vars) " = " (:representation value))))

  (def: .public (let vars value)
    (-> (List Var) Expression Statement)
    (:abstraction (format "local " (..locations vars) " = " (:representation value))))

  (def: .public (local/1 var value)
    (-> Var Expression Statement)
    (:abstraction (format "local " (:representation var) " = " (:representation value))))

  (def: .public (if test then! else!)
    (-> Expression Statement Statement Statement)
    (:abstraction (format "if " (:representation test)
                          text.new_line "then" (..nested (:representation then!))
                          text.new_line "else" (..nested (:representation else!))
                          text.new_line "end")))

  (def: .public (when test then!)
    (-> Expression Statement Statement)
    (:abstraction (format "if " (:representation test)
                          text.new_line "then" (..nested (:representation then!))
                          text.new_line "end")))

  (def: .public (while test body!)
    (-> Expression Statement Statement)
    (:abstraction
     (format "while " (:representation test) " do"
             (..nested (:representation body!))
             text.new_line "end")))

  (def: .public (repeat until body!)
    (-> Expression Statement Statement)
    (:abstraction
     (format "repeat"
             (..nested (:representation body!))
             text.new_line "until " (:representation until))))

  (def: .public (for_in vars source body!)
    (-> (List Var) Expression Statement Statement)
    (:abstraction
     (format "for " (|> vars
                        (list\map ..code)
                        (text.interposed ..input_separator))
             " in " (:representation source) " do"
             (..nested (:representation body!))
             text.new_line "end")))

  (def: .public (for_step var from to step body!)
    (-> Var Expression Expression Expression Statement
        Statement)
    (:abstraction
     (format "for " (:representation var)
             " = " (:representation from)
             ..input_separator (:representation to)
             ..input_separator (:representation step) " do"
             (..nested (:representation body!))
             text.new_line "end")))

  (def: .public (return value)
    (-> Expression Statement)
    (:abstraction (format "return " (:representation value))))

  (def: .public (closure args body!)
    (-> (List Var) Statement Expression)
    (|> (format "function " (|> args
                                ..locations
                                (text.enclosed ["(" ")"]))
                (..nested (:representation body!))
                text.new_line "end")
        (text.enclosed ["(" ")"])
        :abstraction))

  (template [<name> <code>]
    [(def: .public (<name> name args body!)
       (-> Var (List Var) Statement Statement)
       (:abstraction
        (format <code> " " (:representation name)
                (|> args
                    ..locations
                    (text.enclosed ["(" ")"]))
                (..nested (:representation body!))
                text.new_line "end")))]

    [function "function"]
    [local_function "local function"]
    )

  (def: .public break
    Statement
    (:abstraction "break"))

  (def: .public (set_label label)
    (-> Label Statement)
    (:abstraction (format "::" (:representation label) "::")))

  (def: .public (go_to label)
    (-> Label Statement)
    (:abstraction (format "goto " (:representation label))))
  )

(def: .public (cond clauses else!)
  (-> (List [Expression Statement]) Statement Statement)
  (list\mix (.function (_ [test then!] next!)
              (..if test then! next!))
            else!
            (list.reversed clauses)))

(syntax: (arity_inputs [arity <code>.nat])
  (in (case arity
        0 (.list)
        _ (|> (-- arity)
              (enum.range n.enum 0)
              (list\map (|>> %.nat code.local_identifier))))))

(syntax: (arity_types [arity <code>.nat])
  (in (list.repeated arity (` ..Expression))))

(template [<arity> <function>+]
  [(with_expansions [<apply> (template.identifier ["apply/" <arity>])
                     <inputs> (arity_inputs <arity>)
                     <types> (arity_types <arity>)
                     <definitions> (template.spliced <function>+)]
     (def: .public (<apply> function <inputs>)
       (-> Expression <types> Computation)
       (..apply/* (.list <inputs>) function))

     (template [<function>]
       [(`` (def: .public (~~ (template.identifier [<function> "/" <arity>]))
              (<apply> (..var <function>))))]

       <definitions>))]

  [1
   [["error"]
    ["print"]
    ["require"]
    ["type"]
    ["ipairs"]]]

  [2
   [["print"]
    ["error"]]]

  [3
   [["print"]]]

  [4
   []]

  [5
   []]
  )
