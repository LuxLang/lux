(.module:
  [library
   [lux {"-" Location Code static int if cond function or and not comment local global}
    ["@" target]
    [abstract
     [equivalence {"+" Equivalence}]
     [hash {"+" Hash}]
     ["[0]" enum]]
    [control
     [pipe {"+" case> cond> new>}]
     [parser
      ["<[0]>" code]]]
    [data
     ["[0]" text
      ["%" format {"+" format}]]
     [collection
      ["[0]" list ("[1]#[0]" functor mix)]]]
    [macro
     [syntax {"+" syntax:}]
     ["[0]" template]
     ["[0]" code]]
    [math
     [number
      ["n" nat]
      ["f" frac]]]
    [type
     abstract]]])

(def: input_separator ", ")
(def: statement_suffix ";")

(def: nested
  (-> Text Text)
  (.let [nested_new_line (format text.new_line text.tab)]
    (|>> (format text.new_line)
         (text.replaced text.new_line nested_new_line))))

(abstract: .public (Code brand)
  Text

  (implementation: .public code_equivalence
    (All (_ brand) (Equivalence (Code brand)))

    (def: (= reference subject)
      (# text.equivalence = (:representation reference) (:representation subject))))

  (implementation: .public code_hash
    (All (_ brand) (Hash (Code brand)))

    (def: &equivalence ..code_equivalence)
    (def: hash (|>> :representation (# text.hash hash))))

  (def: .public manual
    (-> Text Code)
    (|>> :abstraction))

  (def: .public code
    (-> (Code Any) Text)
    (|>> :representation))

  (template [<type> <super>+]
    [(with_expansions [<brand> (template.identifier [<type> "'"])]
       (abstract: (<brand> brand) Any)
       (`` (type: .public <type> (|> Any <brand> (~~ (template.spliced <super>+))))))]
    
    [Expression [Code]]
    [Computation [Expression' Code]]
    [Location [Computation' Expression' Code]]
    [Var [Location' Computation' Expression' Code]]
    [LVar [Var' Location' Computation' Expression' Code]]
    [Statement [Code]]
    )

  (template [<type> <super>+]
    [(with_expansions [<brand> (template.identifier [<type> "'"])]
       (abstract: <brand> Any)
       (`` (type: .public <type> (|> <brand> (~~ (template.spliced <super>+))))))]

    [Literal [Computation' Expression' Code]]
    [Access [Location' Computation' Expression' Code]]
    [GVar [Var' Location' Computation' Expression' Code]]
    [IVar [Var' Location' Computation' Expression' Code]]
    [SVar [Var' Location' Computation' Expression' Code]]
    [LVar* [LVar' Var' Location' Computation' Expression' Code]]
    [LVar** [LVar' Var' Location' Computation' Expression' Code]]
    )

  (template [<var> <prefix> <constructor>]
    [(def: .public <constructor>
       (-> Text <var>)
       (|>> (format <prefix>) :abstraction))]

    [GVar "$"  global]
    [IVar "@"  instance]
    [SVar "@@" static]
    )

  (def: .public local
    (-> Text LVar)
    (|>> :abstraction))

  (template [<var> <prefix> <modifier> <unpacker>]
    [(template [<name> <input> <output>]
       [(def: .public <name>
          (-> <input> <output>)
          (|>> :representation (format <prefix>) :abstraction))]

       [<modifier> LVar <var>]
       [<unpacker> Expression Computation]
       )]

    [LVar*  "*"  variadic    splat]
    [LVar** "**" variadic_kv double_splat]
    )

  (template [<ruby_name> <lux_name>]
    [(def: .public <lux_name>
       (..global <ruby_name>))]

    ["@" latest_error]
    ["_" last_string_read]
    ["." last_line_number_read]
    ["&" last_string_matched]
    ["~" last_regexp_match]
    ["=" case_insensitivity_flag]
    ["/" input_record_separator]
    ["\" output_record_separator]
    ["0" script_name]
    ["$" process_id]
    ["?" exit_status]
    )

  (template [<ruby_name> <lux_name>]
    [(def: .public <lux_name>
       (..local <ruby_name>))]

    ["ARGV" command_line_arguments]
    )

  (def: .public nil
    Literal
    (:abstraction "nil"))

  (def: .public bool
    (-> Bit Literal)
    (|>> (case> #0 "false"
                #1 "true")
         :abstraction))

  (def: safe
    (-> Text Text)
    (`` (|>> (~~ (template [<find> <replace>]
                   [(text.replaced <find> <replace>)]

                   ["\" "\\"]
                   [text.tab "\t"]
                   [text.vertical_tab "\v"]
                   [text.null "\0"]
                   [text.back_space "\b"]
                   [text.form_feed "\f"]
                   [text.new_line "\n"]
                   [text.carriage_return "\r"]
                   [text.double_quote (format "\" text.double_quote)]
                   ))
             )))

  (template [<format> <name> <type> <prep>]
    [(def: .public <name>
       (-> <type> Literal)
       (|>> <prep> <format> :abstraction))]

    [%.int  int    Int  (<|)]
    [%.text string Text ..safe]
    [(<|)   symbol Text (format ":")]
    )

  (def: .public float
    (-> Frac Literal)
    (|>> (cond> [(f.= f.positive_infinity)]
                [(new> "(+1.0/0.0)" [])]
                
                [(f.= f.negative_infinity)]
                [(new> "(-1.0/0.0)" [])]
                
                [(f.= f.not_a_number)]
                [(new> "(+0.0/-0.0)" [])]

                ... else
                [%.frac])
         :abstraction))

  (def: .public (array_range from to array)
    (-> Expression Expression Expression Computation)
    (|> (format (:representation from) ".." (:representation to))
        (text.enclosed ["[" "]"])
        (format (:representation array))
        :abstraction))

  (def: .public array
    (-> (List Expression) Literal)
    (|>> (list#each (|>> :representation))
         (text.interposed ..input_separator)
         (text.enclosed ["[" "]"])
         :abstraction))

  (def: .public hash
    (-> (List [Expression Expression]) Literal)
    (|>> (list#each (.function (_ [k v])
                      (format (:representation k) " => " (:representation v))))
         (text.interposed ..input_separator)
         (text.enclosed ["{" "}"])
         :abstraction))

  (def: .public (apply/* args func)
    (-> (List Expression) Expression Computation)
    (|> args
        (list#each (|>> :representation))
        (text.interposed ..input_separator)
        (text.enclosed ["(" ")"])
        (format (:representation func))
        :abstraction))

  (def: .public (apply_lambda/* args lambda)
    (-> (List Expression) Expression Computation)
    (|> args
        (list#each (|>> :representation))
        (text.interposed ..input_separator)
        (text.enclosed ["[" "]"])
        (format (:representation lambda))
        :abstraction))

  (def: .public (the field object)
    (-> Text Expression Access)
    (:abstraction (format (:representation object) "." field)))

  (def: .public (item idx array)
    (-> Expression Expression Access)
    (|> (:representation idx)
        (text.enclosed ["[" "]"])
        (format (:representation array))
        :abstraction))

  (def: .public (? test then else)
    (-> Expression Expression Expression Computation)
    (|> (format (:representation test) " ? "
                (:representation then) " : "
                (:representation else))
        (text.enclosed ["(" ")"])
        :abstraction))

  (def: .public statement
    (-> Expression Statement)
    (|>> :representation
         (text.suffix ..statement_suffix)
         :abstraction))

  (def: .public (then pre! post!)
    (-> Statement Statement Statement)
    (:abstraction
     (format (:representation pre!)
             text.new_line
             (:representation post!))))

  (def: .public (set vars value)
    (-> (List Location) Expression Statement)
    (:abstraction
     (format (|> vars
                 (list#each (|>> :representation))
                 (text.interposed ..input_separator))
             " = " (:representation value) ..statement_suffix)))

  (def: (block content)
    (-> Text Text)
    (format content
            text.new_line "end" ..statement_suffix))

  (def: .public (if test then! else!)
    (-> Expression Statement Statement Statement)
    (<| :abstraction
        ..block
        (format "if " (:representation test)
                (..nested (:representation then!))
                text.new_line "else"
                (..nested (:representation else!)))))

  (template [<name> <block>]
    [(def: .public (<name> test then!)
       (-> Expression Statement Statement)
       (<| :abstraction
           ..block
           (format <block> " " (:representation test)
                   (..nested (:representation then!)))))]

    [when "if"]
    [while "while"]
    )

  (def: .public (for_in var array iteration!)
    (-> LVar Expression Statement Statement)
    (<| :abstraction
        ..block
        (format "for " (:representation var)
                " in " (:representation array)
                " do "
                (..nested (:representation iteration!)))))

  (type: .public Rescue
    (Record
     [#classes (List Text)
      #exception LVar
      #rescue Statement]))

  (def: .public (begin body! rescues)
    (-> Statement (List Rescue) Statement)
    (<| :abstraction
        ..block
        (format "begin" (..nested (:representation body!))
                (|> rescues
                    (list#each (.function (_ [classes exception rescue])
                                 (format text.new_line "rescue " (text.interposed ..input_separator classes)
                                         " => " (:representation exception)
                                         (..nested (:representation rescue)))))
                    (text.interposed text.new_line)))))

  (def: .public (catch expectation body!)
    (-> Expression Statement Statement)
    (<| :abstraction
        ..block
        (format "catch(" (:representation expectation) ") do"
                (..nested (:representation body!)))))

  (def: .public (return value)
    (-> Expression Statement)
    (:abstraction (format "return " (:representation value) ..statement_suffix)))

  (def: .public (raise message)
    (-> Expression Computation)
    (:abstraction (format "raise " (:representation message))))

  (template [<name> <keyword>]
    [(def: .public <name>
       Statement
       (|> <keyword>
           (text.suffix ..statement_suffix)
           :abstraction))]

    [next "next"]
    [redo "redo"]
    [break "break"]
    )

  (def: .public (function name args body!)
    (-> LVar (List LVar) Statement Statement)
    (<| :abstraction
        ..block
        (format "def " (:representation name)
                (|> args
                    (list#each (|>> :representation))
                    (text.interposed ..input_separator)
                    (text.enclosed ["(" ")"]))
                (..nested (:representation body!)))))

  (def: .public (lambda name args body!)
    (-> (Maybe LVar) (List Var) Statement Literal)
    (let [proc (|> (format (|> args
                               (list#each (|>> :representation))
                               (text.interposed ..input_separator)
                               (text.enclosed' "|"))
                           (..nested (:representation body!)))
                   (text.enclosed ["{" "}"])
                   (format "lambda "))]
      (|> (case name
            {.#None}
            proc
            
            {.#Some name}
            (format (:representation name) " = " proc))
          (text.enclosed ["(" ")"])
          :abstraction)))

  (template [<op> <name>]
    [(def: .public (<name> parameter subject)
       (-> Expression Expression Computation)
       (:abstraction (format "(" (:representation subject) " " <op> " " (:representation parameter) ")")))]

    ["==" =]
    [ "<" <]
    ["<=" <=]
    [ ">" >]
    [">=" >=]

    [ "+" +]
    [ "-" -]
    [ "*" *]
    [ "/" /]
    [ "%" %]
    ["**" pow]

    ["||" or]
    ["&&" and]
    [ "|" bit_or]
    [ "&" bit_and]
    [ "^" bit_xor]

    ["<<" bit_shl]
    [">>" bit_shr]
    )

  (template [<unary> <name>]
    [(def: .public (<name> subject)
       (-> Expression Computation)
       (:abstraction (format "(" <unary> (:representation subject) ")")))]

    ["!" not]
    ["-" opposite]
    )

  (def: .public (comment commentary on)
    (All (_ brand) (-> Text (Code brand) (Code brand)))
    (:abstraction (format "# "  (..safe commentary) text.new_line
                          (:representation on))))
  )

(def: .public (do method args object)
  (-> Text (List Expression) Expression Computation)
  (|> object (..the method) (..apply/* args)))

(def: .public (cond clauses else!)
  (-> (List [Expression Statement]) Statement Statement)
  (list#mix (.function (_ [test then!] next!)
              (..if test then! next!))
            else!
            (list.reversed clauses)))

(syntax: (arity_inputs [arity <code>.nat])
  (in (case arity
        0 (.list)
        _ (|> (-- arity)
              (enum.range n.enum 0)
              (list#each (|>> %.nat code.local_identifier))))))

(syntax: (arity_types [arity <code>.nat])
  (in (list.repeated arity (` ..Expression))))

(template [<arity> <function>+]
  [(with_expansions [<apply> (template.identifier ["apply/" <arity>])
                     <inputs> (arity_inputs <arity>)
                     <types> (arity_types <arity>)
                     <definitions> (template.spliced <function>+)]
     (def: .public (<apply> function <inputs>)
       (-> Expression <types> Computation)
       (..apply/* (.list <inputs>) function))

     (template [<function>]
       [(`` (def: .public (~~ (template.identifier [<function> "/" <arity>]))
              (<apply> (..local <function>))))]

       <definitions>))]

  [1
   [["print"]
    ["require"]]]

  [2
   [["print"]]]

  [3
   [["print"]]]
  )

(def: .public throw/1
  (-> Expression Statement)
  (|>> (..apply/1 (..local "throw"))
       ..statement))
