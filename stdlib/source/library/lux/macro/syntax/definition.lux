(.module:
  [library
   [lux {"-" [Definition]}
    [abstract
     [equivalence {"+" [Equivalence]}]
     [monad {"+" [do]}]]
    [control
     ["." exception {"+" [exception:]}]
     ["<>" parser
      ["<.>" code {"+" [Parser]}]]]
    [data
     ["." sum]
     ["." product]
     ["." bit]
     ["." name]
     ["." text
      ["%" format]]
     [collection
      ["." list]]]
    ["." macro
     ["." code]]
    ["." meta
     ["." location]]]]
  ["." //
   ["#." annotations {"+" [Annotations]}]
   ["#." check {"+" [Check]}]])

(type: .public Definition
  (Record
   [#name Text
    #value (Either Check
                   Code)
    #anns Annotations
    #export? Bit]))

(def: .public equivalence
  (Equivalence Definition)
  ($_ product.equivalence
      text.equivalence
      ($_ sum.equivalence
          //check.equivalence
          code.equivalence
          )
      //annotations.equivalence
      bit.equivalence
      ))

(def: extension
  "lux def")

(def: (tag_format [module short])
  (-> Name Code)
  (` [(~ (code.text module))
      (~ (code.text short))]))

(def: (annotations_format value)
  (-> Annotations Code)
  (case value
    #.End
    (` #.End)
    
    (#.Item [name value] tail)
    (` (#.Item [(~ (..tag_format name))
                (~ value)]
               (~ (annotations_format tail))))))

(def: dummy
  Code
  (` [#.module (~ (code.text (value@ #.module location.dummy)))
      #.line   (~ (code.nat (value@ #.line location.dummy)))
      #.column (~ (code.nat (value@ #.column location.dummy)))]))

(def: .public (format (^slots [#name #value #anns #export?]))
  (-> Definition Code)
  (` ((~ (code.text ..extension))
      (~ (code.local_identifier name))
      (~ (case value
           (#.Left check)
           (//check.format check)

           (#.Right value)
           value))
      [(~ ..dummy) (#.Record (~ (..annotations_format anns)))]
      (~ (code.bit export?)))))

(def: tag_parser
  (Parser Name)
  (<code>.tuple (<>.and <code>.text <code>.text)))

(def: annotations_parser
  (Parser Annotations)
  (<>.rec
   (function (_ recur)
     ($_ <>.or
         (<code>.tag! (name_of #.End))
         (<code>.form (do <>.monad
                        [_ (<code>.tag! (name_of #.Item))
                         [head tail] (<>.and (<code>.tuple (<>.and tag_parser <code>.any))
                                             recur)]
                        (in [head tail])))
         ))))

(def: .public (parser compiler)
  (-> Lux (Parser Definition))
  (do {! <>.monad}
    [raw <code>.any
     me_raw (|> raw
                macro.full_expansion
                (meta.result compiler)
                <>.lifted)]
    (<| (<code>.local me_raw)
        <code>.form
        (<>.after (<code>.text! ..extension))
        ($_ <>.and
            <code>.local_identifier
            (<>.or //check.parser
                   <code>.any)
            (<| <code>.tuple
                (<>.after <code>.any)
                <code>.form
                (<>.after (<code>.this! (` #.Record)))
                ..annotations_parser)
            <code>.bit
            ))))

(exception: .public (lacks_type {definition Definition})
  (exception.report
   ["Definition" (%.code (..format definition))]))

(def: .public (typed compiler)
  (-> Lux (Parser Definition))
  (do <>.monad
    [definition (..parser compiler)
     _ (case (value@ #value definition)
         (#.Left _)
         (in [])

         (#.Right _)
         (<>.lifted (exception.except ..lacks_type [definition])))]
    (in definition)))
