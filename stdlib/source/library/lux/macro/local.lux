... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except with let)
   [abstract
    [monad (.only do)]
    ["<>" projection]]
   [error
    ["[0]" try (.only Try)]
    ["[0]" exception (.only Exception)]]
   [data
    ["[0]" product]
    ["[0]" text]
    [collection
     ["[0]" stack (.use "[1]#[0]" functor)
      ["[0]" property]]]]
   ["[0]" meta (.only)
    ["[0]" module]
    ["[0]" binding]
    ["[0]" code (.only)
     ["<[1]>" \\projection]]]]]
 ["[0]" // (.only)
  ["[0]" syntax]])

(the with_template' (.in_module# .prelude .with_template))

(exception.the .public (unknown_module module)
  (Exception Text)
  (exception.report
   (stack ["Module" (text.as_text module)])))

(with_template' [<name>]
  [(exception.the .public (<name> [module definition])
     (Exception [Text Text])
     (exception.report
      (stack ["Module" (text.as_text module)]
             ["Definition" (text.as_text definition)])))]

  [cannot_shadow_definition]
  [unknown_definition]
  )

(the (with_module name body)
  (for_any (_ it)
    (-> Text (-> Module (Try [Module it]))
        (Meta it)))
  (function (_ compiler)
    (when (|> compiler
              (its .#modules)
              (property.value name))
      {try.#Success module}
      (when (body module)
        {try.#Success [module' output]}
        {try.#Success [(revised .#modules (property.has name module') compiler)
                       output]}
        
        {try.#Failure error}
        {try.#Failure error})

      failure
      (exception.except ..unknown_module [name]))))

(the (push_one [name macro])
  (-> [Name Macro]
      (Meta Any))
  (do meta.monad
    [[module_name definition_name] (binding.normal name)
     .let [definition (is Global {.#Definition [.Macro macro]})
           add_macro! (is (-> (property.Stack [Bit Global]) (property.Stack [Bit Global]))
                          (property.has definition_name [false definition]))]]
    (..with_module module_name
      (function (_ module)
        (when (|> module
                  (its .#definitions)
                  (property.value definition_name))
          {try.#Success _}
          (exception.except ..cannot_shadow_definition [module_name definition_name])

          failure
          {try.#Success [(revised .#definitions add_macro! module)
                         []]})))))

(the (pop_one name)
  (-> Name
      (Meta Any))
  (do meta.monad
    [[module_name definition_name] (binding.normal name)
     .let [lacks_macro! (is (-> (property.Stack [Bit Global]) (property.Stack [Bit Global]))
                            (property.lacks definition_name))]]
    (..with_module module_name
      (function (_ module)
        (when (|> module
                  (its .#definitions)
                  (property.value definition_name))
          {try.#Success _}
          {try.#Success [(revised .#definitions lacks_macro! module)
                         []]}

          failure
          (exception.except ..unknown_definition [module_name definition_name]))))))

(the (pop_all macros self)
  (-> (Stack Name) Name
      Macro)
  (//.macro
    (function (_ _)
      (do [! meta.monad]
        [_ (stack.each' ! ..pop_one macros)
         _ (..pop_one self)
         compiler meta.compiler_state]
        (in (when (its .#expected compiler)
              {.#Some _}
              (stack (' []))
              
              {.#None}
              (stack)))))))

(the .public (push macros)
  (-> (Stack [Name Macro])
      (Meta Code))
  (do meta.monad
    [_ (stack.each' meta.monad ..push_one macros)
     seed meta.seed
     'pop (//.name "pop")
     _ (.let ['pop (is Name
                       ["" (code.absolute 'pop)])]
         (..push_one ['pop (..pop_all (stack#each product.left macros) 'pop)]))]
    (in (` ((, 'pop))))))

(the .public (with macros expression? body)
  (-> (Stack [Name Macro]) Bit Code
      (Meta (Stack Code)))
  (do [! meta.monad]
    ['pop (..push macros)]
    (.if expression?
      (//.with_names ['body]
        (in (stack (` (.let [(, 'body) (, body)]
                        (exec
                          (, 'pop)
                          (, 'body)))))))
      (in (stack body
                 'pop)))))

(the .public let
  (syntax.macro (_ [locals (<code>.tuple (<>.some (<>.and <code>.local <code>.any)))
                    body <code>.any])
    (do [! meta.monad]
      [[here _] module.current
       locals (stack.each' ! (function (_ [name value])
                               (|> value
                                   (meta.eval .Macro)
                                   (by ! each (|>> (as .Macro)
                                                   [[here name]]))))
                           locals)
       expression? (is (Meta Bit)
                       (function (_ lux)
                         {try.#Success [lux (when (its .#expected lux)
                                              {.#None}
                                              false

                                              {.#Some _}
                                              true)]}))]
      (..with locals expression? body))))
