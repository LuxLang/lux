(.module:
  [library
   [lux #*
    ["." meta]
    [abstract
     ["." monad (#+ do)]]
    [control
     ["." try (#+ Try)]
     ["." exception (#+ exception:)]]
    [data
     ["." product]
     ["." text]
     [collection
      ["." list ("#\." functor)]
      [dictionary
       ["." plist (#+ PList)]]]]]]
  ["." //
   ["#." code]])

(exception: .public (unknown_module {module Text})
  (exception.report
   ["Module" (text.format module)]))

(template [<name>]
  [(exception: .public (<name> {module Text} {definition Text})
     (exception.report
      ["Module" (text.format module)]
      ["Definition" (text.format definition)]))]

  [cannot_shadow_definition]
  [unknown_definition]
  )

(def: (with_module name body)
  (All [a] (-> Text (-> Module (Try [Module a])) (Meta a)))
  (function (_ compiler)
    (case (|> compiler (value@ #.modules) (plist.value name))
      (#.Some module)
      (case (body module)
        (#try.Success [module' output])
        (#try.Success [(revised@ #.modules (plist.has name module') compiler)
                       output])
        
        (#try.Failure error)
        (#try.Failure error))

      #.None
      (exception.except ..unknown_module [name]))))

(def: (push_one [name macro])
  (-> [Name Macro] (Meta Any))
  (do meta.monad
    [[module_name definition_name] (meta.normal name)
     .let [definition (: Global (#.Definition [false .Macro (' {}) macro]))
           add_macro! (: (-> (PList Global) (PList Global))
                         (plist.has definition_name definition))]]
    (..with_module module_name
      (function (_ module)
        (case (|> module (value@ #.definitions) (plist.value definition_name))
          #.None
          (#try.Success [(revised@ #.definitions add_macro! module)
                         []])
          
          (#.Some _)
          (exception.except ..cannot_shadow_definition [module_name definition_name]))))))

(def: (pop_one name)
  (-> Name (Meta Any))
  (do meta.monad
    [[module_name definition_name] (meta.normal name)
     .let [lacks_macro! (: (-> (PList Global) (PList Global))
                           (plist.lacks definition_name))]]
    (..with_module module_name
      (function (_ module)
        (case (|> module (value@ #.definitions) (plist.value definition_name))
          (#.Some _)
          (#try.Success [(revised@ #.definitions lacks_macro! module)
                         []])

          #.None
          (exception.except ..unknown_definition [module_name definition_name]))))))

(def: (pop_all macros self)
  (-> (List Name) Name Macro)
  ("lux macro"
   (function (_ _)
     (do {! meta.monad}
       [_ (monad.each ! ..pop_one macros)
        _ (..pop_one self)
        compiler meta.compiler_state]
       (in (case (value@ #.expected compiler)
             (#.Some _)
             (list (' []))
             
             #.None
             (list)))))))

(def: .public (push macros)
  (-> (List [Name Macro]) (Meta Code))
  (do meta.monad
    [_ (monad.each meta.monad ..push_one macros)
     seed meta.seed
     g!pop (//.identifier "pop")
     _ (let [g!pop (: Name ["" (//code.format g!pop)])]
         (..push_one [g!pop (..pop_all (list\each product.left macros) g!pop)]))]
    (in (` ((~ g!pop))))))
