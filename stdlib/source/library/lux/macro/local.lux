(.using
 [library
  [lux "*"
   ["[0]" meta]
   [abstract
    ["[0]" monad {"+" do}]]
   [control
    ["[0]" try {"+" Try}]
    ["[0]" exception {"+" exception:}]]
   [data
    ["[0]" product]
    ["[0]" text]
    [collection
     ["[0]" list ("[1]#[0]" functor)]
     [dictionary
      ["[0]" plist {"+" PList}]]]]]]
 ["[0]" //
  ["[1][0]" code]])

(exception: .public (unknown_module [module Text])
  (exception.report
   ["Module" (text.format module)]))

(template [<name>]
  [(exception: .public (<name> [module Text
                                definition Text])
     (exception.report
      ["Module" (text.format module)]
      ["Definition" (text.format definition)]))]

  [cannot_shadow_definition]
  [unknown_definition]
  )

(def: (with_module name body)
  (All (_ a) (-> Text (-> Module (Try [Module a])) (Meta a)))
  (function (_ compiler)
    (case (|> compiler (the .#modules) (plist.value name))
      {.#Some module}
      (case (body module)
        {try.#Success [module' output]}
        {try.#Success [(revised .#modules (plist.has name module') compiler)
                       output]}
        
        {try.#Failure error}
        {try.#Failure error})

      {.#None}
      (exception.except ..unknown_module [name]))))

(def: (push_one [name macro])
  (-> [Symbol Macro] (Meta Any))
  (do meta.monad
    [[module_name definition_name] (meta.normal name)
     .let [definition (: Global {.#Definition [false .Macro macro]})
           add_macro! (: (-> (PList Global) (PList Global))
                         (plist.has definition_name definition))]]
    (..with_module module_name
      (function (_ module)
        (case (|> module (the .#definitions) (plist.value definition_name))
          {.#None}
          {try.#Success [(revised .#definitions add_macro! module)
                         []]}
          
          {.#Some _}
          (exception.except ..cannot_shadow_definition [module_name definition_name]))))))

(def: (pop_one name)
  (-> Symbol (Meta Any))
  (do meta.monad
    [[module_name definition_name] (meta.normal name)
     .let [lacks_macro! (: (-> (PList Global) (PList Global))
                           (plist.lacks definition_name))]]
    (..with_module module_name
      (function (_ module)
        (case (|> module (the .#definitions) (plist.value definition_name))
          {.#Some _}
          {try.#Success [(revised .#definitions lacks_macro! module)
                         []]}

          {.#None}
          (exception.except ..unknown_definition [module_name definition_name]))))))

(def: (pop_all macros self)
  (-> (List Symbol) Symbol Macro)
  ("lux macro"
   (function (_ _)
     (do [! meta.monad]
       [_ (monad.each ! ..pop_one macros)
        _ (..pop_one self)
        compiler meta.compiler_state]
       (in (case (the .#expected compiler)
             {.#Some _}
             (list (' []))
             
             {.#None}
             (list)))))))

(def: .public (push macros)
  (-> (List [Symbol Macro]) (Meta Code))
  (do meta.monad
    [_ (monad.each meta.monad ..push_one macros)
     seed meta.seed
     g!pop (//.symbol "pop")
     _ (let [g!pop (: Symbol
                      ["" (//code.format g!pop)])]
         (..push_one [g!pop (..pop_all (list#each product.left macros) g!pop)]))]
    (in (` ((~ g!pop))))))
