(.module:
  [library
   [lux #*
    ["." macro (#+ with_identifiers)]
    ["." meta]
    [abstract
     ["." monad (#+ do)]]
    [control
     ["." maybe]
     ["." try]
     ["<>" parser
      ["</>" code (#+ Parser)]]]
    [data
     ["." text ("#\." monoid)]
     [collection
      ["." list ("#\." functor)]]]
    [math
     [number
      ["." nat]
      ["." int]
      ["." rev]
      ["." frac]]]]]
  [//
   ["." code]])

(def: (self_documenting binding parser)
  (All [a] (-> Code (Parser a) (Parser a)))
  (function (_ tokens)
    (case (parser tokens)
      (#try.Success [tokens output])
      (#try.Success [tokens output])
      
      (#try.Failure error)
      (#try.Failure ($_ text\compose
                        "Failed to parse: " (code.format binding) text.new_line
                        error)))))

(def: (un_paired pairs)
  (All [a] (-> (List [a a]) (List a)))
  (case pairs
    #.End                   #.End
    (#.Item [[x y] pairs']) (list& x y (un_paired pairs'))))

(macro: .public (syntax: tokens)
  {#.doc (example "A more advanced way to define macros than 'macro:'."
                  "The inputs to the macro can be parsed in complex ways through the use of syntax parsers."
                  "The macro body is also (implicitly) run in the Meta monad, to save some typing."
                  "Also, the compiler state can be accessed through the *lux* binding."
                  (syntax: .public (object [.let [imports (class_imports *lux*)]
                                            .let [class_vars (list)]
                                            super (opt (super_class_decl^ imports class_vars))
                                            interfaces (tuple (some (super_class_decl^ imports class_vars)))
                                            constructor_args (constructor_args^ imports class_vars)
                                            methods (some (overriden_method_def^ imports))])
                    (let [def_code ($_ text\compose "anon-class:"
                                       (spaced (list (super_class_decl$ (maybe.else object_super_class super))
                                                     (with_brackets (spaced (list\map super_class_decl$ interfaces)))
                                                     (with_brackets (spaced (list\map constructor_arg$ constructor_args)))
                                                     (with_brackets (spaced (list\map (method_def$ id) methods))))))]
                      (in (list (` ((~ (code.text def_code)))))))))}
  (let [?parts (: (Maybe [Code Text (List Code) Code Code])
                  (case tokens
                    (^ (list export_policy
                             [_ (#.Form (list [_ (#.Identifier ["" name])] [_ (#.Tuple args)]))]
                             body))
                    (#.Some [export_policy name args (` {}) body])

                    (^ (list export_policy
                             [_ (#.Form (list [_ (#.Identifier ["" name])] [_ (#.Tuple args)]))]
                             meta_data
                             body))
                    (#.Some [export_policy name args meta_data body])

                    (^ (list [_ (#.Form (list [_ (#.Identifier ["" name])] [_ (#.Tuple args)]))]
                             body))
                    (#.Some [(` .private) name args (` {}) body])

                    (^ (list [_ (#.Form (list [_ (#.Identifier ["" name])] [_ (#.Tuple args)]))]
                             meta_data
                             body))
                    (#.Some [(` .private) name args meta_data body])

                    _
                    #.None))]
    (case ?parts
      (#.Some [export_policy name args meta body])
      (with_identifiers [g!tokens g!body g!error]
        (do {! meta.monad}
          [_ (if (|> args list.size nat.even?)
               (in [])
               (meta.failure "Syntax pattern expects pairs of bindings and code-parsers."))
           vars+parsers (monad.map !
                                   (: (-> [Code Code] (Meta [Code Code]))
                                      (function (_ [var parser])
                                        (with_expansions [<default> (in [var
                                                                         (` ((~! ..self_documenting) (' (~ var))
                                                                             (~ parser)))])]
                                          (case var
                                            [_ (#.Identifier ["" _])]
                                            <default>

                                            [_ (#.Identifier _)]
                                            (in [var parser])

                                            _
                                            <default>))))
                                   (list.pairs args))
           this_module meta.current_module_name
           .let [g!state (code.identifier ["" "*lux*"])
                 error_msg (code.text (macro.wrong_syntax_error [this_module name]))]]
          (in (list (` (macro: (~ export_policy) ((~ (code.identifier ["" name])) (~ g!tokens) (~ g!state))
                         (~ meta)
                         ({(#.Right (~ g!body))
                           ((~ g!body) (~ g!state))

                           (#.Left (~ g!error))
                           (#.Left ((~! text.join_with) (~! text.new_line) (list (~ error_msg) (~ g!error))))}
                          ((~! </>.result)
                           (: ((~! </>.Parser) (Meta (List Code)))
                              ((~! do) (~! <>.monad)
                               [(~+ (..un_paired vars+parsers))]
                               ((~' in) (~ body))))
                           (~ g!tokens)))))))))
      
      _
      (meta.failure (macro.wrong_syntax_error (name_of ..syntax:))))))
