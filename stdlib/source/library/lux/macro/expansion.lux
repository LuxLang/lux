... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except local name function let)
   [abstract
    [monad (.only do)]]
   [error (.only error)
    ["[0]" try]]
   [data
    ["[0]" text (.use "[1]#[0]" monoid)]
    [collection
     ["[0]" list (.use "[1]#[0]" monad)]]]
   ["[0]" meta (.only)
    ["[0]" code]
    ["[0]" provenance]
    ["[0]" name (.use "[1]#[0]" absolute)]
    ["[0]" binding]]]])

(the with_template (.in_module# .prelude .with_template))

(with_template [,name]
  [(the ,name (.in_module# .prelude ,name))]

  [Projection]
  [?#value]
  [?#or]
  [?#and]
  [?#rest]
  [?#any]
  [?#name]
  [?#local]
  [?#variant]
  [?#tuple]
  [?#form]
  )

(the .public (single syntax)
  (-> Code
      (Meta (List Code)))
  (when (|> (?#form (?#and ?#name ?#rest))
            (?#value (list syntax)))
    {.#Some [name args]}
    (do meta.monad
      [?macro (meta.try (binding.macro name))]
      (when ?macro
        {try.#Success macro}
        ((as (-> Macro Macro') macro) args)
        
        {try.#Failure _}
        (by meta.monad in (list syntax))))

    else
    (by meta.monad in (list syntax))))

(the .public (complete syntax)
  (-> Code
      (Meta (List Code)))
  (when (|> (?#form (?#and ?#name ?#rest))
            (?#value (list syntax)))
    {.#Some [name args]}
    (do meta.monad
      [?macro (meta.try (binding.macro name))]
      (when ?macro
        {try.#Success macro}
        (do [! meta.monad]
          [top_level_complete ((as (-> Macro Macro') macro) args)]
          (|> top_level_complete
              (list.each' meta.monad complete)
              (by ! each list#conjoint)))
        
        {try.#Failure _}
        (by meta.monad in (list syntax))))

    else
    (by meta.monad in (list syntax))))

(the .public (total syntax)
  (-> Code
      (Meta (List Code)))
  (`` (when (|> (all ?#or
                     (?#form (?#and ?#name ?#rest))
                     (?#variant ?#rest)
                     (?#tuple ?#rest)
                     (?#form ?#rest))
                (is (Projection (Or [Name (List Code)]
                                    (List Code)
                                    (List Code)
                                    (List Code))))
                (?#value (list syntax)))
        {.#Some {0 #0 [name args]}}
        (do meta.monad
          [?macro (meta.try (binding.macro name))]
          (when ?macro
            {try.#Success macro}
            (do [! meta.monad]
              [it ((as (-> Macro Macro') macro) args)]
              (|> it
                  (list.each' meta.monad total)
                  (by ! each list#conjoint)))
            
            {try.#Failure _}
            (do meta.monad
              [parts' (list.each' meta.monad total args)]
              (in (list (` ((, (code.name name)) (,* (list#conjoint parts')))))))))

        (,, (with_template [,lefts ,right? ,code]
              [{.#Some {,lefts ,right? it}}
               (do meta.monad
                 [it (list.each' meta.monad total it)]
                 (in (list (,code (list#conjoint it)))))]

              [1 #0 code.variant]
              [2 #0 code.tuple]
              [2 #1 code.form]
              ))

        else
        (by meta.monad in (list syntax)))))

(the .public cannot_expand_to_more_than_1
  (error "Macro expanded to more than 1 element."))

(the .public (one token)
  (-> Code
      (Meta Code))
  (do meta.monad
    [token+ (..complete token)]
    (when token+
      (list token')
      (in token')

      _
      (meta.failure ..cannot_expand_to_more_than_1))))

(with_template [<macro> <func>]
  [(the .public <macro>
     (.let [[module _] (.name .._)
            [_ proper] (.name <macro>)
            macro_name [module proper]]
       (macro (_ tokens)
         (when (is (Maybe [Bit Code])
                   (when tokens
                     (list {.#Text _ "omit"}
                           token)
                     {.#Some [true token]}

                     (list token)
                     {.#Some [false token]}

                     _
                     {.#None}))
           {.#Some [omit? token]}
           (do meta.monad
             [provenance meta.provenance
              output (<func> token)
              .let [_ (.log!# (text (name#as macro_name) " " (provenance.as_text provenance)
                                    (|> output
                                        (list#each (|>> code.absolute
                                                        (text text.\n text.\t)))
                                        text.together)
                                    text.\n))]]
             (in (if omit?
                     (list)
                     output)))

           {.#None}
           (meta.failure .wrong_syntax)))))]

  [log_single!   ..single]
  [log_complete! ..complete]
  [log_total!    ..total]
  )

(the .public let
  (<| (.in_module# .prelude)
      .expansion#let))
