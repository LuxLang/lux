(.module:
  {#.doc "Utilities commonly used while templating."}
  [library
   [lux (#- let local)
    ["." meta]
    [abstract
     ["." monad (#+ do)]]
    [control
     ["." try (#+ Try)]
     ["." exception (#+ exception:)]
     ["<>" parser ("#\." functor)
      ["<.>" code (#+ Parser)]]]
    [data
     ["." bit ("#\." codec)]
     ["." text]
     [collection
      ["." list ("#\." monad)]
      ["." dictionary (#+ Dictionary)]]]
    [math
     [number
      ["." nat ("#\." decimal)]
      ["." int ("#\." decimal)]
      ["." rev ("#\." decimal)]
      ["." frac ("#\." decimal)]]]]]
  ["." //
   [syntax (#+ syntax:)]
   ["." code]
   ["." local]])

(syntax: .public (spliced [parts (<code>.tuple (<>.some <code>.any))])
  (in parts))

(syntax: .public (amount [parts (<code>.tuple (<>.some <code>.any))])
  (in (list (code.nat (list.size parts)))))

(syntax: .public (with_locals [locals (<code>.tuple (<>.some <code>.local_identifier))
                               body <code>.any])
  {#.doc (example "Creates names for local bindings aliased by the names you choose."
                  (with_locals [my_var]
                    (let [my_var 123]
                      (..text [my_var])))
                  "=>"
                  "__gensym__my_var506")}
  (do {! meta.monad}
    [g!locals (|> locals
                  (list\map //.identifier)
                  (monad.all !))]
    (in (list (` (.with_expansions [(~+ (|> (list.zipped/2 locals g!locals)
                                            (list\map (function (_ [name identifier])
                                                        (list (code.local_identifier name) (as_is identifier))))
                                            list\join))]
                   (~ body)))))))

(def: (name_side module_side? parser)
  (-> Bit (Parser Name) (Parser Text))
  (do <>.monad
    [[module short] parser]
    (in (if module_side?
          (case module
            "" short
            _ module)
          short))))

(def: (snippet module_side?)
  (-> Bit (Parser Text))
  (.let [full_identifier (..name_side module_side? <code>.identifier)
         full_tag (..name_side module_side? <code>.tag)]
    ($_ <>.either
        <code>.text
        (if module_side?
          full_identifier
          (<>.either <code>.local_identifier
                     full_identifier))
        (if module_side?
          full_tag
          (<>.either <code>.local_tag
                     full_tag))
        (<>\map bit\encode <code>.bit)
        (<>\map nat\encode <code>.nat)
        (<>\map int\encode <code>.int)
        (<>\map rev\encode <code>.rev)
        (<>\map frac\encode <code>.frac)
        )))

(def: (part module_side?)
  (-> Bit (Parser (List Text)))
  (<code>.tuple (<>.many (..snippet module_side?))))

(syntax: .public (text [simple (..part false)])
  {#.doc (example "A text literal made by concatenating pieces of code."
                  (text [#0 123 +456 +789.0 "abc" .def ..ghi])
                  "=>"
                  "#0123+456+789.0abcdefghi")}
  (in (list (|> simple (text.interposed "") code.text))))

(template [<a/an> <name> <simple> <complex> <short_example> <full_example>]
  [(`` (syntax: .public (<name> [name (<>.or (<>.and (..part true) (..part false))
                                             (..part false))])
         {#.doc (example (~~ (..text [<a/an> " " <name> " made by concatenating pieces of code."]))
                         "The (optional) module part and the short part are specified independently."
                         (<name> ["abc" .def ..ghi])
                         "=>"
                         <short_example>
                         "--------------"
                         (<name> [.def] ["abc" .def ..ghi])
                         "=>"
                         <full_example>)}
         (case name
           (#.Left [simple complex])
           (in (list (<complex> [(text.interposed "" simple)
                                 (text.interposed "" complex)])))
           
           (#.Right simple)
           (in (list (|> simple (text.interposed "") <simple>))))))]

  ["An" identifier code.local_identifier code.identifier
   abcdefghi
   .abcdefghi]
  ["A" tag code.local_tag code.tag
   #abcdefghi
   #.abcdefghi]
  )

(type: Environment
  (Dictionary Text Code))

(def: (applied env template)
  (-> Environment Code Code)
  (case template
    [_ (#.Identifier "" name)]
    (case (dictionary.value name env)
      (#.Some substitute)
      substitute

      #.None
      template)

    (^template [<tag>]
      [[meta (<tag> elems)]
       [meta (<tag> (list\map (applied env) elems))]])
    ([#.Tuple]
     [#.Form])

    [meta (#.Record members)]
    [meta (#.Record (list\map (: (-> [Code Code] [Code Code])
                                 (function (_ [key value])
                                   [(applied env key)
                                    (applied env value)]))
                              members))]

    _
    template))

(type: Local
  {#name Text
   #parameters (List Text)
   #template (List Code)})

(exception: .public (irregular_arguments {expected Nat} {actual Nat})
  (exception.report
   ["Expected" (\ nat.decimal encode expected)]
   ["Actual" (\ nat.decimal encode actual)]))

(def: (macro (^slots [#parameters #template]))
  (-> Local Macro)
  ("lux macro"
   (function (_ inputs compiler)
     (.let [parameters_amount (list.size parameters)
            inputs_amount (list.size inputs)]
       (if (nat.= parameters_amount inputs_amount)
         (.let [environment (: Environment
                               (|> (list.zipped/2 parameters inputs)
                                   (dictionary.of_list text.hash)))]
           (#.Right [compiler (list\map (..applied environment) template)]))
         (exception.except ..irregular_arguments [parameters_amount inputs_amount]))))))

(def: local
  (Parser Local)
  (do <>.monad
    [[name parameters] (<code>.form (<>.and <code>.local_identifier
                                            (<>.many <code>.local_identifier)))
     template (<code>.tuple (<>.some <code>.any))]
    (in {#name name
         #parameters parameters
         #template template})))

(syntax: .public (let [locals (<code>.tuple (<>.some ..local))
                       body <code>.any])
  {#.doc (example "Lexically-bound templates."
                  (let [(!square <root>)
                        [(nat.* <root> <root>)]]
                    (def: (square root)
                      (-> Nat Nat)
                      (!square root))))}
  (do meta.monad
    [here_name meta.current_module_name
     expression? (: (Meta Bit)
                    (function (_ lux)
                      (#try.Success [lux (case (value@ #.expected lux)
                                           #.None
                                           false

                                           (#.Some _)
                                           true)])))
     g!pop (local.push (list\map (function (_ local)
                                   [[here_name (value@ #name local)]
                                    (..macro local)])
                                 locals))]
    (if expression?
      (//.with_identifiers [g!body]
        (in (list (` (.let [(~ g!body) (~ body)]
                       (exec (~ g!pop)
                         (~ g!body)))))))
      (in (list body
                g!pop)))))
