(.module:
  [library
   [lux #*
    [abstract
     [equivalence (#+ Equivalence)]
     [order (#+ Order)]
     [enum (#+ Enum)]
     [codec (#+ Codec)]
     [monad (#+ Monad do)]]
    [control
     [pipe (#+ case>)]
     ["." try (#+ Try)]
     ["." exception (#+ exception:)]
     ["<>" parser
      ["<.>" text (#+ Parser)]]]
    [data
     ["." text ("#\." monoid)]]
    [math
     [number
      ["n" nat ("#\." decimal)]]]
    [type
     abstract]]]
  [/
   ["." duration (#+ Duration)]])

(template [<name> <singular> <plural> <doc>]
  [(def: .public <name>
     {#.doc (example <doc>)}
     Nat
     (.nat (duration.ticks <singular> <plural>)))]

  [milli_seconds duration.milli_second duration.second
   "Number of milli-seconds in a second."]
  [seconds duration.second duration.minute
   "Number of seconds in a minute."]
  [minutes duration.minute duration.hour
   "Number of minutes in an hour."]
  [hours duration.hour duration.day
   "Number of hours in an day."]
  )

(def: limit
  Nat
  (.nat (duration.millis duration.day)))

(exception: .public (time_exceeds_a_day {time Nat})
  (exception.report
   ["Time (in milli-seconds)" (n\encode time)]
   ["Maximum (in milli-seconds)" (n\encode (-- limit))]))

(def: separator ":")

(def: section_parser
  (Parser Nat)
  (<>.codec n.decimal (<text>.exactly 2 <text>.decimal)))

(def: millis_parser
  (Parser Nat)
  (<>.either (|> (<text>.at_most 3 <text>.decimal)
                 (<>.codec n.decimal)
                 (<>.after (<text>.this ".")))
             (\ <>.monad in 0)))

(template [<maximum> <parser> <exception> <sub_parser>]
  [(exception: .public (<exception> {value Nat})
     (exception.report
      ["Value" (n\encode value)]
      ["Minimum" (n\encode 0)]
      ["Maximum" (n\encode (-- <maximum>))]))

   (def: <parser>
     (Parser Nat)
     (do <>.monad
       [value <sub_parser>]
       (if (n.< <maximum> value)
         (in value)
         (<>.lifted (exception.except <exception> [value])))))]

  [..hours hour_parser invalid_hour ..section_parser]
  [..minutes minute_parser invalid_minute ..section_parser]
  [..seconds second_parser invalid_second ..section_parser]
  )

(abstract: .public Time
  {#.doc "Time is defined as milliseconds since the start of the day (00:00:00.000)."}

  Nat

  (def: .public midnight
    {#.doc "The instant corresponding to the start of the day: 00:00:00.000"}
    Time
    (:abstraction 0))
  
  (def: .public (of_millis milli_seconds)
    (-> Nat (Try Time))
    (if (n.< ..limit milli_seconds)
      (#try.Success (:abstraction milli_seconds))
      (exception.except ..time_exceeds_a_day [milli_seconds])))

  (def: .public millis
    (-> Time Nat)
    (|>> :representation))

  (implementation: .public equivalence
    (Equivalence Time)

    (def: (= param subject)
      (n.= (:representation param) (:representation subject))))

  (implementation: .public order
    (Order Time)

    (def: &equivalence ..equivalence)

    (def: (< param subject)
      (n.< (:representation param) (:representation subject))))

  (`` (implementation: .public enum
        (Enum Time)

        (def: &order ..order)

        (def: succ
          (|>> :representation ++ (n.% ..limit) :abstraction))

        (def: pred
          (|>> :representation
               (case> 0 ..limit
                      millis millis)
               --
               :abstraction))))

  (def: .public parser
    (Parser Time)
    (let [millis (: (-> Duration Nat)
                    (|>> duration.millis .nat))
          hour (millis duration.hour)
          minute (millis duration.minute)
          second (millis duration.second)
          millis (millis duration.milli_second)]
      (do {! <>.monad}
        [utc_hour ..hour_parser
         _ (<text>.this ..separator)
         utc_minute ..minute_parser
         _ (<text>.this ..separator)
         utc_second ..second_parser
         utc_millis ..millis_parser]
        (in (:abstraction
             ($_ n.+
                 (n.* utc_hour hour)
                 (n.* utc_minute minute)
                 (n.* utc_second second)
                 (n.* utc_millis millis)))))))
  )

(def: (padded value)
  (-> Nat Text)
  (if (n.< 10 value)
    (text\compose "0" (n\encode value))
    (n\encode value)))

(def: (positive space duration)
  (-> Duration Duration Duration)
  (if (duration.negative? duration)
    (duration.merged space duration)
    duration))

(def: (millis_format millis)
  (-> Nat Text)
  (cond (n.= 0 millis)   ""
        (n.< 10 millis)  ($_ text\compose ".00" (n\encode millis))
        (n.< 100 millis) ($_ text\compose ".0" (n\encode millis))
        ... (n.< 1,000 millis)
        ($_ text\compose "." (n\encode millis))))

(type: .public Clock
  {#.doc (example "A clock marking the specific hour, minute, second, and milli-second in a day.")}
  {#hour Nat
   #minute Nat
   #second Nat
   #milli_second Nat})

(def: .public (clock time)
  (-> Time Clock)
  (let [time (|> time ..millis .int duration.of_millis)
        [hours time] [(duration.ticks duration.hour time) (duration.framed duration.hour time)]
        [minutes time] [(duration.ticks duration.minute time) (duration.framed duration.minute time)]
        [seconds millis] [(duration.ticks duration.second time) (duration.framed duration.second time)]]
    {#hour (.nat hours)
     #minute (.nat minutes)
     #second (.nat seconds)
     #milli_second (|> millis
                       (..positive duration.second)
                       duration.millis
                       .nat)}))

(def: .public (time clock)
  (-> Clock (Try Time))
  (|> ($_ duration.merged
          (duration.up (value@ #hour clock) duration.hour)
          (duration.up (value@ #minute clock) duration.minute)
          (duration.up (value@ #second clock) duration.second)
          (duration.of_millis (.int (value@ #milli_second clock))))
      duration.millis
      .nat
      ..of_millis))

(def: (format time)
  (-> Time Text)
  (let [(^slots [#hour #minute #second #milli_second]) (..clock time)]
    ($_ text\compose
        (..padded hour)
        ..separator (..padded minute)
        ..separator (..padded second)
        (..millis_format milli_second))))

(implementation: .public codec
  {#.doc (example "Based on ISO 8601."
                  "For example: 21:14:51.827")}
  (Codec Text Time)

  (def: encode ..format)
  (def: decode (<text>.result ..parser)))
