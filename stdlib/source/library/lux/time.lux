... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except text)
   [abstract
    [equivalence (.only Equivalence)]
    [enum (.only Enum)]
    [format (.only Format)]
    [monad (.only Monad do)]
    ["<>" projection (.only)]
    ["[0]" order (.only Order)]]
   [control
    ["[0]" pipe]
    ["[0]" try (.only Try)]
    ["[0]" exception (.only Exception)]]
   [data
    ["[0]" text (.use "[1]#[0]" monoid)
     ["<[1]>" \\projection (.only Projection)]]]
   [math
    ["[0]" random (.only Random)]
    [number
     ["n" natural (.use "[1]#[0]" base_10)]]]
   [macro
    ["[0]" template]]
   [type
    ["[0]" nominal]]]]
 [/
  ["[0]" duration (.only Duration)]])

(template.with [<name> <singular> <plural>]
  [(the .public <name>
     Natural
     (.natural (duration.ticks <singular> <plural>)))]

  [milli_seconds duration.milli_second duration.second]
  [seconds duration.second duration.minute]
  [minutes duration.minute duration.hour]
  [hours duration.hour duration.day]
  )

(the limit
  Natural
  (.natural (duration.millis duration.day)))

(exception.the .public (time_exceeds_a_day time)
  (Exception Natural)
  (exception.report
   (list ["Time (in milli-seconds)" (n#as time)]
         ["Maximum (in milli-seconds)" (n#as (-- limit))])))

... https://en.wikipedia.org/wiki/Delimiter
(the delimiter ":")

(the section_of
  (Projection Natural)
  (<>.of n.base_10 (<text>.exactly 2 <text>.decimal)))

(the millis_of
  (Projection Natural)
  (<>.either (|> (<text>.at_most 3 <text>.decimal)
                 (<>.of n.base_10)
                 (<>.after (<text>.this ".")))
             (by <>.monad in 0)))

(template.with [<maximum> <projection> <exception> <sub_of>]
  [(exception.the .public (<exception> value)
     (Exception Natural)
     (exception.report
      (list ["Value" (n#as value)]
            ["Minimum" (n#as 0)]
            ["Maximum" (n#as (-- <maximum>))])))

   (the <projection>
     (Projection Natural)
     (do <>.monad
       [value <sub_of>]
       (if (n.< <maximum> value)
         (in value)
         (<>.of_try (exception.except <exception> [value])))))]

  [..hours hour_of invalid_hour ..section_of]
  [..minutes minute_of invalid_minute ..section_of]
  [..seconds second_of invalid_second ..section_of]
  )

(nominal.every .public Time
  Natural

  (the .public midnight
    Time
    (nominal.abstraction 0))
  
  (the .public (of_millis milli_seconds)
    (-> Natural (Try Time))
    (if (n.< ..limit milli_seconds)
      {try.#Success (nominal.abstraction milli_seconds)}
      (exception.except ..time_exceeds_a_day [milli_seconds])))

  (the .public millis
    (-> Time Natural)
    (|>> nominal.representation))

  (the .public equivalence
    (Equivalence Time)
    (implementation
     (the (= param subject)
       (n.= (nominal.representation param)
            (nominal.representation subject)))))

  (alias [=]
         ..equivalence)

  (the .public order
    (Order Time)
    (implementation
     (the equivalence ..equivalence)

     (the (< param subject)
       (n.< (nominal.representation param)
            (nominal.representation subject)))))

  (order.for [] Time ..order)

  (`` (the .public enum
        (Enum Time)
        (implementation
         (the order ..order)

         (the succ
           (|>> nominal.representation
                ++
                (n.% ..limit)
                nominal.abstraction))

         (the pred
           (|>> nominal.representation
                (pipe.when
                  0 ..limit
                  millis millis)
                --
                nominal.abstraction)))))

  (the .public of_text
    (Projection Time)
    (let [millis (is (-> Duration Natural)
                     (|>> duration.millis .natural))
          hour (millis duration.hour)
          minute (millis duration.minute)
          second (millis duration.second)
          millis (millis duration.milli_second)]
      (do [! <>.monad]
        [utc_hour ..hour_of
         _ (<text>.this ..delimiter)
         utc_minute ..minute_of
         _ (<text>.this ..delimiter)
         utc_second ..second_of
         utc_millis ..millis_of]
        (in (nominal.abstraction
             (all n.+
                  (n.* utc_hour hour)
                  (n.* utc_minute minute)
                  (n.* utc_second second)
                  (n.* utc_millis millis)))))))
  )

(the (positive space duration)
  (-> Duration Duration Duration)
  (if (duration.negative? duration)
    (duration.composite space duration)
    duration))

(the (millis_text millis)
  (-> Natural Text)
  (if (n.= 0 millis)   ""
    (n.< 10 millis)  (all text#composite ".00" (n#as millis))
    (n.< 100 millis) (all text#composite ".0" (n#as millis))
    ... (n.< 1,000 millis)
    (all text#composite "." (n#as millis))))

(every .public Clock
  (Record
   [#hour Natural
    #minute Natural
    #second Natural
    #milli_second Natural]))

(the .public (clock time)
  (-> Time Clock)
  (let [time (|> time ..millis .integer duration.of_millis)
        [hours time] [(duration.ticks duration.hour time) (duration.framed duration.hour time)]
        [minutes time] [(duration.ticks duration.minute time) (duration.framed duration.minute time)]
        [seconds millis] [(duration.ticks duration.second time) (duration.framed duration.second time)]]
    [#hour (.natural hours)
     #minute (.natural minutes)
     #second (.natural seconds)
     #milli_second (|> millis
                       (..positive duration.second)
                       duration.millis
                       .natural)]))

(the .public (time clock)
  (-> Clock (Try Time))
  (|> (all duration.composite
           (duration.up (its #hour clock) duration.hour)
           (duration.up (its #minute clock) duration.minute)
           (duration.up (its #second clock) duration.second)
           (duration.of_millis (.integer (its #milli_second clock))))
      duration.millis
      .natural
      ..of_millis))

(the .public (as_text time)
  (text.Injection Time)
  (let [(open "_[0]") (..clock time)
        segment (by (n.padded 2 n.base_10) as)]
    (all text#composite
         (segment _#hour)
         ..delimiter (segment _#minute)
         ..delimiter (segment _#second)
         (..millis_text _#milli_second)
         )))

(the .public text
  (Format Text Time)
  (implementation
   (the as ..as_text)
   (the of (<text>.value ..of_text))))

(the .public random
  (Random Time)
  (random.try
   (do [! random.monad]
     [milli_seconds (by ! each (n.% ..limit) random.natural)]
     (in (..of_millis milli_seconds)))))
