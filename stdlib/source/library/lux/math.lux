... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except)
   [abstract
    ["[0]" monad (.only do)]]
   [control
    ["<>" projection]
    ["[0]" exception (.only Exception)]]
   [data
    [text
     ["%" \\injection]]
    [collection
     ["[0]" list (.use "[1]#[0]" mix)]]]
   [meta
    [extension (.only analysis)]
    ["[0]" location]
    ["[0]" code
     ["<[1]>" \\projection]]
    [macro
     ["[0]" template]
     ["[0]" expansion]]
    [type
     ["[0]" check]]
    [compiler
     [language
      [lux
       ["[0]" phase (.use "[1]#[0]" monad)]
       ["[0]" analysis (.only Operation Phase)
        ["[0]" type]]]]
     [meta
      [archive (.only Archive)]]]]]]
 [/
  ["[0]" random]
  [number
   ["[0]" nat]
   ["[0]" int]
   ["[0]" rev]
   ["[0]" dec]
   ["[0]" frac (.only Frac)]
   ["[0]" complex (.only Complex)]]])

(exception.the (no_arithmetic_for type)
  (Exception Type)
  (exception.report
   (list ["Type" (%.type type)])))

(the (composite phase archive <+> last prevs)
  (-> Phase Archive Code analysis.Term (List analysis.Term)
      (Operation analysis.Term))
  (when <+>
    [_ {.#Symbol [.prelude $]}]
    (phase#in (list#mix (function (_ left right)
                          [location.dummy {analysis.#Extension [.prelude $] (list left right)}])
                        last
                        prevs))
    
    _
    (do phase.monad
      [[_ $] (type.inferring
              (phase archive <+>))]
      (in (list#mix (function (_ left right)
                      (analysis.reified [$ (list left right)]))
                    last
                    prevs)))))

(expansion.let [<frac/0> [frac.#numerator 0 frac.#denominator 1]
                <frac/1> [frac.#numerator 1 frac.#denominator 1]
                <complex/0> [complex.#real +0.0 complex.#imaginary +0.0]
                <complex/1> [complex.#real +1.0 complex.#imaginary +0.0]]
  (these (template.with [<name> <scenarios>']
           [(expansion.let [<scenarios> (template.spliced <scenarios>')]
              (these (the .public <name>
                       .Analysis
                       (analysis (_ phase archive [operands (<>.some <code>.any)])
                         (<| type.with_var
                             (function (_ [$it :it:]))
                             (do [! phase.monad]
                               [operands (monad.each ! (|>> (phase archive) (type.expecting :it:))
                                                     operands)
                                _ (type.inference :it:)
                                :it: (type.check (check.identity (list) $it))]
                               (when (list.reversed operands)
                                 (list single)
                                 (in single)

                                 (list)
                                 (`` (cond (check.subsumed? .I64 :it:)
                                           (phase.except ..no_arithmetic_for [:it:])
                                           
                                           (,, (template.with [<type> <0> <+>]
                                                 [(check.subsumed? <type> :it:)
                                                  <0>]

                                                 <scenarios>))

                                           ... else
                                           (phase.except ..no_arithmetic_for [:it:])))
                                 
                                 (list.partial last prevs)
                                 (`` (cond (check.subsumed? .I64 :it:)
                                           (phase.except ..no_arithmetic_for [:it:])

                                           (,, (template.with [<type> <0> <+>]
                                                 [(check.subsumed? <type> :it:)
                                                  (..composite phase archive (` <+>) last prevs)]

                                                 <scenarios>))

                                           ... else
                                           (phase.except ..no_arithmetic_for [:it:]))))))))))]

           [+ [[.Nat (in (analysis.nat location.dummy 0)) .i64_+#|translation]
               [.Int (in (analysis.int location.dummy +0)) .i64_+#|translation]
               [.Rev (in (analysis.rev location.dummy .0)) .i64_+#|translation]
               [.Dec (in (analysis.dec location.dummy +0.0)) .f64_+#|translation]
               [Frac (type.expecting Frac (phase archive (` <frac/0>))) frac.+]
               [Complex (type.expecting Complex (phase archive (` <complex/0>))) complex.+]]]
           [- [[.Nat (in (analysis.nat location.dummy 0)) .i64_-#|translation]
               [.Int (in (analysis.int location.dummy -0)) .i64_-#|translation]
               [.Rev (in (analysis.rev location.dummy .0)) .i64_-#|translation]
               [.Dec (in (analysis.dec location.dummy -0.0)) .f64_-#|translation]
               [Frac (type.expecting Frac (phase archive (` <frac/0>))) frac.-]
               [Complex (type.expecting Complex (phase archive (` <complex/0>))) complex.-]]]
           [* [[.Nat (in (analysis.nat location.dummy 1)) nat.*]
               [.Int (in (analysis.int location.dummy +1)) .int_*#|translation]
               [.Rev (in (analysis.rev location.dummy rev./1)) rev.*]
               [.Dec (in (analysis.dec location.dummy +1.0)) .f64_*#|translation]
               [Frac (type.expecting Frac (phase archive (` <frac/1>))) frac.*]
               [Complex (type.expecting Complex (phase archive (` <complex/1>))) complex.*]]]
           [/ [[.Nat (in (analysis.nat location.dummy 1)) nat./]
               [.Int (in (analysis.int location.dummy +1)) .int_/#|translation]
               [.Rev (in (analysis.rev location.dummy rev./1)) rev./]
               [.Dec (in (analysis.dec location.dummy +1.0)) .f64_/#|translation]
               [Frac (type.expecting Frac (phase archive (` <frac/1>))) frac./]
               [Complex (type.expecting Complex (phase archive (` <complex/1>))) complex./]]]
           )
         (template.with [<name> <scenarios>']
           [(expansion.let [<scenarios> (template.spliced <scenarios>')]
              (these (the .public <name>
                       .Analysis
                       (analysis (_ phase archive [left <code>.any
                                                   right <code>.any])
                         (<| type.with_var
                             (function (_ [$it :it:]))
                             (do [! phase.monad]
                               [left (type.expecting :it: (phase archive left))
                                right (type.expecting :it: (phase archive right))
                                _ (type.inference .Bit)
                                :it: (type.check (check.identity (list) $it))]
                               (`` (cond (check.subsumed? .I64 :it:)
                                         (phase.except ..no_arithmetic_for [:it:])

                                         (,, (template.with [<type> <+>]
                                               [(check.subsumed? <type> :it:)
                                                (..composite phase archive (` <+>) right (list left))]

                                               <scenarios>))

                                         ... else
                                         (phase.except ..no_arithmetic_for [:it:])))))))))]

           [= [[.Nat .i64_=#|translation]
               [.Int .i64_=#|translation]
               [.Rev .i64_=#|translation]
               [.Dec .f64_=#|translation]
               [Frac frac.=]
               [Complex complex.=]]]
           [< [[.Nat nat.<]
               [.Int .int_<#|translation]
               [.Rev rev.<]
               [.Dec .f64_<#|translation]
               [Frac frac.<]]]
           [> [[.Nat nat.>]
               [.Int int.>]
               [.Rev rev.>]
               [.Dec dec.>]
               [Frac frac.>]]]
           [<= [[.Nat nat.<=]
                [.Int int.<=]
                [.Rev rev.<=]
                [.Dec dec.<=]
                [Frac frac.<=]]]
           [>= [[.Nat nat.>=]
                [.Int int.>=]
                [.Rev rev.>=]
                [.Dec dec.>=]
                [Frac frac.>=]]]
           )
         (template.with [<name> <scenarios>']
           [(expansion.let [<scenarios> (template.spliced <scenarios>')]
              (these (the .public <name>
                       .Analysis
                       (analysis (_ phase archive [left <code>.any
                                                   right <code>.any])
                         (<| type.with_var
                             (function (_ [$it :it:]))
                             (do [! phase.monad]
                               [left (type.expecting :it: (phase archive left))
                                right (type.expecting :it: (phase archive right))
                                _ (type.inference :it:)
                                :it: (type.check (check.identity (list) $it))]
                               (`` (cond (check.subsumed? .I64 :it:)
                                         (phase.except ..no_arithmetic_for [:it:])

                                         (,, (template.with [<type> <+>]
                                               [(check.subsumed? <type> :it:)
                                                (..composite phase archive (` <+>) right (list left))]

                                               <scenarios>))

                                         ... else
                                         (phase.except ..no_arithmetic_for [:it:])))))))))]

           [% [[.Nat nat.%]
               [.Int .int_%#|translation]
               [.Rev rev.%]
               [.Dec .f64_%#|translation]
               [Frac frac.%]
               [Complex complex.%]]]
           )
         ))
