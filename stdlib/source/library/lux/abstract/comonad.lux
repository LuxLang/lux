(.module:
  [library
   [lux "*"
    [data
     [collection
      ["[0]" list ("[1]#[0]" mix)]]]
    [math
     [number
      ["n" nat]]]
    [meta
     ["[0]" location]]]]
  [//
   [functor {"+" Functor}]])

(type: .public (CoMonad w)
  (Interface
   (: (Functor w)
      &functor)
   (: (All (_ a)
        (-> (w a) a))
      out)
   (: (All (_ a)
        (-> (w a) (w (w a))))
      disjoint)))

(macro: .public (be tokens state)
  (case (: (Maybe [(Maybe Text) Code (List Code) Code])
           (case tokens
             (^ (list [_ {.#Tuple (list [_ {.#Symbol ["" name]}] comonad)}] [_ {.#Tuple bindings}] body))
             {.#Some [{.#Some name} comonad bindings body]}
             
             (^ (list comonad [_ {.#Tuple bindings}] body))
             {.#Some [{.#None} comonad bindings body]}

             _
             {.#None}))
    {.#Some [?name comonad bindings body]}
    (if (|> bindings list.size (n.% 2) (n.= 0))
      (let [[module short] (symbol ..be)
            symbol (: (-> Text Code)
                      (|>> ($_ "lux text concat" module " " short " ") [""] {.#Symbol} [location.dummy]))
            g!_ (symbol "_")
            g!each (symbol "each")
            g!disjoint (symbol "disjoint")
            body' (list#mix (: (-> [Code Code] Code Code)
                               (function (_ binding body')
                                 (with_expansions [<default> (` (|> (~ value) (~ g!disjoint) ((~ g!each) (function ((~ g!_) (~ var)) (~ body')))))]
                                   (let [[var value] binding]
                                     (case var
                                       [_ {.#Symbol ["" _]}]
                                       <default>

                                       [_ {.#Symbol _}]
                                       (` ((~ var) (~ value) (~ body')))

                                       _
                                       <default>)))))
                            body
                            (list.reversed (list.pairs bindings)))]
        {.#Right [state (list (case ?name
                                {.#Some name}
                                (let [name [location.dummy {.#Symbol ["" name]}]]
                                  (` (.case (~ comonad)
                                       (~ name)
                                       (.case (~ name)
                                         [(~ g!each) (~' out) (~ g!disjoint)]
                                         (~ body')))))

                                {.#None}
                                (` (.case (~ comonad)
                                     [(~ g!each) (~' out) (~ g!disjoint)]
                                     (~ body')))))]})
      {.#Left "'be' bindings must have an even number of parts."})

    {.#None}
    {.#Left "Wrong syntax for 'be'"}))
