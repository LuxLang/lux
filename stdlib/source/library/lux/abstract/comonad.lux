(.module:
  [library
   [lux #*
    [data
     [collection
      ["." list ("#\." mix)]]]
    [math
     [number
      ["n" nat]]]
    [meta
     ["." location]]]]
  [//
   [functor (#+ Functor)]])

(type: .public (CoMonad w)
  (Interface
   (: (Functor w)
      &functor)
   (: (All (_ a)
        (-> (w a) a))
      out)
   (: (All (_ a)
        (-> (w a) (w (w a))))
      disjoint)))

(macro: .public (be tokens state)
  (case (: (Maybe [(Maybe Text) Code (List Code) Code])
           (case tokens
             (^ (list [_ (#.Record (list [[_ (#.Identifier ["" name])] comonad]))] [_ (#.Tuple bindings)] body))
             (#.Some [(#.Some name) comonad bindings body])
             
             (^ (list comonad [_ (#.Tuple bindings)] body))
             (#.Some [#.None comonad bindings body])

             _
             #.None))
    (#.Some [?name comonad bindings body])
    (if (|> bindings list.size (n.% 2) (n.= 0))
      (let [[module short] (name_of ..be)
            identifier (: (-> Text Code)
                          (|>> ($_ "lux text concat" module " " short " ") [""] #.Identifier [location.dummy]))
            g!_ (identifier "_")
            g!each (identifier "each")
            g!disjoint (identifier "disjoint")
            body' (list\mix (: (-> [Code Code] Code Code)
                               (function (_ binding body')
                                 (with_expansions [<default> (` (|> (~ value) (~ g!disjoint) ((~ g!each) (function ((~ g!_) (~ var)) (~ body')))))]
                                   (let [[var value] binding]
                                     (case var
                                       [_ (#.Identifier ["" _])]
                                       <default>

                                       [_ (#.Identifier _)]
                                       (` ((~ var) (~ value) (~ body')))

                                       _
                                       <default>)))))
                            body
                            (list.reversed (list.pairs bindings)))]
        (#.Right [state (list (case ?name
                                (#.Some name)
                                (let [name [location.dummy (#.Identifier ["" name])]]
                                  (` ({(~ name)
                                       ({[(~ g!each) (~' out) (~ g!disjoint)]
                                         (~ body')}
                                        (~ name))}
                                      (~ comonad))))

                                #.None
                                (` ({[(~ g!each) (~' out) (~ g!disjoint)]
                                     (~ body')}
                                    (~ comonad)))))]))
      (#.Left "'be' bindings must have an even number of parts."))

    #.None
    (#.Left "Wrong syntax for 'be'")))
