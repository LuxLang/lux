... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except all only)
   [meta
    ["[0]" provenance]]]]
 [//
  [functor (.only Functor)]])

(the (stack#mix f init xs)
  (for_any (_ part whole)
    (-> (-> part whole whole) whole (Stack part)
        whole)) 
  (when xs
    {.#Empty}
    init

    {.#Top x xs'}
    (stack#mix f (f x init) xs')))

(the (reversed xs)
  (for_any (_ it)
    (-> (Stack it)
        (Stack it)))
  (stack#mix (function (_ head tail) {.#Top head tail})
             {.#Empty}
             xs))

(the (pairs xs)
  (for_any (_ it)
    (-> (Stack it)
        (Stack [it it])))
  (when xs
    {.#Top x1 {.#Top x2 xs'}}
    {.#Top [x1 x2] (pairs xs')}

    _
    {.#Empty}))

(every .public (Monad !)
  (Interface
   (is (Functor !)
       functor)
   (is (for_any (_ it)
         (-> it
             (! it)))
       in)
   (is (for_any (_ it)
         (-> (! (! it))
             (! it)))
       conjoint)))

(the _do (.in_module# .prelude .do))
(the _generated_name (.in_module# .prelude .generated_name))
(the _meta#monad (.in_module# .prelude .meta#monad))
(the _failure (.in_module# .prelude .failure))
(the _expansion#let (.in_module# .prelude .expansion#let))
(the list#as_stack (.in_module# .prelude .list#as_stack))

(the .public do
  (macro (_ tokens)
    (when (is (Maybe [(Maybe Text) Code (List Code) Code])
              (when tokens
                (list {.#Tuple _ (list {.#Name _ ["" name]} monad)}
                      {.#Tuple _ bindings}
                      body)
                {.#Some [{.#Some name} monad bindings body]}
                
                (list monad
                      {.#Tuple _ bindings}
                      body)
                {.#Some [{.#None} monad bindings body]}

                _
                {.#None}))
      {.#Some [?name monad bindings body]}
      (if (|> bindings .list_size# .integer (.int_%# +2) (.i64_=# +0))
          (_do _meta#monad
               ['_ (_generated_name "'_")
                'each (_generated_name "'each")
                'conjoint (_generated_name "'conjoint")]
               (let [[module proper] (name ..do)
                     name (is (-> Text Code)
                              (|>> (.text_composite# module " " proper " ")
                                   [""]
                                   [provenance.dummy]
                                   {.#Name}))
                     body' (stack#mix (is (-> [Code Code] Code Code)
                                          (function (_ binding body')
                                            (<| (_expansion#let [<default> (` (|> (, value)
                                                                                  ((, 'each) (function ((, '_) (, var))
                                                                                               (, body')))
                                                                                  (, 'conjoint)))])
                                                (let [[var value] binding]
                                                  (when var
                                                    {.#Name _ ["" _]}
                                                    <default>

                                                    {.#Name _ _}
                                                    (` ((, var) (, value) (, body')))

                                                    _
                                                    <default>)))))
                                      body
                                      (reversed (pairs (list#as_stack bindings))))]
                 (in (list (when ?name
                             {.#Some name}
                             (let [name {.#Name provenance.dummy ["" name]}]
                               (` (.when (, monad)
                                    (, name)
                                    (.when (, name)
                                      [(, 'each) (,' in) (, 'conjoint)]
                                      (, body')))))
                             
                             {.#None}
                             (` (.when (, monad)
                                  [(, 'each) (,' in) (, 'conjoint)]
                                  (, body'))))))))
          (_failure .bindings_must_be_pairs))

      {.#None}
      (_failure .wrong_syntax))))

(the .public (then monad f)
  (for_any (_ ! before after)
    (-> (Monad !) (-> before (! after))
        (-> (! before) (! after))))
  (|>> (by monad each f)
       (by monad conjoint)))

(the .public deferred
  (macro (_ tokens)
    (when tokens
      (list {.#Tuple _ (list ! after)}
            before)
      (_do _meta#monad
           ['_ (_generated_name "'_")
            'it (_generated_name "'it")]
           (in (list (` (..do (, !)
                          [(, 'it) (, before)
                           (, '_) (, after)]
                          ((,' in) (, 'it)))))))

      _
      (_failure .wrong_syntax))))
