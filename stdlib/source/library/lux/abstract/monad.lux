(.module:
  [library
   [lux "*"
    [meta
     ["." location]]]]
  [//
   [functor {"+" [Functor]}]])

(def: (list\mix f init xs)
  (All (_ a b)
    (-> (-> b a a) a (List b) a)) 
  (case xs
    #.End
    init

    (#.Item x xs')
    (list\mix f (f x init) xs')))

(def: (list\size xs)
  (All (_ a) (-> (List a) Nat))
  (loop [counter 0
         xs xs]
    (case xs
      #.End
      counter

      (#.Item _ xs')
      (recur (++ counter) xs'))))

(def: (reversed xs)
  (All (_ a)
    (-> (List a) (List a)))
  (list\mix (function (_ head tail) (#.Item head tail))
            #.End
            xs))

(def: (pairs xs)
  (All (_ a) (-> (List a) (List [a a])))
  (case xs
    (#.Item x1 (#.Item x2 xs'))
    (#.Item [x1 x2] (pairs xs'))

    _
    #.End))

(type: .public (Monad m)
  (Interface
   (: (Functor m)
      &functor)
   (: (All (_ a)
        (-> a (m a)))
      in)
   (: (All (_ a)
        (-> (m (m a)) (m a)))
      conjoint)))

(macro: .public (do tokens state)
  (case (: (Maybe [(Maybe Text) Code (List Code) Code])
           (case tokens
             (^ (list [_ (#.Record (list [[_ (#.Identifier ["" name])] monad]))] [_ (#.Tuple bindings)] body))
             (#.Some [(#.Some name) monad bindings body])
             
             (^ (list monad [_ (#.Tuple bindings)] body))
             (#.Some [#.None monad bindings body])

             _
             #.None))
    (#.Some [?name monad bindings body])
    (if (|> bindings list\size .int ("lux i64 %" +2) ("lux i64 =" +0))
      (let [[module short] (name_of ..do)
            identifier (: (-> Text Code)
                          (|>> ($_ "lux text concat" module " " short " ") [""] #.Identifier [location.dummy]))
            g!_ (identifier "_")
            g!each (identifier "each")
            g!conjoint (identifier "conjoint")
            body' (list\mix (: (-> [Code Code] Code Code)
                               (function (_ binding body')
                                 (with_expansions [<default> (` (|> (~ value) ((~ g!each) (function ((~ g!_) (~ var)) (~ body'))) (~ g!conjoint)))]
                                   (let [[var value] binding]
                                     (case var
                                       [_ (#.Identifier ["" _])]
                                       <default>

                                       [_ (#.Identifier _)]
                                       (` ((~ var) (~ value) (~ body')))

                                       _
                                       <default>)))))
                            body
                            (reversed (pairs bindings)))]
        (#.Right [state (list (case ?name
                                (#.Some name)
                                (let [name [location.dummy (#.Identifier ["" name])]]
                                  (` ({(~ name)
                                       ({[(~ g!each) (~' in) (~ g!conjoint)]
                                         (~ body')}
                                        (~ name))}
                                      (~ monad))))
                                
                                #.None
                                (` ({[(~ g!each) (~' in) (~ g!conjoint)]
                                     (~ body')}
                                    (~ monad)))))]))
      (#.Left "'do' bindings must have an even number of parts."))

    #.None
    (#.Left "Wrong syntax for 'do'")))

(def: .public (then monad f)
  (All (_ ! a b)
    (-> (Monad !) (-> a (! b))
        (-> (! a) (! b))))
  (|>> (\ monad each f)
       (\ monad conjoint)))

(def: .public (all monad)
  (All (_ ! a)
    (-> (Monad !) (List (! a))
        (! (List a))))
  (let [(^open "!\.") monad]
    (function (recur xs)
      (case xs
        #.End
        (!\in #.End)
        
        (#.Item x xs')
        (|> x
            (!\each (function (_ _x)
                      (!\each (|>> (#.Item _x)) (recur xs'))))
            !\conjoint)))))

(def: .public (each monad f)
  (All (_ M a b)
    (-> (Monad M) (-> a (M b)) (List a)
        (M (List b))))
  (let [(^open "!\.") monad]
    (function (recur xs)
      (case xs
        #.End
        (!\in #.End)
        
        (#.Item x xs')
        (|> (f x)
            (!\each (function (_ _x)
                      (!\each (|>> (#.Item _x)) (recur xs'))))
            !\conjoint)))))

(def: .public (only monad f)
  (All (_ ! a b)
    (-> (Monad !) (-> a (! Bit)) (List a)
        (! (List a))))
  (let [(^open "!\.") monad]
    (function (recur xs)
      (case xs
        #.End
        (!\in #.End)
        
        (#.Item head xs')
        (|> (f head)
            (!\each (function (_ verdict)
                      (!\each (function (_ tail)
                                (if verdict
                                  (#.Item head tail)
                                  tail))
                              (recur xs'))))
            !\conjoint)))))

(def: .public (mix monad f init xs)
  (All (_ M a b)
    (-> (Monad M) (-> b a (M a)) a (List b)
        (M a)))
  (case xs
    #.End
    (\ monad in init)

    (#.Item x xs')
    (do monad
      [init' (f x init)]
      (mix monad f init' xs'))))
