... https://en.wikipedia.org/wiki/Interval_(mathematics)
(.using
  [library
   [lux "*"]]
  [//
   [equivalence {"+" Equivalence}]
   ["[0]" order]
   [enum {"+" Enum}]])

(type: .public (Interval a)
  (Interface
   (: (Enum a)
      &enum)

   (: a
      bottom)

   (: a
      top)))

(def: .public (between enum bottom top)
  (All (_ a) (-> (Enum a) a a (Interval a)))
  (implementation
   (def: &enum enum)
   (def: bottom bottom)
   (def: top top)))

(def: .public (singleton enum elem)
  (All (_ a) (-> (Enum a) a (Interval a)))
  (implementation
   (def: &enum enum)
   (def: bottom elem)
   (def: top elem)))

(template [<name> <comp>]
  [(def: .public (<name> interval)
     (All (_ a) (-> (Interval a) Bit))
     (let [(^open ",#[0]") interval]
       (<comp> ,#bottom ,#top)))]

  [inner?     (order.> ,#&order)]
  [outer?     ,#<]
  [singleton? ,#=]
  )

(def: .public (within? interval elem)
  (All (_ a) (-> (Interval a) a Bit))
  (let [(^open ",#[0]") interval]
    (cond (inner? interval)
          (and (order.>= ,#&order ,#bottom elem)
               (order.<= ,#&order ,#top elem))
          
          (outer? interval)
          (or (order.>= ,#&order ,#bottom elem)
              (order.<= ,#&order ,#top elem))
          
          ... singleton
          (and (,#= ,#bottom elem)
               (,#= ,#top elem)))))

(template [<name> <limit>]
  [(def: .public (<name> elem interval)
     (All (_ a) (-> a (Interval a) Bit))
     (let [(^open "[0]") interval]
       (= <limit> elem)))]

  [starts_with? bottom]
  [ends_with?   top]
  )

(def: .public (borders? interval elem)
  (All (_ a) (-> (Interval a) a Bit))
  (or (starts_with? elem interval)
      (ends_with? elem interval)))

(implementation: .public (union left right)
  (All (_ a) (-> (Interval a) (Interval a) (Interval a)))

  (def: &enum (value@ &enum right))
  (def: bottom (order.min (# right &order) (# left bottom) (# right bottom)))
  (def: top (order.max (# right &order) (# left top) (# right top))))

(implementation: .public (intersection left right)
  (All (_ a) (-> (Interval a) (Interval a) (Interval a)))

  (def: &enum (value@ &enum right))
  (def: bottom (order.max (# right &order) (# left bottom) (# right bottom)))
  (def: top (order.min (# right &order) (# left top) (# right top))))

(implementation: .public (complement interval)
  (All (_ a) (-> (Interval a) (Interval a)))

  (def: &enum (value@ &enum interval))
  (def: bottom (# interval succ (# interval top)))
  (def: top (# interval pred (# interval bottom))))

(def: .public (precedes? reference sample)
  (All (_ a) (-> (Interval a) (Interval a) Bit))
  (let [(^open "[0]") reference
        limit (# reference bottom)]
    (and (< limit (# sample bottom))
         (< limit (# sample top)))))

(def: .public (succeeds? reference sample)
  (All (_ a) (-> (Interval a) (Interval a) Bit))
  (precedes? sample reference))

(template [<name> <comp>]
  [(def: .public (<name> reference sample)
     (All (_ a) (-> a (Interval a) Bit))
     (let [(^open ",#[0]") sample]
       (and (<comp> reference ,#bottom)
            (<comp> reference ,#top))))]

  [before? ,#<]
  [after?  (order.> ,#&order)]
  )

(def: .public (meets? reference sample)
  (All (_ a) (-> (Interval a) (Interval a) Bit))
  (let [(^open ",#[0]") reference
        limit (# reference bottom)]
    (and (,#= limit (# sample top))
         (order.<= ,#&order limit (# sample bottom)))))

(def: .public (touches? reference sample)
  (All (_ a) (-> (Interval a) (Interval a) Bit))
  (or (meets? reference sample)
      (meets? sample reference)))

(template [<name> <eq_side> <ineq> <ineq_side>]
  [(def: .public (<name> reference sample)
     (All (_ a) (-> (Interval a) (Interval a) Bit))
     (let [(^open ",#[0]") reference]
       (and (,#= (# reference <eq_side>)
                 (# sample <eq_side>))
            (<ineq> ,#&order
                    (# reference <ineq_side>)
                    (# sample <ineq_side>)))))]

  [starts?   ,#bottom order.<= ,#top]
  [finishes? ,#top    order.>= ,#bottom]
  )

(implementation: .public equivalence
  (All (_ a) (Equivalence (Interval a)))
  
  (def: (= reference sample)
    (let [(^open ",#[0]") reference]
      (and (,#= ,#bottom (# sample bottom))
           (,#= ,#top (# sample top))))))

(def: .public (nested? reference sample)
  (All (_ a) (-> (Interval a) (Interval a) Bit))
  (cond (or (singleton? sample)
            (and (inner? reference) (inner? sample))
            (and (outer? reference) (outer? sample)))
        (let [(^open ",#[0]") reference]
          (and (order.>= ,#&order (# reference bottom) (# sample bottom))
               (order.<= ,#&order (# reference top) (# sample top))))

        (or (singleton? reference)
            (and (inner? reference) (outer? sample)))
        #0

        ... (and (outer? reference) (inner? sample))
        (let [(^open ",#[0]") reference]
          (or (and (order.>= ,#&order (# reference bottom) (# sample bottom))
                   (order.> ,#&order (# reference bottom) (# sample top)))
              (and (,#< (# reference top) (# sample bottom))
                   (order.<= ,#&order (# reference top) (# sample top)))))
        ))

(def: .public (overlaps? reference sample)
  (All (_ a) (-> (Interval a) (Interval a) Bit))
  (let [(^open ",#[0]") reference]
    (and (not (# ..equivalence = reference sample))
         (cond (singleton? sample)
               #0

               (singleton? reference)
               (nested? sample reference)

               (or (and (inner? sample) (outer? reference))
                   (and (outer? sample) (inner? reference)))
               (or (order.>= ,#&order (# reference bottom) (# sample top))
                   (order.<= ,#&order (# reference top) (# sample bottom)))

               ... both inner
               (inner? sample)
               (inner? (intersection reference sample))

               ... both outer
               (not (nested? reference sample))
               ))))
