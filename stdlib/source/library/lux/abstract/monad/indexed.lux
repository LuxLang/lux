(.module:
  [library
   [lux #*
    [control
     [monad]
     ["<>" parser
      ["<.>" code (#+ Parser)]]]
    [data
     [collection
      ["." list ("#\." functor fold)]]]
    ["." macro
     [syntax (#+ syntax:)]
     ["." code]]]])

(interface: #export (IxMonad m)
  (: (All [p a]
       (-> a (m p p a)))
     in)

  (: (All [ii it io vi vo]
       (-> (-> vi (m it io vo))
           (m ii it vi)
           (m ii io vo)))
     bind))

(type: Binding
  [Code Code])

(def: binding
  (Parser Binding)
  (<>.and <code>.any <code>.any))

(type: Context
  (#Let (List Binding))
  (#Bind Binding))

(def: context
  (Parser Context)
  (<>.or (<>.after (<code>.this! (' #let))
                   (<code>.tuple (<>.some binding)))
         binding))

(def: (pair_list [binding value])
  (All [a] (-> [a a] (List a)))
  (list binding value))

(def: named_monad
  (Parser [(Maybe Text) Code])
  (<>.either (<code>.record (<>.and (\ <>.monad map (|>> #.Some)
                                       <code>.local_identifier)
                                    <code>.any))
             (\ <>.monad map (|>> [#.None])
                <code>.any)))

(syntax: #export (do {[?name monad] ..named_monad}
                   {context (<code>.tuple (<>.some context))}
                   expression)
  (macro.with_gensyms [g!_ g!bind]
    (let [body (list\fold (function (_ context next)
                            (case context
                              (#Let bindings)
                              (` (let [(~+ (|> bindings
                                               (list\map pair_list)
                                               list.concat))]
                                   (~ next)))
                              
                              (#Bind [binding value])
                              (` ((~ g!bind)
                                  (.function ((~ g!_) (~ binding))
                                    (~ next))
                                  (~ value)))))
                          expression
                          (list.reversed context))]
      (in (list (case ?name
                  (#.Some name)
                  (let [name (code.local_identifier name)]
                    (` (let [(~ name) (~ monad)
                             {#..in (~' in)
                              #..bind (~ g!bind)} (~ name)]
                         (~ body))))

                  #.None
                  (` (let [{#..in (~' in)
                            #..bind (~ g!bind)} (~ monad)]
                       (~ body)))))))))
