(.module:
  [library
   [lux #*
    [control
     ["<>" parser
      ["<.>" code (#+ Parser)]]]
    [data
     [collection
      ["." list ("#\." functor fold)]]]
    ["." macro
     [syntax (#+ syntax:)]
     ["." code]]]]
  ["." //])

(interface: #export (IxMonad m)
  (: (All [p a]
       (-> a (m p p a)))
     in)

  (: (All [ii it io vi vo]
       (-> (-> vi (m it io vo))
           (m ii it vi)
           (m ii io vo)))
     bind))

(type: Binding
  [Code Code])

(def: binding
  (Parser Binding)
  (<>.and <code>.any <code>.any))

(type: Context
  (#Macro Name Code)
  (#Bind Binding))

(def: global_identifier
  (Parser Name)
  (//.do <>.monad
    [[module short] <code>.identifier
     _ (<>.assertion "" (case module "" false _ true))]
    (in [module short])))

(def: context
  (Parser Context)
  (<>.or (<>.and ..global_identifier
                 <code>.any)
         binding))

(def: (pair_list [binding value])
  (All [a] (-> [a a] (List a)))
  (list binding value))

(def: named_monad
  (Parser [(Maybe Text) Code])
  (<>.either (<code>.record (<>.and (\ <>.monad map (|>> #.Some)
                                       <code>.local_identifier)
                                    <code>.any))
             (\ <>.monad map (|>> [#.None])
                <code>.any)))

(syntax: #export (do {[?name monad] ..named_monad}
                   {context (<code>.tuple (<>.some context))}
                   expression)
  (macro.with_gensyms [g!_ g!bind]
    (let [body (list\fold (function (_ context next)
                            (case context
                              (#Macro macro parameter)
                              (` ((~ (code.identifier macro))
                                  (~ parameter)
                                  (~ next)))
                              
                              (#Bind [binding value])
                              (` ((~ g!bind)
                                  (.function ((~ g!_) (~ binding))
                                    (~ next))
                                  (~ value)))))
                          expression
                          (list.reversed context))]
      (in (list (case ?name
                  (#.Some name)
                  (let [name (code.local_identifier name)]
                    (` (let [(~ name) (~ monad)
                             {#..in (~' in)
                              #..bind (~ g!bind)} (~ name)]
                         (~ body))))

                  #.None
                  (` (let [{#..in (~' in)
                            #..bind (~ g!bind)} (~ monad)]
                       (~ body)))))))))
