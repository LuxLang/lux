(.module:
  [library
   [lux "*"
    [control
     ["<>" parser
      ["<[0]>" code {"+" [Parser]}]]]
    [data
     [collection
      ["[0]" list ("[1]\[0]" functor mix)]]]
    ["[0]" macro
     [syntax {"+" [syntax:]}]
     ["[0]" code]]]]
  ["[0]" //])

(type: .public (IxMonad m)
  (Interface
   (: (All (_ p a)
        (-> a (m p p a)))
      in)

   (: (All (_ ii it io vi vo)
        (-> (-> vi (m it io vo))
            (m ii it vi)
            (m ii io vo)))
      then)))

(type: Binding
  [Code Code])

(def: binding
  (Parser Binding)
  (<>.and <code>.any <code>.any))

(type: Context
  (Variant
   {#Macro Name Code}
   {#Binding Binding}))

(def: global_identifier
  (Parser Name)
  (//.do <>.monad
    [[module short] <code>.identifier
     _ (<>.assertion "" (case module "" false _ true))]
    (in [module short])))

(def: context
  (Parser Context)
  (<>.or (<>.and ..global_identifier
                 <code>.any)
         binding))

(def: (pair_list [binding value])
  (All (_ a) (-> [a a] (List a)))
  (list binding value))

(def: named_monad
  (Parser [(Maybe Text) Code])
  (<>.either (<code>.tuple (<>.and (\ <>.monad each (|>> {.#Some})
                                      <code>.local_identifier)
                                   <code>.any))
             (\ <>.monad each (|>> [{.#None}])
                <code>.any)))

(syntax: .public (do [[?name monad] ..named_monad
                      context (<code>.tuple (<>.some context))
                      expression <code>.any])
  (macro.with_identifiers [g!_ g!then]
    (let [body (list\mix (function (_ context next)
                           (case context
                             {#Macro macro parameter}
                             (` ((~ (code.identifier macro))
                                 (~ parameter)
                                 (~ next)))
                             
                             {#Binding [binding value]}
                             (` ((~ g!then)
                                 (.function ((~ g!_) (~ binding))
                                   (~ next))
                                 (~ value)))))
                         expression
                         (list.reversed context))]
      (in (list (case ?name
                  {.#Some name}
                  (let [name (code.local_identifier name)]
                    (` (let [(~ name) (~ monad)
                             [..in (~' in)
                              ..then (~ g!then)] (~ name)]
                         (~ body))))

                  {.#None}
                  (` (let [[..in (~' in)
                            ..then (~ g!then)] (~ monad)]
                       (~ body)))))))))
