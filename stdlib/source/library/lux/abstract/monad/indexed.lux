(.module:
  [library
   [lux #*
    [control
     ["<>" parser
      ["<.>" code (#+ Parser)]]]
    [data
     [collection
      ["." list ("#\." functor mix)]]]
    ["." macro
     [syntax (#+ syntax:)]
     ["." code]]]]
  ["." //])

(interface: .public (IxMonad m)
  (: (All [p a]
       (-> a (m p p a)))
     in)

  (: (All [ii it io vi vo]
       (-> (-> vi (m it io vo))
           (m ii it vi)
           (m ii io vo)))
     then))

(type: Binding
  [Code Code])

(def: binding
  (Parser Binding)
  (<>.and <code>.any <code>.any))

(type: Context
  (Variant
   (#Macro Name Code)
   (#Binding Binding)))

(def: global_identifier
  (Parser Name)
  (//.do <>.monad
    [[module short] <code>.identifier
     _ (<>.assertion "" (case module "" false _ true))]
    (in [module short])))

(def: context
  (Parser Context)
  (<>.or (<>.and ..global_identifier
                 <code>.any)
         binding))

(def: (pair_list [binding value])
  (All [a] (-> [a a] (List a)))
  (list binding value))

(def: named_monad
  (Parser [(Maybe Text) Code])
  (<>.either (<code>.record (<>.and (\ <>.monad each (|>> #.Some)
                                       <code>.local_identifier)
                                    <code>.any))
             (\ <>.monad each (|>> [#.None])
                <code>.any)))

(syntax: .public (do [[?name monad] ..named_monad
                      context (<code>.tuple (<>.some context))
                      expression <code>.any])
  (macro.with_identifiers [g!_ g!then]
    (let [body (list\mix (function (_ context next)
                           (case context
                             (#Macro macro parameter)
                             (` ((~ (code.identifier macro))
                                 (~ parameter)
                                 (~ next)))
                             
                             (#Binding [binding value])
                             (` ((~ g!then)
                                 (.function ((~ g!_) (~ binding))
                                   (~ next))
                                 (~ value)))))
                         expression
                         (list.reversed context))]
      (in (list (case ?name
                  (#.Some name)
                  (let [name (code.local_identifier name)]
                    (` (let [(~ name) (~ monad)
                             {#..in (~' in)
                              #..then (~ g!then)} (~ name)]
                         (~ body))))

                  #.None
                  (` (let [{#..in (~' in)
                            #..then (~ g!then)} (~ monad)]
                       (~ body)))))))))
