(.using
 [library
  [lux "*"
   ["@" target]]]
 [//
  [monad (.only Monad do)]
  ["[0]" functor (.only Functor)]])

(type: .public (Apply f)
  (Interface
   (is (Functor f)
       functor)
   (is (All (_ a b)
         (-> (f a) (f (-> a b)) (f b)))
       on)))

(implementation: .public (composite f_monad f_apply g_apply)
  (All (_ F G)
    (-> (Monad F) (Apply F) (Apply G)
        ... TODO: Replace (All (_ a) (F (G a))) with (functor.Then F G)
        (Apply (All (_ a) (F (G a))))))
  
  (def: functor
    (functor.composite (the functor f_apply)
                       (the functor g_apply)))
  
  (def: (on fgx fgf)
    ... TODO: Switch from this version to the one below (in comments) ASAP.
    (for @.old (let [fgf' (# f_apply on
                             fgf
                             (# f_monad in (function (_ gf gx) (# g_apply on gx gf))))]
                 (as_expected (# f_apply on (as_expected fgx) (as_expected fgf'))))
         (let [fgf' (# f_apply on
                       fgf
                       (# f_monad in (function (_ gf gx) (# g_apply on gx gf))))]
           (# f_apply on fgx fgf')))
    ... (let [applyF (# f_apply on)
    ...       applyG (# g_apply on)]
    ...   (all applyF
    ...       fgf
    ...       (# f_monad in applyG)
    ...       fgx))
    ))
