(.module:
  [library
   [lux #*
    ["@" target]]]
  [//
   [monad (#+ Monad)]
   ["." functor (#+ Functor)]])

(type: .public (Apply f)
  (Interface
   (: (Functor f)
      &functor)
   (: (All [a b]
        (-> (f a) (f (-> a b)) (f b)))
      on)))

(implementation: .public (composite f_monad f_apply g_apply)
  (All [F G]
    (-> (Monad F) (Apply F) (Apply G)
        ... TODO: Replace (All [a] (F (G a))) with (functor.Then F G)
        (Apply (All [a] (F (G a))))))
  
  (def: &functor
    (functor.composite (value@ #&functor f_apply)
                       (value@ #&functor g_apply)))
  
  (def: (on fgx fgf)
    ... TODO: Switch from this version to the one below (in comments) ASAP.
    (for {@.old (let [fgf' (\ f_apply on
                              fgf
                              (\ f_monad in (function (_ gf gx) (\ g_apply on gx gf))))]
                  (:expected (\ f_apply on (:expected fgx) (:expected fgf'))))}
         (let [fgf' (\ f_apply on
                       fgf
                       (\ f_monad in (function (_ gf gx) (\ g_apply on gx gf))))]
           (\ f_apply on fgx fgf')))
    ... (let [applyF (\ f_apply on)
    ...       applyG (\ g_apply on)]
    ...   ($_ applyF
    ...       fgf
    ...       (\ f_monad in applyG)
    ...       fgx))
    ))
