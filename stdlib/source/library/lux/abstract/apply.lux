(.module:
  [library
   [lux #*]]
  [//
   [monad (#+ Monad)]
   ["." functor (#+ Functor)]])

(interface: #export (Apply f)
  {#.doc "Applicative functors."}
  (: (Functor f)
     &functor)
  (: (All [a b]
       (-> (f (-> a b)) (f a) (f b)))
     apply))

(implementation: #export (compose f_monad f_apply g_apply)
  {#.doc "Applicative functor composition."}
  (All [F G]
    (-> (Monad F) (Apply F) (Apply G)
        ## TODO: Replace (All [a] (F (G a))) with (functor.Then F G)
        (Apply (All [a] (F (G a))))))
  
  (def: &functor (functor.compose (get@ #&functor f_apply) (get@ #&functor g_apply)))
  
  (def: (apply fgf fgx)
    ## TODO: Switch from this version to the one below (in comments) ASAP.
    (let [fgf' (\ f_apply apply
                  (\ f_monad in (\ g_apply apply))
                  fgf)]
      (\ f_apply apply fgf' fgx))
    ## (let [applyF (\ f_apply apply)
    ##       applyG (\ g_apply apply)]
    ##   ($_ applyF
    ##       (\ f_monad in applyG)
    ##       fgf
    ##       fgx))
    ))
