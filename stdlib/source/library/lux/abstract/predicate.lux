(.module:
  [library
   [lux #*
    [control
     ["." function]]]]
  [//
   [monoid (#+ Monoid)]
   [functor
    ["." contravariant]]])

(type: #export (Predicate a)
  {#.doc (doc "A question that can be asked of a value, yield either false (#0) or true (#1).")}
  (-> a Bit))

(template [<identity_name> <identity_value> <composition_name> <composition>
           <identity_doc> <composition_doc>]
  [(def: #export <identity_name>
     {#.doc <identity_doc>}
     Predicate
     (function.constant <identity_value>))

   (def: #export (<composition_name> left right)
     {#.doc <composition_doc>}
     (All [a] (-> (Predicate a) (Predicate a) (Predicate a)))
     (function (_ value)
       (<composition> (left value)
                      (right value))))]

  [none #0 unite     or
   (doc "A predicate that always fails.")
   (doc "A predicate that meets either predecessor.")]
  [all  #1 intersect and
   (doc "A predicate that always succeeds.")
   (doc "A predicate that meets both predecessors.")]
  )

(template [<name> <identity> <composition>]
  [(implementation: #export <name>
     (All [a] (Monoid (Predicate a)))
     
     (def: identity <identity>)
     (def: compose <composition>))]

  [union        ..none ..unite]
  [intersection ..all  ..intersect]
  )

(def: #export (complement predicate)
  {#.doc (doc "The opposite of a predicate.")}
  (All [a] (-> (Predicate a) (Predicate a)))
  (|>> predicate not))

(def: #export (difference sub base)
  {#.doc (doc "A predicate that meeds 'base', but not 'sub'.")}
  (All [a] (-> (Predicate a) (Predicate a) (Predicate a)))
  (function (_ value)
    (and (base value)
         (not (sub value)))))

(def: #export (rec predicate)
  {#.doc (doc "Ties the knot for a recursive predicate.")}
  (All [a]
    (-> (-> (Predicate a) (Predicate a))
        (Predicate a)))
  (function (recur input)
    (predicate recur input)))

(implementation: #export functor
  (contravariant.Functor Predicate)
  
  (def: (map f fb)
    (|>> f fb)))
