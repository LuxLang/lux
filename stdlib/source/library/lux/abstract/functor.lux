(.module:
  [library
   [lux (#- Or And)]])

(type: .public (Functor f)
  (Interface
   (: (All [a b]
        (-> (-> a b)
            (-> (f a) (f b))))
      each)))

(type: .public (Fix f)
  (f (Fix f)))

(type: .public (Or f g)
  (All [a] (.Or (f a) (g a))))

(def: .public (sum (^open "f\.") (^open "g\."))
  (All [F G] (-> (Functor F) (Functor G) (Functor (..Or F G))))
  (implementation
   (def: (each f fa|ga)
     (case fa|ga
       (#.Left fa)
       (#.Left (f\each f fa))
       
       (#.Right ga)
       (#.Right (g\each f ga))))))

(type: .public (And f g)
  (All [a] (.And (f a) (g a))))

(def: .public (product (^open "f\.") (^open "g\."))
  (All [F G] (-> (Functor F) (Functor G) (Functor (..And F G))))
  (implementation
   (def: (each f [fa ga])
     [(f\each f fa)
      (g\each f ga)])))

(type: .public (Then f g)
  (All [a] (f (g a))))

(def: .public (composite (^open "f\.") (^open "g\."))
  (All [F G] (-> (Functor F) (Functor G) (Functor (..Then F G))))
  (implementation
   (def: (each f fga)
     (f\each (g\each f) fga))))
