(.module:
  [library
   [lux (#- Or And)]])

(interface: .public (Functor f)
  (: (All [a b]
       (-> (-> a b)
           (-> (f a) (f b))))
     map))

(type: .public (Fix f)
  (f (Fix f)))

(type: .public (Or f g)
  (All [a] (.Or (f a) (g a))))

(def: .public (sum (^open "f\.") (^open "g\."))
  {#.doc (example "Co-product (sum) composition for functors.")}
  (All [F G] (-> (Functor F) (Functor G) (Functor (..Or F G))))
  (implementation
   (def: (map f fa|ga)
     (case fa|ga
       (#.Left fa)
       (#.Left (f\map f fa))
       
       (#.Right ga)
       (#.Right (g\map f ga))))))

(type: .public (And f g)
  (All [a] (.And (f a) (g a))))

(def: .public (product (^open "f\.") (^open "g\."))
  {#.doc (example "Product composition for functors.")}
  (All [F G] (-> (Functor F) (Functor G) (Functor (..And F G))))
  (implementation
   (def: (map f [fa ga])
     [(f\map f fa)
      (g\map f ga)])))

(type: .public (Then f g)
  (All [a] (f (g a))))

(def: .public (compose (^open "f\.") (^open "g\."))
  {#.doc "Functor composition."}
  (All [F G] (-> (Functor F) (Functor G) (Functor (..Then F G))))
  (implementation
   (def: (map f fga)
     (f\map (g\map f) fga))))
