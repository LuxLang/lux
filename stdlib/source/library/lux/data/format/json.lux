... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except Array
                has text natural integer revolution list
                or and
                variant record)
   [abstract
    [equality (.only Equality)]
    [format (.only Format)]
    ["<>" projection (.use "[1]:[0]" monad)]
    ["[0]" monad]]
   [control
    ["[0]" pipe]]
   ["[0]" error (.only)
    ["[0]" try (.only Try) (.use "[1]:[0]" functor)]
    ["[0]" exception (.only Exception)]]
   ["[0]" function (.only)
    [predicate (.only Predicate)]]
   [data
    ["[0]" maybe]
    ["[0]" product]
    ["[0]" text (.only)
     ["<[1]>" \\projection (.only Projection)]
     ["[0]" escape]
     ["[0]" slice
      ["?[1]" \\projection]]]
    [collection
     ["[0]" list (.use "[1]:[0]" monoid mix functor)
      ["?[1]" \\projection]]
     ["[0]" dictionary (.only Dictionary) (.use "[1]:[0]" functor)]]]
   [logic
    ["[0]" bit]]
   [math
    [number
     ["[0]" /64 (.only)
      ["[0]" natural]
      ["[0]" integer]
      ["[0]" revolution]
      ["[0]" decimal (.use "[1]:[0]" base_10)]]]]
   [macro
    ["^" pattern]
    ["[0]" syntax]
    ["[0]" template]
    ["[0]" expansion]]
   [meta
    ["[0]" code (.only)
     ["<[1]>" \\projection]]]
   [time
    ["[0]" instant]
    ["[0]" duration]
    ["[0]" date]
    ["[0]" day]
    ["[0]" month]]]])

(template.with [<name> <type>]
  [(every .public <name>
     <type>)]

  [[Null    Any]
   [Boolean Bit]
   [Number  Decimal]
   [String  Text]])

(every .public (JSON _)
  (Variant
   {:Null    Null}
   {:Boolean Boolean}
   {:Number  Number}
   {:String  String}
   {:Array   (List (JSON _))}
   {:Object  (Dictionary String (JSON _))}))

(template.with [<name> <type>]
  [(every .public <name>
     <type>)]

  [[Array  (List JSON)]
   [Object (Dictionary String JSON)]])

(the .public null?
  (Predicate JSON)
  (|>> (pipe.when
         {:Null}
         true
         
         _
         false)))

(the .public object
  (-> (List [String JSON])
      JSON)
  (|>> (dictionary.of_list text.hash)
       {..:Object}))

(every JSON'
  (Rec JSON'
    (Variant
     {:Null'    Null}
     {:Boolean' Boolean}
     {:Number'  Number}
     {:String'  String}
     {:Array'   (List JSON')}
     {:Object'  (Dictionary String JSON')}
     {:Code'    Code})))

(the jsonP
  (<code>.Projection JSON')
  (<>.rec
   (function (_ jsonP)
     (all <>.or
          (<code>.form (<>:pure []))
          <code>.bit
          <code>.decimal
          <code>.text
          (<code>.tuple (<>.some jsonP))
          (<>:each (dictionary.of_list text.hash)
                   (<code>.variant (<>.some (<>.and <code>.text jsonP))))
          ?list.any
          ))))

(the (jsonF token)
  (-> JSON'
      Code)
  (`` (when token
        {:Null' _}
        (` {..:Null})
        
        (,, (template.with [<ctor> <input_tag> <output_tag>]
              [{<input_tag> value}
               (` {<output_tag> (, (<ctor> value))})]

              [[code.bit  ..:Boolean' ..:Boolean]
               [code.decimal ..:Number' ..:Number]
               [code.text ..:String' ..:String]]))
        
        {:Array' members}
        (` {..:Array (.list (,* (list:each jsonF members)))})

        {:Object' pairs}
        (` {..:Object (dictionary.of_list text.hash
                                          (.list (,* (|> pairs
                                                         dictionary.entries
                                                         (list:each (function (_ [key_name value])
                                                                      (` [(, (code.text key_name)) (, (jsonF value))])))))))})

        {:Code' code}
        code)))

(syntax.the .public (json [token ..jsonP])
  (pure (.list (` (is JSON
                      (, (jsonF token)))))))

(the .public (fields json)
  (-> JSON
      (Try (List String)))
  (when json
    {:Object obj}
    {try.:Success (dictionary.domain obj)}

    _
    {try.:Failure "Cannot get the fields of a non-object."}))

(the .public (field key json)
  (-> String JSON
      (Try JSON))
  (when json
    {:Object obj}
    (when (dictionary.value key obj)
      {try.:Success value}
      {try.:Success value}

      failure
      {try.:Failure (.text "Missing field '" key "' on object.")})

    _
    {try.:Failure (.text "Cannot get field '" key "' on a non-object.")}))

(the .public (has key value json)
  (-> String JSON JSON
      (Try JSON))
  (when json
    {:Object obj}
    {try.:Success {:Object (dictionary.has key value obj)}}

    _
    {try.:Failure (.text "Cannot set field '" key "' on a non-object.")}))

(template.with [<name> <tag> <type>]
  [(the .public (<name> key json)
     (-> Text JSON
         (Try <type>))
     (when (field key json)
       {try.:Success {<tag> value}}
       {try.:Success value}

       {try.:Success _}
       {try.:Failure (.text "Wrong value type at key: " key)}

       {try.:Failure error}
       {try.:Failure error}))]

  [[boolean_field :Boolean Boolean]
   [number_field  :Number  Number]
   [string_field  :String  String]
   [array_field   :Array   Array]
   [object_field  :Object  Object]])

(the .public equality
  (Equality JSON)
  (implementation
   (the (= x y)
     (`` (when [x y]
           [{:Null} {:Null}]
           true

           (,, (template.with [<tag> <struct>]
                 [[{<tag> x'} {<tag> y'}]
                  (by <struct> = x' y')]

                 [[:Boolean bit.equality]
                  [:Number  decimal.equality]
                  [:String  text.equality]]))

           [{:Array xs} {:Array ys}]
           (.and (natural.= (list.size xs) (list.size ys))
                 (list:mix (function (_ [x' y'] prev)
                             (.and prev
                                   (= x' y')))
                           true
                           (list.zipped_2 xs ys)))
           
           [{:Object xs} {:Object ys}]
           (.and (natural.= (dictionary.size xs) (dictionary.size ys))
                 (list:mix (function (_ [xk xv] prev)
                             (.and prev
                                   (when (dictionary.value xk ys)
                                     {try.:Success yv}
                                     (= xv yv)

                                     failure
                                     false)))
                           true
                           (dictionary.entries xs)))
           
           _
           false)))))

(alias [=]
       ..equality)

............................................................
............................................................
............................................................

(the (null_as_text _)
  (text.Injection Null)
  "null")

(the boolean_as_text
  (text.Injection Boolean)
  (|>> (pipe.when
         .false
         "false"
         
         .true
         "true")))

(the number_as_text
  (text.Injection Number)
  (|>> (pipe.when
         +0.0 ... OR -0.0
         "0.0"

         value
         (let [raw (by decimal.base_10 as value)]
           (if (decimal.< +0.0 value)
               raw
               (|> raw (text.split_at 1) maybe.trusted product.right))))))

(the string_as_text
  (text.Injection String)
  (|>> escape.escaped
       (text.enclosed [text.double_quote text.double_quote])))

(template.with [<token> <name>]
  [(the <name>
     Text
     <token>)]

  [... https://en.wikipedia.org/wiki/Delimiter
   ["," delimiter_of_value]
   [":" delimiter_of_entry]

   ["[" start_of_array]
   ["]" end_of_array]

   ["{" start_of_object]
   ["}" end_of_object]])

(the (array_as_text as_text)
  (-> (text.Injection JSON)
      (text.Injection Array))
  (|>> (list:each as_text)
       (text.interposed ..delimiter_of_value)
       (text.enclosed [..start_of_array ..end_of_array])))

(the (kv_as_text as_text [key value])
  (-> (text.Injection JSON)
      (text.Injection [String JSON]))
  (.text (..string_as_text key)
         ..delimiter_of_entry
         (as_text value)))

(the (object_as_text as_text)
  (-> (text.Injection JSON)
      (text.Injection Object))
  (|>> dictionary.entries
       (list:each (..kv_as_text as_text))
       (text.interposed ..delimiter_of_value)
       (text.enclosed [..start_of_object ..end_of_object])))

(the .public (as_text json)
  (text.Injection JSON)
  (`` (when json
        (,, (template.with [<tag> <as_text>]
              [{<tag> value}
               (<as_text> value)]

              [[:Null    ..null_as_text]
               [:Boolean ..boolean_as_text]
               [:Number  ..number_as_text]
               [:String  ..string_as_text]
               [:Array   (..array_as_text as_text)]
               [:Object  (..object_as_text as_text)]]))
        )))

............................................................
............................................................
............................................................

(template.the (?:= ,reference ,it)
  [(.i64_=# ,reference ,it)])

(template.the (?:< ,greater ,lesser)
  [(.int_<# (.integer ,greater) (.integer ,lesser))])

(template.the (?:size ,it)
  [(.text_size# ,it)])

(template.the (?:after ,origin ,it)
  [(is Natural (.i64_+# (is Natural ,origin) (is Natural ,it)))])

(template.the (?:next ,it)
  [(?:after 1 ,it)])

(template.the (?:character ,tape ,offset)
  [(.text_char# ,offset ,tape)])

(template.the (?:index ,tape ,offset ,reference)
  [(.text_index# ,offset ,reference ,tape)])

(the (any_space [offset tape])
  (Projection Any)
  (let [the_limit (?:size tape)]
    (loop (of [offset offset])
      (if (.and (?:< the_limit offset)
                (text.space? (?:character tape offset)))
          (of (?:next offset))
          {try.:Success [[offset tape] []]}))))

(the with_space
  (for_any (_ it)
    (Change (Projection it)))
  (<<| (<>.after ..any_space)
       (<>.before ..any_space)))

(the (?:this reference [offset tape])
  (-> Text
      (Projection Text))
  (expansion.let [,failure (these (exception.except <text>.cannot_match [reference]))]
    (when (?:index tape offset reference)
      {.:Some where}
      (if (?:= offset where)
          {try.:Success [[(?:after (?:size reference) offset) tape] reference]}
          ,failure)

      else
      ,failure)))

(the any_delimiter_of_value
  (Projection Any)
  (with_space (?:this ..delimiter_of_value)))

(the the_null
  (Projection Null)
  (?:this "null"))

(template.with_locals [,the_offset&tape ,the_error]
  (these (template.the (?:pure ,it)
           [{try.:Success [,the_offset&tape ,it]}])

         (template.the (?:let ,name ,value ,body)
           [(when (,value ,the_offset&tape)
              {try.:Success [,the_offset&tape ,name]}
              ,body

              {try.:Failure ,the_error}
              {try.:Failure ,the_error})])

         (template.with [<value> <name> <token>]
           [(the (<name> ,the_offset&tape)
              (Projection Boolean)
              (<| (?:let _ (?:this <token>))
                  (?:pure <value>)))]

           [[0b the_false "false"]
            [1b the_true  "true"]])

         (template.the (?:either ,this ,that)
           [(when (,this ,the_offset&tape)
              {try.:Failure ,the_error}
              (,that ,the_offset&tape)

              success
              success)])

         (the (any_boolean ,the_offset&tape)
           (Projection Boolean)
           (?:either ..the_false
                     ..the_true))

         (the (?:parses? reference [offset tape])
           (-> Text
               (Projection Bit))
           (expansion.let [,failure (these {try.:Success [[offset tape] false]})]
             (when (?:index tape offset reference)
               {.:Some where}
               (if (?:= offset where)
                   {try.:Success [[(?:after (?:size reference) offset) tape] true]}
                   ,failure)

               else
               ,failure)))

         (the ?:signed?
           (Projection Bit)
           (?:parses? "-"))

         (the <0 (-- (character "0")))
         (the >9 (++ (character "9")))

         (template.the (?:digit? ,it)
           [(.and (?:< ,it ..<0)
                  (?:< ..>9 ,it))])

         (the (?:natural [offset tape])
           (Projection Text)
           (let [the_limit (?:size tape)]
             (loop (of [run 0])
               (let [index (?:after offset run)]
                 (if (.and (?:< the_limit index)
                           (?:digit? (?:character tape index)))
                     (of (?:next run))
                     (if (?:= 0 run)
                         {try.:Failure error.not_valid}
                         {try.:Success [[index tape] (.text_clip# offset run tape)]}))))))

         (the (?:integer ,the_offset&tape)
           (Projection Text)
           (<| (?:let signed? ?:signed?)
               (?:let natural ?:natural)
               (?:pure (.text (if signed? "-" "") natural))))

         (the (?:revolution ,the_offset&tape)
           (Projection Text)
           (<| (?:let _ (?:this "."))
               (?:natural ,the_offset&tape)))

         (the (?:delimiter_of_exponent [offset tape])
           (Projection Text)
           (if (.and (?:< (?:size tape) offset)
                     (when (?:character tape offset)
                       (^.or (character "e")
                             (character "E"))
                       true

                       else
                       false))
               {try.:Success [[(?:next offset) tape] "e"]}
               {try.:Failure error.not_valid}))

         (the (?:else else then
                      ,the_offset&tape)
           (-> Text
               (Change (Projection Text)))
           (when (then ,the_offset&tape)
             {try.:Failure _}
             {try.:Success [,the_offset&tape else]}

             success
             success))

         (the (any_number ,the_offset&tape)
           (Projection Number)
           (<| (?:let digits ?:integer)
               (?:let decimals (?:else "0" ?:revolution))
               (?:let exp (?:else "" (function (_ ,the_offset&tape)
                                       (<| (?:let mark ?:delimiter_of_exponent)
                                           (?:let offset ?:integer)
                                           (?:pure (.text mark offset))))))
               (when (decimal:of (.text digits "." decimals exp))
                 {try.:Success value}
                 (?:pure value)

                 {try.:Failure message}
                 {try.:Failure message})))
         ))

(the escaped_string_of
  (Projection Text)
  (`` (all <>.either
           (,, (template.with [<when> <then>]
                 [(<>.after (?:this <when>)
                            (<>:pure <then>))]

                 [["\t" text.tab]
                  ["\b" text.back_space]
                  ["\n" text.\n]
                  ["\r" text.carriage_return]
                  ["\f" text.form_feed]
                  [(.text "\" text.double_quote) text.double_quote]
                  ["\\" "\"]]))
           (<>.after (?:this "\u")
                     (|> ?slice.base_16
                         (?slice.exactly 4)
                         ?slice.slice
                         (<>.of natural.base_16)
                         (<>:each text.of_character)))
           )))

(the string_of
  (Projection String)
  (<| (<text>.enclosed [text.double_quote text.double_quote])
      (loop (of [_ []]))
      (monad.let [! <>.monad]
        [characters (<text>.some (<text>.none_of (.text "\" text.double_quote)))
         stop <text>.next])
      (if (text.= "\" stop)
          (monad.let !
            [escaped ..escaped_string_of
             next_characters (of [])]
            (pure (.text characters escaped next_characters)))
          (pure characters))))

(the (kv_of json_of)
  (-> (Projection JSON)
      (Projection [String JSON]))
  (monad.let <>.monad
    [key ..string_of
     _ (with_space
         (?:this ..delimiter_of_entry))
     value json_of]
    (pure [key value])))

(template.with [<name> <type> <open> <close> <elem_of> <prep>]
  [(the (<name> json_of)
     (-> (Projection JSON)
         (Projection <type>))
     (monad.let <>.monad
       [_ (?:this <open>)
        elems (with_space
                (<>.delimited_by ..any_delimiter_of_value <elem_of>))
        _ (?:this <close>)]
       (pure (|> elems <prep>))))]

  [[array_of  Array  ..start_of_array ..end_of_array json_of <|]
   [object_of Object ..start_of_object ..end_of_object (kv_of json_of) (dictionary.of_list text.hash)]])

(the json_of
  (Projection JSON)
  (<| with_space
      <>.rec
      (function (_ json_of))
      (all <>.or
           the_null
           any_boolean
           any_number
           string_of
           (array_of json_of)
           (object_of json_of))))

(the .public format
  (Format Text JSON)
  (implementation
   (the as ..as_text)
   (the of (<text>.value json_of))))

(exception.the (cannot_project [it])
  (Exception JSON)
  (exception.report
   (.list ["JSON" (..as_text it)])))

(template.with [,name ,type ,tag]
  [(the .public ,name
     (Format JSON ,type)
     (implementation
      (the as (|>> {,tag}))
      (the (of it)
        (when it
          {,tag it}
          {try.:Success it}

          _
          (exception.except ..cannot_project [it])))))]

  [[any Any :Null]
   [bit Bit :Boolean]
   [decimal Decimal :Number]
   [text Text :String]])

(the low_mask Natural (|> 1 (/64.<< 32) --))
(the high_mask Natural (|> low_mask (/64.<< 32)))

(the .public natural
  (Format JSON Natural)
  (implementation
   (the (as input)
     (let [high (|> input (/64.and high_mask) (/64.>> 32))
           low (/64.and low_mask input)]
       {:Array (.list (|> high .integer integer.decimal {:Number})
                      (|> low .integer integer.decimal {:Number}))}))
   (the (of it)
     (when it
       {:Array (.list {:Number high} {:Number low})}
       {try.:Success (natural.+ (|> high decimal.integer .natural (/64.<< 32))
                                (|> low decimal.integer .natural))}

       _
       (exception.except ..cannot_project [it])))))

(the .public integer
  (Format JSON Integer)
  (implementation
   (the as
     (|>> .natural
          (by ..natural as)))
   (the of
     (|>> (by ..natural of)
          (by try.functor each (|>> .integer))))))

(the .public revolution
  (Format JSON Revolution)
  (implementation
   (the as
     (|>> .natural
          (by ..natural as)))
   (the of
     (|>> (by ..natural of)
          (by try.functor each (|>> .revolution))))))

(template.with [,name ,type ,format]
  [(the .public ,name
     (Format JSON ,type)
     (implementation
      (the as
        (|>> (by ,format as)
             {:String}))
      (the (of it)
        (when it
          {:String it}
          (by ,format of it)
          
          _
          (exception.except ..cannot_project [it])))))]

  [[duration duration.Duration duration.text]
   [instant instant.Instant instant.text]
   [date date.Date date.text]
   [day day.Day day.text]
   [month month.Month month.text]])

(the .public (sum left right)
  (for_any (_ left right)
    (-> (Format JSON left) (Format JSON right)
        (Format JSON (Or left right))))
  (implementation
   (the (as it)
     {:Array (when it
               {0b it}
               (.list {:Boolean 0b} (by left as it))
               
               {1b it}
               (.list {:Boolean 1b} (by right as it)))})
   (the (of it)
     (`` (when it
           (,, (template.with [,flag ,format]
                 [{:Array (.list {:Boolean ,flag} it)}
                  (try:each (|>> {,flag}) (with ,format (of it)))]

                 [[0b left]
                  [1b right]]))

           _
           (exception.except ..cannot_project [it]))))))

(the .public (product left right)
  (for_any (_ left right)
    (-> (Format JSON left) (Format JSON right)
        (Format JSON (And left right))))
  (implementation
   (the (as [itL itR])
     {:Array (.list (with left (as itL))
                    (with right (as itR)))})
   (the (of it)
     (when it
       {:Array (.list itL itR)}
       (monad.let try.monad
         [itL (with left (of itL))
          itR (with right (of itR))]
         (pure [itL itR]))
       
       _
       (exception.except ..cannot_project [it])))))

(the .public (recursive context)
  (for_any (_ it)
    (-> (Change (Format JSON it))
        (Format JSON it)))
  (implementation
   (the (as it)
     (with (context [as (function (_ _) {try.:Failure ""})])
       (as it)))
   (the (of it)
     (with (context [(|>> {:Null}) of])
       (of it)))))

(the .public (list item)
  (for_any (_ it)
    (-> (Format JSON it)
        (Format JSON (List it))))
  (implementation
   (the as
     (|>> (list:each (with item as))
          {:Array}))
   (the (of it)
     (when it
       {:Array it}
       (list.each' try.monad (with item of) it)
       
       _
       (exception.except ..cannot_project [it])))))

(the .public (dictionary value)
  (for_any (_ it)
    (-> (Format JSON it)
        (Format JSON (Dictionary Text it))))
  (implementation
   (the as
     (|>> (dictionary:each (by value as))
          {:Object}))
   (the (of it)
     (when it
       {:Object it}
       (|> it
           dictionary.entries
           (list.each' try.monad (function (_ [key it])
                                   (monad.let try.monad
                                     [it (with value (of it))]
                                     (pure [key it]))))
           (try:each (dictionary.of_list text.hash)))
       
       _
       (exception.except ..cannot_project [it])))))

(every .public (Case it)
  (-> Natural
      (Format JSON it)))

(the .public (case format)
  (for_any (_ it)
    (-> (Format JSON it)
        (Case it)))
  (function (_ expected)
    (let [expected (natural.decimal expected)]
      (implementation
       (the (as it)
         {:Array (.list {:Number expected}
                        (by format as it))})
       (the (of it)
         (when it
           {:Array (.list {:Number actual} case)}
           (if (decimal.= expected actual)
               (by format of case)
               (exception.except ..cannot_project [it]))
           
           _
           (exception.except ..cannot_project [it])))))))

(the .public (or left right)
  (for_any (_ left right)
    (-> (Case left) (Case right)
        (Case (Or left right))))
  (function (_ expected)
    (implementation
     (the (as it)
       (when it
         {0b it} (by (left expected) as it)
         {1b it} (by (right (++ expected)) as it)))
     (the (of it)
       (when (by (left expected) of it)
         {try.:Success it}
         {try.:Success {0b it}}
         
         {try.:Failure _}
         (when (by (right (++ expected)) of it)
           {try.:Success it}
           {try.:Success {1b it}}
           
           {try.:Failure error}
           {try.:Failure error}))))))

(the .public variant
  (for_any (_ it)
    (-> (Case it)
        (Format JSON it)))
  (function.of 0))

(every .public (Member it)
  (-> [Natural Bit]
      (Format (List JSON) it)))

(the .public (member format)
  (for_any (_ it)
    (-> (Format JSON it)
        (Member it)))
  (function (_ [index end?])
    (implementation
     (the (as it)
       (.list (by format as it)))
     (the (of it)
       (if (.or (not end?)
                (natural.= (++ index) (list.size it)))
           (monad.let try.monad
             [it (list.item index it)]
             (by format of it))
           (exception.except ..cannot_project [{:Array it}]))))))

(the .public (and left right)
  (for_any (_ left right)
    (-> (Member left) (Member right)
        (Member (And left right))))
  (function (_ [index end?])
    (implementation
     (the (as it)
       (all list:composite
            (by (left [index false]) as (product.left it))
            (by (right [(++ index) true]) as (product.right it))))
     (the (of it)
       (monad.let try.monad
         [left (by (left [index false]) of it)
          right (by (right [(++ index) true]) of it)]
         (pure [left right]))))))

(the .public (record member)
  (for_any (_ it)
    (-> (Member it)
        (Format JSON it)))
  (let [format (member [0 true])]
    (implementation
     (the (as it)
       {:Array (by format as it)})
     (the (of it)
       (when it
         {:Array items}
         (by format of items)

         _
         (exception.except ..cannot_project [it]))))))
