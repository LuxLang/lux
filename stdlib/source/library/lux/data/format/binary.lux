(.module:
  [library
   [lux (#- and or nat int rev list type)
    [abstract
     [monoid (#+ Monoid)]
     [monad (#+ Monad do)]
     [equivalence (#+ Equivalence)]]
    [control
     [pipe (#+ case>)]
     ["." function]
     ["." try (#+ Try)]
     ["<>" parser ("#\." monad)
      ["/" binary (#+ Offset Size Parser)]]]
    [data
     ["." product]
     ["." binary (#+ Binary)]
     [text
      ["%" format (#+ format)]
      [encoding
       ["." utf8]]]
     [collection
      ["." list]
      ["." row (#+ Row) ("#\." functor)]
      ["." set (#+ Set)]]]
    [math
     [number
      ["." i64]
      ["n" nat]
      ["." frac]]]]])

(def: mask
  (-> Size (I64 Any))
  (|>> (n.* i64.bits_per_byte) i64.mask))

(type: .public Mutation
  {#.doc (example "A mutation of binary data, tracking where in the data to transform.")}
  (-> [Offset Binary] [Offset Binary]))

(type: .public Specification
  {#.doc (example "A description of how to transform binary data.")}
  [Size Mutation])

(def: .public no_op
  {#.doc (example "A specification for empty binary data.")}
  Specification
  [0 function.identity])

(def: .public (instance [size mutation])
  {#.doc (example "Given a specification of how to construct binary data, yields a binary blob that matches it.")}
  (-> Specification Binary)
  (|> size binary.empty [0] mutation product.right))

(implementation: .public monoid
  (Monoid Specification)
  
  (def: identity
    ..no_op)
  
  (def: (compose [sizeL mutL] [sizeR mutR])
    [(n.+ sizeL sizeR)
     (|>> mutL mutR)]))

(type: .public (Writer a)
  {#.doc (example "An operation that knows how to write information into a binary blob.")}
  (-> a Specification))

(def: .public (result writer value)
  {#.doc (example "Yields a binary blob with all the information written to it.")}
  (All [a] (-> (Writer a) a Binary))
  (..instance (writer value)))

(template [<name> <size> <write>]
  [(def: .public <name>
     (Writer (I64 Any))
     (function (_ value)
       [<size>
        (function (_ [offset binary])
          [(n.+ <size> offset)
           (|> binary
               (<write> offset value)
               try.trusted)])]))]

  [bits/8  /.size/8  binary.write/8!]
  [bits/16 /.size/16 binary.write/16!]
  [bits/32 /.size/32 binary.write/32!]
  [bits/64 /.size/64 binary.write/64!]
  )

(def: .public (or left right)
  (All [l r] (-> (Writer l) (Writer r) (Writer (Or l r))))
  (function (_ altV)
    (case altV
      (^template [<number> <tag> <writer>]
        [(<tag> caseV)
         (let [[caseS caseT] (<writer> caseV)]
           [(.inc caseS)
            (function (_ [offset binary])
              (|> binary
                  (binary.write/8! offset <number>)
                  try.trusted
                  [(.inc offset)]
                  caseT))])])
      ([0 #.Left left]
       [1 #.Right right])
      )))

(def: .public (and pre post)
  (All [a b] (-> (Writer a) (Writer b) (Writer [a b])))
  (function (_ [preV postV])
    (\ ..monoid compose (pre preV) (post postV))))

(def: .public (rec body)
  {#.doc (example "A combinator for recursive writers.")}
  (All [a] (-> (-> (Writer a) (Writer a)) (Writer a)))
  (function (recur value)
    (body recur value)))

(def: .public any
  (Writer Any)
  (function.constant ..no_op))

(def: .public bit
  (Writer Bit)
  (|>> (case> #0 0 #1 1) ..bits/8))

(template [<name> <type>]
  [(def: .public <name> (Writer <type>) ..bits/64)]

  [nat Nat]
  [int Int]
  [rev Rev]
  )

(def: .public frac
  (Writer Frac)
  (|>> frac.bits ..bits/64))

(def: .public (segment size)
  {#.doc (example "Writes at most 'size' bytes of an input binary blob.")}
  (-> Nat (Writer Binary))
  (function (_ value)
    [size
     (function (_ [offset binary])
       [(n.+ size offset)
        (try.trusted
         (binary.copy (n.min size (binary.size value))
                      0
                      value
                      offset
                      binary))])]))

(template [<name> <bits> <size> <write>]
  [(def: .public <name>
     (Writer Binary)
     (let [mask (..mask <size>)]
       (function (_ value)
         (let [size (|> value binary.size (i64.and mask))
               size' (n.+ <size> size)]
           [size'
            (function (_ [offset binary])
              [(n.+ size' offset)
               (try.trusted
                (do try.monad
                  [_ (<write> offset size binary)]
                  (binary.copy size 0 value (n.+ <size> offset) binary)))])]))))]

  [binary/8  ..bits/8  /.size/8  binary.write/8!]
  [binary/16 ..bits/16 /.size/16 binary.write/16!]
  [binary/32 ..bits/32 /.size/32 binary.write/32!]
  [binary/64 ..bits/64 /.size/64 binary.write/64!]
  )

(template [<name> <binary>]
  [(def: .public <name>
     (Writer Text)
     (|>> (\ utf8.codec encode) <binary>))]

  [utf8/8  ..binary/8]
  [utf8/16 ..binary/16]
  [utf8/32 ..binary/32]
  [utf8/64 ..binary/64]
  )

(def: .public text ..utf8/64)

(template [<name> <size> <write>]
  [(def: .public (<name> valueW)
     (All [v] (-> (Writer v) (Writer (Row v))))
     (function (_ value)
       (let [original_count (row.size value)
             capped_count (i64.and (..mask <size>)
                                   original_count)
             value (if (n.= original_count capped_count)
                     value
                     (|> value row.list (list.first capped_count) row.of_list))
             (^open "specification\.") ..monoid
             [size mutation] (|> value
                                 (row\map valueW)
                                 (\ row.fold fold
                                    (function (_ post pre)
                                      (specification\compose pre post))
                                    specification\identity))]
         [(n.+ <size> size)
          (function (_ [offset binary])
            (try.trusted
             (do try.monad
               [_ (<write> offset capped_count binary)]
               (in (mutation [(n.+ <size> offset) binary])))))])))]

  [row/8  /.size/8  binary.write/8!]
  [row/16 /.size/16 binary.write/16!]
  [row/32 /.size/32 binary.write/32!]
  [row/64 /.size/64 binary.write/64!]
  )

(def: .public maybe
  (All [a] (-> (Writer a) (Writer (Maybe a))))
  (..or ..any))

(def: .public (list value)
  (All [a] (-> (Writer a) (Writer (List a))))
  (..rec
   (|>> (..and value)
        (..or ..any))))

(def: .public (set value)
  (All [a] (-> (Writer a) (Writer (Set a))))
  (|>> set.list (..list value)))

(def: .public name
  (Writer Name)
  (..and ..text ..text))

(def: .public type
  (Writer Type)
  (..rec
   (function (_ recur)
     (let [pair (..and recur recur)
           indexed ..nat
           quantified (..and (..list recur) recur)]
       (function (_ altV)
         (case altV
           (^template [<number> <tag> <writer>]
             [(<tag> caseV)
              (let [[caseS caseT] (<writer> caseV)]
                [(.inc caseS)
                 (function (_ [offset binary])
                   (|> binary
                       (binary.write/8! offset <number>)
                       try.trusted
                       [(.inc offset)]
                       caseT))])])
           ([0 #.Primitive (..and ..text (..list recur))]
            [1 #.Sum pair]
            [2 #.Product pair]
            [3 #.Function pair]
            [4 #.Parameter indexed]
            [5 #.Var indexed]
            [6 #.Ex indexed]
            [7 #.UnivQ quantified]
            [8 #.ExQ quantified]
            [9 #.Apply pair]
            [10 #.Named (..and ..name recur)])
           ))))))

(def: .public location
  (Writer Location)
  ($_ ..and ..text ..nat ..nat))

(def: .public code
  (Writer Code)
  (..rec
   (function (_ recur)
     (let [sequence (..list recur)]
       (..and ..location
              (function (_ altV)
                (case altV
                  (^template [<number> <tag> <writer>]
                    [(<tag> caseV)
                     (let [[caseS caseT] (<writer> caseV)]
                       [(.inc caseS)
                        (function (_ [offset binary])
                          (|> binary
                              (binary.write/8! offset <number>)
                              try.trusted
                              [(.inc offset)]
                              caseT))])])
                  ([0 #.Bit ..bit]
                   [1 #.Nat ..nat]
                   [2 #.Int ..int]
                   [3 #.Rev ..rev]
                   [4 #.Frac ..frac]
                   [5 #.Text ..text]
                   [6 #.Identifier ..name]
                   [7 #.Tag ..name]
                   [8 #.Form sequence]
                   [9 #.Tuple sequence]
                   [10 #.Record (..list (..and recur recur))])
                  )))))))
