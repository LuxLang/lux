(.using
  [library
   [lux {"-" and or nat int rev list type symbol}
    [abstract
     [monoid {"+" Monoid}]
     [monad {"+" Monad do}]
     [equivalence {"+" Equivalence}]]
    [control
     [pipe {"+" case>}]
     ["[0]" function]
     ["[0]" try {"+" Try}]
     ["<>" parser ("[1]#[0]" monad)
      ["/" binary {"+" Offset Size Parser}]]]
    [data
     ["[0]" product]
     ["[0]" binary {"+" Binary}]
     [text
      ["%" format {"+" format}]
      [encoding
       ["[0]" utf8]]]
     [collection
      ["[0]" list]
      ["[0]" sequence {"+" Sequence} ("[1]#[0]" functor)]
      ["[0]" set {"+" Set}]]]
    [math
     [number
      ["[0]" i64]
      ["n" nat]
      ["[0]" frac]]]]])

(def: mask
  (-> Size (I64 Any))
  (|>> (n.* i64.bits_per_byte) i64.mask))

(type: .public Mutation
  (-> [Offset Binary] [Offset Binary]))

(type: .public Specification
  [Size Mutation])

(def: .public no_op
  Specification
  [0 function.identity])

(def: .public (instance [size mutation])
  (-> Specification Binary)
  (|> size binary.empty [0] mutation product.right))

(implementation: .public monoid
  (Monoid Specification)
  
  (def: identity
    ..no_op)
  
  (def: (composite [sizeL mutL] [sizeR mutR])
    [(n.+ sizeL sizeR)
     (|>> mutL mutR)]))

(type: .public (Writer a)
  (-> a Specification))

(def: .public (result writer value)
  (All (_ a) (-> (Writer a) a Binary))
  (..instance (writer value)))

(template [<name> <size> <write>]
  [(def: .public <name>
     (Writer (I64 Any))
     (function (_ value)
       [<size>
        (function (_ [offset binary])
          [(n.+ <size> offset)
           (|> binary
               (<write> offset value)
               try.trusted)])]))]

  [bits/8  /.size/8  binary.write/8!]
  [bits/16 /.size/16 binary.write/16!]
  [bits/32 /.size/32 binary.write/32!]
  [bits/64 /.size/64 binary.write/64!]
  )

(def: .public (or left right)
  (All (_ l r) (-> (Writer l) (Writer r) (Writer (Or l r))))
  (function (_ altV)
    (case altV
      (^template [<number> <tag> <writer>]
        [{<tag> caseV}
         (let [[caseS caseT] (<writer> caseV)]
           [(.++ caseS)
            (function (_ [offset binary])
              (|> binary
                  (binary.write/8! offset <number>)
                  try.trusted
                  [(.++ offset)]
                  caseT))])])
      ([0 .#Left left]
       [1 .#Right right])
      )))

(def: .public (and pre post)
  (All (_ a b) (-> (Writer a) (Writer b) (Writer [a b])))
  (function (_ [preV postV])
    (# ..monoid composite (pre preV) (post postV))))

(def: .public (rec body)
  (All (_ a) (-> (-> (Writer a) (Writer a)) (Writer a)))
  (function (again value)
    (body again value)))

(def: .public any
  (Writer Any)
  (function.constant ..no_op))

(def: .public bit
  (Writer Bit)
  (|>> (case> #0 0 #1 1) ..bits/8))

(template [<name> <type>]
  [(def: .public <name> (Writer <type>) ..bits/64)]

  [nat Nat]
  [int Int]
  [rev Rev]
  )

(def: .public frac
  (Writer Frac)
  (|>> frac.bits ..bits/64))

(def: .public (segment size)
  (-> Nat (Writer Binary))
  (function (_ value)
    [size
     (function (_ [offset binary])
       [(n.+ size offset)
        (try.trusted
         (binary.copy (n.min size (binary.size value))
                      0
                      value
                      offset
                      binary))])]))

(template [<name> <bits> <size> <write>]
  [(def: .public <name>
     (Writer Binary)
     (let [mask (..mask <size>)]
       (function (_ value)
         (let [size (|> value binary.size (i64.and mask))
               size' (n.+ <size> size)]
           [size'
            (function (_ [offset binary])
              [(n.+ size' offset)
               (try.trusted
                (do try.monad
                  [_ (<write> offset size binary)]
                  (binary.copy size 0 value (n.+ <size> offset) binary)))])]))))]

  [binary/8  ..bits/8  /.size/8  binary.write/8!]
  [binary/16 ..bits/16 /.size/16 binary.write/16!]
  [binary/32 ..bits/32 /.size/32 binary.write/32!]
  [binary/64 ..bits/64 /.size/64 binary.write/64!]
  )

(template [<name> <binary>]
  [(def: .public <name>
     (Writer Text)
     (|>> (# utf8.codec encoded) <binary>))]

  [utf8/8  ..binary/8]
  [utf8/16 ..binary/16]
  [utf8/32 ..binary/32]
  [utf8/64 ..binary/64]
  )

(def: .public text ..utf8/64)

(template [<name> <size> <write>]
  [(def: .public (<name> valueW)
     (All (_ v) (-> (Writer v) (Writer (Sequence v))))
     (function (_ value)
       (let [original_count (sequence.size value)
             capped_count (i64.and (..mask <size>)
                                   original_count)
             value (if (n.= original_count capped_count)
                     value
                     (|> value sequence.list (list.first capped_count) sequence.of_list))
             (^open "specification#[0]") ..monoid
             [size mutation] (|> value
                                 (sequence#each valueW)
                                 (# sequence.mix mix
                                    (function (_ post pre)
                                      (specification#composite pre post))
                                    specification#identity))]
         [(n.+ <size> size)
          (function (_ [offset binary])
            (try.trusted
             (do try.monad
               [_ (<write> offset capped_count binary)]
               (in (mutation [(n.+ <size> offset) binary])))))])))]

  [sequence/8  /.size/8  binary.write/8!]
  [sequence/16 /.size/16 binary.write/16!]
  [sequence/32 /.size/32 binary.write/32!]
  [sequence/64 /.size/64 binary.write/64!]
  )

(def: .public maybe
  (All (_ a) (-> (Writer a) (Writer (Maybe a))))
  (..or ..any))

(def: .public (list value)
  (All (_ a) (-> (Writer a) (Writer (List a))))
  (..rec
   (|>> (..and value)
        (..or ..any))))

(def: .public (set value)
  (All (_ a) (-> (Writer a) (Writer (Set a))))
  (|>> set.list (..list value)))

(def: .public symbol
  (Writer Symbol)
  (..and ..text ..text))

(def: .public type
  (Writer Type)
  (..rec
   (function (_ again)
     (let [pair (..and again again)
           indexed ..nat
           quantified (..and (..list again) again)]
       (function (_ altV)
         (case altV
           (^template [<number> <tag> <writer>]
             [{<tag> caseV}
              (let [[caseS caseT] (<writer> caseV)]
                [(.++ caseS)
                 (function (_ [offset binary])
                   (|> binary
                       (binary.write/8! offset <number>)
                       try.trusted
                       [(.++ offset)]
                       caseT))])])
           ([0 .#Primitive (..and ..text (..list again))]
            [1 .#Sum pair]
            [2 .#Product pair]
            [3 .#Function pair]
            [4 .#Parameter indexed]
            [5 .#Var indexed]
            [6 .#Ex indexed]
            [7 .#UnivQ quantified]
            [8 .#ExQ quantified]
            [9 .#Apply pair]
            [10 .#Named (..and ..symbol again)])
           ))))))

(def: .public location
  (Writer Location)
  ($_ ..and ..text ..nat ..nat))

(def: .public code
  (Writer Code)
  (..rec
   (function (_ again)
     (let [sequence (..list again)]
       (..and ..location
              (function (_ altV)
                (case altV
                  (^template [<number> <tag> <writer>]
                    [{<tag> caseV}
                     (let [[caseS caseT] (<writer> caseV)]
                       [(.++ caseS)
                        (function (_ [offset binary])
                          (|> binary
                              (binary.write/8! offset <number>)
                              try.trusted
                              [(.++ offset)]
                              caseT))])])
                  ([0 .#Bit ..bit]
                   [1 .#Nat ..nat]
                   [2 .#Int ..int]
                   [3 .#Rev ..rev]
                   [4 .#Frac ..frac]
                   [5 .#Text ..text]
                   [6 .#Symbol ..symbol]
                   [7 .#Form sequence]
                   [8 .#Variant sequence]
                   [9 .#Tuple sequence])
                  )))))))
