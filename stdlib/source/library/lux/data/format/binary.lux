(.using
 [library
  [lux (.except and or nat int rev list type symbol)
   [ffi (.only)]
   [abstract
    [monoid (.only Monoid)]
    [monad (.only Monad do)]
    [equivalence (.only Equivalence)]]
   [control
    ["[0]" pipe]
    ["[0]" function]
    ["<>" parser (.open: "[1]#[0]" monad)
     ["</>" binary (.only Offset Size Parser)]]]
   [data
    ["/" binary
     ["[1]" \\unsafe (.only Binary)]]
    ["[0]" product]
    [text
     ["%" format (.only format)]
     [encoding
      ["[0]" utf8]]]
    [collection
     ["[0]" list]
     ["[0]" sequence (.only Sequence) (.open: "[1]#[0]" functor)]
     ["[0]" set (.only Set)]
     [array
      [\\unsafe (.only)]]]]
   [macro
    ["^" pattern]]
   [math
    [number
     ["n" nat]
     ["[0]" i64]
     ["[0]" frac]]]]])

(template [<name> <extension> <post>]
  [(template: (<name> <parameter> <subject>)
     [(<post> (<extension> (.int <parameter>) (.int <subject>)))])]

  [n#= "lux i64 =" .|>]
  [n#+ "lux i64 +" .nat]
  [n#* "lux i64 *" .nat]
  )

(def: mask
  (-> Size (I64 Any))
  (|>> (n#* i64.bits_per_byte) i64.mask))

(type: .public Mutation
  (-> [Offset Binary] [Offset Binary]))

(type: .public Specification
  [Size Mutation])

(def: .public no_op
  Specification
  [0 function.identity])

(def: .public (instance [size mutation])
  (-> Specification Binary)
  (|> size /.empty [0] mutation product.right))

(implementation: .public monoid
  (Monoid Specification)
  
  (def: identity
    ..no_op)
  
  (def: (composite [sizeL mutL] [sizeR mutR])
    [(n#+ sizeL sizeR)
     (|>> mutL mutR)]))

(type: .public (Writer a)
  (-> a Specification))

(def: .public (result writer value)
  (All (_ a) (-> (Writer a) a Binary))
  (..instance (writer value)))

(template [<name> <size> <write>]
  [(def: .public <name>
     (Writer (I64 Any))
     (function (_ value)
       [<size>
        (function (_ [offset binary])
          [(n#+ <size> offset)
           (<write> offset value binary)])]))]

  [bits_8  </>.size_8  /.has_8!]
  [bits_16 </>.size_16 /.has_16!]
  [bits_32 </>.size_32 /.has_32!]
  [bits_64 </>.size_64 /.has_64!]
  )

(def: .public (or left right)
  (All (_ l r) (-> (Writer l) (Writer r) (Writer (Or l r))))
  (function (_ altV)
    (case altV
      (^.template [<number> <tag> <writer>]
        [{<tag> caseV}
         (let [[caseS caseT] (<writer> caseV)]
           [(.++ caseS)
            (function (_ [offset binary])
              (|> binary
                  (/.has_8! offset <number>)
                  [(.++ offset)]
                  caseT))])])
      ([0 .#Left left]
       [1 .#Right right])
      )))

(def: .public (and pre post)
  (All (_ a b) (-> (Writer a) (Writer b) (Writer [a b])))
  (function (_ [preV postV])
    (at ..monoid composite (pre preV) (post postV))))

(def: .public (rec body)
  (All (_ a) (-> (-> (Writer a) (Writer a)) (Writer a)))
  (function (again value)
    (body again value)))

(def: .public any
  (Writer Any)
  (function.constant ..no_op))

(def: .public bit
  (Writer Bit)
  (|>> (pipe.case #0 0 #1 1) ..bits_8))

(template [<name> <type>]
  [(def: .public <name> (Writer <type>) ..bits_64)]

  [nat Nat]
  [int Int]
  [rev Rev]
  )

(def: .public frac
  (Writer Frac)
  (|>> frac.bits ..bits_64))

(def: .public (segment size)
  (-> Nat (Writer Binary))
  (function (_ value)
    [size
     (function (_ [offset binary])
       [(n#+ size offset)
        (/.copy! (n.min size (/.size value))
                 0
                 value
                 offset
                 binary)])]))

(template [<name> <bits> <size> <write>]
  [(def: .public <name>
     (Writer Binary)
     (let [mask (..mask <size>)]
       (function (_ value)
         (let [size (|> value /.size (i64.and mask))
               size' (n#+ <size> size)]
           [size'
            (function (_ [offset binary])
              [(n#+ size' offset)
               (|> binary
                   (<write> offset size)
                   (/.copy! size 0 value (n#+ <size> offset)))])]))))]

  [binary_8  ..bits_8  </>.size_8  /.has_8!]
  [binary_16 ..bits_16 </>.size_16 /.has_16!]
  [binary_32 ..bits_32 </>.size_32 /.has_32!]
  [binary_64 ..bits_64 </>.size_64 /.has_64!]
  )

(template [<name> <binary>]
  [(def: .public <name>
     (Writer Text)
     (|>> (at utf8.codec encoded) <binary>))]

  [utf8_8  ..binary_8]
  [utf8_16 ..binary_16]
  [utf8_32 ..binary_32]
  [utf8_64 ..binary_64]
  )

(def: .public text ..utf8_64)

(template [<name> <size> <write>]
  [(def: .public (<name> valueW)
     (All (_ v) (-> (Writer v) (Writer (Sequence v))))
     (function (_ value)
       (let [original_count (sequence.size value)
             capped_count (i64.and (..mask <size>)
                                   original_count)
             value (if (n#= original_count capped_count)
                     value
                     (|> value sequence.list (list.first capped_count) sequence.of_list))
             (open "specification#[0]") ..monoid
             [size mutation] (|> value
                                 (sequence#each valueW)
                                 (at sequence.mix mix
                                     (function (_ post pre)
                                       (specification#composite pre post))
                                     specification#identity))]
         [(n#+ <size> size)
          (function (_ [offset binary])
            (|> binary
                (<write> offset capped_count)
                [(n#+ <size> offset)]
                mutation))])))]

  [sequence_8  </>.size_8  /.has_8!]
  [sequence_16 </>.size_16 /.has_16!]
  [sequence_32 </>.size_32 /.has_32!]
  [sequence_64 </>.size_64 /.has_64!]
  )

(def: .public maybe
  (All (_ a) (-> (Writer a) (Writer (Maybe a))))
  (..or ..any))

(def: .public (list value)
  (All (_ a) (-> (Writer a) (Writer (List a))))
  (..rec
   (|>> (..and value)
        (..or ..any))))

(def: .public (set value)
  (All (_ a) (-> (Writer a) (Writer (Set a))))
  (|>> set.list (..list value)))

(def: .public symbol
  (Writer Symbol)
  (..and ..text ..text))

(def: .public type
  (Writer Type)
  (..rec
   (function (_ again)
     (let [pair (..and again again)
           indexed ..nat
           quantified (..and (..list again) again)]
       (function (_ altV)
         (case altV
           (^.template [<number> <tag> <writer>]
             [{<tag> caseV}
              (let [[caseS caseT] (<writer> caseV)]
                [(.++ caseS)
                 (function (_ [offset binary])
                   (|> binary
                       (/.has_8! offset <number>)
                       [(.++ offset)]
                       caseT))])])
           ([0 .#Primitive (..and ..text (..list again))]
            [1 .#Sum pair]
            [2 .#Product pair]
            [3 .#Function pair]
            [4 .#Parameter indexed]
            [5 .#Var indexed]
            [6 .#Ex indexed]
            [7 .#UnivQ quantified]
            [8 .#ExQ quantified]
            [9 .#Apply pair]
            [10 .#Named (..and ..symbol again)])
           ))))))

(def: .public location
  (Writer Location)
  (all ..and ..text ..nat ..nat))

(def: .public code
  (Writer Code)
  (..rec
   (function (_ again)
     (let [sequence (..list again)]
       (..and ..location
              (function (_ altV)
                (case altV
                  (^.template [<number> <tag> <writer>]
                    [{<tag> caseV}
                     (let [[caseS caseT] (<writer> caseV)]
                       [(.++ caseS)
                        (function (_ [offset binary])
                          (|> binary
                              (/.has_8! offset <number>)
                              [(.++ offset)]
                              caseT))])])
                  ([0 .#Bit ..bit]
                   [1 .#Nat ..nat]
                   [2 .#Int ..int]
                   [3 .#Rev ..rev]
                   [4 .#Frac ..frac]
                   [5 .#Text ..text]
                   [6 .#Symbol ..symbol]
                   [7 .#Form sequence]
                   [8 .#Variant sequence]
                   [9 .#Tuple sequence])
                  )))))))
