(.module:
  [library
   [lux (#- or and for same? not)
    [data
     ["." text
      ["%" format (#+ format)]]
     [number
      ["i" int]]]
    [type
     abstract]
    [macro
     ["." template]]
    ["." locale (#+ Locale)]]])

(type: .public Label Text)

(type: .public Tag Label)
(type: .public ID Label)
(type: .public Class Label)
(type: .public Attribute Label)

(abstract: .public (Generic brand) {} Any)

(template [<generic> <brand>]
  [(abstract: <brand> {} Any)
   (type: .public <generic> (Generic <brand>))]

  [Can_Chain Can_Chain']
  [Cannot_Chain Cannot_Chain']
  )

(abstract: .public Unique {} Any)
(abstract: .public Specific {} Any)
(abstract: .public Composite {} Any)

(abstract: .public (Selector kind)
  {}
  
  Text

  (def: .public selector
    (-> (Selector Any) Text)
    (|>> :representation))

  (def: .public any
    (Selector Cannot_Chain)
    (:abstraction "*"))

  (def: .public tag
    (-> Tag (Selector Cannot_Chain))
    (|>> :abstraction))

  (template [<name> <type> <prefix> <kind>]
    [(def: .public <name>
       (-> <type> (Selector <kind>))
       (|>> (format <prefix>) :abstraction))]

    [id ID "#" Unique]
    [class Class "." Can_Chain]
    )

  (template [<right> <left> <combo> <combinator>+]
    [(`` (template [<combinator> <name>]
           [(def: .public (<name> right left)
              (-> (Selector <right>) (Selector <left>) (Selector <combo>))
              (:abstraction (format (:representation left)
                                    <combinator>
                                    (:representation right))))]

           (~~ (template.spliced <combinator>+))))]

    [Can_Chain (Generic Any) Can_Chain
     [["" and]]]
    [Unique (Generic Any) Composite
     [["" for]]]
    [Specific (Generic Any) Composite
     [["" at]]]
    [Any Any Composite
     [["," or]
      [" " in]
      [">" sub]
      ["+" next]
      ["~" later]]]
    )

  (type: .public Combinator
    (-> (Selector Any) (Selector Any) (Selector Composite)))

  (def: .public (with? attribute)
    (-> Attribute (Selector Can_Chain))
    (:abstraction (format "[" attribute "]")))

  (template [<check> <name>]
    [(def: .public (<name> attribute value)
       (-> Attribute Text (Selector Can_Chain))
       (:abstraction (format "[" attribute <check> value "]")))]

    ["=" same?]
    ["~=" has?]
    ["|=" has_start?]
    ["^=" starts?]
    ["$=" ends?]
    ["*=" contains?]
    )

  (template [<kind> <pseudo>+]
    [(`` (template [<name> <pseudo>]
           [(def: .public <name>
              (Selector Can_Chain)
              (:abstraction <pseudo>))]

           (~~ (template.spliced <pseudo>+))))]

    [Can_Chain
     [[active ":active"]
      [checked ":checked"]
      [default ":default"]
      [disabled ":disabled"]
      [empty ":empty"]
      [enabled ":enabled"]
      [first_child ":first-child"]
      [first_of_type ":first-of-type"]
      [focused ":focus"]
      [hovered ":hover"]
      [in_range ":in-range"]
      [indeterminate ":indeterminate"]
      [invalid ":invalid"]
      [last_child ":last-child"]
      [last_of_type ":last-of-type"]
      [link ":link"]
      [only_of_type ":only-of-type"]
      [only_child ":only-child"]
      [optional ":optional"]
      [out_of_range ":out-of-range"]
      [read_only ":read-only"]
      [read_write ":read-write"]
      [required ":required"]
      [root ":root"]
      [target ":target"]
      [valid ":valid"]
      [visited ":visited"]]]
    
    [Specific
     [[after "::after"]
      [before "::before"]
      [first_letter "::first-letter"]
      [first_line "::first-line"]
      [placeholder "::placeholder"]
      [selection "::selection"]]]
    )

  (def: .public (language locale)
    (-> Locale (Selector Can_Chain))
    (|> locale
        locale.code
        (text.enclosed ["(" ")"])
        (format ":lang")
        :abstraction))

  (def: .public not
    (-> (Selector Any) (Selector Can_Chain))
    (|>> :representation
         (text.enclosed ["(" ")"])
         (format ":not")
         :abstraction))

  (abstract: .public Index
    {}
    
    Text

    (def: .public index
      (-> Nat Index)
      (|>> %.nat :abstraction))

    (template [<name> <index>]
      [(def: .public <name> Index (:abstraction <index>))]
      
      [odd "odd"]
      [even "even"]
      )

    (type: .public Formula
      (Record
       [#constant Int
        #variable Int]))

    (def: .public (formula input)
      (-> Formula Index)
      (let [(^slots [#constant #variable]) input]
        (:abstraction (format (if (i.< +0 variable)
                                (%.int variable)
                                (%.nat (.nat variable)))
                              (%.int constant)))))
    
    (template [<name> <pseudo>]
      [(def: .public (<name> index)
         (-> Index (Selector Can_Chain))
         (|> (:representation index)
             (text.enclosed ["(" ")"])
             (format <pseudo>)
             (:abstraction Selector)))]

      [nth_child ":nth-child"]
      [nth_last_child ":nth-last-child"]
      [nth_last_of_type ":nth-last-of-type"]
      [nth_of_type ":nth-of-type"]
      )
    )
  )
