(.using
 [library
  [lux {"-" list nat int rev type symbol}
   [abstract
    [monad {"+" do}]
    [functor
     ["[0]" contravariant]]]
   [control
    ["<>" parser
     ["<[0]>" code {"+" Parser}]]]
   [data
    ["[0]" bit]
    ["[0]" text]
    [format
     ["[0]" xml]
     ["[0]" json]]
    [collection
     ["[0]" list ("[1]#[0]" monad)]]]
   ["[0]" time
    ["[0]" instant]
    ["[0]" duration]
    ["[0]" date]
    ["[0]" day]
    ["[0]" month]]
   [math
    ["[0]" modular]
    [number
     ["[0]" nat]
     ["[0]" int]
     ["[0]" rev]
     ["[0]" frac]
     ["[0]" ratio]]]
   [macro
    [syntax {"+" syntax:}]
    ["[0]" code]
    ["[0]" template]]
   [meta
    ["[0]" location]
    ["[0]" symbol]]
   ["[0]" type]]])

(type: .public (Format a)
  (-> a Text))

(implementation: .public functor
  (contravariant.Functor Format)
  
  (def: (each f fb)
    (|>> f fb)))

(syntax: .public (format [fragments (<>.many <code>.any)])
  (in (.list (` (all "lux text concat" (~+ fragments))))))

(template [<name> <type> <formatter>]
  [(def: .public <name>
     (Format <type>)
     <formatter>)]

  [bit      Bit               (# bit.codec encoded)]
  [nat      Nat               (# nat.decimal encoded)]
  [int      Int               (# int.decimal encoded)]
  [rev      Rev               (# rev.decimal encoded)]
  [frac     Frac              (# frac.decimal encoded)]
  [text     Text              text.format]
  
  [ratio    ratio.Ratio       (# ratio.codec encoded)]
  [symbol   Symbol            (# symbol.codec encoded)]
  [location Location          location.format]
  [code     Code              code.format]
  [type     Type              type.format]
  
  [instant  instant.Instant   (# instant.codec encoded)]
  [duration duration.Duration (# duration.codec encoded)]
  [date     date.Date         (# date.codec encoded)]
  [time     time.Time         (# time.codec encoded)]
  [day      day.Day           (# day.codec encoded)]
  [month    month.Month       (# month.codec encoded)]
  
  [xml      xml.XML           (# xml.codec encoded)]
  [json     json.JSON         (# json.codec encoded)]
  )

(template [<type> <format>,<codec>]
  [(`` (template [<format> <codec>]
         [(def: .public <format>
            (Format <type>)
            (# <codec> encoded))]

         (~~ (template.spliced <format>,<codec>))))]

  [Nat
   [[nat_2 nat.binary]
    [nat_8 nat.octal]
    [nat_10 nat.decimal]
    [nat_16 nat.hex]]]
  [Int
   [[int_2 int.binary]
    [int_8 int.octal]
    [int_10 int.decimal]
    [int_16 int.hex]]]
  [Rev
   [[rev_2 rev.binary]
    [rev_8 rev.octal]
    [rev_10 rev.decimal]
    [rev_16 rev.hex]]]
  [Frac
   [[frac_2 frac.binary]
    [frac_8 frac.octal]
    [frac_10 frac.decimal]
    [frac_16 frac.hex]]]
  )

(def: .public (mod modular)
  (All (_ m) (Format (modular.Mod m)))
  (let [codec (modular.codec (modular.modulus modular))]
    (# codec encoded modular)))

(def: .public (list formatter)
  (All (_ a) (-> (Format a) (Format (List a))))
  (|>> (list#each (|>> formatter (format " ")))
       text.together
       (text.enclosed ["(list" ")"])))

(def: .public (maybe format)
  (All (_ a) (-> (Format a) (Format (Maybe a))))
  (function (_ value)
    (case value
      {.#None}
      "{.#None}"

      {.#Some value}
      (..format "{.#Some " (format value) "}"))))
