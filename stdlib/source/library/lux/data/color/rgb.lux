(.require
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]
    [monoid (.only Monoid)]
    [equivalence (.only Equivalence)]
    ["[0]" hash (.only Hash)]]
   [control
    [function
     [predicate (.only Predicate)]]]
   [data
    ["[0]" product]]
   [math
    [number
     ["n" nat]
     ["i" int]
     ["f" frac]
     ["[0]" i64]]]
   [meta
    [type
     ["[0]" nominal]]]]])

(def .public limit
  Nat
  256)

(type .public Value
  Nat)

(with_template [<name> <value>]
  [(def .public <name>
     Value
     <value>)]

  [least 0]
  [most (-- limit)]
  )

(def .public (value? it)
  (Predicate Nat)
  (not (or (n.< ..least it)
           (n.> ..most it))))

(def .public value
  (-> Nat
      Value)
  (|>> (n.max ..least)
       (n.min ..most)))

(nominal.def .public RGB
  (Record
   [#red Value
    #green Value
    #blue Value])

  (def .public (rgb red green blue)
    (-> Nat Nat Nat
        RGB)
    (nominal.abstraction
     [#red (value red)
      #green (value green)
      #blue (value blue)]))

  (with_template [<name> <slot>]
    [(def .public <name>
       (-> RGB
           Value)
       (|>> nominal.representation
            (the <slot>)))]

    [red #red]
    [green #green]
    [blue #blue]
    )

  (def .public hash
    (Hash RGB)
    (of hash.functor each
        (|>> nominal.representation)
        (all product.hash
             n.hash
             n.hash
             n.hash
             )))

  (def .public equivalence
    (Equivalence RGB)
    (of ..hash equivalence))

  (def (opposite_intensity value)
    (-> Nat
        Nat)
    (|> ..most
        (n.- value)))

  (def .public (complement it)
    (-> RGB
        RGB)
    (nominal.abstraction
     (`` [(,, (with_template [<slot>]
                [<slot> (|> it
                            nominal.representation
                            (the <slot>)
                            opposite_intensity)]

                [#red]
                [#green]
                [#blue]
                ))])))

  (def .public black
    RGB
    (nominal.abstraction
     [#red ..least
      #green ..least
      #blue ..least]))

  (def .public white
    RGB
    (nominal.abstraction
     [#red ..most
      #green ..most
      #blue ..most]))

  (with_template [<monoid> <identity> <composite> <left> <right>]
    [(def .public <monoid>
       (Monoid RGB)
       (implementation
        (def identity
          <identity>)

        (def (composite left right)
          (let [left (<left> left)
                right (<right> right)]
            (nominal.abstraction
             (`` [(,, (with_template [<slot>]
                        [<slot> (<composite> (the <slot> (nominal.representation left))
                                             (the <slot> (nominal.representation right)))]

                        [#red]
                        [#green]
                        [#blue]
                        ))]))))))]

    [addition ..black n.max |> |>]
    [subtraction ..white n.min ..complement |>]
    )
  )

(def (ratio it)
  (-> Frac
      Frac)
  (cond (f.> +1.0 it)
        (f.% +1.0 it)

        (f.< +0.0 it)
        (|> it (f.% +1.0) (f.+ +1.0))

        ... else
        it))

(def .public (interpolated end ratio start)
  (-> RGB Frac RGB
      RGB)
  (let [dS (..ratio ratio)
        dE (|> +1.0 (f.- dS))
        interpolated' (is (-> Nat Nat
                              Nat)
                          (function (_ end start)
                            (|> (|> start .int i.frac (f.* dS))
                                (f.+ (|> end .int i.frac (f.* dE)))
                                f.int
                                .nat)))]
    (..rgb (interpolated' (..red end) (..red start))
           (interpolated' (..green end) (..green start))
           (interpolated' (..blue end) (..blue start)))))

(with_template [<name> <target>]
  [(def .public <name>
     (-> Frac RGB
         RGB)
     (..interpolated <target>))]

  [darker   ..black]
  [brighter ..white]
  )
