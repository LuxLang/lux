(.require
 [library
  [lux (.except)
   [abstract
    [monad (.only do)]
    [monoid (.only Monoid)]
    [equivalence (.only Equivalence)]
    ["[0]" hash (.only Hash)]]
   [control
    [function
     [predicate (.only Predicate)]]]
   [data
    ["[0]" product]]
   [math
    [number
     ["n" nat]
     ["[0]" i64]]]
   [meta
    [type
     ["[0]" nominal]]]]])

(def .public limit
  Nat
  256)

(type .public Value
  Nat)

(with_template [<name> <value>]
  [(def .public <name>
     Value
     <value>)]

  [least 0]
  [most (-- limit)]
  )

(def .public (value? it)
  (Predicate Nat)
  (not (or (n.< ..least it)
           (n.> ..most it))))

(def .public value
  (-> Nat
      Value)
  (|>> (n.max ..least)
       (n.min ..most)))

(nominal.def .public RGB
  (Record
   [#red Value
    #green Value
    #blue Value])

  (def .public (rgb red green blue)
    (-> Nat Nat Nat
        RGB)
    (nominal.abstraction
     [#red (value red)
      #green (value green)
      #blue (value blue)]))

  (with_template [<name> <slot>]
    [(def .public <name>
       (-> RGB
           Value)
       (|>> nominal.representation
            (the <slot>)))]

    [red #red]
    [green #green]
    [blue #blue]
    )

  (def .public hash
    (Hash RGB)
    (of hash.functor each
        (|>> nominal.representation)
        (all product.hash
             n.hash
             n.hash
             n.hash
             )))

  (def .public equivalence
    (Equivalence RGB)
    (of ..hash equivalence))

  (def (opposite_intensity value)
    (-> Nat
        Nat)
    (|> ..most
        (n.- value)))

  (def .public (complement it)
    (-> RGB
        RGB)
    (nominal.abstraction
     (`` [(,, (with_template [<slot>]
                [<slot> (|> it
                            nominal.representation
                            (the <slot>)
                            opposite_intensity)]

                [#red]
                [#green]
                [#blue]
                ))])))

  (def .public black
    RGB
    (nominal.abstraction
     [#red ..least
      #green ..least
      #blue ..least]))

  (def .public white
    RGB
    (nominal.abstraction
     [#red ..most
      #green ..most
      #blue ..most]))

  (with_template [<monoid> <identity> <composite> <left> <right>]
    [(def .public <monoid>
       (Monoid RGB)
       (implementation
        (def identity
          <identity>)

        (def (composite left right)
          (let [left (<left> left)
                right (<right> right)]
            (nominal.abstraction
             (`` [(,, (with_template [<slot>]
                        [<slot> (<composite> (the <slot> (nominal.representation left))
                                             (the <slot> (nominal.representation right)))]

                        [#red]
                        [#green]
                        [#blue]
                        ))]))))))]

    [addition ..black n.max |> |>]
    [subtraction ..white n.min ..complement |>]
    )
  )
