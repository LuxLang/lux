(.module:
  [library
   [lux #*
    [abstract
     [functor (#+ Functor)]
     [apply (#+ Apply)]
     [monad (#+ Monad do)]
     [equivalence (#+ Equivalence)]]
    [control
     ["." io]
     [parser
      ["s" code]]
     [concurrency
      ["." atom]]]
    [macro (#+ with_gensyms)
     [syntax (#+ syntax:)]]
    [type
     abstract]]])

(abstract: #export (Lazy a)
  (-> [] a)

  {#.doc (doc "A value specified by an expression that is calculated only at the last moment possible."
              "Afterwards, the value is cached for future reference.")}

  (def: (lazy' generator)
    (All [a] (-> (-> [] a) (Lazy a)))
    (let [cache (atom.atom #.None)]
      (:abstraction (function (_ _)
                      (case (io.run (atom.read cache))
                        (#.Some value)
                        value

                        _
                        (let [value (generator [])]
                          (exec (io.run (atom.compare_and_swap _ (#.Some value) cache))
                            value)))))))

  (def: #export (value lazy)
    (All [a] (-> (Lazy a) a))
    ((:representation lazy) [])))

(syntax: #export (lazy expression)
  {#.doc (doc "Specifies a lazy value by providing the expression that computes it.")}
  (with_gensyms [g!_]
    (in (list (` ((~! lazy') (function ((~ g!_) (~ g!_)) (~ expression))))))))

(implementation: #export (equivalence (^open "\."))
  (All [a] (-> (Equivalence a) (Equivalence (Lazy a))))
  
  (def: (= left right)
    (\= (..value left)
        (..value right))))

(implementation: #export functor
  (Functor Lazy)
  
  (def: (map f fa)
    (lazy (f (value fa)))))

(implementation: #export apply
  (Apply Lazy)
  
  (def: &functor ..functor)
  (def: (apply ff fa)
    (lazy ((value ff) (value fa)))))

(implementation: #export monad
  (Monad Lazy)
  
  (def: &functor ..functor)
  (def: in (|>> lazy))
  (def: join value))
