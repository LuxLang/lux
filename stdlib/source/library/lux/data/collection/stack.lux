(.using
  [library
   [lux "*"
    [abstract
     [equivalence {"+" Equivalence}]
     [functor {"+" Functor}]]
    [data
     [collection
      ["//" list]]]
    [type
     abstract]]])

(abstract: .public (Stack a)
  (List a)

  (def: .public empty
    Stack
    (:abstraction (list)))

  (def: .public size
    (All (_ a) (-> (Stack a) Nat))
    (|>> :representation //.size))

  (def: .public empty?
    (All (_ a) (-> (Stack a) Bit))
    (|>> :representation //.empty?))

  (def: .public (value stack)
    (All (_ a) (-> (Stack a) (Maybe a)))
    (case (:representation stack)
      {.#End}
      {.#None}
      
      {.#Item value _}
      {.#Some value}))

  (def: .public (next stack)
    (All (_ a) (-> (Stack a) (Maybe [a (Stack a)])))
    (case (:representation stack)
      {.#End}
      {.#None}
      
      {.#Item top stack'}
      {.#Some [top (:abstraction stack')]}))

  (def: .public (top value stack)
    (All (_ a) (-> a (Stack a) (Stack a)))
    (:abstraction {.#Item value (:representation stack)}))

  (implementation: .public (equivalence super)
    (All (_ a)
      (-> (Equivalence a)
          (Equivalence (Stack a))))

    (def: (= reference subject)
      (# (//.equivalence super) = (:representation reference) (:representation subject))))

  (implementation: .public functor
    (Functor Stack)
    
    (def: (each f value)
      (|> value
          :representation
          (# //.functor each f)
          :abstraction)))
  )
