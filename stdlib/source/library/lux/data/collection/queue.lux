(.module:
  [library
   [lux (#- list)
    [abstract
     [equivalence (#+ Equivalence)]
     [functor (#+ Functor)]]
    [data
     [collection
      ["." list ("#\." monoid functor)]]]
    [math
     [number
      ["n" nat]]]]])

(type: .public (Queue a)
  {#.doc (example "A first-in, first-out sequential data-structure.")}
  {#front (List a)
   #rear (List a)})

(def: .public empty
  Queue
  {#front (.list)
   #rear (.list)})

(def: .public (of_list entries)
  (All [a] (-> (List a) (Queue a)))
  {#front entries
   #rear (.list)})

(def: .public (list queue)
  (All [a] (-> (Queue a) (List a)))
  (let [(^slots [#front #rear]) queue]
    (list\compose front (list.reversed rear))))

(def: .public front
  {#.doc (example "Yields the first value in the queue, if any.")}
  (All [a] (-> (Queue a) (Maybe a)))
  (|>> (value@ #front) list.head))

(def: .public (size queue)
  (All [a] (-> (Queue a) Nat))
  (let [(^slots [#front #rear]) queue]
    (n.+ (list.size front)
         (list.size rear))))

(def: .public empty?
  (All [a] (-> (Queue a) Bit))
  (|>> (value@ #front) list.empty?))

(def: .public (member? equivalence queue member)
  (All [a] (-> (Equivalence a) (Queue a) a Bit))
  (let [(^slots [#front #rear]) queue]
    (or (list.member? equivalence front member)
        (list.member? equivalence rear member))))

(def: .public (next queue)
  (All [a] (-> (Queue a) (Queue a)))
  (case (value@ #front queue)
    ... Empty...
    (^ (.list))
    queue

    ... Front has dried up...
    (^ (.list _))
    (|> queue
        (with@ #front (list.reversed (value@ #rear queue)))
        (with@ #rear (.list)))

    ... Consume front!
    (^ (.list& _ front'))
    (|> queue
        (with@ #front front'))))

(def: .public (end val queue)
  (All [a] (-> a (Queue a) (Queue a)))
  (case (value@ #front queue)
    #.End
    (with@ #front (.list val) queue)

    _
    (revised@ #rear (|>> (#.Item val)) queue)))

(implementation: .public (equivalence super)
  (All [a] (-> (Equivalence a) (Equivalence (Queue a))))
  
  (def: (= reference subject)
    (\ (list.equivalence super) =
       (..list reference)
       (..list subject))))

(implementation: .public functor
  (Functor Queue)
  
  (def: (map f fa)
    {#front (|> fa (value@ #front) (list\map f))
     #rear (|> fa (value@ #rear) (list\map f))}))
