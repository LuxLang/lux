(.module:
  [library
   [lux {"-" [list]}
    [abstract
     [equivalence {"+" [Equivalence]}]
     [functor {"+" [Functor]}]]
    [data
     [collection
      ["[0]" list ("[1]#[0]" monoid functor)]]]
    [math
     [number
      ["n" nat]]]]])

(type: .public (Queue a)
  (Record
   [#front (List a)
    #rear (List a)]))

(def: .public empty
  Queue
  [#front (.list)
   #rear (.list)])

(def: .public (of_list entries)
  (All (_ a) (-> (List a) (Queue a)))
  [#front entries
   #rear (.list)])

(def: .public (list queue)
  (All (_ a) (-> (Queue a) (List a)))
  (let [(^slots [#front #rear]) queue]
    (list#composite #front (list.reversed #rear))))

(def: .public front
  (All (_ a) (-> (Queue a) (Maybe a)))
  (|>> (value@ #front) list.head))

(def: .public (size queue)
  (All (_ a) (-> (Queue a) Nat))
  (let [(^slots [#front #rear]) queue]
    (n.+ (list.size #front)
         (list.size #rear))))

(def: .public empty?
  (All (_ a) (-> (Queue a) Bit))
  (|>> (value@ #front) list.empty?))

(def: .public (member? equivalence queue member)
  (All (_ a) (-> (Equivalence a) (Queue a) a Bit))
  (let [(^slots [#front #rear]) queue]
    (or (list.member? equivalence #front member)
        (list.member? equivalence #rear member))))

(def: .public (next queue)
  (All (_ a) (-> (Queue a) (Queue a)))
  (case (value@ #front queue)
    ... Empty...
    (^ (.list))
    queue

    ... Front has dried up...
    (^ (.list _))
    (|> queue
        (with@ #front (list.reversed (value@ #rear queue)))
        (with@ #rear (.list)))

    ... Consume front!
    (^ (.list& _ front'))
    (|> queue
        (with@ #front front'))))

(def: .public (end val queue)
  (All (_ a) (-> a (Queue a) (Queue a)))
  (case (value@ #front queue)
    {.#End}
    (with@ #front (.list val) queue)

    _
    (revised@ #rear (|>> {.#Item val}) queue)))

(implementation: .public (equivalence super)
  (All (_ a) (-> (Equivalence a) (Equivalence (Queue a))))
  
  (def: (= reference subject)
    (# (list.equivalence super) =
       (..list reference)
       (..list subject))))

(implementation: .public functor
  (Functor Queue)
  
  (def: (each f fa)
    [#front (|> fa (value@ #front) (list#each f))
     #rear (|> fa (value@ #rear) (list#each f))]))
