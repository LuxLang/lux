... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except has stack)
   [abstract
    [equivalence (.only Equivalence)]
    [order (.only Order)]]
   [error
    ["[0]" try (.only Try)]]
   [data
    [collection
     ["[0]" stack (.use "[1]#[0]" mix)]
     [dictionary
      ["/" ordered]]]]
   [macro
    ["[0]" template]]
   [type
    ["[0]" nominal]]
   [meta
    ["[0]" provenance]]]])

(nominal.every .public (Set of)
  (/.Dictionary of of)

  (the .public empty
    (for_any (_ of)
      (-> (Order of)
          (Set of)))
    (|>> /.empty
         nominal.abstraction))

  (the .public (member? set elem)
    (for_any (_ of)
      (-> (Set of) of
          Bit))
    (/.key? (nominal.reification set) elem))

  (the .public it_is_empty
    Error
    (provenance.with (provenance.here)
      "Empty."))

  (template.with [<name> <alias>]
    [(the .public <name>
       (for_any (_ of)
         (-> (Set of)
             (Try of)))
       (|>> nominal.reification
            <alias>
            (try.as it_is_empty)))]

    [minor /.minor]
    [major /.major]
    )

  (template.with [<type> <name> <alias>]
    [(the .public <name>
       (for_any (_ of)
         (-> (Set of)
             <type>))
       (|>> nominal.reification
            <alias>))]

    [Natural size  /.size]
    [Bit empty? /.empty?]
    )

  (the .public (has elem set)
    (for_any (_ of)
      (-> of (Set of)
          (Set of)))
    (|> set
        nominal.reification
        (/.has elem elem)
        nominal.abstraction))

  (the .public (lacks elem set)
    (for_any (_ of)
      (-> of (Set of)
          (Set of)))
    (|> set
        nominal.reification
        (/.lacks elem)
        nominal.abstraction))

  (the .public stack
    (for_any (_ of)
      (-> (Set of)
          (Stack of)))
    (|>> nominal.reification
         /.keys))

  (the .public (of_stack order stack)
    (for_any (_ of)
      (-> (Order of) (Stack of)
          (Set of)))
    (stack#mix has (..empty order) stack))

  (the .public (union left right)
    (for_any (_ of)
      (-> (Set of) (Set of)
          (Set of)))
    (stack#mix ..has right (..stack left)))

  (the .public (intersection left right)
    (for_any (_ of)
      (-> (Set of) (Set of)
          (Set of)))
    (|> (..stack right)
        (stack.only (..member? left))
        (..of_stack (its /.#order (nominal.reification right)))))

  (the .public (difference param subject)
    (for_any (_ of)
      (-> (Set of) (Set of)
          (Set of)))
    (|> (..stack subject)
        (stack.only (|>> (..member? param) not))
        (..of_stack (its /.#order (nominal.reification subject)))))

  (the .public equivalence
    (for_any (_ of)
      (Equivalence (Set of)))
    (implementation
     (the (= expected actual)
       (by (stack.equivalence (by (nominal.reification expected) equivalence))
           = (..stack expected) (..stack actual)))))
  )

(the .public (sub? super sub)
  (for_any (_ of)
    (-> (Set of) (Set of)
        Bit))
  (|> sub
      ..stack
      (stack.every? (..member? super))))

(the .public (super? sub super)
  (for_any (_ of)
    (-> (Set of) (Set of)
        Bit))
  (sub? super sub))
