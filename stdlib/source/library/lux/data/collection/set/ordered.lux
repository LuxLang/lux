... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except has list)
   [abstract
    [equivalence (.only Equivalence)]
    [order (.only Order)]]
   [data
    [collection
     ["[0]" list (.use "[1]#[0]" mix)]
     [dictionary
      ["/" ordered]]]]
   [meta
    [type
     ["[0]" nominal]]]]])

(nominal.every .public (Set a)
  (/.Dictionary a a)

  (the .public empty
    (All (_ a) (-> (Order a) (Set a)))
    (|>> /.empty
         nominal.abstraction))

  (the .public (member? set elem)
    (All (_ a) (-> (Set a) a Bit))
    (/.key? (nominal.representation set) elem))

  (with_template [<type> <name> <alias>]
    [(the .public <name>
       (All (_ a) (-> (Set a) <type>))
       (|>> nominal.representation <alias>))]

    [(Maybe a) min /.min]
    [(Maybe a) max /.max]
    [Nat size  /.size]
    [Bit empty? /.empty?]
    )

  (the .public (has elem set)
    (All (_ a) (-> a (Set a) (Set a)))
    (|> set
        nominal.representation
        (/.has elem elem)
        nominal.abstraction))

  (the .public (lacks elem set)
    (All (_ a) (-> a (Set a) (Set a)))
    (|> set
        nominal.representation
        (/.lacks elem)
        nominal.abstraction))

  (the .public list
    (All (_ a) (-> (Set a) (List a)))
    (|>> nominal.representation
         /.keys))

  (the .public (of_list order list)
    (All (_ a) (-> (Order a) (List a) (Set a)))
    (list#mix has (..empty order) list))

  (the .public (union left right)
    (All (_ a) (-> (Set a) (Set a) (Set a)))
    (list#mix ..has right (..list left)))

  (the .public (intersection left right)
    (All (_ a) (-> (Set a) (Set a) (Set a)))
    (|> (..list right)
        (list.only (..member? left))
        (..of_list (its /.#order (nominal.representation right)))))

  (the .public (difference param subject)
    (All (_ a) (-> (Set a) (Set a) (Set a)))
    (|> (..list subject)
        (list.only (|>> (..member? param) not))
        (..of_list (its /.#order (nominal.representation subject)))))

  (the .public equivalence
    (All (_ a) (Equivalence (Set a)))
    (implementation
     (the (= reference sample)
       (of (list.equivalence (of (nominal.representation reference) equivalence))
           = (..list reference) (..list sample)))))
  )

(the .public (sub? super sub)
  (All (_ a) (-> (Set a) (Set a) Bit))
  (|> sub
      ..list
      (list.every? (..member? super))))

(the .public (super? sub super)
  (All (_ a) (-> (Set a) (Set a) Bit))
  (sub? super sub))
