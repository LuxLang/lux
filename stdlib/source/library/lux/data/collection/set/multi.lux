... https://en.wikipedia.org/wiki/Multiset
(.module:
  [library
   [lux (#- list)
    [abstract
     [equivalence (#+ Equivalence)]
     [hash (#+ Hash)]]
    [control
     ["." function]
     ["." maybe]]
    [math
     [number
      ["n" nat]]]
    [type
     [abstract (#+ abstract: :abstraction :representation ^:representation)]]]]
  ["." //
   [//
    ["." list ("#\." fold monoid)]
    ["." dictionary (#+ Dictionary)]]])

(abstract: .public (Set a)
  {#.doc (example "A set that keeps track of repetition in its entries.")}

  (Dictionary a Nat)

  (def: .public empty
    (All [a] (-> (Hash a) (Set a)))
    (|>> dictionary.empty :abstraction))

  (def: .public size
    (All [a] (-> (Set a) Nat))
    (|>> :representation dictionary.values (list\fold n.+ 0)))

  (def: .public (add multiplicity elem set)
    (All [a] (-> Nat a (Set a) (Set a)))
    (case multiplicity
      0 set
      _ (|> set
            :representation
            (dictionary.upsert elem 0 (n.+ multiplicity))
            :abstraction)))

  (def: .public (remove multiplicity elem set)
    (All [a] (-> Nat a (Set a) (Set a)))
    (case multiplicity
      0 set
      _ (case (dictionary.get elem (:representation set))
          (#.Some current)
          (:abstraction
           (if (n.> multiplicity current)
             (dictionary.update elem (n.- multiplicity) (:representation set))
             (dictionary.remove elem (:representation set))))
          
          #.None
          set)))

  (def: .public (multiplicity set elem)
    (All [a] (-> (Set a) a Nat))
    (|> set :representation (dictionary.get elem) (maybe.else 0)))

  (def: .public list
    (All [a] (-> (Set a) (List a)))
    (|>> :representation
         dictionary.entries
         (list\fold (function (_ [elem multiplicity] output)
                      (list\compose (list.repeated multiplicity elem) output))
                    #.End)))

  (template [<name> <compose>]
    [(def: .public (<name> parameter subject)
       (All [a] (-> (Set a) (Set a) (Set a)))
       (:abstraction (dictionary.merged_with <compose> (:representation parameter) (:representation subject))))]

    [union n.max]
    [sum n.+]
    )

  (def: .public (intersection parameter (^:representation subject))
    (All [a] (-> (Set a) (Set a) (Set a)))
    (list\fold (function (_ [elem multiplicity] output)
                 (..add (n.min (..multiplicity parameter elem)
                               multiplicity)
                        elem
                        output))
               (..empty (dictionary.key_hash subject))
               (dictionary.entries subject)))

  (def: .public (difference parameter subject)
    (All [a] (-> (Set a) (Set a) (Set a)))
    (|> parameter
        :representation
        dictionary.entries
        (list\fold (function (_ [elem multiplicity] output)
                     (..remove multiplicity elem output))
                   subject)))

  (def: .public (sub? reference subject)
    {#.doc (example "Is 'subject' a sub-set of 'reference'?")}
    (All [a] (-> (Set a) (Set a) Bit))
    (|> subject
        :representation
        dictionary.entries
        (list.every? (function (_ [elem multiplicity])
                       (|> elem
                           (..multiplicity reference)
                           (n.>= multiplicity))))))

  (def: .public (support set)
    {#.doc (example "A set of the unique (non repeated) members.")}
    (All [a] (-> (Set a) (//.Set a)))
    (let [(^@ set [hash _]) (:representation set)]
      (|> set
          dictionary.keys
          (//.of_list hash))))

  (implementation: .public equivalence
    (All [a] (Equivalence (Set a)))
    
    (def: (= (^:representation reference) sample)
      (and (n.= (dictionary.size reference)
                (dictionary.size (:representation sample)))
           (|> reference
               dictionary.entries
               (list.every? (function (_ [elem multiplicity])
                              (|> elem
                                  (..multiplicity sample)
                                  (n.= multiplicity))))))))

  (implementation: .public hash
    (All [a] (Hash (Set a)))
    
    (def: &equivalence ..equivalence)
    
    (def: (hash (^:representation set))
      (let [[hash _] set]
        (list\fold (function (_ [elem multiplicity] acc)
                     (|> elem (\ hash hash) (n.* multiplicity) (n.+ acc)))
                   0
                   (dictionary.entries set)))))
  )

(def: .public (member? set elem)
  (All [a] (-> (Set a) a Bit))
  (|> elem (..multiplicity set) (n.> 0)))

(def: .public empty?
  (All [a] (-> (Set a) Bit))
  (|>> ..size (n.= 0)))

(def: .public (of_list hash subject)
  (All [a] (-> (Hash a) (List a) (Set a)))
  (list\fold (..add 1) (..empty hash) subject))

(def: .public (of_set subject)
  (All [a] (-> (//.Set a) (Set a)))
  (..of_list (//.member_hash subject)
             (//.list subject)))

(def: .public super?
  {#.doc (example "Is 'subject' a super-set of 'reference'?")}
  (All [a] (-> (Set a) (Set a) Bit))
  (function.flip sub?))
