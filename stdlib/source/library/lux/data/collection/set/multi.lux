... https://en.wikipedia.org/wiki/Multiset
(.module:
  [library
   [lux (#- list)
    [abstract
     [equivalence (#+ Equivalence)]
     [hash (#+ Hash)]]
    [control
     ["." function]
     ["." maybe]]
    [math
     [number
      ["n" nat]]]
    [type
     [abstract (#+ abstract: :abstraction :representation ^:representation)]]]]
  ["." //
   [//
    ["." list ("#\." mix monoid)]
    ["." dictionary (#+ Dictionary)]]])

(abstract: .public (Set a)
  {}

  (Dictionary a Nat)

  (def: .public empty
    (All [a] (-> (Hash a) (Set a)))
    (|>> dictionary.empty :abstraction))

  (def: .public size
    (All [a] (-> (Set a) Nat))
    (|>> :representation dictionary.values (list\mix n.+ 0)))

  (def: .public (has multiplicity elem set)
    (All [a] (-> Nat a (Set a) (Set a)))
    (case multiplicity
      0 set
      _ (|> set
            :representation
            (dictionary.revised' elem 0 (n.+ multiplicity))
            :abstraction)))

  (def: .public (lacks multiplicity elem set)
    (All [a] (-> Nat a (Set a) (Set a)))
    (case multiplicity
      0 set
      _ (case (dictionary.value elem (:representation set))
          (#.Some current)
          (:abstraction
           (if (n.> multiplicity current)
             (dictionary.revised elem (n.- multiplicity) (:representation set))
             (dictionary.lacks elem (:representation set))))
          
          #.None
          set)))

  (def: .public (multiplicity set elem)
    (All [a] (-> (Set a) a Nat))
    (|> set :representation (dictionary.value elem) (maybe.else 0)))

  (def: .public list
    (All [a] (-> (Set a) (List a)))
    (|>> :representation
         dictionary.entries
         (list\mix (function (_ [elem multiplicity] output)
                     (list\composite (list.repeated multiplicity elem) output))
                   #.End)))

  (template [<name> <composite>]
    [(def: .public (<name> parameter subject)
       (All [a] (-> (Set a) (Set a) (Set a)))
       (:abstraction (dictionary.merged_with <composite> (:representation parameter) (:representation subject))))]

    [union n.max]
    [sum n.+]
    )

  (def: .public (intersection parameter (^:representation subject))
    (All [a] (-> (Set a) (Set a) (Set a)))
    (list\mix (function (_ [elem multiplicity] output)
                (..has (n.min (..multiplicity parameter elem)
                              multiplicity)
                       elem
                       output))
              (..empty (dictionary.key_hash subject))
              (dictionary.entries subject)))

  (def: .public (difference parameter subject)
    (All [a] (-> (Set a) (Set a) (Set a)))
    (|> parameter
        :representation
        dictionary.entries
        (list\mix (function (_ [elem multiplicity] output)
                    (..lacks multiplicity elem output))
                  subject)))

  (def: .public (sub? reference subject)
    (All [a] (-> (Set a) (Set a) Bit))
    (|> subject
        :representation
        dictionary.entries
        (list.every? (function (_ [elem multiplicity])
                       (|> elem
                           (..multiplicity reference)
                           (n.>= multiplicity))))))

  (def: .public (support set)
    (All [a] (-> (Set a) (//.Set a)))
    (let [(^@ set [hash _]) (:representation set)]
      (|> set
          dictionary.keys
          (//.of_list hash))))

  (implementation: .public equivalence
    (All [a] (Equivalence (Set a)))
    
    (def: (= (^:representation reference) sample)
      (and (n.= (dictionary.size reference)
                (dictionary.size (:representation sample)))
           (|> reference
               dictionary.entries
               (list.every? (function (_ [elem multiplicity])
                              (|> elem
                                  (..multiplicity sample)
                                  (n.= multiplicity))))))))

  (implementation: .public hash
    (All [a] (Hash (Set a)))
    
    (def: &equivalence ..equivalence)
    
    (def: (hash (^:representation set))
      (let [[hash _] set]
        (list\mix (function (_ [elem multiplicity] acc)
                    (|> elem (\ hash hash) (n.* multiplicity) (n.+ acc)))
                  0
                  (dictionary.entries set)))))
  )

(def: .public (member? set elem)
  (All [a] (-> (Set a) a Bit))
  (|> elem (..multiplicity set) (n.> 0)))

(def: .public empty?
  (All [a] (-> (Set a) Bit))
  (|>> ..size (n.= 0)))

(def: .public (of_list hash subject)
  (All [a] (-> (Hash a) (List a) (Set a)))
  (list\mix (..has 1) (..empty hash) subject))

(def: .public (of_set subject)
  (All [a] (-> (//.Set a) (Set a)))
  (..of_list (//.member_hash subject)
             (//.list subject)))

(def: .public super?
  (All [a] (-> (Set a) (Set a) Bit))
  (function.flipped sub?))
