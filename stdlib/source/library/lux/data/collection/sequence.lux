... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

... https://hypirion.com/musings/understanding-persistent-vector-pt-1
... https://hypirion.com/musings/understanding-persistent-vector-pt-2
... https://hypirion.com/musings/understanding-persistent-vector-pt-3
(.using
 [library
  [lux (.except has revised only all)
   [abstract
    [functor (.only Functor)]
    [monad (.only Monad do)]
    [equivalence (.only Equivalence)]
    [monoid (.only Monoid)]
    ["<>" projection]]
   [control
    ["[0]" maybe (.use "[1]#[0]" functor)]]
   [error
    ["[0]" try (.only Try)]
    ["[0]" exception (.only Exception)]]
   [function
    [predicate (.only Predicate)]
    [polytypism
     [mix (.only Mix)]]]
   [data
    ["[0]" product]
    [collection
     ["[0]" list (.use "[1]#[0]" mix functor monoid)]
     ["[0]" stack (.use "[1]#[0]" mix functor monoid)]
     ["[0]" array
      ["[1]" \\unsafe (.only Array)]]]]
   [math
    ["[0]" random (.only Random) (.use "[1]#[0]" monad)]
    [number
     ["n" natural]
     ["[0]" i64]]]
   [macro
    ["^" pattern]
    ["[0]" syntax]
    ["[0]" expansion]
    ["[0]" template]]
   [meta
    ["[0]" code (.only)
     ["<[1]>" \\projection]]]]])

(every Base
  Array)

(every (Node it)
  (Variant
   {#Base (Base it)}
   {#Hierarchy (Array (Node it))}))

(every (Hierarchy it)
  (Array (Node it)))

(every Level
  Natural)

(every Index
  Natural)

(the branching_exponent
  Natural
  5)

(the root_level
  Level
  0)

(template.with [<name> <op>]
  [(the <name>
     (-> Level
         Level)
     (<op> branching_exponent))]

  [level_up   n.+]
  [level_down n.-]
  )

(the full_node_size
  Natural
  (i64.left_shifted branching_exponent 1))

(the branch_idx_mask
  Natural
  (-- full_node_size))

(the branch_idx
  (-> Index
      Index)
  (i64.and branch_idx_mask))

(the (empty_hierarchy _)
  (for_any (_ it)
    (-> Any
        (Hierarchy it)))
  (array.empty ..full_node_size))

(the (tail_off sequence_size)
  (-> Natural
      Natural)
  (if (n.< full_node_size sequence_size)
    0
    (|> (-- sequence_size)
        (i64.right_shifted branching_exponent)
        (i64.left_shifted branching_exponent))))

(the (path level tail)
  (for_any (_ it)
    (-> Level (Base it)
        (Node it)))
  (if (n.= 0 level)
    {#Base tail}
    (|> (empty_hierarchy [])
        (array.has! 0 (path (level_down level) tail))
        {#Hierarchy})))

(the (tail singleton)
  (for_any (_ it)
    (-> it
        (Base it)))
  (|> (array.empty 1)
      (array.has! 0 singleton)))

(the (with_tail size level tail parent)
  (for_any (_ it)
    (-> Natural Level (Base it) (Hierarchy it)
        (Hierarchy it)))
  (let [sub_idx (branch_idx (i64.right_shifted level (-- size)))
        ... If we're currently on a bottom node
        sub_node (if (n.= branching_exponent level)
                   ... Just add the tail to it
                   {#Base tail}
                   ... Otherwise, check whether there's a vacant spot
                   (if (array.lacks? sub_idx parent)
                     ... If so, set the path to the tail
                     (..path (level_down level) tail)
                     (when (array.item sub_idx parent)
                       ... If not, push the tail onto the sub_node.
                       {#Hierarchy sub_node}
                       {#Hierarchy (with_tail size (level_down level) tail sub_node)}

                       _
                       (undefined))))]
    (|> (array.clone parent)
        (array.has! sub_idx sub_node))))

(the (expanded_tail val tail)
  (for_any (_ it)
    (-> it (Base it)
        (Base it)))
  (let [tail_size (array.size tail)]
    (|> (array.empty (++ tail_size))
        (array.copy! tail_size 0 tail 0)
        (array.has! tail_size val))))

(the (hierarchy#has level idx val hierarchy)
  (for_any (_ it)
    (-> Level Index it (Hierarchy it)
        (Hierarchy it)))
  (let [sub_idx (branch_idx (i64.right_shifted level idx))]
    (when (array.item sub_idx hierarchy)
      {#Hierarchy sub_node}
      (|> (array.clone hierarchy)
          (array.has! sub_idx {#Hierarchy (hierarchy#has (level_down level) idx val sub_node)}))

      (^.multi {#Base base}
               (n.= 0 (level_down level)))
      (|> (array.clone hierarchy)
          (array.has! sub_idx (|> (array.clone base)
                                  (array.has! (branch_idx idx) val)
                                  {#Base})))

      _
      (undefined))))

(the (without_tail size level hierarchy)
  (for_any (_ it)
    (-> Natural Level (Hierarchy it)
        (Maybe (Hierarchy it))))
  (let [sub_idx (branch_idx (i64.right_shifted level (n.- 2 size)))]
    (if (n.= 0 sub_idx)
      {.#None}

      (n.> branching_exponent level)
      (if (array.lacks? sub_idx hierarchy)
        {.#None}
        (maybe#each (function (_ sub)
                      (|> (array.clone hierarchy)
                          (array.has! sub_idx {#Hierarchy sub})))
                    (when (array.item sub_idx hierarchy)
                      {#Hierarchy sub}
                      (without_tail size (level_down level) sub)

                      {#Base _}
                      (undefined))))

      ... Else...
      (|> (array.clone hierarchy)
          (array.lacks! sub_idx)
          {.#Some})
      )))

(the (node#stack node)
  (for_any (_ it)
    (-> (Node it)
        (Stack it)))
  (when node
    {#Base base}
    (array.stack {.#None} base)
    
    {#Hierarchy hierarchy}
    (|> hierarchy
        (array.stack {.#None})
        stack.reversed
        (stack#mix (function (_ sub acc)
                     (stack#composite (node#stack sub) acc))
                   {.#Empty}))))

(every .public (Sequence it)
  (Record
   [#level Level
    #size Natural
    #root (Hierarchy it)
    #tail (Base it)]))

(the .public empty
  Sequence
  [#level (level_up root_level)
   #size 0
   #root (empty_hierarchy [])
   #tail (array.empty 0)])

(the .public size
  (for_any (_ it)
    (-> (Sequence it)
        Natural))
  (its #size))

(the .public (suffix val sequence)
  (for_any (_ it)
    (-> it (Sequence it)
        (Sequence it)))
  ... Check if there is room in the tail.
  (let [sequence_size (its #size sequence)]
    (if (|> sequence_size (n.- (tail_off sequence_size)) (n.< full_node_size))
      ... If so, append to it.
      (|> sequence
          (.revised #size ++)
          (.revised #tail (..expanded_tail val)))
      ... Otherwise, push tail into the tree
      ... --------------------------------------------------------
      ... Will the root experience an overflow with this addition?
      (|> (if (n.> (i64.left_shifted (its #level sequence) 1)
                   (i64.right_shifted branching_exponent sequence_size))
            ... If so, a brand-new root must be established, that is
            ... 1-level taller.
            (|> sequence
                (.has #root (|> (`` (is (Hierarchy (,, (type_of val)))
                                        (empty_hierarchy [])))
                                (array.has! 0 {#Hierarchy (its #root sequence)})
                                (array.has! 1 (..path (its #level sequence) (its #tail sequence)))))
                (.revised #level level_up))
            ... Otherwise, just push the current tail onto the root.
            (|> sequence
                (.revised #root (..with_tail sequence_size (its #level sequence) (its #tail sequence)))))
          ... Finally, update the size of the sequence and grow a new
          ... tail with the new element as it's sole member.
          (.revised #size ++)
          (.has #tail (..tail val)))
      )))

(exception.the incorrect_sequence_structure)

(exception.the .public (index_out_of_bounds [sequence index])
  (for_any (_ it)
    (Exception [(Sequence it) Natural]))
  (exception.report
   (list ["Size" (by n.base_10 as (its #size sequence))]
         ["Index" (by n.base_10 as index)])))

(exception.the base_was_not_found)

(the .public (within_bounds? sequence)
  (for_any (_ it)
    (-> (Sequence it)
        (Predicate Natural)))
  (n.< (its #size sequence)))

(the (base_for idx sequence)
  (for_any (_ it)
    (-> Index (Sequence it)
        (Try (Base it))))
  (if (within_bounds? sequence idx)
    (if (n.< (tail_off (its #size sequence)) idx)
      (loop (again [level (its #level sequence)
                    hierarchy (its #root sequence)])
        (let [index (branch_idx (i64.right_shifted level idx))]
          (if (array.lacks? index hierarchy)
            (exception.except ..base_was_not_found [])
            (when [(n.> branching_exponent level)
                   (array.item index hierarchy)]
              [.true {#Hierarchy sub}]
              (again (level_down level) sub)

              [.false {#Base base}]
              {try.#Success base}

              _
              (exception.except ..incorrect_sequence_structure [])))))
      {try.#Success (its #tail sequence)})
    (exception.except ..index_out_of_bounds [sequence idx])))

(the .public (item idx sequence)
  (for_any (_ it)
    (-> Natural (Sequence it)
        (Try it)))
  (do try.monad
    [base (base_for idx sequence)
     .let [index (branch_idx idx)]]
    (if (array.lacks? index base)
      (exception.except ..incorrect_sequence_structure [])
      {try.#Success (array.item index base)})))

(the .public (has idx val sequence)
  (for_any (_ it)
    (-> Natural it (Sequence it)
        (Try (Sequence it))))
  (let [sequence_size (its #size sequence)]
    (if (within_bounds? sequence idx)
      {try.#Success (if (n.< (tail_off sequence_size) idx)
                      (.revised #root (hierarchy#has (its #level sequence) idx val)
                                sequence)
                      (.revised #tail (`` (is (-> (Base (,, (type_of val)))
                                                  (Base (,, (type_of val))))
                                              (|>> array.clone (array.has! (branch_idx idx) val))))
                                sequence))}
      (exception.except ..index_out_of_bounds [sequence idx]))))

(the .public (revised idx revision it)
  (for_any (_ it)
    (-> Natural (-> it it) (Sequence it)
        (Try (Sequence it))))
  (do try.monad
    [val (..item idx it)]
    (..has idx (revision val) it)))

(the .public (prefix sequence)
  (for_any (_ it)
    (-> (Sequence it)
        (Sequence it)))
  (when (its #size sequence)
    0
    empty

    1
    empty

    sequence_size
    (if (|> sequence_size (n.- (tail_off sequence_size)) (n.> 1))
      (let [old_tail (its #tail sequence)
            new_tail_size (-- (array.size old_tail))]
        (|> sequence
            (.revised #size --)
            (.has #tail (|> (array.empty new_tail_size)
                            (array.copy! new_tail_size 0 old_tail 0)))))
      (maybe.trusted
       (do maybe.monad
         [new_tail (base_for (n.- 2 sequence_size) sequence)
          .let [[level' root'] (let [init_level (its #level sequence)]
                                 (loop (again [level init_level
                                               root (maybe.else (empty_hierarchy [])
                                                                (without_tail sequence_size init_level (its #root sequence)))])
                                   (expansion.let [<else> [level root]]
                                     (if (n.> branching_exponent level)
                                       (if (array.lacks? 1 root)
                                         (when (array.item 0 root)
                                           {#Hierarchy sub_node}
                                           (again (level_down level) sub_node)

                                           ... {#Base _}
                                           ... (undefined)

                                           _
                                           <else>)
                                         <else>)
                                       <else>))))]]
         (in (|> sequence
                 (.revised #size --)
                 (.has #level level')
                 (.has #root root')
                 (.has #tail new_tail))))))
    ))

(the node_mix
  (Mix Node)
  (implementation
   (the (mix $ init xs)
     (when xs
       {#Base base}
       (array.mix (function (_ _ item output) ($ item output))
                  init
                  base)
       
       {#Hierarchy hierarchy}
       (array.mix (function (_ _ node init') (mix $ init' node))
                  init
                  hierarchy)))))

(the .public mix
  (Mix Sequence)
  (implementation
   (the (mix $ init xs)
     (let [(open "[0]") node_mix]
       (mix $
            (mix $
                 init
                 {#Hierarchy (its #root xs)})
            {#Base (its #tail xs)})))))

(the .public (as_array it)
  (for_any (_ it)
    (-> (Sequence it)
        (Array it)))
  (|> it
      (..mix (function (_ value [output index])
               [(array.has! index value output)
                (++ index)])
             [(array.empty (..size it))
              0])
      product.left))

(the .public of_array
  (for_any (_ it)
    (-> (Array it)
        (Sequence it)))
  (|>> (array.mix (function (_ index value it)
                    (..suffix value it))
                  ..empty)))

(the list_abstraction
  (.in_module# (product.left (name list._))
               list.abstraction))
(the .public (as_list it)
  (for_any (_ it)
    (-> (Sequence it)
        (List it)))
  (|> it
      (..mix (function (_ value [output index])
               [(array.has! index value output)
                (++ index)])
             [(array.empty (..size it))
              0])
      product.left
      list_abstraction))

(the .public of_list
  (for_any (_ it)
    (-> (List it)
        (Sequence it)))
  (list#mix ..suffix ..empty))

(the .public (member? equivalence sequence)
  (for_any (_ it)
    (-> (Equivalence it) (Sequence it)
        (Predicate it)))
  (list.member? equivalence (..as_list sequence)))

(the .public empty?
  (for_any (_ it)
    (Predicate (Sequence it)))
  (|>> (its #size)
       (n.= 0)))

(the .public sequence
  (syntax.macro (_ [elems (<>.some <code>.any)])
    (in (list (` (..of_list (list (,* (list.as_stack elems)))))))))

(the (node_equivalence //#=)
  (for_any (_ it)
    (-> (Equivalence it)
        (Equivalence (Node it))))
  (implementation
   (the (= v1 v2)
     (when [v1 v2]
       [{#Base b1} {#Base b2}]
       (array.= //#= b1 b2)
       
       [{#Hierarchy h1} {#Hierarchy h2}]
       (array.= (node_equivalence //#=) h1 h2)

       _
       false))))

(the .public (equivalence //#=)
  (for_any (_ it)
    (-> (Equivalence it)
        (Equivalence (Sequence it))))
  (implementation
   (the (= v1 v2)
     (and (n.= (its #size v1) (its #size v2))
          (let [(open "node#[0]") (node_equivalence //#=)]
            (and (node#= {#Base (its #tail v1)}
                         {#Base (its #tail v2)})
                 (node#= {#Hierarchy (its #root v1)}
                         {#Hierarchy (its #root v2)})))))))

(the .public monoid
  (for_any (_ it)
    (Monoid (Sequence it)))
  (implementation
   (the identity ..empty)
   (the composite (..mix ..suffix))))

(the node_functor
  (Functor Node)
  (implementation
   (the (each $ xs)
     (when xs
       {#Base base}
       {#Base (array.each $ base)}
       
       {#Hierarchy hierarchy}
       {#Hierarchy (array.each (each $) hierarchy)}))))

(the .public functor
  (Functor Sequence)
  (implementation
   (the (each $ xs)
     [#level (its #level xs)
      #size (its #size xs)
      #root (let [ ... TODO: This binding was established to get around a compilation error. Fix and inline!
                  $ (by node_functor each $)]
              (|> xs (its #root) (array.each $)))
      #tail (|> xs (its #tail) (array.each $))])))

(the .public monad
  (Monad Sequence)
  (implementation
   (the functor ..functor)

   (the in
     (|>> sequence))

   (the conjoint
     (let [(open "[0]") ..mix
           (open "[0]") ..monoid]
       (mix (function (_ post pre) (composite pre post)) identity)))))

(the .public reversed
  (for_any (_ it)
    (-> (Sequence it)
        (Sequence it)))
  (|>> ..as_list
       list.reversed
       ..of_list))

(template.with [<name> ,for_array <init> <op>]
  [(the .public <name>
     (for_any (_ it)
       (-> (Predicate it)
           (Predicate (Sequence it))))
     (let [for_node (is (for_any (_ it)
                          (-> (Predicate it)
                              (Predicate (Node it))))
                        (function (for_node predicate node)
                          (when node
                            {#Base base}
                            (,for_array predicate base)

                            {#Hierarchy hierarchy}
                            (,for_array (for_node predicate) hierarchy))))]
       (function (<name> predicate (open "_[0]"))
         (<op> (,for_array (for_node predicate) _#root)
               (,for_array predicate _#tail)))))]

  [every? array.every? #1 and]
  [any?   array.any?   #0 or]
  )

(the .public (only when)
  (for_any (_ it)
    (-> (Predicate it)
        (-> (Sequence it)
            (Sequence it))))
  (..mix (function (_ item output)
           (if (when item)
             (..suffix item output)
             output))
         ..empty))

(the (one|node check items)
  (for_any (_ input output)
    (-> (-> input (Maybe output)) (Node input)
        (Maybe output)))
  (when items
    {#Base items}
    (array.one check items)
    
    {#Hierarchy items}
    (array.one (one|node check) items)))

(exception.the no_one)

(the .public (one check items)
  (for_any (_ input output)
    (-> (-> input (Maybe output)) (Sequence input)
        (Try output)))
  (.all try.or
        (let [... TODO: This binding was established to get around a compilation error. Fix and inline!
              check (..one|node check)]
          (|> items
              (its #root)
              (array.one check)))
        (|> items
            (its #tail)
            (array.one check))
        (exception.except ..no_one [])
        ))

(the .public (all ? it)
  (for_any (_ input output)
    (-> (-> input (Maybe output)) (Sequence input)
        (Sequence output)))
  (..mix (function (_ in out)
           (when (? in)
             {.#Some in}
             (suffix in out)
             
             {.#None}
             out))
         (sequence)
         it))

(the .public (random size value)
  (for_any (_ it)
    (-> Natural (Random it)
        (Random (Sequence it))))
  (when size
    0 (random#in ..empty)
    _ (do random.monad
        [tail value]
        (random#each (..suffix tail)
                     (random (-- size) value)))))
