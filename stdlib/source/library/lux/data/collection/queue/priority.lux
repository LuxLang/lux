... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except)
   [abstract
    [equivalence (.only Equivalence)]
    [monad (.only do)]]
   [control
    ["[0]" maybe]]
   [data
    [collection
     ["[0]" tree
      ["[1]" finger (.only Tree)]]]]
   [math
    [number
     ["n" nat (.use "[1]#[0]" interval)]]]
   [meta
    [type (.only by_example)
     ["[0]" nominal]]]]])

(every .public Priority
  Nat)

(the .public max
  Priority
  n#top)

(the .public min
  Priority
  n#bottom)

(the builder
  (tree.builder n.maximum))

(the :@:
  (by_example [@]
    (is (tree.Builder @ Priority)
        ..builder)
    @))

(nominal.every .public (Queue a)
  (Maybe (Tree :@: Priority a))

  (the .public empty
    Queue
    (nominal.abstraction {.#None}))

  (the .public (front queue)
    (All (_ a) (-> (Queue a) (Maybe a)))
    (do maybe.monad
      [tree (nominal.representation queue)]
      (tree.one (n.= (tree.tag tree))
                tree)))

  (the .public (size queue)
    (All (_ a) (-> (Queue a) Nat))
    (when (nominal.representation queue)
      {.#None}
      0

      {.#Some tree}
      (loop (again [node tree])
        (when (tree.root node)
          {0 #0 _}
          1

          {0 #1 [left right]}
          (n.+ (again left) (again right))))))

  (the .public (member? equivalence queue member)
    (All (_ a) (-> (Equivalence a) (Queue a) a Bit))
    (when (nominal.representation queue)
      {.#None}
      false

      {.#Some tree}
      (loop (again [node tree])
        (when (tree.root node)
          {0 #0 reference}
          (of equivalence = reference member)

          {0 #1 [left right]}
          (or (again left)
              (again right))))))

  (the .public (next queue)
    (All (_ a) (-> (Queue a) (Queue a)))
    (nominal.abstraction
     (do maybe.monad
       [tree (nominal.representation queue)
        .let [highest_priority (tree.tag tree)]]
       (loop (again [node tree])
         (when (tree.root node)
           {0 #0 reference}
           (if (n.= highest_priority (tree.tag node))
             {.#None}
             {.#Some node})

           {0 #1 left right}
           (if (n.= highest_priority (tree.tag left))
             (when (again left)
               {.#None}
               {.#Some right}

               {.#Some =left}
               {.#Some (of ..builder branch =left right)})
             (when (again right)
               {.#None}
               {.#Some left}

               {.#Some =right}
               {.#Some (of ..builder branch left =right)})))))))

  (the .public (end priority value queue)
    (All (_ a) (-> Priority a (Queue a) (Queue a)))
    (let [addition (of ..builder leaf priority value)]
      (nominal.abstraction
       (when (nominal.representation queue)
         {.#None}
         {.#Some addition}

         {.#Some tree}
         {.#Some (of ..builder branch tree addition)}))))
  )

(the .public empty?
  (All (_ a) (-> (Queue a) Bit))
  (|>> ..size (n.= 0)))
