... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    [equivalence (.only Equivalence)]
    [hash (.only Hash)]
    [monoid (.only Monoid)]
    [functor (.only Functor)]
    [monad (.only Monad)]]
   [algorithm
    [mix (.only Mix)]]
   [error
    ["[0]" try (.only Try)]]
   [function
    [predicate (.only Predicate)]]
   [math
    [number
     ["n" natural]]]]]
 [//
  [array
   ["/" \\unsafe]]])

(the with_template' (.in_module# .prelude .with_template))
(the template#macro (.in_module# .prelude .template#macro))

(with_template' [,name ,from ,to]
  [(the ,name
     (template#macro
      (_ ,it)
      [((is (for_any (_ of write)
              (-> ,from
                  ,to))
            (|>> as_expected))
        ,it)]))]

  [reification (.List of) (/.Array' of write)]
  [abstraction (/.Array' of write) (.List of)]
  )

(the .public size
  (for_any (_ of)
    (-> (List of)
        Natural))
  (|>> ..reification
       /.size))

(the .public (equivalence //)
  (for_any (_ of)
    (-> (Equivalence of)
        (Equivalence (List of))))
  (implementation
   (the (= that this)
     (/.= //
          (..reification that)
          (..reification this)))))

(the .public (hash //)
  (for_any (_ of)
    (-> (Hash of)
        (Hash (List of))))
  (implementation
   (the equivalence
     (..equivalence (by // equivalence)))
   
   (the (hash it)
     (/.mix (function (_ index member hash)
              (n.+ (by // hash member) hash))
            0
            (..reification it)))))

(the .public empty
  List
  (..abstraction (/.empty 0)))

(the .public monoid
  (for_any (_ of)
    (Monoid (List of)))
  (implementation
   (the identity ..empty)

   (the (composite left right)
     (<| ..abstraction
         (/.composite (..reification left)
                      (..reification right))))))

(the .public mix
  (Mix (for_any (_ of)
         (List of)))
  (implementation
   (the (mix step init it)
     (/.mix (function (_ index partial total)
              (step partial total))
            init
            (..reification it)))))

(the .public functor
  (Functor List)
  (implementation
   (the (each it input)
     (|> (..reification input)
         (/.each it)
         ..abstraction))))

(the .public monad
  (Monad List)
  (implementation
   (the functor ..functor)

   (the in
     (|>> list))

   (the (conjoint it)
     (/.mix (function (_ index right left)
              (<| ..abstraction
                  (/.composite (..reification left)
                               (..reification right))))
            ..empty
            (..reification it)))))

(the .public of_stack
  (for_any (_ of)
    (-> (Stack of)
        (List of)))
  (|>> /.of_stack ..abstraction))

(the .public (as_stack it)
  (for_any (_ of)
    (-> (List of)
        (Stack of)))
  (/.stack {.#None} (..reification it)))
