... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    [equivalence (.only Equivalence)]
    [hash (.only Hash)]
    [monoid (.only Monoid)]
    [functor (.only Functor)]
    [monad (.only Monad)]]
   [algorithm
    [mix (.only Mix)]]
   [error (.only error)
    ["[0]" try (.only Try)]]
   [function
    [predicate (.only Predicate)]]
   [math
    [number
     ["n" natural]]]]]
 [//
  [array
   ["/" \\unsafe]]])

(the with_template' (.in_module# .prelude .with_template))
(the template#macro (.in_module# .prelude .template#macro))

(with_template' [,name ,from ,to]
  [(the ,name
     (template#macro
      (_ ,it)
      [((is (for_any (_ it write)
              (-> ,from
                  ,to))
            (|>> as_expected))
        ,it)]))]

  [reification (.List it) (/.Array' it write)]
  [abstraction (/.Array' it write) (.List it)]
  )

(the .public size
  (for_any (_ it)
    (-> (List it)
        Natural))
  (|>> ..reification
       /.size))

(the .public empty?
  (for_any (_ it)
    (Predicate (List it)))
  (|>> ..size
       (n.= 0)))

(the .public (equivalence //)
  (for_any (_ it)
    (-> (Equivalence it)
        (Equivalence (List it))))
  (implementation
   (the (= that this)
     (/.= //
          (..reification that)
          (..reification this)))))

(the .public (hash //)
  (for_any (_ it)
    (-> (Hash it)
        (Hash (List it))))
  (implementation
   (the equivalence
     (..equivalence (by // equivalence)))
   
   (the (hash it)
     (/.mix (function (_ index member hash)
              (n.+ (by // hash member) hash))
            0
            (..reification it)))))

(the .public empty
  List
  (..abstraction (/.empty 0)))

(the .public monoid
  (for_any (_ it)
    (Monoid (List it)))
  (implementation
   (the identity ..empty)

   (the (composite left right)
     (<| ..abstraction
         (/.composite (..reification left)
                      (..reification right))))))

(the .public mix
  (Mix List)
  (implementation
   (the (mix step init it)
     (/.mix (function (_ index partial total)
              (step partial total))
            init
            (..reification it)))))

(the .public functor
  (Functor List)
  (implementation
   (the (each it input)
     (|> (..reification input)
         (/.each it)
         ..abstraction))))

(the .public monad
  (Monad List)
  (implementation
   (the functor ..functor)

   (the in
     (|>> list))

   (the (conjoint it)
     (/.mix (function (_ index right left)
              (<| ..abstraction
                  (/.composite (..reification left)
                               (..reification right))))
            ..empty
            (..reification it)))))

(the .public (enumeration it)
  (for_any (_ it)
    (-> (List it)
        (List [Natural it])))
  (..abstraction
   (let [it (..reification it)]
     (/.mix (function (_ index value it)
              (/.has! index [index value] it))
            (/.empty (/.size it))
            it))))

(the .public of_stack
  (for_any (_ it)
    (-> (Stack it)
        (List it)))
  (|>> /.of_stack
       ..abstraction))

(the .public as_stack
  (for_any (_ it)
    (-> (List it)
        (Stack it)))
  (|>> ..reification
       (/.stack {.#None})))

(the .public not_valid
  (..error "Not valid."))

(the .public (item position it)
  (for_any (_ it)
    (-> Natural (List it)
        (Try it)))
  (let [it (..reification it)]
    (if (n.< (/.size it) position)
      {try.#Success (/.item position it)}
      {try.#Failure ..not_valid})))

(the .public (first amount it)
  (for_any (_ it)
    (-> Natural (List it)
        (List it)))
  (..abstraction
   (let [it (..reification it)
         amount (n.minor amount (/.size it))]
     (|> (/.empty amount)
         (/.copy! amount 0 it 0)))))

(the .public (after amount it)
  (for_any (_ it)
    (-> Natural (List it)
        (List it)))
  (let [it (..reification it)]
    (if (n.< (/.size it) amount)
      (let [size (n.- amount (/.size it))]
        (|> (/.empty size)
            (/.copy! size amount it 0)
            ..abstraction))
      ..empty)))

(the .public (reversed it)
  (for_any (_ it)
    (-> (List it)
        (List it)))
  (..abstraction
   (let [it (..reification it)
         size (/.size it)
         last (-- size)]
     (/.mix (function (_ index value it)
              (/.has! (n.- index last) value it))
            (/.empty size)
            it))))

(the .public (indices limit)
  (for_any (_ it)
    (-> Natural
        (List Natural)))
  (..abstraction
   (let [it (/.empty limit)]
     (loop (next [index 0])
       (if (n.< limit index)
         (exec
           (/.has! index index it)
           (next (++ index)))
         it)))))
