(.module:
  [library
   [lux "*"
    ["@" target]
    [abstract
     [functor {"+" [Functor]}]
     [comonad {"+" [CoMonad]}]
     [monad {"+" [do]}]
     [equivalence {"+" [Equivalence]}]]
    [control
     ["[0]" maybe ("[1]\[0]" monad)]]
    [data
     ["[0]" product]
     [text
      ["%" format {"+" [format]}]]
     [collection
      ["[0]" list ("[1]\[0]" functor monoid)]]]]]
  ["[0]" // {"+" [Tree]} ("[1]\[0]" functor)])

(type: (Family Zipper a)
  (Record
   [#parent (Zipper a)
    #lefts (List (Tree a))
    #rights (List (Tree a))]))

... https://en.wikipedia.org/wiki/Zipper_(data_structure)
(type: .public (Zipper a)
  (Record
   [#family (Maybe (Family Zipper a))
    #node (Tree a)]))

(implementation: .public (equivalence super)
  (All (_ a)
    (-> (Equivalence a)
        (Equivalence (Zipper a))))
  
  (def: (= reference sample)
    (let [== ($_ product.equivalence
                 (maybe.equivalence
                  ($_ product.equivalence
                      =
                      (list.equivalence (//.equivalence super))
                      (list.equivalence (//.equivalence super))))
                 (//.equivalence super))]
      (== reference sample))))

(def: .public (zipper tree)
  (All (_ a) (-> (Tree a) (Zipper a)))
  [#family #.None
   #node tree])

(def: .public tree
  (All (_ a) (-> (Zipper a) (Tree a)))
  (value@ #node))

(def: .public value
  (All (_ a) (-> (Zipper a) a))
  (value@ [#node #//.value]))

(def: .public (set value zipper)
  (All (_ a) (-> a (Zipper a) (Zipper a)))
  (with@ [#node #//.value] value zipper))

(def: .public (update transform zipper)
  (All (_ a) (-> (-> a a) (Zipper a) (Zipper a)))
  (revised@ [#node #//.value] transform zipper))

(def: children
  (All (_ a) (-> (Zipper a) (List (Tree a))))
  (value@ [#node #//.children]))

(def: .public leaf?
  (All (_ a) (-> (Zipper a) Bit))
  (|>> ..children list.empty?))

(def: .public branch?
  (All (_ a) (-> (Zipper a) Bit))
  (|>> ..leaf? not))

(def: .public (start? zipper)
  (All (_ a) (-> (Zipper a) Bit))
  (case (value@ #family zipper)
    #.None
    true

    _
    false))

(def: .public (down zipper)
  (All (_ a) (-> (Zipper a) (Maybe (Zipper a))))
  (case (..children zipper)
    #.End
    #.None

    (#.Item head tail)
    (#.Some [#family (#.Some [#parent (with@ [#node #//.children] (list) zipper)
                              #lefts #.End
                              #rights tail])
             #node head])))

(def: .public (up zipper)
  (All (_ a) (-> (Zipper a) (Maybe (Zipper a))))
  (do maybe.monad
    [family (value@ #family zipper)]
    (in (let [(^slots [#parent #lefts #rights]) family]
          (for [@.old
                (revised@ #node (: (-> (Tree (:parameter 0))
                                       (Tree (:parameter 0)))
                                   (with@ #//.children (list\composite (list.reversed lefts)
                                                                       (#.Item (value@ #node zipper)
                                                                               rights))))
                          parent)]
               (with@ [#node #//.children]
                      (list\composite (list.reversed lefts)
                                      (#.Item (value@ #node zipper)
                                              rights))
                      parent))))))

(template [<one> <all> <side> <op_side>]
  [(def: .public (<one> zipper)
     (All (_ a) (-> (Zipper a) (Maybe (Zipper a))))
     (case (value@ #family zipper)
       (#.Some family)
       (case (value@ <side> family)
         (#.Item next side')
         (#.Some (for [@.old
                       [#family (#.Some (|> family
                                            (with@ <side> side')
                                            (revised@ <op_side> (|>> (#.Item (value@ #node zipper))))))
                        #node next]]
                      (let [move (: (All (_ a) (-> (List (Tree a)) (Zipper a) (Family Zipper a) (Family Zipper a)))
                                    (function (_ side' zipper)
                                      (|>> (with@ <side> side')
                                           (revised@ <op_side> (|>> (#.Item (value@ #node zipper)))))))]
                        [#family (#.Some (move side' zipper family))
                         #node next])))

         #.End
         #.None)

       #.None
       #.None))

   (def: .public (<all> zipper)
     (All (_ a) (-> (Zipper a) (Maybe (Zipper a))))
     (case (value@ #family zipper)
       #.None
       #.None

       (#.Some family)
       (case (list.reversed (value@ <side> family))
         #.End
         #.None

         (#.Item last prevs)
         (#.Some (for [@.old [#family (#.Some (|> family
                                                  (with@ <side> #.End)
                                                  (revised@ <op_side> (|>> (#.Item (value@ #node zipper))
                                                                           (list\composite prevs)))))
                              #node last]]
                      (let [move (: (All (_ a) (-> (List (Tree a)) (Zipper a) (Family Zipper a) (Family Zipper a)))
                                    (function (_ prevs zipper)
                                      (|>> (with@ <side> #.End)
                                           (revised@ <op_side> (|>> (#.Item (value@ #node zipper))
                                                                    (list\composite prevs))))))]
                        [#family (#.Some (move prevs zipper family))
                         #node last]))))))]

  [right rightmost #rights #lefts]
  [left  leftmost  #lefts  #rights]
  )

(def: .public (next zipper)
  (All (_ a) (-> (Zipper a) (Maybe (Zipper a))))
  (case (..down zipper)
    (#.Some forward)
    (#.Some forward)
    
    #.None
    (loop [@ zipper]
      (case (..right @)
        (#.Some forward)
        (#.Some forward)
        
        #.None
        (do maybe.monad
          [@ (..up @)]
          (recur @))))))

(def: (bottom zipper)
  (All (_ a) (-> (Zipper a) (Zipper a)))
  (case (..right zipper)
    (#.Some forward)
    (bottom forward)

    #.None
    (case (..down zipper)
      (#.Some forward)
      (bottom forward)

      #.None
      zipper)))

(def: .public (previous zipper)
  (All (_ a) (-> (Zipper a) (Maybe (Zipper a))))
  (case (..left zipper)
    #.None
    (..up zipper)

    (#.Some backward)
    (#.Some (case (..down backward)
              (#.Some then)
              (..bottom then)

              #.None
              backward))))

(template [<name> <move>]
  [(def: .public (<name> zipper)
     (All (_ a) (-> (Zipper a) (Maybe (Zipper a))))
     (case (<move> zipper)
       #.None
       #.None

       (#.Some @)
       (loop [@ @]
         (case (<move> @)
           #.None
           (#.Some @)

           (#.Some @)
           (recur @)))))]

  [end ..next]
  [start ..previous]
  )

(def: .public (end? zipper)
  (All (_ a) (-> (Zipper a) Bit))
  (case (..end zipper)
    #.None
    true

    (#.Some _)
    false))

(def: .public (interpose value zipper)
  (All (_ a) (-> a (Zipper a) (Zipper a)))
  (revised@ [#node #//.children]
            (|>> (//.branch value) list)
            zipper))

(def: .public (adopt value zipper)
  (All (_ a) (-> a (Zipper a) (Zipper a)))
  (revised@ [#node #//.children]
            (|>> (#.Item (//.leaf value)))
            zipper))

(def: .public (remove zipper)
  (All (_ a) (-> (Zipper a) (Maybe (Zipper a))))
  (do maybe.monad
    [family (value@ #family zipper)]
    (case (value@ #lefts family)
      #.End
      (in (with@ [#node #//.children]
                 (value@ #rights family)
                 (value@ #parent family)))

      (#.Item next side)
      (in (|> zipper
              (with@ #family (|> family
                                 (with@ #lefts side)
                                 #.Some))
              (with@ #node next))))))

(template [<name> <side>]
  [(def: .public (<name> value zipper)
     (All (_ a) (-> a (Zipper a) (Maybe (Zipper a))))
     (case (value@ #family zipper)
       #.None
       #.None

       (#.Some family)
       (#.Some (with@ #family
                      (#.Some (revised@ <side> (|>> (#.Item (//.leaf value))) family))
                      zipper))))]

  [insert_left  #lefts]
  [insert_right #rights]
  )

(implementation: .public functor
  (Functor Zipper)
  
  (def: (each f (^slots [#family #node]))
    [#family (maybe\each (function (_ (^slots [#parent #lefts #rights]))
                           [#parent (each f parent)
                            #lefts (list\each (//\each f) lefts)
                            #rights (list\each (//\each f) rights)])
                         family)
     #node (//\each f node)]))

(implementation: .public comonad
  (CoMonad Zipper)
  
  (def: &functor ..functor)

  (def: out (value@ [#node #//.value]))

  (def: (disjoint (^slots [#family #node]))
    (let [tree_splitter (: (All (_ a) (-> (Tree a) (Tree (Zipper a))))
                           (function (tree_splitter tree)
                             [#//.value (..zipper tree)
                              #//.children (|> tree
                                               (value@ #//.children)
                                               (list\each tree_splitter))]))]
      [#family (maybe\each (function (_ (^slots [#parent #lefts #rights]))
                             [#parent (disjoint parent)
                              #lefts (list\each tree_splitter lefts)
                              #rights (list\each tree_splitter rights)])
                           family)
       #node (tree_splitter node)])))
