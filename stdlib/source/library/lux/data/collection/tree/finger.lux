(.module:
  [library
   [lux "*"
    [abstract
     [predicate {"+" [Predicate]}]
     ["[0]" monoid {"+" [Monoid]}]]
    [data
     [collection
      ["[0]" list ("[1]\[0]" monoid)]]]
    [type
     [abstract {"+" [abstract: :abstraction :representation]}]]]])

... https://en.wikipedia.org/wiki/Finger_tree
(abstract: .public (Tree @ t v)
  (Record
   [#monoid (Monoid t)
    #tag t
    #root (Or v
              [(Tree @ t v) (Tree @ t v)])])

  [(type: .public (Builder @ t)
     (Interface
      (: (All (_ v)
           (-> t v (Tree @ t v)))
         leaf)
      (: (All (_ v)
           (-> (Tree @ t v)
               (Tree @ t v)
               (Tree @ t v)))
         branch)))

   (template [<name> <tag> <output>]
     [(def: .public <name>
        (All (_ @ t v) (-> (Tree @ t v) <output>))
        (|>> :representation (value@ <tag>)))]

     [tag #tag t]
     [root #root (Either v [(Tree @ t v) (Tree @ t v)])]
     )

   (implementation: .public (builder monoid)
     (All (_ t) (Ex (_ @) (-> (Monoid t) (Builder @ t))))

     (def: (leaf tag value)
       (:abstraction
        [#monoid monoid
         #tag tag
         #root (0 #0 value)]))
     
     (def: (branch left right)
       (:abstraction
        [#monoid monoid
         #tag (\ monoid composite (..tag left) (..tag right))
         #root (0 #1 [left right])])))

   (def: .public (value tree)
     (All (_ @ t v) (-> (Tree @ t v) v))
     (case (value@ #root (:representation tree))
       (0 #0 value)
       value

       (0 #1 [left right])
       (value left)))

   (def: .public (tags tree)
     (All (_ @ t v) (-> (Tree @ t v) (List t)))
     (case (value@ #root (:representation tree))
       (0 #0 value)
       (list (value@ #tag (:representation tree)))

       (0 #1 [left right])
       (list\composite (tags left)
                       (tags right))))

   (def: .public (values tree)
     (All (_ @ t v) (-> (Tree @ t v) (List v)))
     (case (value@ #root (:representation tree))
       (0 #0 value)
       (list value)

       (0 #1 [left right])
       (list\composite (values left)
                       (values right))))

   (def: .public (one predicate tree)
     (All (_ @ t v) (-> (Predicate t) (Tree @ t v) (Maybe v)))
     (let [[monoid tag root] (:representation tree)]
       (if (predicate tag)
         (let [(^open "tag//[0]") monoid]
           (loop [_tag tag//identity
                  _node root]
             (case _node
               (0 #0 value)
               (#.Some value)

               (0 #1 [left right])
               (let [shifted_tag (tag//composite _tag (..tag left))]
                 (if (predicate shifted_tag)
                   (recur _tag (value@ #root (:representation left)))
                   (recur shifted_tag (value@ #root (:representation right))))))))
         #.None)))]
  )

(def: .public (exists? predicate tree)
  (All (_ @ t v) (-> (Predicate t) (Tree @ t v) Bit))
  (case (..one predicate tree)
    (#.Some _)
    true

    #.None
    false))
