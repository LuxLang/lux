(.using
 [library
  [lux (.full)
   [abstract
    [functor (.only Functor)]
    [equivalence (.only Equivalence)]
    [mix (.only Mix)]
    [monad (.only do)]]
   [control
    ["<>" parser (.only)
     ["<[0]>" code (.only Parser)]]]
   [data
    [collection
     ["[0]" list ("[1]#[0]" monad mix)]]]
   [macro
    [syntax (.only syntax:)]
    ["[0]" code]]]])

(type: .public (Tree a)
  (Record
   [#value a
    #children (List (Tree a))]))

(def: .public (flat tree)
  (All (_ a) (-> (Tree a) (List a)))
  (|> tree
      (the #children)
      (list#each flat)
      list#conjoint
      {.#Item (the #value tree)}))

(def: .public (leaf value)
  (All (_ a) (-> a (Tree a)))
  [#value value
   #children (list)])

(def: .public (branch value children)
  (All (_ a) (-> a (List (Tree a)) (Tree a)))
  [#value value
   #children children])

(type: Tree_Code
  (Rec Tree_Code
    [Code (List Tree_Code)]))

(def: tree^
  (Parser Tree_Code)
  (|> (|>> <>.some
           <code>.variant
           (<>.and <code>.any))
      <>.rec
      <>.some
      <code>.variant
      (<>.else (list))
      (<>.and <code>.any)))

(syntax: .public (tree [root tree^])
  (in (list (loop (again [[value children] root])
              (` [#value (~ value)
                  #children (list (~+ (list#each again children)))])))))

(implementation: .public (equivalence super)
  (All (_ a) (-> (Equivalence a) (Equivalence (Tree a))))
  
  (def: (= tx ty)
    (and (# super = (the #value tx) (the #value ty))
         (# (list.equivalence (equivalence super)) = (the #children tx) (the #children ty)))))

(implementation: .public functor
  (Functor Tree)
  
  (def: (each f fa)
    [#value (f (the #value fa))
     #children (list#each (each f)
                          (the #children fa))]))

(implementation: .public mix
  (Mix Tree)
  
  (def: (mix f init tree)
    (list#mix (function (_ tree' init') (mix f init' tree'))
              (f (the #value tree)
                 init)
              (the #children tree))))
