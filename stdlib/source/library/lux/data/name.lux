(.module:
  [library
   [lux #*
    [abstract
     [equivalence (#+ Equivalence)]
     [hash (#+ Hash)]
     [order (#+ Order)]
     [codec (#+ Codec)]]
    [data
     ["." text ("#\." equivalence monoid)]
     ["." product]]]])

... (type: Name
...   [Text Text])

(template [<name> <doc>]
  [(def: .public (<name> name)
     {#.doc (example <doc>)}
     (-> Name Text)
     (let [[module short] name]
       <name>))]

  [module "The module part of a name."]
  [short "The short part of a name."]
  )

(def: .public hash
  (Hash Name)
  (product.hash text.hash text.hash))

(def: .public equivalence
  (Equivalence Name)
  (\ ..hash &equivalence))

(implementation: .public order
  (Order Name)
  
  (def: &equivalence ..equivalence)
  (def: (< [moduleP shortP] [moduleS shortS])
    (if (text\= moduleP moduleS)
      (\ text.order < shortP shortS)
      (\ text.order < moduleP moduleS))))

(def: separator
  ".")

(implementation: .public codec
  (Codec Text Name)
  
  (def: (encode [module short])
    (case module
      "" short
      _ ($_ text\compose module ..separator short)))
  
  (def: (decode input)
    (case (text.split_all_with ..separator input)
      (^ (list short))
      (#.Right ["" short])

      (^ (list module short))
      (#.Right [module short])

      _
      (#.Left (text\compose "Invalid format for Name: " input)))))
