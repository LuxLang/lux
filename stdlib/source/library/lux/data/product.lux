(.module:
  {#.doc "Functionality for working with tuples (particularly 2-tuples/pairs)."}
  [library
   [lux #*
    [abstract
     [equivalence (#+ Equivalence)]
     [hash (#+ Hash)]]]])

(template [<name> <doc>]
  [(def: .public (<name> pair)
     {#.doc (doc <doc>)}
     (All [left right]
       (-> [left right] <name>))
     (let [[left right] pair]
       <name>))]

  [left "The left side of a pair."]
  [right "The right side of a pair."]
  )

... https://en.wikipedia.org/wiki/Currying
(def: .public (curry f)
  {#.doc (doc "Converts a 2-argument function into nested single-argument functions.")}
  (All [a b c]
    (-> (-> [a b] c)
        (-> a b c)))
  (function (_ x y)
    (f [x y])))

(def: .public (uncurry f)
  {#.doc (doc "Converts nested single-argument functions into a 2-argument function.")}
  (All [a b c]
    (-> (-> a b c)
        (-> [a b] c)))
  (function (_ xy)
    (let [[x y] xy]
      (f x y))))

(def: .public (swap xy)
  (All [a b] (-> [a b] [b a]))
  (let [[x y] xy]
    [y x]))

(def: .public (apply f g)
  {#.doc (doc "Apply functions to both sides of a pair.")}
  (All [a b c d]
    (-> (-> a c) (-> b d)
        (-> [a b] [c d])))
  (function (_ [x y])
    [(f x) (g y)]))

(def: .public (fork f g)
  {#.doc (doc "Yields a pair by applying both functions to a single value.")}
  (All [a l r]
    (-> (-> a l) (-> a r)
        (-> a [l r])))
  (function (_ x)
    [(f x) (g x)]))

(implementation: .public (equivalence left right)
  (All [l r] (-> (Equivalence l) (Equivalence r) (Equivalence [l r])))

  (def: (= [rl rr] [sl sr])
    (and (\ left = rl sl)
         (\ right = rr sr))))

(def: .public (hash left right)
  (All [l r] (-> (Hash l) (Hash r) (Hash [l r])))
  (implementation
   (def: &equivalence
     (..equivalence (\ left &equivalence)
                    (\ right &equivalence)))
   (def: (hash [leftV rightV])
     ("lux i64 +"
      (\ left hash leftV)
      (\ right hash rightV)))))
