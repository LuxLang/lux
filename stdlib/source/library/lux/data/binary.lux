(.using
 [library
  [lux "*"
   ["@" target]
   ["[0]" ffi]
   [abstract
    [equivalence {"+" Equivalence}]
    [monoid {"+" Monoid}]]
   [control
    ["[0]" try {"+" Try}]
    ["[0]" exception {"+" exception:}]]
   [data
    [text
     ["%" format]]
    [collection
     ["[0]" array]]]
   [math
    [number
     ["n" nat]]]]]
 ["[0]" / "_"
  ["[1]" \\unsafe]])

(type: .public Binary
  /.Binary)

(def: .public size
  (-> Binary Nat)
  (|>> /.size))

(def: .public (empty size)
  (-> Nat Binary)
  (/.empty size))

(def: .public (aggregate $ init it)
  (All (_ a) (-> (-> I64 a a) a Binary a))
  (let [size (/.size it)]
    (loop [index 0
           output init]
      (if (n.< size index)
        (again (++ index) ($ (/.bytes/1 index it) output))
        output))))

(exception: .public (index_out_of_bounds [size Nat
                                          index Nat])
  (exception.report
   ["Size" (%.nat size)]
   ["Index" (%.nat index)]))

(template [<safe> <unsafe> <shift>]
  [(def: .public (<safe> index it)
     (-> Nat Binary (Try I64))
     (if (n.< (/.size it) (|> index <shift>))
       {try.#Success (<unsafe> index it)}
       (exception.except ..index_out_of_bounds [(/.size it) index])))]

  [read/8! /.bytes/1 (|>)]
  [read/16! /.bytes/2 (n.+ 1)]
  [read/32! /.bytes/4 (n.+ 3)]
  [read/64! /.bytes/8 (n.+ 7)]
  )

(template [<safe> <unsafe> <shift>]
  [(def: .public (<safe> index value it)
     (-> Nat (I64 Any) Binary (Try Binary))
     (if (n.< (/.size it) (|> index <shift>))
       {try.#Success (<unsafe> index value it)}
       (exception.except ..index_out_of_bounds [(/.size it) index])))]

  [write/8! /.with/1! (|>)]
  [write/16! /.with/2! (n.+ 1)]
  [write/32! /.with/4! (n.+ 3)]
  [write/64! /.with/8! (n.+ 7)]
  )

(implementation: .public equivalence
  (Equivalence Binary)
  
  (def: (= reference sample)
    (/.= reference sample)))

(exception: .public (cannot_copy_bytes [bytes Nat
                                        source_input Nat
                                        target_output Nat])
  (exception.report
   ["Bytes" (%.nat bytes)]
   ["Source input space" (%.nat source_input)]
   ["Target output space" (%.nat target_output)]))

(def: .public (copy bytes source_offset source target_offset target)
  (-> Nat Nat Binary Nat Binary (Try Binary))
  (let [source_input (n.- source_offset (/.size source))]
    (if (n.< bytes source_input)
      (let [target_output (n.- target_offset (/.size target))]
        (exception.except ..cannot_copy_bytes [bytes source_input target_output]))
      {try.#Success (/.copy! bytes source_offset source target_offset target)})))

(exception: .public (slice_out_of_bounds [size Nat
                                          offset Nat
                                          length Nat])
  (exception.report
   ["Size" (%.nat size)]
   ["Offset" (%.nat offset)]
   ["Length" (%.nat length)]))

(def: .public (slice offset length binary)
  (-> Nat Nat Binary (Try Binary))
  (let [size (/.size binary)
        limit (n.+ length offset)]
    (if (n.< limit size)
      (exception.except ..slice_out_of_bounds [size offset length])
      {try.#Success (/.slice offset length binary)})))

(def: .public (after bytes binary)
  (-> Nat Binary Binary)
  (cond (n.= 0 bytes)
        binary

        (n.< bytes (/.size binary))
        (/.empty 0)

        ... else
        (/.slice bytes (n.- bytes (/.size binary)) binary)))

(implementation: .public monoid
  (Monoid Binary)

  (def: identity
    (/.empty 0))

  (def: (composite left right)
    (let [sizeL (/.size left)
          sizeR (/.size right)
          output (/.empty (n.+ sizeL sizeR))]
      (exec
        (/.copy! sizeL 0 left 0 output)
        (/.copy! sizeR 0 right sizeL output)
        output))))
