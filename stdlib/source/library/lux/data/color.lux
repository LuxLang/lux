(.require
 [library
  [lux (.except)
   [abstract
    [monoid (.only Monoid)]
    ["[0]" equivalence (.only Equivalence)]
    ["[0]" hash (.only Hash)]]
   [data
    [collection
     ["[0]" list (.use "[1]#[0]" functor)]]]
   [math
    [number
     ["n" nat]
     ["f" frac]
     ["[0]" int]
     ["[0]" rev (.use "[1]#[0]" interval)]
     ["[0]" i64]]]
   [meta
    [type
     ["[0]" nominal]]]]]
 [/
  ["[0]" rgb (.only RGB)]
  ["[0]" hsl]
  ["[0]" hsb]])

(nominal.def .public Color
  RGB

  (def .public of_rgb
    (-> RGB Color)
    (|>> nominal.abstraction))

  (def .public rgb
    (-> Color RGB)
    (|>> nominal.representation))
  )

(def (ratio it)
  (-> Frac
      Frac)
  (cond (f.> +1.0 it)
        (f.% +1.0 it)

        (f.< +0.0 it)
        (|> it (f.% +1.0) (f.+ +1.0))

        ... else
        it))

(with_template [<op> <name>]
  [(def .public (<name> ratio it)
     (-> Frac Color Color)
     (let [it (hsl.of_rgb (rgb it))]
       (|> (hsl.hsl (hsl.hue it)
                    (|> it
                        hsl.saturation
                        (f.* (|> +1.0 (<op> (..ratio ratio))))
                        (f.min +1.0))
                    (hsl.luminance it))
           hsl.rgb
           of_rgb)))]

  [f.+ saturated]
  [f.- un_saturated]
  )

(def .public (gray_scale color)
  (-> Color Color)
  (let [color (hsl.of_rgb (rgb color))]
    (|> (hsl.hsl +0.0
                 +0.0
                 (hsl.luminance color))
        hsl.rgb
        of_rgb)))

(with_template [<name> <1> <2>]
  [(`` (def .public (<name> color)
         (-> Color [Color Color Color])
         (let [hsl (hsl.of_rgb (rgb color))
               hue (hsl.hue hsl)
               saturation (hsl.saturation hsl)
               luminance (hsl.luminance hsl)]
           [color
            (|> (hsl.hsl (|> hue (f.+ <1>) ..ratio)
                         saturation
                         luminance)
                hsl.rgb
                of_rgb)
            (|> (hsl.hsl (|> hue (f.+ <2>) ..ratio)
                         saturation
                         luminance)
                hsl.rgb
                of_rgb)])))]

  [triad            (|> +1.0 (f./ +3.0)) (|> +2.0 (f./ +3.0))]
  [clash            (|> +1.0 (f./ +4.0)) (|> +3.0 (f./ +4.0))]
  [split_complement (|> +1.0 (f./ +5.0)) (|> +3.0 (f./ +5.0))]
  )

(with_template [<name> <1> <2> <3>]
  [(`` (def .public (<name> color)
         (-> Color [Color Color Color Color])
         (let [it (hsl.of_rgb (..rgb color))
               hue (hsl.hue it)
               saturation (hsl.saturation it)
               luminance (hsl.luminance it)
               of_hue (is (-> hsl.Value
                              Color)
                          (function (_ hue)
                            (|> (hsl.hsl hue saturation luminance)
                                hsl.rgb
                                ..of_rgb)))]
           [color
            (|> hue (f.+ <1>) ..ratio of_hue)
            (|> hue (f.+ <2>) ..ratio of_hue)
            (|> hue (f.+ <3>) ..ratio of_hue)])))]

  [square   (|> +1.0 (f./ +4.0))  (|> +2.0 (f./ +4.0))  (|> +3.0 (f./ +4.0))]
  [tetradic (|> +2.0 (f./ +12.0)) (|> +6.0 (f./ +12.0)) (|> +8.0 (f./ +12.0))]
  )

(type .public Spread
  Frac)

(type .public Palette
  (-> Spread Nat Color (List Color)))

(def .public (analogous spread variations it)
  Palette
  (let [it (hsl.of_rgb (..rgb it))
        hue (hsl.hue it)
        saturation (hsl.saturation it)
        luminance (hsl.luminance it)
        spread (..ratio spread)]
    (list#each (function (_ idx)
                 (|> (hsl.hsl (|> idx ++ .int int.frac (f.* spread) (f.+ hue) ..ratio)
                              saturation
                              luminance)
                     hsl.rgb
                     ..of_rgb))
               (list.indices variations))))

(def .public (monochromatic spread variations it)
  Palette
  (let [it (hsb.of_rgb (..rgb it))
        hue (hsb.hue it)
        saturation (hsb.saturation it)
        brightness (hsb.brightness it)
        spread (..ratio spread)]
    (|> (list.indices variations)
        (list#each (|>> ++ .int int.frac
                        (f.* spread)
                        (f.+ brightness)
                        ..ratio
                        (hsb.hsb hue saturation)
                        hsb.rgb
                        ..of_rgb)))))
