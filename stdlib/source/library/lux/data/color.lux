(.require
 [library
  [lux (.except)
   [abstract
    [monoid (.only Monoid)]
    ["[0]" equivalence (.only Equivalence)]
    ["[0]" hash (.only Hash)]]
   [control
    ["[0]" try]]
   [data
    [collection
     ["[0]" list (.use "[1]#[0]" functor)]]]
   [math
    [number
     ["n" nat]
     ["f" frac]
     ["[0]" int]
     ["[0]" rev (.use "[1]#[0]" interval)]
     ["[0]" i64]]]
   [meta
    [type
     ["[0]" nominal]]]]]
 [/
  ["[0]" rgb (.only RGB)]
  ["[0]" hsl]
  ["[0]" hsb]])

(nominal.def .public Color
  RGB

  (def .public of_rgb
    (-> RGB Color)
    (|>> nominal.abstraction))

  (def .public rgb
    (-> Color RGB)
    (|>> nominal.representation))

  (def .public equivalence
    (Equivalence Color)
    (at equivalence.functor each ..rgb rgb.equivalence))

  (def .public hash
    (Hash Color)
    (at hash.functor each ..rgb rgb.hash))

  (with_template [<color> <rgb>]
    [(def .public <color>
       Color
       (nominal.abstraction <rgb>))]

    [black rgb.black]
    [white rgb.white]
    )

  (with_template [<color> <rgb>]
    [(def .public <color>
       (Monoid Color)
       (implementation
        (def identity
          (nominal.abstraction
           (at <rgb> identity)))

        (def (composite left right)
          (nominal.abstraction
           (at <rgb> composite
               (nominal.representation left)
               (nominal.representation right))))))]

    [addition rgb.addition]
    [subtraction rgb.subtraction]
    )

  (def .public complement
    (-> Color Color)
    (|>> nominal.representation
         rgb.complement
         nominal.abstraction))
  )

(def (normal ratio)
  (-> Frac Frac)
  (cond (f.> +1.0 ratio)
        (f.% +1.0 ratio)

        (f.< +0.0 ratio)
        (|> ratio (f.% +1.0) (f.+ +1.0))

        ... else
        ratio))

(def .public (interpolated ratio end start)
  (-> Frac Color Color Color)
  (let [dS (..normal ratio)
        dE (|> +1.0 (f.- dS))
        interpolated' (is (-> Nat Nat Nat)
                          (function (_ end start)
                            (|> (|> start .int int.frac (f.* dS))
                                (f.+ (|> end .int int.frac (f.* dE)))
                                f.int
                                .nat)))
        [redS greenS blueS] (rgb start)
        [redE greenE blueE] (rgb end)]
    (|> (rgb.rgb (interpolated' (rgb.number redE) (rgb.number redS))
                 (interpolated' (rgb.number greenE) (rgb.number greenS))
                 (interpolated' (rgb.number blueE) (rgb.number blueS)))
        try.trusted
        of_rgb)))

(with_template [<name> <target>]
  [(def .public (<name> ratio color)
     (-> Frac Color Color)
     (..interpolated ratio <target> color))]

  [darker   ..black]
  [brighter ..white]
  )

(with_template [<op> <name>]
  [(def .public (<name> ratio it)
     (-> Frac Color Color)
     (let [it (hsl.of_rgb (rgb it))]
       (|> (hsl.hsl (hsl.hue it)
                    (|> it
                        hsl.saturation
                        (f.* (|> +1.0 (<op> (..normal ratio))))
                        (f.min +1.0))
                    (hsl.luminance it))
           hsl.rgb
           of_rgb)))]

  [f.+ saturated]
  [f.- un_saturated]
  )

(def .public (gray_scale color)
  (-> Color Color)
  (let [color (hsl.of_rgb (rgb color))]
    (|> (hsl.hsl +0.0
                 +0.0
                 (hsl.luminance color))
        hsl.rgb
        of_rgb)))

(with_template [<name> <1> <2>]
  [(`` (def .public (<name> color)
         (-> Color [Color Color Color])
         (let [hsl (hsl.of_rgb (rgb color))
               hue (hsl.hue hsl)
               saturation (hsl.saturation hsl)
               luminance (hsl.luminance hsl)]
           [color
            (|> (hsl.hsl (|> hue (f.+ <1>) ..normal)
                         saturation
                         luminance)
                hsl.rgb
                of_rgb)
            (|> (hsl.hsl (|> hue (f.+ <2>) ..normal)
                         saturation
                         luminance)
                hsl.rgb
                of_rgb)])))]

  [triad            (|> +1.0 (f./ +3.0)) (|> +2.0 (f./ +3.0))]
  [clash            (|> +1.0 (f./ +4.0)) (|> +3.0 (f./ +4.0))]
  [split_complement (|> +1.0 (f./ +5.0)) (|> +3.0 (f./ +5.0))]
  )

(with_template [<name> <1> <2> <3>]
  [(`` (def .public (<name> color)
         (-> Color [Color Color Color Color])
         (let [it (hsl.of_rgb (..rgb color))
               hue (hsl.hue it)
               saturation (hsl.saturation it)
               luminance (hsl.luminance it)
               of_hue (is (-> hsl.Value
                              Color)
                          (function (_ hue)
                            (|> (hsl.hsl hue saturation luminance)
                                hsl.rgb
                                ..of_rgb)))]
           [color
            (|> hue (f.+ <1>) ..normal of_hue)
            (|> hue (f.+ <2>) ..normal of_hue)
            (|> hue (f.+ <3>) ..normal of_hue)])))]

  [square   (|> +1.0 (f./ +4.0))  (|> +2.0 (f./ +4.0))  (|> +3.0 (f./ +4.0))]
  [tetradic (|> +2.0 (f./ +12.0)) (|> +6.0 (f./ +12.0)) (|> +8.0 (f./ +12.0))]
  )

(type .public Spread
  Frac)

(type .public Palette
  (-> Spread Nat Color (List Color)))

(def .public (analogous spread variations it)
  Palette
  (let [it (hsl.of_rgb (..rgb it))
        hue (hsl.hue it)
        saturation (hsl.saturation it)
        luminance (hsl.luminance it)
        spread (..normal spread)]
    (list#each (function (_ idx)
                 (|> (hsl.hsl (|> idx ++ .int int.frac (f.* spread) (f.+ hue) ..normal)
                              saturation
                              luminance)
                     hsl.rgb
                     ..of_rgb))
               (list.indices variations))))

(def .public (monochromatic spread variations it)
  Palette
  (let [it (hsb.of_rgb (..rgb it))
        hue (hsb.hue it)
        saturation (hsb.saturation it)
        brightness (hsb.brightness it)
        spread (..normal spread)]
    (|> (list.indices variations)
        (list#each (|>> ++ .int int.frac
                        (f.* spread)
                        (f.+ brightness)
                        ..normal
                        (hsb.hsb hue saturation)
                        hsb.rgb
                        ..of_rgb)))))

(type .public Alpha
  Rev)

(def .public transparent
  Alpha
  rev#bottom)

(def .public translucent
  Alpha
  .5)

(def .public opaque
  Alpha
  rev#top)

(type .public Pigment
  (Record
   [#color Color
    #alpha Alpha]))
