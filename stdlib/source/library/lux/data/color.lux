(.require
 [library
  [lux (.except)
   [abstract
    [monoid (.only Monoid)]
    ["[0]" equivalence (.only Equivalence)]
    ["[0]" hash (.only Hash)]]
   [data
    [collection
     ["[0]" list (.use "[1]#[0]" functor)]]]
   [math
    [number
     ["n" nat]
     ["f" frac]
     ["[0]" int]
     ["[0]" rev (.use "[1]#[0]" interval)]
     ["[0]" i64]]]
   [meta
    [type
     ["[0]" nominal]]]]]
 [/
  ["[0]" rgb (.only RGB)]
  ["[0]" hsl]
  ["[0]" hsb]])

(nominal.def .public Color
  RGB

  (def .public of_rgb
    (-> RGB Color)
    (|>> nominal.abstraction))

  (def .public rgb
    (-> Color RGB)
    (|>> nominal.representation))
  )

(def (ratio it)
  (-> Frac
      Frac)
  (cond (f.> +1.0 it)
        (f.% +1.0 it)

        (f.< +0.0 it)
        (|> it (f.% +1.0) (f.+ +1.0))

        ... else
        it))

(type .public Spread
  Frac)

... https://en.wikipedia.org/wiki/Color_scheme
(type .public Palette
  (-> Spread Nat Color (List Color)))

(def .public (analogous spread variations it)
  Palette
  (let [it (hsl.of_rgb (..rgb it))
        hue (the hsl.#hue it)
        saturation (the hsl.#saturation it)
        luminance (the hsl.#luminance it)
        spread (..ratio spread)]
    (list#each (function (_ idx)
                 (|> (hsl.hsl (|> idx ++ .int int.frac (f.* spread) (f.+ hue) ..ratio)
                              saturation
                              luminance)
                     hsl.rgb
                     ..of_rgb))
               (list.indices variations))))

(def .public (monochromatic spread variations it)
  Palette
  (let [it (hsb.of_rgb (..rgb it))
        hue (hsb.hue it)
        saturation (hsb.saturation it)
        brightness (hsb.brightness it)
        spread (..ratio spread)]
    (|> (list.indices variations)
        (list#each (|>> ++ .int int.frac
                        (f.* spread)
                        (f.+ brightness)
                        ..ratio
                        (hsb.hsb hue saturation)
                        hsb.rgb
                        ..of_rgb)))))
