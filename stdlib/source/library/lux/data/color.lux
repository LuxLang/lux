(.require
 [library
  [lux (.except)
   [abstract
    [monoid (.only Monoid)]
    ["[0]" equivalence (.only Equivalence)]
    ["[0]" hash (.only Hash)]]
   [control
    ["[0]" try]]
   [data
    [collection
     ["[0]" list (.use "[1]#[0]" functor)]]]
   [math
    [number
     ["n" nat]
     ["f" frac]
     ["[0]" int]
     ["[0]" rev (.use "[1]#[0]" interval)]
     ["[0]" i64]]]
   [meta
    [type
     ["[0]" primitive]]]]]
 [/
  ["[0]" rgb (.only RGB)]])

(def top
  (-- rgb.limit))

(def rgb_factor
  (|> top .int int.frac))

(def down
  (-> Nat Frac)
  (|>> .int int.frac (f./ rgb_factor)))

(def up
  (-> Frac Nat)
  (|>> (f.* rgb_factor) f.int .nat))

(type .public HSL
  [Frac Frac Frac])

(type .public CMYK
  (Record
   [#cyan Frac
    #magenta Frac
    #yellow Frac
    #key Frac]))

(type .public HSB
  [Frac Frac Frac])

(primitive.def .public Color
  RGB

  (def .public of_rgb
    (-> RGB Color)
    (|>> primitive.abstraction))

  (def .public rgb
    (-> Color RGB)
    (|>> primitive.representation))

  (def .public equivalence
    (Equivalence Color)
    (at equivalence.functor each ..rgb rgb.equivalence))

  (def .public hash
    (Hash Color)
    (at hash.functor each ..rgb rgb.hash))

  (with_template [<color> <rgb>]
    [(def .public <color>
       Color
       (primitive.abstraction <rgb>))]

    [black rgb.black]
    [white rgb.white]
    )

  (with_template [<color> <rgb>]
    [(def .public <color>
       (Monoid Color)
       (implementation
        (def identity
          (primitive.abstraction
           (at <rgb> identity)))

        (def (composite left right)
          (primitive.abstraction
           (at <rgb> composite
               (primitive.representation left)
               (primitive.representation right))))))]

    [addition rgb.addition]
    [subtraction rgb.subtraction]
    )

  (def .public complement
    (-> Color Color)
    (|>> primitive.representation
         rgb.complement
         primitive.abstraction))
  )

(def .public (hsl color)
  (-> Color HSL)
  (let [[red green blue] (rgb color)
        red (..down (rgb.number red))
        green (..down (rgb.number green))
        blue (..down (rgb.number blue))
        max (all f.max red green blue)
        min (all f.min red green blue)
        luminance (|> (f.+ max min) (f./ +2.0))]
    (if (f.= max min)
      ... Achromatic
      [+0.0
       +0.0
       luminance]
      ... Chromatic
      (let [diff (|> max (f.- min))
            saturation (|> diff
                           (f./ (if (f.> +0.5 luminance)
                                  (|> +2.0 (f.- max) (f.- min))
                                  (|> max (f.+ min)))))
            hue' (cond (f.= red max)
                       (|> green (f.- blue) (f./ diff)
                           (f.+ (if (f.< blue green) +6.0 +0.0)))
                       
                       (f.= green max)
                       (|> blue (f.- red) (f./ diff)
                           (f.+ +2.0))
                       
                       ... (f.= blue max)
                       (|> red (f.- green) (f./ diff)
                           (f.+ +4.0)))]
        [(|> hue' (f./ +6.0))
         saturation
         luminance]))))

(def (hue_rgb p q t)
  (-> Frac Frac Frac Nat)
  (let [t (cond (f.< +0.0 t) (f.+ +1.0 t)
                (f.> +1.0 t) (f.- +1.0 t)
                ... else
                t)
        f2/3 (f./ +3.0 +2.0)]
    (..up (cond (f.< (f./ +6.0 +1.0) t)
                (|> q (f.- p) (f.* +6.0) (f.* t) (f.+ p))
                
                (f.< (f./ +2.0 +1.0) t)
                q
                
                (f.< f2/3 t)
                (|> q (f.- p) (f.* (|> f2/3 (f.- t))) (f.* +6.0) (f.+ p))
                
                ... else
                p))))

(def .public (of_hsl [hue saturation luminance])
  (-> HSL Color)
  (|> (if (f.= +0.0 saturation)
        ... Achromatic
        (let [intensity (..up luminance)]
          (rgb.rgb intensity intensity intensity))
        ... Chromatic
        (let [q (if (f.< +0.5 luminance)
                  (|> saturation (f.+ +1.0) (f.* luminance))
                  (|> luminance (f.+ saturation) (f.- (f.* saturation luminance))))
              p (|> luminance (f.* +2.0) (f.- q))
              third (|> +1.0 (f./ +3.0))]
          (rgb.rgb (|> hue (f.+ third) (hue_rgb p q))
                   (|> hue (hue_rgb p q))
                   (|> hue (f.- third) (hue_rgb p q)))))
      try.trusted
      of_rgb))

(def .public (hsb color)
  (-> Color HSB)
  (let [[red green blue] (rgb color)
        red (..down (rgb.number red))
        green (..down (rgb.number green))
        blue (..down (rgb.number blue))
        max (all f.max red green blue)
        min (all f.min red green blue)
        brightness max
        diff (|> max (f.- min))
        saturation (if (f.= +0.0 max)
                     +0.0
                     (|> diff (f./ max)))]
    (if (f.= max min)
      ... Achromatic
      [+0.0 saturation brightness]
      ... Chromatic
      (let [hue (cond (f.= red max)
                      (|> green (f.- blue) (f./ diff)
                          (f.+ (if (f.< blue green) +6.0 +0.0)))

                      (f.= green max)
                      (|> blue (f.- red) (f./ diff)
                          (f.+ +2.0))

                      ... (f.= blue max)
                      (|> red (f.- green) (f./ diff)
                          (f.+ +4.0)))]
        [(|> hue (f./ +6.0))
         saturation
         brightness]))))

(def .public (of_hsb [hue saturation brightness])
  (-> HSB Color)
  (let [hue (|> hue (f.* +6.0))
        i (f.floor hue)
        f (|> hue (f.- i))
        p (|> +1.0 (f.- saturation) (f.* brightness))
        q (|> +1.0 (f.- (f.* f saturation)) (f.* brightness))
        t (|> +1.0 (f.- (|> +1.0 (f.- f) (f.* saturation))) (f.* brightness))
        v brightness
        mod (|> i (f.% +6.0) f.int .nat)
        red (when mod 0 v 1 q 2 p 3 p 4 t 5 v _ (undefined))
        green (when mod 0 t 1 v 2 v 3 q 4 p 5 p _ (undefined))
        blue (when mod 0 p 1 p 2 t 3 v 4 v 5 q _ (undefined))]
    (|> (rgb.rgb (..up red)
                 (..up green)
                 (..up blue))
        try.trusted
        of_rgb)))

(def .public (cmyk color)
  (-> Color CMYK)
  (let [[red green blue] (rgb color)
        red (..down (rgb.number red))
        green (..down (rgb.number green))
        blue (..down (rgb.number blue))
        key (|> +1.0 (f.- (all f.max red green blue)))
        f (if (f.< +1.0 key)
            (|> +1.0 (f./ (|> +1.0 (f.- key))))
            +0.0)
        cyan (|> +1.0 (f.- red) (f.- key) (f.* f))
        magenta (|> +1.0 (f.- green) (f.- key) (f.* f))
        yellow (|> +1.0 (f.- blue) (f.- key) (f.* f))]
    [#cyan cyan
     #magenta magenta
     #yellow yellow
     #key key]))

(def .public (of_cmyk [cyan magenta yellow key])
  (-> CMYK Color)
  (if (f.= +1.0 key)
    ..black
    (let [red (|> (|> +1.0 (f.- cyan))
                  (f.* (|> +1.0 (f.- key))))
          green (|> (|> +1.0 (f.- magenta))
                    (f.* (|> +1.0 (f.- key))))
          blue (|> (|> +1.0 (f.- yellow))
                   (f.* (|> +1.0 (f.- key))))]
      (|> (rgb.rgb (..up red)
                   (..up green)
                   (..up blue))
          try.trusted
          of_rgb))))

(def (normal ratio)
  (-> Frac Frac)
  (cond (f.> +1.0 ratio)
        (f.% +1.0 ratio)

        (f.< +0.0 ratio)
        (|> ratio (f.% +1.0) (f.+ +1.0))

        ... else
        ratio))

(def .public (interpolated ratio end start)
  (-> Frac Color Color Color)
  (let [dS (..normal ratio)
        dE (|> +1.0 (f.- dS))
        interpolated' (is (-> Nat Nat Nat)
                          (function (_ end start)
                            (|> (|> start .int int.frac (f.* dS))
                                (f.+ (|> end .int int.frac (f.* dE)))
                                f.int
                                .nat)))
        [redS greenS blueS] (rgb start)
        [redE greenE blueE] (rgb end)]
    (|> (rgb.rgb (interpolated' (rgb.number redE) (rgb.number redS))
                 (interpolated' (rgb.number greenE) (rgb.number greenS))
                 (interpolated' (rgb.number blueE) (rgb.number blueS)))
        try.trusted
        of_rgb)))

(with_template [<name> <target>]
  [(def .public (<name> ratio color)
     (-> Frac Color Color)
     (..interpolated ratio <target> color))]

  [darker   ..black]
  [brighter ..white]
  )

(with_template [<op> <name>]
  [(def .public (<name> ratio color)
     (-> Frac Color Color)
     (let [[hue saturation luminance] (hsl color)]
       (of_hsl [hue
                (|> saturation
                    (f.* (|> +1.0 (<op> (..normal ratio))))
                    (f.min +1.0))
                luminance])))]

  [f.+ saturated]
  [f.- un_saturated]
  )

(def .public (gray_scale color)
  (-> Color Color)
  (let [[_ _ luminance] (hsl color)]
    (of_hsl [+0.0
             +0.0
             luminance])))

(with_template [<name> <1> <2>]
  [(`` (def .public (<name> color)
         (-> Color [Color Color Color])
         (let [[hue saturation luminance] (hsl color)]
           [color
            (of_hsl [(|> hue (f.+ <1>) ..normal)
                     saturation
                     luminance])
            (of_hsl [(|> hue (f.+ <2>) ..normal)
                     saturation
                     luminance])])))]

  [triad            (|> +1.0 (f./ +3.0)) (|> +2.0 (f./ +3.0))]
  [clash            (|> +1.0 (f./ +4.0)) (|> +3.0 (f./ +4.0))]
  [split_complement (|> +1.0 (f./ +5.0)) (|> +3.0 (f./ +5.0))]
  )

(with_template [<name> <1> <2> <3>]
  [(`` (def .public (<name> color)
         (-> Color [Color Color Color Color])
         (let [[hue saturation luminance] (hsb color)]
           [color
            (of_hsb [(|> hue (f.+ <1>) ..normal)
                     saturation
                     luminance])
            (of_hsb [(|> hue (f.+ <2>) ..normal)
                     saturation
                     luminance])
            (of_hsb [(|> hue (f.+ <3>) ..normal)
                     saturation
                     luminance])])))]

  [square   (|> +1.0 (f./ +4.0))  (|> +2.0 (f./ +4.0))  (|> +3.0 (f./ +4.0))]
  [tetradic (|> +2.0 (f./ +12.0)) (|> +6.0 (f./ +12.0)) (|> +8.0 (f./ +12.0))]
  )

(type .public Spread
  Frac)

(type .public Palette
  (-> Spread Nat Color (List Color)))

(`` (def .public (analogous spread variations color)
      Palette
      (let [[hue saturation brightness] (hsb color)
            spread (..normal spread)]
        (list#each (function (_ idx)
                     (of_hsb [(|> idx ++ .int int.frac (f.* spread) (f.+ hue) ..normal)
                              saturation
                              brightness]))
                   (list.indices variations)))))

(`` (def .public (monochromatic spread variations color)
      Palette
      (let [[hue saturation brightness] (hsb color)
            spread (..normal spread)]
        (|> (list.indices variations)
            (list#each (|>> ++ .int int.frac
                            (f.* spread)
                            (f.+ brightness)
                            ..normal
                            [hue saturation]
                            of_hsb))))))

(type .public Alpha
  Rev)

(def .public transparent
  Alpha
  rev#bottom)

(def .public translucent
  Alpha
  .5)

(def .public opaque
  Alpha
  rev#top)

(type .public Pigment
  (Record
   [#color Color
    #alpha Alpha]))
