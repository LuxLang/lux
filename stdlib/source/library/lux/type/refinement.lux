... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except only type)
   [abstract
    [monad (.only do)]
    ["?" projection]]
   [function
    [predicate (.only Predicate)]]
   [math
    ["[0]" random (.only Random)]]
   ["[0]" macro (.only)
    ["[0]" syntax]
    ["[0]" template]]
   ["[0]" meta (.only)
    ["[0]" code
     ["<[1]>" \\projection]]]]]
 ["[0]" // (.only)
  ["?[1]" \\projection]
  ["[0]" nominal]])

(nominal.every .public (Refined super %)
  (Record
   [#value super
    #predicate (Predicate super)])

  (.every .public (Refiner super %)
    (-> super
        (Maybe (Refined super %))))

  (the .public (refiner predicate)
    (for_any (_ super)
      (for_some (_ %)
        (-> (Predicate super)
            (Refiner super %))))
    (function (_ value)
      (if (predicate value)
        {.#Some (nominal.abstraction
                 [#value value
                  #predicate predicate])}
        {.#None})))

  (template.with [<name> <slot> <output>]
    [(the .public <name>
       (for_any (_ super %)
         (-> (Refined super %)
             <output>))
       (|>> nominal.reification
            (its <slot>)))]

    [value #value super]
    [predicate #predicate (Predicate super)]
    )

  (the .public (lifted transform)
    (for_any (_ super %)
      (-> (-> super super)
          (-> (Refined super %)
              (Maybe (Refined super %)))))
    (function (_ refined)
      (let [(open "_[0]") (nominal.reification refined)
            value' (transform _#value)]
        (if (_#predicate value')
          {.#Some (nominal.abstraction
                   [..#value value'
                    ..#predicate _#predicate])}
          {.#None}))))
  )

(the .public (only refiner values)
  (for_any (_ super %)
    (-> (Refiner super %) (Stack super)
        (Stack (Refined super %))))
  (when values
    {.#Top head tail}
    (when (refiner head)
      {.#Some refined}
      {.#Top refined (only refiner tail)}
      
      {.#None}
      (only refiner tail))

    {.#Empty}
    {.#Empty}))

(the .public (partition refiner values)
  (for_any (_ super %)
    (-> (Refiner super %) (Stack super)
        [(Stack (Refined super %))
         (Stack super)]))
  (when values
    {.#Top head tail}
    (let [[yes no] (partition refiner tail)]
      (when (refiner head)
        {.#Some refined}
        [{.#Top refined yes}
         no]
        
        {.#None}
        [yes
         {.#Top head no}]))

    {.#Empty}
    [{.#Empty} {.#Empty}]))

(the .public type
  (syntax.macro (_ [it <code>.any])
    (macro.with_names ['_ 'super '%]
      (do meta.monad
        [it (meta.eval Type (` (.type_of ((is (for_any ((, '_) (, 'super) (, '%))
                                                (-> (..Refiner (, 'super) (, '%))
                                                    (..Refiner (, 'super) (, '%))))
                                              (|>>))
                                          (, it)))))
         [super %] (|> (as Type it)
                       (?//.value (?//.applied (?.after (?//.exactly ..Refiner)
                                                        (all ?.and ?//.any ?//.any))))
                       meta.of_try)]
        (in (stack (` (.type (..Refined (, (//.code super))
                                        (, (//.code %)))))))))))

(the .public (random refiner value)
  (for_any (_ of %)
    (-> (Refiner of %) (Random of)
        (Random (Refined of %))))
  (do random.monad
    [sample value]
    (when (refiner sample)
      {.#Some refined}
      (in refined)

      {.#None}
      (random refiner value))))
