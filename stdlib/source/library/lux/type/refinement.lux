(.module:
  [library
   [lux (#- type)
    [abstract
     [predicate (#+ Predicate)]]
    ["." macro
     [syntax (#+ syntax:)]]
    ["." type
     abstract]]])

(abstract: .public (Refined t %)
  {#.doc "A refined version of another type, using a predicate to select valid instances."}

  {#value t
   #predicate (Predicate t)}

  (type: .public (Refiner t %)
    {#.doc (doc "A selection mechanism for refined instances of a type.")}
    (-> t (Maybe (Refined t %))))

  (def: .public (refiner predicate)
    (All [t]
      (Ex [%]
        (-> (Predicate t) (Refiner t %))))
    (function (_ value)
      (if (predicate value)
        (#.Some (:abstraction {#value value
                               #predicate predicate}))
        #.None)))

  (template [<name> <output> <slot>]
    [(def: .public <name>
       (All [t %] (-> (Refined t %) <output>))
       (|>> :representation (get@ <slot>)))]

    [value     t             #value]
    [predicate (Predicate t) #predicate]
    )

  (def: .public (lift transform)
    {#.doc (doc "Yields a function that can work on refined values."
                "Respects the constraints of the refinement.")}
    (All [t %]
      (-> (-> t t)
          (-> (Refined t %) (Maybe (Refined t %)))))
    (function (_ refined)
      (let [(^slots [#value #predicate]) (:representation refined)
            value' (transform value)]
        (if (predicate value')
          (#.Some (:abstraction {#value value'
                                 #predicate predicate}))
          #.None))))
  )

(def: .public (only refiner values)
  (All [t %]
    (-> (Refiner t %) (List t) (List (Refined t %))))
  (case values
    #.End
    #.End

    (#.Item head tail)
    (case (refiner head)
      (#.Some refined)
      (#.Item refined (only refiner tail))
      
      #.None
      (only refiner tail))))

(def: .public (partition refiner values)
  {#.doc (doc "Separates refined values from the un-refined ones.")}
  (All [t %]
    (-> (Refiner t %) (List t) [(List (Refined t %)) (List t)]))
  (case values
    #.End
    [#.End #.End]

    (#.Item head tail)
    (let [[yes no] (partition refiner tail)]
      (case (refiner head)
        (#.Some refined)
        [(#.Item refined yes)
         no]
        
        #.None
        [yes
         (#.Item head no)]))))

(syntax: .public (type refiner)
  {#.doc (doc "The Refined type associated with a Refiner type."
              (def: even
                (refiner even?))

              (def: Even
                Type
                (type even))

              (: (Maybe Even)
                 (even 123)))}
  (macro.with_gensyms [g!t g!%]
    (in (list (` ((~! type.:by_example) [(~ g!t) (~ g!%)]
                  (..Refiner (~ g!t) (~ g!%))
                  (~ refiner)
                  
                  (..Refined (~ g!t) (~ g!%))))))))
