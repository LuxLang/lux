(.module:
  [library
   [lux (#- type)
    [abstract
     [equivalence (#+ Equivalence)]]
    [control
     [parser
      ["<.>" code]]]
    [macro (#+ with_identifiers)
     [syntax (#+ syntax:)]]
    ["." type
     abstract]]])

(abstract: .public (Class t c %)
  {}
  
  (-> t c)

  (def: .public class
    (All [t c]
      (Ex [%]
        (-> (-> t c) (Class t c %))))
    (|>> :abstraction))

  (abstract: .public (Quotient t c %)
    {}
    
    (Record
     {#value t
      #label c})

    (def: .public (quotient class value)
      (All [t c %]
        (-> (Class t c %) t
            (Quotient t c %)))
      (:abstraction {#value value
                     #label ((:representation Class class) value)}))

    (template [<name> <output> <slot>]
      [(def: .public <name>
         (All [t c %] (-> (Quotient t c %) <output>))
         (|>> :representation (value@ <slot>)))]

      [value t #value]
      [label c #label]
      )
    )
  )

(syntax: .public (type [class <code>.any])
  (with_identifiers [g!t g!c g!%]
    (in (list (` ((~! type.:by_example)
                  [(~ g!t) (~ g!c) (~ g!%)]

                  (..Class (~ g!t) (~ g!c) (~ g!%))
                  (~ class)
                  
                  (..Quotient (~ g!t) (~ g!c) (~ g!%))))))))

(implementation: .public (equivalence super)
  (All [t c %] (-> (Equivalence c) (Equivalence (..Quotient t c %))))

  (def: (= reference sample)
    (\ super = (..label reference) (..label sample))))
