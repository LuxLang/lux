(.using
 [library
  [lux {"-" static}
   ["[0]" debug]
   [control
    ["[0]" try {"+" Try}]
    ["[0]" exception {"+" exception:}]
    [parser
     ["<[0]>" code]]]
   [data
    [text
     ["%" format]]]
   [macro {"+" with_symbols}
    ["[0]" syntax {"+" syntax:}]]
   ["[0]" type
    ["[0]" abstract {"+" abstract:}]]]])

(exception: .public (wrong_type [expected Type
                                 actual Type])
  (exception.report
   "Expected" (%.type expected)
   "Actual" (%.type actual)))

(abstract: .public Dynamic
  [Type Any]

  (def: abstraction
    (-> [Type Any] Dynamic)
    (|>> abstract.abstraction))
  
  (def: representation
    (-> Dynamic [Type Any])
    (|>> abstract.representation))

  (syntax: .public (dynamic [value <code>.any])
    (with_symbols [g!value]
      (in (list (` (.let [(~ g!value) (~ value)]
                     ((~! ..abstraction) [(.type_of (~ g!value)) (~ g!value)])))))))

  (syntax: .public (static [type <code>.any
                            value <code>.any])
    (with_symbols [g!type g!value]
      (in (list (` (.let [[(~ g!type) (~ g!value)] ((~! ..representation) (~ value))]
                     (.is ((~! try.Try) (~ type))
                          (.if (.# (~! type.equivalence) (~' =)
                                   (.type (~ type)) (~ g!type))
                            {try.#Success (.as (~ type) (~ g!value))}
                            ((~! exception.except) ..wrong_type [(.type (~ type)) (~ g!type)])))))))))

  (def: .public (format value)
    (-> Dynamic (Try Text))
    (let [[type value] (abstract.representation value)]
      (debug.representation type value)))
  )
