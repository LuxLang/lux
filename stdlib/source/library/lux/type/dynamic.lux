(.using
 [library
  [lux "*"
   ["[0]" debug]
   [control
    ["[0]" try {"+" Try}]
    ["[0]" exception {"+" exception:}]
    [parser
     ["<[0]>" code]]]
   [data
    [text
     ["%" format]]]
   [macro {"+" with_symbols}
    ["[0]" syntax {"+" syntax:}]]
   ["[0]" type
    abstract]]])

(exception: .public (wrong_type [expected Type
                                 actual Type])
  (exception.report
   "Expected" (%.type expected)
   "Actual" (%.type actual)))

(abstract: .public Dynamic
  [Type Any]

  (def: abstraction
    (-> [Type Any] Dynamic)
    (|>> :abstraction))
  
  (def: representation
    (-> Dynamic [Type Any])
    (|>> :representation))

  (syntax: .public (:dynamic [value <code>.any])
    (with_symbols [g!value]
      (in (list (` (let [(~ g!value) (~ value)]
                     ((~! ..abstraction) [(:of (~ g!value)) (~ g!value)])))))))

  (syntax: .public (:static [type <code>.any
                             value <code>.any])
    (with_symbols [g!type g!value]
      (in (list (` (let [[(~ g!type) (~ g!value)] ((~! ..representation) (~ value))]
                     (: ((~! try.Try) (~ type))
                        (if (# (~! type.equivalence) (~' =)
                               (.type (~ type)) (~ g!type))
                          {try.#Success (:as (~ type) (~ g!value))}
                          ((~! exception.except) ..wrong_type [(.type (~ type)) (~ g!type)])))))))))

  (def: .public (format value)
    (-> Dynamic (Try Text))
    (let [[type value] (:representation value)]
      (debug.representation type value)))
  )
