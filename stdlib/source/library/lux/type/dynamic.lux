(.module:
  [library
   [lux #*
    ["." debug]
    [control
     ["." try (#+ Try)]
     ["." exception (#+ exception:)]
     [parser
      ["<.>" code]]]
    [data
     [text
      ["%" format]]]
    [macro (#+ with_identifiers)
     ["." syntax (#+ syntax:)]]
    ["." type
     abstract]]])

(exception: .public (wrong_type {expected Type} {actual Type})
  (exception.report
   ["Expected" (%.type expected)]
   ["Actual" (%.type actual)]))

(abstract: .public Dynamic
  {}

  [Type Any]

  (def: abstraction
    (-> [Type Any] Dynamic)
    (|>> :abstraction))
  
  (def: representation
    (-> Dynamic [Type Any])
    (|>> :representation))

  (syntax: .public (:dynamic [value <code>.any])
    (with_identifiers [g!value]
      (in (list (` (let [(~ g!value) (~ value)]
                     ((~! ..abstraction) [(:of (~ g!value)) (~ g!value)])))))))

  (syntax: .public (:static [type <code>.any
                             value <code>.any])
    (with_identifiers [g!type g!value]
      (in (list (` (let [[(~ g!type) (~ g!value)] ((~! ..representation) (~ value))]
                     (: ((~! try.Try) (~ type))
                        (if (\ (~! type.equivalence) (~' =)
                               (.type (~ type)) (~ g!type))
                          (#try.Success (:as (~ type) (~ g!value)))
                          ((~! exception.except) ..wrong_type [(.type (~ type)) (~ g!type)])))))))))

  (def: .public (format value)
    (-> Dynamic (Try Text))
    (let [[type value] (:representation value)]
      (debug.representation type value)))
  )
