(.module:
  [library
   [lux #*
    ["." meta]
    [abstract
     [monad (#+ Monad do)]
     [equivalence (#+ Equivalence)]
     [order (#+ Order)]
     [enum (#+ Enum)]]
    [control
     ["<>" parser ("#\." monad)
      ["<.>" code (#+ Parser)]]]
    [data
     [text
      ["%" format (#+ format)]]]
    [macro
     ["." code]
     [syntax (#+ syntax:)
      ["|.|" annotations]]]
    [math
     [number
      ["n" nat]
      ["i" int]
      ["." ratio (#+ Ratio)]]]
    [type
     abstract]]])

(abstract: .public (Qty unit)
  {}
  
  Int
  
  (def: in
    (All [unit] (-> Int (Qty unit)))
    (|>> :abstraction))

  (def: out
    (All [unit] (-> (Qty unit) Int))
    (|>> :representation))

  (template [<name> <op>]
    [(def: .public (<name> param subject)
       (All [unit] (-> (Qty unit) (Qty unit) (Qty unit)))
       (:abstraction (<op> (:representation param)
                           (:representation subject))))]

    [+ i.+]
    [- i.-]
    )

  (template [<name> <op> <p> <s> <p*s>]
    [(def: .public (<name> param subject)
       (All [p s] (-> (Qty <p>) (Qty <s>) (Qty <p*s>)))
       (:abstraction (<op> (:representation param)
                           (:representation subject))))]

    [* i.* p s [p s]]
    [/ i./ p [p s] s]
    )
  )

(interface: .public (Unit a)
  (: (-> Int (Qty a))
     in)
  (: (-> (Qty a) Int)
     out))

(interface: .public (Scale s)
  (: (All [u] (-> (Qty u) (Qty (s u))))
     scale)
  (: (All [u] (-> (Qty (s u)) (Qty u)))
     de_scale)
  (: Ratio
     ratio))

(type: .public Pure
  (Qty Any))

(def: .public pure
  (-> Int Pure)
  ..in)

(def: .public number
  (-> Pure Int)
  ..out)

(def: unitP
  (Parser [Code Text Text |annotations|.Annotations])
  (let [private ($_ <>.and
                    <code>.local_identifier
                    <code>.local_identifier
                    (<>.else |annotations|.empty |annotations|.parser))]
    (<>.either (<>.and <code>.any private)
               (<>.and (<>\in (` .private)) private))))

(syntax: .public (unit:
                   {[export_policy type_name unit_name annotations] ..unitP})
  (do meta.monad
    [@ meta.current_module_name
     .let [g!type (code.local_identifier type_name)]]
    (in (list (` (type: (~ export_policy) (~ g!type)
                   (~ (|annotations|.format annotations))
                   (primitive (~ (code.text (%.name [@ type_name]))))))

              (` (implementation: (~ export_policy) (~ (code.local_identifier unit_name))
                   (..Unit (~ g!type))

                   (def: (~' in) (~! ..in))
                   (def: (~' out) (~! ..out))))
              ))))

(def: scale
  (Parser Ratio)
  (<code>.tuple (do <>.monad
                  [numerator <code>.nat
                   _ (<>.assertion (format "Numerator must be positive: " (%.nat numerator))
                                   (n.> 0 numerator))
                   denominator <code>.nat
                   _ (<>.assertion (format "Denominator must be positive: " (%.nat denominator))
                                   (n.> 0 denominator))]
                  (in [numerator denominator]))))

(def: scaleP
  (Parser [Code Text Text Ratio |annotations|.Annotations])
  (let [private ($_ <>.and
                    <code>.local_identifier
                    <code>.local_identifier
                    ..scale
                    (<>.else |annotations|.empty |annotations|.parser))]
    (<>.either (<>.and <code>.any private)
               (<>.and (<>\in (` .private)) private))))

(syntax: .public (scale:
                   {[export_policy type_name scale_name ratio annotations] ..scaleP})
  (do meta.monad
    [.let [(^slots [#ratio.numerator #ratio.denominator]) ratio]
     @ meta.current_module_name
     .let [g!scale (code.local_identifier type_name)]]
    (in (list (` (type: (~ export_policy) ((~ g!scale) (~' u))
                   (~ (|annotations|.format annotations))
                   (primitive (~ (code.text (%.name [@ type_name]))) [(~' u)])))
              
              (` (implementation: (~ export_policy) (~ (code.local_identifier scale_name))
                   (..Scale (~ g!scale))
                   
                   (def: (~' scale)
                     (|>> ((~! ..out))
                          (i.* (~ (code.int (.int numerator))))
                          (i./ (~ (code.int (.int denominator))))
                          ((~! ..in))))
                   (def: (~' de_scale)
                     (|>> ((~! ..out))
                          (i.* (~ (code.int (.int denominator))))
                          (i./ (~ (code.int (.int numerator))))
                          ((~! ..in))))
                   (def: (~' ratio)
                     [(~ (code.nat numerator)) (~ (code.nat denominator))])))
              ))))

(def: .public (re_scaled from to quantity)
  (All [si so u] (-> (Scale si) (Scale so) (Qty (si u)) (Qty (so u))))
  (let [[numerator denominator] (ratio./ (\ from ratio)
                                         (\ to ratio))]
    (|> quantity
        out
        (i.* (.int numerator))
        (i./ (.int denominator))
        in)))

(scale: .public Kilo kilo [1         1,000])
(scale: .public Mega mega [1     1,000,000])
(scale: .public Giga giga [1 1,000,000,000])

(scale: .public Milli milli [        1,000 1])
(scale: .public Micro micro [    1,000,000 1])
(scale: .public Nano  nano  [1,000,000,000 1])

(unit: .public Gram gram)
(unit: .public Meter meter)
(unit: .public Litre litre)
(unit: .public Second second)

(implementation: .public equivalence
  (All [unit] (Equivalence (Qty unit)))
  
  (def: (= reference sample)
    (i.= (..out reference) (..out sample))))

(implementation: .public order
  (All [unit] (Order (Qty unit)))
  
  (def: &equivalence ..equivalence)
  
  (def: (< reference sample)
    (i.< (..out reference) (..out sample))))

(implementation: .public enum
  (All [unit] (Enum (Qty unit)))
  
  (def: &order ..order)
  (def: succ (|>> ..out inc ..in))
  (def: pred (|>> ..out dec ..in)))
