(.using
 [library
  [lux (.except)
   ["[0]" meta]
   [abstract
    [monad (.only Monad do)]
    [equivalence (.only Equivalence)]
    [order (.only Order)]
    [enum (.only Enum)]]
   [control
    ["<>" parser (.open: "[1]#[0]" monad)
     ["<[0]>" code (.only Parser)]]]
   [data
    ["[0]" text (.only)
     ["%" \\format (.only format)]]]
   [macro
    ["[0]" code]
    ["[0]" template]
    [syntax (.only syntax)
     ["|[0]|" export]]]
   [math
    [number
     ["n" nat]
     ["i" int]
     ["[0]" ratio (.only Ratio)]]]
   [type
    [primitive (.except)]]]])

(primitive: .public (Qty unit)
  Int
  
  (def: in'
    (All (_ unit) (-> Int (Qty unit)))
    (|>> abstraction))

  (def: out'
    (All (_ unit) (-> (Qty unit) Int))
    (|>> representation))

  (with_template [<name> <op>]
    [(def: .public (<name> param subject)
       (All (_ unit) (-> (Qty unit) (Qty unit) (Qty unit)))
       (abstraction (<op> (representation param)
                          (representation subject))))]

    [+ i.+]
    [- i.-]
    )

  (with_template [<name> <op> <p> <s> <p*s>]
    [(def: .public (<name> param subject)
       (All (_ p s) (-> (Qty <p>) (Qty <s>) (Qty <p*s>)))
       (abstraction (<op> (representation param)
                          (representation subject))))]

    [* i.* p s [p s]]
    [/ i./ p [p s] s]
    )
  )

(type: .public (Unit a)
  (Interface
   (is (-> Int (Qty a))
       in)
   (is (-> (Qty a) Int)
       out)))

(type: .public (Scale s)
  (Interface
   (is (All (_ u) (-> (Qty u) (Qty (s u))))
       scale)
   (is (All (_ u) (-> (Qty (s u)) (Qty u)))
       de_scale)
   (is Ratio
       ratio)))

(type: .public Pure
  (Qty Any))

(def: .public pure
  (-> Int Pure)
  ..in')

(def: .public number
  (-> Pure Int)
  ..out')

(def: .public unit:
  (syntax (_ [[export_policy type_name unit_name]
              (|export|.parser
               (all <>.and
                    <code>.local
                    <code>.local))])
    (do meta.monad
      [@ meta.current_module_name
       .let [g!type (code.local type_name)]]
      (in (list (` (type: (~ export_policy) (~ g!type)
                     (Primitive (~ (code.text (%.symbol [@ type_name]))))))

                (` (def: (~ export_policy) (~ (code.local unit_name))
                     (..Unit (~ g!type))
                     (implementation
                      (def: (~' in) (~! ..in'))
                      (def: (~' out) (~! ..out')))))
                )))))

(def: scaleP
  (Parser Ratio)
  (<code>.tuple (do <>.monad
                  [numerator <code>.nat
                   _ (<>.assertion (format "Numerator must be positive: " (%.nat numerator))
                                   (n.> 0 numerator))
                   denominator <code>.nat
                   _ (<>.assertion (format "Denominator must be positive: " (%.nat denominator))
                                   (n.> 0 denominator))]
                  (in [numerator denominator]))))

(def: .public scale:
  (syntax (_ [[export_policy type_name scale_name ratio]
              (|export|.parser
               (all <>.and
                    <code>.local
                    <code>.local
                    ..scaleP))])
    (do meta.monad
      [.let [(open "_[0]") ratio]
       @ meta.current_module_name
       .let [g!scale (code.local type_name)]]
      (in (list (` (type: (~ export_policy) ((~ g!scale) (~' u))
                     (Primitive (~ (code.text (%.symbol [@ type_name]))) [(~' u)])))
                
                (` (def: (~ export_policy) (~ (code.local scale_name))
                     (..Scale (~ g!scale))
                     (implementation
                      (def: (~' scale)
                        (|>> ((~! ..out'))
                             (i.* (~ (code.int (.int _#numerator))))
                             (i./ (~ (code.int (.int _#denominator))))
                             ((~! ..in'))))
                      (def: (~' de_scale)
                        (|>> ((~! ..out'))
                             (i.* (~ (code.int (.int _#denominator))))
                             (i./ (~ (code.int (.int _#numerator))))
                             ((~! ..in'))))
                      (def: (~' ratio)
                        [(~ (code.nat _#numerator))
                         (~ (code.nat _#denominator))]))))
                )))))

(def: .public (re_scaled from to quantity)
  (All (_ si so u) (-> (Scale si) (Scale so) (Qty (si u)) (Qty (so u))))
  (let [[numerator denominator] (ratio./ (at from ratio)
                                         (at to ratio))]
    (|> quantity
        out'
        (i.* (.int numerator))
        (i./ (.int denominator))
        in')))

(def: implementation_name
  (syntax (_ [type_name <code>.local])
    (in (list (code.local (text.lower_cased type_name))))))

(with_template [<type> <from> <to>]
  [(`` (scale: .public <type>
         (~~ (implementation_name <type>))
         [<from> <to>]))]

  [Kilo 1         1,000]
  [Mega 1     1,000,000]
  [Giga 1 1,000,000,000]

  [Milli 1,000         1]
  [Micro 1,000,000     1]
  [Nano  1,000,000,000 1]
  )

(with_template [<type>]
  [(`` (unit: .public <type>
         (~~ (implementation_name <type>))))]

  [Gram]
  [Meter]
  [Litre]
  [Second]
  )

(def: .public equivalence
  (All (_ unit) (Equivalence (Qty unit)))
  (implementation
   (def: (= reference sample)
     (i.= (..out' reference) (..out' sample)))))

(def: .public order
  (All (_ unit) (Order (Qty unit)))
  (implementation
   (def: equivalence ..equivalence)
   
   (def: (< reference sample)
     (i.< (..out' reference) (..out' sample)))))

(def: .public enum
  (All (_ unit) (Enum (Qty unit)))
  (implementation
   (def: order ..order)
   (def: succ (|>> ..out' ++ ..in'))
   (def: pred (|>> ..out' -- ..in'))))
