(.using
 [library
  [lux (.except)
   ["[0]" meta]
   ["[0]" type]
   [abstract
    ["[0]" monad (.only do)]]
   [control
    ["[0]" maybe]
    ["<>" parser (.open: "[1]#[0]" monad)
     ["<[0]>" type (.only Env)]
     ["<[0]>" code (.only Parser)]]]
   [data
    ["[0]" product]
    ["[0]" text]
    [collection
     ["[0]" list (.open: "[1]#[0]" functor)]
     ["[0]" dictionary]]]
   [macro (.only with_symbols)
    [syntax (.only syntax)]
    ["^" pattern]
    ["[0]" code]]
   [math
    [number
     ["n" nat]]]]])

(def: polyP
  (Parser [Code Text Code])
  (let [private (all <>.and
                     <code>.local
                     <code>.any)]
    (<>.either (<>.and <code>.any private)
               (<>.and (<>#in (` .private)) private))))

(def: .public poly:
  (syntax (_ [[export_policy name body] ..polyP])
    (with_symbols [g!_ g!type g!output]
      (let [g!name (code.symbol ["" name])]
        (in (.list (` (def: (~ export_policy) (~ g!name)
                        ((~! syntax) ((~ g!name) [(~ g!type) (~! <code>.any)])
                         ((~! do) (~! meta.monad)
                          [(~ g!type) ((~! meta.eval) .Type (~ g!type))]
                          (case (is (.Either .Text .Code)
                                    ((~! <type>.result) ((~! <>.rec)
                                                         (function ((~ g!_) (~ g!name))
                                                           (~ body)))
                                     (.as .Type (~ g!type))))
                            {.#Left (~ g!output)}
                            ((~! meta.failure) (~ g!output))

                            {.#Right (~ g!output)}
                            ((~' in) (.list (~ g!output))))))))))))))

(def: .public (code env type)
  (-> Env Type Code)
  (`` (case type
        {.#Primitive name params}
        (` {.#Primitive (~ (code.text name))
                        (.list (~+ (list#each (code env) params)))})

        (^.template [<tag>]
          [{<tag> idx}
           (` {<tag> (~ (code.nat idx))})])
        ([.#Var] [.#Ex])

        {.#Parameter idx}
        (let [idx (<type>.argument env idx)]
          (if (n.= 0 idx)
            (|> (dictionary.value idx env) maybe.trusted product.left (code env))
            (` (.$ (~ (code.nat (-- idx)))))))

        {.#Apply {.#Primitive "" {.#End}}
                 {.#Parameter idx}}
        (case (<type>.argument env idx)
          0 (|> env (dictionary.value 0) maybe.trusted product.left (code env))
          idx (undefined))
        
        (^.template [<tag>]
          [{<tag> left right}
           (` {<tag> (~ (code env left))
                     (~ (code env right))})])
        ([.#Function] [.#Apply])

        (^.template [<macro> <tag> <flattener>]
          [{<tag> left right}
           (` (<macro> (~+ (list#each (code env) (<flattener> type)))))])
        ([.Union .#Sum type.flat_variant]
         [.Tuple .#Product type.flat_tuple])

        {.#Named name sub_type}
        (code.symbol name)

        (^.template [<tag>]
          [{<tag> scope body}
           (` {<tag> (.list (~+ (list#each (code env) scope)))
                     (~ (code env body))})])
        ([.#UnivQ] [.#ExQ])
        )))
