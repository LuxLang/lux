(.module:
  [library
   [lux "*"
    ["." meta]
    ["." type]
    [abstract
     ["." monad {"+" [do]}]]
    [control
     ["." maybe]
     ["<>" parser ("#\." monad)
      ["<.>" type {"+" [Env]}]
      ["<.>" code {"+" [Parser]}]]]
    [data
     ["." product]
     ["." text]
     [collection
      ["." list ("#\." functor)]
      ["." dictionary]]]
    [macro {"+" [with_identifiers]}
     ["." code]
     [syntax {"+" [syntax:]}]]
    [math
     [number
      ["n" nat]]]]])

(def: polyP
  (Parser [Code Text Code])
  (let [private ($_ <>.and
                    <code>.local_identifier
                    <code>.any)]
    (<>.either (<>.and <code>.any private)
               (<>.and (<>\in (` .private)) private))))

(syntax: .public (poly: [[export_policy name body] ..polyP])
  (with_identifiers [g!_ g!type g!output]
    (let [g!name (code.identifier ["" name])]
      (in (.list (` ((~! syntax:) (~ export_policy) ((~ g!name) [(~ g!type) (~! <code>.identifier)])
                     ((~! do) (~! meta.monad)
                      [(~ g!type) ((~! meta.type_definition) (~ g!type))]
                      (case (: (.Either .Text .Code)
                               ((~! <type>.result) ((~! <>.rec)
                                                    (function ((~ g!_) (~ g!name))
                                                      (~ body)))
                                (~ g!type)))
                        (#.Left (~ g!output))
                        ((~! meta.failure) (~ g!output))

                        (#.Right (~ g!output))
                        ((~' in) (.list (~ g!output))))))))))))

(def: derivedP
  (Parser [Code Text [Name (List Name)] (Maybe Code)])
  (let [private ($_ <>.and
                    <code>.local_identifier
                    (<code>.form (<>.and <code>.identifier (<>.many <code>.identifier)))
                    (<>.maybe <code>.any))]
    (<>.either (<>.and <code>.any private)
               (<>.and (<>\in (` .private)) private))))

(syntax: .public (derived: [[export_policy name [poly_func poly_args] ?custom_impl] ..derivedP])
  (do [! meta.monad]
    [poly_args (monad.each ! meta.normal poly_args)
     .let [impl (case ?custom_impl
                  (#.Some custom_impl)
                  custom_impl

                  #.None
                  (` ((~ (code.identifier poly_func)) (~+ (list\each code.identifier poly_args)))))]]
    (in (.list (` (def: (~ export_policy) (~ (code.identifier ["" name]))
                    {#.implementation? #1}
                    (~ impl)))))))

(def: .public (code env type)
  (-> Env Type Code)
  (`` (case type
        (#.Primitive name params)
        (` (#.Primitive (~ (code.text name))
                        (.list (~+ (list\each (code env) params)))))

        (^template [<tag>]
          [(<tag> idx)
           (` (<tag> (~ (code.nat idx))))])
        ([#.Var] [#.Ex])

        (#.Parameter idx)
        (let [idx (<type>.adjusted_idx env idx)]
          (if (n.= 0 idx)
            (|> (dictionary.value idx env) maybe.trusted product.left (code env))
            (` (.$ (~ (code.nat (-- idx)))))))

        (#.Apply (#.Primitive "" #.End)
                 (#.Parameter idx))
        (case (<type>.adjusted_idx env idx)
          0 (|> env (dictionary.value 0) maybe.trusted product.left (code env))
          idx (undefined))
        
        (^template [<tag>]
          [(<tag> left right)
           (` (<tag> (~ (code env left))
                     (~ (code env right))))])
        ([#.Function] [#.Apply])

        (^template [<macro> <tag> <flattener>]
          [(<tag> left right)
           (` (<macro> (~+ (list\each (code env) (<flattener> type)))))])
        ([.Union #.Sum type.flat_variant]
         [.Tuple #.Product type.flat_tuple])

        (#.Named name sub_type)
        (code.identifier name)

        (^template [<tag>]
          [(<tag> scope body)
           (` (<tag> (.list (~+ (list\each (code env) scope)))
                     (~ (code env body))))])
        ([#.UnivQ] [#.ExQ])
        )))
