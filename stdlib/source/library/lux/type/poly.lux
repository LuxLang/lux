(.require
 [library
  [lux (.except)
   ["[0]" meta]
   [abstract
    ["[0]" monad (.only do)]]
   [control
    ["<>" parser (.use "[1]#[0]" monad)]
    ["[0]" maybe]]
   [data
    ["[0]" product]
    ["[0]" text]
    [collection
     ["[0]" list (.use "[1]#[0]" functor)]
     ["[0]" dictionary]]]
   [macro (.only with_symbols)
    [syntax (.only syntax)]
    ["^" pattern]
    ["[0]" code (.only)
     ["<[1]>" \\parser (.only Parser)]]]
   [math
    [number
     ["n" nat]]]
   ["[0]" type (.only)
    ["<[1]>" \\parser (.only Env)]]]])

(def .public polytypic
  (syntax (_ [name <code>.local
              body <code>.any])
    (with_symbols [g!_ g!type g!output]
      (let [g!name (code.symbol ["" name])]
        (in (.list (` ((~! syntax) ((~ g!_) [(~ g!type) (~! <code>.any)])
                       ((~! do) (~! meta.monad)
                        [(~ g!type) ((~! meta.eval) .Type (~ g!type))]
                        (case (is (.Either .Text .Code)
                                  ((~! <type>.result) ((~! <>.rec)
                                                       (function ((~ g!_) (~ g!name))
                                                         (~ body)))
                                   (.as .Type (~ g!type))))
                          {.#Right (~ g!output)}
                          ((~' in) (.list (~ g!output)))

                          {.#Left (~ g!output)}
                          ((~! meta.failure) (~ g!output))))))))))))

(def .public (code env type)
  (-> Env Type Code)
  (case type
    {.#Primitive name params}
    (` {.#Primitive (~ (code.text name))
                    (.list (~+ (list#each (code env) params)))})

    (^.with_template [<tag>]
      [{<tag> idx}
       (` {<tag> (~ (code.nat idx))})])
    ([.#Var] [.#Ex])

    {.#Parameter idx}
    (let [idx (<type>.argument env idx)]
      (if (n.= 0 idx)
        (|> (dictionary.value idx env) maybe.trusted product.left (code env))
        (` (.$ (~ (code.nat (-- idx)))))))

    {.#Apply {.#Primitive "" {.#End}}
             {.#Parameter idx}}
    (case (<type>.argument env idx)
      0 (|> env (dictionary.value 0) maybe.trusted product.left (code env))
      idx (undefined))
    
    (^.with_template [<tag>]
      [{<tag> left right}
       (` {<tag> (~ (code env left))
                 (~ (code env right))})])
    ([.#Function] [.#Apply])

    (^.with_template [<macro> <tag> <flattener>]
      [{<tag> left right}
       (` (<macro> (~+ (list#each (code env) (<flattener> type)))))])
    ([.Union .#Sum type.flat_variant]
     [.Tuple .#Product type.flat_tuple])

    {.#Named name sub_type}
    (code.symbol name)

    (^.with_template [<tag>]
      [{<tag> scope body}
       (` {<tag> (.list (~+ (list#each (code env) scope)))
                 (~ (code env body))})])
    ([.#UnivQ] [.#ExQ])))
