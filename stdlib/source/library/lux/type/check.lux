(.module:
  [library
   [lux "*"
    ["@" target]
    [abstract
     [functor {"+" [Functor]}]
     [apply {"+" [Apply]}]
     ["[0]" monad {"+" [Monad do]}]]
    [control
     ["[0]" maybe]
     ["[0]" try {"+" [Try]}]
     ["[0]" exception {"+" [Exception exception:]}]]
    [data
     ["[0]" product]
     ["[0]" text ("[1]#[0]" monoid equivalence)]
     [collection
      ["[0]" list]
      ["[0]" set {"+" [Set]}]]]
    [math
     [number
      ["n" nat ("[1]#[0]" decimal)]]]]]
  ["[0]" // ("[1]#[0]" equivalence)])

(template: (!n#= reference subject)
  [("lux i64 =" reference subject)])

(template: (!text#= reference subject)
  [("lux text =" reference subject)])

(exception: .public (unknown_type_var [id Nat])
  (exception.report
   ["ID" (n#encoded id)]))

(exception: .public (unbound_type_var [id Nat])
  (exception.report
   ["ID" (n#encoded id)]))

(exception: .public (invalid_type_application [funcT Type
                                               argT Type])
  (exception.report
   ["Type function" (//.format funcT)]
   ["Type argument" (//.format argT)]))

(exception: .public (cannot_rebind_var [id Nat
                                        type Type
                                        bound Type])
  (exception.report
   ["Var" (n#encoded id)]
   ["Wanted Type" (//.format type)]
   ["Current Type" (//.format bound)]))

(exception: .public (type_check_failed [expected Type
                                        actual Type])
  (exception.report
   ["Expected" (//.format expected)]
   ["Actual" (//.format actual)]))

(type: .public Var
  Nat)

(type: Assumption
  [Type Type])

(type: .public (Check a)
  (-> Type_Context (Try [Type_Context a])))

(type: (Checker a)
  (-> (List Assumption) a a (Check (List Assumption))))

(type: Type_Vars
  (List [Var (Maybe Type)]))

(implementation: .public functor
  (Functor Check)
  
  (def: (each f fa)
    (function (_ context)
      (case (fa context)
        {try.#Success [context' output]}
        {try.#Success [context' (f output)]}

        {try.#Failure error}
        {try.#Failure error}))))

(implementation: .public apply
  (Apply Check)
  
  (def: &functor ..functor)

  (def: (on fa ff)
    (function (_ context)
      (case (ff context)
        {try.#Success [context' f]}
        (case (fa context')
          {try.#Success [context'' a]}
          {try.#Success [context'' (f a)]}

          {try.#Failure error}
          {try.#Failure error})

        {try.#Failure error}
        {try.#Failure error}
        )))
  )

(implementation: .public monad
  (Monad Check)
  
  (def: &functor ..functor)

  (def: (in x)
    (function (_ context)
      {try.#Success [context x]}))

  (def: (conjoint ffa)
    (function (_ context)
      (case (ffa context)
        {try.#Success [context' fa]}
        (case (fa context')
          {try.#Success [context'' a]}
          {try.#Success [context'' a]}

          {try.#Failure error}
          {try.#Failure error})

        {try.#Failure error}
        {try.#Failure error}
        )))
  )

(open: "check#[0]" ..monad)

(def: (var::new id plist)
  (-> Var Type_Vars Type_Vars)
  {.#Item [id {.#None}] plist})

(def: (var::get id plist)
  (-> Var Type_Vars (Maybe (Maybe Type)))
  (case plist
    {.#Item [var_id var_type]
            plist'}
    (if (!n#= id var_id)
      {.#Some var_type}
      (var::get id plist'))

    {.#End}
    {.#None}))

(def: (var::put id value plist)
  (-> Var (Maybe Type) Type_Vars Type_Vars)
  (case plist
    {.#End}
    (list [id value])

    {.#Item [var_id var_type]
            plist'}
    (if (!n#= id var_id)
      {.#Item [var_id value]
              plist'}
      {.#Item [var_id var_type]
              (var::put id value plist')})))

(def: .public (result context proc)
  (All (_ a) (-> Type_Context (Check a) (Try a)))
  (case (proc context)
    {try.#Success [context' output]}
    {try.#Success output}

    {try.#Failure error}
    {try.#Failure error}))

(def: .public (failure message)
  (All (_ a) (-> Text (Check a)))
  (function (_ context)
    {try.#Failure message}))

(def: .public (assertion message test)
  (-> Text Bit (Check Any))
  (function (_ context)
    (if test
      {try.#Success [context []]}
      {try.#Failure message})))

(def: .public (except exception message)
  (All (_ e a) (-> (Exception e) e (Check a)))
  (..failure (exception.error exception message)))

(def: .public existential
  (Check [Nat Type])
  (function (_ context)
    (let [id (value@ .#ex_counter context)]
      {try.#Success [(revised@ .#ex_counter ++ context)
                     [id {.#Ex id}]]})))

(template [<name> <outputT> <fail> <succeed>]
  [(def: .public (<name> id)
     (-> Var (Check <outputT>))
     (function (_ context)
       (case (|> context (value@ .#var_bindings) (var::get id))
         (^or {.#Some {.#Some {.#Var _}}}
              {.#Some {.#None}})
         {try.#Success [context <fail>]}
         
         {.#Some {.#Some bound}}
         {try.#Success [context <succeed>]}

         {.#None}
         (exception.except ..unknown_type_var id))))]

  [bound? Bit          false    true]
  [peek   (Maybe Type) {.#None} {.#Some bound}]
  )

(def: .public (read id)
  (-> Var (Check Type))
  (do ..monad
    [?type (peek id)]
    (case ?type
      {.#Some type}
      (in type)

      {.#None}
      (..except ..unbound_type_var id))))

(def: (bound id)
  (-> Var (Check Type))
  (function (_ context)
    (case (|> context (value@ .#var_bindings) (var::get id))
      {.#Some {.#Some bound}}
      {try.#Success [context bound]}

      {.#Some _}
      (exception.except ..unbound_type_var id)

      _
      (exception.except ..unknown_type_var id))))

(def: .public (bind type id)
  (-> Type Var (Check Any))
  (function (_ context)
    (case (|> context (value@ .#var_bindings) (var::get id))
      {.#Some {.#None}}
      {try.#Success [(revised@ .#var_bindings (var::put id {.#Some type}) context)
                     []]}

      {.#Some {.#Some bound}}
      (exception.except ..cannot_rebind_var [id type bound])
      
      _
      (exception.except ..unknown_type_var id))))

(def: (re_bind type id)
  (-> Type Var (Check Any))
  (function (_ context)
    (case (|> context (value@ .#var_bindings) (var::get id))
      {.#Some _}
      {try.#Success [(revised@ .#var_bindings (var::put id {.#Some type}) context)
                     []]}
      
      _
      (exception.except ..unknown_type_var id))))

(def: .public var
  (Check [Var Type])
  (function (_ context)
    (let [id (value@ .#var_counter context)]
      {try.#Success [(|> context
                         (revised@ .#var_counter ++)
                         (revised@ .#var_bindings (var::new id)))
                     [id {.#Var id}]]})))

(def: (on argT funcT)
  (-> Type Type (Check Type))
  (case funcT
    {.#Var func_id}
    (do ..monad
      [?funcT' (peek func_id)]
      (case ?funcT'
        {.#Some funcT'}
        (on argT funcT')

        _
        (except ..invalid_type_application [funcT argT])))

    {.#Apply argT' funcT'}
    (do ..monad
      [funcT'' (on argT' funcT')]
      (on argT funcT''))

    _
    (case (//.applied (list argT) funcT)
      {.#Some output}
      (check#in output)

      _
      (except ..invalid_type_application [funcT argT]))))

(type: Ring
  (Set Var))

(def: empty_ring
  Ring
  (set.empty n.hash))

... TODO: Optimize this by not using sets anymore.
(def: (ring start)
  (-> Var (Check Ring))
  (function (_ context)
    (loop [current start
           output (set.has start empty_ring)]
      (case (|> context (value@ .#var_bindings) (var::get current))
        {.#Some {.#Some type}}
        (case type
          {.#Var post}
          (if (!n#= start post)
            {try.#Success [context output]}
            (recur post (set.has post output)))
          
          _
          {try.#Success [context empty_ring]})

        {.#Some {.#None}}
        {try.#Success [context output]}
        
        {.#None}
        (exception.except ..unknown_type_var current)))))

(def: .public fresh_context
  Type_Context
  [.#var_counter 0
   .#ex_counter 0
   .#var_bindings (list)])

(def: (attempt op)
  (All (_ a) (-> (Check a) (Check (Maybe a))))
  (function (_ context)
    (case (op context)
      {try.#Success [context' output]}
      {try.#Success [context' {.#Some output}]}

      {try.#Failure _}
      {try.#Success [context {.#None}]})))

(def: (either left right)
  (All (_ a) (-> (Check a) (Check a) (Check a)))
  (function (_ context)
    (case (left context)
      {try.#Failure _}
      (right context)

      output
      output)))

(def: (assumed? [e a] assumptions)
  (-> Assumption (List Assumption) Bit)
  (list.any? (function (_ [e' a'])
               (and (//#= e e')
                    (//#= a a')))
             assumptions))

... TODO: "if_can_bind" can be optimized...
(def: (if_can_bind id type then else)
  (All (_ a)
    (-> Var Type (Check a) (-> Type (Check a))
        (Check a)))
  ($_ either
      (do ..monad
        [_ (..bind type id)]
        then)
      (do [! ..monad]
        [ring (..ring id)
         _ (..assertion "" (n.> 1 (set.size ring)))
         _ (monad.each ! (re_bind type) (set.list ring))]
        then)
      (do ..monad
        [?bound (peek id)]
        (else (maybe.else {.#Var id} ?bound)))))

... TODO: "link/2" can be optimized...
(def: (link/2 left right)
  (-> Var Var (Check Any))
  (do ..monad
    [_ (..bind {.#Var right} left)]
    (..bind {.#Var left} right)))

... TODO: "link/3" can be optimized...
(def: (link/3 interpose to from)
  (-> Var Var Var (Check Any))
  (do ..monad
    [_ (re_bind {.#Var interpose} from)]
    (re_bind {.#Var to} interpose)))

... TODO: "check_vars" can be optimized...
(def: (check_vars check' assumptions idE idA)
  (-> (Checker Type) (Checker Var))
  (if (!n#= idE idA)
    (check#in assumptions)
    (do [! ..monad]
      [ebound (attempt (..bound idE))
       abound (attempt (..bound idA))]
      (case [ebound abound]
        ... Link the 2 variables circularly
        [{.#None} {.#None}]
        (do !
          [_ (link/2 idE idA)]
          (in assumptions))

        ... Interpose new variable between 2 existing links
        [{.#Some etype} {.#None}]
        (case etype
          {.#Var targetE}
          (do !
            [_ (link/3 idA targetE idE)]
            (in assumptions))

          _
          (check' assumptions etype {.#Var idA}))

        ... Interpose new variable between 2 existing links
        [{.#None} {.#Some atype}]
        (case atype
          {.#Var targetA}
          (do !
            [_ (link/3 idE targetA idA)]
            (in assumptions))

          _
          (check' assumptions {.#Var idE} atype))

        [{.#Some etype} {.#Some atype}]
        (case [etype atype]
          [{.#Var targetE} {.#Var targetA}]
          (do !
            [ringE (..ring idE)
             ringA (..ring idA)]
            (if (# set.equivalence = ringE ringA)
              (in assumptions)
              ... Fuse 2 rings
              (do !
                [_ (monad.mix ! (function (_ interpose to)
                                  (do !
                                    [_ (link/3 interpose to idE)]
                                    (in interpose)))
                              targetE
                              (set.list ringA))]
                (in assumptions))))

          (^template [<pattern> <id> <type>]
            [<pattern>
             (do !
               [ring (..ring <id>)
                _ (monad.each ! (re_bind <type>) (set.list ring))]
               (in assumptions))])
          ([[{.#Var _} _] idE atype]
           [[_ {.#Var _}] idA etype])
          
          _
          (check' assumptions etype atype))))))

(def: silent_failure!
  (All (_ a) (Check a))
  (..failure ""))

... TODO: "check_apply" can be optimized...
(def: (check_apply check' assumptions expected actual)
  (-> (Checker Type) (Checker [Type Type]))
  (let [[expected_input expected_function] expected
        [actual_input actual_function] actual]
    (case [expected_function actual_function]
      [{.#Ex exE} {.#Ex exA}]
      (if (!n#= exE exA)
        (check' assumptions expected_input actual_input)
        ..silent_failure!)

      [{.#UnivQ _ _} {.#Ex _}]
      (do ..monad
        [expected' (..on expected_input expected_function)]
        (check' assumptions expected' {.#Apply actual}))

      [{.#Ex _} {.#UnivQ _ _}]
      (do ..monad
        [actual' (..on actual_input actual_function)]
        (check' assumptions {.#Apply expected} actual'))

      [{.#Apply [expected_input' expected_function']} {.#Ex _}]
      (do ..monad
        [expected_function'' (..on expected_input' expected_function')]
        (check' assumptions {.#Apply [expected_input expected_function'']} {.#Apply actual}))

      [{.#Ex _} {.#Apply [actual_input' actual_function']}]
      (do ..monad
        [actual_function'' (..on actual_input' actual_function')]
        (check' assumptions {.#Apply expected} {.#Apply [actual_input actual_function'']}))

      (^or [{.#Ex _} _] [_ {.#Ex _}])
      (do ..monad
        [assumptions (check' assumptions expected_function actual_function)]
        (check' assumptions expected_input actual_input))

      [{.#Var id} _]
      (function (_ context)
        (case ((do ..monad
                 [expected_function' (..read id)]
                 (check' assumptions {.#Apply expected_input expected_function'} {.#Apply actual}))
               context)
          {try.#Success output}
          {try.#Success output}

          {try.#Failure _}
          (case actual_function
            {.#UnivQ _ _}
            ((do ..monad
               [actual' (..on actual_input actual_function)]
               (check' assumptions {.#Apply expected} actual'))
             context)
            
            {.#Ex exA}
            ((do ..monad
               [assumptions (check' assumptions expected_function actual_function)]
               (check' assumptions expected_input actual_input))
             context)

            _
            ((do ..monad
               [assumptions (check' assumptions expected_function actual_function)
                expected' (..on expected_input actual_function)
                actual' (..on actual_input actual_function)]
               (check' assumptions expected' actual'))
             context))))

      [_ {.#Var id}]
      (function (_ context)
        (case ((do ..monad
                 [actual_function' (read id)]
                 (check' assumptions {.#Apply expected} {.#Apply actual_input actual_function'}))
               context)
          {try.#Success output}
          {try.#Success output}

          _
          ((do ..monad
             [assumptions (check' assumptions expected_function actual_function)
              expected' (..on expected_input expected_function)
              actual' (..on actual_input expected_function)]
             (check' assumptions expected' actual'))
           context)))

      _
      ..silent_failure!)))

(def: (with exception parameter check)
  (All (_ e a) (-> (Exception e) e (Check a) (Check a)))
  (|>> check
       (exception.with exception parameter)))

... TODO: "check'" can be optimized...
... Type-check to ensure that the 'expected' type subsumes the 'actual' type.
(def: (check' assumptions expected actual)
  (Checker Type)
  (if (for [... TODO: Remove this once JPHP is gone.
            @.php false]
           (same? expected actual))
    (check#in assumptions)
    (with ..type_check_failed [expected actual]
      (case [expected actual]
        [{.#Var idE} {.#Var idA}]
        (check_vars check' assumptions idE idA)
        
        [{.#Var id} _]
        (if_can_bind id actual
                     (check#in assumptions)
                     (function (_ bound)
                       (check' assumptions bound actual)))
        
        [_ {.#Var id}]
        (if_can_bind id expected
                     (check#in assumptions)
                     (function (_ bound)
                       (check' assumptions expected bound)))

        (^template [<fE> <fA>]
          [[{.#Apply aE <fE>} {.#Apply aA <fA>}]
           (check_apply check' assumptions [aE <fE>] [aA <fA>])])
        ([F1 {.#Ex ex}]
         [{.#Ex exE} fA]
         [fE {.#Var idA}]
         [{.#Var idE} fA])
        
        [{.#Apply A F} _]
        (let [new_assumption [expected actual]]
          (if (assumed? new_assumption assumptions)
            (check#in assumptions)
            (do ..monad
              [expected' (..on A F)]
              (check' {.#Item new_assumption assumptions} expected' actual))))

        [_ {.#Apply A F}]
        (do ..monad
          [actual' (..on A F)]
          (check' assumptions expected actual'))

        ... TODO: Refactor-away as cold-code
        (^template [<tag> <instancer>]
          [[{<tag> _} _]
           (do ..monad
             [[_ paramT] <instancer>
              expected' (..on paramT expected)]
             (check' assumptions expected' actual))])
        ([.#UnivQ ..existential]
         [.#ExQ ..var])

        ... TODO: Refactor-away as cold-code
        (^template [<tag> <instancer>]
          [[_ {<tag> _}]
           (do ..monad
             [[_ paramT] <instancer>
              actual' (..on paramT actual)]
             (check' assumptions expected actual'))])
        ([.#UnivQ ..var]
         [.#ExQ ..existential])

        [{.#Primitive e_name e_params} {.#Primitive a_name a_params}]
        (if (!text#= e_name a_name)
          (loop [assumptions assumptions
                 e_params e_params
                 a_params a_params]
            (case [e_params a_params]
              [{.#End} {.#End}]
              (check#in assumptions)
              
              [{.#Item e_head e_tail} {.#Item a_head a_tail}]
              (do ..monad
                [assumptions' (check' assumptions e_head a_head)]
                (recur assumptions' e_tail a_tail))

              _
              ..silent_failure!))
          ..silent_failure!)

        (^template [<composite>]
          [[{<composite> eL eR} {<composite> aL aR}]
           (do ..monad
             [assumptions (check' assumptions eL aL)]
             (check' assumptions eR aR))])
        ([.#Sum]
         [.#Product])
        
        [{.#Function eI eO} {.#Function aI aO}]
        (do ..monad
          [assumptions (check' assumptions aI eI)]
          (check' assumptions eO aO))

        [{.#Ex e!id} {.#Ex a!id}]
        (if (!n#= e!id a!id)
          (check#in assumptions)
          ..silent_failure!)

        [{.#Named _ ?etype} _]
        (check' assumptions ?etype actual)

        [_ {.#Named _ ?atype}]
        (check' assumptions expected ?atype)

        _
        ..silent_failure!))))

(def: .public (check expected actual)
  (-> Type Type (Check Any))
  (check' (list) expected actual))

(def: .public (subsumes? expected actual)
  (-> Type Type Bit)
  (case (..result ..fresh_context
                  (..check expected actual))
    {try.#Failure _}
    false

    {try.#Success _}
    true))

(def: .public context
  (Check Type_Context)
  (function (_ context)
    {try.#Success [context context]}))

(def: .public (clean inputT)
  (-> Type (Check Type))
  (case inputT
    {.#Primitive name paramsT+}
    (|> paramsT+
        (monad.each ..monad clean)
        (check#each (|>> {.#Primitive name})))

    (^or {.#Parameter _} {.#Ex _} {.#Named _})
    (check#in inputT)

    (^template [<tag>]
      [{<tag> leftT rightT}
       (do ..monad
         [leftT' (clean leftT)]
         (|> (clean rightT)
             (check#each (|>> {<tag> leftT'}))))])
    ([.#Sum] [.#Product] [.#Function] [.#Apply])

    {.#Var id}
    (do ..monad
      [?actualT (peek id)]
      (case ?actualT
        {.#Some actualT}
        (clean actualT)

        _
        (in inputT)))

    (^template [<tag>]
      [{<tag> envT+ unquantifiedT}
       (do [! ..monad]
         [envT+' (monad.each ! clean envT+)]
         (in {<tag> envT+' unquantifiedT}))])
    ([.#UnivQ] [.#ExQ])
    ))
