(.module:
  [library
   [lux #*
    ["." meta]
    [abstract
     ["." monad (#+ Monad do)
      [indexed (#+ IxMonad)]]]
    [control
     ["." exception (#+ exception:)]
     ["<>" parser
      ["<.>" code (#+ Parser)]]]
    [data
     ["." maybe]
     [text
      ["%" format (#+ format)]]
     [collection
      ["." set]
      ["." row (#+ Row)]
      ["." list ("#\." functor fold)]]]
    ["." macro
     [syntax (#+ syntax:)]]
    [math
     [number
      ["n" nat]]]
    [type
     abstract]]])

(type: .public (Procedure monad input output value)
  {#.doc (doc "A computation that takes a sequence of resource access rights as inputs and yields a different sequence as outputs."
              "A procedure yields a result value."
              "A procedure can make use of monadic effects.")}
  (-> input (monad [output value])))

(type: .public (Linear monad value)
  {#.doc (doc "A procedure that is constant with regards to resource access rights."
              "This means no additional resources will be available after the computation is over."
              "This also means no previously available resources will have been consumed.")}
  (All [keys]
    (Procedure monad keys keys value)))

(type: .public (Affine monad permissions value)
  {#.doc (doc "A procedure which expands the number of available resources.")}
  (All [keys]
    (Procedure monad keys [permissions keys] value)))

(type: .public (Relevant monad permissions value)
  {#.doc (doc "A procedure which reduces the number of available resources.")}
  (All [keys]
    (Procedure monad [permissions keys] keys value)))

(implementation: .public (monad monad)
  (All [!] (-> (Monad !) (IxMonad (Procedure !))))
  
  (def: (in value)
    (function (_ keys)
      (\ monad in [keys value])))

  (def: (bind f input)
    (function (_ keysI)
      (do monad
        [[keysT value] (input keysI)]
        ((f value) keysT)))))

(def: .public (run monad procedure)
  (All [! v] (-> (Monad !) (Linear ! v) (! v)))
  (do monad
    [[_ output] (procedure [])]
    (in output)))

(def: .public (lifted monad procedure)
  (All [! v] (-> (Monad !) (! v) (Linear ! v)))
  (function (_ keys)
    (do monad
      [output procedure]
      (in [keys output]))))

(abstract: .public Ordered
  {#.doc (doc "The mode of keys which CANNOT be swapped, and for whom order of release/consumption matters.")}
  Any)

(abstract: .public Commutative
  {#.doc (doc "The mode of keys which CAN be swapped, and for whom order of release/consumption DOES NOT matters.")}
  Any)

(abstract: .public (Key mode key)
  {#.doc (doc "The access right for a resource."
              "Without the key for a resource existing somewhere among the available ambient rights, one cannot use a resource.")}
  
  Any

  (template [<name> <mode>]
    [(def: <name>
       (Ex [k] (-> Any (Key <mode> k)))
       (|>> :abstraction))]

    [ordered_key     Ordered]
    [commutative_key Commutative]
    ))

(abstract: .public (Res key value)
  {#.doc (doc "A resource locked by a key."
              "The 'key' represents the right to access/consume a resource.")}

  value

  (template [<name> <mode> <key>]
    [(def: .public (<name> monad value)
       {#.doc (doc "Makes a value into a resource and adds the key/access-right to it to the ambient keyring for future use.")}
       (All [! v] (Ex [k] (-> (Monad !) v (Affine ! (Key <mode> k) (Res k v)))))
       (function (_ keys)
         (\ monad in [[(<key> []) keys] (:abstraction value)])))]

    [ordered     Ordered     ..ordered_key]
    [commutative Commutative ..commutative_key]
    )

  (def: .public (read monad resource)
    {#.doc (doc "Access the value of a resource, so long as its key is available.")}
    (All [! v k m]
      (-> (Monad !) (Res k v) (Relevant ! (Key m k) v)))
    (function (_ [key keys])
      (\  monad in [keys (:representation resource)])))
  )

(exception: .public (index_cannot_be_repeated {index Nat})
  (exception.report
   ["Index" (%.nat index)]))

(exception: .public amount_cannot_be_zero)

(def: indices
  (Parser (List Nat))
  (<code>.tuple (loop [seen (set.empty n.hash)]
                  (do {! <>.monad}
                    [done? <code>.end?]
                    (if done?
                      (in (list))
                      (do !
                        [head <code>.nat
                         _ (<>.assertion (exception.error ..index_cannot_be_repeated head)
                                         (not (set.member? seen head)))
                         tail (recur (set.add head seen))]
                        (in (list& head tail))))))))

(def: (no_op monad)
  (All [m] (-> (Monad m) (Linear m Any)))
  (function (_ context)
    (\ monad in [context []])))

(syntax: .public (exchange {swaps ..indices})
  {#.doc (doc "A function that can exchange the keys for resource, so long as they are commutative."
              "This keys will be placed at the front of the keyring in the order they are specified."
              "The specific keys must be specified based of their index into the current keyring."
              (do (..monad !)
                [res|left (/.commutative ! pre)
                 res|right (/.commutative ! post)
                 _ ((/.exchange [1 0]) !)
                 left (/.read ! res|left)
                 right (/.read ! res|right)]
                (in (format left right))))}
  (macro.with_gensyms [g!_ g!context g!!]
    (case swaps
      #.End
      (in (list (` (~! no_op))))

      (#.Item head tail)
      (do {! meta.monad}
        [.let [max_idx (list\fold n.max head tail)]
         g!inputs (<| (monad.seq !) (list.repeated (inc max_idx)) (macro.gensym "input"))
         .let [g!outputs (|> (monad.fold maybe.monad
                                         (function (_ from to)
                                           (do maybe.monad
                                             [input (list.item from g!inputs)]
                                             (in (row.add input to))))
                                         (: (Row Code) row.empty)
                                         swaps)
                             maybe.assume
                             row.list)
               g!inputsT+ (list\map (|>> (~) (..Key ..Commutative) (`)) g!inputs)
               g!outputsT+ (list\map (|>> (~) (..Key ..Commutative) (`)) g!outputs)]]
        (in (list (` (: (All [(~ g!!) (~+ g!inputs) (~ g!context)]
                          (-> ((~! monad.Monad) (~ g!!))
                              (Procedure (~ g!!)
                                         [(~+ g!inputsT+) (~ g!context)]
                                         [(~+ g!outputsT+) (~ g!context)]
                                         .Any)))
                        (function ((~ g!_) (~ g!!) [(~+ g!inputs) (~ g!context)])
                          (\ (~ g!!) (~' in) [[(~+ g!outputs) (~ g!context)] []]))))))))))

(def: amount
  (Parser Nat)
  (do <>.monad
    [raw <code>.nat
     _ (<>.assertion (exception.error ..amount_cannot_be_zero [])
                     (n.> 0 raw))]
    (in raw)))

(template [<name> <from> <to>]
  [(syntax: .public (<name> {amount ..amount})
     {#.doc (doc "Group/un-group keys in the keyring into/out-of tuples."
                 (do (..monad !)
                   [res|left (/.commutative ! pre)
                    res|right (/.commutative ! post)
                    _ ((/.group 2) !)
                    _ ((/.un_group 2) !)
                    right (/.read ! res|right)
                    left (/.read ! res|left)]
                   (in (format left right))))}
     (macro.with_gensyms [g!_ g!context g!!]
       (do {! meta.monad}
         [g!keys (|> (macro.gensym "keys")
                     (list.repeated amount)
                     (monad.seq !))]
         (in (list (` (: (All [(~ g!!) (~+ g!keys) (~ g!context)]
                           (-> ((~! monad.Monad) (~ g!!))
                               (Procedure (~ g!!)
                                          [<from> (~ g!context)]
                                          [<to> (~ g!context)]
                                          .Any)))
                         (function ((~ g!_) (~ g!!) [<from> (~ g!context)])
                           (\ (~ g!!) (~' in) [[<to> (~ g!context)] []])))))))))]

  [group    (~+ g!keys)   [(~+ g!keys)]]
  [un_group [(~+ g!keys)] (~+ g!keys)]
  )
