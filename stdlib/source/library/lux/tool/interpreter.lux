(.module:
  [library
   [lux #*
    [control
     [monad (#+ Monad do)]
     ["." try (#+ Try)]
     ["ex" exception (#+ exception:)]]
    [data
     ["." text ("#\." equivalence)
      ["%" format (#+ format)]]]
    [type (#+ :sharing)
     ["." check]]
    [compiler
     ["." phase
      ["." analysis
       ["." module]
       ["." type]]
      ["." generation]
      ["." directive (#+ State+ Operation)
       ["." total]]
      ["." extension]]
     ["." default
      ["." syntax]
      ["." platform (#+ Platform)]
      ["." init]]
     ["." cli (#+ Configuration)]]
    [world
     ["." file (#+ File)]
     ["." console (#+ Console)]]]]
  ["." /type])

(exception: #export (error {message Text})
  message)

(def: #export module "<INTERPRETER>")

(def: fresh_source
  Source
  [[..module 1 0] 0 ""])

(def: (add_line line [where offset input])
  (-> Text Source Source)
  [where offset (format input text.new_line line)])

(def: exit_command
  Text
  "exit")

(def: welcome_message
  Text
  (format text.new_line
          "Welcome to the interpreter!" text.new_line
          "Type '" ..exit_command "' to leave." text.new_line
          text.new_line))

(def: farewell_message
  Text
  "Till next time...")

(def: enter_module
  (All [anchor expression directive]
    (Operation anchor expression directive Any))
  (directive.lift_analysis
   (do phase.monad
     [_ (module.create 0 ..module)]
     (analysis.set_current_module ..module))))

(def: (initialize Monad<!> Console<!> platform configuration generation_bundle)
  (All [! anchor expression directive]
    (-> (Monad !)
        (Console !) (Platform ! anchor expression directive)
        Configuration
        (generation.Bundle anchor expression directive)
        (! (State+ anchor expression directive))))
  (do Monad<!>
    [state (platform.initialize platform generation_bundle)
     state (platform.compile platform
                             (set@ #cli.module syntax.prelude configuration)
                             (set@ [#extension.state
                                    #directive.analysis #directive.state
                                    #extension.state
                                    #.info #.mode]
                                   #.Interpreter
                                   state))
     [state _] (\ (get@ #platform.file_system platform)
                  lift (phase.run' state enter_module))
     _ (\ Console<!> write ..welcome_message)]
    (in state)))

(with_expansions [<Interpretation> (as_is (Operation anchor expression directive [Type Any]))]
  
  (def: (interpret_directive code)
    (All [anchor expression directive]
      (-> Code <Interpretation>))
    (do phase.monad
      [_ (total.phase code)
       _ init.refresh]
      (in [Any []])))

  (def: (interpret_expression code)
    (All [anchor expression directive]
      (-> Code <Interpretation>))
    (do {! phase.monad}
      [state (extension.lift phase.get_state)
       #let [analyse (get@ [#directive.analysis #directive.phase] state)
             synthesize (get@ [#directive.synthesis #directive.phase] state)
             generate (get@ [#directive.generation #directive.phase] state)]
       [_ codeT codeA] (directive.lift_analysis
                        (analysis.with_scope
                          (type.with_fresh_env
                            (do !
                              [[codeT codeA] (type.with_inference
                                               (analyse code))
                               codeT (type.with_env
                                       (check.clean codeT))]
                              (in [codeT codeA])))))
       codeS (directive.lift_synthesis
              (synthesize codeA))]
      (directive.lift_generation
       (generation.with_buffer
         (do !
           [codeH (generate codeS)
            count generation.next
            codeV (generation.evaluate! (format "interpretation_" (%.nat count)) codeH)]
           (in [codeT codeV]))))))

  (def: (interpret configuration code)
    (All [anchor expression directive]
      (-> Configuration Code <Interpretation>))
    (function (_ state)
      (case (<| (phase.run' state)
                (:sharing [anchor expression directive]
                          {(State+ anchor expression directive)
                           state}
                          {<Interpretation>
                           (interpret_directive code)}))
        (#try.Success [state' output])
        (#try.Success [state' output])

        (#try.Failure error)
        (if (ex.match? total.not_a_directive error)
          (<| (phase.run' state)
              (:sharing [anchor expression directive]
                        {(State+ anchor expression directive)
                         state}
                        {<Interpretation>
                         (interpret_expression code)}))
          (#try.Failure error)))))
  )

(def: (execute configuration code)
  (All [anchor expression directive]
    (-> Configuration Code (Operation anchor expression directive Text)))
  (do phase.monad
    [[codeT codeV] (interpret configuration code)
     state phase.get_state]
    (in (/type.represent (get@ [#extension.state
                                #directive.analysis #directive.state
                                #extension.state]
                               state)
                         codeT
                         codeV))))

(type: (Context anchor expression directive)
  {#configuration Configuration
   #state (State+ anchor expression directive)
   #source Source})

(with_expansions [<Context> (as_is (Context anchor expression directive))]
  (def: (read_eval_print context)
    (All [anchor expression directive]
      (-> <Context> (Try [<Context> Text])))
    (do try.monad
      [#let [[_where _offset _code] (get@ #source context)]
       [source' input] (syntax.parse ..module syntax.no_aliases (text.size _code) (get@ #source context))
       [state' representation] (let [## TODO: Simplify ASAP
                                     state (:sharing [anchor expression directive]
                                                     {<Context>
                                                      context}
                                                     {(State+ anchor expression directive)
                                                      (get@ #state context)})]
                                 (<| (phase.run' state)
                                     ## TODO: Simplify ASAP
                                     (:sharing [anchor expression directive]
                                               {<Context>
                                                context}
                                               {(Operation anchor expression directive Text)
                                                (execute (get@ #configuration context) input)})))]
      (in [(|> context
               (set@ #state state')
               (set@ #source source'))
           representation]))))

(def: #export (run Monad<!> Console<!> platform configuration generation_bundle)
  (All [! anchor expression directive]
    (-> (Monad !)
        (Console !) (Platform ! anchor expression directive)
        Configuration
        (generation.Bundle anchor expression directive)
        (! Any)))
  (do {! Monad<!>}
    [state (initialize Monad<!> Console<!> platform configuration)]
    (loop [context {#configuration configuration
                    #state state
                    #source ..fresh_source}
           multi_line? #0]
      (do !
        [_ (if multi_line?
             (\ Console<!> write "  ")
             (\ Console<!> write "> "))
         line (\ Console<!> read_line)]
        (if (and (not multi_line?)
                 (text\= ..exit_command line))
          (\ Console<!> write ..farewell_message)
          (case (read_eval_print (update@ #source (add_line line) context))
            (#try.Success [context' representation])
            (do !
              [_ (\ Console<!> write representation)]
              (recur context' #0))

            (#try.Failure error)
            (if (ex.match? syntax.end_of_file error)
              (recur context #1)
              (exec (log! (ex.error ..error error))
                (recur (set@ #source ..fresh_source context) #0))))))
      )))
