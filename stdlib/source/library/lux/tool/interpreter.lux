(.module:
  [library
   [lux "*"
    [control
     [monad {"+" Monad do}]
     ["[0]" try {"+" Try}]
     ["ex" exception {"+" exception:}]]
    [data
     ["[0]" text ("[1]#[0]" equivalence)
      ["%" format {"+" format}]]]
    [type {"+" :sharing}
     ["[0]" check]]
    [compiler
     ["[0]" phase
      ["[0]" analysis
       ["[0]" module]
       ["[0]" type]]
      ["[0]" generation]
      ["[0]" directive {"+" State+ Operation}
       ["[0]" total]]
      ["[0]" extension]]
     ["[0]" default
      ["[0]" syntax]
      ["[0]" platform {"+" Platform}]
      ["[0]" init]]
     ["[0]" cli {"+" Configuration}]]
    [world
     ["[0]" file {"+" File}]
     ["[0]" console {"+" Console}]]]]
  ["[0]" /type])

(exception: .public (error [message Text])
  message)

(def: .public module "<INTERPRETER>")

(def: fresh_source
  Source
  [[..module 1 0] 0 ""])

(def: (add_line line [where offset input])
  (-> Text Source Source)
  [where offset (format input text.new_line line)])

(def: exit_command
  Text
  "exit")

(def: welcome_message
  Text
  (format text.new_line
          "Welcome to the interpreter!" text.new_line
          "Type '" ..exit_command "' to leave." text.new_line
          text.new_line))

(def: farewell_message
  Text
  "Till next time...")

(def: enter_module
  (All (_ anchor expression directive)
    (Operation anchor expression directive Any))
  (directive.lifted_analysis
   (do phase.monad
     [_ (module.create 0 ..module)]
     (analysis.set_current_module ..module))))

(def: (initialize Monad<!> Console<!> platform configuration generation_bundle)
  (All (_ ! anchor expression directive)
    (-> (Monad !)
        (Console !) (Platform ! anchor expression directive)
        Configuration
        (generation.Bundle anchor expression directive)
        (! (State+ anchor expression directive))))
  (do Monad<!>
    [state (platform.initialize platform generation_bundle)
     state (platform.compile platform
                             (with@ cli.#module syntax.prelude configuration)
                             (with@ [extension.#state
                                     directive.#analysis directive.#state
                                     extension.#state
                                     .#info .#mode]
                                    {.#Interpreter}
                                    state))
     [state _] (# (value@ platform.#file_system platform)
                  lift (phase.result' state enter_module))
     _ (# Console<!> write ..welcome_message)]
    (in state)))

(with_expansions [<Interpretation> (as_is (Operation anchor expression directive [Type Any]))]
  
  (def: (interpret_directive code)
    (All (_ anchor expression directive)
      (-> Code <Interpretation>))
    (do phase.monad
      [_ (total.phase code)
       _ init.refresh]
      (in [Any []])))

  (def: (interpret_expression code)
    (All (_ anchor expression directive)
      (-> Code <Interpretation>))
    (do [! phase.monad]
      [state (extension.lifted phase.get_state)
       .let [analyse (value@ [directive.#analysis directive.#phase] state)
             synthesize (value@ [directive.#synthesis directive.#phase] state)
             generate (value@ [directive.#generation directive.#phase] state)]
       [_ codeT codeA] (directive.lifted_analysis
                        (analysis.with_scope
                          (type.with_fresh_env
                            (do !
                              [[codeT codeA] (type.with_inference
                                               (analyse code))
                               codeT (type.with_env
                                       (check.clean codeT))]
                              (in [codeT codeA])))))
       codeS (directive.lifted_synthesis
              (synthesize codeA))]
      (directive.lifted_generation
       (generation.with_buffer
         (do !
           [codeH (generate codeS)
            count generation.next
            codeV (generation.evaluate! (format "interpretation_" (%.nat count)) codeH)]
           (in [codeT codeV]))))))

  (def: (interpret configuration code)
    (All (_ anchor expression directive)
      (-> Configuration Code <Interpretation>))
    (function (_ state)
      (case (<| (phase.result' state)
                (:sharing [anchor expression directive]
                          (State+ anchor expression directive)
                          state

                          <Interpretation>
                          (interpret_directive code)))
        {try.#Success [state' output]}
        {try.#Success [state' output]}

        {try.#Failure error}
        (if (ex.match? total.not_a_directive error)
          (<| (phase.result' state)
              (:sharing [anchor expression directive]
                        (State+ anchor expression directive)
                        state
                        
                        <Interpretation>
                        (interpret_expression code)))
          {try.#Failure error}))))
  )

(def: (execute configuration code)
  (All (_ anchor expression directive)
    (-> Configuration Code (Operation anchor expression directive Text)))
  (do phase.monad
    [[codeT codeV] (interpret configuration code)
     state phase.get_state]
    (in (/type.represent (value@ [extension.#state
                                  directive.#analysis directive.#state
                                  extension.#state]
                                 state)
                         codeT
                         codeV))))

(type: (Context anchor expression directive)
  (Record
   [#configuration Configuration
    #state (State+ anchor expression directive)
    #source Source]))

(with_expansions [<Context> (as_is (Context anchor expression directive))]
  (def: (read_eval_print context)
    (All (_ anchor expression directive)
      (-> <Context> (Try [<Context> Text])))
    (do try.monad
      [.let [[_where _offset _code] (value@ #source context)]
       [source' input] (syntax.parse ..module syntax.no_aliases (text.size _code) (value@ #source context))
       [state' representation] (let [... TODO: Simplify ASAP
                                     state (:sharing [anchor expression directive]
                                                     <Context>
                                                     context
                                                     
                                                     (State+ anchor expression directive)
                                                     (value@ #state context))]
                                 (<| (phase.result' state)
                                     ... TODO: Simplify ASAP
                                     (:sharing [anchor expression directive]
                                               <Context>
                                               context
                                               
                                               (Operation anchor expression directive Text)
                                               (execute (value@ #configuration context) input))))]
      (in [(|> context
               (with@ #state state')
               (with@ #source source'))
           representation]))))

(def: .public (run! Monad<!> Console<!> platform configuration generation_bundle)
  (All (_ ! anchor expression directive)
    (-> (Monad !)
        (Console !) (Platform ! anchor expression directive)
        Configuration
        (generation.Bundle anchor expression directive)
        (! Any)))
  (do [! Monad<!>]
    [state (initialize Monad<!> Console<!> platform configuration)]
    (loop [context [#configuration configuration
                    #state state
                    #source ..fresh_source]
           multi_line? #0]
      (do !
        [_ (if multi_line?
             (# Console<!> write "  ")
             (# Console<!> write "> "))
         line (# Console<!> read_line)]
        (if (and (not multi_line?)
                 (text#= ..exit_command line))
          (# Console<!> write ..farewell_message)
          (case (read_eval_print (revised@ #source (add_line line) context))
            {try.#Success [context' representation]}
            (do !
              [_ (# Console<!> write representation)]
              (recur context' #0))

            {try.#Failure error}
            (if (ex.match? syntax.end_of_file error)
              (recur context #1)
              (exec (log! (ex.error ..error error))
                (recur (with@ #source ..fresh_source context) #0))))))
      )))
