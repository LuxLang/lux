(.module:
  [library
   [lux "*"
    [abstract
     ["[0]" monad {"+" [do]}]]
    [control
     ["[0]" function]
     ["[0]" try]
     ["<>" parser
      ["<[0]>" synthesis {"+" [Parser]}]]]
    [data
     ["[0]" product]
     ["[0]" text
      ["%" format {"+" [format]}]]
     [collection
      ["[0]" dictionary]
      ["[0]" list ("[1]\[0]" functor mix)]]]
    [math
     [number
      ["f" frac]]]
    [target
     ["_" python {"+" [Expression Statement]}]]]]
  ["[0]" //// "_"
   ["/" bundle]
   ["/[1]" // "_"
    ["[0]" extension]
    [generation
     ["[0]" reference]
     [extension {"+" [Nullary Unary Binary Trinary
                      nullary unary binary trinary]}]
     ["//" python "_"
      ["[1][0]" runtime {"+" [Operation Phase Phase! Handler Bundle Generator]}]
      ["[1][0]" primitive]
      ["[1][0]" structure]
      ["[1][0]" reference]
      ["[1][0]" function]
      ["[1][0]" case]
      ["[1][0]" loop]]]
    [//
     [analysis {"+" []}]
     ["[0]" synthesis {"+" [%synthesis]}]
     ["[0]" generation]
     [///
      ["[1]" phase ("[1]\[0]" monad)]]]]])

(def: .public (statement expression archive synthesis)
  Phase!
  (case synthesis
    ... TODO: Get rid of this ASAP
    {synthesis.#Extension "lux syntax char case!" parameters}
    (do /////.monad
      [body (expression archive synthesis)]
      (in (:as (Statement Any) body)))
    
    (^template [<tag>]
      [(^ (<tag> value))
       (/////\each _.return (expression archive synthesis))])
    ([synthesis.bit]
     [synthesis.i64]
     [synthesis.f64]
     [synthesis.text]
     [synthesis.variant]
     [synthesis.tuple]
     [synthesis.branch/get]
     [synthesis.function/apply])

    (^template [<tag>]
      [(^ {<tag> value})
       (/////\each _.return (expression archive synthesis))])
    ([synthesis.#Reference]
     [synthesis.#Extension])

    (^ (synthesis.branch/case case))
    (//case.case! false statement expression archive case)

    (^template [<tag> <generator>]
      [(^ (<tag> value))
       (<generator> statement expression archive value)])
    ([synthesis.branch/let //case.let!]
     [synthesis.branch/if //case.if!]
     [synthesis.loop/scope //loop.scope!]
     [synthesis.loop/recur //loop.recur!])

    (^ (synthesis.function/abstraction abstraction))
    (/////\each _.return (//function.function statement expression archive abstraction))
    ))

(def: .public (custom [parser handler])
  (All (_ s)
    (-> [(Parser s)
         (-> Text (Generator s))]
        Handler))
  (function (_ extension_name phase archive input)
    (case (<synthesis>.result parser input)
      {try.#Success input'}
      (handler extension_name phase archive input')

      {try.#Failure error}
      (/////.except extension.invalid_syntax [extension_name %synthesis input]))))

... TODO: Get rid of this ASAP
(def: lux::syntax_char_case!
  (..custom [($_ <>.and
                 <synthesis>.any
                 <synthesis>.any
                 (<>.some (<synthesis>.tuple ($_ <>.and
                                                 (<synthesis>.tuple (<>.many <synthesis>.i64))
                                                 <synthesis>.any))))
             (function (_ extension_name phase archive [input else conditionals])
               (do [! /////.monad]
                 [inputG (phase archive input)
                  else! (..statement phase archive else)
                  @input (\ ! each _.var (generation.identifier "input"))
                  conditionals! (: (Operation (List [(Expression Any)
                                                     (Statement Any)]))
                                   (monad.each ! (function (_ [chars branch])
                                                   (do !
                                                     [branch! (..statement phase archive branch)]
                                                     (in [(|> chars
                                                              (list\each (|>> .int _.int (_.= @input)))
                                                              (list\mix (function (_ clause total)
                                                                          (if (same? _.none total)
                                                                            clause
                                                                            (_.or clause total)))
                                                                        _.none))
                                                          branch!])))
                                               conditionals))
                  ... .let [dependencies (//case.dependencies (list\mix (function (_ right left)
                  ...                                                      (synthesis.path/seq left right))
                  ...                                                    (synthesis.path/then input)
                  ...                                                    {.#Item (synthesis.path/then else)
                  ...                                                     (list\each (|>> product.right
                  ...                                                                     synthesis.path/then)
                  ...                                                                conditionals)}))
                  ...       @closure (_.var (reference.artifact artifact_id))
                  ...       closure (_.def @closure dependencies
                  ...                      ($_ _.then
                  ...                          (_.set (list @input) inputG)
                  ...                          (list\mix (function (_ [test then!] else!)
                  ...                                       (_.if test then! else!))
                  ...                                     else!
                  ...                                     conditionals!)))]
                  ... _ (generation.execute! closure)
                  ... _ (generation.save! (product.right artifact_id) {.#None} closure)
                  ]
                 ... (in (_.apply/* @closure dependencies))
                 (in (<| (:as (Expression Any))
                         (: (Statement Any))
                         ($_ _.then
                             (_.set (list @input) inputG)
                             (list\mix (function (_ [test then!] else!)
                                         (_.if test then! else!))
                                       else!
                                       conditionals!))))))]))

(def: lux_procs
  Bundle
  (|> /.empty
      (/.install "syntax char case!" lux::syntax_char_case!)
      (/.install "is" (binary (product.uncurried _.is)))
      (/.install "try" (unary //runtime.lux::try))))

(def: (capped operation parameter subject)
  (-> (-> (Expression Any) (Expression Any) (Expression Any))
      (-> (Expression Any) (Expression Any) (Expression Any)))
  (//runtime.i64::64 (operation parameter subject)))

(def: i64_procs
  Bundle
  (<| (/.prefix "i64")
      (|> /.empty
          (/.install "and" (binary (product.uncurried //runtime.i64::and)))
          (/.install "or" (binary (product.uncurried //runtime.i64::or)))
          (/.install "xor" (binary (product.uncurried //runtime.i64::xor)))
          (/.install "left-shift" (binary (product.uncurried //runtime.i64::left_shifted)))
          (/.install "right-shift" (binary (product.uncurried //runtime.i64::right_shifted)))

          (/.install "<" (binary (product.uncurried _.<)))
          (/.install "=" (binary (product.uncurried _.=)))
          (/.install "+" (binary (product.uncurried (..capped _.+))))
          (/.install "-" (binary (product.uncurried (..capped _.-))))
          (/.install "*" (binary (product.uncurried (..capped _.*))))
          (/.install "/" (binary (product.uncurried //runtime.i64::division)))
          (/.install "%" (binary (product.uncurried //runtime.i64::remainder)))
          (/.install "f64" (unary _.float/1))
          (/.install "char" (unary //runtime.i64::char))
          )))

(def: f64_procs
  Bundle
  (<| (/.prefix "f64")
      (|> /.empty
          (/.install "+" (binary (product.uncurried _.+)))
          (/.install "-" (binary (product.uncurried _.-)))
          (/.install "*" (binary (product.uncurried _.*)))
          (/.install "/" (binary (product.uncurried //runtime.f64::/)))
          (/.install "%" (binary (function (_ [parameter subject])
                                   (|> (_.__import__/1 (_.unicode "math"))
                                       (_.do "fmod" (list subject parameter))))))
          (/.install "=" (binary (product.uncurried _.=)))
          (/.install "<" (binary (product.uncurried _.<)))
          (/.install "i64" (unary _.int/1))
          (/.install "encode" (unary _.repr/1))
          (/.install "decode" (unary //runtime.f64::decode)))))

(def: (text::clip [paramO extraO subjectO])
  (Trinary (Expression Any))
  (//runtime.text::clip paramO extraO subjectO))

(def: (text::index [startO partO textO])
  (Trinary (Expression Any))
  (//runtime.text::index startO partO textO))

(def: text_procs
  Bundle
  (<| (/.prefix "text")
      (|> /.empty
          (/.install "=" (binary (product.uncurried _.=)))
          (/.install "<" (binary (product.uncurried _.<)))
          (/.install "concat" (binary (product.uncurried (function.flipped _.+))))
          (/.install "index" (trinary ..text::index))
          (/.install "size" (unary _.len/1))
          (/.install "char" (binary (product.uncurried //runtime.text::char)))
          (/.install "clip" (trinary ..text::clip))
          )))

(def: io_procs
  Bundle
  (<| (/.prefix "io")
      (|> /.empty
          (/.install "log" (unary //runtime.io::log!))
          (/.install "error" (unary //runtime.io::throw!)))))

(def: .public bundle
  Bundle
  (<| (/.prefix "lux")
      (|> lux_procs
          (dictionary.merged i64_procs)
          (dictionary.merged f64_procs)
          (dictionary.merged text_procs)
          (dictionary.merged io_procs)
          )))
