(.using
  [library
   [lux "*"
    [abstract
     ["[0]" monad {"+" do}]]
    [control
     ["[0]" maybe]
     ["[0]" try]
     ["[0]" exception {"+" exception:}]
     ["<>" parser
      ["<[0]>" code {"+" Parser}]]]
    [data
     ["[0]" text
      ["%" format {"+" format}]]
     [collection
      ["[0]" list ("[1]#[0]" functor)]
      ["[0]" dictionary {"+" Dictionary}]]]
    [math
     [number
      ["n" nat]]]
    [type
     ["[0]" check]]
    ["[0]" meta]]]
  ["[0]" ///
   ["[1][0]" bundle]
   ["/[1]" // "_"
    [analysis
     ["[0]A" type]]
    [//
     ["[1][0]" analysis {"+" Analysis Operation Phase Handler Bundle}
      [evaluation {"+" Eval}]]
     [///
      ["[1]" phase]
      [meta
       [archive {"+" Archive}]]]]]])

(def: .public (custom [syntax handler])
  (All (_ s)
    (-> [(Parser s)
         (-> Text Phase Archive s (Operation Analysis))]
        Handler))
  (function (_ extension_name analyse archive args)
    (case (<code>.result syntax args)
      {try.#Success inputs}
      (handler extension_name analyse archive inputs)

      {try.#Failure _}
      (////analysis.except ///.invalid_syntax [extension_name %.code args]))))

(def: (simple inputsT+ outputT)
  (-> (List Type) Type Handler)
  (let [num_expected (list.size inputsT+)]
    (function (_ extension_name analyse archive args)
      (let [num_actual (list.size args)]
        (if (n.= num_expected num_actual)
          (do [! ////.monad]
            [_ (typeA.infer outputT)
             argsA (monad.each !
                               (function (_ [argT argC])
                                 (typeA.with_type argT
                                   (analyse archive argC)))
                               (list.zipped/2 inputsT+ args))]
            (in {////analysis.#Extension extension_name argsA}))
          (////analysis.except ///.incorrect_arity [extension_name num_expected num_actual]))))))

(def: .public (nullary valueT)
  (-> Type Handler)
  (simple (list) valueT))

(def: .public (unary inputT outputT)
  (-> Type Type Handler)
  (simple (list inputT) outputT))

(def: .public (binary subjectT paramT outputT)
  (-> Type Type Type Handler)
  (simple (list subjectT paramT) outputT))

(def: .public (trinary subjectT param0T param1T outputT)
  (-> Type Type Type Type Handler)
  (simple (list subjectT param0T param1T) outputT))

... TODO: Get rid of this ASAP
(as_is
 (exception: .public (char_text_must_be_size_1 [text Text])
   (exception.report
    ["Text" (%.text text)]))
 
 (def: text_char
   (Parser text.Char)
   (do <>.monad
     [raw <code>.text]
     (case (text.size raw)
       1 (in (|> raw (text.char 0) maybe.trusted))
       _ (<>.failure (exception.error ..char_text_must_be_size_1 [raw])))))

 (def: lux::syntax_char_case!
   (..custom
    [($_ <>.and
         <code>.any
         (<code>.tuple (<>.some (<>.and (<code>.tuple (<>.many ..text_char))
                                        <code>.any)))
         <code>.any)
     (function (_ extension_name phase archive [input conditionals else])
       (do [! ////.monad]
         [input (typeA.with_type text.Char
                  (phase archive input))
          expectedT (///.lifted meta.expected_type)
          conditionals (monad.each ! (function (_ [cases branch])
                                       (do !
                                         [branch (typeA.with_type expectedT
                                                   (phase archive branch))]
                                         (in [cases branch])))
                                   conditionals)
          else (typeA.with_type expectedT
                 (phase archive else))]
         (in (|> conditionals
                 (list#each (function (_ [cases branch])
                              (////analysis.tuple
                               (list (////analysis.tuple (list#each (|>> ////analysis.nat) cases))
                                     branch))))
                 (list& input else)
                 {////analysis.#Extension extension_name}))))])))

... "lux is" represents reference/pointer equality.
(def: lux::is
  Handler
  (function (_ extension_name analyse archive args)
    (do ////.monad
      [[var_id varT] (typeA.with_env check.var)]
      ((binary varT varT Bit extension_name)
       analyse archive args))))

... "lux try" provides a simple way to interact with the host platform's
... error_handling facilities.
(def: lux::try
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list opC))
      (do ////.monad
        [[var_id varT] (typeA.with_env check.var)
         _ (typeA.infer (type (Either Text varT)))
         opA (typeA.with_type (type (-> .Any varT))
               (analyse archive opC))]
        (in {////analysis.#Extension extension_name (list opA)}))
      
      _
      (////analysis.except ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: lux::in_module
  Handler
  (function (_ extension_name analyse archive argsC+)
    (case argsC+
      (^ (list [_ {.#Text module_name}] exprC))
      (////analysis.with_current_module module_name
        (analyse archive exprC))
      
      _
      (////analysis.except ///.invalid_syntax [extension_name %.code argsC+]))))

(def: (lux::type::check eval)
  (-> Eval Handler)
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list typeC valueC))
      (do [! ////.monad]
        [actualT (# ! each (|>> (:as Type))
                    (eval archive Type typeC))
         _ (typeA.infer actualT)]
        (typeA.with_type actualT
          (analyse archive valueC)))

      _
      (////analysis.except ///.incorrect_arity [extension_name 2 (list.size args)]))))

(def: (lux::type::as eval)
  (-> Eval Handler)
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list typeC valueC))
      (do [! ////.monad]
        [actualT (# ! each (|>> (:as Type))
                    (eval archive Type typeC))
         _ (typeA.infer actualT)
         [valueT valueA] (typeA.with_inference
                           (analyse archive valueC))]
        (in valueA))

      _
      (////analysis.except ///.incorrect_arity [extension_name 2 (list.size args)]))))

(def: (caster input output)
  (-> Type Type Handler)
  (..custom
   [<code>.any
    (function (_ extension_name phase archive valueC)
      (do [! ////.monad]
        [_ (typeA.infer output)]
        (typeA.with_type input
          (phase archive valueC))))]))

(exception: .public (not_a_type [symbol Symbol])
  (exception.report
   ["Symbol" (%.symbol symbol)]))

(def: lux::macro
  Handler
  (..custom
   [<code>.any
    (function (_ extension_name phase archive valueC)
      (do [! ////.monad]
        [_ (typeA.infer .Macro)
         input_type (loop [input_name (symbol .Macro')]
                      (do !
                        [input_type (///.lifted (meta.definition (symbol .Macro')))]
                        (case input_type
                          (^or {.#Definition [exported? def_type def_value]}
                               {.#Type [exported? def_value labels]})
                          (in (:as Type def_value))

                          (^or {.#Tag _}
                               {.#Slot _})
                          (////.failure (exception.error ..not_a_type [(symbol .Macro')]))

                          {.#Alias real_name}
                          (again real_name))))]
        (typeA.with_type input_type
          (phase archive valueC))))]))

(def: (bundle::lux eval)
  (-> Eval Bundle)
  (|> ///bundle.empty
      (///bundle.install "syntax char case!" lux::syntax_char_case!)
      (///bundle.install "is" lux::is)
      (///bundle.install "try" lux::try)
      (///bundle.install "type check" (lux::type::check eval))
      (///bundle.install "type as" (lux::type::as eval))
      (///bundle.install "macro" ..lux::macro)
      (///bundle.install "type check type" (..caster .Type .Type))
      (///bundle.install "in-module" lux::in_module)))

(def: bundle::io
  Bundle
  (<| (///bundle.prefix "io")
      (|> ///bundle.empty
          (///bundle.install "log" (unary Text Any))
          (///bundle.install "error" (unary Text Nothing))
          (///bundle.install "exit" (unary Int Nothing)))))

(def: I64*
  (type (I64 Any)))

(def: bundle::i64
  Bundle
  (<| (///bundle.prefix "i64")
      (|> ///bundle.empty
          (///bundle.install "and" (binary I64* I64* I64))
          (///bundle.install "or" (binary I64* I64* I64))
          (///bundle.install "xor" (binary I64* I64* I64))
          (///bundle.install "left-shift" (binary Nat I64* I64))
          (///bundle.install "right-shift" (binary Nat I64* I64))
          (///bundle.install "=" (binary I64* I64* Bit))
          (///bundle.install "<" (binary Int Int Bit))
          (///bundle.install "+" (binary I64* I64* I64))
          (///bundle.install "-" (binary I64* I64* I64))
          (///bundle.install "*" (binary Int Int Int))
          (///bundle.install "/" (binary Int Int Int))
          (///bundle.install "%" (binary Int Int Int))
          (///bundle.install "f64" (unary Int Frac))
          (///bundle.install "char" (unary Int Text)))))

(def: bundle::f64
  Bundle
  (<| (///bundle.prefix "f64")
      (|> ///bundle.empty
          (///bundle.install "+" (binary Frac Frac Frac))
          (///bundle.install "-" (binary Frac Frac Frac))
          (///bundle.install "*" (binary Frac Frac Frac))
          (///bundle.install "/" (binary Frac Frac Frac))
          (///bundle.install "%" (binary Frac Frac Frac))
          (///bundle.install "=" (binary Frac Frac Bit))
          (///bundle.install "<" (binary Frac Frac Bit))
          (///bundle.install "i64" (unary Frac Int))
          (///bundle.install "encode" (unary Frac Text))
          (///bundle.install "decode" (unary Text (type (Maybe Frac)))))))

(def: bundle::text
  Bundle
  (<| (///bundle.prefix "text")
      (|> ///bundle.empty
          (///bundle.install "=" (binary Text Text Bit))
          (///bundle.install "<" (binary Text Text Bit))
          (///bundle.install "concat" (binary Text Text Text))
          (///bundle.install "index" (trinary Nat Text Text (type (Maybe Nat))))
          (///bundle.install "size" (unary Text Nat))
          (///bundle.install "char" (binary Nat Text Nat))
          (///bundle.install "clip" (trinary Nat Nat Text Text))
          )))

(def: .public (bundle eval)
  (-> Eval Bundle)
  (<| (///bundle.prefix "lux")
      (|> ///bundle.empty
          (dictionary.merged (bundle::lux eval))
          (dictionary.merged bundle::i64)
          (dictionary.merged bundle::f64)
          (dictionary.merged bundle::text)
          (dictionary.merged bundle::io)
          )))
