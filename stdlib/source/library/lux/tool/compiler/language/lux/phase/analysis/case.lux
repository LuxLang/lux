(.module:
  [library
   [lux {"-" [case]}
    ["[0]" meta]
    [abstract
     ["[0]" monad {"+" [do]}]]
    [control
     ["[0]" maybe]
     ["[0]" try]
     ["[0]" exception {"+" [exception:]}]]
    [data
     ["[0]" product]
     [text
      ["%" format {"+" [format]}]]
     [collection
      ["[0]" list ("[1]\[0]" mix monoid functor)]]]
    [math
     [number
      ["n" nat]]]
    [macro
     ["[0]" code]]
    ["[0]" type
     ["[0]" check]]]]
  ["[0]" / "_"
   ["[1][0]" coverage {"+" [Coverage]}]
   ["/[1]" // "_"
    ["[1][0]" scope]
    ["[1][0]" type]
    ["[1][0]" structure]
    ["/[1]" // "_"
     ["[1][0]" extension]
     [//
      ["/" analysis {"+" [Pattern Analysis Operation Phase]}]
      [///
       ["[1]" phase]]]]]])

(exception: .public (cannot_match_with_pattern [type Type
                                                pattern Code])
  (exception.report
   ["Type" (%.type type)]
   ["Pattern" (%.code pattern)]))

(exception: .public (sum_has_no_case [case Nat
                                      type Type])
  (exception.report
   ["Case" (%.nat case)]
   ["Type" (%.type type)]))

(exception: .public (not_a_pattern [code Code])
  (exception.report ["Code" (%.code code)]))

(exception: .public (cannot_simplify_for_pattern_matching [type Type])
  (exception.report ["Type" (%.type type)]))

(exception: .public (non_exhaustive_pattern_matching [input Code
                                                      branches (List [Code Code])
                                                      coverage Coverage])
  (exception.report
   ["Input" (%.code input)]
   ["Branches" (%.code (code.record branches))]
   ["Coverage" (/coverage.%coverage coverage)]))

(exception: .public (cannot_have_empty_branches [message Text])
  message)

(def: (re_quantify envs baseT)
  (-> (List (List Type)) Type Type)
  (.case envs
    #.End
    baseT

    {#.Item head tail}
    (re_quantify tail {#.UnivQ head baseT})))

... Type-checking on the input value is done during the analysis of a
... "case" expression, to ensure that the patterns being used make
... sense for the type of the input value.
... Sometimes, that input value is complex, by depending on
... type-variables or quantifications.
... This function makes it easier for "case" analysis to properly
... type-check the input with respect to the patterns.
(def: (simplify_case caseT)
  (-> Type (Operation Type))
  (loop [envs (: (List (List Type))
                 (list))
         caseT caseT]
    (.case caseT
      {#.Var id}
      (do ///.monad
        [?caseT' (//type.with_env
                   (check.peek id))]
        (.case ?caseT'
          {#.Some caseT'}
          (recur envs caseT')

          _
          (/.except ..cannot_simplify_for_pattern_matching caseT)))

      {#.Named name unnamedT}
      (recur envs unnamedT)

      {#.UnivQ env unquantifiedT}
      (recur {#.Item env envs} unquantifiedT)

      {#.ExQ _}
      (do ///.monad
        [[var_id varT] (//type.with_env
                         check.var)]
        (recur envs (maybe.trusted (type.applied (list varT) caseT))))

      {#.Apply inputT funcT}
      (.case funcT
        {#.Var funcT_id}
        (do ///.monad
          [funcT' (//type.with_env
                    (do check.monad
                      [?funct' (check.peek funcT_id)]
                      (.case ?funct'
                        {#.Some funct'}
                        (in funct')

                        _
                        (check.except ..cannot_simplify_for_pattern_matching caseT))))]
          (recur envs {#.Apply inputT funcT'}))

        _
        (.case (type.applied (list inputT) funcT)
          {#.Some outputT}
          (recur envs outputT)

          #.None
          (/.except ..cannot_simplify_for_pattern_matching caseT)))

      {#.Product _}
      (|> caseT
          type.flat_tuple
          (list\each (re_quantify envs))
          type.tuple
          (\ ///.monad in))

      _
      (\ ///.monad in (re_quantify envs caseT)))))

(def: (analyse_primitive type inputT location output next)
  (All (_ a) (-> Type Type Location Pattern (Operation a) (Operation [Pattern a])))
  (/.with_location location
    (do ///.monad
      [_ (//type.with_env
           (check.check inputT type))
       outputA next]
      (in [output outputA]))))

... This function handles several concerns at once, but it must be that
... way because those concerns are interleaved when doing
... pattern-matching and they cannot be separated.
... The pattern is analysed in order to get a general feel for what is
... expected of the input value. This, in turn, informs the
... type-checking of the input.
... A kind of "continuation" value is passed around which signifies
... what needs to be done _after_ analysing a pattern.
... In general, this is done to analyse the "body" expression
... associated to a particular pattern _in the context of_ said
... pattern.
... The reason why *context* is important is because patterns may bind
... values to local variables, which may in turn be referenced in the
... body expressions.
... That is why the body must be analysed in the context of the
... pattern, and not separately.
(def: (analyse_pattern num_tags inputT pattern next)
  (All (_ a) (-> (Maybe Nat) Type Code (Operation a) (Operation [Pattern a])))
  (.case pattern
    [location {#.Identifier ["" name]}]
    (/.with_location location
      (do ///.monad
        [outputA (//scope.with_local [name inputT]
                   next)
         idx //scope.next_local]
        (in [{#/.Bind idx} outputA])))

    (^template [<type> <input> <output>]
      [[location <input>]
       (analyse_primitive <type> inputT location {#/.Simple <output>} next)])
    ([Bit  {#.Bit pattern_value}  {#/.Bit pattern_value}]
     [Nat  {#.Nat pattern_value}  {#/.Nat pattern_value}]
     [Int  {#.Int pattern_value}  {#/.Int pattern_value}]
     [Rev  {#.Rev pattern_value}  {#/.Rev pattern_value}]
     [Frac {#.Frac pattern_value} {#/.Frac pattern_value}]
     [Text {#.Text pattern_value} {#/.Text pattern_value}]
     [Any  {#.Tuple #.End}        #/.Unit])
    
    (^ [location {#.Tuple (list singleton)}])
    (analyse_pattern #.None inputT singleton next)
    
    [location {#.Tuple sub_patterns}]
    (do [! ///.monad]
      [record (//structure.normal sub_patterns)
       record_size,members,recordT (: (Operation (Maybe [Nat (List Code) Type]))
                                      (.case record
                                        {#.Some record}
                                        (//structure.order record)

                                        #.None
                                        (in #.None)))]
      (.case record_size,members,recordT
        {#.Some [record_size members recordT]}
        (do !
          [_ (.case inputT
               {#.Var _id}
               (//type.with_env
                 (check.check inputT recordT))

               _
               (in []))]
          (analyse_pattern {#.Some record_size} inputT [location {#.Tuple members}] next))
        
        #.None
        (/.with_location location
          (do [! ///.monad]
            [inputT' (simplify_case inputT)]
            (.case inputT'
              {#.Product _}
              (let [matches (loop [types (type.flat_tuple inputT')
                                   patterns sub_patterns
                                   output (: (List [Type Code])
                                             #.End)]
                              (.case [types patterns]
                                [#.End #.End]
                                output

                                [{#.Item headT #.End} {#.Item headP #.End}]
                                {#.Item [headT headP] output}

                                [remainingT {#.Item headP #.End}]
                                {#.Item [(type.tuple remainingT) headP] output}

                                [{#.Item headT #.End} remainingP]
                                {#.Item [headT (code.tuple remainingP)] output}
                                
                                [{#.Item headT tailT} {#.Item headP tailP}]
                                (recur tailT tailP {#.Item [headT headP] output})

                                _
                                (undefined)))]
                (do !
                  [[memberP+ thenA] (list\mix (: (All (_ a)
                                                   (-> [Type Code] (Operation [(List Pattern) a])
                                                       (Operation [(List Pattern) a])))
                                                 (function (_ [memberT memberC] then)
                                                   (do !
                                                     [[memberP [memberP+ thenA]] ((:as (All (_ a) (-> (Maybe Nat) Type Code (Operation a) (Operation [Pattern a])))
                                                                                       analyse_pattern)
                                                                                  #.None memberT memberC then)]
                                                     (in [(list& memberP memberP+) thenA]))))
                                              (do !
                                                [nextA next]
                                                (in [(list) nextA]))
                                              matches)]
                  (in [(/.pattern/tuple memberP+)
                       thenA])))

              _
              (/.except ..cannot_match_with_pattern [inputT' pattern]))))))

    [location {#.Tag tag}]
    (/.with_location location
      (analyse_pattern #.None inputT (` ((~ pattern))) next))

    (^ [location {#.Form (list& [_ {#.Nat lefts}] [_ {#.Bit right?}] values)}])
    (/.with_location location
      (do ///.monad
        [inputT' (simplify_case inputT)]
        (.case inputT'
          {#.Sum _}
          (let [flat_sum (type.flat_variant inputT')
                size_sum (list.size flat_sum)
                num_cases (maybe.else size_sum num_tags)
                idx (/.tag lefts right?)]
            (.case (list.item idx flat_sum)
              (^multi {#.Some caseT}
                      (n.< num_cases idx))
              (do ///.monad
                [[testP nextA] (if (and (n.> num_cases size_sum)
                                        (n.= (-- num_cases) idx))
                                 (analyse_pattern #.None
                                                  (type.variant (list.after (-- num_cases) flat_sum))
                                                  (` [(~+ values)])
                                                  next)
                                 (analyse_pattern #.None caseT (` [(~+ values)]) next))]
                (in [(/.pattern/variant [lefts right? testP])
                     nextA]))

              _
              (/.except ..sum_has_no_case [idx inputT])))

          {#.UnivQ _}
          (do ///.monad
            [[ex_id exT] (//type.with_env
                           check.existential)]
            (analyse_pattern num_tags
                             (maybe.trusted (type.applied (list exT) inputT'))
                             pattern
                             next))
          
          _
          (/.except ..cannot_match_with_pattern [inputT' pattern]))))

    (^ [location {#.Form (list& [_ {#.Tag tag}] values)}])
    (/.with_location location
      (do ///.monad
        [tag (///extension.lifted (meta.normal tag))
         [idx group variantT] (///extension.lifted (meta.tag tag))
         _ (//type.with_env
             (check.check inputT variantT))
         .let [[lefts right?] (/.choice (list.size group) idx)]]
        (analyse_pattern {#.Some (list.size group)} inputT (` ((~ (code.nat lefts)) (~ (code.bit right?)) (~+ values))) next)))

    _
    (/.except ..not_a_pattern pattern)
    ))

(def: .public (case analyse branches archive inputC)
  (-> Phase (List [Code Code]) Phase)
  (.case branches
    {#.Item [patternH bodyH] branchesT}
    (do [! ///.monad]
      [[inputT inputA] (//type.with_inference
                         (analyse archive inputC))
       outputH (analyse_pattern #.None inputT patternH (analyse archive bodyH))
       outputT (monad.each !
                           (function (_ [patternT bodyT])
                             (analyse_pattern #.None inputT patternT (analyse archive bodyT)))
                           branchesT)
       outputHC (|> outputH product.left /coverage.determine)
       outputTC (monad.each ! (|>> product.left /coverage.determine) outputT)
       _ (.case (monad.mix try.monad /coverage.merged outputHC outputTC)
           {#try.Success coverage}
           (///.assertion non_exhaustive_pattern_matching [inputC branches coverage]
                          (/coverage.exhaustive? coverage))

           {#try.Failure error}
           (/.failure error))]
      (in {#/.Case inputA [outputH outputT]}))

    #.End
    (/.except ..cannot_have_empty_branches "")))
