(.using
 [library
  [lux "*"
   [abstract
    ["[0]" monad {"+" do}]]
   [control
    ["[0]" maybe]
    ["[0]" try {"+" Try}]
    ["[0]" exception {"+" exception:}]]
   [data
    ["[0]" product]
    [text
     ["%" format {"+" format}]]
    [collection
     ["[0]" list ("[1]#[0]" functor)]]]]]
 [//
  [generation {"+" Context}]
  [///
   [meta
    ["[0]" archive {"+" Archive}
     ["[0]" descriptor]
     ["[0]" registry {"+" Registry}]]]]])

(type: .public (Program expression directive)
  (-> Context expression directive))

(def: .public name
  Text
  "")

(exception: .public (cannot_find_program [modules (List descriptor.Module)])
  (exception.report
   ["Modules" (exception.listing %.text modules)]))

(def: .public (context archive)
  (-> Archive (Try Context))
  (do [! try.monad]
    [registries (|> archive
                    archive.archived
                    (monad.each !
                                (function (_ module)
                                  (do !
                                    [id (archive.id module archive)
                                     [descriptor document output registry] (archive.find module archive)]
                                    (in [[module id] registry])))))]
    (case (list.one (function (_ [[module module_id] registry])
                      (do maybe.monad
                        [program_id (registry.id ..name registry)]
                        (in [module_id program_id])))
                    registries)
      {.#Some program_context}
      (in program_context)
      
      {.#None}
      (|> registries
          (list#each (|>> product.left product.left))
          (exception.except ..cannot_find_program)))))
