(.module:
  [library
   [lux "*"
    [abstract
     monad]
    [control
     ["[0]" exception {"+" [exception:]}]]
    ["[0]" meta]
    [data
     ["[0]" text ("[1]\[0]" equivalence)
      ["%" format {"+" [format]}]]]]]
  ["[0]" // "_"
   ["[1][0]" scope]
   ["[1][0]" type]
   ["/[1]" // "_"
    ["[1][0]" extension]
    [//
     ["/" analysis {"+" [Analysis Operation]}]
     [///
      ["[1][0]" reference]
      ["[1]" phase]]]]])

(exception: .public (foreign_module_has_not_been_imported [current Text
                                                           foreign Text])
  (exception.report
   ["Current" current]
   ["Foreign" foreign]))

(exception: .public (definition_has_not_been_exported [definition Name])
  (exception.report
   ["Definition" (%.name definition)]))

(exception: .public (labels_are_not_definitions [definition Name])
  (exception.report
   ["Label" (%.name definition)]))

(def: (definition def_name)
  (-> Name (Operation Analysis))
  (with_expansions [<return> (in (|> def_name ///reference.constant #/.Reference))]
    (do [! ///.monad]
      [constant (///extension.lifted (meta.definition def_name))]
      (case constant
        (#.Alias real_def_name)
        (definition real_def_name)
        
        (#.Definition [exported? actualT _])
        (do !
          [_ (//type.infer actualT)
           (^@ def_name [::module ::name]) (///extension.lifted (meta.normal def_name))
           current (///extension.lifted meta.current_module_name)]
          (if (text\= current ::module)
            <return>
            (if exported?
              (do !
                [imported! (///extension.lifted (meta.imported_by? ::module current))]
                (if imported!
                  <return>
                  (/.except foreign_module_has_not_been_imported [current ::module])))
              (/.except definition_has_not_been_exported def_name))))

        (#.Type [exported? value labels])
        (do !
          [_ (//type.infer .Type)
           (^@ def_name [::module ::name]) (///extension.lifted (meta.normal def_name))
           current (///extension.lifted meta.current_module_name)]
          (if (text\= current ::module)
            <return>
            (if exported?
              (do !
                [imported! (///extension.lifted (meta.imported_by? ::module current))]
                (if imported!
                  <return>
                  (/.except foreign_module_has_not_been_imported [current ::module])))
              (/.except definition_has_not_been_exported def_name))))

        (#.Label _)
        (/.except labels_are_not_definitions [def_name])
        
        (#.Slot _)
        (/.except labels_are_not_definitions [def_name])))))

(def: (variable var_name)
  (-> Text (Operation (Maybe Analysis)))
  (do [! ///.monad]
    [?var (//scope.find var_name)]
    (case ?var
      (#.Some [actualT ref])
      (do !
        [_ (//type.infer actualT)]
        (in (#.Some (|> ref ///reference.variable #/.Reference))))

      #.None
      (in #.None))))

(def: .public (reference reference)
  (-> Name (Operation Analysis))
  (case reference
    ["" simple_name]
    (do [! ///.monad]
      [?var (variable simple_name)]
      (case ?var
        (#.Some varA)
        (in varA)

        #.None
        (do !
          [this_module (///extension.lifted meta.current_module_name)]
          (definition [this_module simple_name]))))

    _
    (definition reference)))
