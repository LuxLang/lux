(.using
 [library
  [lux "*"
   [abstract
    [monad {"+" do}]]
   [control
    ["[0]" exception {"+" exception:}]]
   [data
    [text
     ["%" format {"+" format}]]
    [collection
     ["[0]" list]]]
   [math
    [number
     ["n" nat]]]
   ["[0]" meta
    ["[0]" location]]]]
 ["[0]" / "_"
  ["[1][0]" type]
  ["[1][0]" primitive]
  ["[1][0]" structure]
  ["[1][0]" reference]
  ["[1][0]" case]
  ["[1][0]" function]
  ["/[1]" // "_"
   ["[1][0]" extension]
   ["/[1]" // "_"
    ["/" analysis {"+" Analysis Operation Phase}
     ["[1][0]" macro {"+" Expander}]]
    [///
     ["//" phase]
     ["[0]" reference]
     [meta
      [archive {"+" Archive}]]]]]])

(exception: .public (unrecognized_syntax [code Code])
  (exception.report
   ["Code" (%.code code)]))

... TODO: Had to split the 'compile' function due to compilation issues
... with old-luxc. Must re-combine all the code ASAP

(type: (Fix a)
  (-> a a))

(def: (compile|literal archive compile else code')
  (-> Archive Phase (Fix (-> (Code' (Ann Location)) (Operation Analysis))))
  (case code'
    (^template [<tag> <analyser>]
      [{<tag> value}
       (<analyser> value)])
    ([.#Bit  /primitive.bit]
     [.#Nat  /primitive.nat]
     [.#Int  /primitive.int]
     [.#Rev  /primitive.rev]
     [.#Frac /primitive.frac]
     [.#Text /primitive.text])

    (^ {.#Variant (list& [_ {.#Symbol tag}]
                         values)})
    (case values
      {.#Item value {.#End}}
      (/structure.tagged_sum compile tag archive value)

      _
      (/structure.tagged_sum compile tag archive (` [(~+ values)])))

    (^ {.#Variant (list& [_ {.#Nat lefts}] [_ {.#Bit right?}]
                         values)})
    (case values
      {.#Item value {.#End}}
      (/structure.sum compile lefts right? archive value)

      _
      (/structure.sum compile lefts right? archive (` [(~+ values)])))

    (^ {.#Tuple elems})
    (/structure.record archive compile elems)

    _
    (else code')))

(def: (compile|others expander archive compile code')
  (-> Expander Archive Phase (-> (Code' (Ann Location)) (Operation Analysis)))
  (case code'
    {.#Symbol reference}
    (/reference.reference reference)

    (^ {.#Form (list [_ {.#Variant branches}] input)})
    (case (list.pairs branches)
      {.#Some branches}
      (/case.case compile branches archive input)

      {.#None}
      (//.except ..unrecognized_syntax [location.dummy code']))

    (^ {.#Form (list& [_ {.#Text extension_name}] extension_args)})
    (//extension.apply archive compile [extension_name extension_args])

    (^ {.#Form (list [_ {.#Tuple (list [_ {.#Symbol ["" function_name]}]
                                       [_ {.#Symbol ["" arg_name]}])}]
                     body)})
    (/function.function compile function_name arg_name archive body)

    (^ {.#Form (list& functionC argsC+)})
    (do [! //.monad]
      [[functionT functionA] (/type.with_inference
                               (compile archive functionC))]
      (case functionA
        {/.#Reference {reference.#Constant def_name}}
        (do !
          [?macro (//extension.lifted (meta.macro def_name))]
          (case ?macro
            {.#Some macro}
            (do !
              [expansion (//extension.lifted (/macro.expand_one expander def_name macro argsC+))]
              (compile archive expansion))

            _
            (/function.apply compile argsC+ functionT functionA archive functionC)))

        _
        (/function.apply compile argsC+ functionT functionA archive functionC)))

    _
    (//.except ..unrecognized_syntax [location.dummy code'])))

(def: .public (phase expander)
  (-> Expander Phase)
  (function (compile archive code)
    (let [[location code'] code]
      ... The location must be set in the state for the sake
      ... of having useful error messages.
      (/.with_location location
        (compile|literal archive compile
                         (compile|others expander archive compile)
                         code')))))
