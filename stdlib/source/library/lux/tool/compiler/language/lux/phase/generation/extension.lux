(.module:
  [library
   [lux "*"
    [abstract
     ["[0]" monad {"+" do}]]
    [control
     [parser
      ["<[0]>" code]]]
    [data
     [collection
      ["[0]" list ("[1]#[0]" functor)]]]
    ["[0]" meta]
    ["[0]" macro {"+" with_identifiers}
     ["[0]" code]
     [syntax {"+" syntax:}]]]]
  ["[0]" /// "_"
   ["[1][0]" extension]
   [//
    [synthesis {"+" Synthesis}]
    ["[0]" generation]
    [///
     ["[1]" phase]]]])

(syntax: (Vector [size <code>.nat
                  elemT <code>.any])
  (in (list (` [(~+ (list.repeated size elemT))]))))

(type: .public (Nullary of) (-> (Vector 0 of) of))
(type: .public (Unary of)   (-> (Vector 1 of) of))
(type: .public (Binary of)  (-> (Vector 2 of) of))
(type: .public (Trinary of) (-> (Vector 3 of) of))
(type: .public (Variadic of) (-> (List of) of))

(syntax: (arity: [arity <code>.nat
                  name <code>.local_identifier
                  type <code>.any])
  (with_identifiers [g!_ g!extension g!name g!phase g!archive g!inputs g!of g!anchor g!expression g!directive]
    (do [! meta.monad]
      [g!input+ (monad.all ! (list.repeated arity (macro.identifier "input")))]
      (in (list (` (def: .public ((~ (code.local_identifier name)) (~ g!extension))
                     (All ((~ g!_) (~ g!anchor) (~ g!expression) (~ g!directive))
                       (-> ((~ type) (~ g!expression))
                           (generation.Handler (~ g!anchor) (~ g!expression) (~ g!directive))))
                     (function ((~ g!_) (~ g!name) (~ g!phase) (~ g!archive) (~ g!inputs))
                       (case (~ g!inputs)
                         (^ (list (~+ g!input+)))
                         (do ///.monad
                           [(~+ (|> g!input+
                                    (list#each (function (_ g!input)
                                                 (list g!input (` ((~ g!phase) (~ g!archive) (~ g!input))))))
                                    list.together))]
                           ((~' in) ((~ g!extension) [(~+ g!input+)])))

                         (~' _)
                         (///.except ///extension.incorrect_arity [(~ g!name) 1 (list.size (~ g!inputs))]))))))))))

(arity: 0 nullary ..Nullary)
(arity: 1 unary ..Unary)
(arity: 2 binary ..Binary)
(arity: 3 trinary ..Trinary)

(def: .public (variadic extension)
  (All (_ anchor expression directive)
    (-> (Variadic expression) (generation.Handler anchor expression directive)))
  (function (_ extension_name)
    (function (_ phase archive inputsS)
      (do [! ///.monad]
        [inputsI (monad.each ! (phase archive) inputsS)]
        (in (extension inputsI))))))
