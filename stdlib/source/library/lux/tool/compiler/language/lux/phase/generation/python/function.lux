(.module:
  [library
   [lux {"-" [function]}
    [abstract
     ["[0]" monad {"+" [do]}]]
    [data
     ["[0]" product]
     [text
      ["%" format {"+" [format]}]]
     [collection
      ["[0]" list ("[1]#[0]" functor mix)]]]
    [target
     ["_" python {"+" [SVar Expression Statement]}]]]]
  ["[0]" // "_"
   [runtime {"+" [Operation Phase Generator Phase! Generator!]}]
   ["[1][0]" reference]
   ["[1][0]" case]
   ["[1][0]" loop]
   ["/[1]" // "_"
    ["[1][0]" reference]
    ["//[1]" /// "_"
     [analysis {"+" [Environment Abstraction Application Analysis]}]
     [synthesis {"+" [Synthesis]}]
     ["[1][0]" generation {"+" [Context]}]
     ["//[1]" /// "_"
      [arity {"+" [Arity]}]
      ["[1][0]" phase]
      [reference
       [variable {"+" [Register Variable]}]]
      [meta
       [archive {"+" [Archive]}
        ["[0]" artifact]]]]]]])

(def: .public (apply expression archive [functionS argsS+])
  (Generator (Application Synthesis))
  (do [! ///////phase.monad]
    [functionO (expression archive functionS)
     argsO+ (monad.each ! (expression archive) argsS+)]
    (in (_.apply/* functionO argsO+))))

(def: .public capture
  (-> Register SVar)
  (|>> (///reference.foreign //reference.system) :expected))

(def: (with_closure function_id @function inits function_definition)
  (-> artifact.ID SVar (List (Expression Any)) (Statement Any) (Operation (Expression Any)))
  (case inits
    {.#End}
    (do ///////phase.monad
      [_ (/////generation.execute! function_definition)
       _ (/////generation.save! function_id {.#None} function_definition)]
      (in @function))

    _
    (do [! ///////phase.monad]
      [.let [directive (_.def @function
                              (|> (list.enumeration inits)
                                  (list#each (|>> product.left ..capture)))
                              ($_ _.then
                                  function_definition
                                  (_.return @function)))]
       _ (/////generation.execute! directive)
       _ (/////generation.save! function_id {.#None} directive)]
      (in (_.apply/* @function inits)))))

(def: input
  (|>> ++ //case.register))

(def: .public (function statement expression archive [environment arity bodyS])
  (-> Phase! (Generator (Abstraction Synthesis)))
  (do [! ///////phase.monad]
    [[[function_module function_artifact] body!] (/////generation.with_new_context archive
                                                   (/////generation.with_anchor 1
                                                     (statement expression archive bodyS)))
     environment (monad.each ! (expression archive) environment)
     .let [@curried (_.var "curried")
           arityO (|> arity .int _.int)
           @num_args (_.var "num_args")
           @self (_.var (///reference.artifact [function_module function_artifact]))
           apply_poly (.function (_ args func)
                        (_.apply_poly (list) args func))
           initialize_self! (_.set (list (//case.register 0)) @self)
           initialize! (list#mix (.function (_ post pre!)
                                   ($_ _.then
                                       pre!
                                       (_.set (list (..input post)) (_.item (|> post .int _.int) @curried))))
                                 initialize_self!
                                 (list.indices arity))]]
    (with_closure function_artifact @self environment
      (_.def @self (list (_.poly @curried))
             ($_ _.then
                 (_.set (list @num_args) (_.len/1 @curried))
                 (_.cond (list [(|> @num_args (_.= arityO))
                                (<| (_.then initialize!)
                                    //loop.set_scope
                                    body!)]
                               [(|> @num_args (_.> arityO))
                                (let [arity_inputs (_.slice (_.int +0) arityO @curried)
                                      extra_inputs (_.slice arityO @num_args @curried)]
                                  (_.return (|> @self
                                                (apply_poly arity_inputs)
                                                (apply_poly extra_inputs))))])
                         ... (|> @num_args (_.< arityO))
                         (let [@next (_.var "next")
                               @missing (_.var "missing")]
                           ($_ _.then
                               (_.def @next (list (_.poly @missing))
                                      (_.return (|> @self (apply_poly (|> @curried (_.+ @missing))))))
                               (_.return @next)
                               )))
                 )))
    ))
