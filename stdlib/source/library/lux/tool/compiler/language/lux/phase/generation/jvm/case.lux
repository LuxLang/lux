(.module:
  [library
   [lux (#- Type if let case int)
    [abstract
     ["." monad (#+ do)]]
    [control
     ["." function]]
    [data
     [number
      ["." i32]
      ["n" nat]]
     [collection
      ["." list ("#\." fold)]]]
    [target
     [jvm
      ["_" bytecode (#+ Label Bytecode) ("#\." monad)]
      ["." type (#+ Type)
       [category (#+ Method)]]]]]]
  ["." // #_
   ["#." type]
   ["#." runtime (#+ Operation Phase Generator)]
   ["#." value]
   ["#." structure]
   [////
    ["." synthesis (#+ Path Synthesis)]
    ["." generation]
    [///
     ["." phase ("operation\." monad)]
     [reference
      [variable (#+ Register)]]]]])

(def: equals_name
  "equals")

(def: equals_type
  (type.method [(list //type.value) type.boolean (list)]))

(def: (pop_alt stack_depth)
  (-> Nat (Bytecode Any))
  (.case stack_depth
    0 (_\in [])
    1 _.pop
    2 _.pop2
    _ ... (n.> 2)
    ($_ _.compose
        _.pop2
        (pop_alt (n.- 2 stack_depth)))))

(def: int
  (-> (I64 Any) (Bytecode Any))
  (|>> .i64 i32.i32 _.int))

(def: long
  (-> (I64 Any) (Bytecode Any))
  (|>> .int _.long))

(def: double
  (-> Frac (Bytecode Any))
  (|>> _.double))

(def: peek
  (Bytecode Any)
  ($_ _.compose
      _.dup
      (//runtime.get //runtime.stack_head)))

(def: pop
  (Bytecode Any)
  ($_ _.compose
      (//runtime.get //runtime.stack_tail)
      (_.checkcast //type.stack)))

(def: (left_projection lefts)
  (-> Nat (Bytecode Any))
  ($_ _.compose
      (_.checkcast //type.tuple)
      (..int lefts)
      (.case lefts
        0
        _.aaload
        
        lefts
        //runtime.left_projection)))

(def: (right_projection lefts)
  (-> Nat (Bytecode Any))
  ($_ _.compose
      (_.checkcast //type.tuple)
      (..int lefts)
      //runtime.right_projection))

(def: (path' stack_depth @else @end phase archive path)
  (-> Nat Label Label (Generator Path))
  (.case path
    #synthesis.Pop
    (operation\in ..pop)
    
    (#synthesis.Bind register)
    (operation\in ($_ _.compose
                      ..peek
                      (_.astore register)))

    (#synthesis.Then bodyS)
    (do phase.monad
      [bodyG (phase archive bodyS)]
      (in ($_ _.compose
              (..pop_alt stack_depth)
              bodyG
              (_.goto @end))))
    
    (^template [<pattern> <right?>]
      [(^ (<pattern> lefts))
       (operation\in
        (do _.monad
          [@success _.new_label
           @fail _.new_label]
          ($_ _.compose
              ..peek
              (_.checkcast //type.variant)
              (//structure.tag lefts <right?>)
              (//structure.flag <right?>)
              //runtime.case
              _.dup
              (_.ifnull @fail)
              (_.goto @success)
              (_.set_label @fail)
              _.pop
              (_.goto @else)
              (_.set_label @success)
              //runtime.push)))])
    ([synthesis.side/left  false]
     [synthesis.side/right true])

    (^template [<pattern> <projection>]
      [(^ (<pattern> lefts))
       (operation\in ($_ _.compose
                         ..peek
                         (<projection> lefts)
                         //runtime.push))])
    ([synthesis.member/left ..left_projection]
     [synthesis.member/right ..right_projection])

    ... Extra optimization
    (^ (synthesis.path/seq
        (synthesis.member/left 0)
        (synthesis.!bind_top register thenP)))
    (do phase.monad
      [thenG (path' stack_depth @else @end phase archive thenP)]
      (in ($_ _.compose
              ..peek
              (_.checkcast //type.tuple)
              _.iconst_0
              _.aaload
              (_.astore register)
              thenG)))

    ... Extra optimization
    (^template [<pm> <projection>]
      [(^ (synthesis.path/seq
           (<pm> lefts)
           (synthesis.!bind_top register thenP)))
       (do phase.monad
         [then! (path' stack_depth @else @end phase archive thenP)]
         (in ($_ _.compose
                 ..peek
                 (_.checkcast //type.tuple)
                 (..int lefts)
                 <projection>
                 (_.astore register)
                 then!)))])
    ([synthesis.member/left //runtime.left_projection]
     [synthesis.member/right //runtime.right_projection])

    (#synthesis.Alt leftP rightP)
    (do phase.monad
      [@alt_else //runtime.forge_label
       left! (path' (inc stack_depth) @alt_else @end phase archive leftP)
       right! (path' stack_depth @else @end phase archive rightP)]
      (in ($_ _.compose
              _.dup
              left!
              (_.set_label @alt_else)
              _.pop
              right!)))
    
    (#synthesis.Seq leftP rightP)
    (do phase.monad
      [left! (path' stack_depth @else @end phase archive leftP)
       right! (path' stack_depth @else @end phase archive rightP)]
      (in ($_ _.compose
              left!
              right!)))

    _
    (undefined)
    ))

(def: (path @end phase archive path)
  (-> Label (Generator Path))
  (do phase.monad
    [@else //runtime.forge_label
     pathG (..path' 1 @else @end phase archive path)]
    (in ($_ _.compose
            pathG
            (_.set_label @else)
            _.pop
            //runtime.pm_failure
            _.aconst_null
            (_.goto @end)))))

(def: .public (if phase archive [conditionS thenS elseS])
  (Generator [Synthesis Synthesis Synthesis])
  (do phase.monad
    [conditionG (phase archive conditionS)
     thenG (phase archive thenS)
     elseG (phase archive elseS)]
    (in (do _.monad
          [@else _.new_label
           @end _.new_label]
          ($_ _.compose
              conditionG
              (//value.unwrap type.boolean)
              (_.ifeq @else)
              thenG
              (_.goto @end)
              (_.set_label @else)
              elseG
              (_.set_label @end))))))

(def: .public (let phase archive [inputS register bodyS])
  (Generator [Synthesis Register Synthesis])
  (do phase.monad
    [inputG (phase archive inputS)
     bodyG (phase archive bodyS)]
    (in ($_ _.compose
            inputG
            (_.astore register)
            bodyG))))

(def: .public (get phase archive [path recordS])
  (Generator [(List synthesis.Member) Synthesis])
  (do phase.monad
    [recordG (phase archive recordS)]
    (in (list\fold (function (_ step so_far)
                     (.let [next (.case step
                                   (#.Left lefts)
                                   (..left_projection lefts)
                                   
                                   (#.Right lefts)
                                   (..right_projection lefts))]
                       (_.compose so_far next)))
                   recordG
                   (list.reversed path)))))

(def: .public (case phase archive [valueS path])
  (Generator [Synthesis Path])
  (do phase.monad
    [@end //runtime.forge_label
     valueG (phase archive valueS)
     pathG (..path @end phase archive path)]
    (in ($_ _.compose
            _.aconst_null
            valueG
            //runtime.push
            pathG
            (_.set_label @end)))))
