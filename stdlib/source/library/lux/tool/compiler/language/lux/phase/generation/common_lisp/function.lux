(.module:
  [library
   [lux {"-" [function]}
    [abstract
     ["[0]" monad {"+" [do]}]]
    [control
     pipe]
    [data
     ["[0]" product]
     [text
      ["%" format {"+" [format]}]]
     [collection
      ["[0]" list ("[1]\[0]" functor)]]]
    [target
     ["_" common_lisp {"+" [Expression Var/1]}]]]]
  ["[0]" // "_"
   ["[1][0]" runtime {"+" [Operation Phase Generator]}]
   ["[1][0]" reference]
   ["[1][0]" case]
   ["/[1]" // "_"
    ["[1][0]" reference]
    ["//[1]" /// "_"
     [analysis {"+" [Variant Tuple Abstraction Application Analysis]}]
     [synthesis {"+" [Synthesis]}]
     ["[1][0]" generation {"+" [Context]}]
     ["//[1]" /// "_"
      [arity {"+" [Arity]}]
      ["[1][0]" phase ("[1]\[0]" monad)]
      [reference
       [variable {"+" [Register Variable]}]]]]]])

(def: .public (apply expression archive [functionS argsS+])
  (Generator (Application Synthesis))
  (do [! ///////phase.monad]
    [functionG (expression archive functionS)
     argsG+ (monad.each ! (expression archive) argsS+)]
    (in (_.funcall/+ [functionG argsG+]))))

(def: capture
  (-> Register Var/1)
  (|>> (///reference.foreign //reference.system) :expected))

(def: (with_closure inits function_definition)
  (-> (List (Expression Any)) (Expression Any) (Operation (Expression Any)))
  (case inits
    #.End
    (\ ///////phase.monad in function_definition)

    _
    (do [! ///////phase.monad]
      [@closure (\ ! each _.var (/////generation.identifier "closure"))]
      (in (_.labels (list [@closure [(|> (list.enumeration inits)
                                         (list\each (|>> product.left ..capture))
                                         _.args)
                                     function_definition]])
                    (_.funcall/+ [(_.function/1 @closure) inits]))))))

(def: input
  (|>> ++ //case.register))

(def: .public (function expression archive [environment arity bodyS])
  (Generator (Abstraction Synthesis))
  (do [! ///////phase.monad]
    [@scope (\ ! each (|>> %.nat (format "function_scope") _.tag) /////generation.next)
     @output (\ ! each (|>> %.nat (format "loop_output") _.var) /////generation.next)
     [function_name bodyG] (/////generation.with_new_context archive
                             (/////generation.with_anchor [@scope 1]
                               (expression archive bodyS)))
     closureG+ (monad.each ! (expression archive) environment)
     .let [@curried (_.var "curried")
           @missing (_.var "missing")
           arityG (|> arity .int _.int)
           @num_args (_.var "num_args")
           @self (_.var (///reference.artifact function_name))
           initialize_self! [(//case.register 0) (_.function/1 @self)]
           initialize! [(|> (list.indices arity)
                            (list\each ..input)
                            _.args)
                        @curried]]]
    (with_closure closureG+
      (_.labels (list [@self [(_.args& (list) @curried)
                              (_.let (list [@num_args (_.length/1 @curried)])
                                (list (_.cond (list [(_.=/2 [arityG @num_args])
                                                     (_.let (list [@output _.nil]
                                                                  initialize_self!)
                                                       (list (_.destructuring-bind initialize!
                                                                                   (list (_.tagbody
                                                                                          (list @scope
                                                                                                (_.setq @output bodyG)))
                                                                                         @output))))]

                                                    [(_.>/2 [arityG @num_args])
                                                     (let [arity_inputs (_.subseq/3 [@curried (_.int +0) arityG])
                                                           extra_inputs (_.subseq/3 [@curried arityG @num_args])]
                                                       (_.apply/2 [(_.apply/2 [(_.function/1 @self)
                                                                               arity_inputs])
                                                                   extra_inputs]))])
                                              ... (|> @num_args (_.< arityG))
                                              (_.lambda (_.args& (list) @missing)
                                                        (_.apply/2 [(_.function/1 @self)
                                                                    (_.append/2 [@curried @missing])])))))]])
                (_.function/1 @self)))
    ))
