(.module:
  [library
   [lux "*"
    ["[0]" meta]
    [abstract
     ["[0]" monad {"+" [do]}]]
    [control
     [io {"+" [IO]}]
     ["[0]" try]
     ["[0]" exception {"+" [exception:]}]
     ["<>" parser
      ["<[0]>" code {"+" [Parser]}]]]
    [data
     ["[0]" product]
     ["[0]" text
      ["%" format {"+" [format]}]]
     [collection
      ["[0]" dictionary]]]
    [macro
     ["[0]" code]]
    [math
     [number
      ["n" nat]]]
    ["[0]" type {"+" [:sharing]}
     ["[0]" check]]]]
  ["[0]" /// {"+" [Extender]}
   ["[1][0]" bundle]
   ["[1][0]" analysis]
   ["/[1]" // "_"
    [analysis
     ["[0]" module]
     ["[0]A" type]]
    ["/[1]" // "_"
     ["[1][0]" analysis
      [macro {"+" [Expander]}]
      ["[1]/[0]" evaluation]]
     ["[1][0]" synthesis {"+" [Synthesis]}]
     ["[1][0]" generation {"+" [Context]}]
     ["[1][0]" directive {"+" [Import Requirements Phase Operation Handler Bundle]}]
     ["[1][0]" program {"+" [Program]}]
     [///
      ["[0]" phase]
      [meta
       ["[0]" archive {"+" [Archive]}]]]]]])

(def: .public (custom [syntax handler])
  (All (_ anchor expression directive s)
    (-> [(Parser s)
         (-> Text
             (Phase anchor expression directive)
             Archive
             s
             (Operation anchor expression directive Requirements))]
        (Handler anchor expression directive)))
  (function (_ extension_name phase archive inputs)
    (case (<code>.result syntax inputs)
      (#try.Success inputs)
      (handler extension_name phase archive inputs)

      (#try.Failure error)
      (phase.except ///.invalid_syntax [extension_name %.code inputs]))))

(def: (context [module_id artifact_id])
  (-> Context Context)
  ... TODO: Find a better way that doesn't rely on clever tricks.
  [module_id (n.- (++ artifact_id) 0)])

... TODO: Inline "evaluate!'" into "evaluate!" ASAP
(def: (evaluate!' archive generate code//type codeS)
  (All (_ anchor expression directive)
    (-> Archive
        (/////generation.Phase anchor expression directive)
        Type
        Synthesis
        (Operation anchor expression directive [Type expression Any])))
  (/////directive.lifted_generation
   (do phase.monad
     [module /////generation.module
      id /////generation.next
      codeG (generate archive codeS)
      module_id (/////generation.module_id module archive)
      codeV (/////generation.evaluate! (..context [module_id id]) codeG)]
     (in [code//type codeG codeV]))))

(def: .public (evaluate! archive type codeC)
  (All (_ anchor expression directive)
    (-> Archive Type Code (Operation anchor expression directive [Type expression Any])))
  (do phase.monad
    [state (///.lifted phase.get_state)
     .let [analyse (value@ [#/////directive.analysis #/////directive.phase] state)
           synthesize (value@ [#/////directive.synthesis #/////directive.phase] state)
           generate (value@ [#/////directive.generation #/////directive.phase] state)]
     [_ codeA] (/////directive.lifted_analysis
                (/////analysis.with_scope
                  (typeA.with_fresh_env
                    (typeA.with_type type
                      (analyse archive codeC)))))
     codeS (/////directive.lifted_synthesis
            (synthesize archive codeA))]
    (evaluate!' archive generate type codeS)))

... TODO: Inline "definition'" into "definition" ASAP
(def: (definition' archive generate [module name] code//type codeS)
  (All (_ anchor expression directive)
    (-> Archive
        (/////generation.Phase anchor expression directive)
        Name
        Type
        Synthesis
        (Operation anchor expression directive [Type expression Any])))
  (/////directive.lifted_generation
   (do phase.monad
     [codeG (generate archive codeS)
      id (/////generation.learn name)
      module_id (phase.lifted (archive.id module archive))
      [target_name value directive] (/////generation.define! [module_id id] #.None codeG)
      _ (/////generation.save! id #.None directive)]
     (in [code//type codeG value]))))

(def: (definition archive name expected codeC)
  (All (_ anchor expression directive)
    (-> Archive Name (Maybe Type) Code
        (Operation anchor expression directive [Type expression Any])))
  (do [! phase.monad]
    [state (///.lifted phase.get_state)
     .let [analyse (value@ [#/////directive.analysis #/////directive.phase] state)
           synthesize (value@ [#/////directive.synthesis #/////directive.phase] state)
           generate (value@ [#/////directive.generation #/////directive.phase] state)]
     [_ code//type codeA] (/////directive.lifted_analysis
                           (/////analysis.with_scope
                             (typeA.with_fresh_env
                               (case expected
                                 #.None
                                 (do !
                                   [[code//type codeA] (typeA.with_inference
                                                         (analyse archive codeC))
                                    code//type (typeA.with_env
                                                 (check.clean code//type))]
                                   (in [code//type codeA]))

                                 (#.Some expected)
                                 (do !
                                   [codeA (typeA.with_type expected
                                            (analyse archive codeC))]
                                   (in [expected codeA]))))))
     codeS (/////directive.lifted_synthesis
            (synthesize archive codeA))]
    (definition' archive generate name code//type codeS)))

(template [<full> <partial> <learn>]
  [... TODO: Inline "<partial>" into "<full>" ASAP
   (def: (<partial> archive generate extension codeT codeS)
     (All (_ anchor expression directive)
       (-> Archive
           (/////generation.Phase anchor expression directive)
           Text
           Type
           Synthesis
           (Operation anchor expression directive [expression Any])))
     (do phase.monad
       [current_module (/////directive.lifted_analysis
                        (///.lifted meta.current_module_name))]
       (/////directive.lifted_generation
        (do phase.monad
          [codeG (generate archive codeS)
           module_id (phase.lifted (archive.id current_module archive))
           id (<learn> extension)
           [target_name value directive] (/////generation.define! [module_id id] #.None codeG)
           _ (/////generation.save! id #.None directive)]
          (in [codeG value])))))

   (def: .public (<full> archive extension codeT codeC)
     (All (_ anchor expression directive)
       (-> Archive Text Type Code
           (Operation anchor expression directive [expression Any])))
     (do phase.monad
       [state (///.lifted phase.get_state)
        .let [analyse (value@ [#/////directive.analysis #/////directive.phase] state)
              synthesize (value@ [#/////directive.synthesis #/////directive.phase] state)
              generate (value@ [#/////directive.generation #/////directive.phase] state)]
        [_ codeA] (/////directive.lifted_analysis
                   (/////analysis.with_scope
                     (typeA.with_fresh_env
                       (typeA.with_type codeT
                         (analyse archive codeC)))))
        codeS (/////directive.lifted_synthesis
               (synthesize archive codeA))]
       (<partial> archive generate extension codeT codeS)))]

  [analyser analyser' /////generation.learn_analyser]
  [synthesizer synthesizer' /////generation.learn_synthesizer]
  [generator generator' /////generation.learn_generator]
  [directive directive' /////generation.learn_directive]
  )

(def: (refresh expander host_analysis)
  (All (_ anchor expression directive)
    (-> Expander /////analysis.Bundle (Operation anchor expression directive Any)))
  (do phase.monad
    [[bundle state] phase.get_state
     .let [eval (/////analysis/evaluation.evaluator expander
                                                    (value@ [#/////directive.synthesis #/////directive.state] state)
                                                    (value@ [#/////directive.generation #/////directive.state] state)
                                                    (value@ [#/////directive.generation #/////directive.phase] state))]]
    (phase.set_state [bundle
                      (revised@ [#/////directive.analysis #/////directive.state]
                                (: (-> /////analysis.State+ /////analysis.State+)
                                   (|>> product.right
                                        [(///analysis.bundle eval host_analysis)]))
                                state)])))

(def: (announce_definition! short type)
  (All (_ anchor expression directive)
    (-> Text Type (Operation anchor expression directive Any)))
  (/////directive.lifted_generation
   (/////generation.log! (format short " : " (%.type type)))))

(def: (lux::def expander host_analysis)
  (-> Expander /////analysis.Bundle Handler)
  (function (_ extension_name phase archive inputsC+)
    (case inputsC+
      (^ (list [_ (#.Identifier ["" short_name])] valueC annotationsC exported?C))
      (do phase.monad
        [current_module (/////directive.lifted_analysis
                         (///.lifted meta.current_module_name))
         .let [full_name [current_module short_name]]
         [type valueT value] (..definition archive full_name #.None valueC)
         [_ _ exported?] (evaluate! archive Bit exported?C)
         [_ _ annotations] (evaluate! archive Code annotationsC)
         _ (/////directive.lifted_analysis
            (module.define short_name (#.Definition [(:as Bit exported?) type (:as Code annotations) value])))
         _ (..refresh expander host_analysis)
         _ (..announce_definition! short_name type)]
        (in /////directive.no_requirements))

      _
      (phase.except ///.invalid_syntax [extension_name %.code inputsC+]))))

(def: (announce_labels! tags owner)
  (All (_ anchor expression directive)
    (-> (List Text) Type (Operation anchor expression directive (List Any))))
  (/////directive.lifted_generation
   (monad.each phase.monad
               (function (_ tag)
                 (/////generation.log! (format "#" tag " : Tag of " (%.type owner))))
               tags)))

(def: (def::type_tagged expander host_analysis)
  (-> Expander /////analysis.Bundle Handler)
  (..custom
   [($_ <>.and <code>.local_identifier <code>.any <code>.any
        (<>.or (<code>.form (<>.some <code>.text))
               (<code>.tuple (<>.some <code>.text)))
        <code>.any)
    (function (_ extension_name phase archive [short_name valueC annotationsC labels exported?C])
      (do phase.monad
        [current_module (/////directive.lifted_analysis
                         (///.lifted meta.current_module_name))
         .let [full_name [current_module short_name]]
         [_ _ exported?] (evaluate! archive Bit exported?C)
         [_ _ annotations] (evaluate! archive Code annotationsC)
         .let [exported? (:as Bit exported?)
               annotations (:as Code annotations)]
         [type valueT value] (..definition archive full_name (#.Some .Type) valueC)
         labels (/////directive.lifted_analysis
                 (do phase.monad
                   [.let [[record? labels] (case labels
                                             (#.Left tags)
                                             [false tags]
                                             
                                             (#.Right slots)
                                             [true slots])]
                    _ (case labels
                        #.End
                        (module.define short_name (#.Definition [exported? type annotations value]))

                        (#.Item labels)
                        (module.define short_name (#.Type [exported? (:as .Type value) (if record?
                                                                                         (#.Right labels)
                                                                                         (#.Left labels))])))
                    _ (module.declare_tags record? labels exported? (:as .Type value))]
                   (in labels)))
         _ (..refresh expander host_analysis)
         _ (..announce_definition! short_name type)
         _ (..announce_labels! labels (:as Type value))]
        (in /////directive.no_requirements)))]))

(def: imports
  (Parser (List Import))
  (|> (<code>.tuple (<>.and <code>.text <code>.text))
      <>.some
      <code>.tuple))

(def: def::module
  Handler
  (..custom
   [($_ <>.and <code>.any ..imports)
    (function (_ extension_name phase archive [annotationsC imports])
      (do [! phase.monad]
        [[_ _ annotationsV] (evaluate! archive Code annotationsC)
         .let [annotationsV (:as Code annotationsV)]
         _ (/////directive.lifted_analysis
            (do !
              [_ (monad.each ! (function (_ [module alias])
                                 (do !
                                   [_ (module.import module)]
                                   (case alias
                                     "" (in [])
                                     _ (module.alias alias module))))
                             imports)]
              (module.set_annotations annotationsV)))]
        (in [#/////directive.imports imports
             #/////directive.referrals (list)])))]))

(exception: .public (cannot_alias_an_alias {local Alias} {foreign Alias} {target Name})
  (exception.report
   ["Local alias" (%.name local)]
   ["Foreign alias" (%.name foreign)]
   ["Target definition" (%.name target)]))

(exception: .public (cannot_alias_a_label {local Alias} {foreign Alias})
  (exception.report
   ["Alias" (%.name local)]
   ["Label" (%.name foreign)]))

(def: (define_alias alias original)
  (-> Text Name (/////analysis.Operation Any))
  (do phase.monad
    [current_module (///.lifted meta.current_module_name)
     constant (///.lifted (meta.definition original))]
    (case constant
      (#.Alias de_aliased)
      (phase.except ..cannot_alias_an_alias [[current_module alias] original de_aliased])
      
      (^or (#.Definition _)
           (#.Type _))
      (module.define alias (#.Alias original))

      (^or (#.Label _)
           (#.Slot _))
      (phase.except ..cannot_alias_a_label [[current_module alias] original]))))

(def: def::alias
  Handler
  (..custom
   [($_ <>.and <code>.local_identifier <code>.identifier)
    (function (_ extension_name phase archive [alias def_name])
      (do phase.monad
        [_ (///.lifted
            (phase.sub [(value@ [#/////directive.analysis #/////directive.state])
                        (with@ [#/////directive.analysis #/////directive.state])]
                       (define_alias alias def_name)))]
        (in /////directive.no_requirements)))]))

(template [<description> <mame> <def_type> <type> <scope> <definer>]
  [(def: (<mame> [anchorT expressionT directiveT] extender)
     (All (_ anchor expression directive)
       (-> [Type Type Type] Extender
           (Handler anchor expression directive)))
     (function (handler extension_name phase archive inputsC+)
       (case inputsC+
         (^ (list nameC valueC))
         (do phase.monad
           [[_ _ name] (evaluate! archive Text nameC)
            [_ handlerV] (<definer> archive (:as Text name)
                                    (type <def_type>)
                                    valueC)
            _ (<| <scope>
                  (///.install extender (:as Text name))
                  (:sharing [anchor expression directive]
                            (Handler anchor expression directive)
                            handler
                            
                            <type>
                            (:expected handlerV)))
            _ (/////directive.lifted_generation
               (/////generation.log! (format <description> " " (%.text (:as Text name)))))]
           (in /////directive.no_requirements))

         _
         (phase.except ///.invalid_syntax [extension_name %.code inputsC+]))))]

  ["Analysis"
   def::analysis
   /////analysis.Handler /////analysis.Handler
   /////directive.lifted_analysis
   ..analyser]
  ["Synthesis"
   def::synthesis
   /////synthesis.Handler /////synthesis.Handler
   /////directive.lifted_synthesis
   ..synthesizer]
  ["Generation"
   def::generation
   (/////generation.Handler anchorT expressionT directiveT) (/////generation.Handler anchor expression directive)
   /////directive.lifted_generation
   ..generator]
  ["Directive"
   def::directive
   (/////directive.Handler anchorT expressionT directiveT) (/////directive.Handler anchor expression directive)
   (<|)
   ..directive]
  )

... TODO; Both "prepare-program" and "define-program" exist only
... because the old compiler couldn't handle a fully-inlined definition
... for "def::program". Inline them ASAP.
(def: (prepare_program archive analyse synthesize programC)
  (All (_ anchor expression directive output)
    (-> Archive
        /////analysis.Phase
        /////synthesis.Phase
        Code
        (Operation anchor expression directive Synthesis)))
  (do phase.monad
    [[_ programA] (/////directive.lifted_analysis
                   (/////analysis.with_scope
                     (typeA.with_fresh_env
                       (typeA.with_type (type (-> (List Text) (IO Any)))
                         (analyse archive programC)))))]
    (/////directive.lifted_synthesis
     (synthesize archive programA))))

(def: (define_program archive module_id generate program programS)
  (All (_ anchor expression directive output)
    (-> Archive
        archive.ID
        (/////generation.Phase anchor expression directive)
        (Program expression directive)
        Synthesis
        (/////generation.Operation anchor expression directive Any)))
  (do phase.monad
    [programG (generate archive programS)
     artifact_id (/////generation.learn /////program.name)]
    (/////generation.save! artifact_id #.None (program [module_id artifact_id] programG))))

(def: (def::program program)
  (All (_ anchor expression directive)
    (-> (Program expression directive) (Handler anchor expression directive)))
  (function (handler extension_name phase archive inputsC+)
    (case inputsC+
      (^ (list programC))
      (do phase.monad
        [state (///.lifted phase.get_state)
         .let [analyse (value@ [#/////directive.analysis #/////directive.phase] state)
               synthesize (value@ [#/////directive.synthesis #/////directive.phase] state)
               generate (value@ [#/////directive.generation #/////directive.phase] state)]
         programS (prepare_program archive analyse synthesize programC)
         current_module (/////directive.lifted_analysis
                         (///.lifted meta.current_module_name))
         module_id (phase.lifted (archive.id current_module archive))
         _ (/////directive.lifted_generation
            (define_program archive module_id generate program programS))]
        (in /////directive.no_requirements))

      _
      (phase.except ///.invalid_syntax [extension_name %.code inputsC+]))))

(def: (bundle::def expander host_analysis program anchorT,expressionT,directiveT extender)
  (All (_ anchor expression directive)
    (-> Expander
        /////analysis.Bundle
        (Program expression directive)
        [Type Type Type]
        Extender
        (Bundle anchor expression directive)))
  (<| (///bundle.prefix "def")
      (|> ///bundle.empty
          (dictionary.has "module" def::module)
          (dictionary.has "alias" def::alias)
          (dictionary.has "type tagged" (def::type_tagged expander host_analysis))
          (dictionary.has "analysis" (def::analysis anchorT,expressionT,directiveT extender))
          (dictionary.has "synthesis" (def::synthesis anchorT,expressionT,directiveT extender))
          (dictionary.has "generation" (def::generation anchorT,expressionT,directiveT extender))
          (dictionary.has "directive" (def::directive anchorT,expressionT,directiveT extender))
          (dictionary.has "program" (def::program program))
          )))

(def: .public (bundle expander host_analysis program anchorT,expressionT,directiveT extender)
  (All (_ anchor expression directive)
    (-> Expander
        /////analysis.Bundle
        (Program expression directive)
        [Type Type Type]
        Extender
        (Bundle anchor expression directive)))
  (<| (///bundle.prefix "lux")
      (|> ///bundle.empty
          (dictionary.has "def" (lux::def expander host_analysis))
          (dictionary.merged (..bundle::def expander host_analysis program anchorT,expressionT,directiveT extender)))))
