(.using
 [library
  [lux (.except)
   ["@" target]
   ["[0]" meta]
   [abstract
    ["[0]" monad (.only do)]]
   [control
    [io (.only IO)]
    ["[0]" maybe (.open: "[1]#[0]" functor)]
    ["[0]" try]
    ["[0]" exception (.only exception:)]
    ["<>" parser (.only)
     ["<[0]>" code (.only Parser)]]]
   [data
    ["[0]" binary]
    ["[0]" product]
    ["[0]" text
     ["%" \\format (.only format)]]
    [collection
     ["[0]" dictionary]
     ["[0]" array]
     ["[0]" list (.open: "[1]#[0]" functor mix)]
     ["[0]" set (.only Set)]]]
   [macro
    ["^" pattern]
    ["[0]" code]]
   [math
    [number
     ["n" nat]]]
   ["[0]" type (.only sharing) (.open: "[1]#[0]" equivalence)
    ["[0]" check]]]]
 ["[0]" /// (.only Extender)
  ["[1][0]" bundle]
  ["[1][0]" analysis]
  ["/[1]" //
   ["/[1]" //
    ["[1][0]" analysis (.only)
     [macro (.only Expander)]
     ["[1]/[0]" evaluation]
     ["[0]A" type]
     ["[0]A" module]
     ["[0]" scope]]
    ["[1][0]" synthesis (.only Synthesis)]
    ["[1][0]" generation]
    ["[1][0]" directive (.only Import Requirements Phase Operation Handler Bundle)]
    ["[1][0]" program (.only Program)]
    [///
     ["[0]" phase]
     [meta
      ["[0]" archive (.only Archive)
       ["[0]" artifact]
       ["[0]" module]
       ["[0]" unit]]
      ["[0]" cache
       [dependency
        ["[1]/[0]" artifact]]]]]]]])

(def: .public (custom [syntax handler])
  (All (_ anchor expression directive s)
    (-> [(Parser s)
         (-> Text
             (Phase anchor expression directive)
             Archive
             s
             (Operation anchor expression directive Requirements))]
        (Handler anchor expression directive)))
  (function (_ extension_name phase archive inputs)
    (case (<code>.result syntax inputs)
      {try.#Success inputs}
      (handler extension_name phase archive inputs)

      {try.#Failure error}
      (phase.except ///.invalid_syntax [extension_name %.code inputs]))))

(def: (context [@module @artifact])
  (-> unit.ID unit.ID)
  ... TODO: Find a better way that doesn't rely on clever tricks.
  [@module (n.- (++ @artifact) 0)])

... TODO: Inline "evaluate!'" into "evaluate!" ASAP
(def: (evaluate!' archive generate code//type codeS)
  (All (_ anchor expression directive)
    (-> Archive
        (/////generation.Phase anchor expression directive)
        Type
        Synthesis
        (Operation anchor expression directive [Type expression Any])))
  (/////directive.lifted_generation
   (do phase.monad
     [module /////generation.module
      id /////generation.next
      codeG (generate archive codeS)
      @module (/////generation.module_id module archive)
      codeV (/////generation.evaluate! (..context [@module id]) [{.#None} codeG])]
     (in [code//type codeG codeV]))))

(def: .public (evaluate! archive type codeC)
  (All (_ anchor expression directive)
    (-> Archive Type Code (Operation anchor expression directive [Type expression Any])))
  (do phase.monad
    [state (///.lifted phase.state)
     .let [analyse (the [/////directive.#analysis /////directive.#phase] state)
           synthesize (the [/////directive.#synthesis /////directive.#phase] state)
           generate (the [/////directive.#generation /////directive.#phase] state)]
     [_ codeA] (<| /////directive.lifted_analysis
                   scope.with
                   typeA.fresh
                   (typeA.expecting type)
                   (analyse archive codeC))
     codeS (/////directive.lifted_synthesis
            (synthesize archive codeA))]
    (evaluate!' archive generate type codeS)))

... TODO: Inline "definition'" into "definition" ASAP
(def: (definition' archive generate [module name] code//type codeS)
  (All (_ anchor expression directive)
    (-> Archive
        (/////generation.Phase anchor expression directive)
        Symbol
        Type
        Synthesis
        (Operation anchor expression directive [Type expression Any])))
  (/////directive.lifted_generation
   (do phase.monad
     [dependencies (cache/artifact.dependencies archive codeS)
      [interim_artifacts codeG] (/////generation.with_interim_artifacts archive
                                  (generate archive codeS))
      .let [@abstraction (case codeS
                           (pattern (/////synthesis.function/abstraction [env arity body]))
                           (|> interim_artifacts
                               list.last
                               (maybe#each (|>> [arity])))

                           _
                           {.#None})]
      @module (phase.lifted (archive.id module archive))
      @self (/////generation.learn [name @abstraction] false (list#mix set.has dependencies interim_artifacts))
      [target_name value directive] (/////generation.define! [@module @self] {.#None} [(maybe#each product.right @abstraction) codeG])
      _ (/////generation.save! @self {.#None} directive)]
     (in [code//type codeG value]))))

(def: (definition archive name expected codeC)
  (All (_ anchor expression directive)
    (-> Archive Symbol (Maybe Type) Code
        (Operation anchor expression directive [Type expression Any])))
  (do [! phase.monad]
    [state (///.lifted phase.state)
     .let [analyse (the [/////directive.#analysis /////directive.#phase] state)
           synthesize (the [/////directive.#synthesis /////directive.#phase] state)
           generate (the [/////directive.#generation /////directive.#phase] state)]
     [_ code//type codeA] (/////directive.lifted_analysis
                           (scope.with
                             (typeA.fresh
                              (case expected
                                {.#None}
                                (do !
                                  [[code//type codeA] (typeA.inferring
                                                       (analyse archive codeC))
                                   code//type (typeA.check (check.clean (list) code//type))]
                                  (in [code//type codeA]))

                                {.#Some expected}
                                (do !
                                  [codeA (<| (typeA.expecting expected)
                                             (analyse archive codeC))]
                                  (in [expected codeA]))))))
     codeS (/////directive.lifted_synthesis
            (synthesize archive codeA))]
    (definition' archive generate name code//type codeS)))

(with_template [<full> <partial> <learn>]
  [... TODO: Inline "<partial>" into "<full>" ASAP
   (def: (<partial> archive generate extension codeT codeS)
     (All (_ anchor expression directive)
       (-> Archive
           (/////generation.Phase anchor expression directive)
           Text
           Type
           Synthesis
           (Operation anchor expression directive [expression Any])))
     (do phase.monad
       [current_module (/////directive.lifted_analysis
                        (///.lifted meta.current_module_name))]
       (/////directive.lifted_generation
        (do phase.monad
          [dependencies (cache/artifact.dependencies archive codeS)
           [interim_artifacts codeG] (/////generation.with_interim_artifacts archive
                                       (generate archive codeS))
           @module (phase.lifted (archive.id current_module archive))
           @self (<learn> extension (list#mix set.has dependencies interim_artifacts))
           [target_name value directive] (/////generation.define! [@module @self] {.#None} [{.#None} codeG])
           _ (/////generation.save! @self {.#None} directive)]
          (in [codeG value])))))

   (def: .public (<full> archive extension codeT codeC)
     (All (_ anchor expression directive)
       (-> Archive Text Type Code
           (Operation anchor expression directive [expression Any])))
     (do phase.monad
       [state (///.lifted phase.state)
        .let [analyse (the [/////directive.#analysis /////directive.#phase] state)
              synthesize (the [/////directive.#synthesis /////directive.#phase] state)
              generate (the [/////directive.#generation /////directive.#phase] state)]
        [_ codeA] (<| /////directive.lifted_analysis
                      scope.with
                      typeA.fresh
                      (typeA.expecting codeT)
                      (analyse archive codeC))
        codeS (/////directive.lifted_synthesis
               (synthesize archive codeA))]
       (<partial> archive generate extension codeT codeS)))]

  [analyser analyser' /////generation.learn_analyser]
  [synthesizer synthesizer' /////generation.learn_synthesizer]
  [generator generator' /////generation.learn_generator]
  [directive directive' /////generation.learn_directive]
  )

... TODO: Get rid of this function ASAP.
(def: (refresh expander host_analysis)
  (All (_ anchor expression directive)
    (-> Expander /////analysis.Bundle (Operation anchor expression directive Any)))
  (do phase.monad
    [[bundle state] phase.state
     .let [eval (/////analysis/evaluation.evaluator expander
                                                    (the [/////directive.#synthesis /////directive.#state] state)
                                                    (the [/////directive.#generation /////directive.#state] state)
                                                    (the [/////directive.#generation /////directive.#phase] state))
           previous_analysis_extensions (the [/////directive.#analysis /////directive.#state ///.#bundle] state)]]
    (phase.with [bundle
                 (revised [/////directive.#analysis /////directive.#state]
                          (is (-> /////analysis.State+ /////analysis.State+)
                              (|>> product.right
                                   [(|> previous_analysis_extensions
                                        (dictionary.composite (///analysis.bundle eval host_analysis)))]))
                          state)])))

(def: (announce_definition! short type)
  (All (_ anchor expression directive)
    (-> Text Type (Operation anchor expression directive Any)))
  (/////directive.lifted_generation
   (/////generation.log! (format short " : " (%.type type)))))

(def: (lux::def expander host_analysis)
  (-> Expander /////analysis.Bundle Handler)
  (function (_ extension_name phase archive inputsC+)
    (case inputsC+
      (pattern (list [_ {.#Symbol ["" short_name]}] valueC exported?C))
      (do phase.monad
        [current_module (/////directive.lifted_analysis
                         (///.lifted meta.current_module_name))
         .let [full_name [current_module short_name]]
         [type valueT value] (..definition archive full_name {.#None} valueC)
         [_ _ exported?] (evaluate! archive Bit exported?C)
         _ (/////directive.lifted_analysis
            (moduleA.define short_name {.#Definition [(as Bit exported?) type value]}))
         _ (..refresh expander host_analysis)
         _ (..announce_definition! short_name type)]
        (in /////directive.no_requirements))

      _
      (phase.except ///.invalid_syntax [extension_name %.code inputsC+]))))

(def: (announce_labels! labels owner)
  (All (_ anchor expression directive)
    (-> (List Text) Type (Operation anchor expression directive (List Any))))
  (/////directive.lifted_generation
   (monad.each phase.monad
               (function (_ tag)
                 (/////generation.log! (format tag " : Tag of " (%.type owner))))
               labels)))

(def: (def::type_tagged expander host_analysis)
  (-> Expander /////analysis.Bundle Handler)
  (..custom
   [(all <>.and <code>.local <code>.any
         (<>.or (<code>.variant (<>.some <code>.text))
                (<code>.tuple (<>.some <code>.text)))
         <code>.any)
    (function (_ extension_name phase archive [short_name valueC labels exported?C])
      (do phase.monad
        [current_module (/////directive.lifted_analysis
                         (///.lifted meta.current_module_name))
         .let [full_name [current_module short_name]]
         [_ _ exported?] (evaluate! archive Bit exported?C)
         .let [exported? (as Bit exported?)]
         [type valueT value] (..definition archive full_name {.#Some .Type} valueC)
         labels (/////directive.lifted_analysis
                 (do phase.monad
                   [.let [[record? labels] (case labels
                                             {.#Left tags}
                                             [false tags]
                                             
                                             {.#Right slots}
                                             [true slots])]
                    _ (case labels
                        {.#End}
                        (moduleA.define short_name {.#Definition [exported? type value]})

                        {.#Item labels}
                        (moduleA.define short_name {.#Type [exported? (as .Type value) (if record?
                                                                                         {.#Right labels}
                                                                                         {.#Left labels})]}))
                    _ (moduleA.declare_labels record? labels exported? (as .Type value))]
                   (in labels)))
         _ (..refresh expander host_analysis)
         _ (..announce_definition! short_name type)
         _ (..announce_labels! labels (as Type value))]
        (in /////directive.no_requirements)))]))

(def: imports
  (Parser (List Import))
  (|> (<code>.tuple (<>.and <code>.text <code>.text))
      <>.some
      <code>.tuple))

(def: def::module
  Handler
  (..custom
   [..imports
    (function (_ extension_name phase archive imports)
      (do [! phase.monad]
        [_ (/////directive.lifted_analysis
            (monad.each ! (function (_ [module alias])
                            (do !
                              [_ (moduleA.import module)]
                              (case alias
                                "" (in [])
                                _ (moduleA.alias alias module))))
                        imports))]
        (in [/////directive.#imports imports
             /////directive.#referrals (list)])))]))

(exception: .public (cannot_alias_an_alias [local Alias
                                            foreign Alias
                                            target Symbol])
  (exception.report
   "Local alias" (%.symbol local)
   "Foreign alias" (%.symbol foreign)
   "Target definition" (%.symbol target)))

(exception: .public (cannot_alias_a_label [local Alias
                                           foreign Alias])
  (exception.report
   "Alias" (%.symbol local)
   "Label" (%.symbol foreign)))

(def: (define_alias alias original)
  (-> Text Symbol (/////analysis.Operation Any))
  (do phase.monad
    [current_module (///.lifted meta.current_module_name)
     constant (///.lifted (meta.definition original))]
    (case constant
      {.#Alias de_aliased}
      (phase.except ..cannot_alias_an_alias [[current_module alias] original de_aliased])
      
      (^.or {.#Definition _}
            {.#Type _})
      (moduleA.define alias {.#Alias original})

      (^.or {.#Tag _}
            {.#Slot _})
      (phase.except ..cannot_alias_a_label [[current_module alias] original]))))

(def: def::alias
  Handler
  (..custom
   [(all <>.and <code>.local <code>.symbol)
    (function (_ extension_name phase archive [alias def_name])
      (do phase.monad
        [_ (///.lifted
            (phase.sub [(the [/////directive.#analysis /////directive.#state])
                        (has [/////directive.#analysis /////directive.#state])]
                       (define_alias alias def_name)))]
        (in /////directive.no_requirements)))]))

... TODO: Stop requiring these types and the "swapped" function below to make types line-up.
(with_template [<name> <anonymous>]
  [(def: <name>
     Type
     (with_expansions [<original> binary.Binary]
       (let [_ <original>]
         {.#Named (symbol <original>)
                  <anonymous>})))]

  [Binary|Python (Primitive "bytearray")]
  [Binary|DEFAULT (type (array.Array (I64 Any)))]
  )

(def: (swapped original replacement)
  (-> Type Type Type Type)
  (function (again type)
    (if (type#= original type)
      replacement
      (case type
        {.#Primitive name parameters}
        {.#Primitive name (list#each again parameters)}

        (^.with_template [<tag>]
          [{<tag> left right}
           {<tag> (again left) (again right)}])
        ([.#Sum]
         [.#Product]
         [.#Function]
         [.#Apply])
        
        (^.or {.#Parameter _}
              {.#Var _}
              {.#Ex _})
        type

        (^.with_template [<tag>]
          [{<tag> closure body}
           {<tag> closure (again body)}])
        ([.#UnivQ]
         [.#ExQ])
        
        {.#Named name anonymous}
        {.#Named name (again anonymous)}))))

(with_template [<description> <mame> <def_type> <type> <scope> <definer>]
  [(def: (<mame> [anchorT expressionT directiveT] extender)
     (All (_ anchor expression directive)
       (-> [Type Type Type] Extender
           (Handler anchor expression directive)))
     (function (handler extension_name phase archive inputsC+)
       (case inputsC+
         (pattern (list nameC valueC))
         (do phase.monad
           [target_platform (/////directive.lifted_analysis
                             (///.lifted meta.target))
            [_ _ name] (evaluate! archive Text nameC)
            [_ handlerV] (<definer> archive (as Text name)
                                    (let [raw_type (type <def_type>)]
                                      (case target_platform
                                        (^.or (pattern (static @.jvm))
                                              (pattern (static @.js)))
                                        raw_type
                                        
                                        (pattern (static @.python))
                                        (swapped binary.Binary Binary|Python raw_type)

                                        _
                                        (swapped binary.Binary Binary|DEFAULT raw_type)))
                                    valueC)
            _ (<| <scope>
                  (///.install extender (as Text name))
                  (sharing [anchor expression directive]
                    (is (Handler anchor expression directive)
                        handler)
                    (is <type>
                        (as_expected handlerV))))
            _ (/////directive.lifted_generation
               (/////generation.log! (format <description> " " (%.text (as Text name)))))]
           (in /////directive.no_requirements))

         _
         (phase.except ///.invalid_syntax [extension_name %.code inputsC+]))))]

  ["Analysis"
   def::analysis
   /////analysis.Handler /////analysis.Handler
   /////directive.lifted_analysis
   ..analyser]
  ["Synthesis"
   def::synthesis
   /////synthesis.Handler /////synthesis.Handler
   /////directive.lifted_synthesis
   ..synthesizer]
  ["Generation"
   def::generation
   (/////generation.Handler anchorT expressionT directiveT) (/////generation.Handler anchor expression directive)
   /////directive.lifted_generation
   ..generator]
  ["Directive"
   def::directive
   (/////directive.Handler anchorT expressionT directiveT) (/////directive.Handler anchor expression directive)
   (<|)
   ..directive]
  )

... TODO; Both "prepare-program" and "define-program" exist only
... because the old compiler couldn't handle a fully-inlined definition
... for "def::program". Inline them ASAP.
(def: (prepare_program archive analyse synthesize programC)
  (All (_ anchor expression directive output)
    (-> Archive
        /////analysis.Phase
        /////synthesis.Phase
        Code
        (Operation anchor expression directive Synthesis)))
  (do phase.monad
    [[_ programA] (<| /////directive.lifted_analysis
                      scope.with
                      typeA.fresh
                      (typeA.expecting (type (-> (List Text) (IO Any))))
                      (analyse archive programC))]
    (/////directive.lifted_synthesis
     (synthesize archive programA))))

(def: (define_program archive @module generate program programS)
  (All (_ anchor expression directive output)
    (-> Archive
        module.ID
        (/////generation.Phase anchor expression directive)
        (Program expression directive)
        Synthesis
        (/////generation.Operation anchor expression directive Any)))
  (do phase.monad
    [dependencies (cache/artifact.dependencies archive programS)
     [interim_artifacts programG] (/////generation.with_interim_artifacts archive
                                    (generate archive programS))
     @self (/////generation.learn [/////program.name {.#None}] true (list#mix set.has dependencies interim_artifacts))]
    (/////generation.save! @self {.#None} (program [@module @self] programG))))

(def: (def::program program)
  (All (_ anchor expression directive)
    (-> (Program expression directive) (Handler anchor expression directive)))
  (function (handler extension_name phase archive inputsC+)
    (case inputsC+
      (pattern (list programC))
      (do phase.monad
        [state (///.lifted phase.state)
         .let [analyse (the [/////directive.#analysis /////directive.#phase] state)
               synthesize (the [/////directive.#synthesis /////directive.#phase] state)
               generate (the [/////directive.#generation /////directive.#phase] state)]
         programS (prepare_program archive analyse synthesize programC)
         current_module (/////directive.lifted_analysis
                         (///.lifted meta.current_module_name))
         @module (phase.lifted (archive.id current_module archive))
         _ (/////directive.lifted_generation
            (define_program archive @module generate program programS))]
        (in /////directive.no_requirements))

      _
      (phase.except ///.invalid_syntax [extension_name %.code inputsC+]))))

(def: (bundle::def expander host_analysis program anchorT,expressionT,directiveT extender)
  (All (_ anchor expression directive)
    (-> Expander
        /////analysis.Bundle
        (Program expression directive)
        [Type Type Type]
        Extender
        (Bundle anchor expression directive)))
  (<| (///bundle.prefix "def")
      (|> ///bundle.empty
          (dictionary.has "module" def::module)
          (dictionary.has "alias" def::alias)
          (dictionary.has "type tagged" (def::type_tagged expander host_analysis))
          (dictionary.has "analysis" (def::analysis anchorT,expressionT,directiveT extender))
          (dictionary.has "synthesis" (def::synthesis anchorT,expressionT,directiveT extender))
          (dictionary.has "generation" (def::generation anchorT,expressionT,directiveT extender))
          (dictionary.has "directive" (def::directive anchorT,expressionT,directiveT extender))
          (dictionary.has "program" (def::program program))
          )))

(def: .public (bundle expander host_analysis program anchorT,expressionT,directiveT extender)
  (All (_ anchor expression directive)
    (-> Expander
        /////analysis.Bundle
        (Program expression directive)
        [Type Type Type]
        Extender
        (Bundle anchor expression directive)))
  (<| (///bundle.prefix "lux")
      (|> ///bundle.empty
          (dictionary.has "def" (lux::def expander host_analysis))
          (dictionary.composite (..bundle::def expander host_analysis program anchorT,expressionT,directiveT extender)))))
