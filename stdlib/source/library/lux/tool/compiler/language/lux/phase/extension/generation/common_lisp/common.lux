(.module:
  [library
   [lux "*"
    [abstract
     ["[0]" monad {"+" do}]]
    [control
     ["[0]" function]
     ["[0]" try]
     ["<>" parser
      ["<s>" synthesis {"+" Parser}]]]
    [data
     ["[0]" product]
     ["[0]" text
      ["%" format {"+" format}]]
     [collection
      ["[0]" dictionary]
      ["[0]" set]
      ["[0]" list ("[1]#[0]" functor mix)]]]
    [math
     [number
      ["f" frac]]]
    ["@" target
     ["_" common_lisp {"+" Expression}]]]]
  ["[0]" //// "_"
   ["/" bundle]
   ["/[1]" // "_"
    ["[0]" extension]
    [generation
     [extension {"+" Nullary Unary Binary Trinary
                 nullary unary binary trinary}]
     ["[0]" reference]
     ["//" common_lisp "_"
      ["[1][0]" runtime {"+" Operation Phase Handler Bundle Generator}]
      ["[1][0]" case]]]
    [//
     ["[0]" synthesis {"+" %synthesis}]
     ["[0]" generation]
     [///
      ["[1]" phase]]]]])

(def: .public (custom [parser handler])
  (All (_ s)
    (-> [(Parser s)
         (-> Text (Generator s))]
        Handler))
  (function (_ extension_name phase archive input)
    (case (<s>.result parser input)
      {try.#Success input'}
      (handler extension_name phase archive input')

      {try.#Failure error}
      (/////.except extension.invalid_syntax [extension_name %synthesis input]))))

(template: (!unary function)
  (|>> list _.apply/* (|> (_.constant function))))

... ... TODO: Get rid of this ASAP
... (def: lux::syntax_char_case!
...   (..custom [($_ <>.and
...                  <s>.any
...                  <s>.any
...                  (<>.some (<s>.tuple ($_ <>.and
...                                          (<s>.tuple (<>.many <s>.i64))
...                                          <s>.any))))
...              (function (_ extension_name phase archive [input else conditionals])
...                (do [! /////.monad]
...                  [@input (# ! each _.var (generation.identifier "input"))
...                   inputG (phase archive input)
...                   elseG (phase archive else)
...                   conditionalsG (: (Operation (List [Expression Expression]))
...                                    (monad.each ! (function (_ [chars branch])
...                                                   (do !
...                                                     [branchG (phase archive branch)]
...                                                     (in [(|> chars (list#each (|>> .int _.int (_.=/2 @input))) _.or)
...                                                            branchG])))
...                                               conditionals))]
...                  (in (_.let (list [@input inputG])
...                          (list (list#mix (function (_ [test then] else)
...                                             (_.if test then else))
...                                           elseG
...                                           conditionalsG))))))]))

(def: lux_procs
  Bundle
  (|> /.empty
      ... (/.install "syntax char case!" lux::syntax_char_case!)
      (/.install "is" (binary _.eq/2))
      ... (/.install "try" (unary //runtime.lux//try))
      ))

... (def: (capped operation parameter subject)
...   (-> (-> Expression Expression Expression)
...       (-> Expression Expression Expression))
...   (//runtime.i64//64 (operation parameter subject)))

(def: i64_procs
  Bundle
  (<| (/.prefix "i64")
      (|> /.empty
          (/.install "and" (binary _.logand/2))
          (/.install "or" (binary _.logior/2))
          (/.install "xor" (binary _.logxor/2))
          (/.install "left-shift" (binary _.ash/2))
          (/.install "right-shift" (binary (product.uncurried //runtime.i64//right_shifted)))
          (/.install "=" (binary _.=/2))
          (/.install "<" (binary _.</2))
          (/.install "+" (binary _.+/2))
          (/.install "-" (binary _.-/2))
          (/.install "*" (binary _.*/2))
          (/.install "/" (binary _.floor/2))
          (/.install "%" (binary _.rem/2))
          ... (/.install "f64" (unary (_.//2 (_.float +1.0))))
          (/.install "char" (unary (|>> _.code_char/1 _.string/1)))
          )))

(def: f64_procs
  Bundle
  (<| (/.prefix "f64")
      (|> /.empty
          ... (/.install "=" (binary (product.uncurried _.=/2)))
          ... (/.install "<" (binary (product.uncurried _.</2)))
          ... (/.install "+" (binary (product.uncurried _.+/2)))
          ... (/.install "-" (binary (product.uncurried _.-/2)))
          ... (/.install "*" (binary (product.uncurried _.*/2)))
          ... (/.install "/" (binary (product.uncurried _.//2)))
          ... (/.install "%" (binary (product.uncurried _.rem/2)))
          ... (/.install "i64" (unary _.truncate/1))
          (/.install "encode" (unary _.write_to_string/1))
          ... (/.install "decode" (unary //runtime.f64//decode))
          )))

(def: (text//index [offset sub text])
  (Trinary (Expression Any))
  (//runtime.text//index offset sub text))

(def: (text//clip [offset length text])
  (Trinary (Expression Any))
  (//runtime.text//clip offset length text))

(def: (text//char [index text])
  (Binary (Expression Any))
  (_.char_code/1 (_.char/2 [text index])))

(def: text_procs
  Bundle
  (<| (/.prefix "text")
      (|> /.empty
          (/.install "=" (binary _.string=/2))
          ... (/.install "<" (binary (product.uncurried _.string<?/2)))
          (/.install "concat" (binary (function (_ [left right])
                                        (_.concatenate/3 [(_.symbol "string") left right]))))
          (/.install "index" (trinary ..text//index))
          (/.install "size" (unary _.length/1))
          (/.install "char" (binary ..text//char))
          (/.install "clip" (trinary ..text//clip))
          )))

(def: (io//log! message)
  (Unary (Expression Any))
  (_.progn (list (_.write_line/1 message)
                 //runtime.unit)))

(def: io_procs
  Bundle
  (<| (/.prefix "io")
      (|> /.empty
          (/.install "log" (unary ..io//log!))
          (/.install "error" (unary _.error/1))
          )))

(def: .public bundle
  Bundle
  (<| (/.prefix "lux")
      (|> /.empty
          (dictionary.merged lux_procs)
          (dictionary.merged i64_procs)
          (dictionary.merged f64_procs)
          (dictionary.merged text_procs)
          (dictionary.merged io_procs)
          )))
