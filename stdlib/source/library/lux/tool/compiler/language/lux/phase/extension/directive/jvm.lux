(.module:
  [library
   [lux {"-" [Type Definition]}
    ["." host]
    [abstract
     ["." monad {"+" [do]}]]
    [control
     [pipe {"+" [case>]}]
     ["<>" parser ("#\." monad)
      ["<c>" code {"+" [Parser]}]
      ["<t>" text]]]
    [data
     ["." product]
     [text
      ["%" format {"+" [format]}]]
     [collection
      ["." list ("#\." functor mix)]
      ["." dictionary]
      ["." row]]]
    [macro
     ["." template]]
    [math
     [number
      ["." i32]]]
    [target
     [jvm
      ["_" bytecode {"+" [Bytecode]}]
      ["." modifier {"+" [Modifier]} ("#\." monoid)]
      ["." attribute]
      ["." field]
      ["." version]
      ["." class]
      ["." constant
       ["." pool {"+" [Resource]}]]
      [encoding
       ["." name]]
      ["." type {"+" [Type Constraint Argument Typed]}
       [category {"+" [Void Value Return Method Primitive Object Class Array Var Parameter]}]
       [".T" lux {"+" [Mapping]}]
       ["." signature]
       ["." descriptor {"+" [Descriptor]}]
       ["." parser]]]]
    [tool
     [compiler
      ["." analysis]
      ["." synthesis]
      ["." generation]
      ["." directive {"+" [Handler Bundle]}]
      ["." phase
       [analysis
        [".A" type]]
       ["." generation
        [jvm
         [runtime {"+" [Anchor Definition]}]]]
       ["." extension
        ["." bundle]
        [analysis
         ["." jvm]]
        [directive
         ["/" lux]]]]]]
    [type
     ["." check {"+" [Check]}]]]])

(type: Operation
  (directive.Operation Anchor (Bytecode Any) Definition))

(def: signature (|>> type.signature signature.signature))

(type: Declaration
  [Text (List (Type Var))])

(def: declaration
  (Parser Declaration)
  (<c>.form (<>.and <c>.text (<>.some jvm.var))))

(def: visibility
  (Parser (Modifier field.Field))
  (`` ($_ <>.either
          (~~ (template [<label> <modifier>]
                [(<>.after (<c>.text! <label>) (<>\in <modifier>))]

                ["public" field.public]
                ["private" field.private]
                ["protected" field.protected]
                ["default" modifier.empty])))))

(def: inheritance
  (Parser (Modifier class.Class))
  (`` ($_ <>.either
          (~~ (template [<label> <modifier>]
                [(<>.after (<c>.text! <label>) (<>\in <modifier>))]

                ["final" class.final]
                ["abstract" class.abstract]
                ["default" modifier.empty])))))

(def: state
  (Parser (Modifier field.Field))
  (`` ($_ <>.either
          (~~ (template [<label> <modifier>]
                [(<>.after (<c>.text! <label>) (<>\in <modifier>))]

                ["volatile" field.volatile]
                ["final" field.final]
                ["default" modifier.empty])))))

(type: Annotation Any)

(def: annotation
  (Parser Annotation)
  <c>.any)

(def: field_type
  (Parser (Type Value))
  (<t>.then parser.value <c>.text))

(type: Constant
  [Text (List Annotation) (Type Value) Code])

(def: constant
  (Parser Constant)
  (<| <c>.form
      (<>.after (<c>.text! "constant"))
      ($_ <>.and
          <c>.text
          (<c>.tuple (<>.some ..annotation))
          ..field_type
          <c>.any
          )))

(type: Variable
  [Text (Modifier field.Field) (Modifier field.Field) (List Annotation) (Type Value)])

(def: variable
  (Parser Variable)
  (<| <c>.form
      (<>.after (<c>.text! "variable"))
      ($_ <>.and
          <c>.text
          ..visibility
          ..state
          (<c>.tuple (<>.some ..annotation))
          ..field_type
          )))

(type: Field
  (#Constant Constant)
  (#Variable Variable))

(def: field
  (Parser Field)
  ($_ <>.or
      ..constant
      ..variable
      ))

(type: Method_Definition
  (#Constructor (jvm.Constructor Code))
  (#Virtual_Method (jvm.Virtual_Method Code))
  (#Static_Method (jvm.Static_Method Code))
  (#Overriden_Method (jvm.Overriden_Method Code)))

(def: method
  (Parser Method_Definition)
  ($_ <>.or
      jvm.constructor_definition
      jvm.virtual_method_definition
      jvm.static_method_definition
      jvm.overriden_method_definition
      ))

(def: (constraint name)
  (-> Text Constraint)
  [#type.name name
   #type.super_class (type.class "java.lang.Object" (list))
   #type.super_interfaces (list)])

(def: constant::modifier
  (Modifier field.Field)
  ($_ modifier\composite
      field.public
      field.static
      field.final))

(def: (field_definition field)
  (-> Field (Resource field.Field))
  (case field
    ... TODO: Handle annotations.
    (#Constant [name annotations type value])
    (case value
      (^template [<tag> <type> <constant>]
        [[_ (<tag> value)]
         (do pool.monad
           [constant (`` (|> value (~~ (template.spliced <constant>))))
            attribute (attribute.constant constant)]
           (field.field ..constant::modifier name <type> (row.row attribute)))])
      ([#.Bit type.boolean [(case> #0 +0 #1 +1) .i64 i32.i32 constant.integer pool.integer]]
       [#.Int type.byte [.i64 i32.i32 constant.integer pool.integer]]
       [#.Int type.short [.i64 i32.i32 constant.integer pool.integer]]
       [#.Int type.int [.i64 i32.i32 constant.integer pool.integer]]
       [#.Int type.long [constant.long pool.long]]
       [#.Frac type.float [host.double_to_float constant.float pool.float]]
       [#.Frac type.double [constant.double pool.double]]
       [#.Nat type.char [.i64 i32.i32 constant.integer pool.integer]]
       [#.Text (type.class "java.lang.String" (list)) [pool.string]]
       )

      ... TODO: Tighten this pattern-matching so this catch-all clause isn't necessary.
      _
      (undefined))

    ... TODO: Handle annotations.
    (#Variable [name visibility state annotations type])
    (field.field (modifier\composite visibility state)
                 name type (row.row))))

(def: (method_definition [mapping selfT] [analyse synthesize generate])
  (-> [Mapping .Type]
      [analysis.Phase
       synthesis.Phase
       (generation.Phase Anchor (Bytecode Any) Definition)]
      (-> Method_Definition (Operation synthesis.Synthesis)))
  (function (_ methodC)
    (do phase.monad
      [methodA (: (Operation analysis.Analysis)
                  (directive.lifted_analysis
                   (case methodC
                     (#Constructor method)
                     (jvm.analyse_constructor_method analyse selfT mapping method)

                     (#Virtual_Method method)
                     (jvm.analyse_virtual_method analyse selfT mapping method)
                     
                     (#Static_Method method)
                     (jvm.analyse_static_method analyse mapping method)
                     
                     (#Overriden_Method method)
                     (jvm.analyse_overriden_method analyse selfT mapping method))))]
      (directive.lifted_synthesis
       (synthesize methodA)))))

(def: jvm::class
  (Handler Anchor (Bytecode Any) Definition)
  (/.custom
   [($_ <>.and
        ..declaration
        jvm.class
        (<c>.tuple (<>.some jvm.class))
        ..inheritance
        (<c>.tuple (<>.some ..annotation))
        (<c>.tuple (<>.some ..field))
        (<c>.tuple (<>.some ..method)))
    (function (_ extension phase
                 [[name parameters]
                  super_class
                  super_interfaces
                  inheritance
                  ... TODO: Handle annotations.
                  annotations
                  fields
                  methods])
      (do {! phase.monad}
        [parameters (directive.lifted_analysis
                     (typeA.with_env
                       (jvm.parameter_types parameters)))
         .let [mapping (list\mix (function (_ [parameterJ parameterT] mapping)
                                   (dictionary.has (parser.name parameterJ) parameterT mapping))
                                 luxT.fresh
                                 parameters)]
         super_classT (directive.lifted_analysis
                       (typeA.with_env
                         (luxT.check (luxT.class mapping) (..signature super_class))))
         super_interfaceT+ (directive.lifted_analysis
                            (typeA.with_env
                              (monad.each check.monad
                                          (|>> ..signature (luxT.check (luxT.class mapping)))
                                          super_interfaces)))
         .let [selfT (jvm.inheritance_relationship_type (#.Primitive name (list\each product.right parameters))
                                                        super_classT
                                                        super_interfaceT+)]
         state (extension.lifted phase.get_state)
         .let [analyse (value@ [#directive.analysis #directive.phase] state)
               synthesize (value@ [#directive.synthesis #directive.phase] state)
               generate (value@ [#directive.generation #directive.phase] state)]
         methods (monad.each ! (..method_definition [mapping selfT] [analyse synthesize generate])
                             methods)
         ... _ (directive.lifted_generation
         ...    (generation.save! true ["" name]
         ...                      [name
         ...                       (class.class version.v6_0
         ...                                    (modifier\composite class.public inheritance)
         ...                                    (name.internal name) (list\each (|>> product.left parser.name ..constraint) parameters)
         ...                                    super_class super_interfaces
         ...                                    (list\each ..field_definition fields)
         ...                                    (list) ... TODO: Add methods
         ...                                    (row.row))]))
         _ (directive.lifted_generation
            (generation.log! (format "Class " name)))]
        (in directive.no_requirements)))]))

(def: .public bundle
  (Bundle Anchor (Bytecode Any) Definition)
  (<| (bundle.prefix "jvm")
      (|> bundle.empty
          ... TODO: Finish handling methods and un-comment.
          ... (dictionary.has "class" jvm::class)
          )))
