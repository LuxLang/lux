(.using
 [library
  [lux {"-" Type Definition Primitive}
   ["[0]" ffi {"+" import:}]
   [abstract
    ["[0]" monad {"+" do}]]
   [control
    [pipe {"+" case>}]
    ["<>" parser ("[1]#[0]" monad)
     ["<[0]>" code {"+" Parser}]
     ["<[0]>" text]]]
   [data
    ["[0]" product]
    [text
     ["%" format {"+" format}]]
    [collection
     ["[0]" list ("[1]#[0]" functor mix)]
     ["[0]" dictionary]
     ["[0]" sequence]]
    ["[0]" format "_"
     ["[1]" binary]]]
   [macro
    ["[0]" template]]
   [math
    [number
     ["[0]" i32]]]
   [target
    [jvm
     ["_" bytecode {"+" Bytecode}]
     ["[0]" modifier {"+" Modifier} ("[1]#[0]" monoid)]
     ["[0]" attribute]
     ["[0]" field]
     ["[0]" version]
     ["[0]" method {"+" Method}]
     ["[0]" class]
     ["[0]" constant
      ["[0]" pool {"+" Resource}]]
     [encoding
      ["[0]" name {"+" External}]]
     ["[0]" type {"+" Type Constraint Argument Typed}
      [category {"+" Void Value Return Primitive Object Class Array Var Parameter}]
      ["[0]T" lux {"+" Mapping}]
      ["[0]" signature]
      ["[0]" descriptor {"+" Descriptor}]
      ["[0]" parser]]]]
   [tool
    [compiler
     ["[0]" phase]
     [meta
      [archive {"+" Archive}
       ["[0]" artifact]]]
     [language
      [lux
       ["[0]" analysis]
       ["[0]" synthesis]
       ["[0]" generation]
       ["[0]" directive {"+" Handler Bundle}]
       [phase
        [analysis
         ["[0]A" type]]
        [generation
         [jvm
          ["[0]" runtime {"+" Anchor Definition Extender}]]]
        ["[0]" extension
         ["[0]" bundle]
         [analysis
          ["[0]" jvm]]
         [directive
          ["/" lux]]]]]]]]
   [type
    ["[0]" check {"+" Check}]]]])

(type: Operation
  (directive.Operation Anchor (Bytecode Any) Definition))

(def: signature (|>> type.signature signature.signature))

(type: Declaration
  [Text (List (Type Var))])

(def: declaration
  (Parser Declaration)
  (<code>.form (<>.and <code>.text (<>.some jvm.var))))

(def: visibility
  (Parser (Modifier field.Field))
  (`` ($_ <>.either
          (~~ (template [<label> <modifier>]
                [(<>.after (<code>.text! <label>) (<>#in <modifier>))]

                ["public" field.public]
                ["private" field.private]
                ["protected" field.protected]
                ["default" modifier.empty])))))

(def: inheritance
  (Parser (Modifier class.Class))
  (`` ($_ <>.either
          (~~ (template [<label> <modifier>]
                [(<>.after (<code>.text! <label>) (<>#in <modifier>))]

                ["final" class.final]
                ["abstract" class.abstract]
                ["default" modifier.empty])))))

(def: state
  (Parser (Modifier field.Field))
  (`` ($_ <>.either
          (~~ (template [<label> <modifier>]
                [(<>.after (<code>.text! <label>) (<>#in <modifier>))]

                ["volatile" field.volatile]
                ["final" field.final]
                ["default" modifier.empty])))))

(type: Annotation Any)

(def: annotation
  (Parser Annotation)
  <code>.any)

(def: field_type
  (Parser (Type Value))
  (<text>.then parser.value <code>.text))

(type: Constant
  [Text (List Annotation) (Type Value) Code])

(def: constant
  (Parser Constant)
  (<| <code>.form
      (<>.after (<code>.text! "constant"))
      ($_ <>.and
          <code>.text
          (<code>.tuple (<>.some ..annotation))
          ..field_type
          <code>.any
          )))

(type: Variable
  [Text (Modifier field.Field) (Modifier field.Field) (List Annotation) (Type Value)])

(def: variable
  (Parser Variable)
  (<| <code>.form
      (<>.after (<code>.text! "variable"))
      ($_ <>.and
          <code>.text
          ..visibility
          ..state
          (<code>.tuple (<>.some ..annotation))
          ..field_type
          )))

(type: Field
  (Variant
   {#Constant Constant}
   {#Variable Variable}))

(def: field
  (Parser Field)
  ($_ <>.or
      ..constant
      ..variable
      ))

(type: Method_Definition
  (Variant
   {#Constructor (jvm.Constructor Code)}
   {#Virtual_Method (jvm.Virtual_Method Code)}
   {#Static_Method (jvm.Static_Method Code)}
   {#Overriden_Method (jvm.Overriden_Method Code)}))

(def: method
  (Parser Method_Definition)
  ($_ <>.or
      jvm.constructor_definition
      jvm.virtual_method_definition
      jvm.static_method_definition
      jvm.overriden_method_definition
      ))

(def: (constraint name)
  (-> Text Constraint)
  [type.#name name
   type.#super_class (type.class "java.lang.Object" (list))
   type.#super_interfaces (list)])

(def: constant::modifier
  (Modifier field.Field)
  ($_ modifier#composite
      field.public
      field.static
      field.final))

(def: (field_definition field)
  (-> Field (Resource field.Field))
  (case field
    ... TODO: Handle annotations.
    {#Constant [name annotations type value]}
    (case value
      (^template [<tag> <type> <constant>]
        [[_ {<tag> value}]
         (do pool.monad
           [constant (`` (|> value (~~ (template.spliced <constant>))))
            attribute (attribute.constant constant)]
           (field.field ..constant::modifier name <type> (sequence.sequence attribute)))])
      ([.#Bit type.boolean [(case> #0 +0 #1 +1) .i64 i32.i32 constant.integer pool.integer]]
       [.#Int type.byte [.i64 i32.i32 constant.integer pool.integer]]
       [.#Int type.short [.i64 i32.i32 constant.integer pool.integer]]
       [.#Int type.int [.i64 i32.i32 constant.integer pool.integer]]
       [.#Int type.long [constant.long pool.long]]
       [.#Frac type.float [ffi.double_to_float constant.float pool.float]]
       [.#Frac type.double [constant.double pool.double]]
       [.#Nat type.char [.i64 i32.i32 constant.integer pool.integer]]
       [.#Text (type.class "java.lang.String" (list)) [pool.string]]
       )

      ... TODO: Tighten this pattern-matching so this catch-all clause isn't necessary.
      _
      (undefined))

    ... TODO: Handle annotations.
    {#Variable [name visibility state annotations type]}
    (field.field (modifier#composite visibility state)
                 name type (sequence.sequence))))

(def: (method_definition archive supers [mapping selfT] [analyse synthesize generate])
  (-> Archive
      (List (Type Class))
      [Mapping .Type]
      [analysis.Phase
       synthesis.Phase
       (generation.Phase Anchor (Bytecode Any) Definition)]
      (-> Method_Definition (Operation synthesis.Synthesis)))
  (function (_ methodC)
    (do phase.monad
      [methodA (: (Operation analysis.Analysis)
                  (directive.lifted_analysis
                   (case methodC
                     {#Constructor method}
                     (jvm.analyse_constructor_method analyse archive selfT mapping method)

                     {#Virtual_Method method}
                     (jvm.analyse_virtual_method analyse archive selfT mapping method)
                     
                     {#Static_Method method}
                     (jvm.analyse_static_method analyse archive mapping method)
                     
                     {#Overriden_Method method}
                     (jvm.analyse_overriden_method analyse archive selfT mapping supers method))))]
      (directive.lifted_synthesis
       (synthesize archive methodA)))))

(def: jvm::class
  (Handler Anchor (Bytecode Any) Definition)
  (/.custom
   [($_ <>.and
        ..declaration
        jvm.class
        (<code>.tuple (<>.some jvm.class))
        ..inheritance
        (<code>.tuple (<>.some ..annotation))
        (<code>.tuple (<>.some ..field))
        (<code>.tuple (<>.some ..method)))
    (function (_ extension phase archive
                 [[name parameters]
                  super_class
                  super_interfaces
                  inheritance
                  ... TODO: Handle annotations.
                  annotations
                  fields
                  methods])
      (do [! phase.monad]
        [parameters (directive.lifted_analysis
                     (typeA.with_env
                       (jvm.parameter_types parameters)))
         .let [mapping (list#mix (function (_ [parameterJ parameterT] mapping)
                                   (dictionary.has (parser.name parameterJ) parameterT mapping))
                                 luxT.fresh
                                 parameters)]
         super_classT (directive.lifted_analysis
                       (typeA.with_env
                         (luxT.check (luxT.class mapping) (..signature super_class))))
         super_interfaceT+ (directive.lifted_analysis
                            (typeA.with_env
                              (monad.each check.monad
                                          (|>> ..signature (luxT.check (luxT.class mapping)))
                                          super_interfaces)))
         .let [selfT (jvm.inheritance_relationship_type {.#Primitive name (list#each product.right parameters)}
                                                        super_classT
                                                        super_interfaceT+)]
         state (extension.lifted phase.state)
         .let [analyse (value@ [directive.#analysis directive.#phase] state)
               synthesize (value@ [directive.#synthesis directive.#phase] state)
               generate (value@ [directive.#generation directive.#phase] state)]
         methods (monad.each ! (..method_definition archive (list& super_class super_interfaces) [mapping selfT] [analyse synthesize generate])
                             methods)
         ... _ (directive.lifted_generation
         ...    (generation.save! true ["" name]
         ...                      [name
         ...                       (class.class version.v6_0
         ...                                    (modifier#composite class.public inheritance)
         ...                                    (name.internal name) (list#each (|>> product.left parser.name ..constraint) parameters)
         ...                                    super_class super_interfaces
         ...                                    (list#each ..field_definition fields)
         ...                                    (list) ... TODO: Add methods
         ...                                    (sequence.sequence))]))
         _ (directive.lifted_generation
            (generation.log! (format "JVM Class " name)))]
        (in directive.no_requirements)))]))

(def: (method_declaration (^open "it[0]"))
  (-> (jvm.Method_Declaration Code) (Resource Method))
  (let [type (type.method [it#type_variables it#arguments it#return it#exceptions])]
    (method.method ($_ modifier#composite
                       method.public
                       method.abstract)
                   it#name
                   type
                   (list)
                   {.#None})))

(template [<name> <type> <parser>]
  [(def: <name>
     (Parser <type>)
     (do [! <>.monad]
       [raw <code>.text]
       (<>.lifted (<text>.result <parser> raw))))]

  [class_declaration [External (List (Type Var))] parser.declaration']
  )

(def: jvm::class::interface
  (Handler Anchor (Bytecode Any) Definition)
  (/.custom
   [($_ <>.and
        ..class_declaration
        (<code>.tuple (<>.some jvm.class))
        (<code>.tuple (<>.some ..annotation))
        (<>.some jvm.method_declaration))
    (function (_ extension_name phase archive [[name parameters] supers annotations method_declarations])
      (directive.lifted_generation
       (do [! phase.monad]
         [bytecode (<| (# ! each (format.result class.writer))
                       phase.lifted
                       (class.class version.v6_0
                                    ($_ modifier#composite
                                        class.public
                                        class.abstract
                                        class.interface)
                                    (name.internal name)
                                    (name.internal "java.lang.Object")
                                    (list#each (|>> parser.read_class product.left name.internal)
                                               supers)
                                    (list)
                                    (list#each ..method_declaration method_declarations)
                                    (sequence.sequence)))
          ... module generation.module
          ... module_id (generation.module_id module archive)
          artifact_id (generation.learn_custom name artifact.no_dependencies)
          .let [artifact [name
                          ... (runtime.class_name [module_id artifact_id])
                          bytecode]]
          _ (generation.execute! artifact)
          _ (generation.save! artifact_id {.#Some name} artifact)
          _ (generation.log! (format "JVM Interface " (%.text name)))]
         (in directive.no_requirements))))]))

(import: java/lang/ClassLoader)

(def: .public (bundle class_loader extender)
  (-> java/lang/ClassLoader Extender (Bundle Anchor (Bytecode Any) Definition))
  (<| (bundle.prefix "jvm")
      (|> bundle.empty
          ... TODO: Finish handling methods and un-comment.
          ... (dictionary.has "class" jvm::class)
          (dictionary.has "class interface" ..jvm::class::interface)
          )))
