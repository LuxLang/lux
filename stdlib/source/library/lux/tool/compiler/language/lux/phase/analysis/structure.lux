(.module:
  [library
   [lux "*"
    ["[0]" meta]
    [abstract
     ["[0]" monad {"+" [do]}]]
    [control
     ["[0]" maybe]
     ["[0]" try]
     ["[0]" exception {"+" [exception:]}]
     ["[0]" state]]
    [data
     ["[0]" name]
     ["[0]" product]
     [text
      ["%" format {"+" [format]}]]
     [collection
      ["[0]" list ("[1]\[0]" functor)]
      ["[0]" dictionary {"+" [Dictionary]}]]]
    [macro
     ["[0]" code]]
    [math
     [number
      ["n" nat]]]
    ["[0]" type
     ["[0]" check]]]]
  ["[0]" // "_"
   ["[1][0]" type]
   ["[1][0]" primitive]
   ["[1][0]" inference]
   ["/[1]" // "_"
    ["[1][0]" extension]
    [//
     ["/" analysis {"+" [Tag Analysis Operation Phase]}]
     [///
      ["[1]" phase]
      [meta
       [archive {"+" [Archive]}]]]]]])

(exception: .public (invalid_variant_type {type Type} {tag Tag} {code Code})
  (exception.report
   ["Type" (%.type type)]
   ["Tag" (%.nat tag)]
   ["Expression" (%.code code)]))

(template [<name>]
  [(exception: .public (<name> {type Type} {members (List Code)})
     (exception.report
      ["Type" (%.type type)]
      ["Expression" (%.code (` [(~+ members)]))]))]

  [invalid_tuple_type]
  [cannot_analyse_tuple]
  )

(exception: .public (not_a_quantified_type {type Type})
  (%.type type))

(template [<name>]
  [(exception: .public (<name> {type Type} {tag Tag} {code Code})
     (exception.report
      ["Type" (%.type type)]
      ["Tag" (%.nat tag)]
      ["Expression" (%.code code)]))]

  [cannot_analyse_variant]
  [cannot_infer_numeric_tag]
  )

(template [<name>]
  [(exception: .public (<name> {key Name} {record (List [Name Code])})
     (exception.report
      ["Tag" (%.code (code.tag key))]
      ["Record" (%.code (code.record (list\each (function (_ [keyI valC])
                                                  [(code.tag keyI) valC])
                                                record)))]))]

  [cannot_repeat_tag]
  )

(exception: .public (slot_does_not_belong_to_record {key Name} {type Type})
  (exception.report
   ["Tag" (%.code (code.tag key))]
   ["Type" (%.type type)]))

(exception: .public (record_size_mismatch {expected Nat} {actual Nat} {type Type} {record (List [Name Code])})
  (exception.report
   ["Expected" (%.nat expected)]
   ["Actual" (%.nat actual)]
   ["Type" (%.type type)]
   ["Expression" (%.code (|> record
                             (list\each (function (_ [keyI valueC])
                                          [(code.tag keyI) valueC]))
                             code.record))]))

(def: .public (sum analyse lefts right? archive)
  (-> Phase Nat Bit Phase)
  (let [tag (/.tag lefts right?)]
    (function (recur valueC)
      (do [! ///.monad]
        [expectedT (///extension.lifted meta.expected_type)
         expectedT' (//type.with_env
                      (check.clean expectedT))]
        (/.with_stack ..cannot_analyse_variant [expectedT' tag valueC]
          (case expectedT
            (#.Sum _)
            (let [flat (type.flat_variant expectedT)]
              (case (list.item tag flat)
                (#.Some variant_type)
                (do !
                  [valueA (//type.with_type variant_type
                            (analyse archive valueC))]
                  (in (/.variant [lefts right? valueA])))

                #.None
                (/.except //inference.variant_tag_out_of_bounds [(list.size flat) tag expectedT])))

            (#.Named name unnamedT)
            (//type.with_type unnamedT
              (recur valueC))

            (#.Var id)
            (do !
              [?expectedT' (//type.with_env
                             (check.peek id))]
              (case ?expectedT'
                (#.Some expectedT')
                (//type.with_type expectedT'
                  (recur valueC))

                ... Cannot do inference when the tag is numeric.
                ... This is because there is no way of knowing how many
                ... cases the inferred sum type would have.
                _
                (/.except ..cannot_infer_numeric_tag [expectedT tag valueC])))

            (^template [<tag> <instancer>]
              [(<tag> _)
               (do !
                 [[instance_id instanceT] (//type.with_env <instancer>)]
                 (//type.with_type (maybe.trusted (type.applied (list instanceT) expectedT))
                   (recur valueC)))])
            ([#.UnivQ check.existential]
             [#.ExQ check.var])

            (#.Apply inputT funT)
            (case funT
              (#.Var funT_id)
              (do !
                [?funT' (//type.with_env
                          (check.peek funT_id))]
                (case ?funT'
                  (#.Some funT')
                  (//type.with_type (#.Apply inputT funT')
                    (recur valueC))

                  _
                  (/.except ..invalid_variant_type [expectedT tag valueC])))

              _
              (case (type.applied (list inputT) funT)
                (#.Some outputT)
                (//type.with_type outputT
                  (recur valueC))

                #.None
                (/.except ..not_a_quantified_type funT)))
            
            _
            (/.except ..invalid_variant_type [expectedT tag valueC])))))))

(def: (typed_product archive analyse members)
  (-> Archive Phase (List Code) (Operation Analysis))
  (do [! ///.monad]
    [expectedT (///extension.lifted meta.expected_type)
     membersA+ (: (Operation (List Analysis))
                  (loop [membersT+ (type.flat_tuple expectedT)
                         membersC+ members]
                    (case [membersT+ membersC+]
                      [(#.Item memberT #.End) (#.Item memberC #.End)]
                      (do !
                        [memberA (//type.with_type memberT
                                   (analyse archive memberC))]
                        (in (list memberA)))
                      
                      [(#.Item memberT #.End) _]
                      (//type.with_type memberT
                        (\ ! each (|>> list) (analyse archive (code.tuple membersC+))))
                      
                      [_ (#.Item memberC #.End)]
                      (//type.with_type (type.tuple membersT+)
                        (\ ! each (|>> list) (analyse archive memberC)))
                      
                      [(#.Item memberT membersT+') (#.Item memberC membersC+')]
                      (do !
                        [memberA (//type.with_type memberT
                                   (analyse archive memberC))
                         memberA+ (recur membersT+' membersC+')]
                        (in (#.Item memberA memberA+)))
                      
                      _
                      (/.except ..cannot_analyse_tuple [expectedT members]))))]
    (in (/.tuple membersA+))))

(def: .public (product archive analyse membersC)
  (-> Archive Phase (List Code) (Operation Analysis))
  (do [! ///.monad]
    [expectedT (///extension.lifted meta.expected_type)]
    (/.with_stack ..cannot_analyse_tuple [expectedT membersC]
      (case expectedT
        (#.Product _)
        (..typed_product archive analyse membersC)

        (#.Named name unnamedT)
        (//type.with_type unnamedT
          (product archive analyse membersC))

        (#.Var id)
        (do !
          [?expectedT' (//type.with_env
                         (check.peek id))]
          (case ?expectedT'
            (#.Some expectedT')
            (//type.with_type expectedT'
              (product archive analyse membersC))

            _
            ... Must do inference...
            (do !
              [membersTA (monad.each ! (|>> (analyse archive) //type.with_inference)
                                     membersC)
               _ (//type.with_env
                   (check.check expectedT
                                (type.tuple (list\each product.left membersTA))))]
              (in (/.tuple (list\each product.right membersTA))))))

        (^template [<tag> <instancer>]
          [(<tag> _)
           (do !
             [[instance_id instanceT] (//type.with_env <instancer>)]
             (//type.with_type (maybe.trusted (type.applied (list instanceT) expectedT))
               (product archive analyse membersC)))])
        ([#.UnivQ check.existential]
         [#.ExQ check.var])

        (#.Apply inputT funT)
        (case funT
          (#.Var funT_id)
          (do !
            [?funT' (//type.with_env
                      (check.peek funT_id))]
            (case ?funT'
              (#.Some funT')
              (//type.with_type (#.Apply inputT funT')
                (product archive analyse membersC))

              _
              (/.except ..invalid_tuple_type [expectedT membersC])))

          _
          (case (type.applied (list inputT) funT)
            (#.Some outputT)
            (//type.with_type outputT
              (product archive analyse membersC))

            #.None
            (/.except ..not_a_quantified_type funT)))
        
        _
        (/.except ..invalid_tuple_type [expectedT membersC])
        ))))

(def: .public (tagged_sum analyse tag archive valueC)
  (-> Phase Name Phase)
  (do [! ///.monad]
    [tag (///extension.lifted (meta.normal tag))
     [idx group variantT] (///extension.lifted (meta.tag tag))
     .let [case_size (list.size group)
           [lefts right?] (/.choice case_size idx)]
     expectedT (///extension.lifted meta.expected_type)]
    (case expectedT
      (#.Var _)
      (do !
        [inferenceT (//inference.variant idx case_size variantT)
         [inferredT valueA+] (//inference.general archive analyse inferenceT (list valueC))]
        (in (/.variant [lefts right? (|> valueA+ list.head maybe.trusted)])))

      _
      (..sum analyse lefts right? archive valueC))))

... There cannot be any ambiguity or improper syntax when analysing
... records, so they must be normalized for further analysis.
... Normalization just means that all the tags get resolved to their
... canonical form (with their corresponding module identified).
(def: .public (normal record)
  (-> (List Code) (Operation (Maybe (List [Name Code]))))
  (loop [input record
         output (: (List [Name Code])
                   #.End)]
    (case input
      (^ (list& [_ (#.Tag slotH)] valueH tail))
      (do ///.monad
        [slotH (///extension.lifted (meta.normal slotH))]
        (recur tail (#.Item [slotH valueH] output)))

      #.End
      (\ ///.monad in (#.Some output))

      _
      (\ ///.monad in #.None))))

... Lux already possesses the means to analyse tuples, so
... re-implementing the same functionality for records makes no sense.
... Records, thus, get transformed into tuples by ordering the elements.
(def: .public (order record)
  (-> (List [Name Code]) (Operation (Maybe [Nat (List Code) Type])))
  (case record
    ... empty_record = empty_tuple = unit/any = []
    #.End
    (\ ///.monad in (#.Some [0 (list) Any]))

    (#.Item [head_k head_v] _)
    (do [! ///.monad]
      [slotH' (///extension.lifted
               (do meta.monad
                 [head_k (meta.normal head_k)]
                 (meta.try (meta.slot head_k))))]
      (case slotH'
        (#try.Success [_ slot_set recordT])
        (do !
          [.let [size_record (list.size record)
                 size_ts (list.size slot_set)]
           _ (if (n.= size_ts size_record)
               (in [])
               (/.except ..record_size_mismatch [size_ts size_record recordT record]))
           .let [tuple_range (list.indices size_ts)
                 tag->idx (dictionary.of_list name.hash (list.zipped/2 slot_set tuple_range))]
           idx->val (monad.mix !
                               (function (_ [key val] idx->val)
                                 (do !
                                   [key (///extension.lifted (meta.normal key))]
                                   (case (dictionary.value key tag->idx)
                                     (#.Some idx)
                                     (if (dictionary.key? idx->val idx)
                                       (/.except ..cannot_repeat_tag [key record])
                                       (in (dictionary.has idx val idx->val)))

                                     #.None
                                     (/.except ..slot_does_not_belong_to_record [key recordT]))))
                               (: (Dictionary Nat Code)
                                  (dictionary.empty n.hash))
                               record)
           .let [ordered_tuple (list\each (function (_ idx)
                                            (maybe.trusted (dictionary.value idx idx->val)))
                                          tuple_range)]]
          (in (#.Some [size_ts ordered_tuple recordT])))

        (#try.Failure error)
        (in #.None)))
    ))

(def: .public (record archive analyse members)
  (-> Archive Phase (List Code) (Operation Analysis))
  (case members
    (^ (list))
    //primitive.unit

    (^ (list singletonC))
    (analyse archive singletonC)

    (^ (list [_ (#.Tag pseudo_slot)] singletonC))
    (do [! ///.monad]
      [head_k (///extension.lifted (meta.normal pseudo_slot))
       slot (///extension.lifted (meta.try (meta.slot head_k)))]
      (case slot
        (#try.Success [_ slot_set recordT])
        (case (list.size slot_set)
          1 (analyse archive singletonC)
          _ (..product archive analyse members))

        _
        (..product archive analyse members)))

    _
    (do [! ///.monad]
      [?members (normal members)]
      (case ?members
        #.None
        (..product archive analyse members)

        (#.Some slots)
        (do !
          [record_size,membersC,recordT (..order slots)]
          (case record_size,membersC,recordT
            #.None
            (..product archive analyse members)

            (#.Some [record_size membersC recordT])
            (do !
              [expectedT (///extension.lifted meta.expected_type)]
              (case expectedT
                (#.Var _)
                (do !
                  [inferenceT (//inference.record record_size recordT)
                   [inferredT membersA] (//inference.general archive analyse inferenceT membersC)]
                  (in (/.tuple membersA)))

                _
                (..product archive analyse membersC)))))))))
