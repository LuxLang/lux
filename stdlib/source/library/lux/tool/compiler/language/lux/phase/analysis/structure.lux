(.module:
  [library
   [lux #*
    ["." meta]
    [abstract
     ["." monad (#+ do)]]
    [control
     ["." maybe]
     ["ex" exception (#+ exception:)]
     ["." state]]
    [data
     ["." name]
     ["." product]
     [text
      ["%" format (#+ format)]]
     [collection
      ["." list ("#\." functor)]
      ["." dictionary (#+ Dictionary)]]]
    [macro
     ["." code]]
    [math
     [number
      ["n" nat]]]
    ["." type
     ["." check]]]]
  ["." // #_
   ["#." type]
   ["#." primitive]
   ["#." inference]
   ["/#" // #_
    ["#." extension]
    [//
     ["/" analysis (#+ Tag Analysis Operation Phase)]
     [///
      ["#" phase]
      [meta
       [archive (#+ Archive)]]]]]])

(exception: .public (invalid_variant_type {type Type} {tag Tag} {code Code})
  (ex.report ["Type" (%.type type)]
             ["Tag" (%.nat tag)]
             ["Expression" (%.code code)]))

(template [<name>]
  [(exception: .public (<name> {type Type} {members (List Code)})
     (ex.report ["Type" (%.type type)]
                ["Expression" (%.code (` [(~+ members)]))]))]

  [invalid_tuple_type]
  [cannot_analyse_tuple]
  )

(exception: .public (not_a_quantified_type {type Type})
  (%.type type))

(template [<name>]
  [(exception: .public (<name> {type Type} {tag Tag} {code Code})
     (ex.report ["Type" (%.type type)]
                ["Tag" (%.nat tag)]
                ["Expression" (%.code code)]))]

  [cannot_analyse_variant]
  [cannot_infer_numeric_tag]
  )

(exception: .public (record_keys_must_be_tags {key Code} {record (List [Code Code])})
  (ex.report ["Key" (%.code key)]
             ["Record" (%.code (code.record record))]))

(template [<name>]
  [(exception: .public (<name> {key Name} {record (List [Name Code])})
     (ex.report ["Tag" (%.code (code.tag key))]
                ["Record" (%.code (code.record (list\map (function (_ [keyI valC])
                                                           [(code.tag keyI) valC])
                                                         record)))]))]

  [cannot_repeat_tag]
  )

(exception: .public (tag_does_not_belong_to_record {key Name} {type Type})
  (ex.report ["Tag" (%.code (code.tag key))]
             ["Type" (%.type type)]))

(exception: .public (record_size_mismatch {expected Nat} {actual Nat} {type Type} {record (List [Name Code])})
  (ex.report ["Expected" (%.nat expected)]
             ["Actual" (%.nat actual)]
             ["Type" (%.type type)]
             ["Expression" (%.code (|> record
                                       (list\map (function (_ [keyI valueC])
                                                   [(code.tag keyI) valueC]))
                                       code.record))]))

(def: .public (sum analyse lefts right? archive)
  (-> Phase Nat Bit Phase)
  (let [tag (/.tag lefts right?)]
    (function (recur valueC)
      (do {! ///.monad}
        [expectedT (///extension.lift meta.expected_type)
         expectedT' (//type.with_env
                      (check.clean expectedT))]
        (/.with_stack ..cannot_analyse_variant [expectedT' tag valueC]
          (case expectedT
            (#.Sum _)
            (let [flat (type.flat_variant expectedT)]
              (case (list.item tag flat)
                (#.Some variant_type)
                (do !
                  [valueA (//type.with_type variant_type
                            (analyse archive valueC))]
                  (in (/.variant [lefts right? valueA])))

                #.None
                (/.except //inference.variant_tag_out_of_bounds [(list.size flat) tag expectedT])))

            (#.Named name unnamedT)
            (//type.with_type unnamedT
              (recur valueC))

            (#.Var id)
            (do !
              [?expectedT' (//type.with_env
                             (check.read id))]
              (case ?expectedT'
                (#.Some expectedT')
                (//type.with_type expectedT'
                  (recur valueC))

                ... Cannot do inference when the tag is numeric.
                ... This is because there is no way of knowing how many
                ... cases the inferred sum type would have.
                _
                (/.except ..cannot_infer_numeric_tag [expectedT tag valueC])))

            (^template [<tag> <instancer>]
              [(<tag> _)
               (do !
                 [[instance_id instanceT] (//type.with_env <instancer>)]
                 (//type.with_type (maybe.assume (type.applied (list instanceT) expectedT))
                   (recur valueC)))])
            ([#.UnivQ check.existential]
             [#.ExQ check.var])

            (#.Apply inputT funT)
            (case funT
              (#.Var funT_id)
              (do !
                [?funT' (//type.with_env (check.read funT_id))]
                (case ?funT'
                  (#.Some funT')
                  (//type.with_type (#.Apply inputT funT')
                    (recur valueC))

                  _
                  (/.except ..invalid_variant_type [expectedT tag valueC])))

              _
              (case (type.applied (list inputT) funT)
                (#.Some outputT)
                (//type.with_type outputT
                  (recur valueC))

                #.None
                (/.except ..not_a_quantified_type funT)))
            
            _
            (/.except ..invalid_variant_type [expectedT tag valueC])))))))

(def: (typed_product archive analyse members)
  (-> Archive Phase (List Code) (Operation Analysis))
  (do {! ///.monad}
    [expectedT (///extension.lift meta.expected_type)
     membersA+ (: (Operation (List Analysis))
                  (loop [membersT+ (type.flat_tuple expectedT)
                         membersC+ members]
                    (case [membersT+ membersC+]
                      [(#.Item memberT #.End) _]
                      (//type.with_type memberT
                        (\ ! map (|>> list) (analyse archive (code.tuple membersC+))))
                      
                      [_ (#.Item memberC #.End)]
                      (//type.with_type (type.tuple membersT+)
                        (\ ! map (|>> list) (analyse archive memberC)))
                      
                      [(#.Item memberT membersT+') (#.Item memberC membersC+')]
                      (do !
                        [memberA (//type.with_type memberT
                                   (analyse archive memberC))
                         memberA+ (recur membersT+' membersC+')]
                        (in (#.Item memberA memberA+)))

                      _
                      (/.except ..cannot_analyse_tuple [expectedT members]))))]
    (in (/.tuple membersA+))))

(def: .public (product archive analyse membersC)
  (-> Archive Phase (List Code) (Operation Analysis))
  (do {! ///.monad}
    [expectedT (///extension.lift meta.expected_type)]
    (/.with_stack ..cannot_analyse_tuple [expectedT membersC]
      (case expectedT
        (#.Product _)
        (..typed_product archive analyse membersC)

        (#.Named name unnamedT)
        (//type.with_type unnamedT
          (product archive analyse membersC))

        (#.Var id)
        (do !
          [?expectedT' (//type.with_env
                         (check.read id))]
          (case ?expectedT'
            (#.Some expectedT')
            (//type.with_type expectedT'
              (product archive analyse membersC))

            _
            ... Must do inference...
            (do !
              [membersTA (monad.map ! (|>> (analyse archive) //type.with_inference)
                                    membersC)
               _ (//type.with_env
                   (check.check expectedT
                                (type.tuple (list\map product.left membersTA))))]
              (in (/.tuple (list\map product.right membersTA))))))

        (^template [<tag> <instancer>]
          [(<tag> _)
           (do !
             [[instance_id instanceT] (//type.with_env <instancer>)]
             (//type.with_type (maybe.assume (type.applied (list instanceT) expectedT))
               (product archive analyse membersC)))])
        ([#.UnivQ check.existential]
         [#.ExQ check.var])

        (#.Apply inputT funT)
        (case funT
          (#.Var funT_id)
          (do !
            [?funT' (//type.with_env (check.read funT_id))]
            (case ?funT'
              (#.Some funT')
              (//type.with_type (#.Apply inputT funT')
                (product archive analyse membersC))

              _
              (/.except ..invalid_tuple_type [expectedT membersC])))

          _
          (case (type.applied (list inputT) funT)
            (#.Some outputT)
            (//type.with_type outputT
              (product archive analyse membersC))

            #.None
            (/.except ..not_a_quantified_type funT)))
        
        _
        (/.except ..invalid_tuple_type [expectedT membersC])
        ))))

(def: .public (tagged_sum analyse tag archive valueC)
  (-> Phase Name Phase)
  (do {! ///.monad}
    [tag (///extension.lift (meta.normal tag))
     [idx group variantT] (///extension.lift (meta.tag tag))
     .let [case_size (list.size group)
           [lefts right?] (/.choice case_size idx)]
     expectedT (///extension.lift meta.expected_type)]
    (case expectedT
      (#.Var _)
      (do !
        [inferenceT (//inference.variant idx case_size variantT)
         [inferredT valueA+] (//inference.general archive analyse inferenceT (list valueC))]
        (in (/.variant [lefts right? (|> valueA+ list.head maybe.assume)])))

      _
      (..sum analyse lefts right? archive valueC))))

... There cannot be any ambiguity or improper syntax when analysing
... records, so they must be normalized for further analysis.
... Normalization just means that all the tags get resolved to their
... canonical form (with their corresponding module identified).
(def: .public (normal record)
  (-> (List [Code Code]) (Operation (List [Name Code])))
  (monad.map ///.monad
             (function (_ [key val])
               (case key
                 [_ (#.Tag key)]
                 (do ///.monad
                   [key (///extension.lift (meta.normal key))]
                   (in [key val]))

                 _
                 (/.except ..record_keys_must_be_tags [key record])))
             record))

... Lux already possesses the means to analyse tuples, so
... re-implementing the same functionality for records makes no sense.
... Records, thus, get transformed into tuples by ordering the elements.
(def: .public (order record)
  (-> (List [Name Code]) (Operation [(List Code) Type]))
  (case record
    ... empty_record = empty_tuple = unit = []
    #.End
    (\ ///.monad in [(list) Any])

    (#.Item [head_k head_v] _)
    (do {! ///.monad}
      [head_k (///extension.lift (meta.normal head_k))
       [_ tag_set recordT] (///extension.lift (meta.tag head_k))
       .let [size_record (list.size record)
             size_ts (list.size tag_set)]
       _ (if (n.= size_ts size_record)
           (in [])
           (/.except ..record_size_mismatch [size_ts size_record recordT record]))
       .let [tuple_range (list.indices size_ts)
             tag->idx (dictionary.of_list name.hash (list.zipped/2 tag_set tuple_range))]
       idx->val (monad.fold !
                            (function (_ [key val] idx->val)
                              (do !
                                [key (///extension.lift (meta.normal key))]
                                (case (dictionary.get key tag->idx)
                                  (#.Some idx)
                                  (if (dictionary.key? idx->val idx)
                                    (/.except ..cannot_repeat_tag [key record])
                                    (in (dictionary.has idx val idx->val)))

                                  #.None
                                  (/.except ..tag_does_not_belong_to_record [key recordT]))))
                            (: (Dictionary Nat Code)
                               (dictionary.empty n.hash))
                            record)
       .let [ordered_tuple (list\map (function (_ idx) (maybe.assume (dictionary.get idx idx->val)))
                                     tuple_range)]]
      (in [ordered_tuple recordT]))
    ))

(def: .public (record archive analyse members)
  (-> Archive Phase (List [Code Code]) (Operation Analysis))
  (case members
    (^ (list))
    //primitive.unit

    (^ (list [_ singletonC]))
    (analyse archive singletonC)

    _
    (do {! ///.monad}
      [members (normal members)
       [membersC recordT] (order members)
       expectedT (///extension.lift meta.expected_type)]
      (case expectedT
        (#.Var _)
        (do !
          [inferenceT (//inference.record recordT)
           [inferredT membersA] (//inference.general archive analyse inferenceT membersC)]
          (in (/.tuple membersA)))

        _
        (..product archive analyse membersC)))))
