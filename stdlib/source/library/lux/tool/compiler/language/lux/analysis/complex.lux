(.using
 [library
  [lux (.except Tuple Variant)
   [abstract
    [equivalence (.only Equivalence)]
    [hash (.only Hash)]]
   [data
    ["[0]" bit ("[1]#[0]" equivalence)]
    ["[0]" text
     ["%" format (.only Format)]]
    [collection
     ["[0]" list ("[1]#[0]" functor)]]]
   [math
    [number
     ["n" nat]]]]])

(type: .public (Variant a)
  (Record
   [#lefts Nat
    #right? Bit
    #value a]))

(type: .public (Tuple a)
  (List a))

(type: .public (Complex a)
  (.Variant
   {#Variant (Variant a)}
   {#Tuple (Tuple a)}))

(type: .public Tag
  Nat)

(def: .public (tag right? lefts)
  (-> Bit Nat Tag)
  (if right?
    (++ lefts)
    lefts))

(def: .public (lefts right? tag)
  (-> Bit Tag Nat)
  (if right?
    (-- tag)
    tag))

(def: .public (choice multiplicity pick)
  (-> Nat Tag [Nat Bit])
  (let [right? (n.= (-- multiplicity) pick)]
    [(..lefts right? pick)
     right?]))

(implementation: .public (equivalence (open "/#[0]"))
  (All (_ a) (-> (Equivalence a) (Equivalence (Complex a))))
  
  (def: (= reference sample)
    (case [reference sample]
      [{#Variant [reference_lefts reference_right? reference_value]}
       {#Variant [sample_lefts sample_right? sample_value]}]
      (and (n.= reference_lefts sample_lefts)
           (bit#= reference_right? sample_right?)
           (/#= reference_value sample_value))
      
      [{#Tuple reference} {#Tuple sample}]
      (# (list.equivalence /#=) = reference sample)

      _
      false)))

(implementation: .public (hash super)
  (All (_ a) (-> (Hash a) (Hash (Complex a))))

  (def: equivalence
    (..equivalence (# super equivalence)))
  
  (def: (hash value)
    (case value
      {#Variant [lefts right? value]}
      (all n.* 2
           (# n.hash hash lefts)
           (# bit.hash hash right?)
           (# super hash value))
      
      {#Tuple members}
      (all n.* 3
           (# (list.hash super) hash members))
      )))

(def: .public (format %it it)
  (All (_ a) (-> (Format a) (Format (Complex a))))
  (case it
    {#Variant [lefts right? it]}
    (%.format "{" (%.nat lefts) " " (%.bit right?) " " (%it it) "}")
    
    {#Tuple it}
    (|> it
        (list#each %it)
        (text.interposed " ")
        (text.enclosed ["[" "]"]))))
