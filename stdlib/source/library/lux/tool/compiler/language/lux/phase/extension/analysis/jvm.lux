(.using
 [library
  [lux {"-" Type Module Primitive type char int}
   ["[0]" ffi {"+" import:}]
   ["[0]" meta]
   [abstract
    ["[0]" monad {"+" do}]
    ["[0]" predicate]]
   [control
    ["[0]" pipe]
    ["[0]" maybe ("[1]#[0]" functor)]
    ["[0]" try {"+" Try} ("[1]#[0]" monad)]
    ["[0]" exception {"+" exception:}]
    ["<>" parser
     ["<[0]>" code {"+" Parser}]
     ["<[0]>" text]]]
   [data
    [binary {"+" Binary}]
    ["[0]" product]
    ["[0]" text ("[1]#[0]" equivalence)
     ["%" format {"+" format}]]
    [collection
     ["[0]" list ("[1]#[0]" mix monad monoid)]
     ["[0]" array]
     ["[0]" dictionary {"+" Dictionary}]
     ["[0]" sequence]]
    ["[0]" format "_"
     ["[1]" binary]]]
   [macro
    ["^" pattern]
    ["[0]" template]]
   [math
    [number
     ["n" nat]
     ["[0]" i32]]]
   [target
    ["[0]" jvm "_"
     ["[0]!" reflection]
     ["_" bytecode {"+" Bytecode} ("[1]#[0]" monad)]
     ["[0]" modifier {"+" Modifier} ("[1]#[0]" monoid)]
     ["[0]" attribute]
     ["[0]" field]
     ["[0]" version]
     ["[0]" method]
     ["[0]" class]
     ["[0]" constant
      ["[0]" pool {"+" Resource}]]
     [encoding
      ["[0]" name {"+" External}]]
     ["[1]" type {"+" Type Argument Typed} ("[1]#[0]" equivalence)
      ["[0]" category {"+" Void Value' Value Return' Return Primitive Object Class Array Var Parameter Method}]
      ["[0]" box]
      ["[0]" reflection]
      ["[0]" descriptor]
      ["[0]" signature]
      ["[0]" parser]
      ["[0]" alias {"+" Aliasing}]
      ["[0]T" lux {"+" Mapping}]]]]
   ["[0]" type
    ["[0]" check {"+" Check} ("[1]#[0]" monad)]]]]
 ["[0]" // "_"
  ["[1][0]" lux {"+" custom}]
  ["/[1]" //
   ["[1][0]" bundle]
   ["/[1]" // "_"
    [generation
     [jvm
      ["[0]" runtime]
      ["[0]" function "_"
       ["[1]" abstract]]]]
    ["/[1]" // "_"
     ["[0]" generation]
     ["[0]" directive]
     ["[1][0]" analysis {"+" Analysis Operation Phase Handler Bundle}
      ["[0]" complex]
      ["[0]" pattern]
      ["[0]" inference]
      ["[0]A" type]
      ["[0]" scope]]
     [///
      ["[0]" phase ("[1]#[0]" monad)]
      [meta
       [archive {"+" Archive}
        [module
         [descriptor {"+" Module}]]]]]]]]])

(import: java/lang/ClassLoader
  "[1]::[0]")

(import: java/lang/Object
  "[1]::[0]"
  (equals [java/lang/Object] boolean))

(import: java/lang/reflect/Type
  "[1]::[0]")

(import: (java/lang/reflect/TypeVariable d)
  "[1]::[0]"
  (getName [] java/lang/String)
  (getBounds [] [java/lang/reflect/Type]))

(import: java/lang/reflect/Modifier
  "[1]::[0]"
  ("static" isStatic [int] boolean)
  ("static" isFinal [int] boolean)
  ("static" isInterface [int] boolean)
  ("static" isAbstract [int] boolean)
  ("static" isPublic [int] boolean)
  ("static" isProtected [int] boolean))

(import: java/lang/annotation/Annotation
  "[1]::[0]")

(import: java/lang/reflect/Method
  "[1]::[0]"
  (getName [] java/lang/String)
  (getModifiers [] int)
  (getDeclaringClass [] (java/lang/Class java/lang/Object))
  (getTypeParameters [] [(java/lang/reflect/TypeVariable java/lang/reflect/Method)])
  (getGenericParameterTypes [] [java/lang/reflect/Type])
  (getDeclaredAnnotations [] [java/lang/annotation/Annotation])
  
  (getReturnType [] (java/lang/Class java/lang/Object))
  (getGenericReturnType [] "?" java/lang/reflect/Type)
  
  (getExceptionTypes [] [(java/lang/Class java/lang/Object)])
  (getGenericExceptionTypes [] [java/lang/reflect/Type]))

(import: (java/lang/reflect/Constructor c)
  "[1]::[0]"
  (getModifiers [] int)
  (getDeclaringClass [] (java/lang/Class c))
  (getTypeParameters [] [(java/lang/reflect/TypeVariable (java/lang/reflect/Constructor c))])
  (getGenericParameterTypes [] [java/lang/reflect/Type])
  (getExceptionTypes [] [(java/lang/Class java/lang/Object)])
  (getGenericExceptionTypes [] [java/lang/reflect/Type])
  (getDeclaredAnnotations [] [java/lang/annotation/Annotation]))

(import: (java/lang/Class c)
  "[1]::[0]"
  ("static" forName [java/lang/String] "try" (java/lang/Class java/lang/Object))
  (getName [] java/lang/String)
  (getModifiers [] int)
  (isAssignableFrom [(java/lang/Class java/lang/Object)] boolean)
  (getTypeParameters [] [(java/lang/reflect/TypeVariable (java/lang/Class c))])
  (getGenericInterfaces [] [java/lang/reflect/Type])
  (getGenericSuperclass [] "?" java/lang/reflect/Type)
  (getDeclaredField [java/lang/String] "try" java/lang/reflect/Field)
  (getConstructors [] [(java/lang/reflect/Constructor java/lang/Object)])
  (getDeclaredMethods [] [java/lang/reflect/Method])
  (getDeclaredAnnotations [] [java/lang/annotation/Annotation])
  (getSuperclass [] "?" (java/lang/Class java/lang/Object))
  (getInterfaces [] [(java/lang/Class java/lang/Object)]))

(template [<name>]
  [(exception: .public (<name> [class External
                                field Text])
     (exception.report
      "Class" (%.text class)
      "Field" (%.text field)))]

  [cannot_set_a_final_field]
  [deprecated_field]
  )

(exception: .public (deprecated_method [class External
                                        method Text
                                        type .Type])
  (exception.report
   "Class" (%.text class)
   "Method" (%.text method)
   "Type" (%.type type)))

(exception: .public (deprecated_class [class External])
  (exception.report
   "Class" (%.text class)))

(def: (ensure_fresh_class! class_loader name)
  (-> java/lang/ClassLoader External (Operation Any))
  (do phase.monad
    [class (phase.lifted (reflection!.load class_loader name))]
    (phase.assertion ..deprecated_class [name]
                     (|> class
                         java/lang/Class::getDeclaredAnnotations
                         reflection!.deprecated?
                         not))))

(def: reflection
  (All (_ category) (-> (Type (<| Return' Value' category)) Text))
  (|>> jvm.reflection reflection.reflection))

(def: signature (|>> jvm.signature signature.signature))

(def: object_class
  External
  "java.lang.Object")

... TODO: Get rid of this template block and use the definition in
... lux/ffi.jvm.lux ASAP
(template [<name> <class>]
  [(def: .public <name>
     .Type
     {.#Primitive <class> {.#End}})]

  ... Boxes
  [Boolean   box.boolean]
  [Byte      box.byte]
  [Short     box.short]
  [Integer   box.int]
  [Long      box.long]
  [Float     box.float]
  [Double    box.double]
  [Character box.char]
  [String    "java.lang.String"]

  ... Primitives
  [boolean   (reflection.reflection reflection.boolean)]
  [byte      (reflection.reflection reflection.byte)]
  [short     (reflection.reflection reflection.short)]
  [int       (reflection.reflection reflection.int)]
  [long      (reflection.reflection reflection.long)]
  [float     (reflection.reflection reflection.float)]
  [double    (reflection.reflection reflection.double)]
  [char      (reflection.reflection reflection.char)]
  )

(type: Member
  (Record
   [#class External
    #member Text]))

(def: member
  (Parser Member)
  ($_ <>.and <code>.text <code>.text))

(type: Method_Signature
  (Record
   [#method .Type
    #deprecated? Bit
    #throws (List .Type)]))

(template [<name>]
  [(exception: .public (<name> [type .Type])
     (exception.report
      "Type" (%.type type)))]

  [non_object]
  [non_array]
  [non_parameter]
  [non_jvm_type]
  )

(template [<name>]
  [(exception: .public (<name> [class External])
     (exception.report
      "Class/type" (%.text class)))]

  [non_interface]
  [non_throwable]
  [primitives_are_not_objects]
  )

(template [<name>]
  [(exception: .public (<name> [class_variables (List (Type Var))
                                class External
                                method Text
                                method_variables (List (Type Var))
                                inputsJT (List (Type Value))
                                hints (List Method_Signature)])
     (exception.report
      "Class Variables" (exception.listing ..signature class_variables)
      "Class" class
      "Method" method
      "Method Variables" (exception.listing ..signature method_variables)
      "Arguments" (exception.listing ..signature inputsJT)
      "Hints" (exception.listing %.type (list#each product.left hints))))]

  [no_candidates]
  [too_many_candidates]
  )

(exception: .public (cannot_cast [from .Type
                                  to .Type
                                  value Code])
  (exception.report
   "From" (%.type from)
   "To" (%.type to)
   "Value" (%.code value)))

(template [<name>]
  [(exception: .public (<name> [message Text])
     message)]

  [primitives_cannot_have_type_parameters]

  [cannot_possibly_be_an_instance]

  [unknown_type_var]
  )

(def: bundle::conversion
  Bundle
  (<| (///bundle.prefix "conversion")
      (|> ///bundle.empty
          (///bundle.install "double-to-float" (//lux.unary ..double ..float))
          (///bundle.install "double-to-int" (//lux.unary ..double ..int))
          (///bundle.install "double-to-long" (//lux.unary ..double ..long))
          (///bundle.install "float-to-double" (//lux.unary ..float ..double))
          (///bundle.install "float-to-int" (//lux.unary ..float ..int))
          (///bundle.install "float-to-long" (//lux.unary ..float ..long))
          (///bundle.install "int-to-byte" (//lux.unary ..int ..byte))
          (///bundle.install "int-to-char" (//lux.unary ..int ..char))
          (///bundle.install "int-to-double" (//lux.unary ..int ..double))
          (///bundle.install "int-to-float" (//lux.unary ..int ..float))
          (///bundle.install "int-to-long" (//lux.unary ..int ..long))
          (///bundle.install "int-to-short" (//lux.unary ..int ..short))
          (///bundle.install "long-to-double" (//lux.unary ..long ..double))
          (///bundle.install "long-to-float" (//lux.unary ..long ..float))
          (///bundle.install "long-to-int" (//lux.unary ..long ..int))
          (///bundle.install "long-to-short" (//lux.unary ..long ..short))
          (///bundle.install "long-to-byte" (//lux.unary ..long ..byte))
          (///bundle.install "char-to-byte" (//lux.unary ..char ..byte))
          (///bundle.install "char-to-short" (//lux.unary ..char ..short))
          (///bundle.install "char-to-int" (//lux.unary ..char ..int))
          (///bundle.install "char-to-long" (//lux.unary ..char ..long))
          (///bundle.install "byte-to-long" (//lux.unary ..byte ..long))
          (///bundle.install "short-to-long" (//lux.unary ..short ..long))
          )))

(template [<name> <prefix> <type>]
  [(def: <name>
     Bundle
     (<| (///bundle.prefix (reflection.reflection <prefix>))
         (|> ///bundle.empty
             (///bundle.install "+" (//lux.binary <type> <type> <type>))
             (///bundle.install "-" (//lux.binary <type> <type> <type>))
             (///bundle.install "*" (//lux.binary <type> <type> <type>))
             (///bundle.install "/" (//lux.binary <type> <type> <type>))
             (///bundle.install "%" (//lux.binary <type> <type> <type>))
             (///bundle.install "=" (//lux.binary <type> <type> Bit))
             (///bundle.install "<" (//lux.binary <type> <type> Bit))
             (///bundle.install "and" (//lux.binary <type> <type> <type>))
             (///bundle.install "or" (//lux.binary <type> <type> <type>))
             (///bundle.install "xor" (//lux.binary <type> <type> <type>))
             (///bundle.install "shl" (//lux.binary ..int <type> <type>))
             (///bundle.install "shr" (//lux.binary ..int <type> <type>))
             (///bundle.install "ushr" (//lux.binary ..int <type> <type>))
             )))]

  [bundle::int  reflection.int  ..int]
  [bundle::long reflection.long ..long]
  )

(template [<name> <prefix> <type>]
  [(def: <name>
     Bundle
     (<| (///bundle.prefix (reflection.reflection <prefix>))
         (|> ///bundle.empty
             (///bundle.install "+" (//lux.binary <type> <type> <type>))
             (///bundle.install "-" (//lux.binary <type> <type> <type>))
             (///bundle.install "*" (//lux.binary <type> <type> <type>))
             (///bundle.install "/" (//lux.binary <type> <type> <type>))
             (///bundle.install "%" (//lux.binary <type> <type> <type>))
             (///bundle.install "=" (//lux.binary <type> <type> Bit))
             (///bundle.install "<" (//lux.binary <type> <type> Bit))
             )))]

  [bundle::float  reflection.float  ..float]
  [bundle::double reflection.double ..double]
  )

(def: bundle::char
  Bundle
  (<| (///bundle.prefix (reflection.reflection reflection.char))
      (|> ///bundle.empty
          (///bundle.install "=" (//lux.binary ..char ..char Bit))
          (///bundle.install "<" (//lux.binary ..char ..char Bit))
          )))

(def: .public boxes
  (Dictionary External [External (Type Primitive)])
  (|> (list [(reflection.reflection reflection.boolean) [box.boolean jvm.boolean]]
            [(reflection.reflection reflection.byte)    [box.byte jvm.byte]]
            [(reflection.reflection reflection.short)   [box.short jvm.short]]
            [(reflection.reflection reflection.int)     [box.int jvm.int]]
            [(reflection.reflection reflection.long)    [box.long jvm.long]]
            [(reflection.reflection reflection.float)   [box.float jvm.float]]
            [(reflection.reflection reflection.double)  [box.double jvm.double]]
            [(reflection.reflection reflection.char)    [box.char jvm.char]])
      (dictionary.of_list text.hash)))

(template: (lux_array_type :read: :write:)
  [{.#Primitive (static array.type_name) (list {.#Apply :write: {.#Apply :read: _Mutable}})}])

(def: (jvm_type luxT)
  (-> .Type (Operation (Type Value)))
  (case luxT
    {.#Named name anonymousT}
    (jvm_type anonymousT)
    
    {.#Apply inputT abstractionT}
    (case (type.applied (list inputT) abstractionT)
      {.#Some outputT}
      (jvm_type outputT)

      {.#None}
      (/////analysis.except ..non_jvm_type luxT))

    (pattern (lux_array_type elemT _))
    (phase#each jvm.array (jvm_type elemT))

    {.#Primitive class parametersT}
    (case (dictionary.value class ..boxes)
      {.#Some [_ primitive_type]}
      (case parametersT
        {.#End}
        (phase#in primitive_type)

        _
        (/////analysis.except ..primitives_cannot_have_type_parameters class))

      {.#None}
      (do [! phase.monad]
        [parametersJT (is (Operation (List (Type Parameter)))
                          (monad.each !
                                      (function (_ parameterT)
                                        (do phase.monad
                                          [parameterJT (jvm_type parameterT)]
                                          (case (parser.parameter? parameterJT)
                                            {.#Some parameterJT}
                                            (in parameterJT)
                                            
                                            {.#None}
                                            (/////analysis.except ..non_parameter parameterT))))
                                      parametersT))]
        (in (jvm.class class parametersJT))))

    {.#Ex _}
    (phase#in (jvm.class ..object_class (list)))

    {.#Function _}
    (phase#in function.class)
    
    _
    (/////analysis.except ..non_jvm_type luxT)))

(def: (jvm_array_type objectT)
  (-> .Type (Operation (Type Array)))
  (do phase.monad
    [objectJ (jvm_type objectT)]
    (|> objectJ
        ..signature
        (<text>.result parser.array)
        phase.lifted)))

(def: (primitive_array_length_handler primitive_type)
  (-> (Type Primitive) Handler)
  (function (_ extension_name analyse archive args)
    (case args
      (pattern (list arrayC))
      (do phase.monad
        [_ (typeA.inference ..int)
         arrayA (<| (typeA.expecting {.#Primitive (|> (jvm.array primitive_type)
                                                      ..reflection)
                                                  (list)})
                    (analyse archive arrayC))]
        (in {/////analysis.#Extension extension_name (list arrayA)}))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: array::length::object
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (pattern (list arrayC))
      (<| typeA.with_var
          (function (_ [@read :read:]))
          typeA.with_var
          (function (_ [@write :write:]))
          (do phase.monad
            [_ (typeA.inference ..int)
             arrayA (<| (typeA.expecting (.type (array.Array' :read: :write:)))
                        (analyse archive arrayC))
             :read: (typeA.check (check.clean (list) :read:))
             :write: (typeA.check (check.clean (list) :write:))
             arrayJT (jvm_array_type (.type (array.Array' :read: :write:)))]
            (in {/////analysis.#Extension extension_name (list (/////analysis.text (..signature arrayJT))
                                                               arrayA)})))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: (new_primitive_array_handler primitive_type)
  (-> (Type Primitive) Handler)
  (function (_ extension_name analyse archive args)
    (case args
      (pattern (list lengthC))
      (do phase.monad
        [lengthA (<| (typeA.expecting ..int)
                     (analyse archive lengthC))
         _ (typeA.inference {.#Primitive (|> (jvm.array primitive_type) ..reflection)
                                         (list)})]
        (in {/////analysis.#Extension extension_name (list lengthA)}))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: array::new::object
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (pattern (list lengthC))
      (do phase.monad
        [lengthA (<| (typeA.expecting ..int)
                     (analyse archive lengthC))
         expectedT (///.lifted meta.expected_type)
         expectedJT (jvm_array_type expectedT)
         elementJT (case (parser.array? expectedJT)
                     {.#Some elementJT}
                     (in elementJT)
                     
                     {.#None}
                     (/////analysis.except ..non_array expectedT))]
        (in {/////analysis.#Extension extension_name (list (/////analysis.text (..signature elementJT))
                                                           lengthA)}))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: (check_parameter objectT)
  (-> .Type (Operation (Type Parameter)))
  (case objectT
    (pattern (lux_array_type elementT _))
    (/////analysis.except ..non_parameter objectT)
    
    {.#Primitive name parameters}
    (`` (cond (or (~~ (template [<type>]
                        [(text#= (..reflection <type>) name)]

                        [jvm.boolean]
                        [jvm.byte]
                        [jvm.short]
                        [jvm.int]
                        [jvm.long]
                        [jvm.float]
                        [jvm.double]
                        [jvm.char]))
                  (text.starts_with? descriptor.array_prefix name))
              (/////analysis.except ..non_parameter objectT)

              ... else
              (phase#in (jvm.class name (list)))))

    {.#Named name anonymous}
    (check_parameter anonymous)

    {.#Var @var}
    (do phase.monad
      [:var: (typeA.check (check.peek @var))]
      (case :var:
        {.#Some :var:}
        (check_parameter :var:)
        
        {.#None}
        (in (jvm.class ..object_class (list)))))

    (^.or {.#Ex id}
          {.#Parameter id})
    (phase#in (jvm.class ..object_class (list)))

    (^.template [<tag>]
      [{<tag> env unquantified}
       (check_parameter unquantified)])
    ([.#UnivQ]
     [.#ExQ])

    {.#Apply inputT abstractionT}
    (case (type.applied (list inputT) abstractionT)
      {.#Some outputT}
      (check_parameter outputT)

      {.#None}
      (/////analysis.except ..non_parameter objectT))

    {.#Function _}
    (phase#in function.class)

    _
    (/////analysis.except ..non_parameter objectT)))

(def: (check_jvm objectT)
  (-> .Type (Operation (Type Value)))
  (case objectT
    {.#Primitive name {.#End}}
    (`` (cond (~~ (template [<type>]
                    [(text#= (..reflection <type>) name)
                     (phase#in <type>)]

                    [jvm.boolean]
                    [jvm.byte]
                    [jvm.short]
                    [jvm.int]
                    [jvm.long]
                    [jvm.float]
                    [jvm.double]
                    [jvm.char]))

              (~~ (template [<type>]
                    [(text#= (..reflection (jvm.array <type>)) name)
                     (phase#in (jvm.array <type>))]

                    [jvm.boolean]
                    [jvm.byte]
                    [jvm.short]
                    [jvm.int]
                    [jvm.long]
                    [jvm.float]
                    [jvm.double]
                    [jvm.char]))

              (text.starts_with? descriptor.array_prefix name)
              (let [[_ unprefixed] (maybe.trusted (text.split_by descriptor.array_prefix name))]
                (# phase.monad each jvm.array
                   (check_jvm {.#Primitive unprefixed (list)})))

              ... else
              (phase#in (jvm.class name (list)))))

    (pattern (lux_array_type elementT _))
    (|> elementT
        check_jvm
        (phase#each jvm.array))
    
    {.#Primitive name parameters}
    (do [! phase.monad]
      [parameters (monad.each ! check_parameter parameters)]
      (phase#in (jvm.class name parameters)))

    {.#Named name anonymous}
    (check_jvm anonymous)

    (^.template [<tag>]
      [{<tag> env unquantified}
       (check_jvm unquantified)])
    ([.#UnivQ]
     [.#ExQ])

    {.#Apply inputT abstractionT}
    (case (type.applied (list inputT) abstractionT)
      {.#Some outputT}
      (check_jvm outputT)

      {.#None}
      (/////analysis.except ..non_object objectT))

    _
    (check_parameter objectT)))

(template [<name> <category> <parser>]
  [(def: .public (<name> mapping typeJ)
     (-> Mapping (Type <category>) (Operation .Type))
     (case (|> typeJ ..signature (<text>.result (<parser> mapping)))
       {try.#Success check}
       (typeA.check check)
       
       {try.#Failure error}
       (phase.failure error)))]

  [boxed_reflection_type Value luxT.boxed_type]
  [reflection_type Value luxT.type]
  [boxed_reflection_return Return luxT.boxed_return]
  [reflection_return Return luxT.return]
  )

(def: (check_object objectT)
  (-> .Type (Operation [External .Type]))
  (do [! phase.monad]
    [:object: (check_jvm objectT)
     .let [name (..reflection :object:)]]
    (if (dictionary.key? ..boxes name)
      (/////analysis.except ..primitives_are_not_objects [name])
      (do !
        [:object: (reflection_type luxT.fresh :object:)]
        (phase#in [name :object:])))))

(def: (check_return type)
  (-> .Type (Operation (Type Return)))
  (if (same? .Any type)
    (phase#in jvm.void)
    (check_jvm type)))

(def: (read_primitive_array_handler lux_type jvm_type)
  (-> .Type (Type Primitive) Handler)
  (function (_ extension_name analyse archive args)
    (case args
      (pattern (list idxC arrayC))
      (do phase.monad
        [_ (typeA.inference lux_type)
         idxA (<| (typeA.expecting ..int)
                  (analyse archive idxC))
         arrayA (<| (typeA.expecting {.#Primitive (|> (jvm.array jvm_type) ..reflection)
                                                  (list)})
                    (analyse archive arrayC))]
        (in {/////analysis.#Extension extension_name (list idxA arrayA)}))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 2 (list.size args)]))))

(def: array::read::object
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (pattern (list idxC arrayC))
      (<| typeA.with_var
          (function (_ [@read :read:]))
          typeA.with_var
          (function (_ [@write :write:]))
          (do phase.monad
            [_ (typeA.inference :read:)
             arrayA (<| (typeA.expecting (.type (array.Array' :read: :write:)))
                        (analyse archive arrayC))
             idxA (<| (typeA.expecting ..int)
                      (analyse archive idxC))
             :read: (typeA.check (check.clean (list) :read:))
             :write: (typeA.check (check.clean (list) :write:))
             arrayJT (jvm_array_type (.type (array.Array' :read: :write:)))]
            (in {/////analysis.#Extension extension_name (list (/////analysis.text (..signature arrayJT))
                                                               idxA
                                                               arrayA)})))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 2 (list.size args)]))))

(def: (write_primitive_array_handler lux_type jvm_type)
  (-> .Type (Type Primitive) Handler)
  (let [array_type {.#Primitive (|> (jvm.array jvm_type) ..reflection)
                                (list)}]
    (function (_ extension_name analyse archive args)
      (case args
        (pattern (list idxC valueC arrayC))
        (do phase.monad
          [_ (typeA.inference array_type)
           idxA (<| (typeA.expecting ..int)
                    (analyse archive idxC))
           valueA (<| (typeA.expecting lux_type)
                      (analyse archive valueC))
           arrayA (<| (typeA.expecting array_type)
                      (analyse archive arrayC))]
          (in {/////analysis.#Extension extension_name (list idxA
                                                             valueA
                                                             arrayA)}))

        _
        (/////analysis.except ///.incorrect_arity [extension_name 3 (list.size args)])))))

(def: array::write::object
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (pattern (list idxC valueC arrayC))
      (<| typeA.with_var
          (function (_ [@read :read:]))
          typeA.with_var
          (function (_ [@write :write:]))
          (do phase.monad
            [_ (typeA.inference (.type (array.Array' :read: :write:)))
             arrayA (<| (typeA.expecting (.type (array.Array' :read: :write:)))
                        (analyse archive arrayC))
             idxA (<| (typeA.expecting ..int)
                      (analyse archive idxC))
             valueA (<| (typeA.expecting :write:)
                        (analyse archive valueC))
             :read: (typeA.check (check.clean (list) :read:))
             :write: (typeA.check (check.clean (list) :write:))
             arrayJT (jvm_array_type (.type (array.Array' :read: :write:)))]
            (in {/////analysis.#Extension extension_name (list (/////analysis.text (..signature arrayJT))
                                                               idxA
                                                               valueA
                                                               arrayA)})))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 3 (list.size args)]))))

(def: bundle::array
  Bundle
  (<| (///bundle.prefix "array")
      (|> ///bundle.empty
          (dictionary.merged (<| (///bundle.prefix "length")
                                 (|> ///bundle.empty
                                     (///bundle.install (reflection.reflection reflection.boolean) (primitive_array_length_handler jvm.boolean))
                                     (///bundle.install (reflection.reflection reflection.byte) (primitive_array_length_handler jvm.byte))
                                     (///bundle.install (reflection.reflection reflection.short) (primitive_array_length_handler jvm.short))
                                     (///bundle.install (reflection.reflection reflection.int) (primitive_array_length_handler jvm.int))
                                     (///bundle.install (reflection.reflection reflection.long) (primitive_array_length_handler jvm.long))
                                     (///bundle.install (reflection.reflection reflection.float) (primitive_array_length_handler jvm.float))
                                     (///bundle.install (reflection.reflection reflection.double) (primitive_array_length_handler jvm.double))
                                     (///bundle.install (reflection.reflection reflection.char) (primitive_array_length_handler jvm.char))
                                     (///bundle.install "object" array::length::object))))
          (dictionary.merged (<| (///bundle.prefix "new")
                                 (|> ///bundle.empty
                                     (///bundle.install (reflection.reflection reflection.boolean) (new_primitive_array_handler jvm.boolean))
                                     (///bundle.install (reflection.reflection reflection.byte) (new_primitive_array_handler jvm.byte))
                                     (///bundle.install (reflection.reflection reflection.short) (new_primitive_array_handler jvm.short))
                                     (///bundle.install (reflection.reflection reflection.int) (new_primitive_array_handler jvm.int))
                                     (///bundle.install (reflection.reflection reflection.long) (new_primitive_array_handler jvm.long))
                                     (///bundle.install (reflection.reflection reflection.float) (new_primitive_array_handler jvm.float))
                                     (///bundle.install (reflection.reflection reflection.double) (new_primitive_array_handler jvm.double))
                                     (///bundle.install (reflection.reflection reflection.char) (new_primitive_array_handler jvm.char))
                                     (///bundle.install "object" array::new::object))))
          (dictionary.merged (<| (///bundle.prefix "read")
                                 (|> ///bundle.empty
                                     (///bundle.install (reflection.reflection reflection.boolean) (read_primitive_array_handler ..boolean jvm.boolean))
                                     (///bundle.install (reflection.reflection reflection.byte) (read_primitive_array_handler ..byte jvm.byte))
                                     (///bundle.install (reflection.reflection reflection.short) (read_primitive_array_handler ..short jvm.short))
                                     (///bundle.install (reflection.reflection reflection.int) (read_primitive_array_handler ..int jvm.int))
                                     (///bundle.install (reflection.reflection reflection.long) (read_primitive_array_handler ..long jvm.long))
                                     (///bundle.install (reflection.reflection reflection.float) (read_primitive_array_handler ..float jvm.float))
                                     (///bundle.install (reflection.reflection reflection.double) (read_primitive_array_handler ..double jvm.double))
                                     (///bundle.install (reflection.reflection reflection.char) (read_primitive_array_handler ..char jvm.char))
                                     (///bundle.install "object" array::read::object))))
          (dictionary.merged (<| (///bundle.prefix "write")
                                 (|> ///bundle.empty
                                     (///bundle.install (reflection.reflection reflection.boolean) (write_primitive_array_handler ..boolean jvm.boolean))
                                     (///bundle.install (reflection.reflection reflection.byte) (write_primitive_array_handler ..byte jvm.byte))
                                     (///bundle.install (reflection.reflection reflection.short) (write_primitive_array_handler ..short jvm.short))
                                     (///bundle.install (reflection.reflection reflection.int) (write_primitive_array_handler ..int jvm.int))
                                     (///bundle.install (reflection.reflection reflection.long) (write_primitive_array_handler ..long jvm.long))
                                     (///bundle.install (reflection.reflection reflection.float) (write_primitive_array_handler ..float jvm.float))
                                     (///bundle.install (reflection.reflection reflection.double) (write_primitive_array_handler ..double jvm.double))
                                     (///bundle.install (reflection.reflection reflection.char) (write_primitive_array_handler ..char jvm.char))
                                     (///bundle.install "object" array::write::object))))
          )))

(def: object::null
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (pattern (list))
      (do phase.monad
        [expectedT (///.lifted meta.expected_type)
         [_ :object:] (check_object expectedT)
         _ (typeA.inference :object:)]
        (in {/////analysis.#Extension extension_name (list)}))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 0 (list.size args)]))))

(def: object::null?
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (pattern (list objectC))
      (do phase.monad
        [_ (typeA.inference .Bit)
         [objectT objectA] (typeA.inferring
                            (analyse archive objectC))
         _ (check_object objectT)]
        (in {/////analysis.#Extension extension_name (list objectA)}))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: object::synchronized
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (pattern (list monitorC exprC))
      (do phase.monad
        [[monitorT monitorA] (typeA.inferring
                              (analyse archive monitorC))
         _ (check_object monitorT)
         exprA (analyse archive exprC)]
        (in {/////analysis.#Extension extension_name (list monitorA exprA)}))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 2 (list.size args)]))))

(def: (object::throw class_loader)
  (-> java/lang/ClassLoader Handler)
  (function (_ extension_name analyse archive args)
    (case args
      (pattern (list exceptionC))
      (do phase.monad
        [_ (typeA.inference Nothing)
         [exceptionT exceptionA] (typeA.inferring
                                  (analyse archive exceptionC))
         [exception_class _] (check_object exceptionT)
         ? (phase.lifted (reflection!.sub? class_loader "java.lang.Throwable" exception_class))
         _ (is (Operation Any)
               (if ?
                 (in [])
                 (/////analysis.except non_throwable exception_class)))]
        (in {/////analysis.#Extension extension_name (list exceptionA)}))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: (object::class class_loader)
  (-> java/lang/ClassLoader Handler)
  (function (_ extension_name analyse archive args)
    (case args
      (pattern (list classC))
      (case classC
        [_ {.#Text class}]
        (do phase.monad
          [_ (..ensure_fresh_class! class_loader class)
           _ (typeA.inference {.#Primitive "java.lang.Class" (list {.#Primitive class (list)})})
           _ (phase.lifted (reflection!.load class_loader class))]
          (in {/////analysis.#Extension extension_name (list (/////analysis.text class))}))

        _
        (/////analysis.except ///.invalid_syntax [extension_name %.code args]))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: (object::instance? class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and <code>.text <code>.any)
    (function (_ extension_name analyse archive [sub_class objectC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader sub_class)
         _ (typeA.inference Bit)
         [objectT objectA] (typeA.inferring
                            (analyse archive objectC))
         [object_class _] (check_object objectT)
         ? (phase.lifted (reflection!.sub? class_loader object_class sub_class))]
        (if ?
          (in {/////analysis.#Extension extension_name (list (/////analysis.text sub_class) objectA)})
          (/////analysis.except cannot_possibly_be_an_instance (format sub_class " !<= "  object_class)))))]))

(def: (class_candidate_parents class_loader source_name fromT target_name target_class)
  (-> java/lang/ClassLoader External .Type External (java/lang/Class java/lang/Object) (Operation (List [[Text .Type] Bit])))
  (do [! phase.monad]
    [source_class (phase.lifted (reflection!.load class_loader source_name))
     mapping (phase.lifted (reflection!.correspond source_class fromT))]
    (monad.each !
                (function (_ superJT)
                  (do !
                    [superJT (phase.lifted (reflection!.type superJT))
                     .let [super_name (..reflection superJT)]
                     super_class (phase.lifted (reflection!.load class_loader super_name))
                     superT (reflection_type mapping superJT)]
                    (in [[super_name superT] (java/lang/Class::isAssignableFrom super_class target_class)])))
                (case (java/lang/Class::getGenericSuperclass source_class)
                  {.#Some super}
                  (list& super (array.list {.#None} (java/lang/Class::getGenericInterfaces source_class)))

                  {.#None}
                  (if (java/lang/reflect/Modifier::isInterface (java/lang/Class::getModifiers source_class))
                    {.#Item (as java/lang/reflect/Type (ffi.class_for java/lang/Object))
                            (array.list {.#None} (java/lang/Class::getGenericInterfaces source_class))}
                    (array.list {.#None} (java/lang/Class::getGenericInterfaces source_class)))))))

(def: (inheritance_candidate_parents class_loader fromT target_class toT fromC)
  (-> java/lang/ClassLoader .Type (java/lang/Class java/lang/Object) .Type Code (Operation (List [[Text .Type] Bit])))
  (case fromT
    (pattern {.#Primitive _ (list& self_classT super_classT super_interfacesT+)})
    (monad.each phase.monad
                (function (_ superT)
                  (do [! phase.monad]
                    [super_name (# ! each ..reflection (check_jvm superT))
                     super_class (phase.lifted (reflection!.load class_loader super_name))]
                    (in [[super_name superT]
                         (java/lang/Class::isAssignableFrom super_class target_class)])))
                (list& super_classT super_interfacesT+))

    _
    (/////analysis.except ..cannot_cast [fromT toT fromC])))

(def: (object::cast class_loader)
  (-> java/lang/ClassLoader Handler)
  (function (_ extension_name analyse archive args)
    (case args
      (pattern (list fromC))
      (do [! phase.monad]
        [toT (///.lifted meta.expected_type)
         target_name (# ! each ..reflection (check_jvm toT))
         [fromT fromA] (typeA.inferring
                        (analyse archive fromC))
         source_name (# ! each ..reflection (check_jvm fromT))
         can_cast? (is (Operation Bit)
                       (`` (cond (~~ (template [<primitive> <object>]
                                       [(let [=primitive (reflection.reflection <primitive>)]
                                          (or (and (text#= =primitive source_name)
                                                   (or (text#= <object> target_name)
                                                       (text#= =primitive target_name)))
                                              (and (text#= <object> source_name)
                                                   (text#= =primitive target_name))))
                                        (in true)]

                                       [reflection.boolean box.boolean]
                                       [reflection.byte    box.byte]
                                       [reflection.short   box.short]
                                       [reflection.int     box.int]
                                       [reflection.long    box.long]
                                       [reflection.float   box.float]
                                       [reflection.double  box.double]
                                       [reflection.char    box.char]))

                                 ... else
                                 (do !
                                   [_ (phase.assertion ..primitives_are_not_objects [source_name]
                                                       (not (dictionary.key? ..boxes source_name)))
                                    _ (phase.assertion ..primitives_are_not_objects [target_name]
                                                       (not (dictionary.key? ..boxes target_name)))
                                    target_class (phase.lifted (reflection!.load class_loader target_name))
                                    _ (do !
                                        [source_class (phase.lifted (reflection!.load class_loader source_name))]
                                        (phase.assertion ..cannot_cast [fromT toT fromC]
                                                         (java/lang/Class::isAssignableFrom source_class target_class)))]
                                   (loop (again [[current_name currentT] [source_name fromT]])
                                     (if (text#= target_name current_name)
                                       (in true)
                                       (do !
                                         [candidate_parents (is (Operation (List [[Text .Type] Bit]))
                                                                (class_candidate_parents class_loader current_name currentT target_name target_class))]
                                         (case (|> candidate_parents
                                                   (list.only product.right)
                                                   (list#each product.left))
                                           {.#Item [next_name nextT] _}
                                           (again [next_name nextT])

                                           {.#End}
                                           (in false)))))))))]
        (if can_cast?
          (in {/////analysis.#Extension extension_name (list (/////analysis.text source_name)
                                                             (/////analysis.text target_name)
                                                             fromA)})
          (/////analysis.except ..cannot_cast [fromT toT fromC])))

      _
      (/////analysis.except ///.invalid_syntax [extension_name %.code args]))))

(def: (bundle::object class_loader)
  (-> java/lang/ClassLoader Bundle)
  (<| (///bundle.prefix "object")
      (|> ///bundle.empty
          (///bundle.install "null" object::null)
          (///bundle.install "null?" object::null?)
          (///bundle.install "synchronized" object::synchronized)
          (///bundle.install "throw" (object::throw class_loader))
          (///bundle.install "class" (object::class class_loader))
          (///bundle.install "instance?" (object::instance? class_loader))
          (///bundle.install "cast" (object::cast class_loader))
          )))

(def: (get::static class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [..member
    (function (_ extension_name analyse archive [class field])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         [final? deprecated? fieldJT] (phase.lifted
                                       (do try.monad
                                         [class (reflection!.load class_loader class)]
                                         (reflection!.static_field field class)))
         _ (phase.assertion ..deprecated_field [class field]
                            (not deprecated?))
         fieldT (reflection_type luxT.fresh fieldJT)
         _ (typeA.inference fieldT)]
        (in (<| {/////analysis.#Extension extension_name}
                (list (/////analysis.text class)
                      (/////analysis.text field)
                      (/////analysis.text (..signature fieldJT)))))))]))

(def: (put::static class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..member <code>.any)
    (function (_ extension_name analyse archive [[class field] valueC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         _ (typeA.inference Any)
         [final? deprecated? fieldJT] (phase.lifted
                                       (do try.monad
                                         [class (reflection!.load class_loader class)]
                                         (reflection!.static_field field class)))
         _ (phase.assertion ..deprecated_field [class field]
                            (not deprecated?))
         ... _ (phase.assertion ..cannot_set_a_final_field [class field]
         ...                    (not final?))
         fieldT (reflection_type luxT.fresh fieldJT)
         valueA (<| (typeA.expecting fieldT)
                    (analyse archive valueC))]
        (in (<| {/////analysis.#Extension extension_name}
                (list (/////analysis.text class)
                      (/////analysis.text field)
                      (/////analysis.text (..signature fieldJT))
                      valueA)))))]))

(def: (get::virtual class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..member <code>.any)
    (function (_ extension_name analyse archive [[class field] objectC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         [objectT objectA] (typeA.inferring
                            (analyse archive objectC))
         [deprecated? mapping fieldJT] (phase.lifted
                                        (do try.monad
                                          [class (reflection!.load class_loader class)
                                           [final? deprecated? fieldJT] (reflection!.virtual_field field class)
                                           mapping (reflection!.correspond class objectT)]
                                          (in [deprecated? mapping fieldJT])))
         _ (phase.assertion ..deprecated_field [class field]
                            (not deprecated?))
         fieldT (reflection_type mapping fieldJT)
         _ (typeA.inference fieldT)]
        (in (<| {/////analysis.#Extension extension_name}
                (list (/////analysis.text class)
                      (/////analysis.text field)
                      (/////analysis.text (..signature fieldJT))
                      objectA)))))]))

(def: (put::virtual class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..member <code>.any <code>.any)
    (function (_ extension_name analyse archive [[class field] valueC objectC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         [objectT objectA] (typeA.inferring
                            (analyse archive objectC))
         _ (typeA.inference objectT)
         [final? deprecated? mapping fieldJT] (phase.lifted
                                               (do try.monad
                                                 [class (reflection!.load class_loader class)
                                                  [final? deprecated? fieldJT] (reflection!.virtual_field field class)
                                                  mapping (reflection!.correspond class objectT)]
                                                 (in [final? deprecated? mapping fieldJT])))
         _ (phase.assertion ..deprecated_field [class field]
                            (not deprecated?))
         _ (phase.assertion ..cannot_set_a_final_field [class field]
                            (not final?))
         fieldT (reflection_type mapping fieldJT)
         valueA (<| (typeA.expecting fieldT)
                    (analyse archive valueC))]
        (in (<| {/////analysis.#Extension extension_name}
                (list (/////analysis.text class)
                      (/////analysis.text field)
                      (/////analysis.text (..signature fieldJT))
                      valueA
                      objectA)))))]))

(type: Method_Style
  (Variant
   {#Static}
   {#Abstract}
   {#Virtual}
   {#Special}
   {#Interface}))

(def: (de_aliased aliasing)
  (-> Aliasing (Type Value) (Type Value))
  (function (again it)
    (`` (<| (case (parser.var? it)
              {.#Some name}
              (|> aliasing
                  (dictionary.value name)
                  (maybe#each jvm.var)
                  (maybe.else it))
              {.#None})
            (case (parser.class? it)
              {.#Some [name parameters]}
              (|> parameters
                  (list#each (|>> again (as (Type Parameter))))
                  (jvm.class name))
              {.#None})
            (~~ (template [<read> <as> <write>]
                  [(case (<read> it)
                     {.#Some :sub:}
                     (<write> (as (Type <as>) (again :sub:)))
                     {.#None})]

                  [parser.array? Value jvm.array]
                  [parser.lower? Class jvm.lower]
                  [parser.upper? Class jvm.upper]
                  ))
            it))))

(def: (check_method aliasing class method_name method_style inputsJT method)
  (-> Aliasing (java/lang/Class java/lang/Object) Text Method_Style (List (Type Value)) java/lang/reflect/Method (Operation Bit))
  (do phase.monad
    [parameters (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                    (array.list {.#None})
                    (monad.each try.monad reflection!.type)
                    phase.lifted)
     .let [modifiers (java/lang/reflect/Method::getModifiers method)
           correct_class? (java/lang/Class::isAssignableFrom class (java/lang/reflect/Method::getDeclaringClass method))
           correct_method? (text#= method_name (java/lang/reflect/Method::getName method))
           same_static? (case method_style
                          {#Static}
                          (java/lang/reflect/Modifier::isStatic modifiers)

                          _
                          true)
           same_special? (case method_style
                           {#Special}
                           (not (or (java/lang/reflect/Modifier::isInterface (java/lang/Class::getModifiers class))
                                    (java/lang/reflect/Modifier::isAbstract modifiers)))

                           _
                           true)
           same_inputs? (and (n.= (list.size inputsJT)
                                  (list.size parameters))
                             (list.every? (function (_ [expectedJC actualJC])
                                            (jvm#= expectedJC (de_aliased aliasing actualJC)))
                                          (list.zipped_2 parameters inputsJT)))]]
    (in (and correct_class?
             correct_method?
             same_static?
             same_special?
             same_inputs?))))

(def: (check_constructor aliasing class inputsJT constructor)
  (-> Aliasing (java/lang/Class java/lang/Object) (List (Type Value)) (java/lang/reflect/Constructor java/lang/Object) (Operation Bit))
  (do phase.monad
    [parameters (|> (java/lang/reflect/Constructor::getGenericParameterTypes constructor)
                    (array.list {.#None})
                    (monad.each try.monad reflection!.type)
                    phase.lifted)]
    (in (and (java/lang/Object::equals class (java/lang/reflect/Constructor::getDeclaringClass constructor))
             (n.= (list.size inputsJT) (list.size parameters))
             (list.every? (function (_ [expectedJC actualJC])
                            (jvm#= expectedJC (de_aliased aliasing actualJC)))
                          (list.zipped_2 parameters inputsJT))))))

(def: index_parameter
  (-> Nat .Type)
  (|>> (n.* 2) ++ {.#Parameter}))

(def: (jvm_type_var_mapping owner_tvars method_tvars)
  (-> (List Text) (List Text) [(List .Type) Mapping])
  (let [jvm_tvars (list#composite owner_tvars method_tvars)
        lux_tvars (|> jvm_tvars
                      list.reversed
                      list.enumeration
                      (list#each (function (_ [idx name])
                                   [name (index_parameter idx)]))
                      list.reversed)
        num_owner_tvars (list.size owner_tvars)
        owner_tvarsT (|> lux_tvars (list.first num_owner_tvars) (list#each product.right))
        mapping (dictionary.of_list text.hash lux_tvars)]
    [owner_tvarsT mapping]))

(def: (lux_class it)
  (-> (java/lang/Class java/lang/Object) (Type Class))
  (jvm.class (java/lang/Class::getName it) (list)))

(template [<name> <type> <params>]
  [(`` (def: <name>
         (-> (<type> (~~ (template.spliced <params>))) (List (Type Class)))
         (|>> (~~ (template.symbol [<type> "::getExceptionTypes"]))
              (array.list {.#None})
              (list#each ..lux_class))))]

  [concrete_method_exceptions java/lang/reflect/Method []]
  [concrete_constructor_exceptions java/lang/reflect/Constructor [java/lang/Object]]
  )

(def: (return_type it)
  (-> java/lang/reflect/Method (Try (Type Return)))
  (reflection!.return
   (case (java/lang/reflect/Method::getGenericReturnType it)
     {.#Some it}
     it
     
     {.#None}
     (java/lang/reflect/Method::getReturnType it))))

(def: (method_signature method_style method)
  (-> Method_Style java/lang/reflect/Method (Operation Method_Signature))
  (let [owner (java/lang/reflect/Method::getDeclaringClass method)
        owner_tvars (case method_style
                      {#Static}
                      (list)

                      _
                      (|> (java/lang/Class::getTypeParameters owner)
                          (array.list {.#None})
                          (list#each (|>> java/lang/reflect/TypeVariable::getName))))
        method_tvars (|> (java/lang/reflect/Method::getTypeParameters method)
                         (array.list {.#None})
                         (list#each (|>> java/lang/reflect/TypeVariable::getName)))
        [owner_tvarsT mapping] (jvm_type_var_mapping owner_tvars method_tvars)]
    (do [! phase.monad]
      [inputsT (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                   (array.list {.#None})
                   (monad.each ! (|>> reflection!.type phase.lifted))
                   (phase#each (monad.each ! (..reflection_type mapping)))
                   phase#conjoint)
       outputT (|> method
                   ..return_type
                   phase.lifted
                   (phase#each (..reflection_return mapping))
                   phase#conjoint)
       .let [concrete_exceptions (..concrete_method_exceptions method)]
       concrete_exceptions (monad.each ! (..reflection_type mapping) concrete_exceptions)
       generic_exceptions (|> (java/lang/reflect/Method::getGenericExceptionTypes method)
                              (array.list {.#None})
                              (monad.each ! (|>> reflection!.type phase.lifted))
                              (phase#each (monad.each ! (..reflection_type mapping)))
                              phase#conjoint)
       .let [methodT (<| (type.univ_q (dictionary.size mapping))
                         (type.function (case method_style
                                          {#Static}
                                          inputsT

                                          _
                                          (list& {.#Primitive (java/lang/Class::getName owner) owner_tvarsT}
                                                 inputsT)))
                         outputT)]]
      (in [methodT
           (reflection!.deprecated? (java/lang/reflect/Method::getDeclaredAnnotations method))
           (if (list.empty? generic_exceptions)
             concrete_exceptions
             generic_exceptions)]))))

(def: (constructor_signature constructor)
  (-> (java/lang/reflect/Constructor java/lang/Object) (Operation Method_Signature))
  (let [owner (java/lang/reflect/Constructor::getDeclaringClass constructor)
        owner_tvars (|> (java/lang/Class::getTypeParameters owner)
                        (array.list {.#None})
                        (list#each (|>> java/lang/reflect/TypeVariable::getName)))
        method_tvars (|> (java/lang/reflect/Constructor::getTypeParameters constructor)
                         (array.list {.#None})
                         (list#each (|>> java/lang/reflect/TypeVariable::getName)))
        [owner_tvarsT mapping] (jvm_type_var_mapping owner_tvars method_tvars)]
    (do [! phase.monad]
      [inputsT (|> (java/lang/reflect/Constructor::getGenericParameterTypes constructor)
                   (array.list {.#None})
                   (monad.each ! (|>> reflection!.type phase.lifted))
                   (phase#each (monad.each ! (reflection_type mapping)))
                   phase#conjoint)
       .let [concrete_exceptions (..concrete_constructor_exceptions constructor)]
       concrete_exceptions (monad.each ! (..reflection_type mapping) concrete_exceptions)
       generic_exceptions (|> (java/lang/reflect/Constructor::getGenericExceptionTypes constructor)
                              (array.list {.#None})
                              (monad.each ! (|>> reflection!.type phase.lifted))
                              (phase#each (monad.each ! (reflection_type mapping)))
                              phase#conjoint)
       .let [objectT {.#Primitive (java/lang/Class::getName owner) owner_tvarsT}
             constructorT (<| (type.univ_q (dictionary.size mapping))
                              (type.function inputsT)
                              objectT)]]
      (in [constructorT
           (reflection!.deprecated? (java/lang/reflect/Constructor::getDeclaredAnnotations constructor))
           (if (list.empty? generic_exceptions)
             concrete_exceptions
             generic_exceptions)]))))

(type: Evaluation
  (Variant
   {#Pass Method_Signature}
   {#Hint Method_Signature}))

(template [<name> <tag>]
  [(def: <name>
     (-> Evaluation (Maybe Method_Signature))
     (|>> (pipe.case
            {<tag> output}
            {.#Some output}

            _
            {.#None})))]

  [pass #Pass]
  [hint #Hint]
  )

(template [<name> <type> <method>]
  [(def: <name>
     (-> <type> (List (Type Var)))
     (|>> <method>
          (array.list {.#None})
          (list#each (|>> java/lang/reflect/TypeVariable::getName jvm.var))))]

  [class_type_variables (java/lang/Class java/lang/Object) java/lang/Class::getTypeParameters]
  [constructor_type_variables (java/lang/reflect/Constructor java/lang/Object) java/lang/reflect/Constructor::getTypeParameters]
  [method_type_variables java/lang/reflect/Method java/lang/reflect/Method::getTypeParameters]
  )

(def: (aliasing expected actual)
  (-> (List (Type Var)) (List (Type Var)) Aliasing)
  (|> (list.zipped_2 (list#each parser.name actual)
                     (list#each parser.name expected))
      (dictionary.of_list text.hash)))

(def: (family_tree' it)
  (-> (java/lang/Class java/lang/Object)
      (List (java/lang/Class java/lang/Object)))
  (let [interfaces (array.list {.#None} (java/lang/Class::getInterfaces it))
        supers (case (java/lang/Class::getSuperclass it)
                 {.#Some class}
                 (list& class interfaces)
                 
                 {.#None}
                 interfaces)]
    (|> supers
        (list#each family_tree')
        list#conjoint
        (list& it))))

(def: family_tree
  (-> (java/lang/Class java/lang/Object)
      (List (java/lang/Class java/lang/Object)))
  (|>> ..family_tree'
       ... De-duplication
       (list#mix (function (_ class all)
                   (dictionary.has (java/lang/Class::getName class) class all))
                 (dictionary.empty text.hash))
       dictionary.values))

(def: (all_declared_methods it)
  (-> (java/lang/Class java/lang/Object)
      (List java/lang/reflect/Method))
  (|> it
      ..family_tree
      (list#each (|>> java/lang/Class::getDeclaredMethods (array.list {.#None})))
      list#conjoint))

(def: (method_candidate allow_inheritance? class_loader actual_class_tvars class_name actual_method_tvars method_name method_style inputsJT)
  (-> Bit java/lang/ClassLoader (List (Type Var)) External (List (Type Var)) Text Method_Style (List (Type Value)) (Operation Method_Signature))
  (do [! phase.monad]
    [class (phase.lifted (reflection!.load class_loader class_name))
     .let [expected_class_tvars (class_type_variables class)]
     candidates (|> (if allow_inheritance?
                      (all_declared_methods class)
                      (array.list {.#None} (java/lang/Class::getDeclaredMethods class)))
                    (list.only (|>> java/lang/reflect/Method::getName (text#= method_name)))
                    (monad.each ! (is (-> java/lang/reflect/Method (Operation Evaluation))
                                      (function (_ method)
                                        (do !
                                          [.let [expected_method_tvars (method_type_variables method)
                                                 aliasing (dictionary.merged (..aliasing expected_class_tvars actual_class_tvars)
                                                                             (..aliasing expected_method_tvars actual_method_tvars))]
                                           passes? (check_method aliasing class method_name method_style inputsJT method)]
                                          (# ! each (if passes?
                                                      (|>> {#Pass})
                                                      (|>> {#Hint}))
                                             (method_signature method_style method)))))))]
    (case (list.all pass candidates)
      {.#Item method {.#End}}
      (in method)

      {.#End}
      (/////analysis.except ..no_candidates [actual_class_tvars class_name method_name actual_method_tvars inputsJT (list.all hint candidates)])
      
      {.#Item method alternatives}
      (if allow_inheritance?
        (in method)
        (/////analysis.except ..too_many_candidates [actual_class_tvars class_name method_name actual_method_tvars inputsJT (list& method alternatives)])))))

(def: constructor_method
  "<init>")

(def: (constructor_candidate class_loader actual_class_tvars class_name actual_method_tvars inputsJT)
  (-> java/lang/ClassLoader (List (Type Var)) External (List (Type Var)) (List (Type Value)) (Operation Method_Signature))
  (do [! phase.monad]
    [class (phase.lifted (reflection!.load class_loader class_name))
     .let [expected_class_tvars (class_type_variables class)]
     candidates (|> class
                    java/lang/Class::getConstructors
                    (array.list {.#None})
                    (monad.each ! (function (_ constructor)
                                    (do !
                                      [.let [expected_method_tvars (constructor_type_variables constructor)
                                             aliasing (dictionary.merged (..aliasing expected_class_tvars actual_class_tvars)
                                                                         (..aliasing expected_method_tvars actual_method_tvars))]
                                       passes? (check_constructor aliasing class inputsJT constructor)]
                                      (# ! each
                                         (if passes?
                                           (|>> {#Pass})
                                           (|>> {#Hint}))
                                         (constructor_signature constructor))))))]
    (case (list.all pass candidates)
      {.#Item constructor {.#End}}
      (in constructor)

      {.#End}
      (/////analysis.except ..no_candidates [actual_class_tvars class_name ..constructor_method actual_method_tvars inputsJT (list.all hint candidates)])
      
      candidates
      (/////analysis.except ..too_many_candidates [actual_class_tvars class_name ..constructor_method actual_method_tvars inputsJT candidates]))))

(template [<name> <category> <parser>]
  [(def: .public <name>
     (Parser (Type <category>))
     (<text>.then <parser> <code>.text))]

  [var Var parser.var]
  [class Class parser.class]
  [type Value parser.value]
  [return Return parser.return]
  )

(def: input
  (Parser (Typed Code))
  (<code>.tuple (<>.and ..type <code>.any)))

(def: (decorate_inputs typesT inputsA)
  (-> (List (Type Value)) (List Analysis) (List Analysis))
  (|> inputsA
      (list.zipped_2 (list#each (|>> ..signature /////analysis.text) typesT))
      (list#each (function (_ [type value])
                   (/////analysis.tuple (list type value))))))

(def: type_vars
  (<code>.tuple (<>.some ..var)))

(def: (invoke::static class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..type_vars ..member ..type_vars (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class method] method_tvars argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         .let [argsT (list#each product.left argsTC)]
         [methodT deprecated? exceptionsT] (..method_candidate false class_loader class_tvars class method_tvars method {#Static} argsT)
         _ (phase.assertion ..deprecated_method [class method methodT]
                            (not deprecated?))
         [outputT argsA] (inference.general archive analyse methodT (list#each product.right argsTC))
         outputJT (check_return outputT)]
        (in {/////analysis.#Extension extension_name (list& (/////analysis.text (..signature (jvm.class class (list))))
                                                            (/////analysis.text method)
                                                            (/////analysis.text (..signature outputJT))
                                                            (decorate_inputs argsT argsA))})))]))

(def: (invoke::virtual class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..type_vars ..member ..type_vars <code>.any (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class method] method_tvars objectC argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         .let [argsT (list#each product.left argsTC)]
         [methodT deprecated? exceptionsT] (..method_candidate true class_loader class_tvars class method_tvars method {#Virtual} argsT)
         _ (phase.assertion ..deprecated_method [class method methodT]
                            (not deprecated?))
         [outputT allA] (inference.general archive analyse methodT (list& objectC (list#each product.right argsTC)))
         .let [[objectA argsA] (case allA
                                 {.#Item objectA argsA}
                                 [objectA argsA]

                                 _
                                 (undefined))]
         outputJT (check_return outputT)]
        (in {/////analysis.#Extension extension_name (list& (/////analysis.text (..signature (jvm.class class (list))))
                                                            (/////analysis.text method)
                                                            (/////analysis.text (..signature outputJT))
                                                            objectA
                                                            (decorate_inputs argsT argsA))})))]))

(def: (invoke::special class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..type_vars ..member ..type_vars <code>.any (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class method] method_tvars objectC argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         .let [argsT (list#each product.left argsTC)]
         [methodT deprecated? exceptionsT] (..method_candidate false class_loader class_tvars class method_tvars method {#Special} argsT)
         _ (phase.assertion ..deprecated_method [class method methodT]
                            (not deprecated?))
         [outputT allA] (inference.general archive analyse methodT (list& objectC (list#each product.right argsTC)))
         .let [[objectA argsA] (case allA
                                 {.#Item objectA argsA}
                                 [objectA argsA]

                                 _
                                 (undefined))]
         outputJT (check_return outputT)]
        (in {/////analysis.#Extension extension_name (list& (/////analysis.text (..signature (jvm.class class (list))))
                                                            (/////analysis.text method)
                                                            (/////analysis.text (..signature outputJT))
                                                            objectA
                                                            (decorate_inputs argsT argsA))})))]))

(def: (invoke::interface class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..type_vars ..member ..type_vars <code>.any (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class_name method] method_tvars objectC argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class_name)
         .let [argsT (list#each product.left argsTC)]
         class (phase.lifted (reflection!.load class_loader class_name))
         _ (phase.assertion non_interface class_name
                            (java/lang/reflect/Modifier::isInterface (java/lang/Class::getModifiers class)))
         [methodT deprecated? exceptionsT] (..method_candidate true class_loader class_tvars class_name method_tvars method {#Interface} argsT)
         _ (phase.assertion ..deprecated_method [class_name method methodT]
                            (not deprecated?))
         [outputT allA] (inference.general archive analyse methodT (list& objectC (list#each product.right argsTC)))
         .let [[objectA argsA] (case allA
                                 {.#Item objectA argsA}
                                 [objectA argsA]

                                 _
                                 (undefined))]
         outputJT (check_return outputT)]
        (in {/////analysis.#Extension extension_name
                                      (list& (/////analysis.text (..signature (jvm.class class_name (list))))
                                             (/////analysis.text method)
                                             (/////analysis.text (..signature outputJT))
                                             objectA
                                             (decorate_inputs argsT argsA))})))]))

(def: (invoke::constructor class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..type_vars <code>.text ..type_vars (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars class method_tvars argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         .let [argsT (list#each product.left argsTC)]
         [methodT deprecated? exceptionsT] (..constructor_candidate class_loader class_tvars class method_tvars argsT)
         _ (phase.assertion ..deprecated_method [class ..constructor_method methodT]
                            (not deprecated?))
         [outputT argsA] (inference.general archive analyse methodT (list#each product.right argsTC))]
        (in {/////analysis.#Extension extension_name (list& (/////analysis.text (..signature (jvm.class class (list))))
                                                            (decorate_inputs argsT argsA))})))]))

(def: (bundle::member class_loader)
  (-> java/lang/ClassLoader Bundle)
  (<| (///bundle.prefix "member")
      (|> ///bundle.empty
          (dictionary.merged (<| (///bundle.prefix "get")
                                 (|> ///bundle.empty
                                     (///bundle.install "static" (get::static class_loader))
                                     (///bundle.install "virtual" (get::virtual class_loader)))))
          (dictionary.merged (<| (///bundle.prefix "put")
                                 (|> ///bundle.empty
                                     (///bundle.install "static" (put::static class_loader))
                                     (///bundle.install "virtual" (put::virtual class_loader)))))
          (dictionary.merged (<| (///bundle.prefix "invoke")
                                 (|> ///bundle.empty
                                     (///bundle.install "static" (invoke::static class_loader))
                                     (///bundle.install "virtual" (invoke::virtual class_loader))
                                     (///bundle.install "special" (invoke::special class_loader))
                                     (///bundle.install "interface" (invoke::interface class_loader))
                                     (///bundle.install "constructor" (invoke::constructor class_loader))
                                     )))
          )))

(type: .public (Annotation_Parameter a)
  [Text a])

(def: annotation_parameter
  (Parser (Annotation_Parameter Code))
  (<code>.tuple (<>.and <code>.text <code>.any)))

(type: .public (Annotation a)
  [Text (List (Annotation_Parameter a))])

(def: .public annotation
  (Parser (Annotation Code))
  (<code>.form (<>.and <code>.text (<>.some ..annotation_parameter))))

(def: .public argument
  (Parser Argument)
  (<code>.tuple (<>.and <code>.text ..type)))

(def: (annotation_parameter_analysis [name value])
  (-> (Annotation_Parameter Analysis) Analysis)
  (/////analysis.tuple (list (/////analysis.text name) value)))

(def: (annotation_analysis [name parameters])
  (-> (Annotation Analysis) Analysis)
  (/////analysis.tuple (list& (/////analysis.text name)
                              (list#each annotation_parameter_analysis parameters))))

(template [<name> <category>]
  [(def: <name>
     (-> (Type <category>) Analysis)
     (|>> ..signature /////analysis.text))]

  [var_analysis Var]
  [class_analysis Class]
  [value_analysis Value]
  [return_analysis Return]
  )

(def: (typed_analysis [type term])
  (-> (Typed Analysis) Analysis)
  (/////analysis.tuple (list (value_analysis type) term)))

(def: (argument_analysis [argument argumentJT])
  (-> Argument Analysis)
  (/////analysis.tuple
   (list (/////analysis.text argument)
         (value_analysis argumentJT))))

(template [<name> <only> <methods>]
  [(def: (<name> [type class])
     (-> [(Type Class) (java/lang/Class java/lang/Object)]
         (Try (List [(Type Class) Text (Type Method)])))
     (|> class
         <methods>
         (list.only (|>> java/lang/reflect/Method::getModifiers
                         (predicate.or (|>> java/lang/reflect/Modifier::isPublic)
                                       (|>> java/lang/reflect/Modifier::isProtected))))
         <only>
         (monad.each try.monad
                     (function (_ method)
                       (do [! try.monad]
                         [.let [type_variables (|> (java/lang/reflect/Method::getTypeParameters method)
                                                   (array.list {.#None})
                                                   (list#each (|>> java/lang/reflect/TypeVariable::getName
                                                                   jvm.var)))]
                          inputs (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                                     (array.list {.#None})
                                     (monad.each ! reflection!.type))
                          return (..return_type method)
                          .let [concrete_exceptions (..concrete_method_exceptions method)]
                          generic_exceptions (|> (java/lang/reflect/Method::getGenericExceptionTypes method)
                                                 (array.list {.#None})
                                                 (monad.each ! reflection!.class))]
                         (in [type
                              (java/lang/reflect/Method::getName method)
                              (jvm.method [type_variables inputs return (if (list.empty? generic_exceptions)
                                                                          concrete_exceptions
                                                                          generic_exceptions)])]))))))]

  [abstract_methods (list.only (|>> java/lang/reflect/Method::getModifiers java/lang/reflect/Modifier::isAbstract))
   (<| (array.list {.#None}) java/lang/Class::getDeclaredMethods)]
  [methods (<|)
   ..all_declared_methods]
  )

(def: jvm_package_separator ".")

(template [<name> <methods>]
  [(def: (<name> class_loader)
     (-> java/lang/ClassLoader (List (Type Class)) (Try (List [(Type Class) Text (Type Method)])))
     (|>> (monad.each try.monad (function (_ type)
                                  (|> type
                                      ..reflection
                                      (reflection!.load class_loader)
                                      (try#each (|>> [type])))))
          (try#each (monad.each try.monad <methods>))
          try#conjoint
          (try#each list#conjoint)))]

  [all_abstract_methods ..abstract_methods]
  [all_methods ..methods]
  )

(template [<name>]
  [(exception: .public (<name> [expected (List [(Type Class) Text (Type Method)])
                                actual (List [(Type Class) Text (Type Method)])])
     (let [%method (is (%.Format [(Type Class) Text (Type Method)])
                       (function (_ [super name type])
                         (format (..signature super) " :: " (%.text name) " " (..signature type))))]
       (exception.report
        "Expected Methods" (exception.listing %method expected)
        "Actual Methods" (exception.listing %method actual))))]

  [missing_abstract_methods]
  [invalid_overriden_methods]
  )

(type: .public Visibility
  (Variant
   {#Public}
   {#Private}
   {#Protected}
   {#Default}))

(type: .public Finality Bit)
(type: .public Strictness Bit)

(def: .public public_tag "public")
(def: .public private_tag "private")
(def: .public protected_tag "protected")
(def: .public default_tag "default")

(def: .public visibility'
  (<text>.Parser Visibility)
  ($_ <>.or
      (<text>.this ..public_tag)
      (<text>.this ..private_tag)
      (<text>.this ..protected_tag)
      (<text>.this ..default_tag)
      ))

(def: .public visibility
  (Parser Visibility)
  (<text>.then ..visibility' <code>.text))

(def: .public (visibility_analysis visibility)
  (-> Visibility Analysis)
  (/////analysis.text (case visibility
                        {#Public} ..public_tag
                        {#Private} ..private_tag
                        {#Protected} ..protected_tag
                        {#Default} ..default_tag)))

(type: Exception
  (Type Class))

(def: .public parameter_types
  (-> (List (Type Var)) (Check (List [(Type Var) .Type])))
  (monad.each check.monad
              (function (_ parameterJ)
                (do check.monad
                  [[_ parameterT] check.existential]
                  (in [parameterJ parameterT])))))

(type: .public (Abstract_Method a)
  [Text
   Visibility
   (List (Annotation a))
   (List (Type Var))
   (List Argument)
   (Type Return)
   (List Exception)])

(def: .public abstract_tag "abstract")

(def: .public abstract_method_definition
  (Parser (Abstract_Method Code))
  (<| <code>.form
      (<>.after (<code>.this_text ..abstract_tag))
      ($_ <>.and
          <code>.text
          ..visibility
          (<code>.tuple (<>.some ..annotation))
          (<code>.tuple (<>.some ..var))
          (<code>.tuple (<>.some ..argument))
          ..return
          (<code>.tuple (<>.some ..class)))))

(def: (method_mapping of_class parameters)
  (-> Mapping (List (Type Var)) (Check Mapping))
  (|> parameters
      ..parameter_types
      (check#each (list#mix (function (_ [parameterJ parameterT] mapping)
                              (dictionary.has (parser.name parameterJ) parameterT mapping))
                            of_class))))

(def: class_mapping
  (-> (List (Type Var)) (Check Mapping))
  (..method_mapping luxT.fresh))

(def: .public (analyse_abstract_method analyse archive method)
  (-> Phase Archive (Abstract_Method Code) (Operation Analysis))
  (let [[method_name visibility annotations vars arguments return exceptions] method]
    (do [! phase.monad]
      [mapping (typeA.check (method_mapping luxT.fresh vars))
       annotationsA (monad.each ! (function (_ [name parameters])
                                    (do !
                                      [parametersA (monad.each ! (function (_ [name value])
                                                                   (do !
                                                                     [valueA (analyse archive value)]
                                                                     (in [name valueA])))
                                                               parameters)]
                                      (in [name parametersA])))
                                annotations)]
      (in (/////analysis.tuple (list (/////analysis.text ..abstract_tag)
                                     (/////analysis.text method_name)
                                     (visibility_analysis visibility)
                                     (/////analysis.tuple (list#each annotation_analysis annotationsA))
                                     (/////analysis.tuple (list#each var_analysis vars))
                                     (/////analysis.tuple (list#each ..argument_analysis arguments))
                                     (return_analysis return)
                                     (/////analysis.tuple (list#each class_analysis exceptions))
                                     ))))))

(type: .public (Constructor a)
  [Visibility
   Strictness
   (List (Annotation a))
   (List (Type Var))
   (List Exception)
   Text
   (List Argument)
   (List (Typed a))
   a])

(def: .public constructor_tag "init")

(def: .public constructor_definition
  (Parser (Constructor Code))
  (<| <code>.form
      (<>.after (<code>.this_text ..constructor_tag))
      ($_ <>.and
          ..visibility
          <code>.bit
          (<code>.tuple (<>.some ..annotation))
          (<code>.tuple (<>.some ..var))
          (<code>.tuple (<>.some ..class))
          <code>.text
          (<code>.tuple (<>.some ..argument))
          (<code>.tuple (<>.some ..input))
          <code>.any)))

(def: .public (analyse_constructor_method analyse archive selfT mapping method)
  (-> Phase Archive .Type Mapping (Constructor Code) (Operation Analysis))
  (let [[visibility strict_fp?
         annotations vars exceptions
         self_name arguments super_arguments body] method]
    (do [! phase.monad]
      [mapping (typeA.check (method_mapping mapping vars))
       annotationsA (monad.each ! (function (_ [name parameters])
                                    (do !
                                      [parametersA (monad.each ! (function (_ [name value])
                                                                   (do !
                                                                     [valueA (analyse archive value)]
                                                                     (in [name valueA])))
                                                               parameters)]
                                      (in [name parametersA])))
                                annotations)
       super_arguments (monad.each ! (function (_ [jvmT super_argC])
                                       (do !
                                         [luxT (reflection_type mapping jvmT)
                                          super_argA (<| (typeA.expecting luxT)
                                                         (analyse archive super_argC))]
                                         (in [jvmT super_argA])))
                                   super_arguments)
       arguments' (monad.each !
                              (function (_ [name jvmT])
                                (do !
                                  [luxT (boxed_reflection_type mapping jvmT)]
                                  (in [name luxT])))
                              arguments)
       [scope bodyA] (|> arguments'
                         {.#Item [self_name selfT]}
                         list.reversed
                         (list#mix scope.with_local (analyse archive body))
                         (typeA.expecting .Any)
                         scope.with)]
      (in (/////analysis.tuple (list (/////analysis.text ..constructor_tag)
                                     (visibility_analysis visibility)
                                     (/////analysis.bit strict_fp?)
                                     (/////analysis.tuple (list#each annotation_analysis annotationsA))
                                     (/////analysis.tuple (list#each var_analysis vars))
                                     (/////analysis.tuple (list#each class_analysis exceptions))
                                     (/////analysis.text self_name)
                                     (/////analysis.tuple (list#each ..argument_analysis arguments))
                                     (/////analysis.tuple (list#each typed_analysis super_arguments))
                                     {/////analysis.#Function
                                      (list#each (|>> /////analysis.variable)
                                                 (scope.environment scope))
                                      (/////analysis.tuple (list bodyA))}
                                     ))))))

(type: .public (Virtual_Method a)
  [Text
   Visibility
   Finality
   Strictness
   (List (Annotation a))
   (List (Type Var))
   Text
   (List Argument)
   (Type Return)
   (List Exception)
   a])

(def: .public virtual_tag "virtual")

(def: .public virtual_method_definition
  (Parser (Virtual_Method Code))
  (<| <code>.form
      (<>.after (<code>.this_text ..virtual_tag))
      ($_ <>.and
          <code>.text
          ..visibility
          <code>.bit
          <code>.bit
          (<code>.tuple (<>.some ..annotation))
          (<code>.tuple (<>.some ..var))
          <code>.text
          (<code>.tuple (<>.some ..argument))
          ..return
          (<code>.tuple (<>.some ..class))
          <code>.any)))

(type: .public (Method_Declaration a)
  (Record
   [#name Text
    #annotations (List (Annotation a))
    #type_variables (List (Type Var))
    #exceptions (List (Type Class))
    #arguments (List (Type Value))
    #return (Type Return)]))

(def: .public method_declaration
  (Parser (Method_Declaration Code))
  (<code>.form
   ($_ <>.and
       <code>.text
       (<code>.tuple (<>.some ..annotation))
       (<code>.tuple (<>.some ..var))
       (<code>.tuple (<>.some ..class))
       (<code>.tuple (<>.some ..type))
       ..return
       )))

(def: .public (analyse_virtual_method analyse archive selfT mapping method)
  (-> Phase Archive .Type Mapping (Virtual_Method Code) (Operation Analysis))
  (let [[method_name visibility
         final? strict_fp? annotations vars
         self_name arguments return exceptions
         body] method]
    (do [! phase.monad]
      [mapping (typeA.check (method_mapping mapping vars))
       annotationsA (monad.each ! (function (_ [name parameters])
                                    (do !
                                      [parametersA (monad.each ! (function (_ [name value])
                                                                   (do !
                                                                     [valueA (analyse archive value)]
                                                                     (in [name valueA])))
                                                               parameters)]
                                      (in [name parametersA])))
                                annotations)
       :return: (boxed_reflection_return mapping return)
       arguments' (monad.each !
                              (function (_ [name jvmT])
                                (do !
                                  [luxT (boxed_reflection_type mapping jvmT)]
                                  (in [name luxT])))
                              arguments)
       [scope bodyA] (|> arguments'
                         {.#Item [self_name selfT]}
                         list.reversed
                         (list#mix scope.with_local (analyse archive body))
                         (typeA.expecting :return:)
                         scope.with)]
      (in (/////analysis.tuple (list (/////analysis.text ..virtual_tag)
                                     (/////analysis.text method_name)
                                     (visibility_analysis visibility)
                                     (/////analysis.bit final?)
                                     (/////analysis.bit strict_fp?)
                                     (/////analysis.tuple (list#each annotation_analysis annotationsA))
                                     (/////analysis.tuple (list#each var_analysis vars))
                                     (/////analysis.text self_name)
                                     (/////analysis.tuple (list#each ..argument_analysis arguments))
                                     (return_analysis return)
                                     (/////analysis.tuple (list#each class_analysis exceptions))
                                     {/////analysis.#Function
                                      (list#each (|>> /////analysis.variable)
                                                 (scope.environment scope))
                                      (/////analysis.tuple (list bodyA))}
                                     ))))))

(type: .public (Static_Method a)
  [Text
   Visibility
   Strictness
   (List (Annotation a))
   (List (Type Var))
   (List Argument)
   (Type Return)
   (List Exception)
   a])

(def: .public static_tag "static")

(def: .public static_method_definition
  (Parser (Static_Method Code))
  (<| <code>.form
      (<>.after (<code>.this_text ..static_tag))
      ($_ <>.and
          <code>.text
          ..visibility
          <code>.bit
          (<code>.tuple (<>.some ..annotation))
          (<code>.tuple (<>.some ..var))
          (<code>.tuple (<>.some ..argument))
          ..return
          (<code>.tuple (<>.some ..class))
          <code>.any)))

(def: .public (analyse_static_method analyse archive mapping method)
  (-> Phase Archive Mapping (Static_Method Code) (Operation Analysis))
  (let [[method_name visibility
         strict_fp? annotations vars
         arguments return exceptions
         body] method]
    (do [! phase.monad]
      [mapping (typeA.check (method_mapping mapping vars))
       annotationsA (monad.each ! (function (_ [name parameters])
                                    (do !
                                      [parametersA (monad.each ! (function (_ [name value])
                                                                   (do !
                                                                     [valueA (analyse archive value)]
                                                                     (in [name valueA])))
                                                               parameters)]
                                      (in [name parametersA])))
                                annotations)
       :return: (boxed_reflection_return mapping return)
       arguments' (monad.each !
                              (function (_ [name jvmT])
                                (do !
                                  [luxT (boxed_reflection_type mapping jvmT)]
                                  (in [name luxT])))
                              arguments)
       [scope bodyA] (|> arguments'
                         list.reversed
                         (list#mix scope.with_local (analyse archive body))
                         (typeA.expecting :return:)
                         scope.with)]
      (in (/////analysis.tuple (list (/////analysis.text ..static_tag)
                                     (/////analysis.text method_name)
                                     (visibility_analysis visibility)
                                     (/////analysis.bit strict_fp?)
                                     (/////analysis.tuple (list#each annotation_analysis annotationsA))
                                     (/////analysis.tuple (list#each var_analysis vars))
                                     (/////analysis.tuple (list#each ..argument_analysis arguments))
                                     (return_analysis return)
                                     (/////analysis.tuple (list#each class_analysis
                                                                     exceptions))
                                     {/////analysis.#Function
                                      (list#each (|>> /////analysis.variable)
                                                 (scope.environment scope))
                                      (/////analysis.tuple (list bodyA))}
                                     ))))))

(type: .public (Overriden_Method a)
  [(Type Class)
   Text
   Bit
   (List (Annotation a))
   (List (Type Var))
   Text
   (List Argument)
   (Type Return)
   (List (Type Class))
   a])

(def: .public overriden_tag "override")

(def: .public overriden_method_definition
  (Parser (Overriden_Method Code))
  (<| <code>.form
      (<>.after (<code>.this_text ..overriden_tag))
      ($_ <>.and
          ..class
          <code>.text
          <code>.bit
          (<code>.tuple (<>.some ..annotation))
          (<code>.tuple (<>.some ..var))
          <code>.text
          (<code>.tuple (<>.some ..argument))
          ..return
          (<code>.tuple (<>.some ..class))
          <code>.any
          )))

(exception: .public (unknown_super [name Text
                                    supers (List (Type Class))])
  (exception.report
   "Name" (%.text name)
   "Available" (exception.listing (|>> parser.read_class product.left) supers)))

(exception: .public (mismatched_super_parameters [name Text
                                                  expected Nat
                                                  actual Nat])
  (exception.report
   "Name" (%.text name)
   "Expected" (%.nat expected)
   "Actual" (%.nat actual)))

(def: (override_mapping mapping supers parent_type)
  (-> Mapping (List (Type Class)) (Type Class) (Operation (List [Text .Type])))
  (let [[parent_name parent_parameters] (parser.read_class parent_type)]
    (case (list.one (function (_ super)
                      (let [[super_name super_parameters] (parser.read_class super)]
                        (if (text#= parent_name super_name)
                          {.#Some super_parameters}
                          {.#None})))
                    supers)
      {.#Some super_parameters}
      (let [expected_count (list.size parent_parameters)
            actual_count (list.size super_parameters)]
        (if (n.= expected_count actual_count)
          (do [! phase.monad]
            [parent_parameters (|> parent_parameters
                                   (monad.each maybe.monad parser.var?)
                                   try.of_maybe
                                   phase.lifted)]
            (|> super_parameters
                (monad.each ! (..reflection_type mapping))
                (# ! each (|>> (list.zipped_2 parent_parameters)))))
          (phase.lifted (exception.except ..mismatched_super_parameters [parent_name expected_count actual_count]))))
      
      {.#None}
      (phase.lifted (exception.except ..unknown_super [parent_name supers])))))

(def: .public (with_override_mapping supers parent_type mapping)
  (-> (List (Type Class)) (Type Class) Mapping (Operation Mapping))
  (do phase.monad
    [override_mapping (..override_mapping mapping supers parent_type)]
    (in (list#mix (function (_ [super_var bound_type] mapping)
                    (dictionary.has super_var bound_type mapping))
                  mapping
                  override_mapping))))

(def: .public (hidden_method_body arity bodyA)
  (-> Nat Analysis Analysis)
  (<| /////analysis.tuple
      (list (/////analysis.unit))
      (case arity
        (^.or 0 1)
        bodyA
        
        2
        (let [forced_refencing (/////analysis.tuple (list#each (|>> /////analysis.local) (list.indices (++ arity))))]
          {/////analysis.#Case (/////analysis.unit)
                               [[/////analysis.#when
                                 {pattern.#Bind 2}
                                 
                                 /////analysis.#then
                                 (/////analysis.tuple (list forced_refencing bodyA))]
                                (list)]})

        _
        (let [forced_refencing (/////analysis.tuple (list#each (|>> /////analysis.local) (list.indices (++ arity))))]
          {/////analysis.#Case (/////analysis.unit)
                               [[/////analysis.#when
                                 {pattern.#Complex
                                  {complex.#Tuple
                                   (|> (-- arity)
                                       list.indices
                                       (list#each (|>> (n.+ 2) {pattern.#Bind})))}}
                                 
                                 /////analysis.#then
                                 (/////analysis.tuple (list forced_refencing bodyA))]
                                (list)]}))))

(def: .public (analyse_overriden_method analyse archive selfT mapping supers method)
  (-> Phase Archive .Type Mapping (List (Type Class)) (Overriden_Method Code) (Operation Analysis))
  (let [[parent_type method_name
         strict_fp? annotations vars
         self_name arguments return exceptions
         body] method]
    (do [! phase.monad]
      [mapping (..with_override_mapping supers parent_type mapping)
       mapping (typeA.check (method_mapping mapping vars))
       annotationsA (monad.each ! (function (_ [name parameters])
                                    (do !
                                      [parametersA (monad.each ! (function (_ [name value])
                                                                   (do !
                                                                     [valueA (analyse archive value)]
                                                                     (in [name valueA])))
                                                               parameters)]
                                      (in [name parametersA])))
                                annotations)
       arguments' (monad.each !
                              (function (_ [name jvmT])
                                (do !
                                  [luxT (boxed_reflection_type mapping jvmT)]
                                  (in [name luxT])))
                              arguments)
       :return: (boxed_reflection_return mapping return)
       [scope bodyA] (|> arguments'
                         {.#Item [self_name selfT]}
                         list.reversed
                         (list#mix scope.with_local (analyse archive body))
                         (typeA.expecting :return:)
                         scope.with)]
      (in (/////analysis.tuple (list (/////analysis.text ..overriden_tag)
                                     (class_analysis parent_type)
                                     (/////analysis.text method_name)
                                     (/////analysis.bit strict_fp?)
                                     (/////analysis.tuple (list#each annotation_analysis annotationsA))
                                     (/////analysis.tuple (list#each var_analysis vars))
                                     (/////analysis.text self_name)
                                     (/////analysis.tuple (list#each ..argument_analysis arguments))
                                     (return_analysis return)
                                     (/////analysis.tuple (list#each class_analysis
                                                                     exceptions))
                                     {/////analysis.#Function
                                      (list#each (|>> /////analysis.variable)
                                                 (scope.environment scope))
                                      (..hidden_method_body (list.size arguments) bodyA)}
                                     ))))))

(def: (matched? [sub sub_method subJT] [super super_method superJT])
  (-> [(Type Class) Text (Type Method)] [(Type Class) Text (Type Method)] Bit)
  (and (# descriptor.equivalence = (jvm.descriptor super) (jvm.descriptor sub))
       (text#= super_method sub_method)
       (jvm#= superJT subJT)))

(def: (mismatched_methods super_set sub_set)
  (-> (List [(Type Class) Text (Type Method)])
      (List [(Type Class) Text (Type Method)])
      (List [(Type Class) Text (Type Method)]))
  (list.only (function (_ sub)
               (not (list.any? (matched? sub) super_set)))
             sub_set))

(exception: .public (class_parameter_mismatch [name Text
                                               declaration (Type Class)
                                               expected (List Text)
                                               actual (List (Type Parameter))])
  (exception.report
   "Class" (%.text name)
   "Declaration" (signature.signature (jvm.signature declaration))
   "Expected (amount)" (%.nat (list.size expected))
   "Expected (parameters)" (exception.listing %.text expected)
   "Actual (amount)" (%.nat (list.size actual))
   "Actual (parameters)" (exception.listing ..signature actual)))

(def: (super_aliasing class_loader class)
  (-> java/lang/ClassLoader (Type Class) (Operation Aliasing))
  (do phase.monad
    [.let [[name actual_parameters] (parser.read_class class)]
     jvm_class (phase.lifted (reflection!.load class_loader name))
     .let [expected_parameters (|> (java/lang/Class::getTypeParameters jvm_class)
                                   (array.list {.#None})
                                   (list#each (|>> java/lang/reflect/TypeVariable::getName)))]
     _ (phase.assertion ..class_parameter_mismatch [name class expected_parameters actual_parameters]
                        (n.= (list.size expected_parameters)
                             (list.size actual_parameters)))]
    (in (|> (list.zipped_2 expected_parameters actual_parameters)
            (list#mix (function (_ [expected actual] mapping)
                        (case (parser.var? actual)
                          {.#Some actual}
                          (dictionary.has actual expected mapping)
                          
                          {.#None}
                          mapping))
                      alias.fresh)))))

(def: (anonymous_class_name module id)
  (-> Module Nat Text)
  (let [global (text.replaced .module_separator ..jvm_package_separator module)
        local (format "anonymous-class" (%.nat id))]
    (format global ..jvm_package_separator local)))

(def: .public (require_complete_method_concretion class_loader supers methods)
  (-> java/lang/ClassLoader (List (Type Class)) (List (Overriden_Method Code)) (Operation Any))
  (do [! phase.monad]
    [required_abstract_methods (phase.lifted (all_abstract_methods class_loader supers))
     available_methods (phase.lifted (all_methods class_loader supers))
     overriden_methods (monad.each ! (function (_ [parent_type method_name
                                                   strict_fp? annotations type_vars
                                                   self_name arguments return exceptions
                                                   body])
                                       (do !
                                         [aliasing (super_aliasing class_loader parent_type)]
                                         (in (|> (jvm.method [type_vars
                                                              (list#each product.right arguments)
                                                              return
                                                              exceptions])
                                                 (alias.method aliasing)
                                                 [parent_type method_name]))))
                                   methods)
     .let [missing_abstract_methods (mismatched_methods overriden_methods required_abstract_methods)
           invalid_overriden_methods (mismatched_methods available_methods overriden_methods)]
     _ (phase.assertion ..missing_abstract_methods [required_abstract_methods overriden_methods]
                        (list.empty? missing_abstract_methods))
     _ (phase.assertion ..invalid_overriden_methods [available_methods invalid_overriden_methods]
                        (list.empty? invalid_overriden_methods))]
    (in [])))

(type: Declaration
  [Text (List (Type Var))])

(type: Constant
  [Text (List Annotation) (Type Value) Code])

(type: Variable
  [Text (Modifier field.Field) (Modifier field.Field) (List Annotation) (Type Value)])

(type: Field
  (Variant
   {#Constant Constant}
   {#Variable Variable}))

(type: (Method_Definition a)
  (Variant
   {#Constructor (..Constructor a)}
   {#Virtual_Method (..Virtual_Method a)}
   {#Static_Method (..Static_Method a)}
   {#Overriden_Method (..Overriden_Method a)}
   {#Abstract_Method (..Abstract_Method a)}))

(def: class_name
  (|>> parser.read_class product.left name.internal))

(def: (mock_class [name parameters] super interfaces fields methods modifier)
  (-> Declaration (Type Class) (List (Type Class))
      (List (Resource field.Field)) (List (Resource method.Method)) (Modifier class.Class)
      (Try [External Binary]))
  (let [signature (signature.inheritance (list#each jvm.signature parameters)
                                         (jvm.signature super)
                                         (list#each jvm.signature interfaces))]
    (try#each (|>> (format.result class.writer)
                   [name])
              (class.class version.v6_0
                           ($_ modifier#composite
                               class.public
                               modifier)
                           (name.internal name)
                           {.#Some signature}
                           (..class_name super)
                           (list#each ..class_name interfaces)
                           fields
                           methods
                           sequence.empty))))

(def: constant::modifier
  (Modifier field.Field)
  ($_ modifier#composite
      field.public
      field.static
      field.final
      ))

(def: (field_definition field)
  (-> Field (Resource field.Field))
  (case field
    ... TODO: Handle annotations.
    {#Constant [name annotations type value]}
    (case value
      (^.template [<tag> <type> <constant>]
        [[_ {<tag> value}]
         (do pool.monad
           [constant (`` (|> value (~~ (template.spliced <constant>))))
            attribute (attribute.constant constant)]
           (field.field ..constant::modifier name #1 <type> (sequence.sequence attribute)))])
      ([.#Bit jvm.boolean [(pipe.case #0 +0 #1 +1) .i64 i32.i32 constant.integer pool.integer]]
       [.#Int jvm.byte [.i64 i32.i32 constant.integer pool.integer]]
       [.#Int jvm.short [.i64 i32.i32 constant.integer pool.integer]]
       [.#Int jvm.int [.i64 i32.i32 constant.integer pool.integer]]
       [.#Int jvm.long [constant.long pool.long]]
       [.#Frac jvm.float [ffi.double_to_float constant.float pool.float]]
       [.#Frac jvm.double [constant.double pool.double]]
       [.#Nat jvm.char [.i64 i32.i32 constant.integer pool.integer]]
       [.#Text (jvm.class "java.lang.String" (list)) [pool.string]]
       )

      ... TODO: Tighten this pattern-matching so this catch-all clause isn't necessary.
      _
      (undefined))

    ... TODO: Handle annotations.
    {#Variable [name visibility state annotations type]}
    (field.field (modifier#composite visibility state)
                 name #1 type sequence.empty)))

(def: method_privacy
  (-> ffi.Privacy (Modifier method.Method))
  (|>> (pipe.case
         {ffi.#PublicP} method.public
         {ffi.#PrivateP} method.private
         {ffi.#ProtectedP} method.protected
         {ffi.#DefaultP} modifier.empty)))

(def: constructor_name
  "<init>")

(def: (mock_value valueT)
  (-> (Type Value) (Bytecode Any))
  (case (jvm.primitive? valueT)
    {.#Left classT}
    _.aconst_null
    
    {.#Right primitiveT}
    (cond (# jvm.equivalence = jvm.long primitiveT)
          _.lconst_0

          (# jvm.equivalence = jvm.float primitiveT)
          _.fconst_0

          (# jvm.equivalence = jvm.double primitiveT)
          _.dconst_0

          ... jvm.boolean jvm.byte jvm.short jvm.int jvm.char
          _.iconst_0)))

(def: (mock_return :return:)
  (-> (Type Return) (Bytecode Any))
  (case (jvm.void? :return:)
    {.#Right :return:}
    _.return

    {.#Left valueT}
    ($_ _.composite
        (mock_value valueT)
        (case (jvm.primitive? valueT)
          {.#Left classT}
          _.areturn
          
          {.#Right primitiveT}
          (cond (# jvm.equivalence = jvm.long primitiveT)
                _.lreturn

                (# jvm.equivalence = jvm.float primitiveT)
                _.freturn

                (# jvm.equivalence = jvm.double primitiveT)
                _.dreturn

                ... jvm.boolean jvm.byte jvm.short jvm.int jvm.char
                _.ireturn)))))

(def: (mock_method super method)
  (-> (Type Class) (Method_Definition Code) (Resource method.Method))
  (case method
    {#Constructor [privacy strict_floating_point? annotations variables exceptions
                   self arguments constructor_arguments
                   body]}
    (method.method ($_ modifier#composite
                       (..method_privacy privacy)
                       (if strict_floating_point?
                         method.strict
                         modifier.empty))
                   ..constructor_name
                   #0 (jvm.method [variables (list#each product.right arguments) jvm.void exceptions])
                   (list)
                   {.#Some ($_ _.composite
                               (_.aload 0)
                               (|> constructor_arguments
                                   (list#each (|>> product.left ..mock_value))
                                   (monad.all _.monad))
                               (|> (jvm.method [(list) (list#each product.left constructor_arguments) jvm.void (list)])
                                   (_.invokespecial super ..constructor_name))
                               _.return
                               )})

    {#Overriden_Method [super name strict_floating_point? annotations variables
                        self arguments return exceptions
                        body]}
    (method.method ($_ modifier#composite
                       method.public
                       (if strict_floating_point?
                         method.strict
                         modifier.empty))
                   name
                   #0 (jvm.method [variables (list#each product.right arguments) return exceptions])
                   (list)
                   {.#Some (..mock_return return)})

    {#Virtual_Method [name privacy final? strict_floating_point? annotations variables
                      self arguments return exceptions
                      body]}
    (method.method ($_ modifier#composite
                       (..method_privacy privacy)
                       (if strict_floating_point?
                         method.strict
                         modifier.empty)
                       (if final?
                         method.final
                         modifier.empty))
                   name
                   #0 (jvm.method [variables (list#each product.right arguments) return exceptions])
                   (list)
                   {.#Some (..mock_return return)})

    {#Static_Method [name privacy strict_floating_point? annotations
                     variables arguments return exceptions
                     body]}
    (method.method ($_ modifier#composite
                       method.static
                       (..method_privacy privacy)
                       (if strict_floating_point?
                         method.strict
                         modifier.empty))
                   name
                   #0 (jvm.method [variables (list#each product.right arguments) return exceptions])
                   (list)
                   {.#Some (..mock_return return)})

    {#Abstract_Method [name privacy annotations
                       variables arguments return exceptions]}
    (method.method ($_ modifier#composite
                       method.abstract
                       (..method_privacy privacy))
                   name
                   #0 (jvm.method [variables (list#each product.right arguments) return exceptions])
                   (list)
                   {.#None})
    ))

(def: (mock declaration super interfaces inheritance fields methods)
  (-> Declaration
      (Type Class) (List (Type Class))
      (Modifier class.Class) (List ..Field) (List (Method_Definition Code))
      (Try [External Binary]))
  (mock_class declaration super interfaces
              (list#each ..field_definition fields)
              (list#each (..mock_method super) methods)
              inheritance))

(def: (class::anonymous class_loader host)
  (-> java/lang/ClassLoader runtime.Host Handler)
  (..custom
   [($_ <>.and
        (<code>.tuple (<>.some ..var))
        ..class
        (<code>.tuple (<>.some ..class))
        (<code>.tuple (<>.some ..input))
        (<code>.tuple (<>.some ..overriden_method_definition)))
    (function (_ extension_name analyse archive [parameters
                                                 super_class
                                                 super_interfaces
                                                 constructor_args
                                                 methods])
      (do [! phase.monad]
        [_ (..ensure_fresh_class! class_loader (..reflection super_class))
         _ (monad.each ! (|>> ..reflection (..ensure_fresh_class! class_loader)) super_interfaces)

         self_name (///.lifted (do meta.monad
                                 [where meta.current_module_name
                                  id meta.seed]
                                 (in (..anonymous_class_name where id))))
         .let [selfT {.#Primitive self_name (list)}]
         mock (<| phase.lifted
                  (..mock [self_name parameters]
                          super_class
                          super_interfaces
                          class.final
                          (list)
                          (list#each (|>> {#Overriden_Method}) methods)))
         ... Necessary for reflection to work properly during analysis.
         _ (phase.lifted (# host execute mock))

         mapping (typeA.check (..class_mapping parameters))
         super_classT (typeA.check (luxT.check (luxT.class mapping) (..signature super_class)))
         super_interfaceT+ (typeA.check (monad.each check.monad
                                                    (|>> ..signature (luxT.check (luxT.class mapping)))
                                                    super_interfaces))
         _ (typeA.inference selfT)
         constructor_argsA+ (monad.each ! (function (_ [type term])
                                            (do !
                                              [argT (reflection_type mapping type)
                                               termA (<| (typeA.expecting argT)
                                                         (analyse archive term))]
                                              (in [type termA])))
                                        constructor_args)
         .let [supers {.#Item super_class super_interfaces}]
         _ (..require_complete_method_concretion class_loader supers methods)
         methodsA (monad.each ! (analyse_overriden_method analyse archive selfT mapping supers) methods)]
        (in {/////analysis.#Extension extension_name
                                      (list (class_analysis super_class)
                                            (/////analysis.tuple (list#each class_analysis super_interfaces))
                                            (/////analysis.tuple (list#each typed_analysis constructor_argsA+))
                                            (/////analysis.tuple methodsA))})))]))

(def: (bundle::class class_loader host)
  (-> java/lang/ClassLoader runtime.Host Bundle)
  (<| (///bundle.prefix "class")
      (|> ///bundle.empty
          (///bundle.install "anonymous" (class::anonymous class_loader host))
          )))

(def: .public (bundle class_loader host)
  (-> java/lang/ClassLoader runtime.Host Bundle)
  (<| (///bundle.prefix "jvm")
      (|> ///bundle.empty
          (dictionary.merged bundle::conversion)
          (dictionary.merged bundle::int)
          (dictionary.merged bundle::long)
          (dictionary.merged bundle::float)
          (dictionary.merged bundle::double)
          (dictionary.merged bundle::char)
          (dictionary.merged bundle::array)
          (dictionary.merged (bundle::object class_loader))
          (dictionary.merged (bundle::member class_loader))
          (dictionary.merged (bundle::class class_loader host))
          )))
