(.module:
  [library
   [lux (#- Type Module primitive type char int)
    ["." ffi (#+ import:)]
    ["." meta]
    [abstract
     ["." monad (#+ do)]]
    [control
     pipe
     ["." try (#+ Try) ("#\." monad)]
     ["." exception (#+ exception:)]
     ["<>" parser
      ["<.>" code (#+ Parser)]
      ["<.>" text]]]
    [data
     ["." maybe]
     ["." product]
     ["." text ("#\." equivalence)
      ["%" format (#+ format)]]
     [collection
      ["." list ("#\." fold monad monoid)]
      ["." array]
      ["." dictionary (#+ Dictionary)]]]
    [math
     [number
      ["n" nat]]]
    [target
     ["." jvm #_
      [".!" reflection]
      [encoding
       [name (#+ External)]]
      ["#" type (#+ Type Argument Typed) ("#\." equivalence)
       ["." category (#+ Void Value' Value Return' Return Primitive Object Class Array Var Parameter Method)]
       ["." box]
       ["." reflection]
       ["." descriptor]
       ["." signature]
       ["#_." parser]
       ["#_." alias (#+ Aliasing)]
       [".T" lux (#+ Mapping)]]]]
    ["." type
     ["." check (#+ Check) ("#\." monad)]]]]
  ["." // #_
   ["#." lux (#+ custom)]
   ["/#" //
    ["#." bundle]
    ["/#" // #_
     [analysis
      [".A" type]
      [".A" inference]
      ["." scope]]
     ["/#" // #_
      ["#." analysis (#+ Analysis Operation Phase Handler Bundle)]
      ["#." synthesis]
      [///
       ["." phase ("#\." monad)]
       [meta
        [archive (#+ Archive)
         [descriptor (#+ Module)]]]]]]]])

(import: java/lang/ClassLoader)

(import: java/lang/Object
  ["#::."
   (equals [java/lang/Object] boolean)])

(import: java/lang/reflect/Type)

(import: (java/lang/reflect/TypeVariable d)
  ["#::."
   (getName [] java/lang/String)
   (getBounds [] [java/lang/reflect/Type])])

(import: java/lang/reflect/Modifier
  ["#::."
   (#static isStatic [int] boolean)
   (#static isFinal [int] boolean)
   (#static isInterface [int] boolean)
   (#static isAbstract [int] boolean)])

(import: java/lang/annotation/Annotation)

(import: java/lang/reflect/Method
  ["#::."
   (getName [] java/lang/String)
   (getModifiers [] int)
   (getDeclaringClass [] (java/lang/Class java/lang/Object))
   (getTypeParameters [] [(java/lang/reflect/TypeVariable java/lang/reflect/Method)])
   (getGenericParameterTypes [] [java/lang/reflect/Type])
   (getGenericReturnType [] java/lang/reflect/Type)
   (getGenericExceptionTypes [] [java/lang/reflect/Type])
   (getDeclaredAnnotations [] [java/lang/annotation/Annotation])])

(import: (java/lang/reflect/Constructor c)
  ["#::."
   (getModifiers [] int)
   (getDeclaringClass [] (java/lang/Class c))
   (getTypeParameters [] [(java/lang/reflect/TypeVariable (java/lang/reflect/Constructor c))])
   (getGenericParameterTypes [] [java/lang/reflect/Type])
   (getGenericExceptionTypes [] [java/lang/reflect/Type])
   (getDeclaredAnnotations [] [java/lang/annotation/Annotation])])

(import: (java/lang/Class c)
  ["#::."
   (#static forName [java/lang/String] #try (java/lang/Class java/lang/Object))
   (getName [] java/lang/String)
   (getModifiers [] int)
   (isAssignableFrom [(java/lang/Class java/lang/Object)] boolean)
   (getTypeParameters [] [(java/lang/reflect/TypeVariable (java/lang/Class c))])
   (getGenericInterfaces [] [java/lang/reflect/Type])
   (getGenericSuperclass [] #? java/lang/reflect/Type)
   (getDeclaredField [java/lang/String] #try java/lang/reflect/Field)
   (getConstructors [] [(java/lang/reflect/Constructor java/lang/Object)])
   (getDeclaredMethods [] [java/lang/reflect/Method])
   (getDeclaredAnnotations [] [java/lang/annotation/Annotation])])

(template [<name>]
  [(exception: #export (<name> {class External} {field Text})
     (exception.report
      ["Class" (%.text class)]
      ["Field" (%.text field)]))]

  [cannot_set_a_final_field]
  [deprecated_field]
  )

(exception: #export (deprecated_method {class External} {method Text} {type .Type})
  (exception.report
   ["Class" (%.text class)]
   ["Method" (%.text method)]
   ["Type" (%.type type)]))

(exception: #export (deprecated_class {class External})
  (exception.report
   ["Class" (%.text class)]))

(def: (ensure_fresh_class! class_loader name)
  (-> java/lang/ClassLoader External (Operation Any))
  (do phase.monad
    [class (phase.lift (reflection!.load class_loader name))]
    (phase.assert ..deprecated_class [name]
                  (|> class
                      java/lang/Class::getDeclaredAnnotations
                      reflection!.deprecated?
                      not))))

(def: reflection
  (All [category]
    (-> (Type (<| Return' Value' category)) Text))
  (|>> jvm.reflection reflection.reflection))

(def: signature (|>> jvm.signature signature.signature))

(def: object_class
  External
  "java.lang.Object")

(def: inheritance_relationship_type_name "_jvm_inheritance")
(def: #export (inheritance_relationship_type class super_class super_interfaces)
  (-> .Type .Type (List .Type) .Type)
  (#.Primitive ..inheritance_relationship_type_name
               (list& class super_class super_interfaces)))

## TODO: Get rid of this template block and use the definition in
## lux/ffi.jvm.lux ASAP
(template [<name> <class>]
  [(def: #export <name> .Type (#.Primitive <class> #.Nil))]

  ## Boxes
  [Boolean   box.boolean]
  [Byte      box.byte]
  [Short     box.short]
  [Integer   box.int]
  [Long      box.long]
  [Float     box.float]
  [Double    box.double]
  [Character box.char]
  [String    "java.lang.String"]

  ## Primitives
  [boolean   (reflection.reflection reflection.boolean)]
  [byte      (reflection.reflection reflection.byte)]
  [short     (reflection.reflection reflection.short)]
  [int       (reflection.reflection reflection.int)]
  [long      (reflection.reflection reflection.long)]
  [float     (reflection.reflection reflection.float)]
  [double    (reflection.reflection reflection.double)]
  [char      (reflection.reflection reflection.char)]
  )

(type: Member
  {#class External
   #member Text})

(def: member
  (Parser Member)
  ($_ <>.and <code>.text <code>.text))

(type: Method_Signature
  {#method .Type
   #deprecated? Bit
   #exceptions (List .Type)})

(template [<name>]
  [(exception: #export (<name> {type .Type})
     (exception.report
      ["Type" (%.type type)]))]

  [non_object]
  [non_array]
  [non_parameter]
  [non_jvm_type]
  )

(template [<name>]
  [(exception: #export (<name> {class External})
     (exception.report
      ["Class/type" (%.text class)]))]

  [non_interface]
  [non_throwable]
  [primitives_are_not_objects]
  )

(template [<name>]
  [(exception: #export (<name> {class External}
                               {method Text}
                               {inputsJT (List (Type Value))}
                               {hints (List Method_Signature)})
     (exception.report
      ["Class" class]
      ["Method" method]
      ["Arguments" (exception.enumerate ..signature inputsJT)]
      ["Hints" (exception.enumerate %.type (list\map product.left hints))]))]

  [no_candidates]
  [too_many_candidates]
  )

(exception: #export (cannot_cast {from .Type} {to .Type} {value Code})
  (exception.report
   ["From" (%.type from)]
   ["To" (%.type to)]
   ["Value" (%.code value)]))

(template [<name>]
  [(exception: #export (<name> {message Text})
     message)]

  [primitives_cannot_have_type_parameters]

  [cannot_possibly_be_an_instance]

  [unknown_type_var]
  )

(def: bundle::conversion
  Bundle
  (<| (///bundle.prefix "conversion")
      (|> ///bundle.empty
          (///bundle.install "double-to-float" (//lux.unary ..double ..float))
          (///bundle.install "double-to-int" (//lux.unary ..double ..int))
          (///bundle.install "double-to-long" (//lux.unary ..double ..long))
          (///bundle.install "float-to-double" (//lux.unary ..float ..double))
          (///bundle.install "float-to-int" (//lux.unary ..float ..int))
          (///bundle.install "float-to-long" (//lux.unary ..float ..long))
          (///bundle.install "int-to-byte" (//lux.unary ..int ..byte))
          (///bundle.install "int-to-char" (//lux.unary ..int ..char))
          (///bundle.install "int-to-double" (//lux.unary ..int ..double))
          (///bundle.install "int-to-float" (//lux.unary ..int ..float))
          (///bundle.install "int-to-long" (//lux.unary ..int ..long))
          (///bundle.install "int-to-short" (//lux.unary ..int ..short))
          (///bundle.install "long-to-double" (//lux.unary ..long ..double))
          (///bundle.install "long-to-float" (//lux.unary ..long ..float))
          (///bundle.install "long-to-int" (//lux.unary ..long ..int))
          (///bundle.install "long-to-short" (//lux.unary ..long ..short))
          (///bundle.install "long-to-byte" (//lux.unary ..long ..byte))
          (///bundle.install "char-to-byte" (//lux.unary ..char ..byte))
          (///bundle.install "char-to-short" (//lux.unary ..char ..short))
          (///bundle.install "char-to-int" (//lux.unary ..char ..int))
          (///bundle.install "char-to-long" (//lux.unary ..char ..long))
          (///bundle.install "byte-to-long" (//lux.unary ..byte ..long))
          (///bundle.install "short-to-long" (//lux.unary ..short ..long))
          )))

(template [<name> <prefix> <type>]
  [(def: <name>
     Bundle
     (<| (///bundle.prefix (reflection.reflection <prefix>))
         (|> ///bundle.empty
             (///bundle.install "+" (//lux.binary <type> <type> <type>))
             (///bundle.install "-" (//lux.binary <type> <type> <type>))
             (///bundle.install "*" (//lux.binary <type> <type> <type>))
             (///bundle.install "/" (//lux.binary <type> <type> <type>))
             (///bundle.install "%" (//lux.binary <type> <type> <type>))
             (///bundle.install "=" (//lux.binary <type> <type> Bit))
             (///bundle.install "<" (//lux.binary <type> <type> Bit))
             (///bundle.install "and" (//lux.binary <type> <type> <type>))
             (///bundle.install "or" (//lux.binary <type> <type> <type>))
             (///bundle.install "xor" (//lux.binary <type> <type> <type>))
             (///bundle.install "shl" (//lux.binary ..int <type> <type>))
             (///bundle.install "shr" (//lux.binary ..int <type> <type>))
             (///bundle.install "ushr" (//lux.binary ..int <type> <type>))
             )))]

  [bundle::int  reflection.int  ..int]
  [bundle::long reflection.long ..long]
  )

(template [<name> <prefix> <type>]
  [(def: <name>
     Bundle
     (<| (///bundle.prefix (reflection.reflection <prefix>))
         (|> ///bundle.empty
             (///bundle.install "+" (//lux.binary <type> <type> <type>))
             (///bundle.install "-" (//lux.binary <type> <type> <type>))
             (///bundle.install "*" (//lux.binary <type> <type> <type>))
             (///bundle.install "/" (//lux.binary <type> <type> <type>))
             (///bundle.install "%" (//lux.binary <type> <type> <type>))
             (///bundle.install "=" (//lux.binary <type> <type> Bit))
             (///bundle.install "<" (//lux.binary <type> <type> Bit))
             )))]

  [bundle::float  reflection.float  ..float]
  [bundle::double reflection.double ..double]
  )

(def: bundle::char
  Bundle
  (<| (///bundle.prefix (reflection.reflection reflection.char))
      (|> ///bundle.empty
          (///bundle.install "=" (//lux.binary ..char ..char Bit))
          (///bundle.install "<" (//lux.binary ..char ..char Bit))
          )))

(def: #export boxes
  (Dictionary External [External (Type Primitive)])
  (|> (list [(reflection.reflection reflection.boolean) [box.boolean jvm.boolean]]
            [(reflection.reflection reflection.byte)    [box.byte jvm.byte]]
            [(reflection.reflection reflection.short)   [box.short jvm.short]]
            [(reflection.reflection reflection.int)     [box.int jvm.int]]
            [(reflection.reflection reflection.long)    [box.long jvm.long]]
            [(reflection.reflection reflection.float)   [box.float jvm.float]]
            [(reflection.reflection reflection.double)  [box.double jvm.double]]
            [(reflection.reflection reflection.char)    [box.char jvm.char]])
      (dictionary.from_list text.hash)))

(def: (jvm_type luxT)
  (-> .Type (Operation (Type Value)))
  (case luxT
    (#.Named name anonymousT)
    (jvm_type anonymousT)
    
    (#.Apply inputT abstractionT)
    (case (type.apply (list inputT) abstractionT)
      (#.Some outputT)
      (jvm_type outputT)

      #.None
      (/////analysis.throw ..non_jvm_type luxT))

    (^ (#.Primitive (static array.type_name) (list elemT)))
    (phase\map jvm.array (jvm_type elemT))

    (#.Primitive class parametersT)
    (case (dictionary.get class ..boxes)
      (#.Some [_ primitive_type])
      (case parametersT
        #.Nil
        (phase\wrap primitive_type)

        _
        (/////analysis.throw ..primitives_cannot_have_type_parameters class))

      #.None
      (do {! phase.monad}
        [parametersJT (: (Operation (List (Type Parameter)))
                         (monad.map !
                                    (function (_ parameterT)
                                      (do phase.monad
                                        [parameterJT (jvm_type parameterT)]
                                        (case (jvm_parser.parameter? parameterJT)
                                          (#.Some parameterJT)
                                          (wrap parameterJT)
                                          
                                          #.None
                                          (/////analysis.throw ..non_parameter parameterT))))
                                    parametersT))]
        (wrap (jvm.class class parametersJT))))

    (#.Ex _)
    (phase\wrap (jvm.class ..object_class (list)))
    
    _
    (/////analysis.throw ..non_jvm_type luxT)))

(def: (jvm_array_type objectT)
  (-> .Type (Operation (Type Array)))
  (do phase.monad
    [objectJ (jvm_type objectT)]
    (|> objectJ
        ..signature
        (<text>.run jvm_parser.array)
        phase.lift)))

(def: (primitive_array_length_handler primitive_type)
  (-> (Type Primitive) Handler)
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list arrayC))
      (do phase.monad
        [_ (typeA.infer ..int)
         arrayA (typeA.with_type (#.Primitive (|> (jvm.array primitive_type)
                                                  ..reflection)
                                              (list))
                  (analyse archive arrayC))]
        (wrap (#/////analysis.Extension extension_name (list arrayA))))

      _
      (/////analysis.throw ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: array::length::object
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list arrayC))
      (do phase.monad
        [_ (typeA.infer ..int)
         [var_id varT] (typeA.with_env check.var)
         arrayA (typeA.with_type (.type (array.Array varT))
                  (analyse archive arrayC))
         varT (typeA.with_env (check.clean varT))
         arrayJT (jvm_array_type (.type (array.Array varT)))]
        (wrap (#/////analysis.Extension extension_name (list (/////analysis.text (..signature arrayJT))
                                                             arrayA))))

      _
      (/////analysis.throw ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: (new_primitive_array_handler primitive_type)
  (-> (Type Primitive) Handler)
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list lengthC))
      (do phase.monad
        [lengthA (typeA.with_type ..int
                   (analyse archive lengthC))
         _ (typeA.infer (#.Primitive (|> (jvm.array primitive_type) ..reflection)
                                     (list)))]
        (wrap (#/////analysis.Extension extension_name (list lengthA))))

      _
      (/////analysis.throw ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: array::new::object
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list lengthC))
      (do phase.monad
        [lengthA (typeA.with_type ..int
                   (analyse archive lengthC))
         expectedT (///.lift meta.expected_type)
         expectedJT (jvm_array_type expectedT)
         elementJT (case (jvm_parser.array? expectedJT)
                     (#.Some elementJT)
                     (wrap elementJT)
                     
                     #.None
                     (/////analysis.throw ..non_array expectedT))]
        (wrap (#/////analysis.Extension extension_name (list (/////analysis.text (..signature elementJT))
                                                             lengthA))))

      _
      (/////analysis.throw ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: (check_parameter objectT)
  (-> .Type (Operation (Type Parameter)))
  (case objectT
    (^ (#.Primitive (static array.type_name)
                    (list elementT)))
    (/////analysis.throw ..non_parameter objectT)
    
    (#.Primitive name parameters)
    (`` (cond (or (~~ (template [<type>]
                        [(text\= (..reflection <type>) name)]

                        [jvm.boolean]
                        [jvm.byte]
                        [jvm.short]
                        [jvm.int]
                        [jvm.long]
                        [jvm.float]
                        [jvm.double]
                        [jvm.char]))
                  (text.starts_with? descriptor.array_prefix name))
              (/////analysis.throw ..non_parameter objectT)

              ## else
              (phase\wrap (jvm.class name (list)))))

    (#.Named name anonymous)
    (check_parameter anonymous)

    (^template [<tag>]
      [(<tag> id)
       (phase\wrap (jvm.class ..object_class (list)))])
    ([#.Var]
     [#.Ex])

    (^template [<tag>]
      [(<tag> env unquantified)
       (check_parameter unquantified)])
    ([#.UnivQ]
     [#.ExQ])

    (#.Apply inputT abstractionT)
    (case (type.apply (list inputT) abstractionT)
      (#.Some outputT)
      (check_parameter outputT)

      #.None
      (/////analysis.throw ..non_parameter objectT))

    _
    (/////analysis.throw ..non_parameter objectT)))

(def: (check_jvm objectT)
  (-> .Type (Operation (Type Value)))
  (case objectT
    (#.Primitive name #.Nil)
    (`` (cond (~~ (template [<type>]
                    [(text\= (..reflection <type>) name)
                     (phase\wrap <type>)]

                    [jvm.boolean]
                    [jvm.byte]
                    [jvm.short]
                    [jvm.int]
                    [jvm.long]
                    [jvm.float]
                    [jvm.double]
                    [jvm.char]))

              (~~ (template [<type>]
                    [(text\= (..reflection (jvm.array <type>)) name)
                     (phase\wrap (jvm.array <type>))]

                    [jvm.boolean]
                    [jvm.byte]
                    [jvm.short]
                    [jvm.int]
                    [jvm.long]
                    [jvm.float]
                    [jvm.double]
                    [jvm.char]))

              (text.starts_with? descriptor.array_prefix name)
              (let [[_ unprefixed] (maybe.assume (text.split_with descriptor.array_prefix name))]
                (\ phase.monad map jvm.array
                   (check_jvm (#.Primitive unprefixed (list)))))

              ## else
              (phase\wrap (jvm.class name (list)))))
    
    (^ (#.Primitive (static array.type_name)
                    (list elementT)))
    (|> elementT
        check_jvm
        (phase\map jvm.array))
    
    (#.Primitive name parameters)
    (do {! phase.monad}
      [parameters (monad.map ! check_parameter parameters)]
      (phase\wrap (jvm.class name parameters)))

    (#.Named name anonymous)
    (check_jvm anonymous)

    (^template [<tag>]
      [(<tag> env unquantified)
       (check_jvm unquantified)])
    ([#.UnivQ]
     [#.ExQ])

    (#.Apply inputT abstractionT)
    (case (type.apply (list inputT) abstractionT)
      (#.Some outputT)
      (check_jvm outputT)

      #.None
      (/////analysis.throw ..non_object objectT))

    _
    (check_parameter objectT)))

(def: (check_object objectT)
  (-> .Type (Operation External))
  (do {! phase.monad}
    [name (\ ! map ..reflection (check_jvm objectT))]
    (if (dictionary.key? ..boxes name)
      (/////analysis.throw ..primitives_are_not_objects [name])
      (phase\wrap name))))

(def: (check_return type)
  (-> .Type (Operation (Type Return)))
  (if (is? .Any type)
    (phase\wrap jvm.void)
    (check_jvm type)))

(def: (read_primitive_array_handler lux_type jvm_type)
  (-> .Type (Type Primitive) Handler)
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list idxC arrayC))
      (do phase.monad
        [_ (typeA.infer lux_type)
         idxA (typeA.with_type ..int
                (analyse archive idxC))
         arrayA (typeA.with_type (#.Primitive (|> (jvm.array jvm_type) ..reflection)
                                              (list))
                  (analyse archive arrayC))]
        (wrap (#/////analysis.Extension extension_name (list idxA arrayA))))

      _
      (/////analysis.throw ///.incorrect_arity [extension_name 2 (list.size args)]))))

(def: array::read::object
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list idxC arrayC))
      (do phase.monad
        [[var_id varT] (typeA.with_env check.var)
         _ (typeA.infer varT)
         arrayA (typeA.with_type (.type (array.Array varT))
                  (analyse archive arrayC))
         varT (typeA.with_env
                (check.clean varT))
         arrayJT (jvm_array_type (.type (array.Array varT)))
         idxA (typeA.with_type ..int
                (analyse archive idxC))]
        (wrap (#/////analysis.Extension extension_name (list (/////analysis.text (..signature arrayJT))
                                                             idxA
                                                             arrayA))))

      _
      (/////analysis.throw ///.incorrect_arity [extension_name 2 (list.size args)]))))

(def: (write_primitive_array_handler lux_type jvm_type)
  (-> .Type (Type Primitive) Handler)
  (let [array_type (#.Primitive (|> (jvm.array jvm_type) ..reflection)
                                (list))]
    (function (_ extension_name analyse archive args)
      (case args
        (^ (list idxC valueC arrayC))
        (do phase.monad
          [_ (typeA.infer array_type)
           idxA (typeA.with_type ..int
                  (analyse archive idxC))
           valueA (typeA.with_type lux_type
                    (analyse archive valueC))
           arrayA (typeA.with_type array_type
                    (analyse archive arrayC))]
          (wrap (#/////analysis.Extension extension_name (list idxA
                                                               valueA
                                                               arrayA))))

        _
        (/////analysis.throw ///.incorrect_arity [extension_name 3 (list.size args)])))))

(def: array::write::object
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list idxC valueC arrayC))
      (do phase.monad
        [[var_id varT] (typeA.with_env check.var)
         _ (typeA.infer (.type (array.Array varT)))
         arrayA (typeA.with_type (.type (array.Array varT))
                  (analyse archive arrayC))
         varT (typeA.with_env
                (check.clean varT))
         arrayJT (jvm_array_type (.type (array.Array varT)))
         idxA (typeA.with_type ..int
                (analyse archive idxC))
         valueA (typeA.with_type varT
                  (analyse archive valueC))]
        (wrap (#/////analysis.Extension extension_name (list (/////analysis.text (..signature arrayJT))
                                                             idxA
                                                             valueA
                                                             arrayA))))

      _
      (/////analysis.throw ///.incorrect_arity [extension_name 3 (list.size args)]))))

(def: bundle::array
  Bundle
  (<| (///bundle.prefix "array")
      (|> ///bundle.empty
          (dictionary.merge (<| (///bundle.prefix "length")
                                (|> ///bundle.empty
                                    (///bundle.install (reflection.reflection reflection.boolean) (primitive_array_length_handler jvm.boolean))
                                    (///bundle.install (reflection.reflection reflection.byte) (primitive_array_length_handler jvm.byte))
                                    (///bundle.install (reflection.reflection reflection.short) (primitive_array_length_handler jvm.short))
                                    (///bundle.install (reflection.reflection reflection.int) (primitive_array_length_handler jvm.int))
                                    (///bundle.install (reflection.reflection reflection.long) (primitive_array_length_handler jvm.long))
                                    (///bundle.install (reflection.reflection reflection.float) (primitive_array_length_handler jvm.float))
                                    (///bundle.install (reflection.reflection reflection.double) (primitive_array_length_handler jvm.double))
                                    (///bundle.install (reflection.reflection reflection.char) (primitive_array_length_handler jvm.char))
                                    (///bundle.install "object" array::length::object))))
          (dictionary.merge (<| (///bundle.prefix "new")
                                (|> ///bundle.empty
                                    (///bundle.install (reflection.reflection reflection.boolean) (new_primitive_array_handler jvm.boolean))
                                    (///bundle.install (reflection.reflection reflection.byte) (new_primitive_array_handler jvm.byte))
                                    (///bundle.install (reflection.reflection reflection.short) (new_primitive_array_handler jvm.short))
                                    (///bundle.install (reflection.reflection reflection.int) (new_primitive_array_handler jvm.int))
                                    (///bundle.install (reflection.reflection reflection.long) (new_primitive_array_handler jvm.long))
                                    (///bundle.install (reflection.reflection reflection.float) (new_primitive_array_handler jvm.float))
                                    (///bundle.install (reflection.reflection reflection.double) (new_primitive_array_handler jvm.double))
                                    (///bundle.install (reflection.reflection reflection.char) (new_primitive_array_handler jvm.char))
                                    (///bundle.install "object" array::new::object))))
          (dictionary.merge (<| (///bundle.prefix "read")
                                (|> ///bundle.empty
                                    (///bundle.install (reflection.reflection reflection.boolean) (read_primitive_array_handler ..boolean jvm.boolean))
                                    (///bundle.install (reflection.reflection reflection.byte) (read_primitive_array_handler ..byte jvm.byte))
                                    (///bundle.install (reflection.reflection reflection.short) (read_primitive_array_handler ..short jvm.short))
                                    (///bundle.install (reflection.reflection reflection.int) (read_primitive_array_handler ..int jvm.int))
                                    (///bundle.install (reflection.reflection reflection.long) (read_primitive_array_handler ..long jvm.long))
                                    (///bundle.install (reflection.reflection reflection.float) (read_primitive_array_handler ..float jvm.float))
                                    (///bundle.install (reflection.reflection reflection.double) (read_primitive_array_handler ..double jvm.double))
                                    (///bundle.install (reflection.reflection reflection.char) (read_primitive_array_handler ..char jvm.char))
                                    (///bundle.install "object" array::read::object))))
          (dictionary.merge (<| (///bundle.prefix "write")
                                (|> ///bundle.empty
                                    (///bundle.install (reflection.reflection reflection.boolean) (write_primitive_array_handler ..boolean jvm.boolean))
                                    (///bundle.install (reflection.reflection reflection.byte) (write_primitive_array_handler ..byte jvm.byte))
                                    (///bundle.install (reflection.reflection reflection.short) (write_primitive_array_handler ..short jvm.short))
                                    (///bundle.install (reflection.reflection reflection.int) (write_primitive_array_handler ..int jvm.int))
                                    (///bundle.install (reflection.reflection reflection.long) (write_primitive_array_handler ..long jvm.long))
                                    (///bundle.install (reflection.reflection reflection.float) (write_primitive_array_handler ..float jvm.float))
                                    (///bundle.install (reflection.reflection reflection.double) (write_primitive_array_handler ..double jvm.double))
                                    (///bundle.install (reflection.reflection reflection.char) (write_primitive_array_handler ..char jvm.char))
                                    (///bundle.install "object" array::write::object))))
          )))

(def: object::null
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list))
      (do phase.monad
        [expectedT (///.lift meta.expected_type)
         _ (check_object expectedT)]
        (wrap (#/////analysis.Extension extension_name (list))))

      _
      (/////analysis.throw ///.incorrect_arity [extension_name 0 (list.size args)]))))

(def: object::null?
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list objectC))
      (do phase.monad
        [_ (typeA.infer Bit)
         [objectT objectA] (typeA.with_inference
                             (analyse archive objectC))
         _ (check_object objectT)]
        (wrap (#/////analysis.Extension extension_name (list objectA))))

      _
      (/////analysis.throw ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: object::synchronized
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list monitorC exprC))
      (do phase.monad
        [[monitorT monitorA] (typeA.with_inference
                               (analyse archive monitorC))
         _ (check_object monitorT)
         exprA (analyse archive exprC)]
        (wrap (#/////analysis.Extension extension_name (list monitorA exprA))))

      _
      (/////analysis.throw ///.incorrect_arity [extension_name 2 (list.size args)]))))

(def: (object::throw class_loader)
  (-> java/lang/ClassLoader Handler)
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list exceptionC))
      (do phase.monad
        [_ (typeA.infer Nothing)
         [exceptionT exceptionA] (typeA.with_inference
                                   (analyse archive exceptionC))
         exception_class (check_object exceptionT)
         ? (phase.lift (reflection!.sub? class_loader "java.lang.Throwable" exception_class))
         _ (: (Operation Any)
              (if ?
                (wrap [])
                (/////analysis.throw non_throwable exception_class)))]
        (wrap (#/////analysis.Extension extension_name (list exceptionA))))

      _
      (/////analysis.throw ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: (object::class class_loader)
  (-> java/lang/ClassLoader Handler)
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list classC))
      (case classC
        [_ (#.Text class)]
        (do phase.monad
          [_ (..ensure_fresh_class! class_loader class)
           _ (typeA.infer (#.Primitive "java.lang.Class" (list (#.Primitive class (list)))))
           _ (phase.lift (reflection!.load class_loader class))]
          (wrap (#/////analysis.Extension extension_name (list (/////analysis.text class)))))

        _
        (/////analysis.throw ///.invalid_syntax [extension_name %.code args]))

      _
      (/////analysis.throw ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: (object::instance? class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and <code>.text <code>.any)
    (function (_ extension_name analyse archive [sub_class objectC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader sub_class)
         _ (typeA.infer Bit)
         [objectT objectA] (typeA.with_inference
                             (analyse archive objectC))
         object_class (check_object objectT)
         ? (phase.lift (reflection!.sub? class_loader object_class sub_class))]
        (if ?
          (wrap (#/////analysis.Extension extension_name (list (/////analysis.text sub_class) objectA)))
          (/////analysis.throw cannot_possibly_be_an_instance (format sub_class " !<= "  object_class)))))]))

(template [<name> <category> <parser>]
  [(def: (<name> mapping typeJ)
     (-> Mapping (Type <category>) (Operation .Type))
     (case (|> typeJ ..signature (<text>.run (<parser> mapping)))
       (#try.Success check)
       (typeA.with_env
         check)
       
       (#try.Failure error)
       (phase.fail error)))]

  [reflection_type Value luxT.type]
  [reflection_return Return luxT.return]
  )

(def: (class_candidate_parents class_loader from_name fromT to_name to_class)
  (-> java/lang/ClassLoader External .Type External (java/lang/Class java/lang/Object) (Operation (List [[Text .Type] Bit])))
  (do {! phase.monad}
    [from_class (phase.lift (reflection!.load class_loader from_name))
     mapping (phase.lift (reflection!.correspond from_class fromT))]
    (monad.map !
               (function (_ superJT)
                 (do !
                   [superJT (phase.lift (reflection!.type superJT))
                    #let [super_name (|> superJT ..reflection)]
                    super_class (phase.lift (reflection!.load class_loader super_name))
                    superT (reflection_type mapping superJT)]
                   (wrap [[super_name superT] (java/lang/Class::isAssignableFrom super_class to_class)])))
               (case (java/lang/Class::getGenericSuperclass from_class)
                 (#.Some super)
                 (list& super (array.to_list (java/lang/Class::getGenericInterfaces from_class)))

                 #.None
                 (if (java/lang/reflect/Modifier::isInterface (java/lang/Class::getModifiers from_class))
                   (#.Cons (:as java/lang/reflect/Type (ffi.class_for java/lang/Object))
                           (array.to_list (java/lang/Class::getGenericInterfaces from_class)))
                   (array.to_list (java/lang/Class::getGenericInterfaces from_class)))))))

(def: (inheritance_candidate_parents class_loader fromT to_class toT fromC)
  (-> java/lang/ClassLoader .Type (java/lang/Class java/lang/Object) .Type Code (Operation (List [[Text .Type] Bit])))
  (case fromT
    (^ (#.Primitive _ (list& self_classT super_classT super_interfacesT+)))
    (monad.map phase.monad
               (function (_ superT)
                 (do {! phase.monad}
                   [super_name (\ ! map ..reflection (check_jvm superT))
                    super_class (phase.lift (reflection!.load class_loader super_name))]
                   (wrap [[super_name superT]
                          (java/lang/Class::isAssignableFrom super_class to_class)])))
               (list& super_classT super_interfacesT+))

    _
    (/////analysis.throw ..cannot_cast [fromT toT fromC])))

(def: (object::cast class_loader)
  (-> java/lang/ClassLoader Handler)
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list fromC))
      (do {! phase.monad}
        [toT (///.lift meta.expected_type)
         to_name (\ ! map ..reflection (check_jvm toT))
         [fromT fromA] (typeA.with_inference
                         (analyse archive fromC))
         from_name (\ ! map ..reflection (check_jvm fromT))
         can_cast? (: (Operation Bit)
                      (`` (cond (~~ (template [<primitive> <object>]
                                      [(let [=primitive (reflection.reflection <primitive>)]
                                         (or (and (text\= =primitive from_name)
                                                  (or (text\= <object> to_name)
                                                      (text\= =primitive to_name)))
                                             (and (text\= <object> from_name)
                                                  (text\= =primitive to_name))))
                                       (wrap true)]

                                      [reflection.boolean box.boolean]
                                      [reflection.byte    box.byte]
                                      [reflection.short   box.short]
                                      [reflection.int     box.int]
                                      [reflection.long    box.long]
                                      [reflection.float   box.float]
                                      [reflection.double  box.double]
                                      [reflection.char    box.char]))

                                ## else
                                (do !
                                  [_ (phase.assert ..primitives_are_not_objects [from_name]
                                                   (not (dictionary.key? ..boxes from_name)))
                                   _ (phase.assert ..primitives_are_not_objects [to_name]
                                                   (not (dictionary.key? ..boxes to_name)))
                                   to_class (phase.lift (reflection!.load class_loader to_name))
                                   _ (if (text\= ..inheritance_relationship_type_name from_name)
                                       (wrap [])
                                       (do !
                                         [from_class (phase.lift (reflection!.load class_loader from_name))]
                                         (phase.assert ..cannot_cast [fromT toT fromC]
                                                       (java/lang/Class::isAssignableFrom from_class to_class))))]
                                  (loop [[current_name currentT] [from_name fromT]]
                                    (if (text\= to_name current_name)
                                      (wrap true)
                                      (do !
                                        [candidate_parents (: (Operation (List [[Text .Type] Bit]))
                                                              (if (text\= ..inheritance_relationship_type_name current_name)
                                                                (inheritance_candidate_parents class_loader currentT to_class toT fromC)
                                                                (class_candidate_parents class_loader current_name currentT to_name to_class)))]
                                        (case (|> candidate_parents
                                                  (list.filter product.right)
                                                  (list\map product.left))
                                          (#.Cons [next_name nextT] _)
                                          (recur [next_name nextT])

                                          #.Nil
                                          (wrap false)))))))))]
        (if can_cast?
          (wrap (#/////analysis.Extension extension_name (list (/////analysis.text from_name)
                                                               (/////analysis.text to_name)
                                                               fromA)))
          (/////analysis.throw ..cannot_cast [fromT toT fromC])))

      _
      (/////analysis.throw ///.invalid_syntax [extension_name %.code args]))))

(def: (bundle::object class_loader)
  (-> java/lang/ClassLoader Bundle)
  (<| (///bundle.prefix "object")
      (|> ///bundle.empty
          (///bundle.install "null" object::null)
          (///bundle.install "null?" object::null?)
          (///bundle.install "synchronized" object::synchronized)
          (///bundle.install "throw" (object::throw class_loader))
          (///bundle.install "class" (object::class class_loader))
          (///bundle.install "instance?" (object::instance? class_loader))
          (///bundle.install "cast" (object::cast class_loader))
          )))

(def: (get::static class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [..member
    (function (_ extension_name analyse archive [class field])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         [final? deprecated? fieldJT] (phase.lift
                                       (do try.monad
                                         [class (reflection!.load class_loader class)]
                                         (reflection!.static_field field class)))
         _ (phase.assert ..deprecated_field [class field]
                         (not deprecated?))
         fieldT (reflection_type luxT.fresh fieldJT)
         _ (typeA.infer fieldT)]
        (wrap (<| (#/////analysis.Extension extension_name)
                  (list (/////analysis.text class)
                        (/////analysis.text field)
                        (/////analysis.text (|> fieldJT ..reflection)))))))]))

(def: (put::static class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..member <code>.any)
    (function (_ extension_name analyse archive [[class field] valueC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         _ (typeA.infer Any)
         [final? deprecated? fieldJT] (phase.lift
                                       (do try.monad
                                         [class (reflection!.load class_loader class)]
                                         (reflection!.static_field field class)))
         _ (phase.assert ..deprecated_field [class field]
                         (not deprecated?))
         _ (phase.assert ..cannot_set_a_final_field [class field]
                         (not final?))
         fieldT (reflection_type luxT.fresh fieldJT)
         valueA (typeA.with_type fieldT
                  (analyse archive valueC))]
        (wrap (<| (#/////analysis.Extension extension_name)
                  (list (/////analysis.text class)
                        (/////analysis.text field)
                        valueA)))))]))

(def: (get::virtual class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..member <code>.any)
    (function (_ extension_name analyse archive [[class field] objectC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         [objectT objectA] (typeA.with_inference
                             (analyse archive objectC))
         [deprecated? mapping fieldJT] (phase.lift
                                        (do try.monad
                                          [class (reflection!.load class_loader class)
                                           [final? deprecated? fieldJT] (reflection!.virtual_field field class)
                                           mapping (reflection!.correspond class objectT)]
                                          (wrap [deprecated? mapping fieldJT])))
         _ (phase.assert ..deprecated_field [class field]
                         (not deprecated?))
         fieldT (reflection_type mapping fieldJT)
         _ (typeA.infer fieldT)]
        (wrap (<| (#/////analysis.Extension extension_name)
                  (list (/////analysis.text class)
                        (/////analysis.text field)
                        objectA)))))]))

(def: (put::virtual class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..member <code>.any <code>.any)
    (function (_ extension_name analyse archive [[class field] valueC objectC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         [objectT objectA] (typeA.with_inference
                             (analyse archive objectC))
         _ (typeA.infer objectT)
         [final? deprecated? mapping fieldJT] (phase.lift
                                               (do try.monad
                                                 [class (reflection!.load class_loader class)
                                                  [final? deprecated? fieldJT] (reflection!.virtual_field field class)
                                                  mapping (reflection!.correspond class objectT)]
                                                 (wrap [final? deprecated? mapping fieldJT])))
         _ (phase.assert ..deprecated_field [class field]
                         (not deprecated?))
         _ (phase.assert ..cannot_set_a_final_field [class field]
                         (not final?))
         fieldT (reflection_type mapping fieldJT)
         valueA (typeA.with_type fieldT
                  (analyse archive valueC))]
        (wrap (<| (#/////analysis.Extension extension_name)
                  (list (/////analysis.text class)
                        (/////analysis.text field)
                        valueA
                        objectA)))))]))

(type: Method_Style
  #Static
  #Abstract
  #Virtual
  #Special
  #Interface)

(def: (check_method aliasing class method_name method_style inputsJT method)
  (-> Aliasing (java/lang/Class java/lang/Object) Text Method_Style (List (Type Value)) java/lang/reflect/Method (Operation Bit))
  (do phase.monad
    [parameters (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                    array.to_list
                    (monad.map try.monad reflection!.type)
                    phase.lift)
     #let [modifiers (java/lang/reflect/Method::getModifiers method)
           correct_class? (java/lang/Object::equals class (java/lang/reflect/Method::getDeclaringClass method))
           correct_method? (text\= method_name (java/lang/reflect/Method::getName method))
           static_matches? (case method_style
                             #Static
                             (java/lang/reflect/Modifier::isStatic modifiers)

                             _
                             true)
           special_matches? (case method_style
                              #Special
                              (not (or (java/lang/reflect/Modifier::isInterface (java/lang/Class::getModifiers class))
                                       (java/lang/reflect/Modifier::isAbstract modifiers)))

                              _
                              true)
           arity_matches? (n.= (list.size inputsJT) (list.size parameters))
           inputs_match? (and arity_matches?
                              (list\fold (function (_ [expectedJC actualJC] prev)
                                           (and prev
                                                (jvm\= expectedJC (: (Type Value)
                                                                     (case (jvm_parser.var? actualJC)
                                                                       (#.Some name)
                                                                       (|> aliasing
                                                                           (dictionary.get name)
                                                                           (maybe.default name)
                                                                           jvm.var)

                                                                       #.None
                                                                       actualJC)))))
                                         true
                                         (list.zip/2 parameters inputsJT)))]]
    (wrap (and correct_class?
               correct_method?
               static_matches?
               special_matches?
               arity_matches?
               inputs_match?))))

(def: (check_constructor aliasing class inputsJT constructor)
  (-> Aliasing (java/lang/Class java/lang/Object) (List (Type Value)) (java/lang/reflect/Constructor java/lang/Object) (Operation Bit))
  (do phase.monad
    [parameters (|> (java/lang/reflect/Constructor::getGenericParameterTypes constructor)
                    array.to_list
                    (monad.map try.monad reflection!.type)
                    phase.lift)]
    (wrap (and (java/lang/Object::equals class (java/lang/reflect/Constructor::getDeclaringClass constructor))
               (n.= (list.size inputsJT) (list.size parameters))
               (list\fold (function (_ [expectedJC actualJC] prev)
                            (and prev
                                 (jvm\= expectedJC (: (Type Value)
                                                      (case (jvm_parser.var? actualJC)
                                                        (#.Some name)
                                                        (|> aliasing
                                                            (dictionary.get name)
                                                            (maybe.default name)
                                                            jvm.var)

                                                        #.None
                                                        actualJC)))))
                          true
                          (list.zip/2 parameters inputsJT))))))

(def: idx_to_parameter
  (-> Nat .Type)
  (|>> (n.* 2) inc #.Parameter))

(def: (jvm_type_var_mapping owner_tvars method_tvars)
  (-> (List Text) (List Text) [(List .Type) Mapping])
  (let [jvm_tvars (list\compose owner_tvars method_tvars)
        lux_tvars (|> jvm_tvars
                      list.reverse
                      list.enumeration
                      (list\map (function (_ [idx name])
                                  [name (idx_to_parameter idx)]))
                      list.reverse)
        num_owner_tvars (list.size owner_tvars)
        owner_tvarsT (|> lux_tvars (list.take num_owner_tvars) (list\map product.right))
        mapping (dictionary.from_list text.hash lux_tvars)]
    [owner_tvarsT mapping]))

(def: (method_signature method_style method)
  (-> Method_Style java/lang/reflect/Method (Operation Method_Signature))
  (let [owner (java/lang/reflect/Method::getDeclaringClass method)
        owner_tvars (case method_style
                      #Static
                      (list)

                      _
                      (|> (java/lang/Class::getTypeParameters owner)
                          array.to_list
                          (list\map (|>> java/lang/reflect/TypeVariable::getName))))
        method_tvars (|> (java/lang/reflect/Method::getTypeParameters method)
                         array.to_list
                         (list\map (|>> java/lang/reflect/TypeVariable::getName)))
        [owner_tvarsT mapping] (jvm_type_var_mapping owner_tvars method_tvars)]
    (do {! phase.monad}
      [inputsT (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                   array.to_list
                   (monad.map ! (|>> reflection!.type phase.lift))
                   (phase\map (monad.map ! (..reflection_type mapping)))
                   phase\join)
       outputT (|> method
                   java/lang/reflect/Method::getGenericReturnType
                   reflection!.return
                   phase.lift
                   (phase\map (..reflection_return mapping))
                   phase\join)
       exceptionsT (|> (java/lang/reflect/Method::getGenericExceptionTypes method)
                       array.to_list
                       (monad.map ! (|>> reflection!.type phase.lift))
                       (phase\map (monad.map ! (..reflection_type mapping)))
                       phase\join)
       #let [methodT (<| (type.univ_q (dictionary.size mapping))
                         (type.function (case method_style
                                          #Static
                                          inputsT

                                          _
                                          (list& (#.Primitive (java/lang/Class::getName owner) owner_tvarsT)
                                                 inputsT)))
                         outputT)]]
      (wrap [methodT
             (reflection!.deprecated? (java/lang/reflect/Method::getDeclaredAnnotations method))
             exceptionsT]))))

(def: (constructor_signature constructor)
  (-> (java/lang/reflect/Constructor java/lang/Object) (Operation Method_Signature))
  (let [owner (java/lang/reflect/Constructor::getDeclaringClass constructor)
        owner_tvars (|> (java/lang/Class::getTypeParameters owner)
                        array.to_list
                        (list\map (|>> java/lang/reflect/TypeVariable::getName)))
        method_tvars (|> (java/lang/reflect/Constructor::getTypeParameters constructor)
                         array.to_list
                         (list\map (|>> java/lang/reflect/TypeVariable::getName)))
        [owner_tvarsT mapping] (jvm_type_var_mapping owner_tvars method_tvars)]
    (do {! phase.monad}
      [inputsT (|> (java/lang/reflect/Constructor::getGenericParameterTypes constructor)
                   array.to_list
                   (monad.map ! (|>> reflection!.type phase.lift))
                   (phase\map (monad.map ! (reflection_type mapping)))
                   phase\join)
       exceptionsT (|> (java/lang/reflect/Constructor::getGenericExceptionTypes constructor)
                       array.to_list
                       (monad.map ! (|>> reflection!.type phase.lift))
                       (phase\map (monad.map ! (reflection_type mapping)))
                       phase\join)
       #let [objectT (#.Primitive (java/lang/Class::getName owner) owner_tvarsT)
             constructorT (<| (type.univ_q (dictionary.size mapping))
                              (type.function inputsT)
                              objectT)]]
      (wrap [constructorT
             (reflection!.deprecated? (java/lang/reflect/Constructor::getDeclaredAnnotations constructor))
             exceptionsT]))))

(type: Evaluation
  (#Pass Method_Signature)
  (#Hint Method_Signature))

(template [<name> <tag>]
  [(def: <name>
     (-> Evaluation (Maybe Method_Signature))
     (|>> (case> (<tag> output)
                 (#.Some output)

                 _
                 #.None)))]

  [pass! #Pass]
  [hint! #Hint]
  )

(template [<name> <type> <method>]
  [(def: <name>
     (-> <type> (List (Type Var)))
     (|>> <method>
          array.to_list
          (list\map (|>> java/lang/reflect/TypeVariable::getName jvm.var))))]

  [class_type_variables (java/lang/Class java/lang/Object) java/lang/Class::getTypeParameters]
  [constructor_type_variables (java/lang/reflect/Constructor java/lang/Object) java/lang/reflect/Constructor::getTypeParameters]
  [method_type_variables java/lang/reflect/Method java/lang/reflect/Method::getTypeParameters]
  )

(def: (aliasing expected actual)
  (-> (List (Type Var)) (List (Type Var)) Aliasing)
  (|> (list.zip/2 (list\map jvm_parser.name actual)
                  (list\map jvm_parser.name expected))
      (dictionary.from_list text.hash)))

(def: (method_candidate class_loader actual_class_tvars class_name actual_method_tvars method_name method_style inputsJT)
  (-> java/lang/ClassLoader (List (Type Var)) External (List (Type Var)) Text Method_Style (List (Type Value)) (Operation Method_Signature))
  (do {! phase.monad}
    [class (phase.lift (reflection!.load class_loader class_name))
     #let [expected_class_tvars (class_type_variables class)]
     candidates (|> class
                    java/lang/Class::getDeclaredMethods
                    array.to_list
                    (list.filter (|>> java/lang/reflect/Method::getName (text\= method_name)))
                    (monad.map ! (: (-> java/lang/reflect/Method (Operation Evaluation))
                                    (function (_ method)
                                      (do !
                                        [#let [expected_method_tvars (method_type_variables method)
                                               aliasing (dictionary.merge (..aliasing expected_class_tvars actual_class_tvars)
                                                                          (..aliasing expected_method_tvars actual_method_tvars))]
                                         passes? (check_method aliasing class method_name method_style inputsJT method)]
                                        (\ ! map (if passes?
                                                   (|>> #Pass)
                                                   (|>> #Hint))
                                           (method_signature method_style method)))))))]
    (case (list.all pass! candidates)
      (#.Cons method #.Nil)
      (wrap method)

      #.Nil
      (/////analysis.throw ..no_candidates [class_name method_name inputsJT (list.all hint! candidates)])
      
      candidates
      (/////analysis.throw ..too_many_candidates [class_name method_name inputsJT candidates]))))

(def: constructor_method
  "<init>")

(def: (constructor_candidate class_loader actual_class_tvars class_name actual_method_tvars inputsJT)
  (-> java/lang/ClassLoader (List (Type Var)) External (List (Type Var)) (List (Type Value)) (Operation Method_Signature))
  (do {! phase.monad}
    [class (phase.lift (reflection!.load class_loader class_name))
     #let [expected_class_tvars (class_type_variables class)]
     candidates (|> class
                    java/lang/Class::getConstructors
                    array.to_list
                    (monad.map ! (function (_ constructor)
                                   (do !
                                     [#let [expected_method_tvars (constructor_type_variables constructor)
                                            aliasing (dictionary.merge (..aliasing expected_class_tvars actual_class_tvars)
                                                                       (..aliasing expected_method_tvars actual_method_tvars))]
                                      passes? (check_constructor aliasing class inputsJT constructor)]
                                     (\ ! map
                                        (if passes? (|>> #Pass) (|>> #Hint))
                                        (constructor_signature constructor))))))]
    (case (list.all pass! candidates)
      (#.Cons constructor #.Nil)
      (wrap constructor)

      #.Nil
      (/////analysis.throw ..no_candidates [class_name ..constructor_method inputsJT (list.all hint! candidates)])
      
      candidates
      (/////analysis.throw ..too_many_candidates [class_name ..constructor_method inputsJT candidates]))))

(template [<name> <category> <parser>]
  [(def: #export <name>
     (Parser (Type <category>))
     (<text>.embed <parser> <code>.text))]

  [var Var jvm_parser.var]
  [class Class jvm_parser.class]
  [type Value jvm_parser.value]
  [return Return jvm_parser.return]
  )

(def: input
  (Parser (Typed Code))
  (<code>.tuple (<>.and ..type <code>.any)))

(def: (decorate_inputs typesT inputsA)
  (-> (List (Type Value)) (List Analysis) (List Analysis))
  (|> inputsA
      (list.zip/2 (list\map (|>> ..signature /////analysis.text) typesT))
      (list\map (function (_ [type value])
                  (/////analysis.tuple (list type value))))))

(def: type_vars
  (<code>.tuple (<>.some ..var)))

(def: (invoke::static class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..type_vars ..member ..type_vars (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class method] method_tvars argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         #let [argsT (list\map product.left argsTC)]
         [methodT deprecated? exceptionsT] (..method_candidate class_loader class_tvars class method_tvars method #Static argsT)
         _ (phase.assert ..deprecated_method [class method methodT]
                         (not deprecated?))
         [outputT argsA] (inferenceA.general archive analyse methodT (list\map product.right argsTC))
         outputJT (check_return outputT)]
        (wrap (#/////analysis.Extension extension_name (list& (/////analysis.text (..signature (jvm.class class (list))))
                                                              (/////analysis.text method)
                                                              (/////analysis.text (..signature outputJT))
                                                              (decorate_inputs argsT argsA))))))]))

(def: (invoke::virtual class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..type_vars ..member ..type_vars <code>.any (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class method] method_tvars objectC argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         #let [argsT (list\map product.left argsTC)]
         [methodT deprecated? exceptionsT] (..method_candidate class_loader class_tvars class method_tvars method #Virtual argsT)
         _ (phase.assert ..deprecated_method [class method methodT]
                         (not deprecated?))
         [outputT allA] (inferenceA.general archive analyse methodT (list& objectC (list\map product.right argsTC)))
         #let [[objectA argsA] (case allA
                                 (#.Cons objectA argsA)
                                 [objectA argsA]

                                 _
                                 (undefined))]
         outputJT (check_return outputT)]
        (wrap (#/////analysis.Extension extension_name (list& (/////analysis.text (..signature (jvm.class class (list))))
                                                              (/////analysis.text method)
                                                              (/////analysis.text (..signature outputJT))
                                                              objectA
                                                              (decorate_inputs argsT argsA))))))]))

(def: (invoke::special class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..type_vars ..member ..type_vars <code>.any (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class method] method_tvars objectC argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         #let [argsT (list\map product.left argsTC)]
         [methodT deprecated? exceptionsT] (..method_candidate class_loader class_tvars class method_tvars method #Special argsT)
         _ (phase.assert ..deprecated_method [class method methodT]
                         (not deprecated?))
         [outputT argsA] (inferenceA.general archive analyse methodT (list& objectC (list\map product.right argsTC)))
         outputJT (check_return outputT)]
        (wrap (#/////analysis.Extension extension_name (list& (/////analysis.text (..signature (jvm.class class (list))))
                                                              (/////analysis.text method)
                                                              (/////analysis.text (..signature outputJT))
                                                              (decorate_inputs argsT argsA))))))]))

(def: (invoke::interface class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..type_vars ..member ..type_vars <code>.any (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class_name method] method_tvars objectC argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class_name)
         #let [argsT (list\map product.left argsTC)]
         class (phase.lift (reflection!.load class_loader class_name))
         _ (phase.assert non_interface class_name
                         (java/lang/reflect/Modifier::isInterface (java/lang/Class::getModifiers class)))
         [methodT deprecated? exceptionsT] (..method_candidate class_loader class_tvars class_name method_tvars method #Interface argsT)
         _ (phase.assert ..deprecated_method [class_name method methodT]
                         (not deprecated?))
         [outputT allA] (inferenceA.general archive analyse methodT (list& objectC (list\map product.right argsTC)))
         #let [[objectA argsA] (case allA
                                 (#.Cons objectA argsA)
                                 [objectA argsA]

                                 _
                                 (undefined))]
         outputJT (check_return outputT)]
        (wrap (#/////analysis.Extension extension_name
                                        (list& (/////analysis.text (..signature (jvm.class class_name (list))))
                                               (/////analysis.text method)
                                               (/////analysis.text (..signature outputJT))
                                               objectA
                                               (decorate_inputs argsT argsA))))))]))

(def: (invoke::constructor class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..type_vars <code>.text ..type_vars (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars class method_tvars argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         #let [argsT (list\map product.left argsTC)]
         [methodT deprecated? exceptionsT] (..constructor_candidate class_loader class_tvars class method_tvars argsT)
         _ (phase.assert ..deprecated_method [class ..constructor_method methodT]
                         (not deprecated?))
         [outputT argsA] (inferenceA.general archive analyse methodT (list\map product.right argsTC))]
        (wrap (#/////analysis.Extension extension_name (list& (/////analysis.text (..signature (jvm.class class (list))))
                                                              (decorate_inputs argsT argsA))))))]))

(def: (bundle::member class_loader)
  (-> java/lang/ClassLoader Bundle)
  (<| (///bundle.prefix "member")
      (|> ///bundle.empty
          (dictionary.merge (<| (///bundle.prefix "get")
                                (|> ///bundle.empty
                                    (///bundle.install "static" (get::static class_loader))
                                    (///bundle.install "virtual" (get::virtual class_loader)))))
          (dictionary.merge (<| (///bundle.prefix "put")
                                (|> ///bundle.empty
                                    (///bundle.install "static" (put::static class_loader))
                                    (///bundle.install "virtual" (put::virtual class_loader)))))
          (dictionary.merge (<| (///bundle.prefix "invoke")
                                (|> ///bundle.empty
                                    (///bundle.install "static" (invoke::static class_loader))
                                    (///bundle.install "virtual" (invoke::virtual class_loader))
                                    (///bundle.install "special" (invoke::special class_loader))
                                    (///bundle.install "interface" (invoke::interface class_loader))
                                    (///bundle.install "constructor" (invoke::constructor class_loader))
                                    )))
          )))

(type: #export (Annotation_Parameter a)
  [Text a])

(def: annotation_parameter
  (Parser (Annotation_Parameter Code))
  (<code>.tuple (<>.and <code>.text <code>.any)))

(type: #export (Annotation a)
  [Text (List (Annotation_Parameter a))])

(def: #export annotation
  (Parser (Annotation Code))
  (<code>.form (<>.and <code>.text (<>.some ..annotation_parameter))))

(def: #export argument
  (Parser Argument)
  (<code>.tuple (<>.and <code>.text ..type)))

(def: (annotation_parameter_analysis [name value])
  (-> (Annotation_Parameter Analysis) Analysis)
  (/////analysis.tuple (list (/////analysis.text name) value)))

(def: (annotation_analysis [name parameters])
  (-> (Annotation Analysis) Analysis)
  (/////analysis.tuple (list& (/////analysis.text name)
                              (list\map annotation_parameter_analysis parameters))))

(template [<name> <category>]
  [(def: <name>
     (-> (Type <category>) Analysis)
     (|>> ..signature /////analysis.text))]

  [var_analysis Var]
  [class_analysis Class]
  [value_analysis Value]
  [return_analysis Return]
  )

(def: (typed_analysis [type term])
  (-> (Typed Analysis) Analysis)
  (/////analysis.tuple (list (value_analysis type) term)))

(def: (argument_analysis [argument argumentJT])
  (-> Argument Analysis)
  (/////analysis.tuple
   (list (/////analysis.text argument)
         (value_analysis argumentJT))))

(template [<name> <filter>]
  [(def: <name>
     (-> (java/lang/Class java/lang/Object)
         (Try (List [Text (Type Method)])))
     (|>> java/lang/Class::getDeclaredMethods
          array.to_list
          <filter>
          (monad.map try.monad
                     (function (_ method)
                       (do {! try.monad}
                         [#let [type_variables (|> (java/lang/reflect/Method::getTypeParameters method)
                                                   array.to_list
                                                   (list\map (|>> java/lang/reflect/TypeVariable::getName
                                                                  jvm.var)))]
                          inputs (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                                     array.to_list
                                     (monad.map ! reflection!.type))
                          return (|> method
                                     java/lang/reflect/Method::getGenericReturnType
                                     reflection!.return)
                          exceptions (|> (java/lang/reflect/Method::getGenericExceptionTypes method)
                                         array.to_list
                                         (monad.map ! reflection!.class))]
                         (wrap [(java/lang/reflect/Method::getName method)
                                (jvm.method [type_variables inputs return exceptions])]))))))]

  [abstract_methods (list.filter (|>> java/lang/reflect/Method::getModifiers java/lang/reflect/Modifier::isAbstract))]
  [methods (<|)]
  )

(def: jvm_package_separator ".")

(template [<name> <methods>]
  [(def: (<name> class_loader)
     (-> java/lang/ClassLoader (List (Type Class)) (Try (List [Text (Type Method)])))
     (|>> (monad.map try.monad (|>> ..reflection (reflection!.load class_loader)))
          (try\map (monad.map try.monad <methods>))
          try\join
          (try\map list\join)))]

  [all_abstract_methods ..abstract_methods]
  [all_methods ..methods]
  )

(template [<name>]
  [(exception: #export (<name> {methods (List [Text (Type Method)])})
     (exception.report
      ["Methods" (exception.enumerate
                  (function (_ [name type])
                    (format (%.text name) " " (..signature type)))
                  methods)]))]

  [missing_abstract_methods]
  [invalid_overriden_methods]
  )

(type: #export Visibility
  #Public
  #Private
  #Protected
  #Default)

(type: #export Finality Bit)
(type: #export Strictness Bit)

(def: #export public_tag "public")
(def: #export private_tag "private")
(def: #export protected_tag "protected")
(def: #export default_tag "default")

(def: #export visibility
  (Parser Visibility)
  ($_ <>.or
      (<code>.text! ..public_tag)
      (<code>.text! ..private_tag)
      (<code>.text! ..protected_tag)
      (<code>.text! ..default_tag)))

(def: #export (visibility_analysis visibility)
  (-> Visibility Analysis)
  (/////analysis.text (case visibility
                        #Public ..public_tag
                        #Private ..private_tag
                        #Protected ..protected_tag
                        #Default ..default_tag)))

(type: #export (Constructor a)
  [Visibility
   Strictness
   (List (Annotation a))
   (List (Type Var))
   (List (Type Class)) ## Exceptions
   Text
   (List Argument)
   (List (Typed a))
   a])

(def: #export constructor_tag "init")

(def: #export constructor_definition
  (Parser (Constructor Code))
  (<| <code>.form
      (<>.after (<code>.text! ..constructor_tag))
      ($_ <>.and
          ..visibility
          <code>.bit
          (<code>.tuple (<>.some ..annotation))
          (<code>.tuple (<>.some ..var))
          (<code>.tuple (<>.some ..class))
          <code>.text
          (<code>.tuple (<>.some ..argument))
          (<code>.tuple (<>.some ..input))
          <code>.any)))

(def: #export (analyse_constructor_method analyse archive selfT mapping method)
  (-> Phase Archive .Type Mapping (Constructor Code) (Operation Analysis))
  (let [[visibility strict_fp?
         annotations vars exceptions
         self_name arguments super_arguments body] method]
    (do {! phase.monad}
      [annotationsA (monad.map ! (function (_ [name parameters])
                                   (do !
                                     [parametersA (monad.map ! (function (_ [name value])
                                                                 (do !
                                                                   [valueA (analyse archive value)]
                                                                   (wrap [name valueA])))
                                                             parameters)]
                                     (wrap [name parametersA])))
                               annotations)
       super_arguments (monad.map ! (function (_ [jvmT super_argC])
                                      (do !
                                        [luxT (reflection_type mapping jvmT)
                                         super_argA (typeA.with_type luxT
                                                      (analyse archive super_argC))]
                                        (wrap [jvmT super_argA])))
                                  super_arguments)
       arguments' (monad.map !
                             (function (_ [name jvmT])
                               (do !
                                 [luxT (reflection_type mapping jvmT)]
                                 (wrap [name luxT])))
                             arguments)
       [scope bodyA] (|> arguments'
                         (#.Cons [self_name selfT])
                         list.reverse
                         (list\fold scope.with_local (analyse archive body))
                         (typeA.with_type .Any)
                         /////analysis.with_scope)]
      (wrap (/////analysis.tuple (list (/////analysis.text ..constructor_tag)
                                       (visibility_analysis visibility)
                                       (/////analysis.bit strict_fp?)
                                       (/////analysis.tuple (list\map annotation_analysis annotationsA))
                                       (/////analysis.tuple (list\map var_analysis vars))
                                       (/////analysis.text self_name)
                                       (/////analysis.tuple (list\map ..argument_analysis arguments))
                                       (/////analysis.tuple (list\map class_analysis exceptions))
                                       (/////analysis.tuple (list\map typed_analysis super_arguments))
                                       (#/////analysis.Function
                                        (list\map (|>> /////analysis.variable)
                                                  (scope.environment scope))
                                        (/////analysis.tuple (list bodyA)))
                                       ))))))

(type: #export (Virtual_Method a)
  [Text
   Visibility
   Finality
   Strictness
   (List (Annotation a))
   (List (Type Var))
   Text
   (List Argument)
   (Type Return)
   (List (Type Class)) ## Exceptions
   a])

(def: virtual_tag "virtual")

(def: #export virtual_method_definition
  (Parser (Virtual_Method Code))
  (<| <code>.form
      (<>.after (<code>.text! ..virtual_tag))
      ($_ <>.and
          <code>.text
          ..visibility
          <code>.bit
          <code>.bit
          (<code>.tuple (<>.some ..annotation))
          (<code>.tuple (<>.some ..var))
          <code>.text
          (<code>.tuple (<>.some ..argument))
          ..return
          (<code>.tuple (<>.some ..class))
          <code>.any)))

(def: #export (analyse_virtual_method analyse archive selfT mapping method)
  (-> Phase Archive .Type Mapping (Virtual_Method Code) (Operation Analysis))
  (let [[method_name visibility
         final? strict_fp? annotations vars
         self_name arguments return exceptions
         body] method]
    (do {! phase.monad}
      [annotationsA (monad.map ! (function (_ [name parameters])
                                   (do !
                                     [parametersA (monad.map ! (function (_ [name value])
                                                                 (do !
                                                                   [valueA (analyse archive value)]
                                                                   (wrap [name valueA])))
                                                             parameters)]
                                     (wrap [name parametersA])))
                               annotations)
       returnT (reflection_return mapping return)
       arguments' (monad.map !
                             (function (_ [name jvmT])
                               (do !
                                 [luxT (reflection_type mapping jvmT)]
                                 (wrap [name luxT])))
                             arguments)
       [scope bodyA] (|> arguments'
                         (#.Cons [self_name selfT])
                         list.reverse
                         (list\fold scope.with_local (analyse archive body))
                         (typeA.with_type returnT)
                         /////analysis.with_scope)]
      (wrap (/////analysis.tuple (list (/////analysis.text ..virtual_tag)
                                       (/////analysis.text method_name)
                                       (visibility_analysis visibility)
                                       (/////analysis.bit final?)
                                       (/////analysis.bit strict_fp?)
                                       (/////analysis.tuple (list\map annotation_analysis annotationsA))
                                       (/////analysis.tuple (list\map var_analysis vars))
                                       (/////analysis.text self_name)
                                       (/////analysis.tuple (list\map ..argument_analysis arguments))
                                       (return_analysis return)
                                       (/////analysis.tuple (list\map class_analysis exceptions))
                                       (#/////analysis.Function
                                        (list\map (|>> /////analysis.variable)
                                                  (scope.environment scope))
                                        (/////analysis.tuple (list bodyA)))
                                       ))))))

(type: #export (Static_Method a)
  [Text
   Visibility
   Strictness
   (List (Annotation a))
   (List (Type Var))
   (List (Type Class)) ## Exceptions
   (List Argument)
   (Type Return)
   a])

(def: #export static_tag "static")

(def: #export static_method_definition
  (Parser (Static_Method Code))
  (<| <code>.form
      (<>.after (<code>.text! ..static_tag))
      ($_ <>.and
          <code>.text
          ..visibility
          <code>.bit
          (<code>.tuple (<>.some ..annotation))
          (<code>.tuple (<>.some ..var))
          (<code>.tuple (<>.some ..class))
          (<code>.tuple (<>.some ..argument))
          ..return
          <code>.any)))

(def: #export (analyse_static_method analyse archive mapping method)
  (-> Phase Archive Mapping (Static_Method Code) (Operation Analysis))
  (let [[method_name visibility
         strict_fp? annotations vars exceptions
         arguments return
         body] method]
    (do {! phase.monad}
      [annotationsA (monad.map ! (function (_ [name parameters])
                                   (do !
                                     [parametersA (monad.map ! (function (_ [name value])
                                                                 (do !
                                                                   [valueA (analyse archive value)]
                                                                   (wrap [name valueA])))
                                                             parameters)]
                                     (wrap [name parametersA])))
                               annotations)
       returnT (reflection_return mapping return)
       arguments' (monad.map !
                             (function (_ [name jvmT])
                               (do !
                                 [luxT (reflection_type mapping jvmT)]
                                 (wrap [name luxT])))
                             arguments)
       [scope bodyA] (|> arguments'
                         list.reverse
                         (list\fold scope.with_local (analyse archive body))
                         (typeA.with_type returnT)
                         /////analysis.with_scope)]
      (wrap (/////analysis.tuple (list (/////analysis.text ..static_tag)
                                       (/////analysis.text method_name)
                                       (visibility_analysis visibility)
                                       (/////analysis.bit strict_fp?)
                                       (/////analysis.tuple (list\map annotation_analysis annotationsA))
                                       (/////analysis.tuple (list\map var_analysis vars))
                                       (/////analysis.tuple (list\map ..argument_analysis arguments))
                                       (return_analysis return)
                                       (/////analysis.tuple (list\map class_analysis
                                                                      exceptions))
                                       (#/////analysis.Function
                                        (list\map (|>> /////analysis.variable)
                                                  (scope.environment scope))
                                        (/////analysis.tuple (list bodyA)))
                                       ))))))

(type: #export (Overriden_Method a)
  [(Type Class)
   Text
   Bit
   (List (Annotation a))
   (List (Type Var))
   Text
   (List Argument)
   (Type Return)
   (List (Type Class))
   a])

(def: #export overriden_tag "override")

(def: #export overriden_method_definition
  (Parser (Overriden_Method Code))
  (<| <code>.form
      (<>.after (<code>.text! ..overriden_tag))
      ($_ <>.and
          ..class
          <code>.text
          <code>.bit
          (<code>.tuple (<>.some ..annotation))
          (<code>.tuple (<>.some ..var))
          <code>.text
          (<code>.tuple (<>.some ..argument))
          ..return
          (<code>.tuple (<>.some ..class))
          <code>.any
          )))

(exception: #export (unknown_super {name Text} {supers (List (Type Class))})
  (exception.report
   ["Name" (%.text name)]
   ["Available" (exception.enumerate (|>> jvm_parser.read_class product.left) supers)]))

(exception: #export (mismatched_super_parameters {name Text} {expected Nat} {actual Nat})
  (exception.report
   ["Name" (%.text name)]
   ["Expected" (%.nat expected)]
   ["Actual" (%.nat actual)]))

(def: (override_mapping mapping supers parent_type)
  (-> Mapping (List (Type Class)) (Type Class) (Operation (List [Text .Type])))
  (let [[parent_name parent_parameters] (jvm_parser.read_class parent_type)]
    (case (list.one (function (_ super)
                      (let [[super_name super_parameters] (jvm_parser.read_class super)]
                        (if (text\= parent_name super_name)
                          (#.Some super_parameters)
                          #.None)))
                    supers)
      (#.Some super_parameters)
      (let [expected_count (list.size parent_parameters)
            actual_count (list.size super_parameters)]
        (if (n.= expected_count actual_count)
          (do {! phase.monad}
            [parent_parameters (|> parent_parameters
                                   (monad.map maybe.monad jvm_parser.var?)
                                   try.from_maybe
                                   phase.lift)]
            (|> super_parameters
                (monad.map ! (..reflection_type mapping))
                (\ ! map (|>> (list.zip/2 parent_parameters)))))
          (phase.lift (exception.throw ..mismatched_super_parameters [parent_name expected_count actual_count]))))
      
      #.None
      (phase.lift (exception.throw ..unknown_super [parent_name supers])))))

(def: #export (analyse_overriden_method analyse archive selfT mapping supers method)
  (-> Phase Archive .Type Mapping (List (Type Class)) (Overriden_Method Code) (Operation Analysis))
  (let [[parent_type method_name
         strict_fp? annotations vars
         self_name arguments return exceptions
         body] method]
    (do {! phase.monad}
      [override_mapping (..override_mapping mapping supers parent_type)
       #let [mapping (list\fold (function (_ [super_var bound_type] mapping)
                                  (dictionary.put super_var bound_type mapping))
                                mapping
                                override_mapping)
             mapping (list\fold (function (_ varJ mapping)
                                  (dictionary.put (jvm_parser.name varJ) java/lang/Object mapping))
                                mapping
                                vars)]
       annotationsA (monad.map ! (function (_ [name parameters])
                                   (do !
                                     [parametersA (monad.map ! (function (_ [name value])
                                                                 (do !
                                                                   [valueA (analyse archive value)]
                                                                   (wrap [name valueA])))
                                                             parameters)]
                                     (wrap [name parametersA])))
                               annotations)
       returnT (reflection_return mapping return)
       arguments' (monad.map !
                             (function (_ [name jvmT])
                               (do !
                                 [luxT (reflection_type mapping jvmT)]
                                 (wrap [name luxT])))
                             arguments)
       [scope bodyA] (|> arguments'
                         (#.Cons [self_name selfT])
                         list.reverse
                         (list\fold scope.with_local (analyse archive body))
                         (typeA.with_type returnT)
                         /////analysis.with_scope)]
      (wrap (/////analysis.tuple (list (/////analysis.text ..overriden_tag)
                                       (class_analysis parent_type)
                                       (/////analysis.text method_name)
                                       (/////analysis.bit strict_fp?)
                                       (/////analysis.tuple (list\map annotation_analysis annotationsA))
                                       (/////analysis.tuple (list\map var_analysis vars))
                                       (/////analysis.text self_name)
                                       (/////analysis.tuple (list\map ..argument_analysis arguments))
                                       (return_analysis return)
                                       (/////analysis.tuple (list\map class_analysis
                                                                      exceptions))
                                       (#/////analysis.Function
                                        (list\map (|>> /////analysis.variable)
                                                  (scope.environment scope))
                                        (/////analysis.tuple (list bodyA)))
                                       ))))))

(type: #export (Method_Definition a)
  (#Overriden_Method (Overriden_Method a)))

(def: #export parameter_types
  (-> (List (Type Var)) (Check (List [(Type Var) .Type])))
  (monad.map check.monad
             (function (_ parameterJ)
               (do check.monad
                 [[_ parameterT] check.existential]
                 (wrap [parameterJ parameterT])))))

(def: (mismatched_methods super_set sub_set)
  (-> (List [Text (Type Method)])
      (List [Text (Type Method)])
      (List [Text (Type Method)]))
  (list.filter (function (_ [sub_name subJT])
                 (|> super_set
                     (list.filter (function (_ [super_name superJT])
                                    (and (text\= super_name sub_name)
                                         (jvm\= superJT subJT))))
                     list.size
                     (n.= 1)
                     not))
               sub_set))

(exception: #export (class_parameter_mismatch {expected (List Text)}
                                              {actual (List (Type Parameter))})
  (exception.report
   ["Expected (amount)" (%.nat (list.size expected))]
   ["Expected (parameters)" (exception.enumerate %.text expected)]
   ["Actual (amount)" (%.nat (list.size actual))]
   ["Actual (parameters)" (exception.enumerate ..signature actual)]))

(def: (super_aliasing class_loader class)
  (-> java/lang/ClassLoader (Type Class) (Operation Aliasing))
  (do phase.monad
    [#let [[name actual_parameters] (jvm_parser.read_class class)]
     class (phase.lift (reflection!.load class_loader name))
     #let [expected_parameters (|> (java/lang/Class::getTypeParameters class)
                                   array.to_list
                                   (list\map (|>> java/lang/reflect/TypeVariable::getName)))]
     _ (phase.assert ..class_parameter_mismatch [expected_parameters actual_parameters]
                     (n.= (list.size expected_parameters)
                          (list.size actual_parameters)))]
    (wrap (|> (list.zip/2 expected_parameters actual_parameters)
              (list\fold (function (_ [expected actual] mapping)
                           (case (jvm_parser.var? actual)
                             (#.Some actual)
                             (dictionary.put actual expected mapping)
                             
                             #.None
                             mapping))
                         jvm_alias.fresh)))))

(def: (anonymous_class_name module id)
  (-> Module Nat Text)
  (let [global (text.replace_all .module_separator ..jvm_package_separator module)
        local (format "anonymous-class" (%.nat id))]
    (format global ..jvm_package_separator local)))

(def: (class::anonymous class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and
        (<code>.tuple (<>.some ..var))
        ..class
        (<code>.tuple (<>.some ..class))
        (<code>.tuple (<>.some ..input))
        (<code>.tuple (<>.some ..overriden_method_definition)))
    (function (_ extension_name analyse archive [parameters
                                                 super_class
                                                 super_interfaces
                                                 constructor_args
                                                 methods])
      (do {! phase.monad}
        [_ (..ensure_fresh_class! class_loader (..reflection super_class))
         _ (monad.map ! (|>> ..reflection (..ensure_fresh_class! class_loader)) super_interfaces)
         parameters (typeA.with_env
                      (..parameter_types parameters))
         #let [mapping (list\fold (function (_ [parameterJ parameterT] mapping)
                                    (dictionary.put (jvm_parser.name parameterJ)
                                                    parameterT
                                                    mapping))
                                  luxT.fresh
                                  parameters)]
         super_classT (typeA.with_env
                        (luxT.check (luxT.class mapping) (..signature super_class)))
         super_interfaceT+ (typeA.with_env
                             (monad.map check.monad
                                        (|>> ..signature (luxT.check (luxT.class mapping)))
                                        super_interfaces))
         selfT (///.lift (do meta.monad
                           [where meta.current_module_name
                            id meta.count]
                           (wrap (inheritance_relationship_type (#.Primitive (..anonymous_class_name where id) (list))
                                                                super_classT
                                                                super_interfaceT+))))
         _ (typeA.infer selfT)
         constructor_argsA+ (monad.map ! (function (_ [type term])
                                           (do !
                                             [argT (reflection_type mapping type)
                                              termA (typeA.with_type argT
                                                      (analyse archive term))]
                                             (wrap [type termA])))
                                       constructor_args)
         methodsA (monad.map ! (analyse_overriden_method analyse archive selfT mapping (#.Cons super_class super_interfaces)) methods)
         required_abstract_methods (phase.lift (all_abstract_methods class_loader (list& super_class super_interfaces)))
         available_methods (phase.lift (all_methods class_loader (list& super_class super_interfaces)))
         overriden_methods (monad.map ! (function (_ [parent_type method_name
                                                      strict_fp? annotations type_vars
                                                      self_name arguments return exceptions
                                                      body])
                                          (do !
                                            [aliasing (super_aliasing class_loader parent_type)]
                                            (wrap [method_name (|> (jvm.method [type_vars
                                                                                (list\map product.right arguments)
                                                                                return
                                                                                exceptions])
                                                                   (jvm_alias.method aliasing))])))
                                      methods)
         #let [missing_abstract_methods (mismatched_methods overriden_methods required_abstract_methods)
               invalid_overriden_methods (mismatched_methods available_methods overriden_methods)]
         _ (phase.assert ..missing_abstract_methods missing_abstract_methods
                         (list.empty? missing_abstract_methods))
         _ (phase.assert ..invalid_overriden_methods invalid_overriden_methods
                         (list.empty? invalid_overriden_methods))]
        (wrap (#/////analysis.Extension extension_name
                                        (list (class_analysis super_class)
                                              (/////analysis.tuple (list\map class_analysis super_interfaces))
                                              (/////analysis.tuple (list\map typed_analysis constructor_argsA+))
                                              (/////analysis.tuple methodsA))))))]))

(def: (bundle::class class_loader)
  (-> java/lang/ClassLoader Bundle)
  (<| (///bundle.prefix "class")
      (|> ///bundle.empty
          (///bundle.install "anonymous" (class::anonymous class_loader))
          )))

(def: #export (bundle class_loader)
  (-> java/lang/ClassLoader Bundle)
  (<| (///bundle.prefix "jvm")
      (|> ///bundle.empty
          (dictionary.merge bundle::conversion)
          (dictionary.merge bundle::int)
          (dictionary.merge bundle::long)
          (dictionary.merge bundle::float)
          (dictionary.merge bundle::double)
          (dictionary.merge bundle::char)
          (dictionary.merge bundle::array)
          (dictionary.merge (bundle::object class_loader))
          (dictionary.merge (bundle::member class_loader))
          (dictionary.merge (bundle::class class_loader))
          )))
