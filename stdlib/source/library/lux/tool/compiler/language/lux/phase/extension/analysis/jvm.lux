(.module:
  [library
   [lux {"-" [Type Module primitive type char int]}
    ["[0]" ffi {"+" [import:]}]
    ["[0]" meta]
    [abstract
     ["[0]" monad {"+" [do]}]]
    [control
     pipe
     ["[0]" maybe]
     ["[0]" try {"+" [Try]} ("[1]\[0]" monad)]
     ["[0]" exception {"+" [exception:]}]
     ["<>" parser
      ["<[0]>" code {"+" [Parser]}]
      ["<[0]>" text]]]
    [data
     ["[0]" product]
     ["[0]" text ("[1]\[0]" equivalence)
      ["%" format {"+" [format]}]]
     [collection
      ["[0]" list ("[1]\[0]" mix monad monoid)]
      ["[0]" array]
      ["[0]" dictionary {"+" [Dictionary]}]]]
    [math
     [number
      ["n" nat]]]
    [target
     ["[0]" jvm "_"
      ["[0]!" reflection]
      [encoding
       [name {"+" [External]}]]
      ["[1]" type {"+" [Type Argument Typed]} ("[1]\[0]" equivalence)
       ["[0]" category {"+" [Void Value' Value Return' Return Primitive Object Class Array Var Parameter Method]}]
       ["[0]" box]
       ["[0]" reflection]
       ["[0]" descriptor]
       ["[0]" signature]
       ["[1]_[0]" parser]
       ["[1]_[0]" alias {"+" [Aliasing]}]
       ["[0]T" lux {"+" [Mapping]}]]]]
    ["[0]" type
     ["[0]" check {"+" [Check]} ("[1]\[0]" monad)]]]]
  ["[0]" // "_"
   ["[1][0]" lux {"+" [custom]}]
   ["/[1]" //
    ["[1][0]" bundle]
    ["/[1]" // "_"
     [analysis
      ["[0]A" type]
      ["[0]A" inference]
      ["[0]" scope]]
     ["/[1]" // "_"
      ["[1][0]" analysis {"+" [Analysis Operation Phase Handler Bundle]}]
      ["[1][0]" synthesis]
      [///
       ["[0]" phase ("[1]\[0]" monad)]
       [meta
        [archive {"+" [Archive]}
         [descriptor {"+" [Module]}]]]]]]]])

(import: java/lang/ClassLoader)

(import: java/lang/Object
  ["[1]::[0]"
   (equals [java/lang/Object] boolean)])

(import: java/lang/reflect/Type)

(import: (java/lang/reflect/TypeVariable d)
  ["[1]::[0]"
   (getName [] java/lang/String)
   (getBounds [] [java/lang/reflect/Type])])

(import: java/lang/reflect/Modifier
  ["[1]::[0]"
   ("static" isStatic [int] boolean)
   ("static" isFinal [int] boolean)
   ("static" isInterface [int] boolean)
   ("static" isAbstract [int] boolean)])

(import: java/lang/annotation/Annotation)

(import: java/lang/reflect/Method
  ["[1]::[0]"
   (getName [] java/lang/String)
   (getModifiers [] int)
   (getDeclaringClass [] (java/lang/Class java/lang/Object))
   (getTypeParameters [] [(java/lang/reflect/TypeVariable java/lang/reflect/Method)])
   (getGenericParameterTypes [] [java/lang/reflect/Type])
   (getGenericReturnType [] java/lang/reflect/Type)
   (getGenericExceptionTypes [] [java/lang/reflect/Type])
   (getDeclaredAnnotations [] [java/lang/annotation/Annotation])])

(import: (java/lang/reflect/Constructor c)
  ["[1]::[0]"
   (getModifiers [] int)
   (getDeclaringClass [] (java/lang/Class c))
   (getTypeParameters [] [(java/lang/reflect/TypeVariable (java/lang/reflect/Constructor c))])
   (getGenericParameterTypes [] [java/lang/reflect/Type])
   (getGenericExceptionTypes [] [java/lang/reflect/Type])
   (getDeclaredAnnotations [] [java/lang/annotation/Annotation])])

(import: (java/lang/Class c)
  ["[1]::[0]"
   ("static" forName [java/lang/String] "try" (java/lang/Class java/lang/Object))
   (getName [] java/lang/String)
   (getModifiers [] int)
   (isAssignableFrom [(java/lang/Class java/lang/Object)] boolean)
   (getTypeParameters [] [(java/lang/reflect/TypeVariable (java/lang/Class c))])
   (getGenericInterfaces [] [java/lang/reflect/Type])
   (getGenericSuperclass [] "?" java/lang/reflect/Type)
   (getDeclaredField [java/lang/String] "try" java/lang/reflect/Field)
   (getConstructors [] [(java/lang/reflect/Constructor java/lang/Object)])
   (getDeclaredMethods [] [java/lang/reflect/Method])
   (getDeclaredAnnotations [] [java/lang/annotation/Annotation])])

(template [<name>]
  [(exception: .public (<name> [class External
                                field Text])
     (exception.report
      ["Class" (%.text class)]
      ["Field" (%.text field)]))]

  [cannot_set_a_final_field]
  [deprecated_field]
  )

(exception: .public (deprecated_method [class External
                                        method Text
                                        type .Type])
  (exception.report
   ["Class" (%.text class)]
   ["Method" (%.text method)]
   ["Type" (%.type type)]))

(exception: .public (deprecated_class [class External])
  (exception.report
   ["Class" (%.text class)]))

(def: (ensure_fresh_class! class_loader name)
  (-> java/lang/ClassLoader External (Operation Any))
  (do phase.monad
    [class (phase.lifted (reflection!.load class_loader name))]
    (phase.assertion ..deprecated_class [name]
                     (|> class
                         java/lang/Class::getDeclaredAnnotations
                         reflection!.deprecated?
                         not))))

(def: reflection
  (All (_ category)
    (-> (Type (<| Return' Value' category)) Text))
  (|>> jvm.reflection reflection.reflection))

(def: signature (|>> jvm.signature signature.signature))

(def: object_class
  External
  "java.lang.Object")

(def: inheritance_relationship_type_name "_jvm_inheritance")
(def: .public (inheritance_relationship_type class super_class super_interfaces)
  (-> .Type .Type (List .Type) .Type)
  {#.Primitive ..inheritance_relationship_type_name
               (list& class super_class super_interfaces)})

... TODO: Get rid of this template block and use the definition in
... lux/ffi.jvm.lux ASAP
(template [<name> <class>]
  [(def: .public <name> .Type {#.Primitive <class> #.End})]

  ... Boxes
  [Boolean   box.boolean]
  [Byte      box.byte]
  [Short     box.short]
  [Integer   box.int]
  [Long      box.long]
  [Float     box.float]
  [Double    box.double]
  [Character box.char]
  [String    "java.lang.String"]

  ... Primitives
  [boolean   (reflection.reflection reflection.boolean)]
  [byte      (reflection.reflection reflection.byte)]
  [short     (reflection.reflection reflection.short)]
  [int       (reflection.reflection reflection.int)]
  [long      (reflection.reflection reflection.long)]
  [float     (reflection.reflection reflection.float)]
  [double    (reflection.reflection reflection.double)]
  [char      (reflection.reflection reflection.char)]
  )

(type: Member
  (Record
   [#class External
    #member Text]))

(def: member
  (Parser Member)
  ($_ <>.and <code>.text <code>.text))

(type: Method_Signature
  (Record
   [#method .Type
    #deprecated? Bit
    #exceptions (List .Type)]))

(template [<name>]
  [(exception: .public (<name> [type .Type])
     (exception.report
      ["Type" (%.type type)]))]

  [non_object]
  [non_array]
  [non_parameter]
  [non_jvm_type]
  )

(template [<name>]
  [(exception: .public (<name> [class External])
     (exception.report
      ["Class/type" (%.text class)]))]

  [non_interface]
  [non_throwable]
  [primitives_are_not_objects]
  )

(template [<name>]
  [(exception: .public (<name> [class External
                                method Text
                                inputsJT (List (Type Value))
                                hints (List Method_Signature)])
     (exception.report
      ["Class" class]
      ["Method" method]
      ["Arguments" (exception.listing ..signature inputsJT)]
      ["Hints" (exception.listing %.type (list\each product.left hints))]))]

  [no_candidates]
  [too_many_candidates]
  )

(exception: .public (cannot_cast [from .Type
                                  to .Type
                                  value Code])
  (exception.report
   ["From" (%.type from)]
   ["To" (%.type to)]
   ["Value" (%.code value)]))

(template [<name>]
  [(exception: .public (<name> [message Text])
     message)]

  [primitives_cannot_have_type_parameters]

  [cannot_possibly_be_an_instance]

  [unknown_type_var]
  )

(def: bundle::conversion
  Bundle
  (<| (///bundle.prefix "conversion")
      (|> ///bundle.empty
          (///bundle.install "double-to-float" (//lux.unary ..double ..float))
          (///bundle.install "double-to-int" (//lux.unary ..double ..int))
          (///bundle.install "double-to-long" (//lux.unary ..double ..long))
          (///bundle.install "float-to-double" (//lux.unary ..float ..double))
          (///bundle.install "float-to-int" (//lux.unary ..float ..int))
          (///bundle.install "float-to-long" (//lux.unary ..float ..long))
          (///bundle.install "int-to-byte" (//lux.unary ..int ..byte))
          (///bundle.install "int-to-char" (//lux.unary ..int ..char))
          (///bundle.install "int-to-double" (//lux.unary ..int ..double))
          (///bundle.install "int-to-float" (//lux.unary ..int ..float))
          (///bundle.install "int-to-long" (//lux.unary ..int ..long))
          (///bundle.install "int-to-short" (//lux.unary ..int ..short))
          (///bundle.install "long-to-double" (//lux.unary ..long ..double))
          (///bundle.install "long-to-float" (//lux.unary ..long ..float))
          (///bundle.install "long-to-int" (//lux.unary ..long ..int))
          (///bundle.install "long-to-short" (//lux.unary ..long ..short))
          (///bundle.install "long-to-byte" (//lux.unary ..long ..byte))
          (///bundle.install "char-to-byte" (//lux.unary ..char ..byte))
          (///bundle.install "char-to-short" (//lux.unary ..char ..short))
          (///bundle.install "char-to-int" (//lux.unary ..char ..int))
          (///bundle.install "char-to-long" (//lux.unary ..char ..long))
          (///bundle.install "byte-to-long" (//lux.unary ..byte ..long))
          (///bundle.install "short-to-long" (//lux.unary ..short ..long))
          )))

(template [<name> <prefix> <type>]
  [(def: <name>
     Bundle
     (<| (///bundle.prefix (reflection.reflection <prefix>))
         (|> ///bundle.empty
             (///bundle.install "+" (//lux.binary <type> <type> <type>))
             (///bundle.install "-" (//lux.binary <type> <type> <type>))
             (///bundle.install "*" (//lux.binary <type> <type> <type>))
             (///bundle.install "/" (//lux.binary <type> <type> <type>))
             (///bundle.install "%" (//lux.binary <type> <type> <type>))
             (///bundle.install "=" (//lux.binary <type> <type> Bit))
             (///bundle.install "<" (//lux.binary <type> <type> Bit))
             (///bundle.install "and" (//lux.binary <type> <type> <type>))
             (///bundle.install "or" (//lux.binary <type> <type> <type>))
             (///bundle.install "xor" (//lux.binary <type> <type> <type>))
             (///bundle.install "shl" (//lux.binary ..int <type> <type>))
             (///bundle.install "shr" (//lux.binary ..int <type> <type>))
             (///bundle.install "ushr" (//lux.binary ..int <type> <type>))
             )))]

  [bundle::int  reflection.int  ..int]
  [bundle::long reflection.long ..long]
  )

(template [<name> <prefix> <type>]
  [(def: <name>
     Bundle
     (<| (///bundle.prefix (reflection.reflection <prefix>))
         (|> ///bundle.empty
             (///bundle.install "+" (//lux.binary <type> <type> <type>))
             (///bundle.install "-" (//lux.binary <type> <type> <type>))
             (///bundle.install "*" (//lux.binary <type> <type> <type>))
             (///bundle.install "/" (//lux.binary <type> <type> <type>))
             (///bundle.install "%" (//lux.binary <type> <type> <type>))
             (///bundle.install "=" (//lux.binary <type> <type> Bit))
             (///bundle.install "<" (//lux.binary <type> <type> Bit))
             )))]

  [bundle::float  reflection.float  ..float]
  [bundle::double reflection.double ..double]
  )

(def: bundle::char
  Bundle
  (<| (///bundle.prefix (reflection.reflection reflection.char))
      (|> ///bundle.empty
          (///bundle.install "=" (//lux.binary ..char ..char Bit))
          (///bundle.install "<" (//lux.binary ..char ..char Bit))
          )))

(def: .public boxes
  (Dictionary External [External (Type Primitive)])
  (|> (list [(reflection.reflection reflection.boolean) [box.boolean jvm.boolean]]
            [(reflection.reflection reflection.byte)    [box.byte jvm.byte]]
            [(reflection.reflection reflection.short)   [box.short jvm.short]]
            [(reflection.reflection reflection.int)     [box.int jvm.int]]
            [(reflection.reflection reflection.long)    [box.long jvm.long]]
            [(reflection.reflection reflection.float)   [box.float jvm.float]]
            [(reflection.reflection reflection.double)  [box.double jvm.double]]
            [(reflection.reflection reflection.char)    [box.char jvm.char]])
      (dictionary.of_list text.hash)))

(def: (jvm_type luxT)
  (-> .Type (Operation (Type Value)))
  (case luxT
    {#.Named name anonymousT}
    (jvm_type anonymousT)
    
    {#.Apply inputT abstractionT}
    (case (type.applied (list inputT) abstractionT)
      {#.Some outputT}
      (jvm_type outputT)

      #.None
      (/////analysis.except ..non_jvm_type luxT))

    (^ {#.Primitive (static array.type_name) (list elemT)})
    (phase\each jvm.array (jvm_type elemT))

    {#.Primitive class parametersT}
    (case (dictionary.value class ..boxes)
      {#.Some [_ primitive_type]}
      (case parametersT
        #.End
        (phase\in primitive_type)

        _
        (/////analysis.except ..primitives_cannot_have_type_parameters class))

      #.None
      (do [! phase.monad]
        [parametersJT (: (Operation (List (Type Parameter)))
                         (monad.each !
                                     (function (_ parameterT)
                                       (do phase.monad
                                         [parameterJT (jvm_type parameterT)]
                                         (case (jvm_parser.parameter? parameterJT)
                                           {#.Some parameterJT}
                                           (in parameterJT)
                                           
                                           #.None
                                           (/////analysis.except ..non_parameter parameterT))))
                                     parametersT))]
        (in (jvm.class class parametersJT))))

    {#.Ex _}
    (phase\in (jvm.class ..object_class (list)))
    
    _
    (/////analysis.except ..non_jvm_type luxT)))

(def: (jvm_array_type objectT)
  (-> .Type (Operation (Type Array)))
  (do phase.monad
    [objectJ (jvm_type objectT)]
    (|> objectJ
        ..signature
        (<text>.result jvm_parser.array)
        phase.lifted)))

(def: (primitive_array_length_handler primitive_type)
  (-> (Type Primitive) Handler)
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list arrayC))
      (do phase.monad
        [_ (typeA.infer ..int)
         arrayA (typeA.with_type {#.Primitive (|> (jvm.array primitive_type)
                                                  ..reflection)
                                              (list)}
                  (analyse archive arrayC))]
        (in {#/////analysis.Extension extension_name (list arrayA)}))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: array::length::object
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list arrayC))
      (do phase.monad
        [_ (typeA.infer ..int)
         [var_id varT] (typeA.with_env check.var)
         arrayA (typeA.with_type (.type (array.Array varT))
                  (analyse archive arrayC))
         varT (typeA.with_env (check.clean varT))
         arrayJT (jvm_array_type (.type (array.Array varT)))]
        (in {#/////analysis.Extension extension_name (list (/////analysis.text (..signature arrayJT))
                                                           arrayA)}))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: (new_primitive_array_handler primitive_type)
  (-> (Type Primitive) Handler)
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list lengthC))
      (do phase.monad
        [lengthA (typeA.with_type ..int
                   (analyse archive lengthC))
         _ (typeA.infer {#.Primitive (|> (jvm.array primitive_type) ..reflection)
                                     (list)})]
        (in {#/////analysis.Extension extension_name (list lengthA)}))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: array::new::object
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list lengthC))
      (do phase.monad
        [lengthA (typeA.with_type ..int
                   (analyse archive lengthC))
         expectedT (///.lifted meta.expected_type)
         expectedJT (jvm_array_type expectedT)
         elementJT (case (jvm_parser.array? expectedJT)
                     {#.Some elementJT}
                     (in elementJT)
                     
                     #.None
                     (/////analysis.except ..non_array expectedT))]
        (in {#/////analysis.Extension extension_name (list (/////analysis.text (..signature elementJT))
                                                           lengthA)}))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: (check_parameter objectT)
  (-> .Type (Operation (Type Parameter)))
  (case objectT
    (^ {#.Primitive (static array.type_name)
                    (list elementT)})
    (/////analysis.except ..non_parameter objectT)
    
    {#.Primitive name parameters}
    (`` (cond (or (~~ (template [<type>]
                        [(text\= (..reflection <type>) name)]

                        [jvm.boolean]
                        [jvm.byte]
                        [jvm.short]
                        [jvm.int]
                        [jvm.long]
                        [jvm.float]
                        [jvm.double]
                        [jvm.char]))
                  (text.starts_with? descriptor.array_prefix name))
              (/////analysis.except ..non_parameter objectT)

              ... else
              (phase\in (jvm.class name (list)))))

    {#.Named name anonymous}
    (check_parameter anonymous)

    (^template [<tag>]
      [{<tag> id}
       (phase\in (jvm.class ..object_class (list)))])
    ([#.Var]
     [#.Ex])

    (^template [<tag>]
      [{<tag> env unquantified}
       (check_parameter unquantified)])
    ([#.UnivQ]
     [#.ExQ])

    {#.Apply inputT abstractionT}
    (case (type.applied (list inputT) abstractionT)
      {#.Some outputT}
      (check_parameter outputT)

      #.None
      (/////analysis.except ..non_parameter objectT))

    _
    (/////analysis.except ..non_parameter objectT)))

(def: (check_jvm objectT)
  (-> .Type (Operation (Type Value)))
  (case objectT
    {#.Primitive name #.End}
    (`` (cond (~~ (template [<type>]
                    [(text\= (..reflection <type>) name)
                     (phase\in <type>)]

                    [jvm.boolean]
                    [jvm.byte]
                    [jvm.short]
                    [jvm.int]
                    [jvm.long]
                    [jvm.float]
                    [jvm.double]
                    [jvm.char]))

              (~~ (template [<type>]
                    [(text\= (..reflection (jvm.array <type>)) name)
                     (phase\in (jvm.array <type>))]

                    [jvm.boolean]
                    [jvm.byte]
                    [jvm.short]
                    [jvm.int]
                    [jvm.long]
                    [jvm.float]
                    [jvm.double]
                    [jvm.char]))

              (text.starts_with? descriptor.array_prefix name)
              (let [[_ unprefixed] (maybe.trusted (text.split_by descriptor.array_prefix name))]
                (\ phase.monad each jvm.array
                   (check_jvm {#.Primitive unprefixed (list)})))

              ... else
              (phase\in (jvm.class name (list)))))
    
    (^ {#.Primitive (static array.type_name)
                    (list elementT)})
    (|> elementT
        check_jvm
        (phase\each jvm.array))
    
    {#.Primitive name parameters}
    (do [! phase.monad]
      [parameters (monad.each ! check_parameter parameters)]
      (phase\in (jvm.class name parameters)))

    {#.Named name anonymous}
    (check_jvm anonymous)

    (^template [<tag>]
      [{<tag> env unquantified}
       (check_jvm unquantified)])
    ([#.UnivQ]
     [#.ExQ])

    {#.Apply inputT abstractionT}
    (case (type.applied (list inputT) abstractionT)
      {#.Some outputT}
      (check_jvm outputT)

      #.None
      (/////analysis.except ..non_object objectT))

    _
    (check_parameter objectT)))

(def: (check_object objectT)
  (-> .Type (Operation External))
  (do [! phase.monad]
    [name (\ ! each ..reflection (check_jvm objectT))]
    (if (dictionary.key? ..boxes name)
      (/////analysis.except ..primitives_are_not_objects [name])
      (phase\in name))))

(def: (check_return type)
  (-> .Type (Operation (Type Return)))
  (if (same? .Any type)
    (phase\in jvm.void)
    (check_jvm type)))

(def: (read_primitive_array_handler lux_type jvm_type)
  (-> .Type (Type Primitive) Handler)
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list idxC arrayC))
      (do phase.monad
        [_ (typeA.infer lux_type)
         idxA (typeA.with_type ..int
                (analyse archive idxC))
         arrayA (typeA.with_type {#.Primitive (|> (jvm.array jvm_type) ..reflection)
                                              (list)}
                  (analyse archive arrayC))]
        (in {#/////analysis.Extension extension_name (list idxA arrayA)}))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 2 (list.size args)]))))

(def: array::read::object
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list idxC arrayC))
      (do phase.monad
        [[var_id varT] (typeA.with_env check.var)
         _ (typeA.infer varT)
         arrayA (typeA.with_type (.type (array.Array varT))
                  (analyse archive arrayC))
         varT (typeA.with_env
                (check.clean varT))
         arrayJT (jvm_array_type (.type (array.Array varT)))
         idxA (typeA.with_type ..int
                (analyse archive idxC))]
        (in {#/////analysis.Extension extension_name (list (/////analysis.text (..signature arrayJT))
                                                           idxA
                                                           arrayA)}))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 2 (list.size args)]))))

(def: (write_primitive_array_handler lux_type jvm_type)
  (-> .Type (Type Primitive) Handler)
  (let [array_type {#.Primitive (|> (jvm.array jvm_type) ..reflection)
                                (list)}]
    (function (_ extension_name analyse archive args)
      (case args
        (^ (list idxC valueC arrayC))
        (do phase.monad
          [_ (typeA.infer array_type)
           idxA (typeA.with_type ..int
                  (analyse archive idxC))
           valueA (typeA.with_type lux_type
                    (analyse archive valueC))
           arrayA (typeA.with_type array_type
                    (analyse archive arrayC))]
          (in {#/////analysis.Extension extension_name (list idxA
                                                             valueA
                                                             arrayA)}))

        _
        (/////analysis.except ///.incorrect_arity [extension_name 3 (list.size args)])))))

(def: array::write::object
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list idxC valueC arrayC))
      (do phase.monad
        [[var_id varT] (typeA.with_env check.var)
         _ (typeA.infer (.type (array.Array varT)))
         arrayA (typeA.with_type (.type (array.Array varT))
                  (analyse archive arrayC))
         varT (typeA.with_env
                (check.clean varT))
         arrayJT (jvm_array_type (.type (array.Array varT)))
         idxA (typeA.with_type ..int
                (analyse archive idxC))
         valueA (typeA.with_type varT
                  (analyse archive valueC))]
        (in {#/////analysis.Extension extension_name (list (/////analysis.text (..signature arrayJT))
                                                           idxA
                                                           valueA
                                                           arrayA)}))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 3 (list.size args)]))))

(def: bundle::array
  Bundle
  (<| (///bundle.prefix "array")
      (|> ///bundle.empty
          (dictionary.merged (<| (///bundle.prefix "length")
                                 (|> ///bundle.empty
                                     (///bundle.install (reflection.reflection reflection.boolean) (primitive_array_length_handler jvm.boolean))
                                     (///bundle.install (reflection.reflection reflection.byte) (primitive_array_length_handler jvm.byte))
                                     (///bundle.install (reflection.reflection reflection.short) (primitive_array_length_handler jvm.short))
                                     (///bundle.install (reflection.reflection reflection.int) (primitive_array_length_handler jvm.int))
                                     (///bundle.install (reflection.reflection reflection.long) (primitive_array_length_handler jvm.long))
                                     (///bundle.install (reflection.reflection reflection.float) (primitive_array_length_handler jvm.float))
                                     (///bundle.install (reflection.reflection reflection.double) (primitive_array_length_handler jvm.double))
                                     (///bundle.install (reflection.reflection reflection.char) (primitive_array_length_handler jvm.char))
                                     (///bundle.install "object" array::length::object))))
          (dictionary.merged (<| (///bundle.prefix "new")
                                 (|> ///bundle.empty
                                     (///bundle.install (reflection.reflection reflection.boolean) (new_primitive_array_handler jvm.boolean))
                                     (///bundle.install (reflection.reflection reflection.byte) (new_primitive_array_handler jvm.byte))
                                     (///bundle.install (reflection.reflection reflection.short) (new_primitive_array_handler jvm.short))
                                     (///bundle.install (reflection.reflection reflection.int) (new_primitive_array_handler jvm.int))
                                     (///bundle.install (reflection.reflection reflection.long) (new_primitive_array_handler jvm.long))
                                     (///bundle.install (reflection.reflection reflection.float) (new_primitive_array_handler jvm.float))
                                     (///bundle.install (reflection.reflection reflection.double) (new_primitive_array_handler jvm.double))
                                     (///bundle.install (reflection.reflection reflection.char) (new_primitive_array_handler jvm.char))
                                     (///bundle.install "object" array::new::object))))
          (dictionary.merged (<| (///bundle.prefix "read")
                                 (|> ///bundle.empty
                                     (///bundle.install (reflection.reflection reflection.boolean) (read_primitive_array_handler ..boolean jvm.boolean))
                                     (///bundle.install (reflection.reflection reflection.byte) (read_primitive_array_handler ..byte jvm.byte))
                                     (///bundle.install (reflection.reflection reflection.short) (read_primitive_array_handler ..short jvm.short))
                                     (///bundle.install (reflection.reflection reflection.int) (read_primitive_array_handler ..int jvm.int))
                                     (///bundle.install (reflection.reflection reflection.long) (read_primitive_array_handler ..long jvm.long))
                                     (///bundle.install (reflection.reflection reflection.float) (read_primitive_array_handler ..float jvm.float))
                                     (///bundle.install (reflection.reflection reflection.double) (read_primitive_array_handler ..double jvm.double))
                                     (///bundle.install (reflection.reflection reflection.char) (read_primitive_array_handler ..char jvm.char))
                                     (///bundle.install "object" array::read::object))))
          (dictionary.merged (<| (///bundle.prefix "write")
                                 (|> ///bundle.empty
                                     (///bundle.install (reflection.reflection reflection.boolean) (write_primitive_array_handler ..boolean jvm.boolean))
                                     (///bundle.install (reflection.reflection reflection.byte) (write_primitive_array_handler ..byte jvm.byte))
                                     (///bundle.install (reflection.reflection reflection.short) (write_primitive_array_handler ..short jvm.short))
                                     (///bundle.install (reflection.reflection reflection.int) (write_primitive_array_handler ..int jvm.int))
                                     (///bundle.install (reflection.reflection reflection.long) (write_primitive_array_handler ..long jvm.long))
                                     (///bundle.install (reflection.reflection reflection.float) (write_primitive_array_handler ..float jvm.float))
                                     (///bundle.install (reflection.reflection reflection.double) (write_primitive_array_handler ..double jvm.double))
                                     (///bundle.install (reflection.reflection reflection.char) (write_primitive_array_handler ..char jvm.char))
                                     (///bundle.install "object" array::write::object))))
          )))

(def: object::null
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list))
      (do phase.monad
        [expectedT (///.lifted meta.expected_type)
         _ (check_object expectedT)]
        (in {#/////analysis.Extension extension_name (list)}))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 0 (list.size args)]))))

(def: object::null?
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list objectC))
      (do phase.monad
        [_ (typeA.infer Bit)
         [objectT objectA] (typeA.with_inference
                             (analyse archive objectC))
         _ (check_object objectT)]
        (in {#/////analysis.Extension extension_name (list objectA)}))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: object::synchronized
  Handler
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list monitorC exprC))
      (do phase.monad
        [[monitorT monitorA] (typeA.with_inference
                               (analyse archive monitorC))
         _ (check_object monitorT)
         exprA (analyse archive exprC)]
        (in {#/////analysis.Extension extension_name (list monitorA exprA)}))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 2 (list.size args)]))))

(def: (object::throw class_loader)
  (-> java/lang/ClassLoader Handler)
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list exceptionC))
      (do phase.monad
        [_ (typeA.infer Nothing)
         [exceptionT exceptionA] (typeA.with_inference
                                   (analyse archive exceptionC))
         exception_class (check_object exceptionT)
         ? (phase.lifted (reflection!.sub? class_loader "java.lang.Throwable" exception_class))
         _ (: (Operation Any)
              (if ?
                (in [])
                (/////analysis.except non_throwable exception_class)))]
        (in {#/////analysis.Extension extension_name (list exceptionA)}))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: (object::class class_loader)
  (-> java/lang/ClassLoader Handler)
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list classC))
      (case classC
        [_ {#.Text class}]
        (do phase.monad
          [_ (..ensure_fresh_class! class_loader class)
           _ (typeA.infer {#.Primitive "java.lang.Class" (list {#.Primitive class (list)})})
           _ (phase.lifted (reflection!.load class_loader class))]
          (in {#/////analysis.Extension extension_name (list (/////analysis.text class))}))

        _
        (/////analysis.except ///.invalid_syntax [extension_name %.code args]))

      _
      (/////analysis.except ///.incorrect_arity [extension_name 1 (list.size args)]))))

(def: (object::instance? class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and <code>.text <code>.any)
    (function (_ extension_name analyse archive [sub_class objectC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader sub_class)
         _ (typeA.infer Bit)
         [objectT objectA] (typeA.with_inference
                             (analyse archive objectC))
         object_class (check_object objectT)
         ? (phase.lifted (reflection!.sub? class_loader object_class sub_class))]
        (if ?
          (in {#/////analysis.Extension extension_name (list (/////analysis.text sub_class) objectA)})
          (/////analysis.except cannot_possibly_be_an_instance (format sub_class " !<= "  object_class)))))]))

(template [<name> <category> <parser>]
  [(def: .public (<name> mapping typeJ)
     (-> Mapping (Type <category>) (Operation .Type))
     (case (|> typeJ ..signature (<text>.result (<parser> mapping)))
       {#try.Success check}
       (typeA.with_env
         check)
       
       {#try.Failure error}
       (phase.failure error)))]

  [boxed_reflection_type Value luxT.boxed_type]
  [reflection_type Value luxT.type]
  [boxed_reflection_return Return luxT.boxed_return]
  [reflection_return Return luxT.return]
  )

(def: (class_candidate_parents class_loader source_name fromT target_name target_class)
  (-> java/lang/ClassLoader External .Type External (java/lang/Class java/lang/Object) (Operation (List [[Text .Type] Bit])))
  (do [! phase.monad]
    [source_class (phase.lifted (reflection!.load class_loader source_name))
     mapping (phase.lifted (reflection!.correspond source_class fromT))]
    (monad.each !
                (function (_ superJT)
                  (do !
                    [superJT (phase.lifted (reflection!.type superJT))
                     .let [super_name (|> superJT ..reflection)]
                     super_class (phase.lifted (reflection!.load class_loader super_name))
                     superT (reflection_type mapping superJT)]
                    (in [[super_name superT] (java/lang/Class::isAssignableFrom super_class target_class)])))
                (case (java/lang/Class::getGenericSuperclass source_class)
                  {#.Some super}
                  (list& super (array.list #.None (java/lang/Class::getGenericInterfaces source_class)))

                  #.None
                  (if (java/lang/reflect/Modifier::isInterface (java/lang/Class::getModifiers source_class))
                    {#.Item (:as java/lang/reflect/Type (ffi.class_for java/lang/Object))
                            (array.list #.None (java/lang/Class::getGenericInterfaces source_class))}
                    (array.list #.None (java/lang/Class::getGenericInterfaces source_class)))))))

(def: (inheritance_candidate_parents class_loader fromT target_class toT fromC)
  (-> java/lang/ClassLoader .Type (java/lang/Class java/lang/Object) .Type Code (Operation (List [[Text .Type] Bit])))
  (case fromT
    (^ {#.Primitive _ (list& self_classT super_classT super_interfacesT+)})
    (monad.each phase.monad
                (function (_ superT)
                  (do [! phase.monad]
                    [super_name (\ ! each ..reflection (check_jvm superT))
                     super_class (phase.lifted (reflection!.load class_loader super_name))]
                    (in [[super_name superT]
                         (java/lang/Class::isAssignableFrom super_class target_class)])))
                (list& super_classT super_interfacesT+))

    _
    (/////analysis.except ..cannot_cast [fromT toT fromC])))

(def: (object::cast class_loader)
  (-> java/lang/ClassLoader Handler)
  (function (_ extension_name analyse archive args)
    (case args
      (^ (list fromC))
      (do [! phase.monad]
        [toT (///.lifted meta.expected_type)
         target_name (\ ! each ..reflection (check_jvm toT))
         [fromT fromA] (typeA.with_inference
                         (analyse archive fromC))
         source_name (\ ! each ..reflection (check_jvm fromT))
         can_cast? (: (Operation Bit)
                      (`` (cond (~~ (template [<primitive> <object>]
                                      [(let [=primitive (reflection.reflection <primitive>)]
                                         (or (and (text\= =primitive source_name)
                                                  (or (text\= <object> target_name)
                                                      (text\= =primitive target_name)))
                                             (and (text\= <object> source_name)
                                                  (text\= =primitive target_name))))
                                       (in true)]

                                      [reflection.boolean box.boolean]
                                      [reflection.byte    box.byte]
                                      [reflection.short   box.short]
                                      [reflection.int     box.int]
                                      [reflection.long    box.long]
                                      [reflection.float   box.float]
                                      [reflection.double  box.double]
                                      [reflection.char    box.char]))

                                ... else
                                (do !
                                  [_ (phase.assertion ..primitives_are_not_objects [source_name]
                                                      (not (dictionary.key? ..boxes source_name)))
                                   _ (phase.assertion ..primitives_are_not_objects [target_name]
                                                      (not (dictionary.key? ..boxes target_name)))
                                   target_class (phase.lifted (reflection!.load class_loader target_name))
                                   _ (if (text\= ..inheritance_relationship_type_name source_name)
                                       (in [])
                                       (do !
                                         [source_class (phase.lifted (reflection!.load class_loader source_name))]
                                         (phase.assertion ..cannot_cast [fromT toT fromC]
                                                          (java/lang/Class::isAssignableFrom source_class target_class))))]
                                  (loop [[current_name currentT] [source_name fromT]]
                                    (if (text\= target_name current_name)
                                      (in true)
                                      (do !
                                        [candidate_parents (: (Operation (List [[Text .Type] Bit]))
                                                              (if (text\= ..inheritance_relationship_type_name current_name)
                                                                (inheritance_candidate_parents class_loader currentT target_class toT fromC)
                                                                (class_candidate_parents class_loader current_name currentT target_name target_class)))]
                                        (case (|> candidate_parents
                                                  (list.only product.right)
                                                  (list\each product.left))
                                          {#.Item [next_name nextT] _}
                                          (recur [next_name nextT])

                                          #.End
                                          (in false)))))))))]
        (if can_cast?
          (in {#/////analysis.Extension extension_name (list (/////analysis.text source_name)
                                                             (/////analysis.text target_name)
                                                             fromA)})
          (/////analysis.except ..cannot_cast [fromT toT fromC])))

      _
      (/////analysis.except ///.invalid_syntax [extension_name %.code args]))))

(def: (bundle::object class_loader)
  (-> java/lang/ClassLoader Bundle)
  (<| (///bundle.prefix "object")
      (|> ///bundle.empty
          (///bundle.install "null" object::null)
          (///bundle.install "null?" object::null?)
          (///bundle.install "synchronized" object::synchronized)
          (///bundle.install "throw" (object::throw class_loader))
          (///bundle.install "class" (object::class class_loader))
          (///bundle.install "instance?" (object::instance? class_loader))
          (///bundle.install "cast" (object::cast class_loader))
          )))

(def: (get::static class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [..member
    (function (_ extension_name analyse archive [class field])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         [final? deprecated? fieldJT] (phase.lifted
                                       (do try.monad
                                         [class (reflection!.load class_loader class)]
                                         (reflection!.static_field field class)))
         _ (phase.assertion ..deprecated_field [class field]
                            (not deprecated?))
         fieldT (reflection_type luxT.fresh fieldJT)
         _ (typeA.infer fieldT)]
        (in (<| {#/////analysis.Extension extension_name}
                (list (/////analysis.text class)
                      (/////analysis.text field)
                      (/////analysis.text (|> fieldJT ..reflection)))))))]))

(def: (put::static class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..member <code>.any)
    (function (_ extension_name analyse archive [[class field] valueC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         _ (typeA.infer Any)
         [final? deprecated? fieldJT] (phase.lifted
                                       (do try.monad
                                         [class (reflection!.load class_loader class)]
                                         (reflection!.static_field field class)))
         _ (phase.assertion ..deprecated_field [class field]
                            (not deprecated?))
         _ (phase.assertion ..cannot_set_a_final_field [class field]
                            (not final?))
         fieldT (reflection_type luxT.fresh fieldJT)
         valueA (typeA.with_type fieldT
                  (analyse archive valueC))]
        (in (<| {#/////analysis.Extension extension_name}
                (list (/////analysis.text class)
                      (/////analysis.text field)
                      valueA)))))]))

(def: (get::virtual class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..member <code>.any)
    (function (_ extension_name analyse archive [[class field] objectC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         [objectT objectA] (typeA.with_inference
                             (analyse archive objectC))
         [deprecated? mapping fieldJT] (phase.lifted
                                        (do try.monad
                                          [class (reflection!.load class_loader class)
                                           [final? deprecated? fieldJT] (reflection!.virtual_field field class)
                                           mapping (reflection!.correspond class objectT)]
                                          (in [deprecated? mapping fieldJT])))
         _ (phase.assertion ..deprecated_field [class field]
                            (not deprecated?))
         fieldT (reflection_type mapping fieldJT)
         _ (typeA.infer fieldT)]
        (in (<| {#/////analysis.Extension extension_name}
                (list (/////analysis.text class)
                      (/////analysis.text field)
                      (/////analysis.text (..reflection fieldJT))
                      objectA)))))]))

(def: (put::virtual class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..member <code>.any <code>.any)
    (function (_ extension_name analyse archive [[class field] valueC objectC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         [objectT objectA] (typeA.with_inference
                             (analyse archive objectC))
         _ (typeA.infer objectT)
         [final? deprecated? mapping fieldJT] (phase.lifted
                                               (do try.monad
                                                 [class (reflection!.load class_loader class)
                                                  [final? deprecated? fieldJT] (reflection!.virtual_field field class)
                                                  mapping (reflection!.correspond class objectT)]
                                                 (in [final? deprecated? mapping fieldJT])))
         _ (phase.assertion ..deprecated_field [class field]
                            (not deprecated?))
         _ (phase.assertion ..cannot_set_a_final_field [class field]
                            (not final?))
         fieldT (reflection_type mapping fieldJT)
         valueA (typeA.with_type fieldT
                  (analyse archive valueC))]
        (in (<| {#/////analysis.Extension extension_name}
                (list (/////analysis.text class)
                      (/////analysis.text field)
                      (/////analysis.text (..reflection fieldJT))
                      valueA
                      objectA)))))]))

(type: Method_Style
  (Variant
   #Static
   #Abstract
   #Virtual
   #Special
   #Interface))

(def: (check_method aliasing class method_name method_style inputsJT method)
  (-> Aliasing (java/lang/Class java/lang/Object) Text Method_Style (List (Type Value)) java/lang/reflect/Method (Operation Bit))
  (do phase.monad
    [parameters (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                    (array.list #.None)
                    (monad.each try.monad reflection!.type)
                    phase.lifted)
     .let [modifiers (java/lang/reflect/Method::getModifiers method)
           correct_class? (java/lang/Object::equals class (java/lang/reflect/Method::getDeclaringClass method))
           correct_method? (text\= method_name (java/lang/reflect/Method::getName method))
           static_matches? (case method_style
                             #Static
                             (java/lang/reflect/Modifier::isStatic modifiers)

                             _
                             true)
           special_matches? (case method_style
                              #Special
                              (not (or (java/lang/reflect/Modifier::isInterface (java/lang/Class::getModifiers class))
                                       (java/lang/reflect/Modifier::isAbstract modifiers)))

                              _
                              true)
           arity_matches? (n.= (list.size inputsJT) (list.size parameters))
           inputs_match? (and arity_matches?
                              (list\mix (function (_ [expectedJC actualJC] prev)
                                          (and prev
                                               (jvm\= expectedJC (: (Type Value)
                                                                    (case (jvm_parser.var? actualJC)
                                                                      {#.Some name}
                                                                      (|> aliasing
                                                                          (dictionary.value name)
                                                                          (maybe.else name)
                                                                          jvm.var)

                                                                      #.None
                                                                      actualJC)))))
                                        true
                                        (list.zipped/2 parameters inputsJT)))]]
    (in (and correct_class?
             correct_method?
             static_matches?
             special_matches?
             arity_matches?
             inputs_match?))))

(def: (check_constructor aliasing class inputsJT constructor)
  (-> Aliasing (java/lang/Class java/lang/Object) (List (Type Value)) (java/lang/reflect/Constructor java/lang/Object) (Operation Bit))
  (do phase.monad
    [parameters (|> (java/lang/reflect/Constructor::getGenericParameterTypes constructor)
                    (array.list #.None)
                    (monad.each try.monad reflection!.type)
                    phase.lifted)]
    (in (and (java/lang/Object::equals class (java/lang/reflect/Constructor::getDeclaringClass constructor))
             (n.= (list.size inputsJT) (list.size parameters))
             (list.every? (function (_ [expectedJC actualJC])
                            (jvm\= expectedJC (: (Type Value)
                                                 (case (jvm_parser.var? actualJC)
                                                   {#.Some name}
                                                   (|> aliasing
                                                       (dictionary.value name)
                                                       (maybe.else name)
                                                       jvm.var)

                                                   #.None
                                                   actualJC))))
                          (list.zipped/2 parameters inputsJT))))))

(def: index_parameter
  (-> Nat .Type)
  (|>> (n.* 2) ++ #.Parameter))

(def: (jvm_type_var_mapping owner_tvars method_tvars)
  (-> (List Text) (List Text) [(List .Type) Mapping])
  (let [jvm_tvars (list\composite owner_tvars method_tvars)
        lux_tvars (|> jvm_tvars
                      list.reversed
                      list.enumeration
                      (list\each (function (_ [idx name])
                                   [name (index_parameter idx)]))
                      list.reversed)
        num_owner_tvars (list.size owner_tvars)
        owner_tvarsT (|> lux_tvars (list.first num_owner_tvars) (list\each product.right))
        mapping (dictionary.of_list text.hash lux_tvars)]
    [owner_tvarsT mapping]))

(def: (method_signature method_style method)
  (-> Method_Style java/lang/reflect/Method (Operation Method_Signature))
  (let [owner (java/lang/reflect/Method::getDeclaringClass method)
        owner_tvars (case method_style
                      #Static
                      (list)

                      _
                      (|> (java/lang/Class::getTypeParameters owner)
                          (array.list #.None)
                          (list\each (|>> java/lang/reflect/TypeVariable::getName))))
        method_tvars (|> (java/lang/reflect/Method::getTypeParameters method)
                         (array.list #.None)
                         (list\each (|>> java/lang/reflect/TypeVariable::getName)))
        [owner_tvarsT mapping] (jvm_type_var_mapping owner_tvars method_tvars)]
    (do [! phase.monad]
      [inputsT (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                   (array.list #.None)
                   (monad.each ! (|>> reflection!.type phase.lifted))
                   (phase\each (monad.each ! (..reflection_type mapping)))
                   phase\conjoint)
       outputT (|> method
                   java/lang/reflect/Method::getGenericReturnType
                   reflection!.return
                   phase.lifted
                   (phase\each (..reflection_return mapping))
                   phase\conjoint)
       exceptionsT (|> (java/lang/reflect/Method::getGenericExceptionTypes method)
                       (array.list #.None)
                       (monad.each ! (|>> reflection!.type phase.lifted))
                       (phase\each (monad.each ! (..reflection_type mapping)))
                       phase\conjoint)
       .let [methodT (<| (type.univ_q (dictionary.size mapping))
                         (type.function (case method_style
                                          #Static
                                          inputsT

                                          _
                                          (list& {#.Primitive (java/lang/Class::getName owner) owner_tvarsT}
                                                 inputsT)))
                         outputT)]]
      (in [methodT
           (reflection!.deprecated? (java/lang/reflect/Method::getDeclaredAnnotations method))
           exceptionsT]))))

(def: (constructor_signature constructor)
  (-> (java/lang/reflect/Constructor java/lang/Object) (Operation Method_Signature))
  (let [owner (java/lang/reflect/Constructor::getDeclaringClass constructor)
        owner_tvars (|> (java/lang/Class::getTypeParameters owner)
                        (array.list #.None)
                        (list\each (|>> java/lang/reflect/TypeVariable::getName)))
        method_tvars (|> (java/lang/reflect/Constructor::getTypeParameters constructor)
                         (array.list #.None)
                         (list\each (|>> java/lang/reflect/TypeVariable::getName)))
        [owner_tvarsT mapping] (jvm_type_var_mapping owner_tvars method_tvars)]
    (do [! phase.monad]
      [inputsT (|> (java/lang/reflect/Constructor::getGenericParameterTypes constructor)
                   (array.list #.None)
                   (monad.each ! (|>> reflection!.type phase.lifted))
                   (phase\each (monad.each ! (reflection_type mapping)))
                   phase\conjoint)
       exceptionsT (|> (java/lang/reflect/Constructor::getGenericExceptionTypes constructor)
                       (array.list #.None)
                       (monad.each ! (|>> reflection!.type phase.lifted))
                       (phase\each (monad.each ! (reflection_type mapping)))
                       phase\conjoint)
       .let [objectT {#.Primitive (java/lang/Class::getName owner) owner_tvarsT}
             constructorT (<| (type.univ_q (dictionary.size mapping))
                              (type.function inputsT)
                              objectT)]]
      (in [constructorT
           (reflection!.deprecated? (java/lang/reflect/Constructor::getDeclaredAnnotations constructor))
           exceptionsT]))))

(type: Evaluation
  (Variant
   {#Pass Method_Signature}
   {#Hint Method_Signature}))

(template [<name> <tag>]
  [(def: <name>
     (-> Evaluation (Maybe Method_Signature))
     (|>> (case> {<tag> output}
                 {#.Some output}

                 _
                 #.None)))]

  [pass! #Pass]
  [hint! #Hint]
  )

(template [<name> <type> <method>]
  [(def: <name>
     (-> <type> (List (Type Var)))
     (|>> <method>
          (array.list #.None)
          (list\each (|>> java/lang/reflect/TypeVariable::getName jvm.var))))]

  [class_type_variables (java/lang/Class java/lang/Object) java/lang/Class::getTypeParameters]
  [constructor_type_variables (java/lang/reflect/Constructor java/lang/Object) java/lang/reflect/Constructor::getTypeParameters]
  [method_type_variables java/lang/reflect/Method java/lang/reflect/Method::getTypeParameters]
  )

(def: (aliasing expected actual)
  (-> (List (Type Var)) (List (Type Var)) Aliasing)
  (|> (list.zipped/2 (list\each jvm_parser.name actual)
                     (list\each jvm_parser.name expected))
      (dictionary.of_list text.hash)))

(def: (method_candidate class_loader actual_class_tvars class_name actual_method_tvars method_name method_style inputsJT)
  (-> java/lang/ClassLoader (List (Type Var)) External (List (Type Var)) Text Method_Style (List (Type Value)) (Operation Method_Signature))
  (do [! phase.monad]
    [class (phase.lifted (reflection!.load class_loader class_name))
     .let [expected_class_tvars (class_type_variables class)]
     candidates (|> class
                    java/lang/Class::getDeclaredMethods
                    (array.list #.None)
                    (list.only (|>> java/lang/reflect/Method::getName (text\= method_name)))
                    (monad.each ! (: (-> java/lang/reflect/Method (Operation Evaluation))
                                     (function (_ method)
                                       (do !
                                         [.let [expected_method_tvars (method_type_variables method)
                                                aliasing (dictionary.merged (..aliasing expected_class_tvars actual_class_tvars)
                                                                            (..aliasing expected_method_tvars actual_method_tvars))]
                                          passes? (check_method aliasing class method_name method_style inputsJT method)]
                                         (\ ! each (if passes?
                                                     (|>> #Pass)
                                                     (|>> #Hint))
                                            (method_signature method_style method)))))))]
    (case (list.all pass! candidates)
      {#.Item method #.End}
      (in method)

      #.End
      (/////analysis.except ..no_candidates [class_name method_name inputsJT (list.all hint! candidates)])
      
      candidates
      (/////analysis.except ..too_many_candidates [class_name method_name inputsJT candidates]))))

(def: constructor_method
  "<init>")

(def: (constructor_candidate class_loader actual_class_tvars class_name actual_method_tvars inputsJT)
  (-> java/lang/ClassLoader (List (Type Var)) External (List (Type Var)) (List (Type Value)) (Operation Method_Signature))
  (do [! phase.monad]
    [class (phase.lifted (reflection!.load class_loader class_name))
     .let [expected_class_tvars (class_type_variables class)]
     candidates (|> class
                    java/lang/Class::getConstructors
                    (array.list #.None)
                    (monad.each ! (function (_ constructor)
                                    (do !
                                      [.let [expected_method_tvars (constructor_type_variables constructor)
                                             aliasing (dictionary.merged (..aliasing expected_class_tvars actual_class_tvars)
                                                                         (..aliasing expected_method_tvars actual_method_tvars))]
                                       passes? (check_constructor aliasing class inputsJT constructor)]
                                      (\ ! each
                                         (if passes? (|>> #Pass) (|>> #Hint))
                                         (constructor_signature constructor))))))]
    (case (list.all pass! candidates)
      {#.Item constructor #.End}
      (in constructor)

      #.End
      (/////analysis.except ..no_candidates [class_name ..constructor_method inputsJT (list.all hint! candidates)])
      
      candidates
      (/////analysis.except ..too_many_candidates [class_name ..constructor_method inputsJT candidates]))))

(template [<name> <category> <parser>]
  [(def: .public <name>
     (Parser (Type <category>))
     (<text>.then <parser> <code>.text))]

  [var Var jvm_parser.var]
  [class Class jvm_parser.class]
  [type Value jvm_parser.value]
  [return Return jvm_parser.return]
  )

(def: input
  (Parser (Typed Code))
  (<code>.tuple (<>.and ..type <code>.any)))

(def: (decorate_inputs typesT inputsA)
  (-> (List (Type Value)) (List Analysis) (List Analysis))
  (|> inputsA
      (list.zipped/2 (list\each (|>> ..signature /////analysis.text) typesT))
      (list\each (function (_ [type value])
                   (/////analysis.tuple (list type value))))))

(def: type_vars
  (<code>.tuple (<>.some ..var)))

(def: (invoke::static class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..type_vars ..member ..type_vars (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class method] method_tvars argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         .let [argsT (list\each product.left argsTC)]
         [methodT deprecated? exceptionsT] (..method_candidate class_loader class_tvars class method_tvars method #Static argsT)
         _ (phase.assertion ..deprecated_method [class method methodT]
                            (not deprecated?))
         [outputT argsA] (inferenceA.general archive analyse methodT (list\each product.right argsTC))
         outputJT (check_return outputT)]
        (in {#/////analysis.Extension extension_name (list& (/////analysis.text (..signature (jvm.class class (list))))
                                                            (/////analysis.text method)
                                                            (/////analysis.text (..signature outputJT))
                                                            (decorate_inputs argsT argsA))})))]))

(def: (invoke::virtual class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..type_vars ..member ..type_vars <code>.any (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class method] method_tvars objectC argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         .let [argsT (list\each product.left argsTC)]
         [methodT deprecated? exceptionsT] (..method_candidate class_loader class_tvars class method_tvars method #Virtual argsT)
         _ (phase.assertion ..deprecated_method [class method methodT]
                            (not deprecated?))
         [outputT allA] (inferenceA.general archive analyse methodT (list& objectC (list\each product.right argsTC)))
         .let [[objectA argsA] (case allA
                                 {#.Item objectA argsA}
                                 [objectA argsA]

                                 _
                                 (undefined))]
         outputJT (check_return outputT)]
        (in {#/////analysis.Extension extension_name (list& (/////analysis.text (..signature (jvm.class class (list))))
                                                            (/////analysis.text method)
                                                            (/////analysis.text (..signature outputJT))
                                                            objectA
                                                            (decorate_inputs argsT argsA))})))]))

(def: (invoke::special class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..type_vars ..member ..type_vars <code>.any (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class method] method_tvars objectC argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         .let [argsT (list\each product.left argsTC)]
         [methodT deprecated? exceptionsT] (..method_candidate class_loader class_tvars class method_tvars method #Special argsT)
         _ (phase.assertion ..deprecated_method [class method methodT]
                            (not deprecated?))
         [outputT argsA] (inferenceA.general archive analyse methodT (list& objectC (list\each product.right argsTC)))
         outputJT (check_return outputT)]
        (in {#/////analysis.Extension extension_name (list& (/////analysis.text (..signature (jvm.class class (list))))
                                                            (/////analysis.text method)
                                                            (/////analysis.text (..signature outputJT))
                                                            (decorate_inputs argsT argsA))})))]))

(def: (invoke::interface class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..type_vars ..member ..type_vars <code>.any (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars [class_name method] method_tvars objectC argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class_name)
         .let [argsT (list\each product.left argsTC)]
         class (phase.lifted (reflection!.load class_loader class_name))
         _ (phase.assertion non_interface class_name
                            (java/lang/reflect/Modifier::isInterface (java/lang/Class::getModifiers class)))
         [methodT deprecated? exceptionsT] (..method_candidate class_loader class_tvars class_name method_tvars method #Interface argsT)
         _ (phase.assertion ..deprecated_method [class_name method methodT]
                            (not deprecated?))
         [outputT allA] (inferenceA.general archive analyse methodT (list& objectC (list\each product.right argsTC)))
         .let [[objectA argsA] (case allA
                                 {#.Item objectA argsA}
                                 [objectA argsA]

                                 _
                                 (undefined))]
         outputJT (check_return outputT)]
        (in {#/////analysis.Extension extension_name
                                      (list& (/////analysis.text (..signature (jvm.class class_name (list))))
                                             (/////analysis.text method)
                                             (/////analysis.text (..signature outputJT))
                                             objectA
                                             (decorate_inputs argsT argsA))})))]))

(def: (invoke::constructor class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and ..type_vars <code>.text ..type_vars (<>.some ..input))
    (function (_ extension_name analyse archive [class_tvars class method_tvars argsTC])
      (do phase.monad
        [_ (..ensure_fresh_class! class_loader class)
         .let [argsT (list\each product.left argsTC)]
         [methodT deprecated? exceptionsT] (..constructor_candidate class_loader class_tvars class method_tvars argsT)
         _ (phase.assertion ..deprecated_method [class ..constructor_method methodT]
                            (not deprecated?))
         [outputT argsA] (inferenceA.general archive analyse methodT (list\each product.right argsTC))]
        (in {#/////analysis.Extension extension_name (list& (/////analysis.text (..signature (jvm.class class (list))))
                                                            (decorate_inputs argsT argsA))})))]))

(def: (bundle::member class_loader)
  (-> java/lang/ClassLoader Bundle)
  (<| (///bundle.prefix "member")
      (|> ///bundle.empty
          (dictionary.merged (<| (///bundle.prefix "get")
                                 (|> ///bundle.empty
                                     (///bundle.install "static" (get::static class_loader))
                                     (///bundle.install "virtual" (get::virtual class_loader)))))
          (dictionary.merged (<| (///bundle.prefix "put")
                                 (|> ///bundle.empty
                                     (///bundle.install "static" (put::static class_loader))
                                     (///bundle.install "virtual" (put::virtual class_loader)))))
          (dictionary.merged (<| (///bundle.prefix "invoke")
                                 (|> ///bundle.empty
                                     (///bundle.install "static" (invoke::static class_loader))
                                     (///bundle.install "virtual" (invoke::virtual class_loader))
                                     (///bundle.install "special" (invoke::special class_loader))
                                     (///bundle.install "interface" (invoke::interface class_loader))
                                     (///bundle.install "constructor" (invoke::constructor class_loader))
                                     )))
          )))

(type: .public (Annotation_Parameter a)
  [Text a])

(def: annotation_parameter
  (Parser (Annotation_Parameter Code))
  (<code>.tuple (<>.and <code>.text <code>.any)))

(type: .public (Annotation a)
  [Text (List (Annotation_Parameter a))])

(def: .public annotation
  (Parser (Annotation Code))
  (<code>.form (<>.and <code>.text (<>.some ..annotation_parameter))))

(def: .public argument
  (Parser Argument)
  (<code>.tuple (<>.and <code>.text ..type)))

(def: (annotation_parameter_analysis [name value])
  (-> (Annotation_Parameter Analysis) Analysis)
  (/////analysis.tuple (list (/////analysis.text name) value)))

(def: (annotation_analysis [name parameters])
  (-> (Annotation Analysis) Analysis)
  (/////analysis.tuple (list& (/////analysis.text name)
                              (list\each annotation_parameter_analysis parameters))))

(template [<name> <category>]
  [(def: <name>
     (-> (Type <category>) Analysis)
     (|>> ..signature /////analysis.text))]

  [var_analysis Var]
  [class_analysis Class]
  [value_analysis Value]
  [return_analysis Return]
  )

(def: (typed_analysis [type term])
  (-> (Typed Analysis) Analysis)
  (/////analysis.tuple (list (value_analysis type) term)))

(def: (argument_analysis [argument argumentJT])
  (-> Argument Analysis)
  (/////analysis.tuple
   (list (/////analysis.text argument)
         (value_analysis argumentJT))))

(template [<name> <only>]
  [(def: <name>
     (-> (java/lang/Class java/lang/Object)
         (Try (List [Text (Type Method)])))
     (|>> java/lang/Class::getDeclaredMethods
          (array.list #.None)
          <only>
          (monad.each try.monad
                      (function (_ method)
                        (do [! try.monad]
                          [.let [type_variables (|> (java/lang/reflect/Method::getTypeParameters method)
                                                    (array.list #.None)
                                                    (list\each (|>> java/lang/reflect/TypeVariable::getName
                                                                    jvm.var)))]
                           inputs (|> (java/lang/reflect/Method::getGenericParameterTypes method)
                                      (array.list #.None)
                                      (monad.each ! reflection!.type))
                           return (|> method
                                      java/lang/reflect/Method::getGenericReturnType
                                      reflection!.return)
                           exceptions (|> (java/lang/reflect/Method::getGenericExceptionTypes method)
                                          (array.list #.None)
                                          (monad.each ! reflection!.class))]
                          (in [(java/lang/reflect/Method::getName method)
                               (jvm.method [type_variables inputs return exceptions])]))))))]

  [abstract_methods (list.only (|>> java/lang/reflect/Method::getModifiers java/lang/reflect/Modifier::isAbstract))]
  [methods (<|)]
  )

(def: jvm_package_separator ".")

(template [<name> <methods>]
  [(def: (<name> class_loader)
     (-> java/lang/ClassLoader (List (Type Class)) (Try (List [Text (Type Method)])))
     (|>> (monad.each try.monad (|>> ..reflection (reflection!.load class_loader)))
          (try\each (monad.each try.monad <methods>))
          try\conjoint
          (try\each list\conjoint)))]

  [all_abstract_methods ..abstract_methods]
  [all_methods ..methods]
  )

(template [<name>]
  [(exception: .public (<name> [methods (List [Text (Type Method)])])
     (exception.report
      ["Methods" (exception.listing
                  (function (_ [name type])
                    (format (%.text name) " " (..signature type)))
                  methods)]))]

  [missing_abstract_methods]
  [invalid_overriden_methods]
  )

(type: .public Visibility
  (Variant
   #Public
   #Private
   #Protected
   #Default))

(type: .public Finality Bit)
(type: .public Strictness Bit)

(def: .public public_tag "public")
(def: .public private_tag "private")
(def: .public protected_tag "protected")
(def: .public default_tag "default")

(def: .public visibility
  (Parser Visibility)
  ($_ <>.or
      (<code>.text! ..public_tag)
      (<code>.text! ..private_tag)
      (<code>.text! ..protected_tag)
      (<code>.text! ..default_tag)))

(def: .public (visibility_analysis visibility)
  (-> Visibility Analysis)
  (/////analysis.text (case visibility
                        #Public ..public_tag
                        #Private ..private_tag
                        #Protected ..protected_tag
                        #Default ..default_tag)))

(type: .public (Constructor a)
  [Visibility
   Strictness
   (List (Annotation a))
   (List (Type Var))
   (List (Type Class)) ... Exceptions
   Text
   (List Argument)
   (List (Typed a))
   a])

(def: .public constructor_tag "init")

(def: .public constructor_definition
  (Parser (Constructor Code))
  (<| <code>.form
      (<>.after (<code>.text! ..constructor_tag))
      ($_ <>.and
          ..visibility
          <code>.bit
          (<code>.tuple (<>.some ..annotation))
          (<code>.tuple (<>.some ..var))
          (<code>.tuple (<>.some ..class))
          <code>.text
          (<code>.tuple (<>.some ..argument))
          (<code>.tuple (<>.some ..input))
          <code>.any)))

(def: .public (analyse_constructor_method analyse archive selfT mapping method)
  (-> Phase Archive .Type Mapping (Constructor Code) (Operation Analysis))
  (let [[visibility strict_fp?
         annotations vars exceptions
         self_name arguments super_arguments body] method]
    (do [! phase.monad]
      [annotationsA (monad.each ! (function (_ [name parameters])
                                    (do !
                                      [parametersA (monad.each ! (function (_ [name value])
                                                                   (do !
                                                                     [valueA (analyse archive value)]
                                                                     (in [name valueA])))
                                                               parameters)]
                                      (in [name parametersA])))
                                annotations)
       super_arguments (monad.each ! (function (_ [jvmT super_argC])
                                       (do !
                                         [luxT (reflection_type mapping jvmT)
                                          super_argA (typeA.with_type luxT
                                                       (analyse archive super_argC))]
                                         (in [jvmT super_argA])))
                                   super_arguments)
       arguments' (monad.each !
                              (function (_ [name jvmT])
                                (do !
                                  [luxT (boxed_reflection_type mapping jvmT)]
                                  (in [name luxT])))
                              arguments)
       [scope bodyA] (|> arguments'
                         {#.Item [self_name selfT]}
                         list.reversed
                         (list\mix scope.with_local (analyse archive body))
                         (typeA.with_type .Any)
                         /////analysis.with_scope)]
      (in (/////analysis.tuple (list (/////analysis.text ..constructor_tag)
                                     (visibility_analysis visibility)
                                     (/////analysis.bit strict_fp?)
                                     (/////analysis.tuple (list\each annotation_analysis annotationsA))
                                     (/////analysis.tuple (list\each var_analysis vars))
                                     (/////analysis.text self_name)
                                     (/////analysis.tuple (list\each ..argument_analysis arguments))
                                     (/////analysis.tuple (list\each class_analysis exceptions))
                                     (/////analysis.tuple (list\each typed_analysis super_arguments))
                                     {#/////analysis.Function
                                      (list\each (|>> /////analysis.variable)
                                                 (scope.environment scope))
                                      (/////analysis.tuple (list bodyA))}
                                     ))))))

(type: .public (Virtual_Method a)
  [Text
   Visibility
   Finality
   Strictness
   (List (Annotation a))
   (List (Type Var))
   Text
   (List Argument)
   (Type Return)
   (List (Type Class)) ... Exceptions
   a])

(def: virtual_tag "virtual")

(def: .public virtual_method_definition
  (Parser (Virtual_Method Code))
  (<| <code>.form
      (<>.after (<code>.text! ..virtual_tag))
      ($_ <>.and
          <code>.text
          ..visibility
          <code>.bit
          <code>.bit
          (<code>.tuple (<>.some ..annotation))
          (<code>.tuple (<>.some ..var))
          <code>.text
          (<code>.tuple (<>.some ..argument))
          ..return
          (<code>.tuple (<>.some ..class))
          <code>.any)))

(def: .public (analyse_virtual_method analyse archive selfT mapping method)
  (-> Phase Archive .Type Mapping (Virtual_Method Code) (Operation Analysis))
  (let [[method_name visibility
         final? strict_fp? annotations vars
         self_name arguments return exceptions
         body] method]
    (do [! phase.monad]
      [annotationsA (monad.each ! (function (_ [name parameters])
                                    (do !
                                      [parametersA (monad.each ! (function (_ [name value])
                                                                   (do !
                                                                     [valueA (analyse archive value)]
                                                                     (in [name valueA])))
                                                               parameters)]
                                      (in [name parametersA])))
                                annotations)
       returnT (reflection_return mapping return)
       arguments' (monad.each !
                              (function (_ [name jvmT])
                                (do !
                                  [luxT (boxed_reflection_type mapping jvmT)]
                                  (in [name luxT])))
                              arguments)
       [scope bodyA] (|> arguments'
                         {#.Item [self_name selfT]}
                         list.reversed
                         (list\mix scope.with_local (analyse archive body))
                         (typeA.with_type returnT)
                         /////analysis.with_scope)]
      (in (/////analysis.tuple (list (/////analysis.text ..virtual_tag)
                                     (/////analysis.text method_name)
                                     (visibility_analysis visibility)
                                     (/////analysis.bit final?)
                                     (/////analysis.bit strict_fp?)
                                     (/////analysis.tuple (list\each annotation_analysis annotationsA))
                                     (/////analysis.tuple (list\each var_analysis vars))
                                     (/////analysis.text self_name)
                                     (/////analysis.tuple (list\each ..argument_analysis arguments))
                                     (return_analysis return)
                                     (/////analysis.tuple (list\each class_analysis exceptions))
                                     {#/////analysis.Function
                                      (list\each (|>> /////analysis.variable)
                                                 (scope.environment scope))
                                      (/////analysis.tuple (list bodyA))}
                                     ))))))

(type: .public (Static_Method a)
  [Text
   Visibility
   Strictness
   (List (Annotation a))
   (List (Type Var))
   (List (Type Class)) ... Exceptions
   (List Argument)
   (Type Return)
   a])

(def: .public static_tag "static")

(def: .public static_method_definition
  (Parser (Static_Method Code))
  (<| <code>.form
      (<>.after (<code>.text! ..static_tag))
      ($_ <>.and
          <code>.text
          ..visibility
          <code>.bit
          (<code>.tuple (<>.some ..annotation))
          (<code>.tuple (<>.some ..var))
          (<code>.tuple (<>.some ..class))
          (<code>.tuple (<>.some ..argument))
          ..return
          <code>.any)))

(def: .public (analyse_static_method analyse archive mapping method)
  (-> Phase Archive Mapping (Static_Method Code) (Operation Analysis))
  (let [[method_name visibility
         strict_fp? annotations vars exceptions
         arguments return
         body] method]
    (do [! phase.monad]
      [annotationsA (monad.each ! (function (_ [name parameters])
                                    (do !
                                      [parametersA (monad.each ! (function (_ [name value])
                                                                   (do !
                                                                     [valueA (analyse archive value)]
                                                                     (in [name valueA])))
                                                               parameters)]
                                      (in [name parametersA])))
                                annotations)
       returnT (reflection_return mapping return)
       arguments' (monad.each !
                              (function (_ [name jvmT])
                                (do !
                                  [luxT (boxed_reflection_type mapping jvmT)]
                                  (in [name luxT])))
                              arguments)
       [scope bodyA] (|> arguments'
                         list.reversed
                         (list\mix scope.with_local (analyse archive body))
                         (typeA.with_type returnT)
                         /////analysis.with_scope)]
      (in (/////analysis.tuple (list (/////analysis.text ..static_tag)
                                     (/////analysis.text method_name)
                                     (visibility_analysis visibility)
                                     (/////analysis.bit strict_fp?)
                                     (/////analysis.tuple (list\each annotation_analysis annotationsA))
                                     (/////analysis.tuple (list\each var_analysis vars))
                                     (/////analysis.tuple (list\each ..argument_analysis arguments))
                                     (return_analysis return)
                                     (/////analysis.tuple (list\each class_analysis
                                                                     exceptions))
                                     {#/////analysis.Function
                                      (list\each (|>> /////analysis.variable)
                                                 (scope.environment scope))
                                      (/////analysis.tuple (list bodyA))}
                                     ))))))

(type: .public (Overriden_Method a)
  [(Type Class)
   Text
   Bit
   (List (Annotation a))
   (List (Type Var))
   Text
   (List Argument)
   (Type Return)
   (List (Type Class))
   a])

(def: .public overriden_tag "override")

(def: .public overriden_method_definition
  (Parser (Overriden_Method Code))
  (<| <code>.form
      (<>.after (<code>.text! ..overriden_tag))
      ($_ <>.and
          ..class
          <code>.text
          <code>.bit
          (<code>.tuple (<>.some ..annotation))
          (<code>.tuple (<>.some ..var))
          <code>.text
          (<code>.tuple (<>.some ..argument))
          ..return
          (<code>.tuple (<>.some ..class))
          <code>.any
          )))

(exception: .public (unknown_super [name Text
                                    supers (List (Type Class))])
  (exception.report
   ["Name" (%.text name)]
   ["Available" (exception.listing (|>> jvm_parser.read_class product.left) supers)]))

(exception: .public (mismatched_super_parameters [name Text
                                                  expected Nat
                                                  actual Nat])
  (exception.report
   ["Name" (%.text name)]
   ["Expected" (%.nat expected)]
   ["Actual" (%.nat actual)]))

(def: (override_mapping mapping supers parent_type)
  (-> Mapping (List (Type Class)) (Type Class) (Operation (List [Text .Type])))
  (let [[parent_name parent_parameters] (jvm_parser.read_class parent_type)]
    (case (list.one (function (_ super)
                      (let [[super_name super_parameters] (jvm_parser.read_class super)]
                        (if (text\= parent_name super_name)
                          {#.Some super_parameters}
                          #.None)))
                    supers)
      {#.Some super_parameters}
      (let [expected_count (list.size parent_parameters)
            actual_count (list.size super_parameters)]
        (if (n.= expected_count actual_count)
          (do [! phase.monad]
            [parent_parameters (|> parent_parameters
                                   (monad.each maybe.monad jvm_parser.var?)
                                   try.of_maybe
                                   phase.lifted)]
            (|> super_parameters
                (monad.each ! (..reflection_type mapping))
                (\ ! each (|>> (list.zipped/2 parent_parameters)))))
          (phase.lifted (exception.except ..mismatched_super_parameters [parent_name expected_count actual_count]))))
      
      #.None
      (phase.lifted (exception.except ..unknown_super [parent_name supers])))))

(def: .public (with_fresh_type_vars vars mapping)
  (-> (List (Type Var)) Mapping (Operation Mapping))
  (do [! phase.monad]
    [pairings (monad.each ! (function (_ var)
                              (do !
                                [[_ exT] (typeA.with_env
                                           check.existential)]
                                (in [var exT])))
                          vars)]
    (in (list\mix (function (_ [varJ varT] mapping)
                    (dictionary.has (jvm_parser.name varJ) varT mapping))
                  mapping
                  pairings))))

(def: .public (with_override_mapping supers parent_type mapping)
  (-> (List (Type Class)) (Type Class) Mapping (Operation Mapping))
  (do phase.monad
    [override_mapping (..override_mapping mapping supers parent_type)]
    (in (list\mix (function (_ [super_var bound_type] mapping)
                    (dictionary.has super_var bound_type mapping))
                  mapping
                  override_mapping))))

(def: .public (hide_method_body arity bodyA)
  (-> Nat Analysis Analysis)
  (<| /////analysis.tuple
      (list (/////analysis.unit))
      (case arity
        (^or 0 1)
        bodyA
        
        2
        {#/////analysis.Case (/////analysis.unit)
                             [[#/////analysis.when
                               {#/////analysis.Bind 2}
                               
                               #/////analysis.then
                               bodyA]
                              (list)]}

        _
        {#/////analysis.Case (/////analysis.unit)
                             [[#/////analysis.when
                               {#/////analysis.Complex
                                {#/////analysis.Tuple (|> arity
                                                          list.indices
                                                          (list\each (|>> (n.+ 2) #/////analysis.Bind)))}}
                               
                               #/////analysis.then
                               bodyA]
                              (list)]})))

(def: .public (analyse_overriden_method analyse archive selfT mapping supers method)
  (-> Phase Archive .Type Mapping (List (Type Class)) (Overriden_Method Code) (Operation Analysis))
  (let [[parent_type method_name
         strict_fp? annotations vars
         self_name arguments return exceptions
         body] method]
    (do [! phase.monad]
      [mapping (..with_override_mapping supers parent_type mapping)
       mapping (..with_fresh_type_vars vars mapping)
       annotationsA (monad.each ! (function (_ [name parameters])
                                    (do !
                                      [parametersA (monad.each ! (function (_ [name value])
                                                                   (do !
                                                                     [valueA (analyse archive value)]
                                                                     (in [name valueA])))
                                                               parameters)]
                                      (in [name parametersA])))
                                annotations)
       arguments' (monad.each !
                              (function (_ [name jvmT])
                                (do !
                                  [luxT (boxed_reflection_type mapping jvmT)]
                                  (in [name luxT])))
                              arguments)
       returnT (boxed_reflection_return mapping return)
       [scope bodyA] (|> arguments'
                         {#.Item [self_name selfT]}
                         list.reversed
                         (list\mix scope.with_local (analyse archive body))
                         (typeA.with_type returnT)
                         /////analysis.with_scope)]
      (in (/////analysis.tuple (list (/////analysis.text ..overriden_tag)
                                     (class_analysis parent_type)
                                     (/////analysis.text method_name)
                                     (/////analysis.bit strict_fp?)
                                     (/////analysis.tuple (list\each annotation_analysis annotationsA))
                                     (/////analysis.tuple (list\each var_analysis vars))
                                     (/////analysis.text self_name)
                                     (/////analysis.tuple (list\each ..argument_analysis arguments))
                                     (return_analysis return)
                                     (/////analysis.tuple (list\each class_analysis
                                                                     exceptions))
                                     {#/////analysis.Function
                                      (list\each (|>> /////analysis.variable)
                                                 (scope.environment scope))
                                      (..hide_method_body (list.size arguments) bodyA)}
                                     ))))))

(type: .public (Method_Definition a)
  (Variant
   {#Overriden_Method (Overriden_Method a)}))

(def: .public parameter_types
  (-> (List (Type Var)) (Check (List [(Type Var) .Type])))
  (monad.each check.monad
              (function (_ parameterJ)
                (do check.monad
                  [[_ parameterT] check.existential]
                  (in [parameterJ parameterT])))))

(def: (mismatched_methods super_set sub_set)
  (-> (List [Text (Type Method)])
      (List [Text (Type Method)])
      (List [Text (Type Method)]))
  (list.only (function (_ [sub_name subJT])
               (|> super_set
                   (list.only (function (_ [super_name superJT])
                                (and (text\= super_name sub_name)
                                     (jvm\= superJT subJT))))
                   list.size
                   (n.= 1)
                   not))
             sub_set))

(exception: .public (class_parameter_mismatch [expected (List Text)
                                               actual (List (Type Parameter))])
  (exception.report
   ["Expected (amount)" (%.nat (list.size expected))]
   ["Expected (parameters)" (exception.listing %.text expected)]
   ["Actual (amount)" (%.nat (list.size actual))]
   ["Actual (parameters)" (exception.listing ..signature actual)]))

(def: (super_aliasing class_loader class)
  (-> java/lang/ClassLoader (Type Class) (Operation Aliasing))
  (do phase.monad
    [.let [[name actual_parameters] (jvm_parser.read_class class)]
     class (phase.lifted (reflection!.load class_loader name))
     .let [expected_parameters (|> (java/lang/Class::getTypeParameters class)
                                   (array.list #.None)
                                   (list\each (|>> java/lang/reflect/TypeVariable::getName)))]
     _ (phase.assertion ..class_parameter_mismatch [expected_parameters actual_parameters]
                        (n.= (list.size expected_parameters)
                             (list.size actual_parameters)))]
    (in (|> (list.zipped/2 expected_parameters actual_parameters)
            (list\mix (function (_ [expected actual] mapping)
                        (case (jvm_parser.var? actual)
                          {#.Some actual}
                          (dictionary.has actual expected mapping)
                          
                          #.None
                          mapping))
                      jvm_alias.fresh)))))

(def: (anonymous_class_name module id)
  (-> Module Nat Text)
  (let [global (text.replaced .module_separator ..jvm_package_separator module)
        local (format "anonymous-class" (%.nat id))]
    (format global ..jvm_package_separator local)))

(def: .public (require_complete_method_concretion class_loader supers methods)
  (-> java/lang/ClassLoader (List (Type Class)) (List (Overriden_Method Code)) (Operation Any))
  (do [! phase.monad]
    [required_abstract_methods (phase.lifted (all_abstract_methods class_loader supers))
     available_methods (phase.lifted (all_methods class_loader supers))
     overriden_methods (monad.each ! (function (_ [parent_type method_name
                                                   strict_fp? annotations type_vars
                                                   self_name arguments return exceptions
                                                   body])
                                       (do !
                                         [aliasing (super_aliasing class_loader parent_type)]
                                         (in [method_name (|> (jvm.method [type_vars
                                                                           (list\each product.right arguments)
                                                                           return
                                                                           exceptions])
                                                              (jvm_alias.method aliasing))])))
                                   methods)
     .let [missing_abstract_methods (mismatched_methods overriden_methods required_abstract_methods)
           invalid_overriden_methods (mismatched_methods available_methods overriden_methods)]
     _ (phase.assertion ..missing_abstract_methods missing_abstract_methods
                        (list.empty? missing_abstract_methods))
     _ (phase.assertion ..invalid_overriden_methods invalid_overriden_methods
                        (list.empty? invalid_overriden_methods))]
    (in [])))

(def: (class::anonymous class_loader)
  (-> java/lang/ClassLoader Handler)
  (..custom
   [($_ <>.and
        (<code>.tuple (<>.some ..var))
        ..class
        (<code>.tuple (<>.some ..class))
        (<code>.tuple (<>.some ..input))
        (<code>.tuple (<>.some ..overriden_method_definition)))
    (function (_ extension_name analyse archive [parameters
                                                 super_class
                                                 super_interfaces
                                                 constructor_args
                                                 methods])
      (do [! phase.monad]
        [_ (..ensure_fresh_class! class_loader (..reflection super_class))
         _ (monad.each ! (|>> ..reflection (..ensure_fresh_class! class_loader)) super_interfaces)
         parameters (typeA.with_env
                      (..parameter_types parameters))
         .let [mapping (list\mix (function (_ [parameterJ parameterT] mapping)
                                   (dictionary.has (jvm_parser.name parameterJ)
                                                   parameterT
                                                   mapping))
                                 luxT.fresh
                                 parameters)]
         super_classT (typeA.with_env
                        (luxT.check (luxT.class mapping) (..signature super_class)))
         super_interfaceT+ (typeA.with_env
                             (monad.each check.monad
                                         (|>> ..signature (luxT.check (luxT.class mapping)))
                                         super_interfaces))
         selfT (///.lifted (do meta.monad
                             [where meta.current_module_name
                              id meta.seed]
                             (in (inheritance_relationship_type {#.Primitive (..anonymous_class_name where id) (list)}
                                                                super_classT
                                                                super_interfaceT+))))
         _ (typeA.infer selfT)
         constructor_argsA+ (monad.each ! (function (_ [type term])
                                            (do !
                                              [argT (reflection_type mapping type)
                                               termA (typeA.with_type argT
                                                       (analyse archive term))]
                                              (in [type termA])))
                                        constructor_args)
         .let [supers {#.Item super_class super_interfaces}]
         _ (..require_complete_method_concretion class_loader supers methods)
         methodsA (monad.each ! (analyse_overriden_method analyse archive selfT mapping supers) methods)]
        (in {#/////analysis.Extension extension_name
                                      (list (class_analysis super_class)
                                            (/////analysis.tuple (list\each class_analysis super_interfaces))
                                            (/////analysis.tuple (list\each typed_analysis constructor_argsA+))
                                            (/////analysis.tuple methodsA))})))]))

(def: (bundle::class class_loader)
  (-> java/lang/ClassLoader Bundle)
  (<| (///bundle.prefix "class")
      (|> ///bundle.empty
          (///bundle.install "anonymous" (class::anonymous class_loader))
          )))

(def: .public (bundle class_loader)
  (-> java/lang/ClassLoader Bundle)
  (<| (///bundle.prefix "jvm")
      (|> ///bundle.empty
          (dictionary.merged bundle::conversion)
          (dictionary.merged bundle::int)
          (dictionary.merged bundle::long)
          (dictionary.merged bundle::float)
          (dictionary.merged bundle::double)
          (dictionary.merged bundle::char)
          (dictionary.merged bundle::array)
          (dictionary.merged (bundle::object class_loader))
          (dictionary.merged (bundle::member class_loader))
          (dictionary.merged (bundle::class class_loader))
          )))
