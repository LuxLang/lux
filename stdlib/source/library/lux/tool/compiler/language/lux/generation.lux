(.using
 [library
  [lux {"-" Module symbol}
   [abstract
    [monad {"+" do}]]
   [control
    ["[0]" try {"+" Try}]
    ["[0]" exception {"+" exception:}]
    ["[0]" function]]
   [data
    [binary {"+" Binary}]
    ["[0]" product]
    ["[0]" text ("[1]#[0]" equivalence)
     ["%" format {"+" format}]]
    [collection
     ["[0]" sequence {"+" Sequence}]
     ["[0]" list ("[1]#[0]" functor mix)]
     ["[0]" set {"+" Set}]]]
   [macro
    ["[0]" template]]
   [math
    [number
     ["n" nat]]]
   [meta
    ["[0]" symbol]]]]
 [//
  [synthesis {"+" Synthesis}]
  [phase
   ["[0]" extension]]
  [///
   ["[0]" phase]
   [meta
    ["[0]" archive {"+" Archive}
     ["[0]" descriptor {"+" Module}]
     ["[0]" artifact]
     ["[0]" registry {"+" Registry}]]]]])

(type: .public Context
  [archive.ID artifact.ID])

(type: .public (Buffer directive)
  (Sequence [artifact.ID (Maybe Text) directive]))

(exception: .public (cannot_interpret [error Text])
  (exception.report
   ["Error" error]))

(template [<name>]
  [(exception: .public (<name> [artifact_id artifact.ID])
     (exception.report
      ["Artifact ID" (%.nat artifact_id)]))]

  [cannot_overwrite_output]
  [no_buffer_for_saving_code]
  )

(type: .public (Host expression directive)
  (Interface
   (: (-> Context expression (Try Any))
      evaluate)
   (: (-> directive (Try Any))
      execute)
   (: (-> Context (Maybe Text) expression (Try [Text Any directive]))
      define)

   (: (-> Context Binary directive)
      ingest)
   (: (-> Context (Maybe Text) directive (Try Any))
      re_learn)
   (: (-> Context (Maybe Text) directive (Try Any))
      re_load)))

(type: .public (State anchor expression directive)
  (Record
   [#module Module
    #anchor (Maybe anchor)
    #host (Host expression directive)
    #buffer (Maybe (Buffer directive))
    #registry Registry
    #counter Nat
    #context (Maybe artifact.ID)
    #log (Sequence Text)
    #interim_artifacts (List artifact.ID)]))

(template [<special> <general>]
  [(type: .public (<special> anchor expression directive)
     (<general> (State anchor expression directive) Synthesis expression))]

  [State+    extension.State]
  [Operation extension.Operation]
  [Phase     extension.Phase]
  [Handler   extension.Handler]
  [Bundle    extension.Bundle]
  [Extender  extension.Extender]
  )

(def: .public (state host module)
  (All (_ anchor expression directive)
    (-> (Host expression directive)
        Module
        (..State anchor expression directive)))
  [#module module
   #anchor {.#None}
   #host host
   #buffer {.#None}
   #registry registry.empty
   #counter 0
   #context {.#None}
   #log sequence.empty
   #interim_artifacts (list)])

(def: .public empty_buffer
  Buffer
  sequence.empty)

(template [<tag>
           <with_declaration> <with_type> <with_value>
           <set> <get> <get_type> <exception>]
  [(exception: .public <exception>)

   (def: .public <with_declaration>
     (All (_ anchor expression directive output) <with_type>)
     (function (_ body)
       (function (_ [bundle state])
         (case (body [bundle (with@ <tag> {.#Some <with_value>} state)])
           {try.#Success [[bundle' state'] output]}
           {try.#Success [[bundle' (with@ <tag> (value@ <tag> state) state')]
                          output]}

           {try.#Failure error}
           {try.#Failure error}))))

   (def: .public <get>
     (All (_ anchor expression directive)
       (Operation anchor expression directive <get_type>))
     (function (_ (^@ stateE [bundle state]))
       (case (value@ <tag> state)
         {.#Some output}
         {try.#Success [stateE output]}

         {.#None}
         (exception.except <exception> []))))

   (def: .public (<set> value)
     (All (_ anchor expression directive)
       (-> <get_type> (Operation anchor expression directive Any)))
     (function (_ [bundle state])
       {try.#Success [[bundle (with@ <tag> {.#Some value} state)]
                      []]}))]

  [#anchor
   (with_anchor anchor)
   (-> anchor (Operation anchor expression directive output)
       (Operation anchor expression directive output))
   anchor
   set_anchor anchor anchor no_anchor]

  [#buffer
   with_buffer
   (-> (Operation anchor expression directive output)
       (Operation anchor expression directive output))
   ..empty_buffer
   set_buffer buffer (Buffer directive) no_active_buffer]
  )

(def: .public get_registry
  (All (_ anchor expression directive)
    (Operation anchor expression directive Registry))
  (function (_ (^@ stateE [bundle state]))
    {try.#Success [stateE (value@ #registry state)]}))

(def: .public (set_registry value)
  (All (_ anchor expression directive)
    (-> Registry (Operation anchor expression directive Any)))
  (function (_ [bundle state])
    {try.#Success [[bundle (with@ #registry value state)]
                   []]}))

(def: .public next
  (All (_ anchor expression directive)
    (Operation anchor expression directive Nat))
  (do phase.monad
    [count (extension.read (value@ #counter))
     _ (extension.update (revised@ #counter ++))]
    (in count)))

(def: .public (symbol prefix)
  (All (_ anchor expression directive)
    (-> Text (Operation anchor expression directive Text)))
  (# phase.monad each (|>> %.nat (format prefix)) ..next))

(def: .public (enter_module module)
  (All (_ anchor expression directive)
    (-> Module (Operation anchor expression directive Any)))
  (extension.update (with@ #module module)))

(def: .public module
  (All (_ anchor expression directive)
    (Operation anchor expression directive Module))
  (extension.read (value@ #module)))

(def: .public (evaluate! label code)
  (All (_ anchor expression directive)
    (-> Context expression (Operation anchor expression directive Any)))
  (function (_ (^@ state+ [bundle state]))
    (case (# (value@ #host state) evaluate label code)
      {try.#Success output}
      {try.#Success [state+ output]}

      {try.#Failure error}
      (exception.except ..cannot_interpret [error]))))

(def: .public (execute! code)
  (All (_ anchor expression directive)
    (-> directive (Operation anchor expression directive Any)))
  (function (_ (^@ state+ [bundle state]))
    (case (# (value@ #host state) execute code)
      {try.#Success output}
      {try.#Success [state+ output]}

      {try.#Failure error}
      (exception.except ..cannot_interpret error))))

(def: .public (define! context custom code)
  (All (_ anchor expression directive)
    (-> Context (Maybe Text) expression (Operation anchor expression directive [Text Any directive])))
  (function (_ (^@ stateE [bundle state]))
    (case (# (value@ #host state) define context custom code)
      {try.#Success output}
      {try.#Success [stateE output]}

      {try.#Failure error}
      (exception.except ..cannot_interpret error))))

(def: .public (save! artifact_id custom code)
  (All (_ anchor expression directive)
    (-> artifact.ID (Maybe Text) directive (Operation anchor expression directive Any)))
  (do [! phase.monad]
    [?buffer (extension.read (value@ #buffer))]
    (case ?buffer
      {.#Some buffer}
      ... TODO: Optimize by no longer checking for overwrites...
      (if (sequence.any? (|>> product.left (n.= artifact_id)) buffer)
        (phase.except ..cannot_overwrite_output [artifact_id])
        (extension.update (with@ #buffer {.#Some (sequence.suffix [artifact_id custom code] buffer)})))
      
      {.#None}
      (phase.except ..no_buffer_for_saving_code [artifact_id]))))

(template [<mandatory?> <inputs> <input_types> <name> <artifact>]
  [(`` (def: .public (<name> name (~~ (template.spliced <inputs>)) dependencies)
         (All (_ anchor expression directive)
           (-> Text (~~ (template.spliced <input_types>)) (Set artifact.Dependency) (Operation anchor expression directive artifact.ID)))
         (function (_ (^@ stateE [bundle state]))
           (let [[id registry'] (<artifact> name <mandatory?> dependencies (value@ #registry state))]
             {try.#Success [[bundle (with@ #registry registry' state)]
                            id]}))))]

  [mandatory? [mandatory?] [Bit] learn registry.definition]
  [#1 [] [] learn_custom registry.custom]
  [#0 [] [] learn_analyser registry.analyser]
  [#0 [] [] learn_synthesizer registry.synthesizer]
  [#0 [] [] learn_generator registry.generator]
  [#0 [] [] learn_directive registry.directive]
  )

(exception: .public (unknown_definition [name Symbol
                                         known_definitions (List Text)])
  (exception.report
   ["Definition" (symbol.short name)]
   ["Module" (symbol.module name)]
   ["Known Definitions" (exception.listing function.identity known_definitions)]))

(def: .public (remember archive name)
  (All (_ anchor expression directive)
    (-> Archive Symbol (Operation anchor expression directive Context)))
  (function (_ (^@ stateE [bundle state]))
    (let [[_module _name] name]
      (do try.monad
        [module_id (archive.id _module archive)
         registry (if (text#= (value@ #module state) _module)
                    {try.#Success (value@ #registry state)}
                    (do try.monad
                      [[descriptor document] (archive.find _module archive)]
                      {try.#Success (value@ descriptor.#registry descriptor)}))]
        (case (registry.id _name registry)
          {.#None}
          (exception.except ..unknown_definition [name (registry.definitions registry)])
          
          {.#Some id}
          {try.#Success [stateE [module_id id]]})))))

(exception: .public no_context)

(def: .public (module_id module archive)
  (All (_ anchor expression directive)
    (-> Module Archive (Operation anchor expression directive archive.ID)))
  (function (_ (^@ stateE [bundle state]))
    (do try.monad
      [module_id (archive.id module archive)]
      (in [stateE module_id]))))

(def: .public (context archive)
  (All (_ anchor expression directive)
    (-> Archive (Operation anchor expression directive Context)))
  (function (_ (^@ stateE [bundle state]))
    (case (value@ #context state)
      {.#None}
      (exception.except ..no_context [])
      
      {.#Some id}
      (do try.monad
        [module_id (archive.id (value@ #module state) archive)]
        (in [stateE [module_id id]])))))

(def: .public (with_context id body)
  (All (_ anchor expression directive a)
    (-> artifact.ID
        (Operation anchor expression directive a)
        (Operation anchor expression directive a)))
  (function (_ [bundle state])
    (do try.monad
      [[[bundle' state'] output] (body [bundle (with@ #context {.#Some id} state)])]
      (in [[bundle' (with@ #context (value@ #context state) state')]
           output]))))

(def: .public (with_new_context archive dependencies body)
  (All (_ anchor expression directive a)
    (-> Archive (Set artifact.Dependency) (Operation anchor expression directive a)
        (Operation anchor expression directive [Context a])))
  (function (_ (^@ stateE [bundle state]))
    (let [[id registry'] (registry.resource false dependencies (value@ #registry state))]
      (do try.monad
        [[[bundle' state'] output] (body [bundle (|> state
                                                     (with@ #registry registry')
                                                     (with@ #context {.#Some id})
                                                     (revised@ #interim_artifacts (|>> {.#Item id})))])
         module_id (archive.id (value@ #module state) archive)]
        (in [[bundle' (with@ #context (value@ #context state) state')]
             [[module_id id]
              output]])))))

(def: .public (log! message)
  (All (_ anchor expression directive a)
    (-> Text (Operation anchor expression directive Any)))
  (function (_ [bundle state])
    {try.#Success [[bundle
                    (revised@ #log (sequence.suffix message) state)]
                   []]}))

(def: .public (with_interim_artifacts archive body)
  (All (_ anchor expression directive a)
    (-> Archive (Operation anchor expression directive a)
        (Operation anchor expression directive [(Set Context) a])))
  (do phase.monad
    [module (extension.read (value@ #module))]
    (function (_ state+)
      (do try.monad
        [module_id (archive.id module archive)
         [[bundle' state'] output] (body state+)]
        (in [[bundle'
              (with@ #interim_artifacts (list) state')]
             [(list#mix (function (_ artifact_id dependencies)
                          (set.has [module_id artifact_id] dependencies))
                        artifact.no_dependencies
                        (value@ #interim_artifacts state'))
              output]])))))
