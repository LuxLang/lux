(.using
 [library
  [lux {"-" symbol}
   [abstract
    [monad {"+" do}]]
   [control
    ["[0]" try {"+" Try}]
    ["[0]" exception {"+" exception:}]
    ["[0]" function]]
   [data
    [binary {"+" Binary}]
    ["[0]" product]
    ["[0]" text ("[1]#[0]" equivalence)
     ["%" format {"+" format}]]
    [collection
     ["[0]" sequence {"+" Sequence}]
     ["[0]" list ("[1]#[0]" functor mix)]
     ["[0]" set {"+" Set}]]]
   [macro
    ["^" pattern]
    ["[0]" template]]
   [math
    [number
     ["n" nat]]]
   [meta
    ["[0]" symbol]]]]
 [//
  [synthesis {"+" Synthesis}]
  [phase
   ["[0]" extension]]
  [///
   ["[0]" phase]
   [meta
    ["[0]" archive {"+" Archive}
     ["[0]" registry {"+" Registry}]
     ["[0]" unit]
     ["[0]" artifact
      ["[0]" category]]
     ["[0]" module
      ["[0]" descriptor]]]]]])

(type: .public (Buffer directive)
  (Sequence [artifact.ID (Maybe Text) directive]))

(exception: .public (cannot_interpret [error Text])
  (exception.report
   "Error" error))

(template [<name>]
  [(exception: .public (<name> [it artifact.ID])
     (exception.report
      "Artifact ID" (%.nat it)))]

  [cannot_overwrite_output]
  [no_buffer_for_saving_code]
  )

(type: .public (Host expression directive)
  (Interface
   (: (-> unit.ID [(Maybe unit.ID) expression] (Try Any))
      evaluate)
   (: (-> directive (Try Any))
      execute)
   (: (-> unit.ID (Maybe Text) [(Maybe unit.ID) expression] (Try [Text Any directive]))
      define)

   (: (-> unit.ID Binary directive)
      ingest)
   (: (-> unit.ID (Maybe Text) directive (Try Any))
      re_learn)
   (: (-> unit.ID (Maybe Text) directive (Try Any))
      re_load)))

(type: .public (State anchor expression directive)
  (Record
   [#module descriptor.Module
    #anchor (Maybe anchor)
    #host (Host expression directive)
    #buffer (Maybe (Buffer directive))
    #registry Registry
    #registry_shift Nat
    #counter Nat
    #context (Maybe artifact.ID)
    #log (Sequence Text)
    #interim_artifacts (List artifact.ID)]))

(template [<special> <general>]
  [(type: .public (<special> anchor expression directive)
     (<general> (State anchor expression directive) Synthesis expression))]

  [State+    extension.State]
  [Operation extension.Operation]
  [Phase     extension.Phase]
  [Handler   extension.Handler]
  [Bundle    extension.Bundle]
  [Extender  extension.Extender]
  )

(def: .public (state host module)
  (All (_ anchor expression directive)
    (-> (Host expression directive)
        descriptor.Module
        (..State anchor expression directive)))
  [#module module
   #anchor {.#None}
   #host host
   #buffer {.#None}
   #registry registry.empty
   #registry_shift 0
   #counter 0
   #context {.#None}
   #log sequence.empty
   #interim_artifacts (list)])

(def: .public empty_buffer
  Buffer
  sequence.empty)

(template [<tag>
           <with_declaration> <with_type> <with_value>
           <set> <get> <get_type> <exception>]
  [(exception: .public <exception>)

   (def: .public <with_declaration>
     (All (_ anchor expression directive output) <with_type>)
     (function (_ body)
       (function (_ [bundle state])
         (case (body [bundle (has <tag> {.#Some <with_value>} state)])
           {try.#Success [[bundle' state'] output]}
           {try.#Success [[bundle' (has <tag> (the <tag> state) state')]
                          output]}

           {try.#Failure error}
           {try.#Failure error}))))

   (def: .public <get>
     (All (_ anchor expression directive)
       (Operation anchor expression directive <get_type>))
     (function (_ (^.let stateE [bundle state]))
       (case (the <tag> state)
         {.#Some output}
         {try.#Success [stateE output]}

         {.#None}
         (exception.except <exception> []))))

   (def: .public (<set> value)
     (All (_ anchor expression directive)
       (-> <get_type> (Operation anchor expression directive Any)))
     (function (_ [bundle state])
       {try.#Success [[bundle (has <tag> {.#Some value} state)]
                      []]}))]

  [#anchor
   (with_anchor anchor)
   (-> anchor (Operation anchor expression directive output)
       (Operation anchor expression directive output))
   anchor
   set_anchor anchor anchor no_anchor]

  [#buffer
   with_buffer
   (-> (Operation anchor expression directive output)
       (Operation anchor expression directive output))
   ..empty_buffer
   set_buffer buffer (Buffer directive) no_active_buffer]
  )

(def: .public get_registry
  (All (_ anchor expression directive)
    (Operation anchor expression directive Registry))
  (function (_ (^.let stateE [bundle state]))
    {try.#Success [stateE (the #registry state)]}))

(def: .public (set_registry value)
  (All (_ anchor expression directive)
    (-> Registry (Operation anchor expression directive Any)))
  (function (_ [bundle state])
    {try.#Success [[bundle (has #registry value state)]
                   []]}))

(def: .public next
  (All (_ anchor expression directive)
    (Operation anchor expression directive Nat))
  (do phase.monad
    [count (extension.read (the #counter))
     _ (extension.update (revised #counter ++))]
    (in count)))

(def: .public (symbol prefix)
  (All (_ anchor expression directive)
    (-> Text (Operation anchor expression directive Text)))
  (# phase.monad each (|>> %.nat (format prefix)) ..next))

(def: .public (enter_module module)
  (All (_ anchor expression directive)
    (-> descriptor.Module (Operation anchor expression directive Any)))
  (extension.update (has #module module)))

(def: .public module
  (All (_ anchor expression directive)
    (Operation anchor expression directive descriptor.Module))
  (extension.read (the #module)))

(def: .public (evaluate! label code)
  (All (_ anchor expression directive)
    (-> unit.ID [(Maybe unit.ID) expression] (Operation anchor expression directive Any)))
  (function (_ (^.let state+ [bundle state]))
    (case (# (the #host state) evaluate label code)
      {try.#Success output}
      {try.#Success [state+ output]}

      {try.#Failure error}
      (exception.except ..cannot_interpret [error]))))

(def: .public (execute! code)
  (All (_ anchor expression directive)
    (-> directive (Operation anchor expression directive Any)))
  (function (_ (^.let state+ [bundle state]))
    (case (# (the #host state) execute code)
      {try.#Success output}
      {try.#Success [state+ output]}

      {try.#Failure error}
      (exception.except ..cannot_interpret error))))

(def: .public (define! context custom code)
  (All (_ anchor expression directive)
    (-> unit.ID (Maybe Text) [(Maybe unit.ID) expression] (Operation anchor expression directive [Text Any directive])))
  (function (_ (^.let stateE [bundle state]))
    (case (# (the #host state) define context custom code)
      {try.#Success output}
      {try.#Success [stateE output]}

      {try.#Failure error}
      (exception.except ..cannot_interpret error))))

(def: .public (save! artifact_id custom code)
  (All (_ anchor expression directive)
    (-> artifact.ID (Maybe Text) directive (Operation anchor expression directive Any)))
  (do [! phase.monad]
    [?buffer (extension.read (the #buffer))]
    (case ?buffer
      {.#Some buffer}
      ... TODO: Optimize by no longer checking for overwrites...
      (if (sequence.any? (|>> product.left (n.= artifact_id)) buffer)
        (phase.except ..cannot_overwrite_output [artifact_id])
        (extension.update (has #buffer {.#Some (sequence.suffix [artifact_id custom code] buffer)})))
      
      {.#None}
      (phase.except ..no_buffer_for_saving_code [artifact_id]))))

(template [<type> <mandatory?> <inputs> <input_types> <name> <artifact>]
  [(`` (def: .public (<name> it (~~ (template.spliced <inputs>)) dependencies)
         (All (_ anchor expression directive)
           (-> <type> (~~ (template.spliced <input_types>)) (Set unit.ID) (Operation anchor expression directive artifact.ID)))
         (function (_ (^.let stateE [bundle state]))
           (let [[id registry'] (<artifact> it <mandatory?> dependencies (the #registry state))]
             {try.#Success [[bundle (has #registry registry' state)]
                            id]}))))]

  [category.Definition mandatory? [mandatory?] [Bit] learn registry.definition]
  [Text #1 [] [] learn_custom registry.custom]
  [Text #0 [] [] learn_analyser registry.analyser]
  [Text #0 [] [] learn_synthesizer registry.synthesizer]
  [Text #0 [] [] learn_generator registry.generator]
  [Text #0 [] [] learn_directive registry.directive]
  )

(exception: .public (unknown_definition [name Symbol
                                         known_definitions (List category.Definition)])
  (exception.report
   "Definition" (symbol.short name)
   "Module" (symbol.module name)
   "Known Definitions" (exception.listing product.left known_definitions)))

(def: .public (remember archive name)
  (All (_ anchor expression directive)
    (-> Archive Symbol (Operation anchor expression directive unit.ID)))
  (function (_ (^.let stateE [bundle state]))
    (let [[_module _name] name]
      (do try.monad
        [@module (archive.id _module archive)
         registry (if (text#= (the #module state) _module)
                    {try.#Success (the #registry state)}
                    (do try.monad
                      [[_module output registry] (archive.find _module archive)]
                      {try.#Success registry}))]
        (case (registry.id _name registry)
          {.#None}
          (exception.except ..unknown_definition [name (registry.definitions registry)])
          
          {.#Some id}
          {try.#Success [stateE [@module id]]})))))

(def: .public (definition archive name)
  (All (_ anchor expression directive)
    (-> Archive Symbol (Operation anchor expression directive [unit.ID (Maybe category.Definition)])))
  (function (_ (^.let stateE [bundle state]))
    (let [[_module _name] name]
      (do try.monad
        [@module (archive.id _module archive)
         registry (if (text#= (the #module state) _module)
                    {try.#Success (the #registry state)}
                    (do try.monad
                      [[_module output registry] (archive.find _module archive)]
                      {try.#Success registry}))]
        (case (registry.find_definition _name registry)
          {.#None}
          (exception.except ..unknown_definition [name (registry.definitions registry)])
          
          {.#Some [@artifact def]}
          {try.#Success [stateE [[@module @artifact] def]]})))))

(exception: .public no_context)

(def: .public (module_id module archive)
  (All (_ anchor expression directive)
    (-> descriptor.Module Archive (Operation anchor expression directive module.ID)))
  (function (_ (^.let stateE [bundle state]))
    (do try.monad
      [@module (archive.id module archive)]
      (in [stateE @module]))))

(def: .public (context archive)
  (All (_ anchor expression directive)
    (-> Archive (Operation anchor expression directive unit.ID)))
  (function (_ (^.let stateE [bundle state]))
    (case (the #context state)
      {.#None}
      (exception.except ..no_context [])
      
      {.#Some id}
      (do try.monad
        [@module (archive.id (the #module state) archive)]
        (in [stateE [@module id]])))))

(def: .public (with_context @artifact body)
  (All (_ anchor expression directive a)
    (-> artifact.ID
        (Operation anchor expression directive a)
        (Operation anchor expression directive a)))
  (function (_ [bundle state])
    (do try.monad
      [[[bundle' state'] output] (body [bundle (has #context {.#Some @artifact} state)])]
      (in [[bundle' (has #context (the #context state) state')]
           output]))))

(def: .public (with_registry_shift shift body)
  (All (_ anchor expression directive a)
    (-> Nat
        (Operation anchor expression directive a)
        (Operation anchor expression directive a)))
  (function (_ [bundle state])
    (do try.monad
      [[[bundle' state'] output] (body [bundle (has #registry_shift shift state)])]
      (in [[bundle' (has #registry_shift (the #registry_shift state) state')]
           output]))))

(def: .public (with_new_context archive dependencies body)
  (All (_ anchor expression directive a)
    (-> Archive (Set unit.ID) (Operation anchor expression directive a)
        (Operation anchor expression directive [unit.ID a])))
  (function (_ (^.let stateE [bundle state]))
    (let [[@artifact registry'] (registry.resource false dependencies (the #registry state))
          @artifact (n.+ @artifact (the #registry_shift state))]
      (do try.monad
        [[[bundle' state'] output] (body [bundle (|> state
                                                     (has #registry registry')
                                                     (has #context {.#Some @artifact})
                                                     (revised #interim_artifacts (|>> {.#Item @artifact})))])
         @module (archive.id (the #module state) archive)]
        (in [[bundle' (has #context (the #context state) state')]
             [[@module @artifact]
              output]])))))

(def: .public (log! message)
  (All (_ anchor expression directive a)
    (-> Text (Operation anchor expression directive Any)))
  (function (_ [bundle state])
    {try.#Success [[bundle
                    (revised #log (sequence.suffix message) state)]
                   []]}))

(def: .public (with_interim_artifacts archive body)
  (All (_ anchor expression directive a)
    (-> Archive (Operation anchor expression directive a)
        (Operation anchor expression directive [(List unit.ID) a])))
  (do phase.monad
    [module (extension.read (the #module))]
    (function (_ state+)
      (do try.monad
        [@module (archive.id module archive)
         [[bundle' state'] output] (body state+)]
        (in [[bundle'
              (has #interim_artifacts (list) state')]
             [(list#each (|>> [@module]) (the #interim_artifacts state'))
              output]])))))
