(.module:
  [library
   [lux {"-" [Module]}
    ["." meta]
    [abstract
     [monad {"+" [do]}]]
    [control
     ["." try]]
    [math
     [number
      ["n" nat]]]]]
  ["." // {"+" [Operation]}
   [macro {"+" [Expander]}]
   [//
    [phase
     [".P" extension]
     [".P" synthesis]
     [".P" analysis
      ["." type]]
     [//
      ["." synthesis]
      ["." generation {"+" [Context]}]
      [///
       ["." phase]
       [meta
        [archive {"+" [Archive]}
         [descriptor {"+" [Module]}]]]]]]]])

(type: .public Eval
  (-> Archive Type Code (Operation Any)))

(def: (context [module_id artifact_id])
  (-> Context Context)
  ... TODO: Find a better way that doesn't rely on clever tricks.
  [(n.- module_id 0) artifact_id])

(def: .public (evaluator expander synthesis_state generation_state generate)
  (All (_ anchor expression artifact)
    (-> Expander
        synthesis.State+
        (generation.State+ anchor expression artifact)
        (generation.Phase anchor expression artifact)
        Eval))
  (let [analyze (analysisP.phase expander)]
    (function (eval archive type exprC)
      (do phase.monad
        [exprA (type.with_type type
                 (//.without_scopes
                  (analyze archive exprC)))
         module (extensionP.lifted
                 meta.current_module_name)
         count (extensionP.lifted
                meta.seed)]
        (phase.lifted (do try.monad
                        [exprS (|> exprA (synthesisP.phase archive) (phase.result synthesis_state))]
                        (phase.result generation_state
                                      (do phase.monad
                                        [exprO (generate archive exprS)
                                         module_id (generation.module_id module archive)]
                                        (generation.evaluate! (..context [module_id count]) exprO)))))))))
