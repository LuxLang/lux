(.module:
  [library
   [lux {"-" Module}
    ["[0]" meta]
    [abstract
     [monad {"+" do}]]
    [control
     ["[0]" try]]
    [math
     [number
      ["n" nat]]]]]
  ["[0]" // {"+" Operation}
   [macro {"+" Expander}]
   [//
    [phase
     ["[0]P" extension]
     ["[0]P" synthesis]
     ["[0]P" analysis
      ["[0]" type]]
     [//
      ["[0]" synthesis]
      ["[0]" generation {"+" Context}]
      [///
       ["[0]" phase]
       [meta
        [archive {"+" Archive}
         [descriptor {"+" Module}]]]]]]]])

(type: .public Eval
  (-> Archive Type Code (Operation Any)))

(def: (context [module_id artifact_id])
  (-> Context Context)
  ... TODO: Find a better way that doesn't rely on clever tricks.
  [(n.- module_id 0) artifact_id])

(def: .public (evaluator expander synthesis_state generation_state generate)
  (All (_ anchor expression artifact)
    (-> Expander
        synthesis.State+
        (generation.State+ anchor expression artifact)
        (generation.Phase anchor expression artifact)
        Eval))
  (let [analyze (analysisP.phase expander)]
    (function (eval archive type exprC)
      (do phase.monad
        [exprA (type.with_type type
                 (//.without_scopes
                  (analyze archive exprC)))
         module (extensionP.lifted
                 meta.current_module_name)
         count (extensionP.lifted
                meta.seed)]
        (phase.lifted (do try.monad
                        [exprS (|> exprA (synthesisP.phase archive) (phase.result synthesis_state))]
                        (phase.result generation_state
                                      (do phase.monad
                                        [exprO (generate archive exprS)
                                         module_id (generation.module_id module archive)]
                                        (generation.evaluate! (..context [module_id count]) exprO)))))))))
