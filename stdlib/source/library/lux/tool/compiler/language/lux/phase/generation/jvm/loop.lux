(.using
 [library
  [lux "*"
   [abstract
    ["[0]" monad (.only do)]]
   [control
    ["[0]" function]]
   [data
    ["[0]" product]
    [collection
     ["[0]" list ("[1]#[0]" functor)]]]
   [math
    [number
     ["n" nat]]]
   [target
    [jvm
     ["_" bytecode (.only Bytecode) ("[1]#[0]" monad)]]]]]
 ["[0]" // "_"
  ["[1][0]" runtime (.only Operation Phase Generator)]
  ["[1][0]" value]
  [////
   ["[0]" synthesis (.only Path Synthesis)]
   ["[0]" generation]
   [///
    ["[0]" phase]
    [reference
     [variable (.only Register)]]]]])

(def: (invariant? register changeS)
  (-> Register Synthesis Bit)
  (case changeS
    (pattern (synthesis.variable/local var))
    (n.= register var)

    _
    false))

(def: no_op
  (_#in []))

(def: .public (again translate archive updatesS)
  (Generator (List Synthesis))
  (do [! phase.monad]
    [[@begin offset] generation.anchor
     updatesG (|> updatesS
                  list.enumeration
                  (list#each (function (_ [index updateS])
                               [(n.+ offset index) updateS]))
                  (monad.each ! (function (_ [register updateS])
                                  (if (invariant? register updateS)
                                    (in [..no_op
                                         ..no_op])
                                    (do !
                                      [fetchG (translate archive updateS)
                                       .let [storeG (_.astore register)]]
                                      (in [fetchG storeG]))))))]
    (in (all _.composite
             ... It may look weird that first I fetch all the values separately,
             ... and then I store them all.
             ... It must be done that way in order to avoid a potential bug.
             ... Let's say that you'll recur with 2 expressions: X and Y.
             ... If Y depends on the value of X, and you don't perform fetches
             ... and stores separately, then by the time Y is evaluated, it
             ... will refer to the new value of X, instead of the old value, as
             ... should be the case.
             (|> updatesG
                 (list#each product.left)
                 (monad.all _.monad))
             (|> updatesG
                 list.reversed
                 (list#each product.right)
                 (monad.all _.monad))
             (_.goto @begin)))))

(def: .public (scope translate archive [offset initsS+ iterationS])
  (Generator [Nat (List Synthesis) Synthesis])
  (do [! phase.monad]
    [@begin //runtime.forge_label
     initsI+ (monad.each ! (translate archive) initsS+)
     iterationG (generation.with_anchor [@begin offset]
                  (translate archive iterationS))
     .let [initializationG (list#each (function (_ [index initG])
                                        [initG (_.astore (n.+ offset index))])
                                      (list.enumeration initsI+))]]
    (in (all _.composite
             (|> initializationG
                 (list#each product.left)
                 (monad.all _.monad))
             (|> initializationG
                 list.reversed
                 (list#each product.right)
                 (monad.all _.monad))
             (_.set_label @begin)
             iterationG))))
