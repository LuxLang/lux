(.module:
  [library
   [lux "*"
    [abstract
     ["[0]" monad {"+" do}]]
    [control
     ["[0]" function]]
    [data
     ["[0]" product]
     [number
      ["n" nat]]
     [collection
      ["[0]" list ("[1]#[0]" functor)]]]
    [target
     [jvm
      ["_" bytecode {"+" Label Bytecode} ("[1]#[0]" monad)]]]]]
  ["[0]" // "_"
   ["[1][0]" runtime {"+" Operation Phase Generator}]
   ["[1][0]" value]
   [////
    ["[0]" synthesis {"+" Path Synthesis}]
    ["[0]" generation]
    [///
     ["[0]" phase]
     [reference
      [variable {"+" Register}]]]]])

(def: (invariant? register changeS)
  (-> Register Synthesis Bit)
  (case changeS
    (^ (synthesis.variable/local var))
    (n.= register var)

    _
    false))

(def: no_op
  (_#in []))

(def: .public (recur translate archive updatesS)
  (Generator (List Synthesis))
  (do [! phase.monad]
    [[@begin offset] generation.anchor
     updatesG (|> updatesS
                  list.enumeration
                  (list#each (function (_ [index updateS])
                               [(n.+ offset index) updateS]))
                  (monad.each ! (function (_ [register updateS])
                                  (if (invariant? register updateS)
                                    (in [..no_op
                                         ..no_op])
                                    (do !
                                      [fetchG (translate archive updateS)
                                       .let [storeG (_.astore register)]]
                                      (in [fetchG storeG]))))))]
    (in ($_ _.composite
            ... It may look weird that first I fetch all the values separately,
            ... and then I store them all.
            ... It must be done that way in order to avoid a potential bug.
            ... Let's say that you'll recur with 2 expressions: X and Y.
            ... If Y depends on the value of X, and you don't perform fetches
            ... and stores separately, then by the time Y is evaluated, it
            ... will refer to the new value of X, instead of the old value, as
            ... should be the case.
            (|> updatesG
                (list#each product.left)
                (monad.all _.monad))
            (|> updatesG
                list.reversed
                (list#each product.right)
                (monad.all _.monad))
            (_.goto @begin)))))

(def: .public (scope translate archive [offset initsS+ iterationS])
  (Generator [Nat (List Synthesis) Synthesis])
  (do [! phase.monad]
    [@begin //runtime.forge_label
     initsI+ (monad.each ! (translate archive) initsS+)
     iterationG (generation.with_anchor [@begin offset]
                  (translate archive iterationS))
     .let [initializationG (|> (list.enumeration initsI+)
                               (list#each (function (_ [index initG])
                                            ($_ _.composite
                                                initG
                                                (_.astore (n.+ offset index)))))
                               (monad.all _.monad))]]
    (in ($_ _.composite
            initializationG
            (_.set_label @begin)
            iterationG))))
