(.using
 [library
  [lux {"-" nat int rev}
   [abstract
    [equivalence {"+" Equivalence}]]
   [data
    [text
     ["%" format]]]
   [math
    [number
     ["n" nat]]]]]
 ["[0]" // "_"
  ["[1][0]" simple {"+" Simple}]
  ["[1][0]" complex {"+" Complex}]
  [////
   [reference
    ["[1][0]" variable {"+" Register}]]]])

(type: .public Pattern
  (Rec Pattern
    (.Variant
     {#Simple Simple}
     {#Complex (Complex Pattern)}
     {#Bind Register})))

(implementation: .public equivalence
  (Equivalence Pattern)

  (def: (= reference sample)
    (case [reference sample]
      [{#Simple reference} {#Simple sample}]
      (# //simple.equivalence = reference sample)
      
      [{#Complex reference} {#Complex sample}]
      (# (//complex.equivalence =) = reference sample)

      [{#Bind reference} {#Bind sample}]
      (n.= reference sample)

      _
      false)))

(def: .public (format it)
  (%.Format Pattern)
  (case it
    {#Simple it}
    (//simple.format it)
    
    {#Complex it}
    (//complex.format format it)
    
    {#Bind it}
    (//variable.format {//variable.#Local it})))

(template [<name> <tag>]
  [(template: .public (<name> content)
     [(.<| {..#Complex}
           <tag>
           content)])]

  [variant {//complex.#Variant}]
  [tuple   {//complex.#Tuple}]
  )

(template: .public (unit)
  [{..#Simple {//simple.#Unit}}])

(template [<name> <tag>]
  [(template: .public (<name> content)
     [{..#Simple {<tag> content}}])]
  
  [bit  //simple.#Bit]
  [nat  //simple.#Nat]
  [int  //simple.#Int]
  [rev  //simple.#Rev]
  [frac //simple.#Frac]
  [text //simple.#Text]
  )

(template: .public (bind register)
  [{..#Bind register}])
