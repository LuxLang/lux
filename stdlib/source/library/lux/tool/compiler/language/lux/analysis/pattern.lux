(.using
 [library
  [lux {"-" Primitive nat int rev}
   [abstract
    [equivalence {"+" Equivalence}]]
   [math
    [number
     ["n" nat]]]]]
 ["[0]" // "_"
  ["[1][0]" primitive {"+" Primitive}]
  ["[1][0]" composite {"+" Composite}]
  [////
   [reference
    [variable {"+" Register}]]]])

(type: .public Pattern
  (Rec Pattern
    (.Variant
     {#Simple Primitive}
     {#Complex (Composite Pattern)}
     {#Bind Register})))

(implementation: .public equivalence
  (Equivalence Pattern)

  (def: (= reference sample)
    (case [reference sample]
      [{#Simple reference} {#Simple sample}]
      (# //primitive.equivalence = reference sample)
      
      [{#Complex reference} {#Complex sample}]
      (# (//composite.equivalence =) = reference sample)

      [{#Bind reference} {#Bind sample}]
      (n.= reference sample)

      _
      false)))

(template [<name> <tag>]
  [(template: .public (<name> content)
     [(.<| {..#Complex}
           <tag>
           content)])]

  [variant {//composite.#Variant}]
  [tuple   {//composite.#Tuple}]
  )

(template: .public (unit)
  [{..#Simple {//primitive.#Unit}}])

(template [<name> <tag>]
  [(template: .public (<name> content)
     [{..#Simple {<tag> content}}])]
  
  [bit  //primitive.#Bit]
  [nat  //primitive.#Nat]
  [int  //primitive.#Int]
  [rev  //primitive.#Rev]
  [frac //primitive.#Frac]
  [text //primitive.#Text]
  )

(template: .public (bind register)
  [{..#Bind register}])
