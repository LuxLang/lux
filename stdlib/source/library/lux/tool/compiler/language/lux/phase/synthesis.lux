(.module:
  [library
   [lux {"-" [primitive]}
    [abstract
     ["[0]" monad {"+" [do]}]]
    [control
     [pipe {"+" [case>]}]
     ["[0]" try]]
    [data
     [collection
      ["[0]" list ("[1]\[0]" functor)]
      ["[0]" dictionary {"+" [Dictionary]}]]]]]
  ["[0]" / "_"
   ["[1][0]" function]
   ["[1][0]" case]
   ["[1][0]" variable]
   ["/[1]" // "_"
    ["[1][0]" extension]
    ["/[1]" // "_"
     ["[1][0]" analysis {"+" [Analysis]}]
     ["/" synthesis {"+" [Synthesis Phase]}]
     [///
      ["[0]" phase ("[1]\[0]" monad)]
      [reference {"+" []}
       [variable {"+" []}]]]]]])

(def: (primitive analysis)
  (-> ///analysis.Primitive /.Primitive)
  (case analysis
    #///analysis.Unit
    (#/.Text /.unit)
    
    (^template [<analysis> <synthesis>]
      [(<analysis> value)
       (<synthesis> value)])
    ([#///analysis.Bit  #/.Bit]
     [#///analysis.Frac #/.F64]
     [#///analysis.Text #/.Text])

    (^template [<analysis> <synthesis>]
      [(<analysis> value)
       (<synthesis> (.i64 value))])
    ([#///analysis.Nat #/.I64]
     [#///analysis.Int #/.I64]
     [#///analysis.Rev #/.I64])))

(def: (optimization archive)
  Phase
  (function (optimization' analysis)
    (case analysis
      (#///analysis.Primitive analysis')
      (phase\in (#/.Primitive (..primitive analysis')))

      (#///analysis.Reference reference)
      (phase\in (#/.Reference reference))

      (#///analysis.Structure structure)
      (/.with_currying? false
        (case structure
          (#///analysis.Variant variant)
          (do phase.monad
            [valueS (optimization' (value@ #///analysis.value variant))]
            (in (/.variant (with@ #///analysis.value valueS variant))))

          (#///analysis.Tuple tuple)
          (|> tuple
              (monad.each phase.monad optimization')
              (phase\each (|>> /.tuple)))))
      
      (#///analysis.Case inputA branchesAB+)
      (/.with_currying? false
        (/case.synthesize optimization branchesAB+ archive inputA))

      (^ (///analysis.no_op value))
      (optimization' value)

      (#///analysis.Apply _)
      (/.with_currying? false
        (/function.apply optimization archive analysis))

      (#///analysis.Function environmentA bodyA)
      (/function.abstraction optimization environmentA archive bodyA)

      (#///analysis.Extension name args)
      (/.with_currying? false
        (function (_ state)
          (|> (//extension.apply archive optimization [name args])
              (phase.result' state)
              (case> (#try.Success output)
                     (#try.Success output)
                     
                     (#try.Failure _)
                     (|> args
                         (monad.each phase.monad optimization')
                         (phase\each (|>> [name] #/.Extension))
                         (phase.result' state))))))
      )))

(def: .public (phase archive analysis)
  Phase
  (do phase.monad
    [synthesis (..optimization archive analysis)]
    (phase.lifted (/variable.optimization synthesis))))
