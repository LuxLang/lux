(.module:
  [library
   [lux "*"
    [abstract
     ["." monad {"+" [do]}]]
    [control
     ["." maybe ("#\." monad)]]
    [data
     [collection
      ["." list]]]
    [math
     [number
      ["n" nat]]]]]
  [////
   ["." analysis {"+" [Environment]}]
   ["/" synthesis {"+" [Path Abstraction Synthesis]}]
   [///
    [arity {"+" [Arity]}]
    ["." reference
     ["." variable {"+" [Register Variable]}]]]])

(type: .public (Transform a)
  (-> a (Maybe a)))

(def: .public (register_optimization offset)
  (-> Register (-> Register Register))
  (|>> -- (n.+ offset)))

(def: (path_optimization body_optimization offset)
  (-> (Transform Synthesis) Register (Transform Path))
  (function (recur path)
    (case path
      (#/.Bind register)
      (#.Some (#/.Bind (register_optimization offset register)))

      (^template [<tag>]
        [(<tag> left right)
         (do maybe.monad
           [left' (recur left)
            right' (recur right)]
           (in (<tag> left' right')))])
      ([#/.Alt] [#/.Seq])

      (#/.Bit_Fork when then else)
      (do {! maybe.monad}
        [then (recur then)
         else (case else
                (#.Some else)
                (\ ! each (|>> #.Some) (recur else))

                #.None
                (in #.None))]
        (in (#/.Bit_Fork when then else)))
      
      (^template [<tag>]
        [(<tag> [[test then] elses])
         (do {! maybe.monad}
           [then (recur then)
            elses (monad.each ! (function (_ [else_test else_then])
                                  (do !
                                    [else_then (recur else_then)]
                                    (in [else_test else_then])))
                              elses)]
           (in (<tag> [[test then] elses])))])
      ([#/.I64_Fork]
       [#/.F64_Fork]
       [#/.Text_Fork])
      
      (#/.Then body)
      (|> body
          body_optimization
          (maybe\each (|>> #/.Then)))

      _
      (#.Some path))))

(def: (body_optimization true_loop? offset scope_environment arity expr)
  (-> Bit Register (Environment Synthesis) Arity (Transform Synthesis))
  (loop [return? true
         expr expr]
    (case expr
      (#/.Primitive _)
      (#.Some expr)

      (#/.Structure structure)
      (case structure
        (#analysis.Variant variant)
        (do maybe.monad
          [value' (|> variant (value@ #analysis.value) (recur false))]
          (in (|> variant
                  (with@ #analysis.value value')
                  /.variant)))
        
        (#analysis.Tuple tuple)
        (|> tuple
            (monad.each maybe.monad (recur false))
            (maybe\each (|>> /.tuple))))

      (#/.Reference reference)
      (case reference
        (^ (#reference.Variable (variable.self)))
        (if true_loop?
          #.None
          (#.Some expr))
        
        (^ (reference.constant constant))
        (#.Some expr)

        (^ (reference.local register))
        (#.Some (#/.Reference (reference.local (register_optimization offset register))))

        (^ (reference.foreign register))
        (if true_loop?
          (list.item register scope_environment)
          (#.Some expr)))

      (^ (/.branch/case [input path]))
      (do maybe.monad
        [input' (recur false input)
         path' (path_optimization (recur return?) offset path)]
        (in (|> path' [input'] /.branch/case)))

      (^ (/.branch/let [input register body]))
      (do maybe.monad
        [input' (recur false input)
         body' (recur return? body)]
        (in (/.branch/let [input' (register_optimization offset register) body'])))

      (^ (/.branch/if [input then else]))
      (do maybe.monad
        [input' (recur false input)
         then' (recur return? then)
         else' (recur return? else)]
        (in (/.branch/if [input' then' else'])))

      (^ (/.branch/get [path record]))
      (do maybe.monad
        [record (recur false record)]
        (in (/.branch/get [path record])))

      (^ (/.loop/scope scope))
      (do {! maybe.monad}
        [inits' (|> scope
                    (value@ #/.inits)
                    (monad.each ! (recur false)))
         iteration' (recur return? (value@ #/.iteration scope))]
        (in (/.loop/scope [#/.start (|> scope (value@ #/.start) (register_optimization offset))
                           #/.inits inits'
                           #/.iteration iteration'])))

      (^ (/.loop/recur args))
      (|> args
          (monad.each maybe.monad (recur false))
          (maybe\each (|>> /.loop/recur)))

      (^ (/.function/abstraction [environment arity body]))
      (do {! maybe.monad}
        [environment' (monad.each ! (recur false) environment)]
        (in (/.function/abstraction [environment' arity body])))
      
      (^ (/.function/apply [abstraction arguments]))
      (do {! maybe.monad}
        [arguments' (monad.each ! (recur false) arguments)]
        (with_expansions [<application> (as_is (do !
                                                 [abstraction' (recur false abstraction)]
                                                 (in (/.function/apply [abstraction' arguments']))))]
          (case abstraction
            (^ (#/.Reference (#reference.Variable (variable.self))))
            (if (and return?
                     (n.= arity (list.size arguments)))
              (in (/.loop/recur arguments'))
              (if true_loop?
                #.None
                <application>))
            
            _
            <application>)))

      ... TODO: Stop relying on this custom code.
      (^ (#/.Extension ["lux syntax char case!" (list& input else matches)]))
      (if return?
        (do {! maybe.monad}
          [input (recur false input)
           matches (monad.each !
                               (function (_ match)
                                 (case match
                                   (^ (#/.Structure (#analysis.Tuple (list when then))))
                                   (do !
                                     [when (recur false when)
                                      then (recur return? then)]
                                     (in (#/.Structure (#analysis.Tuple (list when then)))))

                                   _
                                   (recur false match)))
                               matches)
           else (recur return? else)]
          (in (#/.Extension ["lux syntax char case!" (list& input else matches)])))
        #.None)

      (#/.Extension [name args])
      (|> args
          (monad.each maybe.monad (recur false))
          (maybe\each (|>> [name] #/.Extension))))))

(def: .public (optimization true_loop? offset inits functionS)
  (-> Bit Register (List Synthesis) Abstraction (Maybe [Register (List Synthesis) Synthesis]))
  (|> (value@ #/.body functionS)
      (body_optimization true_loop? offset (value@ #/.environment functionS) (value@ #/.arity functionS))
      (maybe\each (|>> [offset inits]))))
