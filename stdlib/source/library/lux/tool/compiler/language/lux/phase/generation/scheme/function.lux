(.using
 [library
  [lux {"-" function}
   [abstract
    ["[0]" monad {"+" do}]]
   [control
    pipe]
   [data
    ["[0]" product]
    ["[0]" text
     ["%" format {"+" format}]]
    [collection
     ["[0]" list ("[1]#[0]" functor)]]]
   [target
    ["_" scheme {"+" Expression Computation Var}]]]]
 ["[0]" // "_"
  ["[1][0]" runtime {"+" Operation Phase Generator}]
  ["[1][0]" reference]
  ["[1][0]" case]
  ["/[1]" // "_"
   ["[1][0]" reference]
   ["//[1]" /// "_"
    [analysis {"+" Variant Tuple Abstraction Application Analysis}]
    [synthesis {"+" Synthesis}]
    ["[1][0]" generation {"+" Context}]
    ["//[1]" /// "_"
     [arity {"+" Arity}]
     ["[1][0]" phase ("[1]#[0]" monad)]
     [reference
      [variable {"+" Register Variable}]]]]]])

(def: .public (apply expression archive [functionS argsS+])
  (Generator (Application Synthesis))
  (do [! ///////phase.monad]
    [functionO (expression archive functionS)
     argsO+ (monad.each ! (expression archive) argsS+)]
    (in (_.apply argsO+ functionO))))

(def: capture
  (-> Register Var)
  (|>> (///reference.foreign //reference.system) as_expected))

(def: (with_closure inits function_definition)
  (-> (List Expression) Computation (Operation Computation))
  (///////phase#in
   (case inits
     {.#End}
     function_definition

     _
     (|> function_definition
         (_.lambda [(|> (list.enumeration inits)
                        (list#each (|>> product.left ..capture)))
                    {.#None}])
         (_.apply inits)))))

(def: @curried (_.var "curried"))
(def: @missing (_.var "missing"))

(def: input
  (|>> ++ //case.register))

(def: .public (function expression archive [environment arity bodyS])
  (Generator (Abstraction Synthesis))
  (do [! ///////phase.monad]
    [[function_name bodyO] (/////generation.with_new_context archive
                             (do !
                               [@self (# ! each (|>> ///reference.artifact _.var)
                                         (/////generation.context archive))]
                               (/////generation.with_anchor @self
                                 (expression archive bodyS))))
     closureO+ (monad.each ! (expression archive) environment)
     .let [arityO (|> arity .int _.int)
           apply_poly (.function (_ args func)
                        (_.apply/2 (_.var "apply") func args))
           @num_args (_.var "num_args")
           @self (_.var (///reference.artifact function_name))]]
    (with_closure closureO+
      (_.letrec (list [@self (_.lambda [(list) {.#Some @curried}]
                                       (_.let (list [@num_args (_.length/1 @curried)])
                                         (<| (_.if (|> @num_args (_.=/2 arityO))
                                               (<| (_.let (list [(//case.register 0) @self]))
                                                   (_.let_values (list [[(|> (list.indices arity)
                                                                             (list#each ..input))
                                                                         {.#None}]
                                                                        (_.apply/2 (_.var "apply") (_.var "values") @curried)]))
                                                   bodyO))
                                             (_.if (|> @num_args (_.>/2 arityO))
                                               (let [arity_args (//runtime.slice (_.int +0) arityO @curried)
                                                     output_func_args (//runtime.slice arityO
                                                                                       (|> @num_args (_.-/2 arityO))
                                                                                       @curried)]
                                                 (_.begin (list (|> @self
                                                                    (apply_poly arity_args)
                                                                    (apply_poly output_func_args))))))
                                             ... (|> @num_args (_.</2 arityO))
                                             (_.lambda [(list) {.#Some @missing}]
                                                       (|> @self
                                                           (apply_poly (_.append/2 @curried @missing)))))
                                         ))])
                @self))))
