(.module:
  [library
   [lux "*"
    [abstract
     ["[0]" monad {"+" [do]}]]
    [control
     ["ex" exception {"+" [exception:]}]
     [parser
      ["<[0]>" code]]]
    [data
     ["[0]" product]
     ["[0]" text]
     [number {"+" [hex]}
      ["f" frac]]
     [collection
      ["[0]" list ("[1]\[0]" functor)]
      ["dict" dictionary {"+" [Dictionary]}]]]
    ["[0]" macro {"+" [with_identifiers]}
     ["[0]" code]
     [syntax {"+" [syntax:]}]]
    [target
     ["_" scheme {"+" [Expression Computation]}]]]]
  ["[0]" /// "_"
   ["[1][0]" runtime {"+" [Operation Phase Handler Bundle]}]
   ["[1]//" ///
    ["[1][0]" extension
     ["[0]" bundle]]
    ["[1]/" // "_"
     ["[1][0]" synthesis {"+" [Synthesis]}]]]])

(syntax: (Vector [size <code>.nat
                  elemT <code>.any])
  (in (list (` [(~+ (list.repeated size elemT))]))))

(type: .public Nullary (-> (Vector 0 Expression) Computation))
(type: .public Unary   (-> (Vector 1 Expression) Computation))
(type: .public Binary  (-> (Vector 2 Expression) Computation))
(type: .public Trinary (-> (Vector 3 Expression) Computation))
(type: .public Variadic (-> (List Expression) Computation))

(syntax: (arity: [name <code>.local_identifier
                  arity <code>.nat])
  (with_identifiers [g!_ g!extension g!name g!phase g!inputs]
    (do [! macro.monad]
      [g!input+ (monad.all ! (list.repeated arity (macro.identifier "input")))]
      (in (list (` (def: .public ((~ (code.local_identifier name)) (~ g!extension))
                     (-> (-> (..Vector (~ (code.nat arity)) Expression) Computation)
                         Handler)
                     (function ((~ g!_) (~ g!name) (~ g!phase) (~ g!inputs))
                       (case (~ g!inputs)
                         (^ (list (~+ g!input+)))
                         (do /////.monad
                           [(~+ (|> g!input+
                                    (list\each (function (_ g!input)
                                                 (list g!input (` ((~ g!phase) (~ g!input))))))
                                    list.together))]
                           ((~' in) ((~ g!extension) [(~+ g!input+)])))

                         (~' _)
                         (/////.except /////extension.incorrect_arity [(~ g!name) 1 (list.size (~ g!inputs))]))))))))))

(arity: nullary 0)
(arity: unary 1)
(arity: binary 2)
(arity: trinary 3)

(def: .public (variadic extension)
  (-> Variadic Handler)
  (function (_ extension_name)
    (function (_ phase inputsS)
      (do [! /////.monad]
        [inputsI (monad.each ! phase inputsS)]
        (in (extension inputsI))))))

(def: bundle::lux
  Bundle
  (|> bundle.empty
      (bundle.install "is?" (binary (product.uncurried _.eq?/2)))
      (bundle.install "try" (unary ///runtime.lux//try))))

(template [<name> <op>]
  [(def: (<name> [subjectO paramO])
     Binary
     (<op> paramO subjectO))]
  
  [i64::and _.bit_and/2]
  [i64::or  _.bit_or/2]
  [i64::xor _.bit_xor/2]
  )

(def: (i64::left_shifted [subjectO paramO])
  Binary
  (_.arithmetic_shift/2 (_.remainder/2 (_.int +64) paramO)
                        subjectO))

(def: (i64::arithmetic_right_shifted [subjectO paramO])
  Binary
  (_.arithmetic_shift/2 (|> paramO (_.remainder/2 (_.int +64)) (_.*/2 (_.int -1)))
                        subjectO))

(def: (i64::logical_right_shifted [subjectO paramO])
  Binary
  (///runtime.i64//logical_right_shifted (_.remainder/2 (_.int +64) paramO) subjectO))

(template [<name> <op>]
  [(def: (<name> [subjectO paramO])
     Binary
     (|> subjectO (<op> paramO)))]

  [i64::+ _.+/2]
  [i64::- _.-/2]
  [i64::* _.*/2]
  [i64::/ _.quotient/2]
  [i64::% _.remainder/2]
  )

(template [<name> <op>]
  [(def: (<name> [subjectO paramO])
     Binary
     (<op> paramO subjectO))]

  [f64::+ _.+/2]
  [f64::- _.-/2]
  [f64::* _.*/2]
  [f64::/ _.//2]
  [f64::% _.mod/2]
  [f64::= _.=/2]
  [f64::< _.</2]

  [text::= _.string=?/2]
  [text::< _.string<?/2]
  )

(template [<name> <cmp>]
  [(def: (<name> [subjectO paramO])
     Binary
     (<cmp> paramO subjectO))]

  [i64::= _.=/2]
  [i64::< _.</2]
  )

(def: i64::char (|>> _.integer->char/1 _.string/1))

(def: bundle::i64
  Bundle
  (<| (bundle.prefix "i64")
      (|> bundle.empty
          (bundle.install "and" (binary i64::and))
          (bundle.install "or" (binary i64::or))
          (bundle.install "xor" (binary i64::xor))
          (bundle.install "left-shift" (binary i64::left_shifted))
          (bundle.install "logical-right-shift" (binary i64::logical_right_shifted))
          (bundle.install "arithmetic-right-shift" (binary i64::arithmetic_right_shifted))
          (bundle.install "+" (binary i64::+))
          (bundle.install "-" (binary i64::-))
          (bundle.install "*" (binary i64::*))
          (bundle.install "/" (binary i64::/))
          (bundle.install "%" (binary i64::%))
          (bundle.install "=" (binary i64::=))
          (bundle.install "<" (binary i64::<))
          (bundle.install "f64" (unary (|>> (_.//2 (_.float +1.0)))))
          (bundle.install "char" (unary i64::char)))))

(def: bundle::f64
  Bundle
  (<| (bundle.prefix "f64")
      (|> bundle.empty
          (bundle.install "+" (binary f64::+))
          (bundle.install "-" (binary f64::-))
          (bundle.install "*" (binary f64::*))
          (bundle.install "/" (binary f64::/))
          (bundle.install "%" (binary f64::%))
          (bundle.install "=" (binary f64::=))
          (bundle.install "<" (binary f64::<))
          (bundle.install "i64" (unary _.exact/1))
          (bundle.install "encode" (unary _.number->string/1))
          (bundle.install "decode" (unary ///runtime.frac//decode)))))

(def: (text::char [subjectO paramO])
  Binary
  (_.string/1 (_.string_ref/2 subjectO paramO)))

(def: (text::clip [subjectO startO endO])
  Trinary
  (_.substring/3 subjectO startO endO))

(def: bundle::text
  Bundle
  (<| (bundle.prefix "text")
      (|> bundle.empty
          (bundle.install "=" (binary text::=))
          (bundle.install "<" (binary text::<))
          (bundle.install "concat" (binary (product.uncurried _.string_append/2)))
          (bundle.install "size" (unary _.string_length/1))
          (bundle.install "char" (binary text::char))
          (bundle.install "clip" (trinary text::clip)))))

(def: (io::log input)
  Unary
  (_.begin (list (_.display/1 input)
                 _.newline/0)))

(def: (void code)
  (-> Expression Computation)
  (_.begin (list code (_.string //////synthesis.unit))))

(def: bundle::io
  Bundle
  (<| (bundle.prefix "io")
      (|> bundle.empty
          (bundle.install "log" (unary (|>> io::log ..void)))
          (bundle.install "error" (unary _.raise/1))
          (bundle.install "exit" (unary _.exit/1))
          (bundle.install "current-time" (nullary (function (_ _) (///runtime.io//current_time (_.string //////synthesis.unit))))))))

(def: .public bundle
  Bundle
  (<| (bundle.prefix "lux")
      (|> bundle::lux
          (dict.merged bundle::i64)
          (dict.merged bundle::f64)
          (dict.merged bundle::text)
          (dict.merged bundle::io)
          )))
