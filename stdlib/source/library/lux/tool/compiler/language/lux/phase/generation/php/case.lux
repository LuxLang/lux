(.using
 [library
  [lux (.except case let if)
   [abstract
    ["[0]" monad (.only do)]]
   [data
    ["[0]" product]
    ["[0]" text (.only)
     ["%" \\format (.only format)]]
    [collection
     ["[0]" list (.open: "[1]#[0]" functor mix)]
     ["[0]" set]]]
   [macro
    ["^" pattern]]
   [math
    [number
     ["i" int]]]
   [target
    ["_" php (.only Expression Var Statement)]]]]
 ["[0]" //
  ["[1][0]" runtime (.only Operation Phase Phase! Generator Generator!)]
  ["[1][0]" reference]
  ["[1][0]" primitive]
  ["/[1]" //
   ["[1][0]" reference]
   ["/[1]" //
    ["[1][0]" synthesis
     ["[1]/[0]" case]]
    ["/[1]" //
     ["[1][0]" synthesis (.only Member Synthesis Path)]
     ["[1][0]" generation]
     ["//[1]" ///
      [reference
       ["[1][0]" variable (.only Register)]]
      ["[1][0]" phase (.open: "[1]#[0]" monad)]
      [meta
       [archive (.only Archive)]]]]]]])

(def .public register
  (-> Register Var)
  (|>> (///reference.local //reference.system) as_expected))

(def .public capture
  (-> Register Var)
  (|>> (///reference.foreign //reference.system) as_expected))

(def .public (let expression archive [valueS register bodyS])
  (Generator [Synthesis Register Synthesis])
  (do ///////phase.monad
    [valueG (expression archive valueS)
     bodyG (expression archive bodyS)]
    (in (|> bodyG
            (list (_.set (..register register) valueG))
            _.array/*
            (_.item (_.int +1))))))

(def .public (let! statement expression archive [valueS register bodyS])
  (Generator! [Synthesis Register Synthesis])
  (do ///////phase.monad
    [valueO (expression archive valueS)
     body! (statement expression archive bodyS)]
    (in (all _.then
             (_.set! (..register register) valueO)
             body!))))

(def .public (if expression archive [testS thenS elseS])
  (Generator [Synthesis Synthesis Synthesis])
  (do ///////phase.monad
    [testG (expression archive testS)
     thenG (expression archive thenS)
     elseG (expression archive elseS)]
    (in (_.? testG thenG elseG))))

(def .public (if! statement expression archive [testS thenS elseS])
  (Generator! [Synthesis Synthesis Synthesis])
  (do ///////phase.monad
    [test! (expression archive testS)
     then! (statement expression archive thenS)
     else! (statement expression archive elseS)]
    (in (_.if test!
          then!
          else!))))

(def .public (get expression archive [pathP valueS])
  (Generator [(List Member) Synthesis])
  (do ///////phase.monad
    [valueG (expression archive valueS)]
    (in (list#mix (function (_ side source)
                    (.let [method (.case side
                                    (^.with_template [<side> <accessor>]
                                      [(<side> lefts)
                                       (<accessor> (_.int (.int lefts)))])
                                    ([.#Left //runtime.tuple//left]
                                     [.#Right //runtime.tuple//right]))]
                      (method source)))
                  valueG
                  (list.reversed pathP)))))

(def @savepoint (_.var "lux_pm_savepoint"))
(def @cursor (_.var "lux_pm_cursor"))
(def @temp (_.var "lux_pm_temp"))

(def (push! value)
  (-> Expression Statement)
  (_.; (_.array_push/2 [@cursor value])))

(def peek_and_pop
  Expression
  (_.array_pop/1 @cursor))

(def pop!
  Statement
  (_.; ..peek_and_pop))

(def peek
  Expression
  (_.item (|> @cursor _.count/1 (_.- (_.int +1)))
          @cursor))

(def save!
  Statement
  (.let [cursor (_.array_slice/2 [@cursor (_.int +0)])]
    (_.; (_.array_push/2 [@savepoint cursor]))))

(def restore!
  Statement
  (_.set! @cursor (_.array_pop/1 @savepoint)))

(def fail! _.break)

(def (multi_pop! pops)
  (-> Nat Statement)
  (_.; (_.array_splice/3 [@cursor
                          (_.int +0)
                          (_.int (i.* -1 (.int pops)))])))

(with_template [<name> <flag> <prep>]
  [(def (<name> simple? idx)
     (-> Bit Nat Statement)
     (all _.then
          (_.set! @temp (|> idx <prep> .int _.int (//runtime.sum//get ..peek <flag>)))
          (.if simple?
            (_.when (_.is_null/1 @temp)
                    fail!)
            (_.if (_.is_null/1 @temp)
              fail!
              (..push! @temp)))))]

  [left_choice  _.null        (<|)]
  [right_choice (_.string "") ++]
  )

(def (alternation pre! post!)
  (-> Statement Statement Statement)
  (all _.then
       (_.do_while (_.bool false)
                   (all _.then
                        ..save!
                        pre!))
       (all _.then
            ..restore!
            post!)))

(def (pattern_matching' statement expression archive)
  (Generator! Path)
  (function (again pathP)
    (.case pathP
      {/////synthesis.#Then bodyS}
      (statement expression archive bodyS)

      {/////synthesis.#Pop}
      (///////phase#in ..pop!)

      {/////synthesis.#Bind register}
      (///////phase#in (_.set! (..register register) ..peek))

      {/////synthesis.#Bit_Fork when thenP elseP}
      (do [! ///////phase.monad]
        [then! (again thenP)
         else! (.case elseP
                 {.#Some elseP}
                 (again elseP)

                 {.#None}
                 (in ..fail!))]
        (in (.if when
              (_.if ..peek
                then!
                else!)
              (_.if ..peek
                else!
                then!))))

      (^.with_template [<tag> <format>]
        [{<tag> item}
         (do [! ///////phase.monad]
           [clauses (monad.each ! (function (_ [match then])
                                    (do !
                                      [then! (again then)]
                                      (in [(_.=== (|> match <format>)
                                                  ..peek)
                                           then!])))
                                {.#Item item})]
           (in (_.cond clauses ..fail!)))])
      ([/////synthesis.#I64_Fork //primitive.i64]
       [/////synthesis.#F64_Fork //primitive.f64]
       [/////synthesis.#Text_Fork //primitive.text])

      (^.with_template [<complex> <simple> <choice>]
        [(pattern (<complex> idx))
         (///////phase#in (<choice> false idx))

         (pattern (<simple> idx nextP))
         (|> nextP
             again
             (at ///////phase.monad each (_.then (<choice> true idx))))])
      ([/////synthesis.side/left  /////synthesis.simple_left_side  ..left_choice]
       [/////synthesis.side/right /////synthesis.simple_right_side ..right_choice])

      (pattern (/////synthesis.member/left 0))
      (///////phase#in (|> ..peek (_.item (_.int +0)) ..push!))
      
      (^.with_template [<pm> <getter>]
        [(pattern (<pm> lefts))
         (///////phase#in (|> ..peek (<getter> (_.int (.int lefts))) ..push!))])
      ([/////synthesis.member/left  //runtime.tuple//left]
       [/////synthesis.member/right //runtime.tuple//right])

      (pattern (/////synthesis.!bind_top register thenP))
      (do ///////phase.monad
        [then! (again thenP)]
        (///////phase#in (all _.then
                              (_.set! (..register register) ..peek_and_pop)
                              then!)))

      ... (pattern (/////synthesis.!multi_pop nextP))
      ... (.let [[extra_pops nextP'] (////synthesis/case.count_pops nextP)]
      ...   (do ///////phase.monad
      ...     [next! (again nextP')]
      ...     (///////phase#in (all _.then
      ...                    (..multi_pop! (n.+ 2 extra_pops))
      ...                    next!))))

      (^.with_template [<tag> <combinator>]
        [(pattern (<tag> preP postP))
         (do ///////phase.monad
           [pre! (again preP)
            post! (again postP)]
           (in (<combinator> pre! post!)))])
      ([/////synthesis.path/seq _.then]
       [/////synthesis.path/alt ..alternation]))))

(def (pattern_matching statement expression archive pathP)
  (Generator! Path)
  (do ///////phase.monad
    [iteration! (pattern_matching' statement expression archive pathP)]
    (in (all _.then
             (_.do_while (_.bool false)
                         iteration!)
             (_.throw (_.new (_.constant "Exception") (list (_.string ////synthesis/case.pattern_matching_error))))))))

(def .public dependencies
  (-> Path (List Var))
  (|>> ////synthesis/case.storage
       (the ////synthesis/case.#dependencies)
       set.list
       (list#each (function (_ variable)
                    (.case variable
                      {///////variable.#Local register}
                      (..register register)
                      
                      {///////variable.#Foreign register}
                      (..capture register))))))

(def .public (case! statement expression archive [valueS pathP])
  (Generator! [Synthesis Path])
  (do ///////phase.monad
    [stack_init (expression archive valueS)
     pattern_matching! (pattern_matching statement expression archive pathP)]
    (in (all _.then
             (_.set! @cursor (_.array/* (list stack_init)))
             (_.set! @savepoint (_.array/* (list)))
             pattern_matching!))))

(def .public (case statement expression archive [valueS pathP])
  (-> Phase! (Generator [Synthesis Path]))
  (do [! ///////phase.monad]
    [[[case_module case_artifact] case!] (/////generation.with_new_context archive
                                           (case! statement expression archive [valueS pathP]))
     .let [@case (_.constant (///reference.artifact [case_module case_artifact]))
           @dependencies+ (..dependencies (/////synthesis.path/seq (/////synthesis.path/then valueS)
                                                                   pathP))
           directive (_.define_function @case (list#each _.parameter @dependencies+) case!)]
     _ (/////generation.execute! directive)
     _ (/////generation.save! case_artifact directive)]
    (in (_.apply @dependencies+ @case))))
