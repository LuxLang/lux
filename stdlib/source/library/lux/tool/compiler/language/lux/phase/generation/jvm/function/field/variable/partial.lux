(.using
 [library
  [lux {"-" Type}
   [abstract
    ["[0]" monad]]
   [data
    [collection
     ["[0]" list ("[1]#[0]" functor)]]]
   [math
    [number
     ["n" nat]]]
   [target
    [jvm
     ["[0]" field (.only Field)]
     ["_" bytecode (.only Bytecode) ("[1]#[0]" monad)]
     [type (.only Type)
      [category (.only Class)]]
     [constant
      [pool (.only Resource)]]]]]]
 ["[0]" //
  ["[1][0]" count]
  ["/[1]" // "_"
   [constant
    ["[1][0]" arity]]
   ["//[1]" /// "_"
    ["[1][0]" reference]
    [//////
     ["[0]" arity (.only Arity)]
     [reference
      [variable (.only Register)]]]]]])

(def: .public (initial amount)
  (-> Nat (Bytecode Any))
  (all _.composite
       (|> _.aconst_null
           (list.repeated amount)
           (monad.all _.monad))
       (_#in [])))

(def: .public (get class register)
  (-> (Type Class) Register (Bytecode Any))
  (//.get class (/////reference.partial_name register)))

(def: .public (put class register value)
  (-> (Type Class) Register (Bytecode Any) (Bytecode Any))
  (//.put /////reference.partial_name class register value))

(def: .public variables
  (-> Arity (List (Resource Field)))
  (|>> (n.- ///arity.minimum) (//.variables /////reference.partial_name)))

(def: .public (new arity)
  (-> Arity (Bytecode Any))
  (if (arity.multiary? arity)
    (all _.composite
         //count.initial
         (initial (n.- ///arity.minimum arity)))
    (_#in [])))
