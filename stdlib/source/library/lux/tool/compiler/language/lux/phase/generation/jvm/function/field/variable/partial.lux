(.using
  [library
   [lux {"-" Type}
    [abstract
     ["[0]" monad]]
    [data
     [number
      ["n" nat]]
     [collection
      ["[0]" list ("[1]#[0]" functor)]]]
    [target
     [jvm
      ["[0]" field {"+" Field}]
      ["_" bytecode {"+" Label Bytecode} ("[1]#[0]" monad)]
      [type {"+" Type}
       [category {"+" Class}]]
      [constant
       [pool {"+" Resource}]]]]]]
  ["[0]" / "_"
   ["[1][0]" count]
   ["/[1]" //
    ["/[1]" // "_"
     [constant
      ["[1][0]" arity]]
     ["//[1]" /// "_"
      ["[1][0]" reference]
      [//////
       ["[0]" arity {"+" Arity}]
       [reference
        [variable {"+" Register}]]]]]]])

(def: .public (initial amount)
  (-> Nat (Bytecode Any))
  ($_ _.composite
      (|> _.aconst_null
          (list.repeated amount)
          (monad.all _.monad))
      (_#in [])))

(def: .public (get class register)
  (-> (Type Class) Register (Bytecode Any))
  (//.get class (/////reference.partial_name register)))

(def: .public (put class register value)
  (-> (Type Class) Register (Bytecode Any) (Bytecode Any))
  (//.put /////reference.partial_name class register value))

(def: .public variables
  (-> Arity (List (Resource Field)))
  (|>> (n.- ///arity.minimum) (//.variables /////reference.partial_name)))

(def: .public (new arity)
  (-> Arity (Bytecode Any))
  (if (arity.multiary? arity)
    ($_ _.composite
        /count.initial
        (initial (n.- ///arity.minimum arity)))
    (_#in [])))
