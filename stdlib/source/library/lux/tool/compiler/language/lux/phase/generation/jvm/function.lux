(.module:
  [library
   [lux {"-" [Type]}
    [abstract
     ["." monad {"+" [do]}]]
    [data
     [number
      ["." i32]
      ["n" nat]]
     [collection
      ["." list ("#\." monoid functor)]
      ["." row]]
     ["." format "_"
      ["#" binary]]]
    [target
     [jvm
      ["." version]
      ["." modifier {"+" [Modifier]} ("#\." monoid)]
      ["." field {"+" [Field]}]
      ["." method {"+" [Method]}]
      ["_" bytecode {"+" [Label Bytecode]} ("#\." monad)]
      ["." class {"+" [Class]}]
      ["." type {"+" [Type]}
       [category {"+" [Return' Value']}]
       ["." reflection]]
      ["." constant
       [pool {"+" [Resource]}]]
      [encoding
       ["." name {"+" [External Internal]}]
       ["." unsigned]]]]
    [tool
     [compiler
      [meta
       ["." archive {"+" [Archive]}]]]]]]
  ["." / "_"
   ["#." abstract]
   [field
    [constant
     ["#." arity]]
    [variable
     ["#." foreign]
     ["#." partial]]]
   [method
    ["#." init]
    ["#." new]
    ["#." implementation]
    ["#." reset]
    ["#." apply]]
   ["/#" // "_"
    ["#." runtime {"+" [Operation Phase Generator]}]
    [////
     [analysis {"+" [Environment]}]
     [synthesis {"+" [Synthesis Abstraction Apply]}]
     ["." generation]
     [///
      ["." arity {"+" [Arity]}]
      ["." phase]
      [reference
       [variable {"+" [Register]}]]]]]])

(def: .public (with generate archive @begin class environment arity body)
  (-> Phase Archive Label External (Environment Synthesis) Arity (Bytecode Any)
      (Operation [(List (Resource Field))
                  (List (Resource Method))
                  (Bytecode Any)]))
  (let [classT (type.class class (list))
        fields (: (List (Resource Field))
                  (list& /arity.constant
                         (list\composite (/foreign.variables environment)
                                         (/partial.variables arity))))
        methods (: (List (Resource Method))
                   (list& (/init.method classT environment arity)
                          (/reset.method classT environment arity)
                          (if (arity.multiary? arity)
                            (|> (n.min arity /arity.maximum)
                                list.indices
                                (list\each (|>> ++ (/apply.method classT environment arity @begin body)))
                                (list& (/implementation.method arity @begin body)))
                            (list (/implementation.method' //runtime.apply::name arity @begin body)))))]
    (do phase.monad
      [instance (/new.instance generate archive classT environment arity)]
      (in [fields methods instance]))))

(def: modifier
  (Modifier Class)
  ($_ modifier\composite
      class.public
      class.final))

(def: this_offset 1)

(def: internal
  (All (_ category)
    (-> (Type (<| Return' Value' category))
        Internal))
  (|>> type.reflection reflection.reflection name.internal))

(def: .public (abstraction generate archive [environment arity bodyS])
  (Generator Abstraction)
  (do phase.monad
    [@begin //runtime.forge_label
     [function_context bodyG] (generation.with_new_context archive
                                (generation.with_anchor [@begin ..this_offset]
                                  (generate archive bodyS)))
     .let [function_class (//runtime.class_name function_context)]
     [fields methods instance] (..with generate archive @begin function_class environment arity bodyG)
     class (phase.lifted (class.class version.v6_0
                                      ..modifier
                                      (name.internal function_class)
                                      (..internal /abstract.class) (list)
                                      fields
                                      methods
                                      (row.row)))
     .let [bytecode (format.result class.writer class)]
     _ (generation.execute! [function_class bytecode])
     _ (generation.save! function_class #.None [function_class bytecode])]
    (in instance)))

(def: .public (apply generate archive [abstractionS inputsS])
  (Generator Apply)
  (do {! phase.monad}
    [abstractionG (generate archive abstractionS)
     inputsG (monad.each ! (generate archive) inputsS)]
    (in ($_ _.composite
            abstractionG
            (|> inputsG
                (list.sub /arity.maximum)
                (monad.each _.monad
                            (function (_ batchG)
                              ($_ _.composite
                                  (_.checkcast /abstract.class)
                                  (monad.all _.monad batchG)
                                  (_.invokevirtual /abstract.class //runtime.apply::name (//runtime.apply::type (list.size batchG)))
                                  ))))
            ))))
