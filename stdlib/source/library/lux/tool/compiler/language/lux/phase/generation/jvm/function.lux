(.using
 [library
  [lux {"-" Type Label}
   [abstract
    ["[0]" monad {"+" do}]]
   [data
    ["[0]" product]
    [collection
     ["[0]" list ("[1]#[0]" monoid functor)]
     ["[0]" sequence]]
    ["[0]" format "_"
     ["[1]" binary]]]
   [math
    [number
     ["n" nat]
     ["[0]" i32]]]
   [target
    [jvm
     ["[0]" version]
     ["[0]" modifier {"+" Modifier} ("[1]#[0]" monoid)]
     ["[0]" field {"+" Field}]
     ["[0]" method {"+" Method}]
     ["_" bytecode {"+" Label Bytecode} ("[1]#[0]" monad)]
     ["[0]" class {"+" Class}]
     ["[0]" type {"+" Type}
      [category {"+" Return' Value'}]
      ["[0]" reflection]]
     ["[0]" constant
      [pool {"+" Resource}]]
     [encoding
      ["[0]" name {"+" External Internal}]
      ["[0]" unsigned]]]]
   [tool
    [compiler
     [meta
      ["[0]" archive {"+" Archive}]
      ["[0]" cache "_"
       [dependency
        ["[1]/[0]" artifact]]]]]]]]
 ["[0]" / "_"
  ["[1][0]" abstract]
  [field
   [constant
    ["[1][0]" arity]]
   [variable
    ["[1][0]" foreign]
    ["[1][0]" partial]]]
  [method
   ["[1][0]" init]
   ["[1][0]" new]
   ["[1][0]" implementation]
   ["[1][0]" reset]
   ["[1][0]" apply]]
  ["/[1]" // "_"
   ["[1][0]" runtime {"+" Operation Phase Generator}]
   ["[1][0]" reference]
   [////
    [analysis {"+" Environment}]
    ["[0]" synthesis {"+" Synthesis Abstraction Apply}]
    ["[0]" generation]
    [///
     ["[0]" arity {"+" Arity}]
     ["[0]" phase]
     [meta
      [archive
       ["[0]" unit]]]
     [reference
      [variable {"+" Register}]]]]]])

(def: .public (with generate archive @begin class environment arity body)
  (-> Phase Archive Label External (Environment Synthesis) Arity (Bytecode Any)
      (Operation [(List (Resource Field))
                  (List (Resource Method))
                  (Bytecode Any)]))
  (let [classT (type.class class (list))
        fields (: (List (Resource Field))
                  (list#composite (/foreign.variables environment)
                                  (/partial.variables arity)))
        methods (: (List (Resource Method))
                   (list& (/init.method classT environment arity)
                          (/reset.method classT environment arity)
                          (if (arity.multiary? arity)
                            (|> (n.min arity /arity.maximum)
                                list.indices
                                (list#each (|>> ++ (/apply.method classT environment arity @begin body)))
                                (list& (/implementation.method classT arity @begin body)))
                            (list (/implementation.method classT arity @begin body)
                                  (/apply.method classT environment arity @begin body 1)))))]
    (do phase.monad
      [instance (/new.instance generate archive classT environment arity)]
      (in [fields methods instance]))))

(def: modifier
  (Modifier Class)
  ($_ modifier#composite
      class.public
      class.final))

(def: this_offset 1)

(def: internal
  (All (_ category)
    (-> (Type (<| Return' Value' category))
        Internal))
  (|>> type.reflection reflection.reflection name.internal))

(def: .public (abstraction generate archive [environment arity bodyS])
  (Generator Abstraction)
  (do phase.monad
    [dependencies (cache/artifact.dependencies archive bodyS)
     @begin //runtime.forge_label
     [function_context bodyG] (generation.with_new_context archive dependencies
                                (generation.with_anchor [@begin ..this_offset]
                                  (generate archive bodyS)))
     .let [function_class (//runtime.class_name function_context)]
     [fields methods instance] (..with generate archive @begin function_class environment arity bodyG)
     class (phase.lifted (class.class version.v6_0
                                      ..modifier
                                      (name.internal function_class)
                                      {.#None}
                                      (..internal /abstract.class) (list)
                                      fields
                                      methods
                                      (sequence.sequence)))
     .let [bytecode [function_class (format.result class.writer class)]]
     _ (generation.execute! bytecode)
     _ (generation.save! (product.right function_context) {.#None} bytecode)]
    (in instance)))

(def: (apply/?' generate archive [abstractionG inputsS])
  (Generator [(Bytecode Any) (List Synthesis)])
  (do [! phase.monad]
    [inputsG (monad.each ! (generate archive) inputsS)]
    (in ($_ _.composite
            abstractionG
            (|> inputsG
                (list.sub /arity.maximum)
                (monad.each _.monad
                            (function (_ batchG)
                              ($_ _.composite
                                  (_.checkcast /abstract.class)
                                  (monad.all _.monad batchG)
                                  (_.invokevirtual /abstract.class //runtime.apply::name (//runtime.apply::type (list.size batchG)))
                                  ))))
            ))))

(def: (apply/? generate archive [abstractionS inputsS])
  (Generator Apply)
  (do [! phase.monad]
    [abstractionG (generate archive abstractionS)]
    (apply/?' generate archive [abstractionG inputsS])))

(def: (apply/= generate archive [$abstraction @abstraction arity inputsS])
  (Generator [Symbol unit.ID Arity (List Synthesis)])
  (do [! phase.monad]
    [.let [:abstraction: (type.class (//runtime.class_name @abstraction) (list))]
     abstractionG (//reference.constant archive $abstraction)
     inputsG (monad.each ! (generate archive) inputsS)]
    (in ($_ _.composite
            abstractionG
            (monad.all _.monad inputsG)
            (/implementation.call :abstraction: arity)
            ))))

(def: (apply/> generate archive [$abstraction @abstraction arity inputsS])
  (Generator [Symbol unit.ID Arity (List Synthesis)])
  (do [! phase.monad]
    [=G (apply/= generate archive [$abstraction @abstraction arity (list.first arity inputsS)])]
    (apply/?' generate archive [=G (list.after arity inputsS)])))

(def: .public (apply generate archive [abstractionS inputsS])
  (Generator Apply)
  (case abstractionS
    (pattern (synthesis.constant $abstraction))
    (do [! phase.monad]
      [[@definition |abstraction|] (generation.definition archive $abstraction)
       .let [actual_arity (list.size inputsS)]]
      (case |abstraction|
        {.#Some [_ {.#Some [expected_arity @abstraction]}]}
        (cond (n.< expected_arity actual_arity)
              (apply/? generate archive [abstractionS inputsS])
              
              (n.= expected_arity actual_arity)
              (apply/= generate archive [$abstraction @abstraction expected_arity inputsS])
              
              ... (n.> expected_arity actual_arity)
              (apply/> generate archive [$abstraction @abstraction expected_arity inputsS]))
        
        _
        (apply/? generate archive [abstractionS inputsS])))

    _
    (apply/? generate archive [abstractionS inputsS])))
