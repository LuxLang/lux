(.module:
  [library
   [lux (#- Type)
    [abstract
     ["." monad (#+ do)]]
    [data
     [number
      ["." i32]
      ["n" nat]]
     [collection
      ["." list ("#\." monoid functor)]
      ["." row]]
     ["." format #_
      ["#" binary]]]
    [target
     [jvm
      ["." version]
      ["." modifier (#+ Modifier) ("#\." monoid)]
      ["." field (#+ Field)]
      ["." method (#+ Method)]
      ["_" bytecode (#+ Label Bytecode) ("#\." monad)]
      ["." class (#+ Class)]
      ["." type (#+ Type)
       [category (#+ Return' Value')]
       ["." reflection]]
      ["." constant
       [pool (#+ Resource)]]
      [encoding
       ["." name (#+ External Internal)]
       ["." unsigned]]]]
    [tool
     [compiler
      [meta
       ["." archive (#+ Archive)]]]]]]
  ["." / #_
   ["#." abstract]
   [field
    [constant
     ["#." arity]]
    [variable
     ["#." foreign]
     ["#." partial]]]
   [method
    ["#." init]
    ["#." new]
    ["#." implementation]
    ["#." reset]
    ["#." apply]]
   ["/#" // #_
    ["#." runtime (#+ Operation Phase Generator)]
    [////
     [analysis (#+ Environment)]
     [synthesis (#+ Synthesis Abstraction Apply)]
     ["." generation]
     [///
      ["." arity (#+ Arity)]
      ["." phase]
      [reference
       [variable (#+ Register)]]]]]])

(def: #export (with generate archive @begin class environment arity body)
  (-> Phase Archive Label External (Environment Synthesis) Arity (Bytecode Any)
      (Operation [(List (Resource Field))
                  (List (Resource Method))
                  (Bytecode Any)]))
  (let [classT (type.class class (list))
        fields (: (List (Resource Field))
                  (list& /arity.constant
                         (list\compose (/foreign.variables environment)
                                       (/partial.variables arity))))
        methods (: (List (Resource Method))
                   (list& (/init.method classT environment arity)
                          (/reset.method classT environment arity)
                          (if (arity.multiary? arity)
                            (|> (n.min arity /arity.maximum)
                                list.indices
                                (list\map (|>> inc (/apply.method classT environment arity @begin body)))
                                (list& (/implementation.method arity @begin body)))
                            (list (/implementation.method' //runtime.apply::name arity @begin body)))))]
    (do phase.monad
      [instance (/new.instance generate archive classT environment arity)]
      (in [fields methods instance]))))

(def: modifier
  (Modifier Class)
  ($_ modifier\compose
      class.public
      class.final))

(def: this_offset 1)

(def: internal
  (All [category]
    (-> (Type (<| Return' Value' category))
        Internal))
  (|>> type.reflection reflection.reflection name.internal))

(def: #export (abstraction generate archive [environment arity bodyS])
  (Generator Abstraction)
  (do phase.monad
    [@begin //runtime.forge_label
     [function_context bodyG] (generation.with_new_context archive
                                (generation.with_anchor [@begin ..this_offset]
                                  (generate archive bodyS)))
     .let [function_class (//runtime.class_name function_context)]
     [fields methods instance] (..with generate archive @begin function_class environment arity bodyG)
     class (phase.lift (class.class version.v6_0
                                    ..modifier
                                    (name.internal function_class)
                                    (..internal /abstract.class) (list)
                                    fields
                                    methods
                                    (row.row)))
     .let [bytecode (format.run class.writer class)]
     _ (generation.execute! [function_class bytecode])
     _ (generation.save! function_class #.None [function_class bytecode])]
    (in instance)))

(def: #export (apply generate archive [abstractionS inputsS])
  (Generator Apply)
  (do {! phase.monad}
    [abstractionG (generate archive abstractionS)
     inputsG (monad.map ! (generate archive) inputsS)]
    (in ($_ _.compose
            abstractionG
            (|> inputsG
                (list.chunk /arity.maximum)
                (monad.map _.monad
                           (function (_ batchG)
                             ($_ _.compose
                                 (_.checkcast /abstract.class)
                                 (monad.seq _.monad batchG)
                                 (_.invokevirtual /abstract.class //runtime.apply::name (//runtime.apply::type (list.size batchG)))
                                 ))))
            ))))
