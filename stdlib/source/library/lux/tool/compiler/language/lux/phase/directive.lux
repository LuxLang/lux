(.using
  [library
   [lux "*"
    ["[0]" meta]
    [abstract
     ["[0]" monad {"+" do}]]
    [control
     ["[0]" try]
     ["[0]" exception {"+" exception:}]]
    [data
     [text
      ["%" format {"+" format}]]
     [collection
      ["[0]" list ("[1]#[0]" mix monoid)]]]]]
  ["[0]" // "_"
   ["[1][0]" extension]
   ["[1][0]" analysis
    ["[1]/[0]" type]]
   ["/[1]" // "_"
    ["/" directive {"+" Operation Phase}]
    ["[1][0]" analysis
     ["[0]" evaluation]
     ["[1]/[0]" macro {"+" Expander}]]
    [///
     ["//" phase]
     [reference {"+" }
      [variable {"+" }]]
     [meta
      [archive {"+" Archive}]]]]])

(exception: .public (not_a_directive [code Code])
  (exception.report
   ["Directive" (%.code code)]))

(exception: .public (invalid_macro_call [code Code])
  (exception.report
   ["Code" (%.code code)]))

(exception: .public (macro_was_not_found [name Symbol])
  (exception.report
   ["Name" (%.symbol name)]))

(type: Eval
  (-> Type Code (Meta Any)))

(def: (meta_eval archive bundle compiler_eval)
  (-> Archive ///analysis.Bundle evaluation.Eval
      Eval)
  (function (_ type code lux)
    (case (compiler_eval archive type code [bundle lux])
      {try.#Success [[_bundle lux'] value]}
      {try.#Success [lux' value]}
      
      {try.#Failure error}
      {try.#Failure error})))

(def: (requiring phase archive expansion)
  (All (_ anchor expression directive)
    (-> (Phase anchor expression directive) Archive (List Code)
        (Operation anchor expression directive /.Requirements)))
  (function (_ state)
    (loop [state state
           input expansion
           output /.no_requirements]
      (case input
        {.#End}
        {try.#Success [state output]}
        
        {.#Item head tail}
        (case (phase archive head state)
          {try.#Success [state' head']}
          (again state' tail (/.merge_requirements head' output))
          
          {try.#Failure error}
          {try.#Failure error})))))

(with_expansions [<lux_def_module> (as_is [|form_location| {.#Form (list& [|text_location| {.#Text "lux def module"}] annotations)}])]
  (def: .public (phase wrapper expander)
    (-> //.Wrapper Expander Phase)
    (let [analysis (//analysis.phase expander)]
      (function (again archive code)
        (do [! //.monad]
          [state //.state
           .let [compiler_eval (meta_eval archive
                                          (value@ [//extension.#state /.#analysis /.#state //extension.#bundle] state)
                                          (evaluation.evaluator expander
                                                                (value@ [//extension.#state /.#synthesis /.#state] state)
                                                                (value@ [//extension.#state /.#generation /.#state] state)
                                                                (value@ [//extension.#state /.#generation /.#phase] state)))
                 extension_eval (:as Eval (wrapper (:expected compiler_eval)))]
           _ (//.with (with@ [//extension.#state /.#analysis /.#state //extension.#state .#eval] extension_eval state))]
          (case code
            (^ [_ {.#Form (list& [_ {.#Text name}] inputs)}])
            (//extension.apply archive again [name inputs])

            (^ [_ {.#Form (list& macro inputs)}])
            (do !
              [expansion (/.lifted_analysis
                          (do !
                            [macroA (//analysis/type.with_type Macro
                                      (analysis archive macro))]
                            (case macroA
                              (^ (///analysis.constant macro_name))
                              (do !
                                [?macro (//extension.lifted (meta.macro macro_name))
                                 macro (case ?macro
                                         {.#Some macro}
                                         (in macro)
                                         
                                         {.#None}
                                         (//.except ..macro_was_not_found macro_name))]
                                (//extension.lifted (///analysis/macro.expansion expander macro_name macro inputs)))
                              
                              _
                              (//.except ..invalid_macro_call code))))]
              (case expansion
                (^ (list& <lux_def_module> referrals))
                (|> (again archive <lux_def_module>)
                    (# ! each (revised@ /.#referrals (list#composite referrals))))

                _
                (..requiring again archive expansion)))

            _
            (//.except ..not_a_directive code)))))))
