(.using
 [library
  [lux {"-" ++}
   [abstract
    ["[0]" monad {"+" do}]]
   [control
    ["[0]" function]
    ["<>" parser
     ["<[0]>" code]]]
   [data
    ["[0]" product]
    ["[0]" text ("[1]#[0]" hash)
     ["%" format {"+" format}]
     [encoding
      ["[0]" utf8]]]
    [collection
     ["[0]" list ("[1]#[0]" functor)]
     ["[0]" sequence]]]
   ["[0]" macro
    [syntax {"+" syntax:}]
    ["[0]" code]]
   [math
    [number {"+" hex}
     ["f" frac]
     ["[0]" i64]]]
   ["[0]" meta
    ["[0]" version]]
   ["@" target
    ["_" python {"+" Expression SVar Computation Literal Statement}]]]]
 ["[0]" /// "_"
  ["[1][0]" reference]
  ["//[1]" /// "_"
   ["[1][0]" synthesis {"+" Synthesis}]
   ["[1][0]" generation]
   ["//[1]" ///
    ["[1][0]" phase]
    [reference
     [variable {"+" Register}]]
    [meta
     [archive {"+" Output Archive}
      ["[0]" registry {"+" Registry}]
      ["[0]" unit]]]]]])

(template [<name> <base>]
  [(type: .public <name>
     (<base> Register (Expression Any) (Statement Any)))]

  [Operation /////generation.Operation]
  [Phase /////generation.Phase]
  [Handler /////generation.Handler]
  [Bundle /////generation.Bundle]
  )

(type: .public Phase!
  (-> Phase Archive Synthesis (Operation (Statement Any))))

(type: .public (Generator! i)
  (-> Phase! Phase Archive i (Operation (Statement Any))))

(type: .public (Generator i)
  (-> Phase Archive i (Operation (Expression Any))))

(def: prefix
  "LuxRuntime")

(def: .public unit
  (_.unicode /////synthesis.unit))

(def: (flag value)
  (-> Bit Literal)
  (if value
    ..unit
    _.none))

(def: (variant' tag last? value)
  (-> (Expression Any) (Expression Any) (Expression Any) Literal)
  (_.tuple (list tag last? value)))

(def: .public (variant tag last? value)
  (-> Nat Bit (Expression Any) Literal)
  (variant' (_.int (.int tag))
            (flag last?)
            value))

(def: .public left
  (-> (Expression Any) Literal)
  (..variant 0 #0))

(def: .public right
  (-> (Expression Any) Literal)
  (..variant 0 #1))

(def: .public none
  Literal
  (..left ..unit))

(def: .public some
  (-> (Expression Any) Literal)
  ..right)

(def: (runtime_name name)
  (-> Text SVar)
  (let [symbol (format ..prefix
                       "_" (%.nat version.latest)
                       "_" (%.nat (text#hash name)))]
    (_.var symbol)))

(def: (feature name definition)
  (-> SVar (-> SVar (Statement Any)) (Statement Any))
  (definition name))

(syntax: .public (with_vars [vars (<code>.tuple (<>.some <code>.local))
                             body <code>.any])
  (do [! meta.monad]
    [ids (monad.all ! (list.repeated (list.size vars) meta.seed))]
    (in (list (` (let [(~+ (|> vars
                               (list.zipped_2 ids)
                               (list#each (function (_ [id var])
                                            (list (code.local var)
                                                  (` (_.var (~ (code.text (format "v" (%.nat id)))))))))
                               list.together))]
                   (~ body)))))))

(syntax: (runtime: [declaration (<>.or <code>.local
                                       (<code>.form (<>.and <code>.local
                                                            (<>.some <code>.local))))
                    code <code>.any])
  (case declaration
    {.#Left name}
    (macro.with_symbols [g!_]
      (let [nameC (code.local name)
            code_nameC (code.local (format "@" name))
            runtime_nameC (` (runtime_name (~ (code.text name))))]
        (in (list (` (def: .public (~ nameC) SVar (~ runtime_nameC)))
                  (` (def: (~ code_nameC)
                       (Statement Any)
                       (..feature (~ runtime_nameC)
                                  (function ((~ g!_) (~ g!_))
                                    (_.set (list (~ g!_)) (~ code))))))))))
    
    {.#Right [name inputs]}
    (macro.with_symbols [g!_]
      (let [nameC (code.local name)
            code_nameC (code.local (format "@" name))
            runtime_nameC (` (runtime_name (~ (code.text name))))
            inputsC (list#each code.local inputs)
            inputs_typesC (list#each (function.constant (` (_.Expression Any)))
                                     inputs)]
        (in (list (` (def: .public ((~ nameC) (~+ inputsC))
                       (-> (~+ inputs_typesC) (Computation Any))
                       (_.apply/* (list (~+ inputsC)) (~ runtime_nameC))))
                  (` (def: (~ code_nameC)
                       (Statement Any)
                       (..feature (~ runtime_nameC)
                                  (function ((~ g!_) (~ g!_))
                                    (..with_vars [(~+ inputsC)]
                                      (_.def (~ g!_) (list (~+ inputsC))
                                             (~ code)))))))))))))

(runtime: (lux::try op)
  (with_vars [exception]
    (_.try (_.return (..right (_.apply/* (list ..unit) op)))
           (list [(list "Exception") exception
                  (_.return (..left (_.str/1 exception)))]))))

(runtime: (lux::program_args program_args)
  (with_vars [inputs value]
    ($_ _.then
        (_.set (list inputs) ..none)
        (<| (_.for_in value (_.apply/* (list program_args) (_.var "reversed")))
            (_.set (list inputs)
                   (..some (_.list (list value inputs)))))
        (_.return inputs))))

(runtime: (lux::exec code globals)
  ($_ _.then
      (_.exec {.#Some globals} code)
      (_.return ..unit)))

(def: runtime::lux
  (Statement Any)
  ($_ _.then
      @lux::try
      @lux::program_args
      @lux::exec
      ))

(runtime: (io::log! message)
  ($_ _.then
      (_.print message)
      (|> (_.__import__/1 (_.unicode "sys"))
          (_.the "stdout")
          (_.do "flush" (list))
          _.statement)
      (_.return ..unit)))

(runtime: (io::throw! message)
  (_.raise (_.Exception/1 message)))

(def: runtime::io
  (Statement Any)
  ($_ _.then
      @io::log!
      @io::throw!
      ))

(def: last_index
  (|>> _.len/1 (_.- (_.int +1))))

(with_expansions [<recur> (these ($_ _.then
                                     (_.set (list lefts) (_.- last_index_right lefts))
                                     (_.set (list tuple) (_.item last_index_right tuple))))]
  (runtime: (tuple::left lefts tuple)
    (with_vars [last_index_right]
      (_.while (_.bool true)
               ($_ _.then
                   (_.set (list last_index_right) (..last_index tuple))
                   (_.if (_.> lefts last_index_right)
                     ... No need for recursion
                     (_.return (_.item lefts tuple))
                     ... Needs recursion
                     <recur>))
               {.#None})))

  (runtime: (tuple::right lefts tuple)
    (with_vars [last_index_right right_index]
      (_.while (_.bool true)
               ($_ _.then
                   (_.set (list last_index_right) (..last_index tuple))
                   (_.set (list right_index) (_.+ (_.int +1) lefts))
                   (<| (_.if (_.= last_index_right right_index)
                         (_.return (_.item right_index tuple)))
                       (_.if (_.> last_index_right right_index)
                         ... Needs recursion.
                         <recur>)
                       (_.return (_.slice_from right_index tuple))))
               {.#None}))))

(runtime: (sum::get sum expected##right? expected##lefts)
  (let [mismatch! (_.return _.none)
        actual##lefts (_.item (_.int +0) sum)
        actual##right? (_.item (_.int +1) sum)
        actual##value (_.item (_.int +2) sum)
        recur! ($_ _.then
                   (_.set (list expected##lefts) (|> expected##lefts
                                                     (_.- actual##lefts)
                                                     (_.- (_.int +1))))
                   (_.set (list sum) actual##value))]
    (_.while (_.bool true)
             (<| (_.if (_.= expected##lefts actual##lefts)
                   (_.if (_.= expected##right? actual##right?)
                     (_.return actual##value)
                     mismatch!))
                 (_.if (_.< expected##lefts actual##lefts)
                   (_.if (_.= ..unit actual##right?)
                     recur!
                     mismatch!))
                 (_.if (_.= ..unit expected##right?)
                   (_.return (variant' (|> actual##lefts
                                           (_.- expected##lefts)
                                           (_.- (_.int +1)))
                                       actual##right?
                                       actual##value)))
                 mismatch!)
             {.#None})))

(def: runtime::adt
  (Statement Any)
  ($_ _.then
      @tuple::left
      @tuple::right
      @sum::get
      ))

(def: i64::+limit (_.manual "+0x7FFFFFFFFFFFFFFF"))
(def: i64::-limit (_.manual "-0x8000000000000000"))
(def: i64::+iteration (_.manual "+0x10000000000000000"))
(def: i64::-iteration (_.manual "-0x10000000000000000"))
(def: i64::+cap (_.manual "+0x8000000000000000"))
(def: i64::-cap (_.manual "-0x8000000000000001"))

(runtime: (i64::64 input)
  (with_vars [temp]
    (`` (<| (~~ (template [<scenario> <iteration> <cap> <entrance>]
                  [(_.if (|> input <scenario>)
                     ($_ _.then
                         (_.set (list temp) (_.% <iteration> input))
                         (_.return (_.? (|> temp <scenario>)
                                        (|> temp (_.- <cap>) (_.+ <entrance>))
                                        temp))))]

                  [(_.> ..i64::+limit) ..i64::+iteration ..i64::+cap ..i64::-limit]
                  [(_.< ..i64::-limit) ..i64::-iteration ..i64::-cap ..i64::+limit]
                  ))
            (_.return (for @.python input
                           ... This +- is only necessary to guarantee that values within the limits are always longs in Python 2
                           (|> input (_.+ ..i64::+limit) (_.- ..i64::+limit))))))))

(def: as_nat
  (_.% ..i64::+iteration))

(runtime: (i64::left_shifted param subject)
  (_.return (|> subject
                (_.bit_shl (_.% (_.int +64) param))
                ..i64::64)))

(runtime: (i64::right_shifted param subject)
  ($_ _.then
      (_.set (list param) (_.% (_.int +64) param))
      (_.return (_.? (_.= (_.int +0) param)
                     subject
                     (|> subject
                         ..as_nat
                         (_.bit_shr param))))))

(runtime: (i64#/ param subject)
  (with_vars [floored]
    ($_ _.then
        (_.set (list floored) (_.// param subject))
        (_.return (let [potentially_floored? (_.< (_.int +0) floored)
                        inexact? (|> subject
                                     (_.% param)
                                     (_.= (_.int +0))
                                     _.not)]
                    (<| (_.? (_.and potentially_floored?
                                    inexact?)
                             (_.+ (_.int +1) floored))
                        (_.? (_.= (_.manual "+9223372036854775808")
                                  floored)
                             (_.manual "-9223372036854775808"))
                        floored))))))

(runtime: (i64::remainder param subject)
  (_.return (_.- (|>  subject (..i64#/ param) (_.* param))
                 subject)))

(template [<runtime> <host>]
  [(runtime: (<runtime> left right)
     (_.return (..i64::64 (<host> (..as_nat left) (..as_nat right)))))]

  [i64::and _.bit_and]
  [i64::or _.bit_or]
  [i64::xor _.bit_xor]
  )

(def: python_version
  (Expression Any)
  (|> (_.__import__/1 (_.unicode "sys"))
      (_.the "version_info")
      (_.the "major")))

(runtime: (i64::char value)
  (_.return (_.? (_.= (_.int +3) ..python_version)
                 (_.chr/1 value)
                 (_.unichr/1 value))))

(def: runtime::i64
  (Statement Any)
  ($_ _.then
      @i64::64
      @i64::left_shifted
      @i64::right_shifted
      @i64#/
      @i64::remainder
      @i64::and
      @i64::or
      @i64::xor
      @i64::char
      ))

(runtime: (f64::/ parameter subject)
  (_.return (_.? (_.= (_.float +0.0) parameter)
                 (<| (_.? (_.> (_.float +0.0) subject)
                          (_.float f.positive_infinity))
                     (_.? (_.< (_.float +0.0) subject)
                          (_.float f.negative_infinity))
                     (_.float f.not_a_number))
                 (_./ parameter subject))))

(runtime: (f64::decode input)
  (with_vars [ex]
    (_.try (_.return (..some (_.float/1 input)))
           (list [(list "Exception") ex
                  (_.return ..none)]))))

(def: runtime::f64
  (Statement Any)
  ($_ _.then
      @f64::/
      @f64::decode
      ))

(runtime: (text::index start param subject)
  (with_vars [idx]
    ($_ _.then
        (_.set (list idx) (|> subject (_.do "find" (list param start))))
        (_.return (_.? (_.= (_.int -1) idx)
                       ..none
                       (..some (..i64::64 idx)))))))

(def: ++
  (|>> (_.+ (_.int +1))))

(def: (within? top value)
  (-> (Expression Any) (Expression Any) (Computation Any))
  (_.and (|> value (_.>= (_.int +0)))
         (|> value (_.< top))))

(runtime: (text::clip @offset @length @text)
  (_.return (|> @text (_.slice @offset (_.+ @offset @length)))))

(runtime: (text::char idx text)
  (_.if (|> idx (within? (_.len/1 text)))
    (_.return (|> text (_.slice idx (..++ idx)) _.ord/1 ..i64::64))
    (_.raise (_.Exception/1 (_.unicode "[Lux Error] Cannot get char from text.")))))

(def: runtime::text
  (Statement Any)
  ($_ _.then
      @text::index
      @text::clip
      @text::char
      ))

(runtime: (array::write idx value array)
  ($_ _.then
      (_.set (list (_.item idx array)) value)
      (_.return array)))

(def: runtime::array
  (Statement Any)
  ($_ _.then
      @array::write
      ))

(def: runtime
  (Statement Any)
  ($_ _.then
      runtime::lux
      runtime::io
      runtime::adt
      runtime::i64
      runtime::f64
      runtime::text
      runtime::array
      ))

(def: module_id
  0)

(def: .public generate
  (Operation [Registry Output])
  (do ///////phase.monad
    [_ (/////generation.execute! ..runtime)
     _ (/////generation.save! ..module_id {.#None} ..runtime)]
    (in [(|> registry.empty
             (registry.resource true unit.none)
             product.right)
         (sequence.sequence [..module_id
                             {.#None}
                             (|> ..runtime
                                 _.code
                                 (# utf8.codec encoded))])])))
