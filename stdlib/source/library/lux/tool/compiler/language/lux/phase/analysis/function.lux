(.module:
  [library
   [lux {"-" [function]}
    [abstract
     monad]
    [control
     ["." maybe]
     ["ex" exception {"+" [exception:]}]]
    [data
     ["." text
      ["%" format {"+" [format]}]]
     [collection
      ["." list ("#\." monoid monad)]]]
    ["." type
     ["." check]]
    ["." meta]]]
  ["." // "_"
   ["#." scope]
   ["#." type]
   ["#." inference]
   ["/#" // "_"
    ["#." extension]
    [//
     ["/" analysis {"+" [Analysis Operation Phase]}]
     [///
      ["#" phase]
      [reference {"+" []}
       [variable {"+" []}]]]]]])

(exception: .public (cannot_analyse {expected Type} {function Text} {argument Text} {body Code})
  (ex.report ["Type" (%.type expected)]
             ["Function" function]
             ["Argument" argument]
             ["Body" (%.code body)]))

(exception: .public (cannot_apply {functionT Type} {functionC Code} {arguments (List Code)})
  (ex.report ["Function type" (%.type functionT)]
             ["Function" (%.code functionC)]
             ["Arguments" (|> arguments
                              list.enumeration
                              (list\each (.function (_ [idx argC])
                                           (format (%.nat idx) " " (%.code argC))))
                              (text.interposed text.new_line))]))

(def: .public (function analyse function_name arg_name archive body)
  (-> Phase Text Text Phase)
  (do {! ///.monad}
    [functionT (///extension.lifted meta.expected_type)]
    (loop [expectedT functionT]
      (/.with_stack ..cannot_analyse [expectedT function_name arg_name body]
        (case expectedT
          (#.Named name unnamedT)
          (recur unnamedT)

          (#.Apply argT funT)
          (case (type.applied (list argT) funT)
            (#.Some value)
            (recur value)

            #.None
            (/.failure (ex.error cannot_analyse [expectedT function_name arg_name body])))

          (^template [<tag> <instancer>]
            [(<tag> _)
             (do !
               [[_ instanceT] (//type.with_env <instancer>)]
               (recur (maybe.trusted (type.applied (list instanceT) expectedT))))])
          ([#.UnivQ check.existential]
           [#.ExQ check.var])
          
          (#.Var id)
          (do !
            [?expectedT' (//type.with_env
                           (check.peek id))]
            (case ?expectedT'
              (#.Some expectedT')
              (recur expectedT')

              ... Inference
              _
              (do !
                [[input_id inputT] (//type.with_env check.var)
                 [output_id outputT] (//type.with_env check.var)
                 .let [functionT (#.Function inputT outputT)]
                 functionA (recur functionT)
                 _ (//type.with_env
                     (check.check expectedT functionT))]
                (in functionA))))

          (#.Function inputT outputT)
          (<| (\ ! each (.function (_ [scope bodyA])
                          (#/.Function (list\each (|>> /.variable)
                                                  (//scope.environment scope))
                                       bodyA)))
              /.with_scope
              ... Functions have access not only to their argument, but
              ... also to themselves, through a local variable.
              (//scope.with_local [function_name expectedT])
              (//scope.with_local [arg_name inputT])
              (//type.with_type outputT)
              (analyse archive body))
          
          _
          (/.failure "")
          )))))

(def: .public (apply analyse argsC+ functionT functionA archive functionC)
  (-> Phase (List Code) Type Analysis Phase)
  (<| (/.with_stack ..cannot_apply [functionT functionC argsC+])
      (do ///.monad
        [[applyT argsA+] (//inference.general archive analyse functionT argsC+)])
      (in (/.apply [functionA argsA+]))))
