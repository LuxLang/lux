(.using
 [library
  [lux {"-" function}
   ["[0]" meta]
   [abstract
    monad]
   [control
    ["[0]" maybe]
    ["ex" exception {"+" exception:}]]
   [data
    ["[0]" text
     ["%" format {"+" format}]]
    [collection
     ["[0]" list ("[1]#[0]" monoid monad)]]]
   ["[0]" type
    ["[0]" check]]]]
 ["[0]" /// "_"
  ["[1][0]" extension]
  [//
   ["/" analysis {"+" Analysis Operation Phase}
    ["[1][0]" type]
    ["[1][0]" inference]
    ["[1][0]" scope]]
   [///
    ["[1]" phase]
    [reference {"+"}
     [variable {"+"}]]]]])

(exception: .public (cannot_analyse [expected Type
                                     function Text
                                     argument Text
                                     body Code])
  (ex.report ["Type" (%.type expected)]
             ["Function" function]
             ["Argument" argument]
             ["Body" (%.code body)]))

(exception: .public (cannot_apply [functionT Type
                                   functionC Code
                                   arguments (List Code)])
  (ex.report ["Function type" (%.type functionT)]
             ["Function" (%.code functionC)]
             ["Arguments" (|> arguments
                              list.enumeration
                              (list#each (.function (_ [idx argC])
                                           (format (%.nat idx) " " (%.code argC))))
                              (text.interposed text.new_line))]))

(def: .public (function analyse function_name arg_name archive body)
  (-> Phase Text Text Phase)
  (do [! ///.monad]
    [functionT (///extension.lifted meta.expected_type)]
    (loop [expectedT functionT]
      (/.with_exception ..cannot_analyse [expectedT function_name arg_name body]
        (case expectedT
          {.#Named name unnamedT}
          (again unnamedT)

          {.#Apply argT funT}
          (case (type.applied (list argT) funT)
            {.#Some value}
            (again value)

            {.#None}
            (/.failure (ex.error cannot_analyse [expectedT function_name arg_name body])))

          (^template [<tag> <instancer>]
            [{<tag> _}
             (do !
               [[_ instanceT] (/type.check <instancer>)]
               (again (maybe.trusted (type.applied (list instanceT) expectedT))))])
          ([.#UnivQ check.existential]
           [.#ExQ check.var])
          
          {.#Var id}
          (do !
            [?expectedT' (/type.check (check.peek id))]
            (case ?expectedT'
              {.#Some expectedT'}
              (again expectedT')

              ... Inference
              _
              (do !
                [[input_id inputT] (/type.check check.var)
                 [output_id outputT] (/type.check check.var)
                 .let [functionT {.#Function inputT outputT}]
                 functionA (again functionT)
                 _ (/type.check (check.check expectedT functionT))]
                (in functionA))))

          {.#Function inputT outputT}
          (<| (# ! each (.function (_ [scope bodyA])
                          {/.#Function (list#each (|>> /.variable)
                                                  (/scope.environment scope))
                                       bodyA}))
              /scope.with
              ... Functions have access not only to their argument, but
              ... also to themselves, through a local variable.
              (/scope.with_local [function_name expectedT])
              (/scope.with_local [arg_name inputT])
              (/type.expecting outputT)
              (analyse archive body))
          
          _
          (/.failure "")
          )))))

(def: .public (apply analyse argsC+ functionT functionA archive functionC)
  (-> Phase (List Code) Type Analysis Phase)
  (<| (/.with_exception ..cannot_apply [functionT functionC argsC+])
      (do ///.monad
        [[applyT argsA+] (/inference.general archive analyse functionT argsC+)])
      (in (/.reified [functionA argsA+]))))
