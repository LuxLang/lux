(.using
 [library
  [lux {"-" function}
   ["[0]" meta]
   [abstract
    monad]
   [control
    ["[0]" maybe]
    ["[0]" try]
    ["[0]" exception {"+" exception:}]]
   [data
    ["[0]" product]
    ["[0]" text
     ["%" format {"+" format}]]
    [collection
     ["[0]" list ("[1]#[0]" monoid monad)]]]
   [math
    [number
     ["n" nat]]]
   ["[0]" type
    ["[0]" check]]]]
 ["[0]" /// "_"
  ["[1][0]" extension]
  [//
   ["/" analysis {"+" Analysis Operation Phase}
    ["[1][0]" type]
    ["[1][0]" inference]
    ["[1][0]" scope]]
   [///
    ["[1]" phase ("[1]#[0]" functor)]
    [reference {"+"}
     [variable {"+"}]]]]])

(exception: .public (cannot_analyse [expected Type
                                     function Text
                                     argument Text
                                     body Code])
  (exception.report
   ["Type" (%.type expected)]
   ["Function" function]
   ["Argument" argument]
   ["Body" (%.code body)]))

(exception: .public (cannot_apply [:function: Type
                                   functionC Code
                                   arguments (List Code)])
  (exception.report
   ["Function type" (%.type :function:)]
   ["Function" (%.code functionC)]
   ["Arguments" (|> arguments
                    list.enumeration
                    (list#each (.function (_ [idx argC])
                                 (format (%.nat idx) " " (%.code argC))))
                    (text.interposed text.new_line))]))

(def: .public (function analyse function_name arg_name archive body)
  (-> Phase Text Text Phase)
  (do [! ///.monad]
    [:function: (///extension.lifted meta.expected_type)]
    (loop [expectedT :function:]
      (/.with_exception ..cannot_analyse [expectedT function_name arg_name body]
        (case expectedT
          {.#Function :input: :output:}
          (<| (# ! each (.function (_ [scope bodyA])
                          {/.#Function (list#each (|>> /.variable)
                                                  (/scope.environment scope))
                                       bodyA}))
              /scope.with
              ... Functions have access not only to their argument, but
              ... also to themselves, through a local variable.
              (/scope.with_local [function_name expectedT])
              (/scope.with_local [arg_name :input:])
              (/type.expecting :output:)
              (analyse archive body))
          
          {.#Named name unnamedT}
          (again unnamedT)

          {.#Apply argT funT}
          (case (type.applied (list argT) funT)
            {.#Some value}
            (again value)

            {.#None}
            (/.failure (exception.error ..cannot_analyse [expectedT function_name arg_name body])))

          (^template [<tag> <instancer>]
            [{<tag> _}
             (do !
               [[_ instanceT] (/type.check <instancer>)]
               (again (maybe.trusted (type.applied (list instanceT) expectedT))))])
          ([.#UnivQ check.existential]
           [.#ExQ check.var])
          
          {.#Var id}
          (do !
            [?expectedT' (/type.check (check.peek id))]
            (case ?expectedT'
              {.#Some expectedT'}
              (again expectedT')

              ... Inference
              _
              (do !
                [[@input :input:] (/type.check check.var)
                 [@output :output:] (/type.check check.var)
                 .let [:function: {.#Function :input: :output:}]
                 functionA (again :function:)
                 specialization (/type.check (check.try (check.identity (list @output) @input)))
                 :function: (case specialization
                              {try.#Success :input:'}
                              (in :function:)

                              {try.#Failure _}
                              (/type.check
                               (do [! check.monad]
                                 [? (check.linked? @input @output)]
                                 (# ! each
                                    (|>> {.#Function :input:} (/inference.quantified @input 1) {.#UnivQ (list)})
                                    (if ?
                                      (in :input:)
                                      (check.identity (list @input) @output))))))
                 _ (/type.check (check.check expectedT :function:))]
                (in functionA))))

          _
          (/.failure "")
          )))))

(def: .public (apply analyse argsC+ :function: functionA archive functionC)
  (-> Phase (List Code) Type Analysis Phase)
  (|> (/inference.general archive analyse :function: argsC+)
      (///#each (|>> product.right [functionA] /.reified))
      (/.with_exception ..cannot_apply [:function: functionC argsC+])))
