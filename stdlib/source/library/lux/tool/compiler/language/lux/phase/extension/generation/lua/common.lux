(.module:
  [library
   [lux "*"
    [abstract
     ["." monad {"+" [do]}]]
    [control
     ["." function]
     ["." try]
     ["<>" parser
      ["<s>" synthesis {"+" [Parser]}]]]
    [data
     ["." product]
     ["." text
      ["%" format {"+" [format]}]]
     [collection
      ["." dictionary]
      ["." list ("#\." functor mix)]]]
    [math
     [number
      ["f" frac]]]
    ["@" target
     ["_" lua {"+" [Expression Statement]}]]]]
  ["." //// "_"
   ["/" bundle]
   ["/#" // "_"
    ["." extension]
    [generation
     [extension {"+" [Nullary Unary Binary Trinary
                      nullary unary binary trinary]}]
     ["//" lua "_"
      ["#." runtime {"+" [Operation Phase Phase! Handler Bundle Generator]}]
      ["#." primitive]
      ["#." structure]
      ["#." reference]
      ["#." case]
      ["#." loop]
      ["#." function]]]
    [//
     ["." synthesis {"+" [%synthesis]}]
     ["." generation]
     [///
      ["#" phase ("#\." monad)]]]]])

(def: .public (custom [parser handler])
  (All (_ s)
    (-> [(Parser s)
         (-> Text (Generator s))]
        Handler))
  (function (_ extension_name phase archive input)
    (case (<s>.result parser input)
      (#try.Success input')
      (handler extension_name phase archive input')

      (#try.Failure error)
      (/////.except extension.invalid_syntax [extension_name %synthesis input]))))

(template: (!unary function)
  [(|>> list _.apply/* (|> (_.var function)))])

(def: .public (statement expression archive synthesis)
  Phase!
  (case synthesis
    ... TODO: Get rid of this ASAP
    (#synthesis.Extension "lux syntax char case!" parameters)
    (do /////.monad
      [body (expression archive synthesis)]
      (in (:as Statement body)))
    
    (^template [<tag>]
      [(^ (<tag> value))
       (/////\each _.return (expression archive synthesis))])
    ([synthesis.bit]
     [synthesis.i64]
     [synthesis.f64]
     [synthesis.text]
     [synthesis.variant]
     [synthesis.tuple]
     [#synthesis.Reference]
     [synthesis.branch/get]
     [synthesis.function/apply]
     [#synthesis.Extension])

    (^ (synthesis.branch/case case))
    (//case.case! statement expression archive case)

    (^ (synthesis.branch/let let))
    (//case.let! statement expression archive let)

    (^ (synthesis.branch/if if))
    (//case.if! statement expression archive if)

    (^ (synthesis.loop/scope scope))
    (do /////.monad
      [[inits scope!] (//loop.scope! statement expression archive false scope)]
      (in scope!))

    (^ (synthesis.loop/recur updates))
    (//loop.recur! statement expression archive updates)

    (^ (synthesis.function/abstraction abstraction))
    (/////\each _.return (//function.function statement expression archive abstraction))
    ))

... TODO: Get rid of this ASAP
(def: lux::syntax_char_case!
  (..custom [($_ <>.and
                 <s>.any
                 <s>.any
                 (<>.some (<s>.tuple ($_ <>.and
                                         (<s>.tuple (<>.many <s>.i64))
                                         <s>.any))))
             (function (_ extension_name phase archive [input else conditionals])
               (do {! /////.monad}
                 [inputG (phase archive input)
                  else! (..statement phase archive else)
                  @input (\ ! each _.var (generation.identifier "input"))
                  conditionals! (: (Operation (List [Expression Statement]))
                                   (monad.each ! (function (_ [chars branch])
                                                   (do !
                                                     [branch! (..statement phase archive branch)]
                                                     (in [(|> chars
                                                              (list\each (|>> .int _.int (_.= @input)))
                                                              (list\mix (function (_ clause total)
                                                                          (if (same? _.nil total)
                                                                            clause
                                                                            (_.or clause total)))
                                                                        _.nil))
                                                          branch!])))
                                               conditionals))
                  ... .let [closure (_.closure (list @input)
                  ...                          (list\mix (function (_ [test then] else)
                  ...                                      (_.if test (_.return then) else))
                  ...                                    (_.return elseG)
                  ...                                    conditionalsG))]
                  ]
                 ... (in (_.apply/1 closure inputG))
                 (in (<| (:as Expression)
                         (: Statement)
                         ($_ _.then
                             (_.set (list @input) inputG)
                             (list\mix (function (_ [test then!] else!)
                                         (_.if test then! else!))
                                       else!
                                       conditionals!))))))]))

(def: lux_procs
  Bundle
  (|> /.empty
      (/.install "syntax char case!" lux::syntax_char_case!)
      (/.install "is" (binary (product.uncurried _.=)))
      (/.install "try" (unary //runtime.lux//try))))

(def: i64_procs
  Bundle
  (<| (/.prefix "i64")
      (|> /.empty
          (/.install "and" (binary (product.uncurried _.bit_and)))
          (/.install "or" (binary (product.uncurried _.bit_or)))
          (/.install "xor" (binary (product.uncurried _.bit_xor)))
          (/.install "left-shift" (binary (product.uncurried //runtime.i64//left_shifted)))
          (/.install "right-shift" (binary (product.uncurried //runtime.i64//right_shifted)))
          (/.install "=" (binary (product.uncurried _.=)))
          (/.install "+" (binary (product.uncurried _.+)))
          (/.install "-" (binary (product.uncurried _.-)))
          (/.install "<" (binary (product.uncurried _.<)))
          (/.install "*" (binary (product.uncurried _.*)))
          (/.install "/" (binary (product.uncurried //runtime.i64//division)))
          (/.install "%" (binary (product.uncurried //runtime.i64//remainder)))
          (/.install "f64" (unary (_./ (_.float +1.0))))
          (/.install "char" (unary (_.apply/1 (_.var "utf8.char"))))
          )))

(def: f64//decode
  (Unary Expression)
  (|>> list _.apply/* (|> (_.var "tonumber")) _.return (_.closure (list)) //runtime.lux//try))

(def: f64_procs
  Bundle
  (<| (/.prefix "f64")
      (|> /.empty
          (/.install "+" (binary (product.uncurried _.+)))
          (/.install "-" (binary (product.uncurried _.-)))
          (/.install "*" (binary (product.uncurried _.*)))
          (/.install "/" (binary (product.uncurried _./)))
          (/.install "%" (binary (product.uncurried (function.flipped (_.apply/2 (_.var "math.fmod"))))))
          (/.install "=" (binary (product.uncurried _.=)))
          (/.install "<" (binary (product.uncurried _.<)))
          (/.install "i64" (unary (!unary "math.floor")))
          (/.install "encode" (unary (_.apply/2 (_.var "string.format") (_.string "%.17g"))))
          (/.install "decode" (unary ..f64//decode)))))

(def: (text//char [paramO subjectO])
  (Binary Expression)
  (//runtime.text//char (_.+ (_.int +1) paramO) subjectO))

(def: (text//clip [paramO extraO subjectO])
  (Trinary Expression)
  (//runtime.text//clip subjectO paramO extraO))

(def: (text//index [startO partO textO])
  (Trinary Expression)
  (//runtime.text//index textO partO startO))

(def: text_procs
  Bundle
  (<| (/.prefix "text")
      (|> /.empty
          (/.install "=" (binary (product.uncurried _.=)))
          (/.install "<" (binary (product.uncurried _.<)))
          (/.install "concat" (binary (product.uncurried (function.flipped _.concat))))
          (/.install "index" (trinary ..text//index))
          (/.install "size" (unary //runtime.text//size))
          ... TODO: Use version below once the Lua compiler becomes self-hosted.
          ... (/.install "size" (unary (for {@.lua (!unary "utf8.len")}
          ...                               (!unary "string.len"))))
          (/.install "char" (binary ..text//char))
          (/.install "clip" (trinary ..text//clip))
          )))

(def: (io//log! messageO)
  (Unary Expression)
  (|> (_.apply/* (list messageO) (_.var "print"))
      (_.or //runtime.unit)))

(def: io_procs
  Bundle
  (<| (/.prefix "io")
      (|> /.empty
          (/.install "log" (unary ..io//log!))
          (/.install "error" (unary (!unary "error"))))))

(def: .public bundle
  Bundle
  (<| (/.prefix "lux")
      (|> lux_procs
          (dictionary.merged i64_procs)
          (dictionary.merged f64_procs)
          (dictionary.merged text_procs)
          (dictionary.merged io_procs)
          )))
