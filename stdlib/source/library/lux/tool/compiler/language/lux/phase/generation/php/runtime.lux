(.module:
  [library
   [lux (#- Location)
    ["." meta]
    [abstract
     ["." monad (#+ do)]]
    [control
     ["." function]
     ["<>" parser
      ["<.>" code]]]
    [data
     ["." product]
     ["." text ("#\." hash)
      ["%" format (#+ format)]
      [encoding
       ["." utf8]]]
     [collection
      ["." list ("#\." functor)]
      ["." row]]]
    ["." macro
     [syntax (#+ syntax:)]
     ["." code]]
    [math
     [number (#+ hex)
      ["." i64]]]
    ["@" target
     ["_" php (#+ Expression Label Constant Var Computation Literal Statement)]]]]
  ["." /// #_
   ["#." reference]
   ["//#" /// #_
    ["#." synthesis (#+ Synthesis)]
    ["#." generation]
    ["//#" ///
     ["#." phase]
     [reference
      [variable (#+ Register)]]
     [meta
      [archive (#+ Output Archive)
       ["." artifact (#+ Registry)]]]]]])

(template [<name> <base>]
  [(type: .public <name>
     (<base> [Nat Label] Expression Statement))]

  [Operation /////generation.Operation]
  [Phase /////generation.Phase]
  [Handler /////generation.Handler]
  [Bundle /////generation.Bundle]
  )

(type: .public (Generator i)
  (-> Phase Archive i (Operation Expression)))

(type: .public Phase!
  (-> Phase Archive Synthesis (Operation Statement)))

(type: .public (Generator! i)
  (-> Phase! Phase Archive i (Operation Statement)))

(def: .public unit
  (_.string /////synthesis.unit))

(def: (flag value)
  (-> Bit Literal)
  (if value
    ..unit
    _.null))

(def: (feature name definition)
  (-> Constant (-> Constant Statement) Statement)
  (definition name))

(syntax: .public (with_vars [vars (<code>.tuple (<>.some <code>.local_identifier))
                             body <code>.any])
  (do {! meta.monad}
    [ids (monad.all ! (list.repeated (list.size vars) meta.seed))]
    (in (list (` (let [(~+ (|> vars
                               (list.zipped/2 ids)
                               (list\map (function (_ [id var])
                                           (list (code.local_identifier var)
                                                 (` (_.var (~ (code.text (format "v" (%.nat id)))))))))
                               list.together))]
                   (~ body)))))))

(def: module_id
  0)

(syntax: (runtime: [declaration (<>.or <code>.local_identifier
                                       (<code>.form (<>.and <code>.local_identifier
                                                            (<>.some <code>.local_identifier))))
                    code <code>.any])
  (do meta.monad
    [runtime_id meta.seed]
    (macro.with_identifiers [g!_]
      (let [runtime (code.local_identifier (///reference.artifact [..module_id runtime_id]))
            runtime_name (` (_.constant (~ (code.text (%.code runtime)))))]
        (case declaration
          (#.Left name)
          (macro.with_identifiers [g!_]
            (let [g!name (code.local_identifier name)]
              (in (list (` (def: .public (~ g!name)
                             Var
                             (~ runtime_name)))
                        
                        (` (def: (~ (code.local_identifier (format "@" name)))
                             Statement
                             (..feature (~ runtime_name)
                                        (function ((~ g!_) (~ g!name))
                                          (_.define (~ g!name) (~ code))))))))))
          
          (#.Right [name inputs])
          (macro.with_identifiers [g!_]
            (let [g!name (code.local_identifier name)
                  inputsC (list\map code.local_identifier inputs)
                  inputs_typesC (list\map (function.constant (` _.Expression))
                                          inputs)]
              (in (list (` (def: .public ((~ g!name) (~+ inputsC))
                             (-> (~+ inputs_typesC) Computation)
                             (_.apply/* (list (~+ inputsC)) (~ runtime_name))))
                        
                        (` (def: (~ (code.local_identifier (format "@" name)))
                             Statement
                             (..feature (~ runtime_name)
                                        (function ((~ g!_) (~ g!_))
                                          (..with_vars [(~+ inputsC)]
                                            (_.define_function (~ g!_)
                                                               (list (~+ (list\map (|>> (~) [false] (`)) inputsC)))
                                                               (~ code))))))))))))))))

(runtime: (io//log! message)
  ($_ _.then
      (_.echo message)
      (_.echo (_.string text.new_line))
      (_.return ..unit)))

(runtime: (io//throw! message)
  ($_ _.then
      (_.throw (_.new (_.constant "Exception") (list message)))
      (_.return ..unit)))

(def: runtime//io
  Statement
  ($_ _.then
      @io//log!
      @io//throw!
      ))

(def: .public tuple_size_field
  "_lux_size")

(def: tuple_size
  (_.item (_.string ..tuple_size_field)))

(def: jphp?
  (_.=== (_.string "5.6.99") (_.phpversion/0 [])))

(runtime: (array//length array)
  ... TODO: Get rid of this as soon as JPHP is no longer necessary.
  (_.if ..jphp?
    (_.return (..tuple_size array))
    (_.return (_.count/1 array))))

(runtime: (array//write idx value array)
  ($_ _.then
      (_.set! (_.item idx array) value)
      (_.return array)))

(def: runtime//array
  Statement
  ($_ _.then
      @array//length
      @array//write
      ))

(def: jphp_last_index
  (|>> ..tuple_size (_.- (_.int +1))))

(def: normal_last_index
  (|>> _.count/1 (_.- (_.int +1))))

(with_expansions [<recur> (as_is ($_ _.then
                                     (_.set! lefts (_.- last_index_right lefts))
                                     (_.set! tuple (_.item last_index_right tuple))))]
  (runtime: (tuple//make size values)
    (_.if ..jphp?
      ($_ _.then
          (_.set! (..tuple_size values) size)
          (_.return values))
      ... https://www.php.net/manual/en/language.operators.assignment.php
      ... https://www.php.net/manual/en/language.references.php
      ... https://www.php.net/manual/en/functions.arguments.php
      ... https://www.php.net/manual/en/language.oop5.references.php
      ... https://www.php.net/manual/en/class.arrayobject.php
      (_.return (_.new (_.constant "ArrayObject") (list values)))))

  (runtime: (tuple//left lefts tuple)
    (with_vars [last_index_right]
      (<| (_.while (_.bool true))
          ($_ _.then
              (_.if ..jphp?
                (_.set! last_index_right (..jphp_last_index tuple))
                (_.set! last_index_right (..normal_last_index tuple)))
              (_.if (_.> lefts last_index_right)
                ... No need for recursion
                (_.return (_.item lefts tuple))
                ... Needs recursion
                <recur>)))))

  ... TODO: Get rid of this as soon as JPHP is no longer necessary.
  (runtime: (tuple//slice offset input)
    (with_vars [size index output]
      ($_ _.then
          (_.set! size (..array//length input))
          (_.set! index (_.int +0))
          (_.set! output (_.array/* (list)))
          (<| (_.while (|> index (_.+ offset) (_.< size)))
              ($_ _.then
                  (_.set! (_.item index output) (_.item (_.+ offset index) input))
                  (_.set! index (_.+ (_.int +1) index))
                  ))
          (_.return (..tuple//make (_.- offset size) output))
          )))

  (runtime: (tuple//right lefts tuple)
    (with_vars [last_index_right right_index]
      (<| (_.while (_.bool true))
          ($_ _.then
              (_.if ..jphp?
                (_.set! last_index_right (..jphp_last_index tuple))
                (_.set! last_index_right (..normal_last_index tuple)))
              (_.set! right_index (_.+ (_.int +1) lefts))
              (_.cond (list [(_.=== last_index_right right_index)
                             (_.return (_.item right_index tuple))]
                            [(_.> last_index_right right_index)
                             ... Needs recursion.
                             <recur>])
                      (_.if ..jphp?
                        (_.return (..tuple//make (_.- right_index (..tuple_size tuple))
                                                 (..tuple//slice right_index tuple)))
                        (_.return (..tuple//make (_.- right_index (_.count/1 tuple))
                                                 (_.array_slice/2 [(_.do "getArrayCopy" (list) tuple) right_index])))))
              )))))

(def: .public variant_tag_field "_lux_tag")
(def: .public variant_flag_field "_lux_flag")
(def: .public variant_value_field "_lux_value")

(runtime: (sum//make tag last? value)
  (_.return (_.array/** (list [(_.string ..variant_tag_field) tag]
                              [(_.string ..variant_flag_field) last?]
                              [(_.string ..variant_value_field) value]))))

(def: .public (variant tag last? value)
  (-> Nat Bit Expression Computation)
  (sum//make (_.int (.int tag))
             (..flag last?)
             value))

(def: .public none
  Computation
  (..variant 0 #0 ..unit))

(def: .public some
  (-> Expression Computation)
  (..variant 1 #1))

(def: .public left
  (-> Expression Computation)
  (..variant 0 #0))

(def: .public right
  (-> Expression Computation)
  (..variant 1 #1))

(runtime: (sum//get sum wantsLast wantedTag)
  (let [no_match! (_.return _.null)
        sum_tag (_.item (_.string ..variant_tag_field) sum)
        ... sum_tag (_.item (_.int +0) sum)
        sum_flag (_.item (_.string ..variant_flag_field) sum)
        ... sum_flag (_.item (_.int +1) sum)
        sum_value (_.item (_.string ..variant_value_field) sum)
        ... sum_value (_.item (_.int +2) sum)
        is_last? (_.=== ..unit sum_flag)
        test_recursion! (_.if is_last?
                          ... Must recurse.
                          ($_ _.then
                              (_.set! wantedTag (_.- sum_tag wantedTag))
                              (_.set! sum sum_value))
                          no_match!)]
    (<| (_.while (_.bool true))
        (_.cond (list [(_.=== sum_tag wantedTag)
                       (_.if (_.=== wantsLast sum_flag)
                         (_.return sum_value)
                         test_recursion!)]

                      [(_.< wantedTag sum_tag)
                       test_recursion!]

                      [(_.=== ..unit wantsLast)
                       (_.return (sum//make (_.- wantedTag sum_tag) sum_flag sum_value))])
                no_match!))))

(def: runtime//adt
  Statement
  ($_ _.then
      @tuple//make
      @tuple//left
      @tuple//slice
      @tuple//right
      @sum//make
      @sum//get
      ))

(runtime: (lux//try op)
  (with_vars [value]
    (_.try ($_ _.then
               (_.set! value (_.apply/1 op [..unit]))
               (_.return (..right value)))
           (list (with_vars [error]
                   {#_.class (_.constant "Exception")
                    #_.exception error
                    #_.handler (_.return (..left (_.do "getMessage" (list) error)))})))))

(runtime: (lux//program_args inputs)
  (with_vars [head tail]
    ($_ _.then
        (_.set! tail ..none)
        (<| (_.for_each (_.array_reverse/1 inputs) head)
            (_.set! tail (..some (_.array/* (list head tail)))))
        (_.return tail))))

(def: runtime//lux
  Statement
  ($_ _.then
      @lux//try
      @lux//program_args
      ))

(def: .public high
  (-> (I64 Any) (I64 Any))
  (i64.right_shifted 32))

(def: .public low
  (-> (I64 Any) (I64 Any))
  (let [mask (-- (i64.left_shifted 32 1))]
    (|>> (i64.and mask))))

(runtime: (i64//right_shifted param subject)
  (let [... The mask has to be calculated this way instead of in a more straightforward way
        ... because in some languages, 1<<63 = max_negative_value
        ... and max_negative_value-1 = max_positive_value.
        ... And bitwise, max_positive_value works out to the mask that is desired when param = 0.
        ... However, in PHP, max_negative_value-1 underflows and gets cast into a float.
        ... And this messes up the computation.
        ... This slightly more convoluted calculation avoids that problem.
        mask (|> (_.int +1)
                 (_.bit_shl (_.- param (_.int +63)))
                 (_.- (_.int +1))
                 (_.bit_shl (_.int +1))
                 (_.+ (_.int +1)))]
    ($_ _.then
        (_.set! param (_.% (_.int +64) param))
        (_.if (_.=== (_.int +0) param)
          (_.return subject)
          (_.return (|> subject
                        (_.bit_shr param)
                        (_.bit_and mask)))))))

(runtime: (i64//char code)
  (_.if ..jphp?
    (_.return (_.chr/1 [code]))
    (_.return (|> code
                  [(_.string "V")]
                  _.pack/2
                  [(_.string "UTF-32LE") (_.string "UTF-8")]
                  _.iconv/3))))

(runtime: (i64//+ parameter subject)
  (let [high_16 (..i64//right_shifted (_.int +16))
        low_16 (_.bit_and (_.int (.int (hex "FFFF"))))

        cap_16 low_16
        hh (..i64//right_shifted (_.int +48))
        hl (|>> (..i64//right_shifted (_.int +32)) cap_16)
        lh (|>> (..i64//right_shifted (_.int +16)) cap_16)
        ll cap_16

        up_16 (_.bit_shl (_.int +16))]
    (with_vars [l48 l32 l16 l00
                r48 r32 r16 r00
                x48 x32 x16 x00]
      ($_ _.then
          (_.set! l48 (hh subject))
          (_.set! l32 (hl subject))
          (_.set! l16 (lh subject))
          (_.set! l00 (ll subject))

          (_.set! r48 (hh parameter))
          (_.set! r32 (hl parameter))
          (_.set! r16 (lh parameter))
          (_.set! r00 (ll parameter))

          (_.set! x00 (_.+ l00 r00))
          
          (_.set! x16 (|> (high_16 x00)
                          (_.+ l16)
                          (_.+ r16)))
          (_.set! x00 (low_16 x00))
          
          (_.set! x32 (|> (high_16 x16)
                          (_.+ l32)
                          (_.+ r32)))
          (_.set! x16 (low_16 x16))
          
          (_.set! x48 (|> (high_16 x32)
                          (_.+ l48)
                          (_.+ r48)
                          low_16))
          (_.set! x32 (low_16 x32))

          (let [high32 (_.bit_or (up_16 x48) x32)
                low32 (_.bit_or (up_16 x16) x00)]
            (_.return (|> high32
                          (_.bit_shl (_.int +32))
                          (_.bit_or low32))))
          ))))

(runtime: (i64//negate value)
  (let [i64//min (_.int (.int (hex "80,00,00,00,00,00,00,00")))]
    (_.if (_.=== i64//min value)
      (_.return i64//min)
      (_.return (..i64//+ (_.int +1) (_.bit_not value))))))

(runtime: (i64//- parameter subject)
  (_.return (..i64//+ (..i64//negate parameter) subject)))

(runtime: (i64//* parameter subject)
  (let [high_16 (..i64//right_shifted (_.int +16))
        low_16 (_.bit_and (_.int (.int (hex "FFFF"))))
        
        cap_16 low_16
        hh (..i64//right_shifted (_.int +48))
        hl (|>> (..i64//right_shifted (_.int +32)) cap_16)
        lh (|>> (..i64//right_shifted (_.int +16)) cap_16)
        ll cap_16

        up_16 (_.bit_shl (_.int +16))]
    (with_vars [l48 l32 l16 l00
                r48 r32 r16 r00
                x48 x32 x16 x00]
      ($_ _.then
          (_.set! l48 (hh subject))
          (_.set! l32 (hl subject))
          (_.set! l16 (lh subject))
          (_.set! l00 (ll subject))

          (_.set! r48 (hh parameter))
          (_.set! r32 (hl parameter))
          (_.set! r16 (lh parameter))
          (_.set! r00 (ll parameter))

          (_.set! x00 (_.* l00 r00))
          (_.set! x16 (high_16 x00))
          (_.set! x00 (low_16 x00))
          
          (_.set! x16 (|> x16 (_.+ (_.* l16 r00))))
          (_.set! x32 (high_16 x16)) (_.set! x16 (low_16 x16))
          (_.set! x16 (|> x16 (_.+ (_.* l00 r16))))
          (_.set! x32 (|> x32 (_.+ (high_16 x16)))) (_.set! x16 (low_16 x16))

          (_.set! x32 (|> x32 (_.+ (_.* l32 r00))))
          (_.set! x48 (high_16 x32)) (_.set! x32 (low_16 x32))
          (_.set! x32 (|> x32 (_.+ (_.* l16 r16))))
          (_.set! x48 (|> x48 (_.+ (high_16 x32)))) (_.set! x32 (low_16 x32))
          (_.set! x32 (|> x32 (_.+ (_.* l00 r32))))
          (_.set! x48 (|> x48 (_.+ (high_16 x32)))) (_.set! x32 (low_16 x32))
          
          (_.set! x48 (|> x48
                          (_.+ (_.* l48 r00))
                          (_.+ (_.* l32 r16))
                          (_.+ (_.* l16 r32))
                          (_.+ (_.* l00 r48))
                          low_16))

          (let [high32 (_.bit_or (up_16 x48) x32)
                low32 (_.bit_or (up_16 x16) x00)]
            (_.return (|> high32
                          (_.bit_shl (_.int +32))
                          (_.bit_or low32))))
          ))))

(def: runtime//i64
  Statement
  ($_ _.then
      @i64//right_shifted
      @i64//char
      @i64//+
      @i64//negate
      @i64//-
      @i64//*
      ))

(runtime: (text//size value)
  (_.if ..jphp?
    (_.return (_.strlen/1 [value]))
    (_.return (_.iconv_strlen/1 [value]))))

(runtime: (text//index subject param start)
  (_.if (_.=== (_.string "") param)
    (_.return (..some (_.int +0)))
    (with_vars [idx]
      (_.if ..jphp?
        ($_ _.then
            (_.set! idx (_.strpos/3 [subject param start]))
            (_.if (_.=== (_.bool false) idx)
              (_.return ..none)
              (_.return (..some idx))))
        ($_ _.then
            (_.set! idx (_.iconv_strpos/3 [subject param start]))
            (_.if (_.=== (_.bool false) idx)
              (_.return ..none)
              (_.return (..some idx))))))))

(def: (within? top value)
  (-> Expression Expression Computation)
  (_.and (|> value (_.>= (_.int +0)))
         (|> value (_.< top))))

(runtime: (text//clip offset length text)
  (_.if ..jphp?
    (_.return (_.substr/3 [text offset length]))
    (_.return (_.iconv_substr/3 [text offset length]))))

(runtime: (text//char idx text)
  (_.if (|> idx (within? (text//size text)))
    (_.if ..jphp?
      (_.return (_.ord/1 (_.substr/3 [text idx (_.int +1)])))
      (_.return (|> (_.iconv_substr/3 [text idx (_.int +1)])
                    [(_.string "UTF-8") (_.string "UTF-32LE")]
                    _.iconv/3
                    [(_.string "V")]
                    _.unpack/2
                    (_.item (_.int +1)))))
    (_.throw (_.new (_.constant "Exception") (list (_.string "[Lux Error] Cannot get char from text."))))))

(def: runtime//text
  Statement
  ($_ _.then
      @text//size
      @text//index
      @text//clip
      @text//char
      ))

(runtime: (f64//decode value)
  (with_vars [output]
    ($_ _.then
        (_.set! output (_.floatval/1 value))
        (_.if (_.=== (_.float +0.0) output)
          (_.if ($_ _.or
                    (_.=== (_.string "0.0") output)
                    (_.=== (_.string "+0.0") output)
                    (_.=== (_.string "-0.0") output)
                    (_.=== (_.string "0") output)
                    (_.=== (_.string "+0") output)
                    (_.=== (_.string "-0") output))
            (_.return (..some output))
            (_.return ..none))
          (_.return (..some output)))
        )))

(def: runtime//f64
  Statement
  ($_ _.then
      @f64//decode
      ))

(def: check_necessary_conditions!
  Statement
  (let [i64_support? (_.=== (_.int +8) (_.constant "PHP_INT_SIZE"))
        i64_error (_.string (format "Cannot run program!" text.new_line
                                    "Lux/PHP programs require 64-bit PHP builds!"))]
    (_.when (_.not i64_support?)
            (_.throw (_.new (_.constant "Exception") (list i64_error))))))

(def: runtime
  Statement
  ($_ _.then
      check_necessary_conditions!
      runtime//array
      runtime//adt
      runtime//lux
      runtime//i64
      runtime//f64
      runtime//text
      runtime//io
      ))

(def: .public generate
  (Operation [Registry Output])
  (do ///////phase.monad
    [_ (/////generation.execute! ..runtime)
     _ (/////generation.save! ..module_id ..runtime)]
    (in [(|> artifact.empty
             artifact.resource
             product.right)
         (row.row [..module_id
                   (|> ..runtime
                       _.code
                       (\ utf8.codec encode))])])))
