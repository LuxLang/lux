(.using
 [library
  [lux "*"
   ["[0]" meta]
   [abstract
    [monad {"+" do}]]
   [control
    ["[0]" function]
    ["[0]" try]]
   [type
    ["[0]" check {"+" Check}]]]]
 ["/" // {"+" Operation}
  [//
   [phase
    ["[0]" extension]]
   [///
    ["[0]" phase]]]])

(def: .public (expecting expected)
  (All (_ a) (-> Type (Operation a) (Operation a)))
  (extension.localized (value@ .#expected) (with@ .#expected)
                       (function.constant {.#Some expected})))

(def: .public (check action)
  (All (_ a) (-> (Check a) (Operation a)))
  (function (_ (^@ stateE [bundle state]))
    (case (action (value@ .#type_context state))
      {try.#Success [context' output]}
      {try.#Success [[bundle (with@ .#type_context context' state)]
                     output]}

      {try.#Failure error}
      ((/.failure error) stateE))))

(def: .public fresh
  (All (_ a) (-> (Operation a) (Operation a)))
  (extension.localized (value@ .#type_context) (with@ .#type_context)
                       (function.constant check.fresh_context)))

(def: .public (inference actualT)
  (-> Type (Operation Any))
  (do phase.monad
    [expectedT (extension.lifted meta.expected_type)]
    (..check (check.check expectedT actualT))))

(def: .public (with_var it)
  (All (_ a) (-> (-> [check.Var Type] (Operation a))
                 (Operation a)))
  (do phase.monad
    [var (..check check.var)
     .let [[@it :it:] var]
     it (it var)
     _ (..check (check.forget! @it))]
    (in it)))

(def: .public (inferring action)
  (All (_ a) (-> (Operation a) (Operation [Type a])))
  (do phase.monad
    [[@it :it:] (..check check.var)
     it (..expecting :it: action)
     :it: (..check (check.clean :it:))]
    (in [:it: it])))
