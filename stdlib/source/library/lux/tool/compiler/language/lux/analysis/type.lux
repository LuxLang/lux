(.using
 [library
  [lux "*"
   ["[0]" meta]
   [abstract
    [monad {"+" do}]]
   [control
    ["[0]" function]
    ["[0]" try]]
   [type
    ["[0]" check {"+" Check}]]]]
 ["/" // {"+" Operation}
  [//
   [phase
    ["[0]" extension]]
   [///
    ["[0]" phase]]]])

(def: .public (expecting expected)
  (All (_ a) (-> Type (Operation a) (Operation a)))
  (extension.localized (value@ .#expected) (with@ .#expected)
                       (function.constant {.#Some expected})))

(def: .public (check action)
  (All (_ a) (-> (Check a) (Operation a)))
  (function (_ (^@ stateE [bundle state]))
    (case (action (value@ .#type_context state))
      {try.#Success [context' output]}
      {try.#Success [[bundle (with@ .#type_context context' state)]
                     output]}

      {try.#Failure error}
      ((/.failure error) stateE))))

(def: .public fresh
  (All (_ a) (-> (Operation a) (Operation a)))
  (extension.localized (value@ .#type_context) (with@ .#type_context)
                       (function.constant check.fresh_context)))

(def: .public (inference actualT)
  (-> Type (Operation Any))
  (do phase.monad
    [expectedT (extension.lifted meta.expected_type)]
    (..check (check.check expectedT actualT))))

(def: .public (inferring action)
  (All (_ a) (-> (Operation a) (Operation [Type a])))
  (do phase.monad
    [[_ varT] (..check check.var)
     output (..expecting varT action)
     knownT (..check (check.clean varT))]
    (in [knownT output])))
