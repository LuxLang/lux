(.module:
  [library
   [lux #*
    ["." debug]
    [abstract
     [monad (#+ Monad do)]]
    [control
     ["." state]
     ["." try (#+ Try) ("#\." functor)]
     ["ex" exception (#+ Exception exception:)]
     ["." io]
     [parser
      ["<.>" code]]]
    [data
     ["." product]
     ["." text
      ["%" format (#+ format)]]]
    [time
     ["." instant]
     ["." duration]]
    [macro
     [syntax (#+ syntax:)]]]]
  [//
   [meta
    [archive (#+ Archive)]]])

(type: .public (Operation s o)
  (state.+State Try s o))

(def: .public monad
  (All [s] (Monad (Operation s)))
  (state.with try.monad))

(type: .public (Phase s i o)
  (-> Archive i (Operation s o)))

(type: .public Wrapper
  (All [s i o] (-> (Phase s i o) Any)))

(def: .public (result' state operation)
  (All [s o]
    (-> s (Operation s o) (Try [s o])))
  (operation state))

(def: .public (result state operation)
  (All [s o]
    (-> s (Operation s o) (Try o)))
  (|> state
      operation
      (\ try.monad each product.right)))

(def: .public get_state
  (All [s o]
    (Operation s s))
  (function (_ state)
    (#try.Success [state state])))

(def: .public (set_state state)
  (All [s o]
    (-> s (Operation s Any)))
  (function (_ _)
    (#try.Success [state []])))

(def: .public (sub [get set] operation)
  (All [s s' o]
    (-> [(-> s s') (-> s' s s)]
        (Operation s' o)
        (Operation s o)))
  (function (_ state)
    (do try.monad
      [[state' output] (operation (get state))]
      (in [(set state' state) output]))))

(def: .public failure
  (-> Text Operation)
  (|>> #try.Failure (state.lifted try.monad)))

(def: .public (except exception parameters)
  (All [e] (-> (Exception e) e Operation))
  (..failure (ex.error exception parameters)))

(def: .public (lifted error)
  (All [s a] (-> (Try a) (Operation s a)))
  (function (_ state)
    (try\each (|>> [state]) error)))

(syntax: .public (assertion [exception <code>.any
                             message <code>.any
                             test <code>.any])
  (in (list (` (if (~ test)
                 (\ ..monad (~' in) [])
                 (..except (~ exception) (~ message)))))))

(def: .public identity
  (All [s a] (Phase s a a))
  (function (_ archive input state)
    (#try.Success [state input])))

(def: .public (composite pre post)
  (All [s0 s1 i t o]
    (-> (Phase s0 i t)
        (Phase s1 t o)
        (Phase [s0 s1] i o)))
  (function (_ archive input [pre/state post/state])
    (do try.monad
      [[pre/state' temp] (pre archive input pre/state)
       [post/state' output] (post archive temp post/state)]
      (in [[pre/state' post/state'] output]))))

(def: .public (timed definition description operation)
  (All [s a]
    (-> Name Text (Operation s a) (Operation s a)))
  (do ..monad
    [_ (in [])
     .let [pre (io.run! instant.now)]
     output operation
     .let [_ (|> instant.now
                 io.run!
                 instant.relative
                 (duration.difference (instant.relative pre))
                 %.duration
                 (format (%.name definition) " [" description "]: ")
                 debug.log!)]]
    (in output)))
