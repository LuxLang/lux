(.module:
  [library
   [lux {"-" Module}
    [type {"+" :sharing}]
    [abstract
     ["[0]" monad {"+" do}]]
    [control
     ["[0]" try {"+" Try}]]
    [data
     [binary {"+" Binary}]
     ["[0]" product]
     ["[0]" text
      ["%" format {"+" format}]
      ["[0]" encoding]]
     [collection
      ["[0]" row]
      ["[0]" list ("[1]#[0]" functor mix)]
      ["[0]" dictionary {"+" Dictionary}]
      ["[0]" set]]
     [format
      ["[0]" tar]
      ["[0]" binary]]]
    [target
     ["_" scheme]]
    [time
     ["[0]" instant {"+" Instant}]]
    [world
     ["[0]" file]]]]
  [program
   [compositor
    ["[0]" static {"+" Static}]]]
  ["[0]" // {"+" Packager}
   [//
    ["[0]" archive {"+" Output}
     ["[0]" descriptor {"+" Module Descriptor}]
     ["[0]" artifact]
     ["[0]" document {"+" Document}]]
    [cache
     ["[0]" dependency]]
    ["[0]" io "_"
     ["[1]" archive]]
    [//
     [language
      ["$" lux
       [generation {"+" Context}]]]]]])

... TODO: Delete ASAP
(type: (Action ! a)
  (! (Try a)))

(def: (then pre post)
  (-> _.Expression _.Expression _.Expression)
  (_.manual (format (_.code pre)
                    text.new_line
                    (_.code post))))

(def: bundle_module
  (-> Output (Try _.Expression))
  (|>> row.list
       (list#each product.right)
       (monad.mix try.monad
                  (function (_ content so_far)
                    (|> content
                        (# encoding.utf8 decoded)
                        (# try.monad each
                           (|>> :expected
                                (:sharing [directive]
                                          directive
                                          so_far
                                          
                                          directive)
                                (..then so_far)))))
                  (: _.Expression (_.manual "")))))

(def: module_file
  (-> archive.ID file.Path)
  (|>> %.nat (text.suffix ".scm")))

(def: mode
  tar.Mode
  ($_ tar.and
      tar.read_by_group
      tar.read_by_owner
      
      tar.write_by_other
      tar.write_by_group
      tar.write_by_owner))

(def: owner
  tar.Owner
  [tar.#name tar.anonymous
   tar.#id tar.no_id])

(def: ownership
  [tar.#user ..owner
   tar.#group ..owner])

(def: (write_module now mapping [module [module_id [descriptor document output]]])
  (-> Instant (Dictionary Module archive.ID)
      [Module [archive.ID [Descriptor (Document .Module) Output]]]
      (Try tar.Entry))
  (do [! try.monad]
    [bundle (: (Try _.Expression)
               (..bundle_module output))
     entry_content (: (Try tar.Content)
                      (|> descriptor
                          (value@ descriptor.#references)
                          set.list
                          (list.all (function (_ module) (dictionary.value module mapping)))
                          (list#each (|>> ..module_file _.string _.load_relative/1))
                          (list#mix ..then bundle)
                          (: _.Expression)
                          _.code
                          (# encoding.utf8 encoded)
                          tar.content))
     module_file (tar.path (..module_file module_id))]
    (in {tar.#Normal [module_file now ..mode ..ownership entry_content]})))

(def: .public (package now)
  (-> Instant Packager)
  (function (package host_dependencies archive program)
    (do [! try.monad]
      [order (dependency.load_order $.key archive)
       .let [mapping (|> order
                         (list#each (function (_ [module [module_id [descriptor document output]]])
                                      [module module_id]))
                         (dictionary.of_list text.hash)
                         (: (Dictionary Module archive.ID)))]
       entries (monad.each ! (..write_module now mapping) order)]
      (in (|> entries
              row.of_list
              (binary.result tar.writer))))))
