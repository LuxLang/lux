(.module:
  [library
   [lux {"-" [Module]}
    [type {"+" [:sharing]}]
    [abstract
     ["." monad {"+" [do]}]]
    [control
     ["." try {"+" [Try]}]]
    [data
     [binary {"+" [Binary]}]
     ["." product]
     ["." text
      ["%" format {"+" [format]}]
      ["." encoding]]
     [collection
      ["." row]
      ["." list ("#\." functor mix)]
      ["." dictionary {"+" [Dictionary]}]
      ["." set]]
     [format
      ["." tar]
      ["." binary]]]
    [target
     ["_" scheme]]
    [time
     ["." instant {"+" [Instant]}]]
    [world
     ["." file]]]]
  [program
   [compositor
    ["." static {"+" [Static]}]]]
  ["." // {"+" [Packager]}
   [//
    ["." archive {"+" [Output]}
     ["." descriptor {"+" [Module Descriptor]}]
     ["." artifact]
     ["." document {"+" [Document]}]]
    [cache
     ["." dependency]]
    ["." io "_"
     ["#" archive]]
    [//
     [language
      ["$" lux
       [generation {"+" [Context]}]]]]]])

... TODO: Delete ASAP
(type: (Action ! a)
  (! (Try a)))

(def: (then pre post)
  (-> _.Expression _.Expression _.Expression)
  (_.manual (format (_.code pre)
                    text.new_line
                    (_.code post))))

(def: bundle_module
  (-> Output (Try _.Expression))
  (|>> row.list
       (list\each product.right)
       (monad.mix try.monad
                  (function (_ content so_far)
                    (|> content
                        (\ encoding.utf8 decoded)
                        (\ try.monad each
                           (|>> :expected
                                (:sharing [directive]
                                          directive
                                          so_far
                                          
                                          directive)
                                (..then so_far)))))
                  (: _.Expression (_.manual "")))))

(def: module_file
  (-> archive.ID file.Path)
  (|>> %.nat (text.suffix ".scm")))

(def: mode
  tar.Mode
  ($_ tar.and
      tar.read_by_group
      tar.read_by_owner
      
      tar.write_by_other
      tar.write_by_group
      tar.write_by_owner))

(def: owner
  tar.Owner
  [#tar.name tar.anonymous
   #tar.id tar.no_id])

(def: ownership
  [#tar.user ..owner
   #tar.group ..owner])

(def: (write_module now mapping [module [module_id [descriptor document output]]])
  (-> Instant (Dictionary Module archive.ID)
      [Module [archive.ID [Descriptor (Document .Module) Output]]]
      (Try tar.Entry))
  (do {! try.monad}
    [bundle (: (Try _.Expression)
               (..bundle_module output))
     entry_content (: (Try tar.Content)
                      (|> descriptor
                          (value@ #descriptor.references)
                          set.list
                          (list.all (function (_ module) (dictionary.value module mapping)))
                          (list\each (|>> ..module_file _.string _.load_relative/1))
                          (list\mix ..then bundle)
                          (: _.Expression)
                          _.code
                          (\ encoding.utf8 encoded)
                          tar.content))
     module_file (tar.path (..module_file module_id))]
    (in (#tar.Normal [module_file now ..mode ..ownership entry_content]))))

(def: .public (package now)
  (-> Instant Packager)
  (function (package host_dependencies archive program)
    (do {! try.monad}
      [order (dependency.load_order $.key archive)
       .let [mapping (|> order
                         (list\each (function (_ [module [module_id [descriptor document output]]])
                                      [module module_id]))
                         (dictionary.of_list text.hash)
                         (: (Dictionary Module archive.ID)))]
       entries (monad.each ! (..write_module now mapping) order)]
      (in (|> entries
              row.of_list
              (binary.result tar.writer))))))
