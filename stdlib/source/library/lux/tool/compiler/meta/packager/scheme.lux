(.using
 [library
  [lux (.except Module)
   [type (.only sharing)]
   [abstract
    ["[0]" monad (.only do)]]
   [control
    ["[0]" try (.only Try)]]
   [data
    [binary (.only Binary)]
    ["[0]" product]
    ["[0]" text
     ["%" format (.only format)]
     ["[0]" encoding]]
    [collection
     ["[0]" sequence]
     ["[0]" list ("[1]#[0]" functor mix)]
     ["[0]" dictionary (.only Dictionary)]
     ["[0]" set]]
    [format
     ["[0]" tar]
     ["[0]" binary]]]
   [target
    ["_" scheme]]
   [time
    ["[0]" instant (.only Instant)]]
   [world
    ["[0]" file]]]]
 [program
  [compositor
   ["[0]" static (.only Static)]]]
 ["[0]" // (.only Packager)
  [//
   ["[0]" archive (.only Output)
    ["[0]" descriptor (.only Module Descriptor)]
    ["[0]" artifact]
    ["[0]" document (.only Document)]]
   [cache
    ["[0]" dependency]]
   ["[0]" io "_"
    ["[1]" archive]]
   [//
    [language
     ["$" lux
      [generation (.only Context)]]]]]])

... TODO: Delete ASAP
(type: (Action ! a)
  (! (Try a)))

(def: (then pre post)
  (-> _.Expression _.Expression _.Expression)
  (_.manual (format (_.code pre)
                    text.new_line
                    (_.code post))))

(def: bundle_module
  (-> Output (Try _.Expression))
  (|>> sequence.list
       (list#each product.right)
       (monad.mix try.monad
                  (function (_ content so_far)
                    (|> content
                        (# encoding.utf8 decoded)
                        (# try.monad each
                           (|>> as_expected
                                (sharing [directive]
                                         directive
                                         so_far
                                         
                                         directive)
                                (..then so_far)))))
                  (is _.Expression (_.manual "")))))

(def: module_file
  (-> archive.ID file.Path)
  (|>> %.nat (text.suffix ".scm")))

(def: mode
  tar.Mode
  (all tar.and
       tar.read_by_group
       tar.read_by_owner
       
       tar.write_by_other
       tar.write_by_group
       tar.write_by_owner))

(def: owner
  tar.Owner
  [tar.#name tar.anonymous
   tar.#id tar.no_id])

(def: ownership
  [tar.#user ..owner
   tar.#group ..owner])

(def: (write_module now mapping [module [module_id [descriptor document output]]])
  (-> Instant (Dictionary Module archive.ID)
      [Module [archive.ID [Descriptor (Document .Module) Output]]]
      (Try tar.Entry))
  (do [! try.monad]
    [bundle (is (Try _.Expression)
                (..bundle_module output))
     entry_content (is (Try tar.Content)
                       (|> descriptor
                           (the descriptor.#references)
                           set.list
                           (list.all (function (_ module) (dictionary.value module mapping)))
                           (list#each (|>> ..module_file _.string _.load_relative/1))
                           (list#mix ..then bundle)
                           (is _.Expression)
                           _.code
                           (# encoding.utf8 encoded)
                           tar.content))
     module_file (tar.path (..module_file module_id))]
    (in {tar.#Normal [module_file now ..mode ..ownership entry_content]})))

(def: .public (package now)
  (-> Instant Packager)
  (function (package host_dependencies archive program)
    (do [! try.monad]
      [order (dependency.load_order $.key archive)
       .let [mapping (|> order
                         (list#each (function (_ [module [module_id [descriptor document output]]])
                                      [module module_id]))
                         (dictionary.of_list text.hash)
                         (is (Dictionary Module archive.ID)))]
       entries (monad.each ! (..write_module now mapping) order)]
      (in (|> entries
              sequence.of_list
              (binary.result tar.writer))))))
