(.using
 [library
  [lux "*"
   [abstract
    [monad {"+" do}]]
   [control
    ["[0]" pipe]
    ["[0]" maybe ("[1]#[0]" functor)]
    ["[0]" exception {"+" exception:}]
    ["<>" parser
     ["<[0]>" binary {"+" Parser}]]]
   [data
    ["[0]" product]
    ["[0]" text
     ["%" format {"+" format}]]
    [collection
     [set {"+" Set}]
     ["[0]" list]
     ["[0]" sequence {"+" Sequence} ("[1]#[0]" functor mix)]
     ["[0]" dictionary {"+" Dictionary}]]
    [format
     ["[0]" binary {"+" Writer}]]]
   [macro
    ["^" pattern]]
   [type
    [abstract {"-" pattern}]]]]
 ["[0]" // "_"
  ["[0]" unit]
  ["[1]" artifact {"+" Artifact ID}
   ["[2][0]" category {"+" Category}]]])

(abstract: .public Registry
  (Record
   [#artifacts (Sequence [Artifact (Set unit.ID)])
    #resolver (Dictionary Text [ID (Maybe //category.Definition)])])

  (def: .public empty
    Registry
    (abstraction [#artifacts sequence.empty
                  #resolver (dictionary.empty text.hash)]))

  (def: .public artifacts
    (-> Registry (Sequence [Artifact (Set unit.ID)]))
    (|>> representation (the #artifacts)))

  (def: next
    (-> Registry ID)
    (|>> ..artifacts sequence.size))

  (def: .public (resource mandatory? dependencies registry)
    (-> Bit (Set unit.ID) Registry [ID Registry])
    (let [id (..next registry)]
      [id
       (|> registry
           representation
           (revised #artifacts (sequence.suffix [[//.#id id
                                                  //.#category {//category.#Anonymous}
                                                  //.#mandatory? mandatory?]
                                                 dependencies]))
           abstraction)]))

  (template [<tag> <create> <fetch> <type> <name> <+resolver>]
    [(def: .public (<create> it mandatory? dependencies registry)
       (-> <type> Bit (Set unit.ID) Registry [ID Registry])
       (let [id (..next registry)]
         [id
          (|> registry
              representation
              (revised #artifacts (sequence.suffix [[//.#id id
                                                     //.#category {<tag> it}
                                                     //.#mandatory? mandatory?]
                                                    dependencies]))
              (revised #resolver (dictionary.has (<name> it) [id (is (Maybe //category.Definition) <+resolver>)]))
              abstraction)]))

     (def: .public (<fetch> registry)
       (-> Registry (List <type>))
       (|> registry
           representation
           (the #artifacts)
           sequence.list
           (list.all (|>> product.left
                          (the //.#category)
                          (pipe.case
                            {<tag> it} {.#Some it}
                            _ {.#None})))))]

    [//category.#Definition definition definitions //category.Definition
     product.left {.#Some it}]
    [//category.#Analyser analyser analysers Text |> {.#None}]
    [//category.#Synthesizer synthesizer synthesizers Text |> {.#None}]
    [//category.#Generator generator generators Text |> {.#None}]
    [//category.#Directive directive directives Text |> {.#None}]
    [//category.#Custom custom customs Text |> {.#None}]
    )

  (def: .public (find_definition name registry)
    (-> Text Registry (Maybe [ID (Maybe //category.Definition)]))
    (|> (representation registry)
        (the #resolver)
        (dictionary.value name)))

  (def: .public (id name registry)
    (-> Text Registry (Maybe ID))
    (maybe#each product.left (find_definition name registry)))

  (def: .public writer
    (Writer Registry)
    (let [definition (is (Writer //category.Definition)
                         ($_ binary.and
                             binary.text
                             (binary.maybe
                              ($_ binary.and
                                  binary.nat
                                  binary.nat
                                  binary.nat
                                  ))
                             ))
          category (is (Writer Category)
                       (function (_ value)
                         (case value
                           (^.template [<nat> <tag> <writer>]
                             [{<tag> value}
                              ((binary.and binary.nat <writer>) [<nat> value])])
                           ([0 //category.#Anonymous binary.any]
                            [1 //category.#Definition definition]
                            [2 //category.#Analyser binary.text]
                            [3 //category.#Synthesizer binary.text]
                            [4 //category.#Generator binary.text] 
                            [5 //category.#Directive binary.text]
                            [6 //category.#Custom binary.text]))))
          mandatory? binary.bit
          dependency (is (Writer unit.ID)
                         (binary.and binary.nat binary.nat))
          dependencies (is (Writer (Set unit.ID))
                           (binary.set dependency))
          artifacts (is (Writer (Sequence [Category Bit (Set unit.ID)]))
                        (binary.sequence_64 ($_ binary.and category mandatory? dependencies)))]
      (|>> representation
           (the #artifacts)
           (sequence#each (function (_ [it dependencies])
                            [(the //.#category it)
                             (the //.#mandatory? it)
                             dependencies]))
           artifacts)))

  (exception: .public (invalid_category [tag Nat])
    (exception.report
     "Tag" (%.nat tag)))

  (def: .public parser
    (Parser Registry)
    (let [definition (is (Parser //category.Definition)
                         ($_ <>.and
                             <binary>.text
                             (<binary>.maybe
                              ($_ <>.and
                                  <binary>.nat
                                  <binary>.nat
                                  <binary>.nat
                                  ))
                             ))
          category (is (Parser Category)
                       (do [! <>.monad]
                         [tag <binary>.nat]
                         (case tag
                           (^.template [<nat> <tag> <parser>]
                             [<nat>
                              (# ! each (|>> {<tag>}) <parser>)])
                           ([0 //category.#Anonymous <binary>.any]
                            [1 //category.#Definition definition]
                            [2 //category.#Analyser <binary>.text]
                            [3 //category.#Synthesizer <binary>.text]
                            [4 //category.#Generator <binary>.text]
                            [5 //category.#Directive <binary>.text]
                            [6 //category.#Custom <binary>.text])
                           
                           _ (<>.failure (exception.error ..invalid_category [tag])))))
          mandatory? <binary>.bit
          dependency (is (Parser unit.ID)
                         (<>.and <binary>.nat <binary>.nat))
          dependencies (is (Parser (Set unit.ID))
                           (<binary>.set unit.hash dependency))]
      (|> (<binary>.sequence_64 ($_ <>.and category mandatory? dependencies))
          (# <>.monad each (sequence#mix (function (_ [category mandatory? dependencies] registry)
                                           (product.right
                                            (case category
                                              {//category.#Anonymous}
                                              (..resource mandatory? dependencies registry)

                                              (^.template [<tag> <create>]
                                                [{<tag> name}
                                                 (<create> name mandatory? dependencies registry)])
                                              ([//category.#Definition ..definition]
                                               [//category.#Analyser ..analyser]
                                               [//category.#Synthesizer ..synthesizer]
                                               [//category.#Generator ..generator]
                                               [//category.#Directive ..directive]
                                               [//category.#Custom ..custom])
                                              )))
                                         ..empty)))))
  )
