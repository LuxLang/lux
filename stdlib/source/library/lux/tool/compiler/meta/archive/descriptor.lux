(.using
 [library
  [lux {"-" Module}
   [abstract
    [equivalence {"+" Equivalence}]]
   [control
    ["<>" parser
     ["<[0]>" binary {"+" Parser}]]]
   [data
    ["[0]" product]
    ["[0]" text]
    [collection
     ["[0]" set {"+" Set}]]
    ["[0]" format "_"
     ["[1]" binary {"+" Writer}]]]
   [math
    [number
     ["[0]" nat]]]
   [world
    [file {"+" Path}]]]])

(type: .public Module
  Text)

(type: .public Descriptor
  (Record
   [#name Module
    #file Path
    #hash Nat
    #state Module_State
    #references (Set Module)]))

(implementation: module_state_equivalence
  (Equivalence Module_State)
  
  (def: (= left right)
    (case [left right]
      (^template [<tag>]
        [[{<tag>} {<tag>}]
         true])
      ([.#Active]
       [.#Compiled]
       [.#Cached])

      _
      false)))

(def: .public equivalence
  (Equivalence Descriptor)
  ($_ product.equivalence
      text.equivalence
      text.equivalence
      nat.equivalence
      ..module_state_equivalence
      set.equivalence
      ))

(def: .public writer
  (Writer Descriptor)
  ($_ format.and
      format.text
      format.text
      format.nat
      format.any
      (format.set format.text)
      ))

(def: .public parser
  (Parser Descriptor)
  ($_ <>.and
      <binary>.text
      <binary>.text
      <binary>.nat
      (# <>.monad in {.#Cached})
      (<binary>.set text.hash <binary>.text)
      ))
