(.using
 [library
  [lux "*"
   [abstract
    [equivalence {"+" Equivalence}]]
   [data
    ["[0]" product]
    ["[0]" bit]
    ["[0]" text ("[1]#[0]" equivalence)]
    [collection
     ["[0]" set {"+" Set}]]]
   [math
    [number
     ["[0]" nat]]]]])

(type: .public ID
  Nat)

(type: .public Category
  (Variant
   {#Anonymous}
   {#Definition Text}
   {#Analyser Text}
   {#Synthesizer Text}
   {#Generator Text}
   {#Directive Text}
   {#Custom Text}))

(implementation: category_equivalence
  (Equivalence Category)
  
  (def: (= left right)
    (case [left right]
      [{#Anonymous} {#Anonymous}]
      true
      
      (^template [<tag>]
        [[{<tag> left} {<tag> right}]
         (text#= left right)])
      ([#Definition]
       [#Analyser]
       [#Synthesizer]
       [#Generator]
       [#Directive]
       [#Custom])

      _
      false)))

(type: .public Dependency
  [Nat ID])

(def: .public dependency_hash
  (product.hash nat.hash nat.hash))

(def: .public no_dependencies
  (Set Dependency)
  (set.empty dependency_hash))

(type: .public Artifact
  (Record
   [#id ID
    #category Category
    #mandatory? Bit
    #dependencies (Set Dependency)]))

(def: .public equivalence
  (Equivalence Artifact)
  ($_ product.equivalence
      nat.equivalence
      ..category_equivalence
      bit.equivalence
      set.equivalence
      ))
