(.using
 [library
  [lux "*"
   [abstract
    [monad {"+" do}]]
   [control
    [pipe {"+" case>}]
    ["[0]" exception {"+" exception:}]
    ["<>" parser
     ["<[0]>" binary {"+" Parser}]]]
   [data
    ["[0]" product]
    ["[0]" text
     ["%" format {"+" format}]]
    [collection
     ["[0]" list]
     ["[0]" sequence {"+" Sequence} ("[1]#[0]" functor mix)]
     ["[0]" dictionary {"+" Dictionary}]
     ["[0]" set {"+" Set}]]
    [format
     ["[0]" binary {"+" Writer}]]]
   [math
    [number
     ["[0]" nat]]]
   [type
    abstract]]])

(type: .public ID
  Nat)

(type: .public Category
  (Variant
   {#Anonymous}
   {#Definition Text}
   {#Analyser Text}
   {#Synthesizer Text}
   {#Generator Text}
   {#Directive Text}
   {#Custom Text}))

(type: .public Dependency
  [Nat ID])

(def: dependency_hash
  (product.hash nat.hash nat.hash))

(def: .public no_dependencies
  (Set Dependency)
  (set.empty dependency_hash))

(type: .public Artifact
  (Record
   [#id ID
    #category Category
    #mandatory? Bit
    #dependencies (Set Dependency)]))

(abstract: .public Registry
  (Record
   [#artifacts (Sequence Artifact)
    #resolver (Dictionary Text ID)])

  (def: .public empty
    Registry
    (:abstraction [#artifacts sequence.empty
                   #resolver (dictionary.empty text.hash)]))

  (def: .public artifacts
    (-> Registry (Sequence Artifact))
    (|>> :representation (value@ #artifacts)))

  (def: next
    (-> Registry ID)
    (|>> ..artifacts sequence.size))

  (def: .public (resource mandatory? dependencies registry)
    (-> Bit (Set Dependency) Registry [ID Registry])
    (let [id (..next registry)]
      [id
       (|> registry
           :representation
           (revised@ #artifacts (sequence.suffix [#id id
                                                  #category {#Anonymous}
                                                  #mandatory? mandatory?
                                                  #dependencies dependencies]))
           :abstraction)]))

  (template [<tag> <create> <fetch>]
    [(def: .public (<create> name mandatory? dependencies registry)
       (-> Text Bit (Set Dependency) Registry [ID Registry])
       (let [id (..next registry)]
         [id
          (|> registry
              :representation
              (revised@ #artifacts (sequence.suffix [#id id
                                                     #category {<tag> name}
                                                     #mandatory? mandatory?
                                                     #dependencies dependencies]))
              (revised@ #resolver (dictionary.has name id))
              :abstraction)]))

     (def: .public (<fetch> registry)
       (-> Registry (List Text))
       (|> registry
           :representation
           (value@ #artifacts)
           sequence.list
           (list.all (|>> (value@ #category)
                          (case> {<tag> name} {.#Some name}
                                 _ {.#None})))))]

    [#Definition definition definitions]
    [#Analyser analyser analysers]
    [#Synthesizer synthesizer synthesizers]
    [#Generator generator generators]
    [#Directive directive directives]
    [#Custom custom customs]
    )

  (def: .public (remember name registry)
    (-> Text Registry (Maybe ID))
    (|> (:representation registry)
        (value@ #resolver)
        (dictionary.value name)))

  (def: .public writer
    (Writer Registry)
    (let [category (: (Writer Category)
                      (function (_ value)
                        (case value
                          (^template [<nat> <tag> <writer>]
                            [{<tag> value}
                             ((binary.and binary.nat <writer>) [<nat> value])])
                          ([0 #Anonymous binary.any]
                           [1 #Definition binary.text]
                           [2 #Analyser binary.text]
                           [3 #Synthesizer binary.text]
                           [4 #Generator binary.text] 
                           [5 #Directive binary.text]
                           [6 #Custom binary.text]))))
          mandatory? binary.bit
          dependency (: (Writer Dependency)
                        (binary.and binary.nat binary.nat))
          dependencies (: (Writer (Set Dependency))
                          (binary.set dependency))
          artifacts (: (Writer (Sequence [Category Bit (Set Dependency)]))
                       (binary.sequence/64 ($_ binary.and category mandatory? dependencies)))]
      (|>> :representation
           (value@ #artifacts)
           (sequence#each (function (_ it)
                            [(value@ #category it)
                             (value@ #mandatory? it)
                             (value@ #dependencies it)]))
           artifacts)))

  (exception: .public (invalid_category [tag Nat])
    (exception.report
     ["Tag" (%.nat tag)]))

  (def: .public parser
    (Parser Registry)
    (let [category (: (Parser Category)
                      (do [! <>.monad]
                        [tag <binary>.nat]
                        (case tag
                          (^template [<nat> <tag> <parser>]
                            [<nat>
                             (# ! each (|>> {<tag>}) <parser>)])
                          ([0 #Anonymous <binary>.any]
                           [1 #Definition <binary>.text]
                           [2 #Analyser <binary>.text]
                           [3 #Synthesizer <binary>.text]
                           [4 #Generator <binary>.text]
                           [5 #Directive <binary>.text]
                           [6 #Custom <binary>.text])
                          
                          _ (<>.failure (exception.error ..invalid_category [tag])))))
          mandatory? <binary>.bit
          dependency (: (Parser Dependency)
                        (<>.and <binary>.nat <binary>.nat))
          dependencies (: (Parser (Set Dependency))
                          (<binary>.set ..dependency_hash dependency))]
      (|> (<binary>.sequence/64 ($_ <>.and category mandatory? dependencies))
          (# <>.monad each (sequence#mix (function (_ [category mandatory? dependencies] registry)
                                           (product.right
                                            (case category
                                              {#Anonymous}
                                              (..resource mandatory? dependencies registry)

                                              (^template [<tag> <create>]
                                                [{<tag> name}
                                                 (<create> name mandatory? dependencies registry)])
                                              ([#Definition ..definition]
                                               [#Analyser ..analyser]
                                               [#Synthesizer ..synthesizer]
                                               [#Generator ..generator]
                                               [#Directive ..directive]
                                               [#Custom ..custom])
                                              )))
                                         ..empty)))))
  )
