(.using
 [library
  [lux "*"
   [abstract
    ["[0]" monad {"+" do}]]
   [control
    ["[0]" maybe ("[1]#[0]" functor)]
    ["[0]" try {"+" Try}]
    ["[0]" state]
    [function
     ["[0]" memo {"+" Memo}]]]
   [data
    ["[0]" text
     ["%" format {"+" format}]]
    [collection
     ["[0]" list ("[1]#[0]" functor mix)]
     ["[0]" dictionary {"+" Dictionary}]
     ["[0]" set {"+" Set}]]]]]
 [////
  ["[0]" archive {"+" Output Archive}
   [key {"+" Key}]
   ["[0]" module
    ["[0]" descriptor {"+" Descriptor}]
    ["[0]" document {"+" Document}]]]])

(type: .public Ancestry
  (Set descriptor.Module))

(def: fresh
  Ancestry
  (set.empty text.hash))

(type: .public Graph
  (Dictionary descriptor.Module Ancestry))

(def: empty
  Graph
  (dictionary.empty text.hash))

(def: .public modules
  (-> Graph (List descriptor.Module))
  dictionary.keys)

(type: .public Dependency
  (Record
   [#module descriptor.Module
    #imports Ancestry]))

(def: .public graph
  (-> (List Dependency) Graph)
  (list#mix (function (_ [module imports] graph)
              (dictionary.has module imports graph))
            ..empty))

(def: (ancestry archive)
  (-> Archive Graph)
  (let [memo (: (Memo descriptor.Module Ancestry)
                (function (_ again module)
                  (do [! state.monad]
                    [.let [parents (case (archive.find module archive)
                                     {try.#Success [module output registry]}
                                     (value@ [module.#descriptor descriptor.#references] module)
                                     
                                     {try.#Failure error}
                                     ..fresh)]
                     ancestors (monad.each ! again (set.list parents))]
                    (in (list#mix set.union parents ancestors)))))
        ancestry (memo.open memo)]
    (list#mix (function (_ module memory)
                (if (dictionary.key? memory module)
                  memory
                  (let [[memory _] (ancestry [memory module])]
                    memory)))
              ..empty
              (archive.archived archive))))

(def: (dependency? ancestry target source)
  (-> Graph descriptor.Module descriptor.Module Bit)
  (let [target_ancestry (|> ancestry
                            (dictionary.value target)
                            (maybe.else ..fresh))]
    (set.member? target_ancestry source)))

(type: .public (Order a)
  (List [descriptor.Module [module.ID (archive.Entry a)]]))

(def: .public (load_order key archive)
  (All (_ a) (-> (Key a) Archive (Try (Order a))))
  (let [ancestry (..ancestry archive)]
    (|> ancestry
        dictionary.keys
        (list.sorted (..dependency? ancestry))
        (monad.each try.monad
                    (function (_ module)
                      (do try.monad
                        [module_id (archive.id module archive)
                         entry (archive.find module archive)
                         document (document.marked? key (value@ [archive.#module module.#document] entry))]
                        (in [module [module_id (with@ [archive.#module module.#document] document entry)]])))))))
