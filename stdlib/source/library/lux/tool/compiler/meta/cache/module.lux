(.using
 [library
  [lux "*"
   [abstract
    [monad {"+" do}]]
   [control
    [pipe {"+" case>}]
    ["[0]" try {"+" Try}]
    ["[0]" exception {"+" exception:}]
    [concurrency
     ["[0]" async {"+" Async}]]]
   [data
    [text
     ["%" format {"+" format}]]]
   [world
    ["[0]" file]]]]
 ["[0]" //
  [//
   [context {"+" Context}]
   [archive
    ["[0]" module]]]])

(exception: .public (cannot_enable [archive file.Path
                                    @module module.ID
                                    error Text])
  (exception.report
   ["Archive" archive]
   ["Module ID" (%.nat @module)]
   ["Error" error]))

(def: .public (path fs context @module)
  (All (_ !) (-> (file.System !) Context module.ID file.Path))
  (format (//.path fs context)
          (# fs separator)
          (%.nat @module)))

(def: .public (enabled? fs context @module)
  (All (_ !) (-> (file.System !) Context module.ID (! Bit)))
  (# fs directory? (..path fs context @module)))

(def: .public (enable! fs context @module)
  (-> (file.System Async) Context module.ID (Async (Try Any)))
  (do [! async.monad]
    [.let [path (..path fs context @module)]
     module_exists? (# fs directory? path)]
    (if module_exists?
      (in {try.#Success []})
      (with_expansions [<failure> (exception.except ..cannot_enable [(//.path fs context)
                                                                     @module
                                                                     error])]
        (do !
          [? (//.enable! fs context)]
          (case ?
            {try.#Failure error}
            (in <failure>)
            
            success
            (|> path
                (# fs make_directory)
                (# ! each (|>> (case> {try.#Failure error}
                                      <failure>

                                      success
                                      success))))))))))
