(.using
 [library
  [lux "*"
   ["@" target]
   [abstract
    ["[0]" monad {"+" Monad do}]]
   [control
    ["[0]" pipe]
    ["[0]" try {"+" Try}]
    ["[0]" exception {"+" exception:}]]
   [data
    [binary {"+" Binary}]
    ["[0]" product]
    ["[0]" text ("[1]#[0]" equivalence)
     ["%" format {"+" format}]]
    [collection
     ["[0]" list ("[1]#[0]" functor)]
     ["[0]" dictionary {"+" Dictionary}]]]
   [world
    ["[0]" file]]]]
 ["[0]" //
  [//
   [context {"+" Context}]
   [archive
    ["[0]" module]]]])

(exception: .public (cannot_enable [archive file.Path
                                    @module module.ID
                                    error Text])
  (exception.report
   "Archive" archive
   "Module ID" (%.nat @module)
   "Error" error))

(def: .public (path fs context @module)
  (All (_ !) (-> (file.System !) Context module.ID file.Path))
  (format (//.path fs context)
          (# fs separator)
          (%.nat @module)))

(def: .public (enabled? fs context @module)
  (All (_ !) (-> (file.System !) Context module.ID (! Bit)))
  (# fs directory? (..path fs context @module)))

(def: .public (enable! ! fs context @module)
  (All (_ !) (-> (Monad !) (file.System !) Context module.ID (! (Try Any))))
  (do !
    [.let [path (..path fs context @module)]
     module_exists? (# fs directory? path)]
    (if module_exists?
      (in {try.#Success []})
      (with_expansions [<failure> (exception.except ..cannot_enable [(//.path fs context)
                                                                     @module
                                                                     error])]
        (do !
          [? (//.enable! ! fs context)]
          (case ?
            {try.#Failure error}
            (in <failure>)
            
            success
            (|> path
                (# fs make_directory)
                (# ! each (|>> (pipe.case
                                 {try.#Failure error}
                                 <failure>

                                 success
                                 success))))))))))

(def: file
  file.Path
  "descriptor")

(def: .public (descriptor fs context @module)
  (All (_ !) (-> (file.System !) Context module.ID file.Path))
  (format (..path fs context @module)
          (# fs separator)
          ..file))

(def: .public (cache! fs context @module content)
  (All (_ !) (-> (file.System !) Context module.ID Binary (! (Try Any))))
  (# fs write content (..descriptor fs context @module)))

(def: .public (cache fs context @module)
  (All (_ !) (-> (file.System !) Context module.ID (! (Try Binary))))
  (# fs read (..descriptor fs context @module)))

(def: .public (artifacts ! fs context @module)
  (All (_ !) (-> (Monad !) (file.System !) Context module.ID (! (Try (Dictionary Text Binary)))))
  (do [! (try.with !)]
    [files (# fs directory_files (..path fs context @module))
     pairs (|> files
               (list#each (function (_ file)
                            [(file.name fs file) file]))
               (list.only (|>> product.left (text#= ..file) not))
               (monad.each ! (function (_ [name path])
                               (|> path
                                   (# fs read)
                                   (# ! each (|>> [name]))))))]
    (in (dictionary.of_list text.hash (for @.old (as (List [Text Binary]) pairs)
                                           pairs)))))
