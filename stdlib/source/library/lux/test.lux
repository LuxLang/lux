(.module:
  {#.doc "Tools for unit & property-based/generative testing."}
  [library
   [lux (#- and for)
    ["." meta]
    ["." debug]
    [abstract
     ["." monad (#+ do)]]
    [control
     [pipe (#+ case>)]
     ["." maybe]
     ["." try]
     ["." exception (#+ exception:)]
     ["." io]
     [concurrency
      ["." atom (#+ Atom)]
      ["." async (#+ Async) ("#\." monad)]]
     ["<>" parser
      ["<.>" code]]]
    [data
     ["." product]
     ["." name]
     ["." text
      ["%" format (#+ format)]]
     [collection
      ["." list ("#\." functor fold)]
      ["." set (#+ Set)]
      ["." dictionary #_
       ["#" ordered (#+ Dictionary)]]]]
    [time
     ["." instant]
     ["." duration (#+ Duration)]]
    [math
     ["." random (#+ Random) ("#\." monad)]
     [number (#+ hex)
      ["n" nat]
      ["f" frac]]]
    [macro
     [syntax (#+ syntax:)]
     ["." code]]
    [world
     ["." program]]]])

(type: .public Tally
  {#.doc (example "A record of successes and failures while executing tests.")}
  {#successes Nat
   #failures Nat
   #expected_coverage (Set Name)
   #actual_coverage (Set Name)})

(def: (total parameter subject)
  (-> Tally Tally Tally)
  {#successes (n.+ (get@ #successes parameter) (get@ #successes subject))
   #failures (n.+ (get@ #failures parameter) (get@ #failures subject))
   #expected_coverage (set.union (get@ #expected_coverage parameter)
                                 (get@ #expected_coverage subject))
   #actual_coverage (set.union (get@ #actual_coverage parameter)
                               (get@ #actual_coverage subject))})

(def: start
  Tally
  {#successes 0
   #failures 0
   #expected_coverage (set.empty name.hash)
   #actual_coverage (set.empty name.hash)})

(template [<name> <category>]
  [(def: <name>
     Tally
     (update@ <category> .inc ..start))]

  [success_tally #successes]
  [failure_tally #failures]
  )

(type: .public Assertion
  {#.doc (example "An asynchronous operation that yields test results.")}
  (Async [Tally Text]))

(type: .public Test
  {#.doc (example "A test that relies on random data generation to thoroughly cover different scenarios.")}
  (Random Assertion))

(def: separator
  text.new_line)

(def: .public (and' left right)
  {#.doc "Sequencing combinator (for assertions)."}
  (-> Assertion Assertion Assertion)
  (let [[read! write!] (: [(Async [Tally Text])
                           (async.Resolver [Tally Text])]
                          (async.async []))
        _ (|> left
              (async.upon! (function (_ [l_tally l_documentation])
                             (async.upon! (function (_ [r_tally r_documentation])
                                            (write! [(..total l_tally r_tally)
                                                     (format l_documentation ..separator r_documentation)]))
                                          right)))
              io.run!)]
    read!))

(def: .public (and left right)
  {#.doc "Sequencing combinator."}
  (-> Test Test Test)
  (do {! random.monad}
    [left left]
    (\ ! map (..and' left) right)))

(def: context_prefix
  text.tab)

(def: .public (context description)
  {#.doc (example "Adds a contextual description to a test's documentation.")}
  (-> Text Test Test)
  (random\map (async\map (function (_ [tally documentation])
                           [tally (|> documentation
                                      (text.all_split_by ..separator)
                                      (list\map (|>> (format context_prefix)))
                                      (text.interposed ..separator)
                                      (format description ..separator))]))))

(def: failure_prefix "[Failure] ")
(def: success_prefix "[Success] ")

(def: .public failure
  {#.doc (example "A failing test, with a given error message.")}
  (-> Text Test)
  (|>> (format ..failure_prefix)
       [..failure_tally]
       async\in
       random\in))

(def: .public (assertion message condition)
  {#.doc "Check that a condition is #1, and fail with the given message otherwise."}
  (-> Text Bit Assertion)
  (<| async\in
      (if condition
        [..success_tally (format ..success_prefix message)]
        [..failure_tally (format ..failure_prefix message)])))

(def: .public (test message condition)
  {#.doc "Check that a condition is #1, and fail with the given message otherwise."}
  (-> Text Bit Test)
  (random\in (..assertion message condition)))

(def: .public (lifted message random)
  (-> Text (Random Bit) Test)
  (random\map (..assertion message) random))

(def: pcg_32_magic_inc
  Nat
  (hex "FEDCBA9876543210"))

(type: .public Seed
  {#.doc "The seed value used for random testing (if that feature is used)."}
  Nat)

(def: .public (seed value test)
  {#.doc (example "Execute the given test with a specific seed value."
                  "This allows you to reproduce a failing test case as many times as you want while debugging.")}
  (-> Seed Test Test)
  (function (_ prng)
    (let [[_ result] (random.result (random.pcg_32 [..pcg_32_magic_inc value])
                                    test)]
      [prng result])))

(def: failed?
  (-> Tally Bit)
  (|>> (get@ #failures) (n.> 0)))

(def: (times_failure seed documentation)
  (-> Seed Text Text)
  (format documentation ..separator ..separator
          "Failed with this seed: " (%.nat seed)))

(exception: .public must_try_test_at_least_once)

(def: .public (times amount test)
  {#.doc (example "Allows executing a test several times."
                  "By doing this, it's possible to thoroughly test code with many different scenarios."
                  "This assumes that random data generation is being used in tests instead of fixed/constant inputs.")}
  (-> Nat Test Test)
  (case amount
    0 (..failure (exception.error ..must_try_test_at_least_once []))
    _ (do random.monad
        [seed random.nat]
        (function (recur prng)
          (let [[prng' instance] (random.result (random.pcg_32 [..pcg_32_magic_inc seed]) test)]
            [prng' (do {! async.monad}
                     [[tally documentation] instance]
                     (if (..failed? tally)
                       (in [tally (times_failure seed documentation)])
                       (case amount
                         1 instance
                         _ (|> test
                               (times (dec amount))
                               (random.result prng')
                               product.right))))])))))

(def: (description duration tally)
  (-> Duration Tally Text)
  (let [successes (get@ #successes tally)
        failures (get@ #failures tally)
        missing (set.difference (get@ #actual_coverage tally)
                                (get@ #expected_coverage tally))
        unexpected (set.difference (get@ #expected_coverage tally)
                                   (get@ #actual_coverage tally))
        report (: (-> (Set Name) Text)
                  (|>> set.list
                       (list.sorted (\ name.order <))
                       (exception.listing %.name)))
        expected_definitions_to_cover (set.size (get@ #expected_coverage tally))
        unexpected_definitions_covered (set.size unexpected)
        actual_definitions_covered (n.- unexpected_definitions_covered
                                        (set.size (get@ #actual_coverage tally)))
        coverage (case expected_definitions_to_cover
                   0 "N/A"
                   expected (let [missing_ratio (f./ (n.frac expected)
                                                     (n.frac (set.size missing)))
                                  max_percent +100.0
                                  done_percent (|> +1.0
                                                   (f.- missing_ratio)
                                                   (f.* max_percent))]
                              (if (f.= max_percent done_percent)
                                "100%"
                                (let [raw (|> done_percent
                                              %.frac
                                              (text.replaced/1 "+" ""))]
                                  (|> raw
                                      (text.clip 0 (if (f.>= +10.0 done_percent)
                                                     5 ... XX.XX
                                                     4 ...  X.XX
                                                     ))
                                      (maybe.else raw)
                                      (text.suffix "%"))))))]
    (exception.report
     ["Duration" (%.duration duration)]
     ["# Tests" (%.nat (n.+ successes failures))]
     ["# Successes" (%.nat successes)]
     ["# Failures" (%.nat failures)]
     ["# Expected definitions to cover" (%.nat expected_definitions_to_cover)]
     ["# Actual definitions covered" (%.nat actual_definitions_covered)]
     ["# Pending definitions to cover" (%.nat (n.- actual_definitions_covered
                                                   expected_definitions_to_cover))]
     ["# Unexpected definitions covered" (%.nat unexpected_definitions_covered)]
     ["Coverage" coverage]
     ["Pending definitions to cover" (report missing)]
     ["Unexpected definitions covered" (report unexpected)])))

(def: failure_exit_code +1)
(def: success_exit_code +0)

(def: .public (run! test)
  {#.doc (example "Executes a test, and exits the program with either a successful or a failing exit code."
                  "WARNING: This procedure is only meant to be used in (program: ...) forms.")}
  (-> Test (Async Nothing))
  (do async.monad
    [pre (async.future instant.now)
     .let [seed (instant.millis pre)
           prng (random.pcg_32 [..pcg_32_magic_inc seed])]
     [tally documentation] (|> test (random.result prng) product.right)
     post (async.future instant.now)
     .let [duration (instant.span pre post)
           _ (debug.log! (format documentation text.new_line text.new_line
                                 (..description duration tally)
                                 text.new_line))]]
    (async.future (\ program.default exit
                     (case (get@ #failures tally)
                       0 ..success_exit_code
                       _ ..failure_exit_code)))))

(def: (|cover'| coverage condition)
  (-> (List Name) Bit Assertion)
  (let [message (|> coverage
                    (list\map %.name)
                    (text.interposed " & "))
        coverage (set.of_list name.hash coverage)]
    (|> (..assertion message condition)
        (async\map (function (_ [tally documentation])
                     [(update@ #actual_coverage (set.union coverage) tally)
                      documentation])))))

(def: (|cover| coverage condition)
  (-> (List Name) Bit Test)
  (|> (..|cover'| coverage condition)
      random\in))

(def: (|for| coverage test)
  (-> (List Name) Test Test)
  (let [context (|> coverage
                    (list\map %.name)
                    (text.interposed " & "))
        coverage (set.of_list name.hash coverage)]
    (random\map (async\map (function (_ [tally documentation])
                             [(update@ #actual_coverage (set.union coverage) tally)
                              documentation]))
                (..context context test))))

(def: (name_code name)
  (-> Name Code)
  (code.tuple (list (code.text (name.module name))
                    (code.text (name.short name)))))

(syntax: (reference [name <code>.identifier])
  (do meta.monad
    [_ (meta.export name)]
    (in (list (name_code name)))))

(def: coverage_separator
  Text
  (text.of_char 31))

(def: encode_coverage
  (-> (List Text) Text)
  (list\fold (function (_ short aggregate)
               (case aggregate
                 "" short
                 _ (format aggregate ..coverage_separator short)))
             ""))

(def: (decode_coverage module encoding)
  (-> Text Text (Set Name))
  (loop [remaining encoding
         output (set.of_list name.hash (list))]
    (case (text.split_by ..coverage_separator remaining)
      (#.Some [head tail])
      (recur tail (set.has [module head] output))
      
      #.None
      (set.has [module remaining] output))))

(template [<macro> <function>]
  [(syntax: .public (<macro> [coverage (<code>.tuple (<>.many <code>.any))
                              condition <code>.any])
     {#.doc (example "Specifies a test as covering one or more definitions."
                     "Adds to the test tally information to track which definitions have been tested."
                     (<macro> [definition/0 definition/1 ,,, definition/N]
                              (: Bit
                                 (some "computation"))))}
     (let [coverage (list\map (function (_ definition)
                                (` ((~! ..reference) (~ definition))))
                              coverage)]
       (in (list (` ((~! <function>)
                     (: (.List .Name)
                        (.list (~+ coverage)))
                     (~ condition)))))))]

  [cover' ..|cover'|]
  [cover ..|cover|]
  )

(syntax: .public (for [coverage (<code>.tuple (<>.many <code>.any))
                       test <code>.any])
  {#.doc (example "Specifies a context for tests as covering one or more definitions."
                  "Adds to the test tally information to track which definitions have been tested."
                  (for [definition/0 definition/1 ,,, definition/N]
                       (: Test
                          some_test)))}
  (let [coverage (list\map (function (_ definition)
                             (` ((~! ..reference) (~ definition))))
                           coverage)]
    (in (list (` ((~! ..|for|)
                  (: (.List .Name)
                     (.list (~+ coverage)))
                  (~ test)))))))

(def: (covering' module coverage test)
  (-> Text Text Test Test)
  (let [coverage (..decode_coverage module coverage)]
    (|> (..context module test)
        (random\map (async\map (function (_ [tally documentation])
                                 [(update@ #expected_coverage (set.union coverage) tally)
                                  documentation]))))))

(syntax: .public (covering [module <code>.identifier
                            test <code>.any])
  {#.doc (example "Specifies the module being covered by a test."
                  "Adds tracking information to the tally to know which exported definitions in the module need to be covered."
                  (covering .._
                            (: Test
                               some_test)))}
  (do meta.monad
    [.let [module (name.module module)]
     definitions (meta.definitions module)
     .let [coverage (|> definitions
                        (list\fold (function (_ [short [exported? _]] aggregate)
                                     (if exported?
                                       (#.Item short aggregate)
                                       aggregate))
                                   #.End)
                        ..encode_coverage)]]
    (in (list (` ((~! ..covering')
                  (~ (code.text module))
                  (~ (code.text coverage))
                  (~ test)))))))

(exception: .public (error_during_execution {error Text})
  (exception.report
   ["Error" (%.text error)]))

(def: .public (in_parallel tests)
  {#.doc (example "Executes multiple tests in parallel (if the host platform supports it) to take advantage of multiple cores.")}
  (-> (List Test) Test)
  (case (list.size tests)
    0
    (random\in (async\in [..start ""]))
    
    expected_tests
    (do random.monad
      [seed random.nat
       .let [prng (random.pcg_32 [..pcg_32_magic_inc seed])
             run! (: (-> Test Assertion)
                     (|>> (random.result prng)
                          product.right
                          (function (_ _))
                          "lux try"
                          (case> (#try.Success output)
                                 output
                                 
                                 (#try.Failure error)
                                 (..assertion (exception.error ..error_during_execution [error]) false))
                          io.io
                          async.future
                          async\join))
             state (: (Atom (Dictionary Nat [Tally Text]))
                      (atom.atom (dictionary.empty n.order)))
             [read! write!] (: [Assertion
                                (async.Resolver [Tally Text])]
                               (async.async []))
             _ (io.run! (monad.map io.monad
                                   (function (_ [index test])
                                     (async.upon! (function (_ assertion)
                                                    (do io.monad
                                                      [[_ results] (atom.update! (dictionary.has index assertion) state)]
                                                      (if (n.= expected_tests (dictionary.size results))
                                                        (let [assertions (|> results
                                                                             dictionary.entries
                                                                             (list\map product.right))]
                                                          (write! [(|> assertions
                                                                       (list\map product.left)
                                                                       (list\fold ..total ..start))
                                                                   (|> assertions
                                                                       (list\map product.right)
                                                                       (text.interposed ..separator))]))
                                                        (in []))))
                                                  (run! test)))
                                   (list.enumeration tests)))]]
      (in read!))))
