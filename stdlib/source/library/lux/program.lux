(.module:
  [library
   [lux #*
    ["@" target]
    [abstract
     [monad (#+ do)]]
    [control
     ["." io]
     [concurrency
      ["." thread]]
     ["<>" parser
      ["<.>" code]
      ["<.>" cli]]]
    [data
     ["." text]
     [collection
      ["." list ("#\." monad)]]]
    [macro (#+ with_identifiers)
     [syntax (#+ syntax:)]
     ["." code]]]])

(type: Arguments
  (#Raw Text)
  (#Parsed (List Code)))

(def: arguments^
  (<code>.Parser Arguments)
  (<>.or <code>.local_identifier
         (<code>.tuple (<>.some <code>.any))))

(syntax: .public (program: [args ..arguments^
                            body <code>.any])
  {#.doc (example "Defines the entry-point to a program (similar to the 'main' function/method in other programming languages)."
                  "Can take a list of all the input parameters to the program."
                  "Or, can destructure them using CLI-option combinators from the library/lux/control/parser/cli module."
                  (program: all_arguments
                    (do io.monad
                      [foo (initialize program)]
                      (do_something_with all_arguments)))

                  (program: [config configuration_parser]
                    (do io.monad
                      [data (initialize program with config)]
                      (do_something_with data))))}
  (with_identifiers [g!program g!args g!_ g!output g!message]
    (let [initialization+event_loop
          (` ((~! do) (~! io.monad)
              [(~ g!output) (~ body)
               (~+ (for {@.old (list)
                         @.jvm (list)
                         @.js (list)
                         @.python (list)}
                        (list g!_ (` (~! thread.run!)))))]
              ((~' in) (~ g!output))))]
      (in (list (` ("lux def program"
                    (~ (case args
                         (#Raw args)
                         (` (.function ((~ g!program) (~ (code.identifier ["" args])))
                              (~ initialization+event_loop)))
                         
                         (#Parsed args)
                         (` (.function ((~ g!program) (~ g!args))
                              (case ((~! <cli>.result) (: (~! (<cli>.Parser (io.IO .Any)))
                                                          ((~! do) (~! <>.monad)
                                                           [(~+ args)
                                                            (~ g!_) (~! <cli>.end)]
                                                           ((~' in) (~ initialization+event_loop))))
                                     (~ g!args))
                                (#.Right (~ g!output))
                                (~ g!output)

                                (#.Left (~ g!message))
                                (.panic! (~ g!message))))))))))))))
