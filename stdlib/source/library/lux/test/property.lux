... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except and for)
   ["[0]" debug]
   [abstract
    [monad (.only do)]]
   [control
    ["[0]" pipe]
    ["[0]" maybe]
    ["[0]" try]
    ["[0]" exception (.only Exception)]
    ["[0]" io]
    ["[0]" state]
    [concurrency
     ["[0]" atom (.only Atom)]
     ["[0]" async (.only Async) (.use "[1]#[0]" monad)]]]
   [data
    ["[0]" product]
    ["[0]" text (.only)
     ["%" \\injection]]
    [collection
     ["[0]" list (.use "[1]#[0]" functor mix)]
     ["[0]" set]
     ["[0]" dictionary
      ["[1]" ordered (.only Dictionary)]]]]
   [math
    ["[0]" random (.only Random) (.use "[1]#[0]" monad)]
    [number (.only hex)
     ["n" natural]
     ["d" decimal]]]
   [meta
    ["[0]" symbol]
    ["[0]" code
     ["<[1]>" \\projection]]
    [macro
     ["[0]" syntax]
     ["[0]" expansion]
     ["[0]" template]]]
   [world
    ["[0]" environment]
    ["[0]" console]
    [time
     ["[0]" duration (.only Duration)]
     ["[0]" instant]]]]]
 [//
  ["//" unit]
  ["[0]" coverage (.only Coverage)]
  ["[0]" tally (.only Tally)]])

(every .public Test
  (Random //.Test random.PCG_32))

... The PRNG is not updated by the branches in order to ensure that adding new test cases
... in one branch does not alter the random generation in another branch.
(the .public (and left right)
  (-> Test Test
      Test)
  (function (_ prng)
    (let [[_ left] (left prng)
          [_ right] (right prng)]
      [prng (//.and left right)])))

(the .public context
  (-> Text Test
      Test)
  (|>> //.context
       random#each))

(the .public failure
  (-> Text
      Test)
  (|>> //.failure
       random#in))

(the .public success
  (-> Text
      Test)
  (|>> //.success
       random#in))

(the .public (test message condition)
  (-> Text Bit
      Test)
  (random#in (//.test message condition)))

(the .public (lifted message random)
  (-> Text (Random Bit)
      Test)
  (do random.monad
    [it random]
    (test message it)))

(the pcg_32_magic_inc
  (hex "FEDCBA9876543210"))

(every .public Seed
  Natural)

(the .public (seed value test)
  (-> Seed Test
      Test)
  (function (_ prng)
    (let [[_ value] (random.value random.pcg_32
                                  [random.#increase ..pcg_32_magic_inc
                                   random.#seed value]
                                  test)]
      [prng value])))

(the separator
  text.new_line)

(the (times_failure seed documentation)
  (-> Seed Text
      Text)
  (%.message documentation ..separator ..separator
             "Failed with this seed: " (%.natural seed)))

(exception.the .public must_try_test_at_least_once)

(every .public Success_Policy
  Bit)

(template.with [<policy> <name>]
  [(the .public <name>
     Success_Policy
     <policy>)]

  [#0 ignore_success]
  [#1 announce_success]
  )

(the .public (times amount announce_success? test)
  (-> Natural Success_Policy Test
      Test)
  (when amount
    0 (..failure (exception.error ..must_try_test_at_least_once []))
    _ (do random.monad
        [seed random.natural]
        (function (again prng)
          (let [[prng' instance] (random.value random.pcg_32
                                               [random.#increase ..pcg_32_magic_inc
                                                random.#seed seed]
                                               test)]
            [prng' (do [! async.monad]
                     [[tally documentation] instance]
                     (if (tally.failed? tally)
                       (in [tally (times_failure seed documentation)])
                       (exec
                         (if announce_success?
                           (debug.log! (%.message "Succeeded with this seed: " (%.natural seed)))
                           [])
                         (when amount
                           1 instance
                           _ (|> test
                                 (times (-- amount) announce_success?)
                                 (state.value prng')
                                 product.right)))))])))))

(the (description duration tally)
  (-> Duration Tally
      Text)
  (let [successes (its tally.#successes tally)
        failures (its tally.#failures tally)
        missing (set.difference (its tally.#actual tally)
                                (its tally.#expected tally))
        unexpected (set.difference (its tally.#expected tally)
                                   (its tally.#actual tally))
        report (is (-> Coverage Text)
                   (|>> set.list
                        (list.sorted (of symbol.order <))
                        (exception.listing symbol.as_text)))
        expected_coverage (set.size (its tally.#expected tally))
        unexpected_coverage (set.size unexpected)
        actual_coverage (n.- unexpected_coverage
                             (set.size (its tally.#actual tally)))
        coverage (when expected_coverage
                   0 "N/A"
                   expected (let [missing_ratio (d./ (n.decimal expected)
                                                     (n.decimal (set.size missing)))
                                  max_percent +100.0
                                  done_percent (|> +1.0
                                                   (d.- missing_ratio)
                                                   (d.* max_percent))]
                              (if (d.= max_percent done_percent)
                                "100%"
                                (let [raw (|> done_percent
                                              %.decimal
                                              (text.replaced_once "+" ""))]
                                  (|> raw
                                      (text.clip 0 (if (d.< +10.0 done_percent)
                                                     4 ...  X.XX
                                                     5 ... XX.XX
                                                     ))
                                      (maybe.else raw)
                                      (text.suffix "%"))))))]
    (exception.report
     (list ["Duration" (duration.as_text duration)]

           ["Tests" (%.natural (n.+ successes failures))]
           ["Successes" (%.natural successes)]
           ["Failures" (%.natural failures)]
           
           ["Expected coverage" (%.natural expected_coverage)]
           ["Actual coverage" (%.natural actual_coverage)]
           ["Pending coverage" (%.natural (n.- actual_coverage
                                               expected_coverage))]
           ["Unexpected coverage" (%.natural unexpected_coverage)]
           
           ["Coverage" coverage]
           ["Pending" (report missing)]
           ["Unexpected" (report unexpected)]))))

(the failure_exit_code +1)
(the success_exit_code +0)

(the .public (value test)
  (-> Test
      (Async Nothing))
  (do async.monad
    [pre (async.future instant.now)
     .let [seed (instant.millis pre)]
     [tally documentation] (|> test
                               (random.value random.pcg_32
                                             [random.#increase ..pcg_32_magic_inc
                                              random.#seed seed])
                               product.right)
     post (async.future instant.now)
     .let [duration (instant.span pre post)
           report (%.message documentation
                             text.new_line text.new_line
                             (..description duration tally)
                             text.new_line)]
     _ (expansion.let [<else> (in {try.#Success (debug.log! report)})]
         (.for .js (when console.default
                     {.#None}
                     <else>

                     {.#Some console}
                     (console.write_line report console))
               <else>))]
    (async.future (of environment.default exit
                      (when (its tally.#failures tally)
                        0 ..success_exit_code
                        _ ..failure_exit_code)))))

(the .public coverage
  (syntax.macro (_ [coverage <code>.any
                    condition <code>.any])
    (in (list (` (of random.monad (,' in) (//.coverage (, coverage) (, condition))))))))

(the .public for
  (syntax.macro (_ [coverage <code>.any
                    test <code>.any])
    (in (list (` (of random.functor
                     (,' each)
                     (|>> (//.for (, coverage)))
                     (, test)))))))

(the .public covering
  (syntax.macro (_ [module <code>.any
                    test <code>.any])
    (in (list (` (of random.functor
                     (,' each)
                     (|>> (//.covering (, module)))
                     (, test)))))))

(exception.the .public (error_during_execution error)
  (Exception Text)
  (exception.report
   (list ["Error" (%.text error)])))

(the .public (in_parallel tests)
  (-> (List Test)
      Test)
  (when (list.size tests)
    0
    (random#in (async#in [tally.empty ""]))
    
    expected_tests
    (do random.monad
      [seed random.natural
       .let [value (is (-> Test
                           //.Test)
                       (|>> (random.value random.pcg_32
                                          [random.#increase ..pcg_32_magic_inc
                                           random.#seed seed])
                            product.right
                            try
                            (pipe.when
                              {try.#Success output}
                              output
                              
                              {try.#Failure error}
                              (//.test (exception.error ..error_during_execution [error]) false))))
             state (is (Atom (Dictionary Natural [Tally Text]))
                       (atom.atom (dictionary.empty n.order)))
             [read! write!] (is [//.Test
                                 (async.Resolver [Tally Text])]
                                (async.async []))
             _ (list#mix (function (_ test index)
                           (exec
                             (|> (value test)
                                 (async.upon! (function (_ assertion)
                                                (do io.monad
                                                  [[_ results] (atom.update! (dictionary.has index assertion) state)]
                                                  (if (n.= expected_tests (dictionary.size results))
                                                    (let [assertions (|> results
                                                                         dictionary.entries
                                                                         (list#each product.right))]
                                                      (write! [(|> assertions
                                                                   (list#each product.left)
                                                                   (list#mix tally.and tally.empty))
                                                               (|> assertions
                                                                   (list#each product.right)
                                                                   (text.interposed ..separator))]))
                                                    (in [])))))
                                 io.value)
                             (++ index)))
                         0
                         tests)]]
      (in read!))))
