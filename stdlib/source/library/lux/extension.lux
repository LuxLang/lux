(.module:
  [library
   [lux "*"
    [abstract
     ["[0]" monad]]
    [control
     ["<>" parser ("[1]\[0]" monad)
      ["<c>" code {"+" [Parser]}]
      ["<a>" analysis]
      ["<s>" synthesis]]]
    [data
     ["[0]" product]
     [collection
      ["[0]" list ("[1]\[0]" functor)]]]
    [macro {"+" [with_identifiers]}
     ["[0]" code]
     [syntax {"+" [syntax:]}]]
    [tool
     [compiler
      ["[0]" phase]]]]])

(type: Declaration
  (Record
   [#name Code
    #label Text
    #phase Text
    #archive Text
    #inputs (List Code)]))

(def: (declaration default)
  (-> Code (Parser Declaration))
  (<c>.form ($_ <>.and
                <c>.any
                <c>.local_identifier
                <c>.local_identifier
                <c>.local_identifier
                (<c>.tuple (<>.some <c>.any)))))

(template [<any> <end> <and> <result> <extension> <name>]
  [(syntax: .public (<name> [[name extension phase archive inputs] (..declaration (` <any>))
                             body <c>.any])
     (let [g!name (code.local_identifier extension)
           g!phase (code.local_identifier phase)
           g!archive (code.local_identifier archive)]
       (with_identifiers [g!handler g!inputs g!error g!_]
         (in (list (` (<extension> (~ name)
                                   (.function ((~ g!handler) (~ g!name) (~ g!phase) (~ g!archive) (~ g!inputs))
                                     (.case ((~! <result>)
                                             ((~! monad.do) (~! <>.monad)
                                              [(~+ inputs)
                                               (~ g!_) <end>]
                                              (.\ (~! <>.monad) (~' in) (~ body)))
                                             (~ g!inputs))
                                       {.#Right (~ g!_)}
                                       (~ g!_)

                                       {.#Left (~ g!error)}
                                       ((~! phase.failure) (~ g!error)))
                                     ))))))))]

  [<c>.any <c>.end! <c>.and <c>.result "lux def analysis" analysis:]
  [<a>.any <a>.end! <a>.and <a>.result "lux def synthesis" synthesis:]
  [<s>.any <s>.end! <s>.and <s>.result "lux def generation" generation:]
  [<c>.any <c>.end! <c>.and <c>.result "lux def directive" directive:]
  )
