(.using
 [library
  [lux "*"
   [abstract
    ["[0]" monad]]
   [control
    ["<>" parser ("[1]#[0]" monad)
     ["<c>" code {"+" Parser}]
     ["<a>" analysis]
     ["<s>" synthesis]]]
   [data
    ["[0]" product]
    [collection
     ["[0]" list ("[1]#[0]" functor)]]]
   [macro {"+" with_symbols}
    [syntax {"+" syntax:}]
    ["[0]" code]]
   [tool
    [compiler
     ["[0]" phase]]]]])

(type: Declaration
  (Record
   [#name Code
    #label Text
    #phase Text
    #archive Text
    #inputs (List Code)]))

(def: (declaration default)
  (-> Code (Parser Declaration))
  (<c>.form ($_ <>.and
                <c>.any
                <c>.local_symbol
                <c>.local_symbol
                <c>.local_symbol
                (<c>.tuple (<>.some <c>.any)))))

(template [<any> <end> <and> <result> <extension> <name>]
  [(syntax: .public (<name> [[name extension phase archive inputs] (..declaration (` <any>))
                             body <c>.any])
     (let [g!name (code.local_symbol extension)
           g!phase (code.local_symbol phase)
           g!archive (code.local_symbol archive)]
       (with_symbols [g!handler g!inputs g!error g!_]
         (in (list (` (<extension> (~ name)
                                   (.function ((~ g!handler) (~ g!name) (~ g!phase) (~ g!archive) (~ g!inputs))
                                     (.case ((~! <result>)
                                             ((~! monad.do) (~! <>.monad)
                                              [(~+ inputs)
                                               (~ g!_) <end>]
                                              (.# (~! <>.monad) (~' in) (~ body)))
                                             (~ g!inputs))
                                       {.#Right (~ g!_)}
                                       (~ g!_)

                                       {.#Left (~ g!error)}
                                       ((~! phase.failure) (~ g!error)))
                                     ))))))))]

  [<c>.any <c>.end! <c>.and <c>.result "lux def analysis" analysis:]
  [<a>.any <a>.end! <a>.and <a>.result "lux def synthesis" synthesis:]
  [<s>.any <s>.end! <s>.and <s>.result "lux def generation" generation:]
  [<c>.any <c>.end! <c>.and <c>.result "lux def directive" directive:]
  )
