... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except macro
                its revised has
                as
                when
                all with)
   [abstract
    [functor (.only Functor)
     ["[0]" pro]]]
   [type
    ["[0]" nominal]]
   ["[0]" function]
   [data
    ["[0]" product]]]])

(the macro
  (<| (.in_module# .prelude)
      .template#macro))

(the with_template
  (<| (.in_module# .prelude)
      .with_template))

(the Its
  (macro (_ focus focus' context context')
    [(-> context
         focus)]))

(the Has
  (macro (_ focus focus' context context')
    [(-> [focus' context]
         context')]))

(every .public (Lens focus focus' context context')
  (Record
   [#its (Its focus focus' context context')
    #has (Has focus focus' context context')]))

(the .public (lens its has)
  (for_any (_ focus focus' context context')
    (-> (Its focus focus' context context') (Has focus focus' context context')
        (Lens focus focus' context context')))
  [#its its
   #has has])

(the .public its
  (for_any (_ focus focus' context context')
    (-> (Lens focus focus' context context')
        (Its focus focus' context context')))
  (.its #its))

(the .public (has lens value context)
  (for_any (_ focus focus' context context')
    (-> (Lens focus focus' context context')
        (-> focus'
            (-> context context'))))
  (by lens #has [value context]))

(the .public (revised lens change context)
  (for_any (_ focus focus' context context')
    (-> (Lens focus focus' context context')
        (-> (-> focus focus')
            (-> context context'))))
  (by lens #has [(change (its lens context)) context]))

(the .public (composite outer inner)
  (for_any (_ focus focus'
              middle middle'
              context context')
    (-> (Lens middle middle' context context') (Lens focus focus' middle middle')
        (Lens focus focus' context context')))
  [#its (|>> (its outer)
             (its inner))
   #has (function (_ [focus context])
          (revised outer (has inner focus) context))])

(the As
  (macro (_ it alternative)
    [(-> it
         alternative)]))

(the Of
  (macro (_ it alternative)
    [(-> alternative
         it)]))

(every .public (View it alternative)
  (Record
   [#as (As it alternative)
    #of (Of it alternative)]))

(the .public (view as of)
  (for_any (_ it alternative)
    (-> (As it alternative) (Of it alternative)
        (View it alternative)))
  [#as as
   #of of])

(with_template [,name ,type ,tag]
  [(the .public ,name
     (for_any (_ it alternative)
       (-> (View it alternative)
           (,type it alternative)))
     (.its ,tag))]

  [as As #as]
  [of Of #of]
  )

(the When
  (macro (_ context case)
    [(-> context
         (Or context case))]))

(the Some
  (macro (_ context case)
    [(-> case
         context)]))

(every .public (Prism context case)
  (Record
   [#when (When context case)
    #some (Some context case)]))

(the .public (prism when some)
  (for_any (_ context case)
    (-> (When context case) (Some context case)
        (Prism context case)))
  [#when when
   #some some])

(with_template [,name ,type ,tag]
  [(the .public ,name
     (for_any (_ context case)
       (-> (Prism context case)
           (,type context case)))
     (.its ,tag))]

  [when When #when]
  [some Some #some]
  )

... TODO: Make this nominal type unnecessary.
(nominal.every .public (Membership one all)
  (Variant
   {#All all}
   {#One one (Membership one (-> one all))})

  (the outer
    (for_any (_ one all)
      (-> (Membership one all)
          (Or all (And one (Membership one (-> one all))))))
    (|>> nominal.reification))

  (the inner
    (for_any (_ one all)
      (-> (Or all (And one (Membership one (-> one all))))
          (Membership one all)))
    (|>> nominal.abstraction))

  (the .public membership_functor
    (for_any (_ one)
      (Functor (Membership one)))
    (implementation
     (the (each value it)
       (nominal.abstraction
        (.when (nominal.reification it)
          {#All all}
          {#All (value all)}
          
          {#One one next}
          {#One one (each (function (_ before)
                            (|>> before
                                 value))
                          next)}))
       )))

  (every .public (Apply context)
    (Interface
     (is (Functor context)
         functor)
     (is (for_any (_ it)
           (-> it
               (context it)))
         pure)
     (is (for_any (_ it it')
           (-> (context (-> it it'))
               (-> (context it)
                   (context it'))))
         with)))

  (the .public membership_apply
    (for_any (_ one)
      (Apply (Membership one)))
    (implementation
     (the functor ..membership_functor)
     (the pure (|>> {#All} nominal.abstraction))
     (the (with effect cause)
       (.when (nominal.reification effect)
         {#All effect}
         (by ..membership_functor each effect cause)
         
         {#One one effect}
         (nominal.abstraction
          {#One one (with (by ..membership_functor each function.flipped effect)
                      cause)})))))

  (the .public (one it)
    (for_any (_ it)
      (-> it
          (Membership it it)))
    (nominal.abstraction {#One it (nominal.abstraction {#All (|>>)})}))

  (the .public (all it)
    (for_any (_ one all)
      (-> (Membership one all)
          all))
    (.when (nominal.reification it)
      {#All it}
      it
      
      {#One one next}
      ((all next) one))
    ))

(every .public (Member all one)
  (-> all
      (Membership one all)))

(every .public (Optic it cause effect cause' effect')
  (-> (it cause effect)
      (it cause' effect')))

(every .public (Property cause effect cause' effect')
  (for_any (_ it)
    (-> [(pro.Functor it) (pro.Cartesian it)]
        (Optic it cause effect cause' effect'))))

(the .public pro_functor_of_lens
  (for_any (_ cause effect)
    (pro.Functor (Lens cause effect)))
  (implementation
   (the (each before after [/#its /#has])
     (..lens (|>> before
                  /#its)
             (|>> (product.then function.identity before)
                  /#has
                  after)))))

(the .public cartesian_of_lens
  (for_any (_ cause effect)
    (pro.Cartesian (Lens cause effect)))
  (implementation
   (the (in_left [/#its /#has])
     (..lens (|>> product.left
                  /#its)
             (product.forked (|>> (product.then function.identity product.left)
                                  /#has)
                             (|>> product.right
                                  product.right))))
   (the (in_right [/#its /#has])
     (..lens (|>> product.right
                  /#its)
             (product.forked (|>> product.right
                                  product.left)
                             (|>> (product.then function.identity product.right)
                                  /#has))))))

(the .public (as_property [/#its /#has]
                          [pro_functor cartesian])
  (for_any (_ cause effect cause' effect')
    (-> (Lens cause effect cause' effect')
        (Property cause effect cause' effect')))
  (<| (.with pro_functor)
      (.with cartesian)
      (|>> in_left
           (each (product.forked /#its function.identity) /#has))))

(the .public (as_lens it)
  (for_any (_ cause effect cause' effect')
    (-> (Property cause effect cause' effect' (Lens cause effect))
        (Lens cause effect cause' effect')))
  (it [..pro_functor_of_lens ..cartesian_of_lens]
      (..lens function.identity product.left)))
