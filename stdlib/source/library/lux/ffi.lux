... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except Alias Global Declaration Pattern Integer
                global function type_of undefined alias the)
   [abstract
    ["<>" projection (.use "[1]:[0]" monad)]
    ["[0]" monad]]
   [control
    ["[0]" io]
    ["[0]" maybe (.use "[1]:[0]" functor)]]
   [error
    ["[0]" try (.only Try)]]
   [data
    ["[0]" product]
    ["[0]" text (.only)
     ["%" \\injection]]
    [collection
     ["[0]" list (.use "[1]:[0]" monoid monad)
      ["?[1]" \\projection]]]]
   ["[0]" macro (.only with_names)
    ["[0]" syntax]
    ["[0]" template]
    ["[0]" expansion]]
   [type (.only sharing)
    ["[0]" nominal]]
   ["[0]" meta (.only)
    ["[0]" provenance]
    ["[0]" code (.only)
     ["<[1]>" \\projection (.only Projection)]]]
   [target
    ["[0]" js]
    ["[0]" python]]
   [compiler
    [arity (.only Arity)]
    [reference (.only Reference)
     [register (.only Register)]]
    [language
     [lux
      ["[0]" analysis
       ["[1]/[0]" simple]
       [complex (.only Complex)]
       [pattern (.only Pattern)]]
      ["[0]" synthesis
       ["[1]/[0]" simple]
       [access (.only Access)
        [side (.only Side)]
        ["[1]/[0]" member]]]]]]]])

(for .js (these (every (Analysis_Branch it)
                  [Pattern it])

                (every (Analysis_Match it)
                  [(Analysis_Branch it) (List (Analysis_Branch it))])

                (every (Environment it)
                  (List it))

                (every (Extension it)
                  [.Name (List it)])

                (expansion.let [@ ($ (Analysis~' $))]
                  (every (Analysis~' $)
                    (Or analysis/simple.Simple
                        (Complex @)
                        Reference
                        [@ (Analysis_Match @)]
                        [(Environment @) @]
                        [@ @]
                        (Extension @))))

                (every Analysis~
                  (Annotated Provenance
                             (Analysis~' (Annotated Provenance))))

                (.the extension_analysis
                  (template.macro (_ <name> <parameter>)
                    [(is Analysis~
                         [provenance.dummy {5 1b [<name> <parameter>]}])]))

                (.the text_analysis
                  (template.macro (_ <it>)
                    [(is Analysis~
                         [provenance.dummy {0b {5 1b <it>}}])]))

                (.the analysis
                  (template.macro (_ <name> <bindings> <projection> <inputs> <body>)
                    [(.the .public <name>
                       (<| (as (-> Any .Analysis))
                           (.function (_ phase archive inputs))
                           (.function (_ state))
                           (let [<bindings> [phase archive state]]
                             (when (?list.value inputs <projection>)
                               {try.:Success <inputs>}
                               <body>

                               {try.:Failure error}
                               {try.:Failure (text "Invalid inputs for extension..."
                                                   text.\n error)}))))]))

                (every (Synthesis_Road value next)
                  [value next])

                (every (Synthesis_Fork value next)
                  [(Synthesis_Road value next)
                   (List (Synthesis_Road value next))])

                (every (Synthesis_Path s)
                  (Or Any
                      Register
                      Access
                      [Bit (Synthesis_Path s) (Maybe (Synthesis_Path s))]
                      (Synthesis_Fork I64 (Synthesis_Path s))
                      (Synthesis_Fork Decimal (Synthesis_Path s))
                      (Synthesis_Fork Text (Synthesis_Path s))
                      [(Synthesis_Path s) (Synthesis_Path s)]
                      [(Synthesis_Path s) (Synthesis_Path s)]
                      s))

                (every (Synthesis_Abstraction s)
                  [(Environment s) Arity s])

                (every (Synthesis_Reification s)
                  [s (List s)])

                (every (Synthesis_Function s)
                  (Or (Synthesis_Abstraction s)
                      (Synthesis_Reification s)))

                (every (Synthesis_Branch s)
                  (Or [s s]
                      [s Register s]
                      [s s s]
                      [(List synthesis/member.Member) s]
                      [s (Synthesis_Path s)]))

                (every (Synthesis_Scope s)
                  [Register (List s) s])

                (every (Synthesis_Loop s)
                  (Or (Synthesis_Scope s)
                      (List s)))

                (every (Synthesis_Control s)
                  (Or (Synthesis_Branch s)
                      (Synthesis_Loop s)
                      (Synthesis_Function s)))

                (expansion.let [@ ($ (Synthesis~' $))]
                  (every (Synthesis~' $)
                    (Or synthesis/simple.Simple
                        (Complex @)
                        Reference
                        (Synthesis_Control @)
                        (Extension @))))

                (every Synthesis~
                  (Annotated Provenance
                             (Synthesis~' (Annotated Provenance))))

                (.the text_synthesis
                  (template.macro (_ <@> <it>)
                    [[<@> {0b {2 1b <it>}}]]))

                (.the .public invalid_inputs_for_extension
                  Error
                  (provenance.with (provenance.here)
                    "Invalid inputs for extension."))

                (syntax.the (translation [<name> ?list.any
                                          <bindings> ?list.any
                                          <inputs> (<>.or <code>.local
                                                          ?list.any)
                                          <body> ?list.any])
                  (with_names ['_ 'phase 'archive 'inputs 'state]
                    (pure (list (` (.the .public (, <name>)
                                     (<| (as (-> Any .Translation))
                                         (.function ((, '_) (, 'phase) (, 'archive) (, 'inputs)))
                                         (.function ((, '_) (, 'state)))
                                         (let [(, <bindings>) [(, 'phase) (, 'archive) (, 'state)]]
                                           (, (when <inputs>
                                                {.:Left <inputs>}
                                                (` (when (is (List Synthesis~) (, 'inputs))
                                                     (, (code.local <inputs>))
                                                     (, <body>)))
                                                
                                                {.:Right <inputs>}
                                                (` (when (is (List Synthesis~) (, 'inputs))
                                                     (, <inputs>)
                                                     (, <body>)

                                                     (, '_)
                                                     {try.:Failure ..invalid_inputs_for_extension}))))))))))))

                (translation undefined?|translation
                  [phase archive state]
                  (list it)
                  (monad.let try.monad
                    [.let [phase (sharing [archive it state]
                                   (is [archive it state]
                                       [archive it state])
                                   (is (-> archive it state
                                           (Try [state js.Expression]))
                                       (as_expected phase)))]
                     [state it] (phase archive it state)]
                    (pure [state (js.= js.undefined it)])))

                (analysis undefined?|analysis
                  [phase archive state]
                  ?list.any
                  it
                  (monad.let try.monad
                    [.let [phase (sharing [archive state]
                                   (is [archive state]
                                       [archive state])
                                   (is (-> archive Code state
                                           (Try [state Analysis~]))
                                       (as_expected phase)))]
                     [state it] (phase archive (` (.is .Any (, it))) state)]
                    (pure [state (extension_analysis (name ..undefined?|translation)
                                                     (list it))])))

                (.the .public undefined?
                  (template.macro (undefined? <it>)
                    [(.as (-> Any .Bit)
                          (..undefined?|analysis <it>))]))

                (translation undefined|translation
                  [phase archive state]
                  (list)
                  {try.:Success [state js.undefined]})

                (analysis undefined|analysis
                  [phase archive state]
                  (<>:pure [])
                  _
                  {try.:Success [state (extension_analysis (name ..undefined|translation)
                                                           (list))]})

                (.the .public undefined
                  (template.macro (_)
                    [(.is ..Undefined
                          (..undefined|analysis))]))

                (.the (pairs it)
                  (for_any (_ it)
                    (-> (List it)
                        (List [it it])))
                  (when (list.split 2 it)
                    [(list left right) tail]
                    (list:composite (list [left right])
                                    (pairs tail))
                    
                    [(list) (list)]
                    (list)

                    _
                    (.undefined)))

                (translation object|translation
                  [phase archive state]
                  it
                  (monad.let [! try.monad]
                    [.let [phase (sharing [archive state]
                                   (is [archive state]
                                       [archive state])
                                   (is (-> archive Synthesis~ state
                                           (Try [state js.Expression]))
                                       (as_expected phase)))]
                     [state output] (list.mix' !
                                               (.function (_ [key value] [state output])
                                                 (when key
                                                   (text_synthesis @ key)
                                                   (monad.let try.monad
                                                     [[state value] (phase archive value state)]
                                                     (pure [state (list:composite (list [key value])
                                                                                  output)]))
                                                   
                                                   _
                                                   (.undefined)))
                                               [state (is (List [Text js.Expression])
                                                          (list))]
                                               (pairs it))]
                    (pure [state (js.object (list.in_reverse output))])))

                (analysis object|analysis
                  [phase archive state]
                  (<>.some (<>.and <code>.text ?list.any))
                  it
                  (monad.let [! try.monad]
                    [.let [phase (sharing [archive state]
                                   (is [archive state]
                                       [archive state])
                                   (is (-> archive Code state
                                           (Try [state Analysis~]))
                                       (as_expected phase)))]
                     [state output] (list.mix' ! (.function (_ [key value] [state output])
                                                   (monad.let !
                                                     [[state value] (phase archive (` (.is .Any (, value))) state)]
                                                     (pure [state (list:composite (list value (text_analysis key))
                                                                                  output)])))
                                               [state (is (List Analysis~)
                                                          (list))]
                                               it)]
                    (pure [state (extension_analysis (name ..object|translation)
                                                     (list.in_reverse output))])))

                (syntax.the .public (object [it (<>.some ?list.any)])
                  (pure (list (` (.as (-> Any (..Object .Any))
                                      (..object|analysis (,* it)))))))

                (translation set|translation
                  [phase archive state]
                  (list (text_synthesis @ field) value object)
                  (monad.let try.monad
                    [.let [phase (sharing [archive state]
                                   (is [archive state]
                                       [archive state])
                                   (is (-> archive Synthesis~ state
                                           (Try [state js.Expression]))
                                       (as_expected phase)))]
                     [state value] (phase archive value state)
                     [state object] (phase archive object state)]
                    (pure [state (js.set (js.its field object) value)])))

                (analysis set|analysis
                  [phase archive state]
                  (all <>.and <code>.text ?list.any ?list.any)
                  [field value object]
                  (monad.let try.monad
                    [.let [phase (sharing [archive state]
                                   (is [archive state]
                                       [archive state])
                                   (is (-> archive Code state
                                           (Try [state Analysis~]))
                                       (as_expected phase)))]
                     [state value] (phase archive (` (.is .Any (, value))) state)
                     [state object] (phase archive (` (.is (..Object .Any) (, object))) state)]
                    (pure [state (extension_analysis (name ..set|translation)
                                                     (list (text_analysis field) value object))])))

                (syntax.the .public (set [field ?list.any
                                          value ?list.any
                                          object ?list.any])
                  (pure (list (` (.as (-> Any .Any)
                                      (..set|analysis (, field) (, value) (, object)))))))
                )
     ... else
     (these))

(expansion.let [<constant> (for .js .js_constant#
                                .python .python_constant#
                                .lua .lua_constant#
                                .ruby .ruby_constant#)
                <of> (for .js .js_of#
                          .python .python_of#
                          .lua .lua_of#
                          .ruby .ruby_of#)
                <new> (for .js .js_object_new#
                           .python .python_of#
                           (these))
                <do> (for .js .js_object_do#
                          .python .python_object_do#
                          .lua .lua_object_do#
                          .ruby .ruby_object_do#)
                <get> (for .js .js_object_get#
                           .python .python_object_get#
                           .lua .lua_object_get#
                           .ruby .ruby_object_get#
                           (these))
                <set> (for .lua .lua_object_set#
                           .ruby .ruby_object_set#
                           (these))
                <import> (for .python .python_import#
                              .lua .lua_import#
                              .ruby .ruby_import#
                              (these))
                <function> (for .js .js_function#
                                .python .python_function#
                                .lua .lua_function#
                                (these))]
  (these (nominal.every .public (Object it) Any)

         (expansion.let [<un_common> (for .js (these [Symbol]
                                                     [Null]
                                                     [Undefined])
                                          .python (these [None]
                                                         [Dict])
                                          .lua (these [Nil]
                                                      [Table])
                                          .ruby (these [Nil]))
                         <un_common> <un_common>]
           (template.with [<name>]
             [(expansion.let [<it> (template.name [<name> "'"])]
                (nominal.every <it>
                  Any
                  
                  (every .public <name>
                    (Object <it>))))]

             [[Function]
              <un_common>]))

         (expansion.let [<un_common> (for .js (these [Number Decimal])
                                          .python (these [Integer .Integer]
                                                         [Float Decimal])
                                          .lua (these [Integer .Integer]
                                                      [Float Decimal])
                                          .ruby (these [Integer .Integer]
                                                       [Float Decimal]))
                         <un_common> <un_common>]
           (template.with [<name> <type>]
             [(every .public <name>
                <type>)]

             [[Boolean Bit]
              [String  Text]
              <un_common>]))

         (every Alias
           (Maybe Text))

         (.the alias
           (Projection Alias)
           (<>.maybe (<>.after (<code>.this (' "as")) <code>.local)))

         (`` (`` (every Optional
                   (Record
                    [:optional? Bit
                     (,, (for .lua (,, (these :multiple? Bit))
                              (,, (these))))
                     :mandatory Code]))))

         (`` (`` (.the optional
                   (Projection Optional)
                   (let [token_for_optional? "?"
                         token_for_multiple? "multiple"]
                     (<| (<>.and (<>.parses? (<code>.this_text token_for_optional?)))
                         (<>.after (<>.not (<code>.this_text token_for_optional?)))

                         (,, (for .lua (,, (these (<>.and (<>.parses? (<code>.this_text token_for_multiple?)))
                                                  (<>.after (<>.not (<code>.this_text token_for_multiple?)))))
                                  (,, (these))))
                         
                         ?list.any)))))

         (every (Named it)
           (Record
            [:name Text
             :alias Alias
             :anonymous it]))

         (template.with [<case> <name>]
           [(.the <case>
              (for_any (_ it)
                (-> (Projection it)
                    (Projection (Named it))))
              (|>> (all <>.and
                        <name>
                        ..alias
                        )))]

           [[named <code>.local]
            [anonymous (<>:pure "")]])

         (every Output
           Optional)

         (.the output
           (Projection Output)
           ..optional)

         (every Global
           (Named Output))

         (.the variables
           (Projection (List Text))
           (<>.else (list) (<code>.tuple (<>.some <code>.local))))

         (.the (generalized $ it)
           (for_any (_ it)
             (-> (-> (List Text) it it)
                 (-> (Projection it) (Projection it))))
           (monad.let <>.monad
             [variables ..variables
              it it]
             (pure ($ variables it))))

         (every Input
           (Record
            [:variables (List Text)
             :parameters (List Optional)
             :io? Bit
             :try? Bit]))

         (.the input
           (Projection Input)
           (all <>.and
                (<>:pure (list))
                (<code>.tuple (<>.some ..optional))
                (<>.parses? (<code>.this_text "io"))
                (<>.parses? (<code>.this_text "try"))))

         (every Constructor
           (Named Input))

         (.the constructor
           (Projection Constructor)
           (<| <code>.form
               (..generalized (has [:anonymous :variables]))
               (<>.after (<code>.this (' new)))
               (..anonymous ..input)))

         (every (Member it)
           (Record
            [:static? Bit
             :member it]))

         (.the static!
           (Projection Any)
           (<code>.this_text "static"))

         (.the (member it)
           (for_any (_ it)
             (-> (Projection it)
                 (Projection (Member it))))
           (monad.let [! <>.monad]
             [static? (<>.parses? ..static!)]
             (by ! each
                 (|>> [:static? static?
                       :member])
                 it)))

         (every Field
           (Member (Named Output)))

         (.the field
           (Projection Field)
           (<| <code>.form
               ..member
               ..named
               ..output))

         (every Procedure
           (Record
            [:input Input
             :output Optional]))

         (.the procedure
           (Projection (Named Procedure))
           (<| (..generalized (has [:anonymous :input :variables]))
               ..named
               (all <>.and
                    ..input
                    ..optional
                    )))

         (every Method
           (Member (Named Procedure)))

         (.the method
           (Projection Method)
           (<| <code>.form
               ..member
               ..procedure))

         (`` (`` (every Sub
                   (Variant
                    (,, (for .lua (,, (these))
                             .ruby (,, (these))
                             {:Constructor Constructor}))
                    {:Field Field}
                    {:Method Method}))))

         (`` (`` (.the sub
                   (Projection Sub)
                   (all <>.or
                        (,, (for .lua (,, (these))
                                 .ruby (,, (these))
                                 ..constructor))
                        ..field
                        ..method
                        ))))

         (.the parameters
           (-> (Change (List Optional)))
           (|>> list.enumeration
                (list:each (.function (_ [idx it])
                             (has :mandatory (|> idx %.natural code.local) it)))))

         (.the (output_type it)
           (-> Optional
               Code)
           (if (its :optional? it)
               (` (.Maybe (, (its :mandatory it))))
               (its :mandatory it)))

         (`` (template.with [<lux_it> <host_it>
                             <lux_?> <host_?>]
               [(.the .public (<lux_it> _)
                  (-> Any
                      Nothing)
                  (as_expected (<host_it>)))

                (.the .public <lux_?>
                  (-> Any
                      Bit)
                  (|>> <host_?>))

                (template.with_locals ['it]
                  (these (.the 'it' (' 'it))
                         (.the (host_optional it)
                           (-> Optional
                               Code)
                           (.if (.its :optional? it)
                                (` (.when (, (its :mandatory it))
                                     {.:Some (, 'it')}
                                     (, 'it')

                                     {.:None}
                                     (<host_it>)))
                                (its :mandatory it)))

                         (`` (.the (lux_optional it output)
                               (-> Optional
                                   (Change Code))
                               (,, (for .lua
                                        (` (.let [(, 'it') (, (if (its :multiple? it)
                                                                  (` (<of> (<constant> "table.pack") [(, output)]))
                                                                  output))]
                                             (, (if (its :optional? it)
                                                    (` (.if (not (<host_?> (, 'it')))
                                                            {.:Some (, 'it')}
                                                            {.:None}))
                                                    (` (.if (.not (<host_?> (, 'it')))
                                                            (, 'it')
                                                            (.halt! "Invalid output.")))))))

                                        ... by default
                                        (` (.let [(, 'it') (, output)]
                                             (, (if (its :optional? it)
                                                    (` (.if (not (<host_?> (, 'it')))
                                                            {.:Some (, 'it')}
                                                            {.:None}))
                                                    (` (.if (.not (<host_?> (, 'it')))
                                                            (, 'it')
                                                            (.halt! "Invalid output.")))))))))))))]

               [(,, (for .js [null .js_object_null#
                              null? .js_object_null?#]
                         .python [none .python_object_none#
                                  none? .python_object_none?#]
                         .lua [nil .lua_object_nil#
                               nil? .lua_object_nil?#]
                         .ruby [nil .ruby_object_nil#
                                nil? .ruby_object_nil?#]))]
               ))

         (every Declaration
           [Text (List Text)])

         (every Namespace
           Text)

         (every Class
           (Record
            [:declaration Declaration
             :class_alias Alias
             :namespace Namespace
             :members (List Sub)]))

         (.the class
           (Projection Class)
           (all <>.and
                (<>.either (<>.and <code>.local
                                   (<>:pure (list)))
                           (<code>.form (<>.and <code>.local
                                                (<>.some <code>.local))))
                ..alias
                <code>.text
                (<>.some ..sub)))

         (every Import
           (Variant
            {:Class Class}
            {:Procedure (Named Procedure)}
            {:Global Global}))

         (.the importP
           (Projection Import)
           (all <>.or
                ..class
                (<code>.form ..procedure)
                (<code>.form (..named ..output))))

         (.the (input_type input :it:)
           (-> Input Code
               Code)
           (let [:it: (if (its :try? input)
                          (` (Try (, :it:)))
                          :it:)]
             (if (its :io? input)
                 (` (io.IO (, :it:)))
                 :it:)))

         (.the (input_term input term)
           (-> Input Code
               Code)
           (let [term (if (its :try? input)
                          (` (.try (, term)))
                          term)]
             (if (its :io? input)
                 (` (io.io (, term)))
                 term)))

         (.the (procedure_definition import! source it)
           (-> (List Code) Code (Named Procedure)
               Code)
           (let ['it (|> (its :alias it)
                         (maybe.else (its :name it))
                         code.local)
                 'variables (list:each code.local (its [:anonymous :input :variables] it))
                 input (its [:anonymous :input] it)
                 :parameters: (its :parameters input)
                 'parameters (..parameters :parameters:)
                 :output: (its [:anonymous :output] it)
                 :input:/* (when :parameters:
                             (list)
                             (list (` []))
                             
                             not_empty!
                             (list:each ..output_type :parameters:))

                 type_of_return (|>> ..output_type
                                     (..input_type input))
                 type_of_any_return (|>> (has :mandatory (` .Any))
                                         type_of_return)]
             (` (.the ((, 'it) [(,* (list:each (its :mandatory) 'parameters))])
                  (.for_any ((, 'it) (,* 'variables))
                    (-> [(,* :input:/*)]
                        (, (type_of_return :output:))))
                  (.exec
                    (,* import!)
                    (.as (.for_any ((, 'it) (,* 'variables))
                           (-> (, (type_of_any_return :output:))
                               (, (type_of_return :output:))))
                         (, (<| (..input_term input)
                                (..lux_optional :output:)
                                (` (<of> (.as_expected (, source))
                                         [(,* (list:each ..host_optional 'parameters))]))))))))))

         (.the (namespaced namespace host_module class alias member)
           (-> Namespace Text Text Alias Text
               Text)
           (|> namespace
               (text.replaced "[2]" host_module)
               (text.replaced "[1]" (maybe.else class alias))
               (text.replaced "[0]" member)))

         ... https://en.wikipedia.org/wiki/Delimiter
         (.the class_delimiter ".")

         (.the host_path
           (text.replaced .module_delimiter ..class_delimiter))

         (for .js (these)
              (.the (imported class)
                (-> Text
                    Code)
                (for .python
                     (` (<import> (, (code.text (text.replaced .module_delimiter "." class)))))
                     
                     ... else
                     (when (list.split 1 (text.all_split_by .module_delimiter class))
                       [(list head) tail]
                       (list.mix (.function (_ sub super)
                                   (` (<get> (, (code.text sub))
                                             (.as (-> Any (..Object .Any))
                                                  (, super)))))
                                 (` (<import> (, (code.text head))))
                                 tail)
                       
                       else
                       (` (<import> (, (code.text class))))))))

         (.the (global_definition import! it)
           (-> (List Code) Global
               Code)
           (let ['name (|> (its :alias it)
                           (maybe.else (its :name it))
                           code.local)
                 :output: (its :anonymous it)]
             (` (.the (, 'name)
                  (, (..output_type :output:))
                  (.exec
                    (,* import!)
                    (.as_expected
                     (, (<| (lux_optional :output:)
                            (` (<constant> (, (code.text (..host_path (its :name it))))))))))))))
         
         (for .lua (these)
              .ruby (these)
              (.the (constructor_definition host_module [class_name class_parameters] alias namespace it)
                (-> Text Declaration Alias Namespace Constructor
                    Code)
                (let ['it (|> it
                              (its :alias)
                              (maybe.else "new")
                              (..namespaced namespace host_module class_name alias)
                              code.local)
                      input (its :anonymous it)
                      'input_variables (list:each code.local (its :variables input))
                      :parameters: (its :parameters input)
                      'parameters (..parameters :parameters:)
                      'class_variables (list:each code.local class_parameters)
                      'class (` ((, (code.local (maybe.else class_name alias))) (,* 'class_variables)))
                      :output: [:optional? false :mandatory 'class]
                      unquantified_type (` (.-> [(,* (list:each ..output_type :parameters:))]
                                                (, (|> :output:
                                                       ..output_type
                                                       (..input_type input)))))
                      quantified_type (when (list:composite 'class_variables 'input_variables)
                                        (list)
                                        unquantified_type

                                        _
                                        (` (.for_any ((, 'it) (,* 'class_variables) (,* 'input_variables))
                                             (, unquantified_type))))]
                  (` (.the ((, 'it) [(,* (list:each (its :mandatory) 'parameters))])
                       (, quantified_type)
                       (.as_expected
                        (, (<| (..input_term input)
                               (..lux_optional :output:)
                               (` (<new> (, (for .js (` (<constant> (, (code.text (..host_path class_name)))))
                                                 .python (` (.as (-> Any ..Function)
                                                                 (, (..imported class_name))))))
                                         [(,* (list:each ..host_optional 'parameters))]))))))))))

         (.the (optional_value value)
           (-> Code
               (Change Optional))
           (has :mandatory value))
         
         (.the (static_field_definition import! host_module [class_name class_parameters] alias namespace it)
           (-> (List Code) Text Declaration Alias Namespace (Named Output)
               Code)
           (let [field (its :name it)
                 'it (|> (its :alias it)
                         (maybe.else field)
                         (..namespaced namespace host_module class_name alias)
                         code.local)
                 :field: (its :anonymous it)
                 get (` (.as (-> Any (io.IO (, (..output_type :field:))))
                             (io.io (, (<| (lux_optional :field:)
                                           (for .js (` (<constant> (, (code.text (text (..host_path class_name) "." field)))))
                                                .ruby (` (<constant> (, (code.text (text (..host_path class_name) ":" field)))))
                                                ... else
                                                (` (<get> (, (code.text field))
                                                          (, (..imported class_name))))))))))
                 set (let ['value_to_set (host_optional (optional_value (` ((,' ,) (, 'it))) :field:))]
                       (` (.as (-> Any (io.IO .Any))
                               (io.io (, (for .js (` (..set (, (code.text field))
                                                            (, 'value_to_set)
                                                            (.as (-> Any (..Object .Any))
                                                                 (<constant> (, (code.text (..host_path class_name)))))))
                                              .ruby (` (<set> (, (code.text field))
                                                              (, 'value_to_set)
                                                              (<constant> (, (code.text (..host_path class_name))))))
                                              .python (` (<of> (<constant> "setattr")
                                                               [(, (..imported class_name))
                                                                (, (code.text field))
                                                                (, 'value_to_set)]))
                                              ... else
                                              (` (<set> (, (code.text field))
                                                        (, 'value_to_set)
                                                        (, (..imported class_name))))))))))]
             (` (syntax.the ((, 'it) [(, 'it) (<>.maybe ?list.any)])
                  (.by meta.monad (,' pure)
                       (.list (`' (.exec
                                    (,* import!)
                                    ((,' ,) (when (, 'it)
                                              {.:None}
                                              (`' (, get))

                                              {.:Some (, 'it)}
                                              (`' (, set))))))))))))

         (.the (virtual_field_definition host_module [class_name class_parameters] alias namespace it)
           (-> Text Declaration Alias Namespace (Named Output)
               Code)
           (let [name (its :name it)
                 'it (|> (its :alias it)
                         (maybe.else name)
                         (..namespaced namespace host_module class_name alias)
                         code.local)
                 path (text (..host_path class_name) "." name)
                 :field: (its :anonymous it)
                 'variables (list:each code.local class_parameters)
                 'class (` ((, (code.local (maybe.else class_name alias))) (,* 'variables)))]
             (` (.the ((, 'it) (, 'it))
                  (.for_any ((, 'it) (,* 'variables))
                    (.-> (, 'class)
                         (, (..output_type :field:))))
                  (.as_expected
                   (, (<| (lux_optional :field:)
                          (` (<get> (, (code.text name)) (, 'it))))))))))

         (.the (field_definition import! host_module class alias namespace it)
           (-> (List Code) Text Declaration Alias Namespace Field
               Code)
           (if (its :static? it)
               (..static_field_definition import! host_module class alias namespace (its :member it))
               (..virtual_field_definition host_module class alias namespace (its :member it))))

         (.the (static_method_definition import! host_module [class_name class_parameters] alias namespace it)
           (-> (List Code) Text Declaration Alias Namespace (Named Procedure)
               Code)
           (let [method (its :name it)
                 name (|> (its :alias it)
                          (maybe.else (its :name it))
                          (..namespaced namespace host_module class_name alias))]
             (|> it
                 (has :alias {.:Some name})
                 (..procedure_definition import!
                                         (for .js (` (<constant> (, (code.text (text (..host_path class_name) "." method)))))
                                              .ruby (` (<constant> (, (code.text (text (..host_path class_name) ":" method)))))
                                              (` (<get> (, (code.text method))
                                                        (.as (-> Any (..Object .Any))
                                                             (, (..imported class_name))))))))))

         (.the (virtual_method_definition host_module [class_name class_parameters] alias namespace it)
           (-> Text Declaration Alias Namespace (Named Procedure)
               Code)
           (let [method (its :name it)
                 'it (|> (its :alias it)
                         (maybe.else method)
                         (..namespaced namespace host_module class_name alias)
                         code.local)
                 procedure (its :anonymous it)
                 input (its :input procedure)
                 'input_variables (list:each code.local (its :variables input))
                 :parameters: (its :parameters input)
                 'parameters (..parameters :parameters:)
                 'class_variables (list:each code.local class_parameters)
                 'class (` ((, (code.local (maybe.else class_name alias))) (,* 'class_variables)))
                 :output: (its :output procedure)

                 type_of_return (|>> ..output_type
                                     (..input_type input))
                 type_of_any_return (|>> (has :mandatory (` .Any))
                                         type_of_return)]
             (` (.the ((, 'it) [(,* (list:each (its :mandatory) 'parameters))] (, 'it))
                  (.for_any ((, 'it) (,* 'class_variables) (,* 'input_variables))
                    (.-> [(,* (list:each ..output_type :parameters:))]
                         (, 'class)
                         (, (type_of_return :output:))))
                  (.as (.for_any ((, 'it) (,* 'class_variables) (,* 'input_variables))
                         (-> (, (type_of_any_return :output:))
                             (, (type_of_return :output:))))
                       (, (<| (..input_term input)
                              (..lux_optional :output:)
                              (` (<do> (, (code.text method))
                                       (, 'it)
                                       [(,* (list:each ..host_optional 'parameters))])))))))))

         (.the (method_definition import! host_module class alias namespace it)
           (-> (List Code) Text Declaration Alias Namespace Method
               Code)
           (if (its :static? it)
               (static_method_definition import! host_module class alias namespace (its :member it))
               (virtual_method_definition host_module class alias namespace (its :member it))))

         (syntax.the .public (the [host_module (<>.else "" <code>.text)
                                   it ..importP])
           (let [host_module_import! (is (List Code)
                                         (when host_module
                                           ""
                                           (list)

                                           _
                                           (list (` (<import> (, (code.text host_module)))))))]
             (when it
               {:Global it}
               (pure (list (..global_definition host_module_import! it)))

               {:Procedure it}
               (pure (list (..procedure_definition host_module_import!
                                                   (` (<constant> (, (code.text (..host_path (its :name it))))))
                                                   it)))

               {:Class it}
               (let [class (its :declaration it)
                     alias (its :class_alias it)
                     [class_name class_parameters] class
                     namespace (its :namespace it)
                     'class_variables (list:each code.local class_parameters)
                     declaration (` ((, (code.local (maybe.else class_name alias)))
                                     (,* 'class_variables)))]
                 (pure (list (` (these (.every (, declaration)
                                         (..Object (.Nominal (, (code.text (..host_path class_name)))
                                                             [(,* (list:each (|>> (list (code.bit .co_variant))
                                                                                  code.tuple)
                                                                             'class_variables))])))
                                       (,* (list:each (.function (_ member)
                                                        (`` (`` (when member
                                                                  (,, (for .lua (,, (these))
                                                                           .ruby (,, (these))
                                                                           (,, (these {:Constructor it}
                                                                                      (..constructor_definition host_module class alias namespace it)))))
                                                                  
                                                                  {:Field it}
                                                                  (..field_definition host_module_import! host_module class alias namespace it)
                                                                  
                                                                  {:Method it}
                                                                  (..method_definition host_module_import! host_module class alias namespace it)))))
                                                      (its :members it))))))))
               )))

         (for .ruby (these)
              (syntax.the .public (function [[self inputs] (<code>.form
                                                            (all <>.and
                                                                 <code>.local
                                                                 (<code>.tuple (<>.some (<>.and ?list.any ?list.any)))))
                                             type ?list.any
                                             term ?list.any])
                (pure (list (` (.<| (.as (-> Any ..Function))
                                    (<function> (, (code.natural (list.size inputs))))
                                    (.as (-> (.-> [(,* (list:each product.right inputs))]
                                                  (, type))
                                             (.-> [(,* (list.repeated (list.size inputs) (` .Any)))]
                                                  .Any)))
                                    (.function ((, (code.local self)) [(,* (list:each product.left inputs))])
                                      (, term))))))))

         (for .js
              (these (.the .public type_of
                       (template.macro (type_of object)
                         [(.js_type_of# object)]))

                     (syntax.the .public (global [type ?list.any
                                                  [head next,tail] (<code>.tuple (<>.and <code>.local (<>.maybe (<>.and <code>.local (<>.some <code>.local)))))])
                       (with_names ['_]
                         (let [global (` (.js_constant# (, (code.text head))))]
                           (when next,tail
                             {.:None}
                             (pure (list (` (is (.Maybe (, type))
                                                (when (..type_of (, global))
                                                  "undefined"
                                                  {.:None}

                                                  (, '_)
                                                  {.:Some (as (-> Any (, type)) (, global))})))))
                             
                             {.:Some [next tail]}
                             (let [delimiter "."]
                               (pure (list (` (is (.Maybe (, type))
                                                  (when (..type_of (, global))
                                                    "undefined"
                                                    {.:None}

                                                    (, '_)
                                                    (..global (, type) [(, (code.local (text head delimiter next)))
                                                                        (,* (list:each code.local tail))])))))))))))

                     (.the !defined?
                       (template.macro (_ <global>)
                         [(.when (..global Any <global>)
                            {.:None}
                            .false

                            {.:Some _}
                            .true)]))

                     (template.with [<name> <global>]
                       [(.the .public <name>
                          Bit
                          (!defined? <global>))]

                       [[on_browser? [window]]
                        [on_nashorn? [java lang Object]]])

                     (.the .public on_node_js?
                       Bit
                       (|> (..global (Object Any) [process])
                           (maybe:each (|>> []
                                            (.js_of# (.js_constant# "Object.prototype.toString.call"))
                                            (as (-> Any Text))
                                            (text.= "[object process]")))
                           (maybe.else false))))

              ... else
              (these (syntax.the .public (global [type ?list.any
                                                  [head next,tail] (<code>.tuple (<>.and <code>.local (<>.maybe (<>.and <code>.local (<>.some <code>.local)))))])
                       (let [global (` (<constant> (, (code.text head))))]
                         (pure (list (when next,tail
                                       {.:None}
                                       (` (as (-> Any (, type))
                                              (, global)))
                                       
                                       {.:Some [next tail]}
                                       (let [delimiter "."]
                                         (` (..global (, type) [(, (code.local (text head delimiter next)))
                                                                (,* (list:each code.local tail))])))))))))))
  )
