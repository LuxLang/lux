... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except Alias Global Declaration Pattern Integer
                global function type_of undefined alias)
   [abstract
    ["[0]" monad (.only do)]]
   [control
    ["<>" projection (.use "[1]#[0]" monad)]
    ["[0]" io]
    ["[0]" maybe (.use "[1]#[0]" functor)]
    ["[0]" try (.only Try)]]
   [data
    ["[0]" product]
    ["[0]" text (.only)
     ["%" \\injection]]
    [collection
     ["[0]" list (.use "[1]#[0]" monoid monad mix)]]]
   ["[0]" meta (.only)
    ["[0]" location]
    ["[0]" code (.only)
     ["<[1]>" \\projection (.only Projection)]]
    ["[0]" macro (.only with_names)
     ["[0]" syntax]
     ["[0]" template]
     ["[0]" expansion]]
    [type (.only sharing)
     ["[0]" nominal]]
    [compiler
     [target
      ["[0]" js]
      ["[0]" python]]
     [arity (.only Arity)]
     [reference (.only Reference)
      [register (.only Register)]]
     [language
      [lux
       ["[0]" analysis
        ["[1]/[0]" simple]
        [complex (.only Complex)]
        [pattern (.only Pattern)]]
       ["[0]" synthesis
        ["[1]/[0]" simple]
        [access (.only Access)
         [side (.only Side)]
         ["[1]/[0]" member]]]]]]]]])

(for .js (these (every (Analysis_Branch of)
                  [Pattern of])

                (every (Analysis_Match of)
                  [(Analysis_Branch of) (List (Analysis_Branch of))])

                (every (Environment of)
                  (List of))

                (every (Extension of)
                  [.Name (List of)])

                (expansion.let [@ ($ (Analysis~' $))]
                  (every (Analysis~' $)
                    (Or analysis/simple.Simple
                        (Complex @)
                        Reference
                        [@ (Analysis_Match @)]
                        [(Environment @) @]
                        [@ @]
                        (Extension @))))

                (every Analysis~
                  (Annotated Location
                             (Analysis~' (Annotated Location))))

                (the extension_analysis
                  (template.macro (_ <name> <parameter>)
                    [(is Analysis~
                         [location.dummy {5 #1 [<name> <parameter>]}])]))

                (the text_analysis
                  (template.macro (_ <it>)
                    [(is Analysis~
                         [location.dummy {#0 {5 #1 <it>}}])]))

                (the analysis
                  (template.macro (_ <name> <bindings> <projection> <inputs> <body>)
                    [(the .public <name>
                       (<| (as .Analysis)
                           (.function (_ phase archive inputs))
                           (.function (_ state))
                           (let [<bindings> [phase archive state]]
                             (when (<code>.value <projection> inputs)
                               {try.#Success <inputs>}
                               <body>

                               {try.#Failure error}
                               {try.#Failure (%.message "Invalid inputs for extension..."
                                                        text.\n error)}))))]))

                (every (Synthesis_Road value next)
                  [value next])

                (every (Synthesis_Fork value next)
                  [(Synthesis_Road value next)
                   (List (Synthesis_Road value next))])

                (every (Synthesis_Path s)
                  (Or Any
                      Register
                      Access
                      [Bit (Synthesis_Path s) (Maybe (Synthesis_Path s))]
                      (Synthesis_Fork I64 (Synthesis_Path s))
                      (Synthesis_Fork Decimal (Synthesis_Path s))
                      (Synthesis_Fork Text (Synthesis_Path s))
                      [(Synthesis_Path s) (Synthesis_Path s)]
                      [(Synthesis_Path s) (Synthesis_Path s)]
                      s))

                (every (Synthesis_Abstraction s)
                  [(Environment s) Arity s])

                (every (Synthesis_Reification s)
                  [s (List s)])

                (every (Synthesis_Function s)
                  (Or (Synthesis_Abstraction s)
                      (Synthesis_Reification s)))

                (every (Synthesis_Branch s)
                  (Or [s s]
                      [s Register s]
                      [s s s]
                      [(List synthesis/member.Member) s]
                      [s (Synthesis_Path s)]))

                (every (Synthesis_Scope s)
                  [Register (List s) s])

                (every (Synthesis_Loop s)
                  (Or (Synthesis_Scope s)
                      (List s)))

                (every (Synthesis_Control s)
                  (Or (Synthesis_Branch s)
                      (Synthesis_Loop s)
                      (Synthesis_Function s)))

                (expansion.let [@ ($ (Synthesis~' $))]
                  (every (Synthesis~' $)
                    (Or synthesis/simple.Simple
                        (Complex @)
                        Reference
                        (Synthesis_Control @)
                        (Extension @))))

                (every Synthesis~
                  (Annotated Location
                             (Synthesis~' (Annotated Location))))

                (the text_synthesis
                  (template.macro (_ <@> <it>)
                    [[<@> {#0 {2 #1 <it>}}]]))

                (the .public invalid_inputs_for_extension
                  Error
                  (location.with (location.here)
                    "Invalid inputs for extension."))

                (the translation
                  (syntax.macro (_ [<name> <code>.any
                                    <bindings> <code>.any
                                    <inputs> (<>.or <code>.local
                                                    <code>.any)
                                    <body> <code>.any])
                    (with_names ['_ 'phase 'archive 'inputs 'state]
                      (in (list (` (the .public (, <name>)
                                     (<| (as .Translation)
                                         (.function ((, '_) (, 'phase) (, 'archive) (, 'inputs)))
                                         (.function ((, '_) (, 'state)))
                                         (let [(, <bindings>) [(, 'phase) (, 'archive) (, 'state)]]
                                           (, (when <inputs>
                                                {.#Left <inputs>}
                                                (` (when (is (List Synthesis~) (, 'inputs))
                                                     (, (code.local <inputs>))
                                                     (, <body>)))
                                                
                                                {.#Right <inputs>}
                                                (` (when (is (List Synthesis~) (, 'inputs))
                                                     (, <inputs>)
                                                     (, <body>)

                                                     (, '_)
                                                     {try.#Failure ..invalid_inputs_for_extension})))))))))))))

                (translation undefined?|translation
                  [phase archive state]
                  (list it)
                  (do try.monad
                    [.let [phase (sharing [archive it state]
                                   (is [archive it state]
                                       [archive it state])
                                   (is (-> archive it state
                                           (Try [state js.Expression]))
                                       (as_expected phase)))]
                     [state it] (phase archive it state)]
                    (in [state (js.= js.undefined it)])))

                (analysis undefined?|analysis
                  [phase archive state]
                  <code>.any
                  it
                  (do try.monad
                    [.let [phase (sharing [archive state]
                                   (is [archive state]
                                       [archive state])
                                   (is (-> archive Code state
                                           (Try [state Analysis~]))
                                       (as_expected phase)))]
                     [state it] (phase archive (` (.is .Any (, it))) state)]
                    (in [state (extension_analysis (name ..undefined?|translation)
                                                   (list it))])))

                (the .public undefined?
                  (template.macro (undefined? <it>)
                    [(.as .Bit
                          (..undefined?|analysis <it>))]))

                (translation undefined|translation
                  [phase archive state]
                  (list)
                  {try.#Success [state js.undefined]})

                (analysis undefined|analysis
                  [phase archive state]
                  <code>.end
                  _
                  {try.#Success [state (extension_analysis (name ..undefined|translation)
                                                           (list))]})

                (the .public undefined
                  (template.macro (_)
                    [(.is ..Undefined
                          (..undefined|analysis))]))

                (the (pairs it)
                  (for_any (_ a) (-> (List a) (List [a a])))
                  (when it
                    (list.partial left right tail)
                    (list.partial [left right] (pairs tail))
                    
                    (list)
                    (list)

                    _
                    (.undefined)))

                (translation object|translation
                  [phase archive state]
                  it
                  (do [! try.monad]
                    [.let [phase (sharing [archive state]
                                   (is [archive state]
                                       [archive state])
                                   (is (-> archive Synthesis~ state
                                           (Try [state js.Expression]))
                                       (as_expected phase)))]
                     [state output] (monad.mix !
                                               (sharing [state]
                                                 (is state
                                                     state)
                                                 (is (-> [Synthesis~ Synthesis~] [state (List [Text js.Expression])]
                                                         (Try [state (List [Text js.Expression])]))
                                                     (.function (_ [key value] [state output])
                                                       (when key
                                                         (text_synthesis @ key)
                                                         (do try.monad
                                                           [[state value] (phase archive value state)]
                                                           (in [state (list.partial [key value] output)]))
                                                         
                                                         _
                                                         (.undefined)))))
                                               [state (list)]
                                               (pairs it))]
                    (in [state (js.object (list.reversed output))])))

                (analysis object|analysis
                  [phase archive state]
                  (<>.some (<>.and <code>.text <code>.any))
                  it
                  (do [! try.monad]
                    [.let [phase (sharing [archive state]
                                   (is [archive state]
                                       [archive state])
                                   (is (-> archive Code state
                                           (Try [state Analysis~]))
                                       (as_expected phase)))]
                     [state output] (monad.mix ! (.function (_ [key value] [state output])
                                                   (do !
                                                     [[state value] (phase archive (` (.is .Any (, value))) state)]
                                                     (in [state (list.partial value (text_analysis key) output)])))
                                               [state (list)]
                                               it)]
                    (in [state (extension_analysis (name ..object|translation)
                                                   (list.reversed output))])))

                (the .public object
                  (syntax.macro (_ [it (<>.some <code>.any)])
                    (in (list (` (.as (..Object .Any)
                                      (..object|analysis (,* it))))))))

                (translation set|translation
                  [phase archive state]
                  (list (text_synthesis @ field) value object)
                  (do try.monad
                    [.let [phase (sharing [archive state]
                                   (is [archive state]
                                       [archive state])
                                   (is (-> archive Synthesis~ state
                                           (Try [state js.Expression]))
                                       (as_expected phase)))]
                     [state value] (phase archive value state)
                     [state object] (phase archive object state)]
                    (in [state (js.set (js.its field object) value)])))

                (analysis set|analysis
                  [phase archive state]
                  (all <>.and <code>.text <code>.any <code>.any)
                  [field value object]
                  (do try.monad
                    [.let [phase (sharing [archive state]
                                   (is [archive state]
                                       [archive state])
                                   (is (-> archive Code state
                                           (Try [state Analysis~]))
                                       (as_expected phase)))]
                     [state value] (phase archive (` (.is .Any (, value))) state)
                     [state object] (phase archive (` (.is (..Object .Any) (, object))) state)]
                    (in [state (extension_analysis (name ..set|translation)
                                                   (list (text_analysis field) value object))])))

                (the .public set
                  (syntax.macro (_ [field <code>.any
                                    value <code>.any
                                    object <code>.any])
                    (in (list (` (.as .Any
                                      (..set|analysis (, field) (, value) (, object))))))))
                )
     ... else
     (these))

(expansion.let [<constant> (for .js .js_constant#
                                .python .python_constant#
                                .lua .lua_constant#
                                .ruby .ruby_constant#)
                <apply> (for .js .js_apply#
                             .python .python_apply#
                             .lua .lua_apply#
                             .ruby .ruby_apply#)
                <new> (for .js .js_object_new#
                           .python .python_apply#
                           (these))
                <do> (for .js .js_object_do#
                          .python .python_object_do#
                          .lua .lua_object_do#
                          .ruby .ruby_object_do#)
                <get> (for .js .js_object_get#
                           .python .python_object_get#
                           .lua .lua_object_get#
                           .ruby .ruby_object_get#
                           (these))
                <set> (for .lua .lua_object_set#
                           .ruby .ruby_object_set#
                           (these))
                <import> (for .python .python_import#
                              .lua .lua_import#
                              .ruby .ruby_import#
                              (these))
                <function> (for .js .js_function#
                                .python .python_function#
                                .lua .lua_function#
                                (these))]
  (these (nominal.every .public (Object of) Any)

         (expansion.let [<un_common> (for .js (these [Symbol]
                                                     [Null]
                                                     [Undefined])
                                          .python (these [None]
                                                         [Dict])
                                          .lua (these [Nil]
                                                      [Table])
                                          .ruby (these [Nil]))
                         <un_common> <un_common>]
           (template.with [<name>]
             [(expansion.let [<of> (template.name [<name> "'"])]
                (nominal.every <of>
                  Any
                  
                  (every .public <name>
                    (Object <of>))))]

             [Function]
             <un_common>
             ))

         (expansion.let [<un_common> (for .js (these [Number Decimal])
                                          .python (these [Integer .Integer]
                                                         [Float Decimal])
                                          .lua (these [Integer .Integer]
                                                      [Float Decimal])
                                          .ruby (these [Integer .Integer]
                                                       [Float Decimal]))
                         <un_common> <un_common>]
           (template.with [<name> <type>]
             [(every .public <name>
                <type>)]

             [Boolean Bit]
             [String  Text]
             <un_common>
             ))

         (every Alias
           (Maybe Text))

         (the alias
           (Projection Alias)
           (<>.maybe (<>.after (<code>.this (' "as")) <code>.local)))

         (every Optional
           (Record
            [#optional? Bit
             #mandatory Code]))

         (the optional
           (Projection Optional)
           (let [token "?"]
             (<| (<>.and (<>.parses? (<code>.this_text token)))
                 (<>.after (<>.not (<code>.this_text token)))
                 <code>.any)))

         (every (Named of)
           (Record
            [#name Text
             #alias Alias
             #anonymous of]))

         (template.with [<case> <name>]
           [(the <case>
              (for_any (_ of)
                (-> (Projection of)
                    (Projection (Named of))))
              (|>> (all <>.and
                        <name>
                        ..alias
                        )))]

           [named <code>.local]
           [anonymous (<>#in "")]
           )

         (every Output
           Optional)

         (the output
           (Projection Output)
           ..optional)

         (every Global
           (Named Output))

         (the variables
           (Projection (List Text))
           (<>.else (list) (<code>.tuple (<>.some <code>.local))))

         (the (generalized $ it)
           (for_any (_ of)
             (-> (-> (List Text) of of)
                 (-> (Projection of) (Projection of))))
           (do <>.monad
             [variables ..variables
              it it]
             (in ($ variables it))))

         (every Input
           (Record
            [#variables (List Text)
             #parameters (List Optional)
             #io? Bit
             #try? Bit]))

         (the input
           (Projection Input)
           (all <>.and
                (<>#in (list))
                (<code>.tuple (<>.some ..optional))
                (<>.parses? (<code>.this_text "io"))
                (<>.parses? (<code>.this_text "try"))))

         (every Constructor
           (Named Input))

         (the constructor
           (Projection Constructor)
           (<| <code>.form
               (..generalized (has [#anonymous #variables]))
               (<>.after (<code>.this (' new)))
               (..anonymous ..input)))

         (every (Member of)
           (Record
            [#static? Bit
             #member of]))

         (the static!
           (Projection Any)
           (<code>.this_text "static"))

         (the (member it)
           (for_any (_ of)
             (-> (Projection of)
                 (Projection (Member of))))
           (do [! <>.monad]
             [static? (<>.parses? ..static!)]
             (by ! each
                 (|>> [#static? static?
                       #member])
                 it)))

         (every Field
           (Member (Named Output)))

         (the field
           (Projection Field)
           (<| <code>.form
               ..member
               ..named
               ..output))

         (every Procedure
           (Record
            [#input Input
             #output Optional]))

         (the procedure
           (Projection (Named Procedure))
           (<| (..generalized (has [#anonymous #input #variables]))
               ..named
               (all <>.and
                    ..input
                    ..optional
                    )))

         (every Method
           (Member (Named Procedure)))

         (the method
           (Projection Method)
           (<| <code>.form
               ..member
               ..procedure))

         (`` (`` (every Sub
                   (Variant
                    (,, (for .lua (,, (these))
                             .ruby (,, (these))
                             {#Constructor Constructor}))
                    {#Field Field}
                    {#Method Method}))))

         (`` (`` (the sub
                   (Projection Sub)
                   (all <>.or
                        (,, (for .lua (,, (these))
                                 .ruby (,, (these))
                                 ..constructor))
                        ..field
                        ..method
                        ))))

         (the parameters
           (-> (List Optional)
               (List Optional))
           (|>> list.enumeration
                (list#each (.function (_ [idx [optional? type]])
                             [#optional? optional?
                              #mandatory (|> idx %.natural code.local)]))))

         (the (output_type it)
           (-> Optional
               Code)
           (if (its #optional? it)
             (` (.Maybe (, (its #mandatory it))))
             (its #mandatory it)))

         (`` (template.with [<lux_it> <host_it>
                             <lux_?> <host_?>]
               [(the .public (<lux_it> _)
                  (-> Any
                      Nothing)
                  (as_expected (<host_it>)))

                (the .public <lux_?>
                  (-> Any
                      Bit)
                  (|>> <host_?>))

                (template.with_locals ['it]
                  (these (the 'it' (' 'it))
                         (the (host_optional it)
                           (-> Optional
                               Code)
                           (.if (.its #optional? it)
                             (` (.when (, (its #mandatory it))
                                  {.#Some (, 'it')}
                                  (, 'it')

                                  {.#None}
                                  (<host_it>)))
                             (its #mandatory it)))

                         (the (lux_optional it output)
                           (-> Optional Code
                               Code)
                           (` (.let [(, 'it') (, output)]
                                (, (if (its #optional? it)
                                     (` (.if (<host_?> (, 'it'))
                                          {.#None}
                                          {.#Some (, 'it')}))
                                     (` (.if (.not (<host_?> (, 'it')))
                                          (, 'it')
                                          (.halt! "Invalid output."))))))))))]

               (,, (for .js [null .js_object_null#
                             null? .js_object_null?#]
                        .python [none .python_object_none#
                                 none? .python_object_none?#]
                        .lua [nil .lua_object_nil#
                              nil? .lua_object_nil?#]
                        .ruby [nil .ruby_object_nil#
                               nil? .ruby_object_nil?#]))
               ))

         (every Declaration
           [Text (List Text)])

         (every Namespace
           Text)

         (every Class
           (Record
            [#declaration Declaration
             #class_alias Alias
             #namespace Namespace
             #members (List Sub)]))

         (the class
           (Projection Class)
           (all <>.and
                (<>.either (<>.and <code>.local
                                   (<>#in (list)))
                           (<code>.form (<>.and <code>.local
                                                (<>.some <code>.local))))
                ..alias
                <code>.text
                (<>.some ..sub)))

         (every Import
           (Variant
            {#Class Class}
            {#Procedure (Named Procedure)}
            {#Global Global}))

         (the importP
           (Projection Import)
           (all <>.or
                ..class
                (<code>.form ..procedure)
                (<code>.form (..named ..output))))

         (the (input_type input :it:)
           (-> Input Code
               Code)
           (let [:it: (if (its #try? input)
                        (` (Try (, :it:)))
                        :it:)]
             (if (its #io? input)
               (` (io.IO (, :it:)))
               :it:)))

         (the (input_term input term)
           (-> Input Code
               Code)
           (let [term (if (its #try? input)
                        (` (.try (, term)))
                        term)]
             (if (its #io? input)
               (` (io.io (, term)))
               term)))

         (the (procedure_definition import! source it)
           (-> (List Code) Code (Named Procedure)
               Code)
           (let ['it (|> (its #alias it)
                         (maybe.else (its #name it))
                         code.local)
                 'variables (list#each code.local (its [#anonymous #input #variables] it))
                 input (its [#anonymous #input] it)
                 :parameters: (its #parameters input)
                 'parameters (..parameters :parameters:)
                 :output: (its [#anonymous #output] it)
                 :input:/* (when :parameters:
                             {.#End}
                             (list (` []))
                             
                             parameters
                             (list#each ..output_type :parameters:))]
             (` (the ((, 'it) [(,* (list#each (its #mandatory) 'parameters))])
                  (.for_any ((, 'it) (,* 'variables))
                    (-> [(,* :input:/*)]
                        (, (|> :output:
                               ..output_type
                               (..input_type input)))))
                  (.exec
                    (,* import!)
                    (.as_expected
                     (, (<| (..input_term input)
                            (..lux_optional :output:)
                            (` (<apply> (.as_expected (, source))
                                        [(,* (list#each ..host_optional 'parameters))]))))))))))

         (the (namespaced namespace host_module class alias member)
           (-> Namespace Text Text Alias Text
               Text)
           (|> namespace
               (text.replaced "[2]" host_module)
               (text.replaced "[1]" (maybe.else class alias))
               (text.replaced "[0]" member)))

         ... https://en.wikipedia.org/wiki/Delimiter
         (the class_delimiter ".")

         (the host_path
           (text.replaced .module_delimiter ..class_delimiter))

         (for .js (these)
              (the (imported class)
                (-> Text
                    Code)
                (for .python
                     (` (<import> (, (code.text (text.replaced .module_delimiter "." class)))))
                     
                     ... else
                     (when (text.all_split_by .module_delimiter class)
                       {.#Item head tail}
                       (list#mix (.function (_ sub super)
                                   (` (<get> (, (code.text sub))
                                             (.as (..Object .Any)
                                                  (, super)))))
                                 (` (<import> (, (code.text head))))
                                 tail)
                       
                       {.#End}
                       (` (<import> (, (code.text class))))))))

         (the (global_definition import! it)
           (-> (List Code) Global
               Code)
           (let ['name (|> (its #alias it)
                           (maybe.else (its #name it))
                           code.local)
                 :output: (its #anonymous it)]
             (` (the (, 'name)
                  (, (..output_type :output:))
                  (.exec
                    (,* import!)
                    (.as_expected
                     (, (<| (lux_optional :output:)
                            (` (<constant> (, (code.text (..host_path (its #name it))))))))))))))
         
         (for .lua (these)
              .ruby (these)
              (the (constructor_definition host_module [class_name class_parameters] alias namespace it)
                (-> Text Declaration Alias Namespace Constructor
                    Code)
                (let ['it (|> it
                              (its #alias)
                              (maybe.else "new")
                              (..namespaced namespace host_module class_name alias)
                              code.local)
                      input (its #anonymous it)
                      'input_variables (list#each code.local (its #variables input))
                      :parameters: (its #parameters input)
                      'parameters (..parameters :parameters:)
                      'class_variables (list#each code.local class_parameters)
                      'class (` ((, (code.local (maybe.else class_name alias))) (,* 'class_variables)))
                      :output: [#optional? false #mandatory 'class]
                      unquantified_type (` (.-> [(,* (list#each ..output_type :parameters:))]
                                                (, (|> :output:
                                                       ..output_type
                                                       (..input_type input)))))
                      quantified_type (when (list#composite 'class_variables 'input_variables)
                                        (list)
                                        unquantified_type

                                        _
                                        (` (.for_any ((, 'it) (,* 'class_variables) (,* 'input_variables))
                                             (, unquantified_type))))]
                  (` (the ((, 'it) [(,* (list#each (its #mandatory) 'parameters))])
                       (, quantified_type)
                       (.as_expected
                        (, (<| (..input_term input)
                               (..lux_optional :output:)
                               (` (<new> (, (for .js (` (<constant> (, (code.text (..host_path class_name)))))
                                                 .python (` (.as ..Function
                                                                 (, (..imported class_name))))))
                                         [(,* (list#each ..host_optional 'parameters))]))))))))))

         (the (optional_value type value)
           (-> Optional Code
               Optional)
           [#optional? (its #optional? type)
            #mandatory value])
         
         (the (static_field_definition import! host_module [class_name class_parameters] alias namespace it)
           (-> (List Code) Text Declaration Alias Namespace (Named Output)
               Code)
           (let [field (its #name it)
                 'it (|> (its #alias it)
                         (maybe.else field)
                         (..namespaced namespace host_module class_name alias)
                         code.local)
                 :field: (its #anonymous it)
                 get (` (.as (io.IO (, (..output_type :field:)))
                             (io.io (, (<| (lux_optional :field:)
                                           (for .js (` (<constant> (, (code.text (%.message (..host_path class_name) "." field)))))
                                                .ruby (` (<constant> (, (code.text (%.message (..host_path class_name) "::" field)))))
                                                ... else
                                                (` (<get> (, (code.text field))
                                                          (, (..imported class_name))))))))))
                 set (` (.as (io.IO .Any)
                             (io.io (, (for .js (` (..set (, (code.text field))
                                                          (, (host_optional (optional_value :field: (` ((,' ,) (, 'it))))))
                                                          (.as (..Object .Any)
                                                               (<constant> (, (code.text (..host_path class_name)))))))
                                            .ruby (` (<set> (, (code.text field))
                                                            (, (host_optional (optional_value :field: (` ((,' ,) (, 'it))))))
                                                            (<constant> (, (code.text (..host_path class_name))))))
                                            .python (` (<apply> (<constant> "setattr")
                                                                [(, (..imported class_name))
                                                                 (, (code.text field))
                                                                 (, (host_optional (optional_value :field: (` ((,' ,) (, 'it))))))]))
                                            ... else
                                            (` (<set> (, (code.text field))
                                                      (, (host_optional (optional_value :field: (` ((,' ,) (, 'it))))))
                                                      (, (..imported class_name)))))))))]
             (` (the (, 'it)
                  (syntax.macro ((, 'it) [(, 'it) (<>.maybe <code>.any)])
                    (.by meta.monad (,' in)
                         (.list (`' (.exec
                                      (,* import!)
                                      ((,' ,) (when (, 'it)
                                                {.#None}
                                                (`' (, get))

                                                {.#Some (, 'it)}
                                                (`' (, set)))))))))))))

         (the (virtual_field_definition host_module [class_name class_parameters] alias namespace it)
           (-> Text Declaration Alias Namespace (Named Output)
               Code)
           (let [name (its #name it)
                 'it (|> (its #alias it)
                         (maybe.else name)
                         (..namespaced namespace host_module class_name alias)
                         code.local)
                 path (%.message (..host_path class_name) "." name)
                 :field: (its #anonymous it)
                 'variables (list#each code.local class_parameters)
                 'class (` ((, (code.local (maybe.else class_name alias))) (,* 'variables)))]
             (` (the ((, 'it) (, 'it))
                  (.for_any ((, 'it) (,* 'variables))
                    (.-> (, 'class)
                         (, (..output_type :field:))))
                  (.as_expected
                   (, (<| (lux_optional :field:)
                          (` (<get> (, (code.text name)) (, 'it))))))))))

         (the (field_definition import! host_module class alias namespace it)
           (-> (List Code) Text Declaration Alias Namespace Field
               Code)
           (if (its #static? it)
             (..static_field_definition import! host_module class alias namespace (its #member it))
             (..virtual_field_definition host_module class alias namespace (its #member it))))

         (the (static_method_definition import! host_module [class_name class_parameters] alias namespace it)
           (-> (List Code) Text Declaration Alias Namespace (Named Procedure)
               Code)
           (let [method (its #name it)
                 name (|> (its #alias it)
                          (maybe.else (its #name it))
                          (..namespaced namespace host_module class_name alias))]
             (|> it
                 (has #alias {.#Some name})
                 (..procedure_definition import!
                                         (for .js (` (<constant> (, (code.text (%.message (..host_path class_name) "." method)))))
                                              .ruby (` (<constant> (, (code.text (%.message (..host_path class_name) "::" method)))))
                                              (` (<get> (, (code.text method))
                                                        (.as (..Object .Any)
                                                             (, (..imported class_name))))))))))

         (the (virtual_method_definition host_module [class_name class_parameters] alias namespace it)
           (-> Text Declaration Alias Namespace (Named Procedure)
               Code)
           (let [method (its #name it)
                 'it (|> (its #alias it)
                         (maybe.else method)
                         (..namespaced namespace host_module class_name alias)
                         code.local)
                 procedure (its #anonymous it)
                 input (its #input procedure)
                 'input_variables (list#each code.local (its #variables input))
                 :parameters: (its #parameters input)
                 'parameters (..parameters :parameters:)
                 'class_variables (list#each code.local class_parameters)
                 'class (` ((, (code.local (maybe.else class_name alias))) (,* 'class_variables)))
                 :output: (its #output procedure)]
             (` (the ((, 'it) [(,* (list#each (its #mandatory) 'parameters))] (, 'it))
                  (.for_any ((, 'it) (,* 'class_variables) (,* 'input_variables))
                    (.-> [(,* (list#each ..output_type :parameters:))]
                         (, 'class)
                         (, (|> :output:
                                ..output_type
                                (..input_type input)))))
                  (.as_expected
                   (, (<| (..input_term input)
                          (..lux_optional :output:)
                          (` (<do> (, (code.text method))
                                   (, 'it)
                                   [(,* (list#each ..host_optional 'parameters))])))))))))

         (the (method_definition import! host_module class alias namespace it)
           (-> (List Code) Text Declaration Alias Namespace Method
               Code)
           (if (its #static? it)
             (static_method_definition import! host_module class alias namespace (its #member it))
             (virtual_method_definition host_module class alias namespace (its #member it))))

         (the .public import
           (syntax.macro (_ [host_module (<>.else "" <code>.text)
                             it ..importP])
             (let [host_module_import! (is (List Code)
                                           (when host_module
                                             ""
                                             (list)

                                             _
                                             (list (` (<import> (, (code.text host_module)))))))]
               (when it
                 {#Global it}
                 (in (list (..global_definition host_module_import! it)))

                 {#Procedure it}
                 (in (list (..procedure_definition host_module_import!
                                                   (` (<constant> (, (code.text (..host_path (its #name it))))))
                                                   it)))

                 {#Class it}
                 (let [class (its #declaration it)
                       alias (its #class_alias it)
                       [class_name class_parameters] class
                       namespace (its #namespace it)
                       'class_variables (list#each code.local class_parameters)
                       declaration (` ((, (code.local (maybe.else class_name alias)))
                                       (,* 'class_variables)))]
                   (in (list.partial (` (.every (, declaration)
                                          (..Object (.Nominal (, (code.text (..host_path class_name)))
                                                              [(,* 'class_variables)]))))
                                     (list#each (.function (_ member)
                                                  (`` (`` (when member
                                                            (,, (for .lua (,, (these))
                                                                     .ruby (,, (these))
                                                                     (,, (these {#Constructor it}
                                                                                (..constructor_definition host_module class alias namespace it)))))
                                                            
                                                            {#Field it}
                                                            (..field_definition host_module_import! host_module class alias namespace it)
                                                            
                                                            {#Method it}
                                                            (..method_definition host_module_import! host_module class alias namespace it)))))
                                                (its #members it)))))
                 ))))

         (for .ruby (these)
              (the .public function
                (syntax.macro (_ [[self inputs] (<code>.form
                                                 (all <>.and
                                                      <code>.local
                                                      (<code>.tuple (<>.some (<>.and <code>.any <code>.any)))))
                                  type <code>.any
                                  term <code>.any])
                  (in (list (` (.<| (.as ..Function)
                                    (<function> (, (code.natural (list.size inputs))))
                                    (.as (.-> [(,* (list.repeated (list.size inputs) (` .Any)))]
                                              .Any))
                                    (.is (.-> [(,* (list#each product.right inputs))]
                                              (, type)))
                                    (.function ((, (code.local self)) [(,* (list#each product.left inputs))])
                                      (, term)))))))))

         (for .js (these (the .public type_of
                           (template.macro (type_of object)
                             [(.js_type_of# object)]))

                         (the .public global
                           (syntax.macro (_ [type <code>.any
                                             [head tail] (<code>.tuple (<>.and <code>.local (<>.some <code>.local)))])
                             (with_names ['_]
                               (let [global (` (.js_constant# (, (code.text head))))]
                                 (when tail
                                   {.#End}
                                   (in (list (` (is (.Maybe (, type))
                                                    (when (..type_of (, global))
                                                      "undefined"
                                                      {.#None}

                                                      (, '_)
                                                      {.#Some (as (, type) (, global))})))))
                                   
                                   {.#Item [next tail]}
                                   (let [delimiter "."]
                                     (in (list (` (is (.Maybe (, type))
                                                      (when (..type_of (, global))
                                                        "undefined"
                                                        {.#None}

                                                        (, '_)
                                                        (..global (, type) [(, (code.local (%.message head delimiter next)))
                                                                            (,* (list#each code.local tail))]))))))))))))

                         (the !defined?
                           (template.macro (_ <global>)
                             [(.when (..global Any <global>)
                                {.#None}
                                .false

                                {.#Some _}
                                .true)]))

                         (template.with [<name> <global>]
                           [(the .public <name>
                              Bit
                              (!defined? <global>))]

                           [on_browser? [window]]
                           [on_nashorn? [java lang Object]]
                           )

                         (the .public on_node_js?
                           Bit
                           (|> (..global (Object Any) [process])
                               (maybe#each (|>> []
                                                (.js_apply# (.js_constant# "Object.prototype.toString.call"))
                                                (as Text)
                                                (text.= "[object process]")))
                               (maybe.else false))))
              (these)))
  )
