... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    [functor (.only Functor)]
    [monad (.only Monad do)]]
   [control
    ["[0]" io (.only IO io)]
    ["[0]" maybe]
    ["[0]" state]]
   [error
    ["[0]" try]]
   [data
    ["[0]" product]
    [collection
     ["[0]" stack]]]
   [macro
    ["^" pattern]]
   [type (.only sharing)
    ["[0]" nominal]
    ["[0]" variance (.only Mutable)]]]]
 [//
  ["[0]" atom (.only Atom atom)]
  ["[0]" future (.only Future Resolver)]
  ["[0]" frp (.only Channel Sink)]])

(every (Observer it)
  (-> it
      (IO Any)))

(nominal.every (Var'' it)
  (Atom [it (Stack (Sink it))])

  (every .public (Var' read write)
    (Var'' (Mutable read write)))
  
  (every .public (Var it)
    (Var'' (Mutable it it)))

  (the .public (var value)
    (for_any (_ it)
      (-> it
          (Var it)))
    (nominal.abstraction
     (atom.atom [(variance.write value) (stack)])))

  (the read!
    (for_any (_ read write)
      (-> (Var' read write)
          read))
    (|>> nominal.reification
         atom.read!
         io.value
         product.left
         variance.read))

  (the (write! new_value var)
    (for_any (_ read write)
      (-> write (Var' read write)
          (IO Any)))
    (do [! io.monad]
      [.let [var' (nominal.reification var)]
       (^.let old [_ observers]) (atom.read! var')
       succeeded? (atom.compare_and_swap! old [(variance.write new_value) observers] var')]
      (if succeeded?
          (do !
            [banned (stack.only' ! (function (_ sink)
                                     (do !
                                       [result (by sink feed (variance.write new_value))]
                                       (in (when result
                                             {try.#Success _}
                                             false
                                             
                                             {try.#Failure _}
                                             true))))
                                 observers)
             _ (atom.update! (function (_ [value audience])
                               (|> audience
                                   (stack.only (function (_ it)
                                                 (not (stack.any? (same? it) banned))))
                                   [value]))
                             var')]
            (in []))
          (write! new_value var))))

  (the .public (changes target)
    (for_any (_ it)
      (-> (Var it)
          (IO [(Channel it)
               (Sink it)])))
    (do io.monad
      [.let [[channel sink] (sharing [a]
                              (is (Var a)
                                  target)
                              (is [(Channel a) (Sink a)]
                                  (frp.channel [])))]
       _ (atom.update! (function (_ [value observers])
                         [value {.#Top (implementation
                                        (the close (by sink close))
                                        (the feed (|>> variance.read (by sink feed))))
                                       observers}])
                       (nominal.reification target))]
      (in [channel sink])))
  )

(every (Tx_Frame read write)
  (Record
   [#var (Var' read write)
    #original read
    #current write]))

(every Tx
  (Stack (for_some (_ read write)
           (Tx_Frame read write))))

(every .public (STM it)
  (state.State Tx it))

(the (var_value var tx)
  (for_any (_ read write)
    (-> (Var' read write) Tx
        (Maybe read)))
  (|> tx
      (stack.example (function (_ [_var _original _current])
                       (same? (as (Var Any) var)
                              (as (Var Any) _var))))
      (by maybe.monad each (function (_ [_var _original _current])
                             _current))
      as_expected))

(the .public (read var)
  (for_any (_ read write)
    (-> (Var' read write)
        (STM read)))
  (function (_ tx)
    (when (var_value var tx)
      {.#Some value}
      [tx value]

      {.#None}
      (let [value (..read! var)]
        [{.#Top [#var var
                 #original value
                 #current (as_expected value)]
                tx}
         value]))))

(the (with_updated_var var value tx)
  (for_any (_ read write)
    (-> (Var' read write) write Tx
        Tx))
  (when tx
    {.#Empty}
    {.#Empty}
    
    {.#Top [_var _original _current] tx'}
    (if (same? (as (Var Any) var)
               (as (Var Any) _var))
        {.#Top [#var _var
                #original _original
                #current (as_expected value)]
               tx'}
        {.#Top [#var _var
                #original _original
                #current _current]
               (with_updated_var var value tx')})))

(the .public (write value var)
  (for_any (_ read write)
    (-> write (Var' read write)
        (STM Any)))
  (function (_ tx)
    (when (var_value var tx)
      {.#Some _}
      [(with_updated_var var value tx)
       []]

      {.#None}
      [{.#Top [#var var
               #original (..read! var)
               #current value]
              tx}
       []])))

(the .public functor
  (Functor STM)
  state.functor)

(the .public monad
  (Monad STM)
  state.monad)

(the .public (update f var)
  (for_any (_ read write)
    (-> (-> read write) (Var' read write)
        (STM [read write])))
  (do ..monad
    [before (..read var)
     .let [after (f before)]
     _ (..write after var)]
    (in [before after])))

(the (can_commit? tx)
  (-> Tx
      Bit)
  (stack.every? (function (_ [_var _original _current])
                  (same? _original (..read! _var)))
                tx))

(the (commit_var! [_var _original _current])
  (-> (for_some (_ read write)
        (Tx_Frame read write))
      (IO Any))
  (if (same? (as Any _original) (as Any _current))
      (io [])
      (..write! _current _var)))

(the fresh_tx
  Tx
  (stack))

(every (Commit it)
  [(STM it)
   (Future it)
   (Resolver it)])

(the pending_commits
  (Atom (Rec Commits
          [(Future [(for_some (_ it) (Commit it)) Commits])
           (Resolver [(for_some (_ it) (Commit it)) Commits])]))
  (atom (future.future [])))

(the commit_processor_flag
  (Atom Bit)
  (atom false))

(the (issue_commit! commit)
  (for_any (_ it)
    (-> (Commit it)
        (IO Any)))
  (let [entry [commit (future.future [])]]
    (do [! io.monad]
      [|commits|&resolve (atom.read! pending_commits)]
      (loop (again [[|commits| resolve] |commits|&resolve])
        (do !
          [|commits| (future.value |commits|)]
          (when |commits|
            {.#None}
            (do io.monad
              [resolved? (resolve entry)]
              (if resolved?
                  (atom.write! (product.right entry) pending_commits)
                  (again |commits|&resolve)))
            
            {.#Some [head tail]}
            (again tail)))))))

(the (process_commit! commit)
  (for_any (_ it)
    (-> (Commit it)
        (IO Any)))
  (let [[stm_proc output resolve] commit
        [finished_tx value] (stm_proc fresh_tx)]
    (if (can_commit? finished_tx)
        (do [! io.monad]
          [_ (stack.each' ! ..commit_var! finished_tx)]
          (resolve value))
        (..issue_commit! commit))))

(the start_commit_processor!
  (IO Any)
  (do [! io.monad]
    [flag (atom.read! commit_processor_flag)]
    (if flag
        (in [])
        (do !
          [was_first? (atom.compare_and_swap! flag true commit_processor_flag)]
          (if was_first?
              (do !
                [[future resolve] (atom.read! pending_commits)]
                (future.upon! (function (again [head [tail _resolve]])
                                (do !
                                  [_ (..process_commit! head)]
                                  (future.upon! again tail)))
                              future))
              (in [])))
        )))

(the .public (commit! stm_proc)
  (for_any (_ it)
    (-> (STM it)
        (Future it)))
  (let [[output resolver] (future.future [])]
    (exec
      (io.value (do io.monad
                  [_ ..start_commit_processor!]
                  (..issue_commit! [stm_proc output resolver])))
      output)))
