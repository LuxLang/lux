... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except macro
                all with)
   [abstract
    [functor (.only Functor)
     ["[0]" pro]]]
   [type
    ["[0]" nominal]]
   ["[0]" function]
   [data
    ["[0]" product]]]])

(the macro
  (<| (.in_module# .prelude)
      .template#macro))

(the with_template
  (<| (.in_module# .prelude)
      .with_template))

(every .public (Aspect it context context' aspect aspect')
  (-> (it aspect aspect')
      (it context context')))

... TODO: Make this nominal type unnecessary.
(nominal.every .public (Membership one all)
  (Variant
   {#All all}
   {#One one (Membership one (-> one all))})

  (the outer
    (for_any (_ one all)
      (-> (Membership one all)
          (Or all (And one (Membership one (-> one all))))))
    (|>> nominal.reification))

  (the inner
    (for_any (_ one all)
      (-> (Or all (And one (Membership one (-> one all))))
          (Membership one all)))
    (|>> nominal.abstraction))

  (the .public membership_functor
    (for_any (_ one)
      (Functor (Membership one)))
    (implementation
     (the (each value it)
       (nominal.abstraction
        (.when (nominal.reification it)
          {#All all}
          {#All (value all)}

          {#One one next}
          {#One one (each (function (_ before)
                            (|>> before
                                 value))
                          next)}))
       )))

  (every .public (Apply context)
    (Interface
     (is (Functor context)
         functor)
     (is (for_any (_ it)
           (-> it
               (context it)))
         pure)
     (is (for_any (_ it it')
           (-> (context (-> it it'))
               (-> (context it)
                   (context it'))))
         with)))

  (the .public membership_apply
    (for_any (_ one)
      (Apply (Membership one)))
    (implementation
     (the functor ..membership_functor)
     (the pure (|>> {#All} nominal.abstraction))
     (the (with internal_effect internal_cause)
       (.when (nominal.reification internal_effect)
         {#All internal_effect}
         (by ..membership_functor each internal_effect internal_cause)

         {#One one internal_effect}
         (nominal.abstraction
          {#One one (with (by ..membership_functor each function.flipped internal_effect)
                      internal_cause)})))))

  (the .public (one it)
    (for_any (_ it)
      (-> it
          (Membership it it)))
    (nominal.abstraction {#One it (nominal.abstraction {#All (|>>)})}))

  (the .public (all it)
    (for_any (_ one all)
      (-> (Membership one all)
          all))
    (.when (nominal.reification it)
      {#All it}
      it

      {#One one next}
      ((all next) one)))

  (every .public (Member all one)
    (-> all
        (Membership one all)))
  )
