(.module:
  [library
   [lux {"-" [or and list i64 nat int rev char]}
    [abstract
     [hash {"+" [Hash]}]
     [functor {"+" [Functor]}]
     [apply {"+" [Apply]}]
     ["[0]" monad {"+" [Monad do]}]]
    [data
     ["[0]" text {"+" [Char]} ("[1]\[0]" monoid)
      ["[0]" unicode "_"
       ["[1]" set]]]
     [collection
      ["[0]" list ("[1]\[0]" mix)]
      ["[0]" array {"+" [Array]}]
      ["[0]" dictionary {"+" [Dictionary]}]
      ["[0]" queue {"+" [Queue]}]
      ["[0]" set {"+" [Set]}]
      ["[0]" stack {"+" [Stack]}]
      ["[0]" row {"+" [Row]}]
      [tree
       ["[0]" finger {"+" [Tree]}]]]]
    [math
     [number {"+" [hex]}
      ["n" nat]
      ["i" int]
      ["f" frac]
      ["r" ratio]
      ["c" complex]
      ["[0]" i64]]]
    ["[0]" time {"+" [Time]}
     ["[0]" instant {"+" [Instant]}]
     ["[0]" date {"+" [Date]}]
     ["[0]" duration {"+" [Duration]}]
     ["[0]" month {"+" [Month]}]
     ["[0]" day {"+" [Day]}]]
    [type
     [refinement {"+" [Refiner Refined]}]]]])

(type: .public PRNG
  (Rec PRNG
    (-> Any [PRNG I64])))

(type: .public (Random a)
  (-> PRNG [PRNG a]))

(implementation: .public functor
  (Functor Random)
  
  (def: (each f fa)
    (function (_ state)
      (let [[state' a] (fa state)]
        [state' (f a)]))))

(implementation: .public apply
  (Apply Random)
  
  (def: &functor ..functor)

  (def: (on fa ff)
    (function (_ state)
      (let [[state' f] (ff state)
            [state'' a] (fa state')]
        [state'' (f a)]))))

(implementation: .public monad
  (Monad Random)
  
  (def: &functor ..functor)

  (def: (in a)
    (function (_ state)
      [state a]))

  (def: (conjoint ffa)
    (function (_ state)
      (let [[state' fa] (ffa state)]
        (fa state')))))

(def: .public (only pred gen)
  (All (_ a) (-> (-> a Bit) (Random a) (Random a)))
  (do ..monad
    [sample gen]
    (if (pred sample)
      (in sample)
      (only pred gen))))

(def: .public (one check random)
  (All (_ a b)
    (-> (-> a (Maybe b)) (Random a) (Random b)))
  (do ..monad
    [sample random]
    (case (check sample)
      (#.Some output)
      (in output)

      #.None
      (one check random))))

(def: .public (refined refiner gen)
  (All (_ t r) (-> (Refiner t r) (Random t) (Random (Refined t r))))
  (do ..monad
    [sample gen]
    (case (refiner sample)
      (#.Some refined)
      (in refined)

      #.None
      (refined refiner gen))))

(def: .public bit
  (Random Bit)
  (function (_ prng)
    (let [[prng output] (prng [])]
      [prng (|> output (i64.and 1) (n.= 1))])))

(def: .public i64
  (Random I64)
  (function (_ prng)
    (let [[prng left] (prng [])
          [prng right] (prng [])]
      [prng (|> left
                (i64.left_shifted 32)
                ("lux i64 +" right))])))

(template [<name> <type> <cast>]
  [(def: .public <name>
     (Random <type>)
     (\ ..monad each <cast> ..i64))]

  [nat Nat .nat]
  [int Int .int]
  [rev Rev .rev]
  )

(def: .public frac
  (Random Frac)
  (\ ..monad each (|>> .i64 f.of_bits) ..nat))

(def: .public safe_frac
  (Random Frac)
  (let [mantissa_range (.int (i64.left_shifted 53 1))
        mantissa_max (i.frac (-- mantissa_range))]
    (\ ..monad each
       (|>> (i.% mantissa_range)
            i.frac
            (f./ mantissa_max))
       ..int)))

(def: .public (char set)
  (-> unicode.Set (Random Char))
  (let [start (unicode.start set)
        end (unicode.end set)
        size (n.- start end)
        in_range (: (-> Char Char)
                    (|>> (n.% size) (n.+ start)))]
    (|> ..nat
        (\ ..monad each in_range)
        (..only (unicode.member? set)))))

(def: .public (text char_gen size)
  (-> (Random Char) Nat (Random Text))
  (if (n.= 0 size)
    (\ ..monad in "")
    (do ..monad
      [x char_gen
       xs (text char_gen (-- size))]
      (in (text\composite (text.of_char x) xs)))))

(template [<name> <set>]
  [(def: .public <name>
     (-> Nat (Random Text))
     (..text (..char <set>)))]

  [unicode         unicode.character]
  [ascii           unicode.ascii]
  [ascii/alpha     unicode.ascii/alpha]
  [ascii/alpha_num unicode.ascii/alpha_num]
  [ascii/numeric   unicode.ascii/numeric]
  [ascii/upper     unicode.ascii/upper]
  [ascii/lower     unicode.ascii/lower]
  )

(template [<name> <type> <ctor> <gen>]
  [(def: .public <name>
     (Random <type>)
     (do ..monad
       [left <gen>
        right <gen>]
       (in (<ctor> left right))))]

  [ratio   r.Ratio   r.ratio   ..nat]
  [complex c.Complex c.complex ..safe_frac]
  )

(def: .public (and left right)
  (All (_ a b) (-> (Random a) (Random b) (Random [a b])))
  (do ..monad
    [=left left
     =right right]
    (in [=left =right])))

(def: .public (or left right)
  (All (_ a b) (-> (Random a) (Random b) (Random (Or a b))))
  (do [! ..monad]
    [? bit]
    (if ?
      (do !
        [=left left]
        (in (0 #0 =left)))
      (do !
        [=right right]
        (in (0 #1 =right))))))

(def: .public (either left right)
  (All (_ a) (-> (Random a) (Random a) (Random a)))
  (do ..monad
    [? bit]
    (if ?
      left
      right)))

(def: .public (rec gen)
  (All (_ a) (-> (-> (Random a) (Random a)) (Random a)))
  (function (_ state)
    (let [gen' (gen (rec gen))]
      (gen' state))))

(def: .public (maybe value_gen)
  (All (_ a) (-> (Random a) (Random (Maybe a))))
  (do [! ..monad]
    [some? bit]
    (if some?
      (do !
        [value value_gen]
        (in (#.Some value)))
      (in #.None))))

(template [<name> <type> <zero> <plus>]
  [(def: .public (<name> size value_gen)
     (All (_ a) (-> Nat (Random a) (Random (<type> a))))
     (if (n.> 0 size)
       (do ..monad
         [x value_gen
          xs (<name> (-- size) value_gen)]
         (in (<plus> x xs)))
       (\ ..monad in <zero>)))]

  [list List (.list)   #.Item]
  [row  Row  row.empty row.suffix]
  )

(template [<name> <type> <ctor>]
  [(def: .public (<name> size value_gen)
     (All (_ a) (-> Nat (Random a) (Random (<type> a))))
     (do ..monad
       [values (list size value_gen)]
       (in (|> values <ctor>))))]

  [array Array array.of_list]
  [queue Queue queue.of_list]
  [stack Stack (list\mix stack.top stack.empty)]
  )

(def: .public (set hash size value_gen)
  (All (_ a) (-> (Hash a) Nat (Random a) (Random (Set a))))
  (if (n.> 0 size)
    (do [! ..monad]
      [xs (set hash (-- size) value_gen)]
      (loop [_ []]
        (do !
          [x value_gen
           .let [xs+ (set.has x xs)]]
          (if (n.= size (set.size xs+))
            (in xs+)
            (recur [])))))
    (\ ..monad in (set.empty hash))))

(def: .public (dictionary hash size key_gen value_gen)
  (All (_ k v) (-> (Hash k) Nat (Random k) (Random v) (Random (Dictionary k v))))
  (if (n.> 0 size)
    (do [! ..monad]
      [kv (dictionary hash (-- size) key_gen value_gen)]
      (loop [_ []]
        (do !
          [k key_gen
           v value_gen
           .let [kv+ (dictionary.has k v kv)]]
          (if (n.= size (dictionary.size kv+))
            (in kv+)
            (recur [])))))
    (\ ..monad in (dictionary.empty hash))))

(def: .public instant
  (Random Instant)
  (\ ..monad each instant.of_millis ..int))

(def: .public date
  (Random Date)
  (\ ..monad each instant.date ..instant))

(def: .public time
  (Random Time)
  (\ ..monad each instant.time ..instant))

(def: .public duration
  (Random Duration)
  (\ ..monad each duration.of_millis ..int))

(def: .public month
  (Random Month)
  (let [(^open "\[0]") ..monad]
    (..either (..either (..either (\in #month.January)
                                  (..either (\in #month.February)
                                            (\in #month.March)))
                        (..either (\in #month.April)
                                  (..either (\in #month.May)
                                            (\in #month.June))))
              (..either (..either (\in #month.July)
                                  (..either (\in #month.August)
                                            (\in #month.September)))
                        (..either (\in #month.October)
                                  (..either (\in #month.November)
                                            (\in #month.December)))))))

(def: .public day
  (Random Day)
  (let [(^open "\[0]") ..monad]
    (..either (..either (\in #day.Sunday)
                        (..either (\in #day.Monday)
                                  (\in #day.Tuesday)))
              (..either (..either (\in #day.Wednesday)
                                  (\in #day.Thursday))
                        (..either (\in #day.Friday)
                                  (\in #day.Saturday))))))

(def: .public (result prng calc)
  (All (_ a) (-> PRNG (Random a) [PRNG a]))
  (calc prng))

(def: .public (prng update return)
  (All (_ a) (-> (-> a a) (-> a I64) (-> a PRNG)))
  (function (recur state)
    (function (_ _)
      [(recur (update state))
       (return state)])))

(def: .public (pcg_32 [increase seed])
  (-> [(I64 Any) (I64 Any)] PRNG)
  (let [magic 6364136223846793005]
    (function (_ _)
      [(|> seed .nat (n.* magic) ("lux i64 +" increase) [increase] pcg_32)
       (let [rot (|> seed .i64 (i64.right_shifted 59))]
         (|> seed
             (i64.right_shifted 18)
             (i64.xor seed)
             (i64.right_shifted 27)
             (i64.right_rotated rot)
             .i64))])))

(def: .public (xoroshiro_128+ [s0 s1])
  (-> [(I64 Any) (I64 Any)] PRNG)
  (function (_ _)
    [(let [s01 (i64.xor s0 s1)]
       (xoroshiro_128+ [(|> s0
                            (i64.left_rotated 55)
                            (i64.xor s01)
                            (i64.xor (i64.left_shifted 14 s01)))
                        (i64.left_rotated 36 s01)]))
     ("lux i64 +" s0 s1)]))

... https://en.wikipedia.org/wiki/Xorshift#Initialization
... http://xorshift.di.unimi.it/splitmix64.c
(def: .public split_mix_64
  (-> Nat PRNG)
  (let [twist (: (-> Nat Nat Nat)
                 (function (_ shift value)
                   (i64.xor (i64.right_shifted shift value)
                            value)))
        mix n.*]
    (..prng (n.+ (hex "9E,37,79,B9,7F,4A,7C,15"))
            (|>> (twist 30)
                 (mix (hex "BF,58,47,6D,1C,E4,E5,B9"))

                 (twist 27)
                 (mix (hex "94,D0,49,BB,13,31,11,EB"))

                 (twist 31)
                 .i64))))
