(.using
  [library
   [lux "*"
    ["[0]" meta]
    [abstract
     [monad {"+" do}]]
    [control
     ["[0]" try {"+" Try}]
     ["[0]" exception {"+" exception:}]
     [parser
      ["<[0]>" code]]]
    [macro
     [syntax {"+" syntax:}]
     ["[0]" code]]
    [math
     [number
      ["i" int]]]
    [type
     abstract]]])

(exception: .public zero_cannot_be_a_modulus)

(abstract: .public (Modulus %)
  Int

  (def: .public (modulus value)
    (Ex (_ %) (-> Int (Try (Modulus %))))
    (if (i.= +0 value)
      (exception.except ..zero_cannot_be_a_modulus [])
      {try.#Success (:abstraction value)}))

  (def: .public divisor
    (All (_ %) (-> (Modulus %) Int))
    (|>> :representation))

  (def: .public (= reference subject)
    (All (_ %r %s) (-> (Modulus %r) (Modulus %s) Bit))
    (i.= (:representation reference)
         (:representation subject)))

  (def: .public (congruent? modulus reference subject)
    (All (_ %) (-> (Modulus %) Int Int Bit))
    (|> subject
        (i.- reference)
        (i.% (:representation modulus))
        (i.= +0)))
  )

(syntax: .public (literal [divisor <code>.int])
  (meta.lifted
   (do try.monad
     [_ (..modulus divisor)]
     (in (list (` ((~! try.trusted) (..modulus (~ (code.int divisor))))))))))
