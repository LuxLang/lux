(.module:
  [library
   [lux "*"
    ["." meta]
    [abstract
     [monad {"+" [do]}]]
    [control
     ["." try {"+" [Try]}]
     ["." exception {"+" [exception:]}]
     [parser
      ["<.>" code]]]
    [macro
     [syntax {"+" [syntax:]}]
     ["." code]]
    [math
     [number
      ["i" int]]]
    [type
     abstract]]])

(exception: .public zero_cannot_be_a_modulus)

(abstract: .public (Modulus %)
  {}

  Int

  (def: .public (modulus value)
    (Ex (_ %) (-> Int (Try (Modulus %))))
    (if (i.= +0 value)
      (exception.except ..zero_cannot_be_a_modulus [])
      (#try.Success (:abstraction value))))

  (def: .public divisor
    (All (_ %) (-> (Modulus %) Int))
    (|>> :representation))

  (def: .public (= reference subject)
    (All (_ %r %s) (-> (Modulus %r) (Modulus %s) Bit))
    (i.= (:representation reference)
         (:representation subject)))

  (def: .public (congruent? modulus reference subject)
    (All (_ %) (-> (Modulus %) Int Int Bit))
    (|> subject
        (i.- reference)
        (i.% (:representation modulus))
        (i.= +0)))
  )

(syntax: .public (literal [divisor <code>.int])
  (meta.lifted
   (do try.monad
     [_ (..modulus divisor)]
     (in (list (` ((~! try.trusted) (..modulus (~ (code.int divisor))))))))))
