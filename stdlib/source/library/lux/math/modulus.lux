(.module:
  [library
   [lux #*
    ["." meta]
    [abstract
     [monad (#+ do)]]
    [control
     ["." try (#+ Try)]
     ["." exception (#+ exception:)]
     [parser
      ["<.>" code]]]
    [macro
     [syntax (#+ syntax:)]
     ["." code]]
    [math
     [number
      ["i" int]]]
    [type
     abstract]]])

(exception: #export zero_cannot_be_a_modulus)

(abstract: #export (Modulus %)
  Int

  {#.doc (doc "A number used as a modulus in modular arithmetic."
              "It cannot be 0.")}

  (def: #export (modulus value)
    (Ex [%] (-> Int (Try (Modulus %))))
    (if (i.= +0 value)
      (exception.except ..zero_cannot_be_a_modulus [])
      (#try.Success (:abstraction value))))

  (def: #export divisor
    (All [%] (-> (Modulus %) Int))
    (|>> :representation))

  (def: #export (= reference subject)
    (All [%r %s] (-> (Modulus %r) (Modulus %s) Bit))
    (i.= (:representation reference)
         (:representation subject)))

  (def: #export (congruent? modulus reference subject)
    (All [%] (-> (Modulus %) Int Int Bit))
    (|> subject
        (i.- reference)
        (i.% (:representation modulus))
        (i.= +0)))
  )

(syntax: #export (literal {divisor <code>.int})
  {#.doc (doc "Success!"
              (literal 123)

              "Failure!"
              (literal 0))}
  (meta.lift
   (do try.monad
     [_ (..modulus divisor)]
     (in (list (` ((~! try.assumed) (..modulus (~ (code.int divisor))))))))))
