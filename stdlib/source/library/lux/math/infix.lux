(.module:
  [library
   [lux #*
    [abstract
     [monad (#+ do)]]
    [control
     ["<>" parser ("#\." functor)
      ["<.>" code (#+ Parser)]]]
    [data
     ["." product]
     [collection
      ["." list ("#\." mix)]]]
    [macro
     [syntax (#+ syntax:)]
     ["." code]]
    [math
     [number
      ["n" nat]
      ["i" int]]]]])

(type: #rec Infix
  (#Const Code)
  (#Call (List Code))
  (#Unary Code Infix)
  (#Binary Infix Code Infix))

(def: literal
  (Parser Code)
  ($_ <>.either
      (<>\map code.bit <code>.bit)
      (<>\map code.nat <code>.nat)
      (<>\map code.int <code>.int)
      (<>\map code.rev <code>.rev)
      (<>\map code.frac <code>.frac)
      (<>\map code.text <code>.text)
      (<>\map code.identifier <code>.identifier)
      (<>\map code.tag <code>.tag)))

(def: expression
  (Parser Infix)
  (<| <>.rec (function (_ expression))
      ($_ <>.or
          ..literal
          (<code>.form (<>.many <code>.any))
          (<code>.tuple (<>.and <code>.any expression))
          (<code>.tuple ($_ <>.either
                            (do <>.monad
                              [_ (<code>.this! (' #and))
                               init_subject expression
                               init_op <code>.any
                               init_param expression
                               steps (<>.some (<>.and <code>.any expression))]
                              (in (product.right (list\mix (function (_ [op param] [subject [_subject _op _param]])
                                                             [param [(#Binary _subject _op _param)
                                                                     (` and)
                                                                     (#Binary subject op param)]])
                                                           [init_param [init_subject init_op init_param]]
                                                           steps))))
                            (do <>.monad
                              [init_subject expression
                               init_op <code>.any
                               init_param expression
                               steps (<>.some (<>.and <code>.any expression))]
                              (in (list\mix (function (_ [op param] [_subject _op _param])
                                              [(#Binary _subject _op _param) op param])
                                            [init_subject init_op init_param]
                                            steps)))
                            ))
          )))

(def: (prefix infix)
  (-> Infix Code)
  (case infix
    (#Const value)
    value
    
    (#Call parts)
    (code.form parts)

    (#Unary op subject)
    (` ((~ op) (~ (prefix subject))))
    
    (#Binary left op right)
    (` ((~ op) (~ (prefix right)) (~ (prefix left))))))

(syntax: .public (infix [expr ..expression])
  (in (list (..prefix expr))))
