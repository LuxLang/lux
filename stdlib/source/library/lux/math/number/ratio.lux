(.module:
  {#.doc "Rational numbers."}
  [library
   [lux (#- nat)
    [abstract
     [equivalence (#+ Equivalence)]
     [order (#+ Order)]
     [monoid (#+ Monoid)]
     [codec (#+ Codec)]
     [monad (#+ do)]]
    [control
     ["." function]
     ["." maybe]
     ["." try]
     ["<>" parser
      ["<.>" code (#+ Parser)]]]
    [data
     ["." product]
     ["." text ("#\." monoid)]]
    [macro
     [syntax (#+ syntax:)]
     ["." code]]]]
  [//
   ["n" nat ("#\." decimal)]])

(type: .public Ratio
  {#.doc (example "An unsigned ratio of numbers.")}
  {#numerator Nat
   #denominator Nat})

(def: .public (nat value)
  (-> Ratio (Maybe Nat))
  (case (value@ #denominator value)
    1 (#.Some (value@ #numerator value))
    _ #.None))

(def: (normal (^slots [#numerator #denominator]))
  (-> Ratio Ratio)
  (let [common (n.gcd numerator denominator)]
    {#numerator (n./ common numerator)
     #denominator (n./ common denominator)}))

(syntax: .public (ratio [numerator <code>.any
                         ?denominator (<>.maybe <code>.any)])
  {#.doc (example "Rational literals."
                  (ratio numerator denominator)
                  "The denominator can be omitted if it is 1."
                  (ratio numerator))}
  (in (list (` ((~! ..normal) {#..numerator (~ numerator)
                               #..denominator (~ (maybe.else (' 1) ?denominator))})))))

(def: .public (= parameter subject)
  (-> Ratio Ratio Bit)
  (and (n.= (value@ #numerator parameter)
            (value@ #numerator subject))
       (n.= (value@ #denominator parameter)
            (value@ #denominator subject))))

(implementation: .public equivalence
  (Equivalence Ratio)
  
  (def: = ..=))

(def: (equalized parameter subject)
  (-> Ratio Ratio [Nat Nat])
  [(n.* (value@ #denominator subject)
        (value@ #numerator parameter))
   (n.* (value@ #denominator parameter)
        (value@ #numerator subject))])

(def: .public (< parameter subject)
  (-> Ratio Ratio Bit)
  (let [[parameter' subject'] (..equalized parameter subject)]
    (n.< parameter' subject')))

(def: .public (<= parameter subject)
  (-> Ratio Ratio Bit)
  (or (< parameter subject)
      (= parameter subject)))

(def: .public (> parameter subject)
  (-> Ratio Ratio Bit)
  (..< subject parameter))

(def: .public (>= parameter subject)
  (-> Ratio Ratio Bit)
  (or (> parameter subject)
      (= parameter subject)))

(implementation: .public order
  (Order Ratio)
  
  (def: &equivalence ..equivalence)
  (def: < ..<))

(def: .public (+ parameter subject)
  (-> Ratio Ratio Ratio)
  (let [[parameter' subject'] (..equalized parameter subject)]
    (normal [(n.+ parameter' subject')
             (n.* (value@ #denominator parameter)
                  (value@ #denominator subject))])))

(def: .public (- parameter subject)
  (-> Ratio Ratio Ratio)
  (let [[parameter' subject'] (..equalized parameter subject)]
    (normal [(n.- parameter' subject')
             (n.* (value@ #denominator parameter)
                  (value@ #denominator subject))])))

(def: .public (* parameter subject)
  (-> Ratio Ratio Ratio)
  (normal [(n.* (value@ #numerator parameter)
                (value@ #numerator subject))
           (n.* (value@ #denominator parameter)
                (value@ #denominator subject))]))

(def: .public (/ parameter subject)
  (-> Ratio Ratio Ratio)
  (let [[parameter' subject'] (..equalized parameter subject)]
    (normal [subject' parameter'])))

(def: .public (% parameter subject)
  (-> Ratio Ratio Ratio)
  (let [[parameter' subject'] (..equalized parameter subject)
        quot (n./ parameter' subject')]
    (..- (revised@ #numerator (n.* quot) parameter)
         subject)))

(def: .public (reciprocal (^slots [#numerator #denominator]))
  (-> Ratio Ratio)
  {#numerator denominator
   #denominator numerator})

(def: separator ":")

(implementation: .public codec
  (Codec Text Ratio)
  
  (def: (encode (^slots [#numerator #denominator]))
    ($_ text\compose (n\encode numerator) ..separator (n\encode denominator)))

  (def: (decode input)
    (case (text.split_by ..separator input)
      (#.Some [num denom])
      (do try.monad
        [numerator (n\decode num)
         denominator (n\decode denom)]
        (in (normal {#numerator numerator
                     #denominator denominator})))
      
      #.None
      (#.Left (text\compose "Invalid syntax for ratio: " input)))))

(template [<identity> <compose> <name>]
  [(implementation: .public <name>
     (Monoid Ratio)

     (def: identity (..ratio <identity>))
     (def: compose <compose>))]
  
  [0 ..+ addition]
  [1 ..* multiplication]
  )
