(.module:
  [library
   [lux (#- and or not false true)
    [abstract
     [equivalence (#+ Equivalence)]
     [hash (#+ Hash)]
     [monoid (#+ Monoid)]]
    [control
     ["." try]]]]
  [//
   ["n" nat]])

(def: .public bits_per_byte
  8)

(def: .public bytes_per_i64
  8)

(def: .public width
  Nat
  (n.* ..bits_per_byte
       ..bytes_per_i64))

(template [<parameter_type> <name> <op> <doc>]
  [(def: .public (<name> parameter subject)
     {#.doc <doc>}
     (All [s] (-> <parameter_type> (I64 s) (I64 s)))
     (<op> parameter subject))]

  [(I64 Any) or          "lux i64 or"          "Bitwise or."]
  [(I64 Any) xor         "lux i64 xor"         "Bitwise xor."]
  [(I64 Any) and         "lux i64 and"         "Bitwise and."]
  
  [Nat       left_shifted  "lux i64 left-shift"  "Bitwise left-shift."]
  [Nat       right_shifted "lux i64 right-shift" "Unsigned/logic bitwise right-shift."]
  )

... https://en.wikipedia.org/wiki/Mask_(computing)
(type: .public Mask
  {#.doc (example "A pattern of bits that can be imposed on I64 values.")}
  I64)

(def: .public (bit position)
  {#.doc (example "A mask with only a specific bit set.")}
  (-> Nat Mask)
  (|> 1 .i64 (..left_shifted (n.% ..width position))))

(def: .public sign
  {#.doc (example "A mask for the sign bit of ints.")}
  Mask
  (..bit (dec ..width)))

(def: .public not
  {#.doc "Bitwise negation."}
  (All [s] (-> (I64 s) (I64 s)))
  (..xor (.i64 (dec 0))))

(def: .public false
  Mask
  (.i64 0))

(def: .public true
  Mask
  (..not ..false))

(def: .public (mask amount_of_bits)
  {#.doc (example "Mask a block of bits of the specified size.")}
  (-> Nat Mask)
  (case amount_of_bits
    0 ..false
    bits (case (n.% ..width bits)
           0 ..true
           bits (|> 1 .i64 (..left_shifted (n.% ..width bits)) .dec))))

(def: (with_shift shift value)
  (-> Nat Nat Nat)
  (|> value (right_shifted shift) (n.+ value)))

(def: .public (ones subject)
  {#.doc "Count the number of 1s in a bit-map."}
  (-> (I64 Any) Nat)
  (let [ones' (n.- (|> subject (right_shifted 1) (..and 6148914691236517205) i64)
                   (i64 subject))]
    (|> ones'
        (right_shifted 2) (..and 3689348814741910323) (n.+ (..and 3689348814741910323 ones'))
        (with_shift 4) (..and 1085102592571150095)
        (with_shift 8)
        (with_shift 16)
        (with_shift 32)
        (..and 127))))

(def: .public (zero index input)
  {#.doc "Clear bit at the given index."}
  (All [s] (-> Nat (I64 s) (I64 s)))
  (|> index ..bit ..not (..and input)))

(template [<name> <op> <doc>]
  [(def: .public (<name> index input)
     {#.doc <doc>}
     (All [s] (-> Nat (I64 s) (I64 s)))
     (|> index ..bit (<op> input)))]

  [one     ..or  "Set bit at given index."]
  [flipped ..xor "Flip bit at given index."]
  )

(def: .public (one? index input)
  (-> Nat (I64 Any) Bit)
  (|> input (:as I64) (..and (..bit index)) (n.= 0) .not))

(def: .public (zero? index input)
  (-> Nat (I64 Any) Bit)
  (.not (..one? index input)))

(template [<name> <forward> <backward>]
  [(def: .public (<name> distance input)
     (All [s] (-> Nat (I64 s) (I64 s)))
     (..or (<forward> distance input)
           (<backward> (n.- (n.% ..width distance) ..width) input)))]

  [left_rotated  ..left_shifted  ..right_shifted]
  [right_rotated ..right_shifted ..left_shifted]
  )

(def: .public (region offset size)
  {#.doc (example "A mask for a block of bits of the given size, starting at the given offset.")}
  (-> Nat Nat Mask)
  (..left_rotated offset (..mask size)))

(implementation: .public equivalence
  (All [a] (Equivalence (I64 a)))

  (def: (= reference sample)
    ("lux i64 =" reference sample)))

(implementation: .public hash
  (All [a] (Hash (I64 a)))

  (def: &equivalence ..equivalence)

  (def: hash .nat))

(template [<monoid> <identity> <compose>]
  [(implementation: .public <monoid>
     (All [a] (Monoid (I64 a)))

     (def: identity <identity>)
     (def: compose <compose>))]

  [disjunction ..false ..or]
  [conjunction ..true ..and]
  )

(def: .public reversed
  (All [a] (-> (I64 a) (I64 a)))
  (let [swapper (: (-> Nat (All [a] (-> (I64 a) (I64 a))))
                   (function (_ power)
                     (let [size (..left_shifted power 1)
                           repetitions (: (-> Nat Text Text)
                                          (function (_ times char)
                                            (loop [iterations 1
                                                   output char]
                                              (if (n.< times iterations)
                                                (recur (inc iterations)
                                                       ("lux text concat" char output))
                                                output))))
                           pattern (repetitions (n./ (n.+ size size) ..width)
                                                ("lux text concat"
                                                 (repetitions size "1")
                                                 (repetitions size "0")))

                           high (try.trusted (\ n.binary decode pattern))
                           low (..right_rotated size high)]
                       (function (_ value)
                         (..or (..right_shifted size (..and high value))
                               (..left_shifted size (..and low value)))))))
        
        swap/01 (swapper 0)
        swap/02 (swapper 1)
        swap/04 (swapper 2)
        swap/08 (swapper 3)
        swap/16 (swapper 4)
        swap/32 (swapper 5)]
    (|>> swap/32
         swap/16
         swap/08
         swap/04
         swap/02
         swap/01)))

(interface: .public (Sub size)
  {#.doc (example "A sub-space of I64 with a reduce amount of bits.")}
  
  (: (Equivalence (I64 size))
     &equivalence)
  (: Nat
     width)
  (: (-> I64 (I64 size))
     narrow)
  (: (-> (I64 size) I64)
     widen))

(def: .public (sub width)
  {#.doc (example "Given a width in the interval (0,64), yields an implementation for integers of that width.")}
  (Ex [size] (-> Nat (Maybe (Sub size))))
  (if (.and (n.> 0 width)
            (n.< ..width width))
    (let [sign_shift (n.- width ..width)
          sign (..bit (dec width))
          mantissa (..mask (dec width))
          co_mantissa (..xor (.i64 -1) mantissa)]
      (#.Some (: Sub
                 (implementation
                  (def: &equivalence ..equivalence)
                  (def: width width)
                  (def: (narrow value)
                    (..or (|> value (..and ..sign) (..right_shifted sign_shift))
                          (|> value (..and mantissa))))
                  (def: (widen value)
                    (.i64 (case (.nat (..and sign value))
                            0 value
                            _ (..or co_mantissa value))))))))
    #.None))
