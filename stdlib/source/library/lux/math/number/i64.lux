(.using
 [library
  [lux {"-" and or not false true}
   [abstract
    [equivalence {"+" Equivalence}]
    [hash {"+" Hash}]
    [monoid {"+" Monoid}]]
   [control
    ["[0]" try]]]]
 [//
  ["n" nat]])

(def: .public bits_per_byte
  8)

(def: .public bytes_per_i64
  8)

(def: .public width
  Nat
  (n.* ..bits_per_byte
       ..bytes_per_i64))

(template [<parameter_type> <name> <op>]
  [(def: .public (<name> parameter subject)
     (All (_ s) (-> <parameter_type> (I64 s) (I64 s)))
     (<op> parameter subject))]

  [(I64 Any) or          "lux i64 or"]
  [(I64 Any) xor         "lux i64 xor"]
  [(I64 Any) and         "lux i64 and"]
  
  [Nat       left_shifted  "lux i64 left-shift"]
  [Nat       right_shifted "lux i64 right-shift"]
  )

... https://en.wikipedia.org/wiki/Mask_(computing)
(type: .public Mask
  I64)

(def: .public (bit position)
  (-> Nat Mask)
  (|> 1 .i64 (..left_shifted (n.% ..width position))))

(def: .public sign
  Mask
  (..bit (-- ..width)))

(def: .public not
  (All (_ s) (-> (I64 s) (I64 s)))
  (..xor (.i64 (-- 0))))

(def: .public false
  Mask
  (.i64 0))

(def: .public true
  Mask
  (..not ..false))

(def: .public (mask amount_of_bits)
  (-> Nat Mask)
  (case amount_of_bits
    0 ..false
    bits (case (n.% ..width bits)
           0 ..true
           bits (|> 1 .i64 (..left_shifted (n.% ..width bits)) .--))))

(def: (with_shift shift value)
  (-> Nat Nat Nat)
  (|> value (right_shifted shift) (n.+ value)))

(def: .public (ones it)
  (-> (I64 Any) Nat)
  (let [ones' (n.- (|> it (right_shifted 1) (..and 6148914691236517205) i64)
                   (i64 it))]
    (|> ones'
        (right_shifted 2) (..and 3689348814741910323) (n.+ (..and 3689348814741910323 ones'))
        (with_shift 4) (..and 1085102592571150095)
        (with_shift 8)
        (with_shift 16)
        (with_shift 32)
        (..and 127))))

(def: .public (zero index input)
  (All (_ s) (-> Nat (I64 s) (I64 s)))
  (|> index ..bit ..not (..and input)))

(template [<name> <op>]
  [(def: .public (<name> index input)
     (All (_ s) (-> Nat (I64 s) (I64 s)))
     (|> index ..bit (<op> input)))]

  [one     ..or]
  [flipped ..xor]
  )

(def: .public (one? index input)
  (-> Nat (I64 Any) Bit)
  (|> input .i64 (..and (..bit index)) (n.= 0) .not))

(def: .public (zero? index input)
  (-> Nat (I64 Any) Bit)
  (.not (..one? index input)))

(template [<name> <forward> <backward>]
  [(def: .public (<name> distance input)
     (All (_ s) (-> Nat (I64 s) (I64 s)))
     (..or (<forward> distance input)
           (<backward> (n.- (n.% ..width distance) ..width) input)))]

  [left_rotated  ..left_shifted  ..right_shifted]
  [right_rotated ..right_shifted ..left_shifted]
  )

(def: .public (region offset size)
  (-> Nat Nat Mask)
  (..left_rotated offset (..mask size)))

(implementation: .public equivalence
  (All (_ a) (Equivalence (I64 a)))

  (def: (= reference sample)
    ("lux i64 =" reference sample)))

(implementation: .public hash
  (All (_ a) (Hash (I64 a)))

  (def: &equivalence ..equivalence)

  (def: hash (|>> .nat)))

(template [<monoid> <identity> <composite>]
  [(implementation: .public <monoid>
     (All (_ a) (Monoid (I64 a)))

     (def: identity <identity>)
     (def: composite <composite>))]

  [disjunction ..false ..or]
  [conjunction ..true ..and]
  )

(def: .public reversed
  (All (_ a) (-> (I64 a) (I64 a)))
  (let [swapper (is (-> Nat (All (_ a) (-> (I64 a) (I64 a))))
                    (function (_ power)
                      (let [size (..left_shifted power 1)
                            repetitions (is (-> Nat Text Text)
                                            (function (_ times char)
                                              (loop (again [iterations 1
                                                            output char])
                                                (if (n.< times iterations)
                                                  (again (++ iterations)
                                                         ("lux text concat" char output))
                                                  output))))
                            pattern (repetitions (n./ (n.+ size size) ..width)
                                                 ("lux text concat"
                                                  (repetitions size "1")
                                                  (repetitions size "0")))

                            high (try.trusted (# n.binary decoded pattern))
                            low (..right_rotated size high)]
                        (function (_ value)
                          (..or (..right_shifted size (..and high value))
                                (..left_shifted size (..and low value)))))))
        
        swap_01 (swapper 0)
        swap_02 (swapper 1)
        swap_04 (swapper 2)
        swap_08 (swapper 3)
        swap_16 (swapper 4)
        swap_32 (swapper 5)]
    (|>> swap_32
         swap_16
         swap_08
         swap_04
         swap_02
         swap_01)))

(type: .public (Sub size)
  (Interface
   (is (Equivalence (I64 size))
       &equivalence)
   (is Nat
       bits)
   (is (-> I64 (I64 size))
       narrow)
   (is (-> (I64 size) I64)
       wide)))

(def: .public (sub width)
  (Ex (_ size) (-> Nat (Maybe (Sub size))))
  (if (.and (n.> 0 width)
            (n.< ..width width))
    (let [sign_shift (n.- width ..width)
          sign (..bit (-- width))
          mantissa (..mask (-- width))
          co_mantissa (..xor (.i64 -1) mantissa)]
      {.#Some (is Sub
                  (implementation
                   (def: &equivalence ..equivalence)
                   (def: bits width)
                   (def: (narrow value)
                     (..or (|> value (..and ..sign) (..right_shifted sign_shift))
                           (|> value (..and mantissa))))
                   (def: (wide value)
                     (.i64 (case (.nat (..and sign value))
                             0 value
                             _ (..or co_mantissa value))))))})
    {.#None}))
