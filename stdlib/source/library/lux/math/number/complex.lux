... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except)
   [abstract
    [equivalence (.only Equivalence)]
    [format (.only Format)]
    [monad (.only do)]]
   [control
    ["<>" projection]
    ["[0]" maybe]
    ["[0]" try]]
   [data
    ["[0]" text]
    [collection
     ["[0]" list (.use "[1]#[0]" functor)]]]
   [math
    [number
     ["d" dec]
     ["[0]" int]]
    [geometry
     ["[0]" circle]
     ["[0]" hyperbola]]]
   [meta
    ["[0]" code
     ["<[1]>" \\projection]]
    [macro
     ["[0]" syntax]]]]]
 [///
  [arithmetic (.only Arithmetic)]])

(every .public Complex
  (Record
   [#real Dec
    #imaginary Dec]))

(the .public complex
  (syntax.macro (_ [real <code>.any
                    ?imaginary (<>.maybe <code>.any)])
    (in (list (` [..#real (, real)
                  ..#imaginary (, (maybe.else (' +0.0) ?imaginary))])))))

(the .public i
  Complex
  (..complex +0.0 +1.0))

(the .public +one
  Complex
  (..complex +1.0 +0.0))

(the .public -one
  Complex
  (..complex -1.0 +0.0))

(the .public zero
  Complex
  (..complex +0.0 +0.0))

(the .public (not_a_number? complex)
  (-> Complex
      Bit)
  (or (d.not_a_number? (its #real complex))
      (d.not_a_number? (its #imaginary complex))))

(the .public (= param input)
  (-> Complex Complex
      Bit)
  (and (d.= (its #real param)
            (its #real input))
       (d.= (its #imaginary param)
            (its #imaginary input))))

(with_template [<name> <op>]
  [(the .public (<name> param input)
     (-> Complex Complex
         Complex)
     [#real (<op> (its #real param)
                  (its #real input))
      #imaginary (<op> (its #imaginary param)
                       (its #imaginary input))])]

  [+ d.+]
  [- d.-]
  )

(the .public equivalence
  (Equivalence Complex)
  (implementation
   (the = ..=)))

(with_template [<name> <transform>]
  [(the .public <name>
     (-> Complex
         Complex)
     (|>> (revised #real <transform>)
          (revised #imaginary <transform>)))]

  [opposite d.opposite]
  [signum d.signum]
  )

(the .public conjugate
  (-> Complex
      Complex)
  (revised #imaginary d.opposite))

(the .public (*' param input)
  (-> Dec Complex
      Complex)
  [#real (d.* param
              (its #real input))
   #imaginary (d.* param
                   (its #imaginary input))])

(the .public (* param input)
  (-> Complex Complex
      Complex)
  [#real (d.- (d.* (its #imaginary param)
                   (its #imaginary input))
              (d.* (its #real param)
                   (its #real input)))
   #imaginary (d.+ (d.* (its #real param)
                        (its #imaginary input))
                   (d.* (its #imaginary param)
                        (its #real input)))])

(the .public (/ param input)
  (-> Complex Complex
      Complex)
  (let [(open "/[0]") param]
    (if (d.< (d.abs /#imaginary)
             (d.abs /#real))
      (let [quot (d./ /#imaginary /#real)
            denom (|> /#real (d.* quot) (d.+ /#imaginary))]
        [..#real (|> (its ..#real input) (d.* quot) (d.+ (its ..#imaginary input)) (d./ denom))
         ..#imaginary (|> (its ..#imaginary input) (d.* quot) (d.- (its ..#real input)) (d./ denom))])
      (let [quot (d./ /#real /#imaginary)
            denom (|> /#imaginary (d.* quot) (d.+ /#real))]
        [..#real (|> (its ..#imaginary input) (d.* quot) (d.+ (its ..#real input)) (d./ denom))
         ..#imaginary (|> (its ..#imaginary input) (d.- (d.* quot (its ..#real input))) (d./ denom))]))))

(the .public (/' param subject)
  (-> Dec Complex
      Complex)
  (let [(open "/[0]") subject]
    [..#real (d./ param /#real)
     ..#imaginary (d./ param /#imaginary)]))

(the .public (% param input)
  (-> Complex Complex
      Complex)
  (let [scaled (/ param input)
        quotient (|> scaled
                     (revised #real d.floor)
                     (revised #imaginary d.floor))]
    (- (* quotient param)
       input)))

(the .public arithmetic
  (Arithmetic Complex)
  (implementation
   (the + ..+)
   (the - ..-)
   (the * ..*)
   (the / ../)))

(the .public (cos subject)
  (-> Complex
      Complex)
  (let [(open "/[0]") subject]
    [..#real (d.* (hyperbola.co_sine /#imaginary)
                  (circle.cos /#real))
     ..#imaginary (d.opposite (d.* (hyperbola.sine /#imaginary)
                                   (circle.sin /#real)))]))

(the .public (cosh subject)
  (-> Complex
      Complex)
  (let [(open "/[0]") subject]
    [..#real (d.* (circle.cos /#imaginary)
                  (hyperbola.co_sine /#real))
     ..#imaginary (d.* (circle.sin /#imaginary)
                       (hyperbola.sine /#real))]))

(the .public (sin subject)
  (-> Complex
      Complex)
  (let [(open "/[0]") subject]
    [..#real (d.* (hyperbola.co_sine /#imaginary)
                  (circle.sin /#real))
     ..#imaginary (d.* (hyperbola.sine /#imaginary)
                       (circle.cos /#real))]))

(the .public (sinh subject)
  (-> Complex
      Complex)
  (let [(open "/[0]") subject]
    [..#real (d.* (circle.cos /#imaginary)
                  (hyperbola.sine /#real))
     ..#imaginary (d.* (circle.sin /#imaginary)
                       (hyperbola.co_sine /#real))]))

(the .public (tan subject)
  (-> Complex
      Complex)
  (let [(open "/[0]") subject
        r2 (d.* +2.0 /#real)
        i2 (d.* +2.0 /#imaginary)
        d (d.+ (circle.cos r2) (hyperbola.co_sine i2))]
    [..#real (d./ d (circle.sin r2))
     ..#imaginary (d./ d (hyperbola.sine i2))]))

(the .public (tanh subject)
  (-> Complex
      Complex)
  (let [(open "/[0]") subject
        r2 (d.* +2.0 /#real)
        i2 (d.* +2.0 /#imaginary)
        d (d.+ (hyperbola.co_sine r2) (circle.cos i2))]
    [..#real (d./ d (hyperbola.sine r2))
     ..#imaginary (d./ d (circle.sin i2))]))

(the .public (abs subject)
  (-> Complex
      Dec)
  (let [(open "/[0]") subject]
    (if (d.< (d.abs /#imaginary)
             (d.abs /#real))
      (if (d.= +0.0 /#imaginary)
        (d.abs /#real)
        (let [q (d./ /#imaginary /#real)]
          (d.* (d.pow +0.5 (d.+ +1.0 (d.* q q)))
               (d.abs /#imaginary))))
      (if (d.= +0.0 /#real)
        (d.abs /#imaginary)
        (let [q (d./ /#real /#imaginary)]
          (d.* (d.pow +0.5 (d.+ +1.0 (d.* q q)))
               (d.abs /#real)))))))

(the .public (exp subject)
  (-> Complex
      Complex)
  (let [(open "/[0]") subject
        r_exp (d.exp /#real)]
    [..#real (d.* r_exp (circle.cos /#imaginary))
     ..#imaginary (d.* r_exp (circle.sin /#imaginary))]))

(the .public (log subject)
  (-> Complex
      Complex)
  (let [(open "/[0]") subject]
    [..#real (|> subject ..abs d.log)
     ..#imaginary (circle.atan_2 /#real /#imaginary)]))

(with_template [<name> <type> <op>]
  [(the .public (<name> param input)
     (-> <type> Complex
         Complex)
     (|> input log (<op> param) exp))]

  [pow  Complex ..*]
  [pow' Dec     ..*']
  )

(the (with_sign sign magnitude)
  (-> Dec Dec
      Dec)
  (d.* (d.signum sign) magnitude))

(the .public (root_2 input)
  (-> Complex
      Complex)
  (let [(open "/[0]") input
        t (|> input ..abs (d.+ (d.abs /#real)) (d./ +2.0) (d.pow +0.5))]
    (if (d.< +0.0 /#real)
      [..#real (d./ (d.* +2.0 t)
                    (d.abs /#imaginary))
       ..#imaginary (d.* t (..with_sign /#imaginary +1.0))]
      [..#real t
       ..#imaginary (d./ (d.* +2.0 t)
                         /#imaginary)])))

(the (root_2-1z input)
  (-> Complex
      Complex)
  (|> (complex +1.0) (- (* input input)) ..root_2))

(the .public (reciprocal (open "/[0]"))
  (-> Complex
      Complex)
  (if (d.< (d.abs /#imaginary)
           (d.abs /#real))
    (let [q (d./ /#imaginary /#real)
          scale (d./ (|> /#real (d.* q) (d.+ /#imaginary))
                     +1.0)]
      [..#real (d.* q scale)
       ..#imaginary (d.opposite scale)])
    (let [q (d./ /#real /#imaginary)
          scale (d./ (|> /#imaginary (d.* q) (d.+ /#real))
                     +1.0)]
      [..#real scale
       ..#imaginary (|> scale d.opposite (d.* q))])))

(the .public (acos input)
  (-> Complex
      Complex)
  (|> input
      (..+ (|> input ..root_2-1z (..* ..i)))
      ..log
      (..* (..opposite ..i))))

(the .public (asin input)
  (-> Complex
      Complex)
  (|> input
      ..root_2-1z
      (..+ (..* ..i input))
      ..log
      (..* (..opposite ..i))))

(the .public (atan input)
  (-> Complex
      Complex)
  (|> input
      (..+ ..i)
      (../ (..- input ..i))
      ..log
      (..* (../ (..complex +2.0) ..i))))

(the .public (argument (open "/[0]"))
  (-> Complex
      Dec)
  (circle.atan_2 /#real /#imaginary))

(the .public (roots nth input)
  (-> Nat Complex
      (List Complex))
  (when nth
    0 (list)
    _ (let [r_nth (|> nth .int int.dec)
            nth_root_of_abs (|> input ..abs (d.pow (d./ r_nth +1.0)))
            nth_phi (|> input ..argument (d./ r_nth))
            slice (d./ r_nth circle.tau)]
        (|> (list.indices nth)
            (list#each (function (_ nth')
                         (let [inner (|> nth' .int int.dec
                                         (d.* slice)
                                         (d.+ nth_phi))
                               real (d.* nth_root_of_abs
                                         (circle.cos inner))
                               imaginary (d.* nth_root_of_abs
                                              (circle.sin inner))]
                           [..#real real
                            ..#imaginary imaginary])))))))

(the .public (approximately? margin_of_error standard value)
  (-> Dec Complex Complex
      Bit)
  (and (d.approximately? margin_of_error
                         (its ..#real standard)
                         (its ..#real value))
       (d.approximately? margin_of_error
                         (its ..#imaginary standard)
                         (its ..#imaginary value))))

(the .public (injection it)
  (-> Complex
      Text)
  (.text_composite# (of d.decimal injection (its ..#real it))
                    " " (of d.decimal injection (its ..#imaginary it)) "i"))

(the .public format
  (Format Text Complex)
  (implementation
   (the injection ..injection)
   (the (projection it)
     (when (text.split_by " " it)
       {.#Some [real imaginary]}
       (do try.monad
         [real (of d.decimal projection real)
          imaginary (of d.decimal projection (text.replaced_once "i" "" imaginary))]
         (in [#real real
              #imaginary imaginary]))

       {.#None}
       (do try.monad
         [real (of d.decimal projection it)]
         (in [#real real
              #imaginary +0.0]))))))

... https://en.wikipedia.org/wiki/Polar_coordinate_system
(the (square it)
  (-> Dec
      Dec)
  (d.* it it))

(the .public (magnitude it)
  (-> Complex
      Dec)
  (d.root_2 (d.+ (square (its #real it))
                 (square (its #imaginary it)))))

(the .public (phase it)
  (-> Complex
      Dec)
  (circle.atan_2 (its #real it)
                 (its #imaginary it)))

(the .public (polar magnitude phase)
  (-> Dec Dec
      Complex)
  [#real (d.* magnitude (circle.cos phase))
   #imaginary (d.* magnitude (circle.sin phase))])

... https://en.wikipedia.org/wiki/Number#Classification
(alias [C]
       ..Complex)
