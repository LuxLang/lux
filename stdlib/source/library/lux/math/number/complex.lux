(.module:
  [library
   [lux "*"
    ["[0]" math]
    [abstract
     [equivalence {"+" [Equivalence]}]
     [codec {"+" [Codec]}]
     ["M" monad {"+" [Monad do]}]]
    [control
     ["[0]" maybe]
     ["<>" parser
      ["<[0]>" code {"+" [Parser]}]]]
    [data
     [collection
      ["[0]" list ("[1]#[0]" functor)]]]
    [macro
     [syntax {"+" [syntax:]}]
     ["[0]" code]]
    [math
     [number
      ["n" nat]
      ["f" frac]
      ["[0]" int]]]]])

(type: .public Complex
  (Record
   [#real Frac
    #imaginary Frac]))

(syntax: .public (complex [real <code>.any
                           ?imaginary (<>.maybe <code>.any)])
  (in (list (` [..#real (~ real)
                ..#imaginary (~ (maybe.else (' +0.0) ?imaginary))]))))

(def: .public i
  Complex
  (..complex +0.0 +1.0))

(def: .public +one
  Complex
  (..complex +1.0 +0.0))

(def: .public -one
  Complex
  (..complex -1.0 +0.0))

(def: .public zero
  Complex
  (..complex +0.0 +0.0))

(def: .public (not_a_number? complex)
  (-> Complex Bit)
  (or (f.not_a_number? (value@ #real complex))
      (f.not_a_number? (value@ #imaginary complex))))

(def: .public (= param input)
  (-> Complex Complex Bit)
  (and (f.= (value@ #real param)
            (value@ #real input))
       (f.= (value@ #imaginary param)
            (value@ #imaginary input))))

(template [<name> <op>]
  [(def: .public (<name> param input)
     (-> Complex Complex Complex)
     [#real (<op> (value@ #real param)
                  (value@ #real input))
      #imaginary (<op> (value@ #imaginary param)
                       (value@ #imaginary input))])]

  [+ f.+]
  [- f.-]
  )

(implementation: .public equivalence
  (Equivalence Complex)
  
  (def: = ..=))

(template [<name> <transform>]
  [(def: .public <name>
     (-> Complex Complex)
     (|>> (revised@ #real <transform>)
          (revised@ #imaginary <transform>)))]

  [opposite f.opposite]
  [signum f.signum]
  )

(def: .public conjugate
  (-> Complex Complex)
  (revised@ #imaginary f.opposite))

(def: .public (*' param input)
  (-> Frac Complex Complex)
  [#real (f.* param
              (value@ #real input))
   #imaginary (f.* param
                   (value@ #imaginary input))])

(def: .public (* param input)
  (-> Complex Complex Complex)
  [#real (f.- (f.* (value@ #imaginary param)
                   (value@ #imaginary input))
              (f.* (value@ #real param)
                   (value@ #real input)))
   #imaginary (f.+ (f.* (value@ #real param)
                        (value@ #imaginary input))
                   (f.* (value@ #imaginary param)
                        (value@ #real input)))])

(def: .public (/ param input)
  (-> Complex Complex Complex)
  (let [(^slots [#real #imaginary]) param]
    (if (f.< (f.abs #imaginary)
             (f.abs #real))
      (let [quot (f./ #imaginary #real)
            denom (|> #real (f.* quot) (f.+ #imaginary))]
        [..#real (|> (value@ ..#real input) (f.* quot) (f.+ (value@ ..#imaginary input)) (f./ denom))
         ..#imaginary (|> (value@ ..#imaginary input) (f.* quot) (f.- (value@ ..#real input)) (f./ denom))])
      (let [quot (f./ #real #imaginary)
            denom (|> #imaginary (f.* quot) (f.+ #real))]
        [..#real (|> (value@ ..#imaginary input) (f.* quot) (f.+ (value@ ..#real input)) (f./ denom))
         ..#imaginary (|> (value@ ..#imaginary input) (f.- (f.* quot (value@ ..#real input))) (f./ denom))]))))

(def: .public (/' param subject)
  (-> Frac Complex Complex)
  (let [(^slots [#real #imaginary]) subject]
    [..#real (f./ param #real)
     ..#imaginary (f./ param #imaginary)]))

(def: .public (% param input)
  (-> Complex Complex Complex)
  (let [scaled (/ param input)
        quotient (|> scaled
                     (revised@ #real math.floor)
                     (revised@ #imaginary math.floor))]
    (- (* quotient param)
       input)))

(def: .public (cos subject)
  (-> Complex Complex)
  (let [(^slots [#real #imaginary]) subject]
    [..#real (f.* (math.cosh #imaginary)
                  (math.cos #real))
     ..#imaginary (f.opposite (f.* (math.sinh #imaginary)
                                   (math.sin #real)))]))

(def: .public (cosh subject)
  (-> Complex Complex)
  (let [(^slots [#real #imaginary]) subject]
    [..#real (f.* (math.cos #imaginary)
                  (math.cosh #real))
     ..#imaginary (f.* (math.sin #imaginary)
                       (math.sinh #real))]))

(def: .public (sin subject)
  (-> Complex Complex)
  (let [(^slots [#real #imaginary]) subject]
    [..#real (f.* (math.cosh #imaginary)
                  (math.sin #real))
     ..#imaginary (f.* (math.sinh #imaginary)
                       (math.cos #real))]))

(def: .public (sinh subject)
  (-> Complex Complex)
  (let [(^slots [#real #imaginary]) subject]
    [..#real (f.* (math.cos #imaginary)
                  (math.sinh #real))
     ..#imaginary (f.* (math.sin #imaginary)
                       (math.cosh #real))]))

(def: .public (tan subject)
  (-> Complex Complex)
  (let [(^slots [#real #imaginary]) subject
        r2 (f.* +2.0 #real)
        i2 (f.* +2.0 #imaginary)
        d (f.+ (math.cos r2) (math.cosh i2))]
    [..#real (f./ d (math.sin r2))
     ..#imaginary (f./ d (math.sinh i2))]))

(def: .public (tanh subject)
  (-> Complex Complex)
  (let [(^slots [#real #imaginary]) subject
        r2 (f.* +2.0 #real)
        i2 (f.* +2.0 #imaginary)
        d (f.+ (math.cosh r2) (math.cos i2))]
    [..#real (f./ d (math.sinh r2))
     ..#imaginary (f./ d (math.sin i2))]))

(def: .public (abs subject)
  (-> Complex Frac)
  (let [(^slots [#real #imaginary]) subject]
    (if (f.< (f.abs #imaginary)
             (f.abs #real))
      (if (f.= +0.0 #imaginary)
        (f.abs #real)
        (let [q (f./ #imaginary #real)]
          (f.* (math.pow +0.5 (f.+ +1.0 (f.* q q)))
               (f.abs #imaginary))))
      (if (f.= +0.0 #real)
        (f.abs #imaginary)
        (let [q (f./ #real #imaginary)]
          (f.* (math.pow +0.5 (f.+ +1.0 (f.* q q)))
               (f.abs #real)))))))

(def: .public (exp subject)
  (-> Complex Complex)
  (let [(^slots [#real #imaginary]) subject
        r_exp (math.exp #real)]
    [..#real (f.* r_exp (math.cos #imaginary))
     ..#imaginary (f.* r_exp (math.sin #imaginary))]))

(def: .public (log subject)
  (-> Complex Complex)
  (let [(^slots [#real #imaginary]) subject]
    [..#real (|> subject ..abs math.log)
     ..#imaginary (math.atan/2 #real #imaginary)]))

(template [<name> <type> <op>]
  [(def: .public (<name> param input)
     (-> <type> Complex Complex)
     (|> input log (<op> param) exp))]

  [pow  Complex ..*]
  [pow' Frac    ..*']
  )

(def: (with_sign sign magnitude)
  (-> Frac Frac Frac)
  (f.* (f.signum sign) magnitude))

(def: .public (root/2 input)
  (-> Complex Complex)
  (let [(^slots [#real #imaginary]) input
        t (|> input ..abs (f.+ (f.abs #real)) (f./ +2.0) (math.pow +0.5))]
    (if (f.< +0.0 #real)
      [..#real (f./ (f.* +2.0 t)
                    (f.abs #imaginary))
       ..#imaginary (f.* t (..with_sign #imaginary +1.0))]
      [..#real t
       ..#imaginary (f./ (f.* +2.0 t)
                         #imaginary)])))

(def: (root/2-1z input)
  (-> Complex Complex)
  (|> (complex +1.0) (- (* input input)) ..root/2))

(def: .public (reciprocal (^slots [#real #imaginary]))
  (-> Complex Complex)
  (if (f.< (f.abs #imaginary)
           (f.abs #real))
    (let [q (f./ #imaginary #real)
          scale (f./ (|> #real (f.* q) (f.+ #imaginary))
                     +1.0)]
      [..#real (f.* q scale)
       ..#imaginary (f.opposite scale)])
    (let [q (f./ #real #imaginary)
          scale (f./ (|> #imaginary (f.* q) (f.+ #real))
                     +1.0)]
      [..#real scale
       ..#imaginary (|> scale f.opposite (f.* q))])))

(def: .public (acos input)
  (-> Complex Complex)
  (|> input
      (..+ (|> input ..root/2-1z (..* ..i)))
      ..log
      (..* (..opposite ..i))))

(def: .public (asin input)
  (-> Complex Complex)
  (|> input
      ..root/2-1z
      (..+ (..* ..i input))
      ..log
      (..* (..opposite ..i))))

(def: .public (atan input)
  (-> Complex Complex)
  (|> input
      (..+ ..i)
      (../ (..- input ..i))
      ..log
      (..* (../ (..complex +2.0) ..i))))

(def: .public (argument (^slots [#real #imaginary]))
  (-> Complex Frac)
  (math.atan/2 #real #imaginary))

(def: .public (roots nth input)
  (-> Nat Complex (List Complex))
  (if (n.= 0 nth)
    (list)
    (let [r_nth (|> nth .int int.frac)
          nth_root_of_abs (|> input ..abs (math.pow (f./ r_nth +1.0)))
          nth_phi (|> input ..argument (f./ r_nth))
          slice (|> math.pi (f.* +2.0) (f./ r_nth))]
      (|> (list.indices nth)
          (list#each (function (_ nth')
                       (let [inner (|> nth' .int int.frac
                                       (f.* slice)
                                       (f.+ nth_phi))
                             real (f.* nth_root_of_abs
                                       (math.cos inner))
                             imaginary (f.* nth_root_of_abs
                                            (math.sin inner))]
                         [..#real real
                          ..#imaginary imaginary])))))))

(def: .public (approximately? margin_of_error standard value)
  (-> Frac Complex Complex Bit)
  (and (f.approximately? margin_of_error
                         (value@ ..#real standard)
                         (value@ ..#real value))
       (f.approximately? margin_of_error
                         (value@ ..#imaginary standard)
                         (value@ ..#imaginary value))))
