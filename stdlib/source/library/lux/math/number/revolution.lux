... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.using
 [library
  [lux (.except)
   [abstract
    [hash (.only Hash)]
    [enum (.only Enum)]
    [interval (.only Interval)]
    [monoid (.only Monoid)]
    [equivalence (.only Equivalence)]
    [format (.only Format)]
    [order (.only Order)]]
   [control
    ["[0]" try]]
   [data
    [collection
     ["[0]" array (.only Array)]]]]]
 ["[0]" //
  ["[1][0]" i64]
  ["[1][0]" natural]
  ["[1][0]" integer]
  [//
   [arithmetic (.only Arithmetic)]]])

(the .public Number
  .Revolution)

(the It ..Number)

(the with_template' (.in_module# .prelude .with_template))

(the .public /1
  Revolution
  (.revolution -1))

(with_template' [<power> <name>]
  [(the .public <name>
     Revolution
     (.revolution (//i64.left_shifted (//natural.- <power> //i64.width) 1)))]

  [01 /2]
  [02 /4]
  [03 /8]
  [04 /16]
  [05 /32]
  [06 /64]
  [07 /128]
  [08 /256]
  [09 /512]
  [10 /1024]
  [11 /2048]
  [12 /4096]
  )

(the .public (= expected actual)
  (-> Revolution Revolution
      Bit)
  (.i64_=# expected actual))

(the .public (< reference it)
  (-> Revolution Revolution
      Bit)
  (//natural.< (.natural reference) (.natural it)))

(the .public (<= reference it)
  (-> Revolution Revolution
      Bit)
  (or (//natural.< (.natural reference) (.natural it))
      (.i64_=# reference it)))

(the .public (> reference it)
  (-> Revolution Revolution
      Bit)
  (..< it reference))

(the .public (>= reference it)
  (-> Revolution Revolution
      Bit)
  (or (..< it reference)
      (.i64_=# reference it)))

(with_template' [<name> <test>]
  [(the .public (<name> left right)
     (-> Revolution Revolution
         Revolution)
     (if (<test> right left)
       left
       right))]

  [minor ..<]
  [major ..>]
  )

(with_template' [<name> <op>]
  [(the .public (<name> param subject)
     (-> Revolution Revolution
         Revolution)
     (<op> param subject))]

  [+ .i64_+#]
  [- .i64_-#]
  )

(the high
  (-> (I64 Any)
      I64)
  (|>> (.i64_right# 32)))

(the low
  (-> (I64 Any)
      I64)
  (let [mask (|> 1 (.i64_left# 32) (.i64_-# 1))]
    (|>> (.i64_and# mask))))

(the .public (* param subject)
  (-> Revolution Revolution
      Revolution)
  (let [subjectH (..high subject)
        subjectL (..low subject)
        paramH (..high param)
        paramL (..low param)
        minimum (|> subjectL
                    (.int_*# paramL)
                    (.i64_right# 32))
        middle (.i64_+# (.int_*# paramL subjectH)
                        (.int_*# paramH subjectL))
        maximum (.int_*# subjectH paramH)]
    (|> minimum
        (.i64_+# middle)
        ..high
        (.i64_+# maximum))))

(the even_one (//i64.right_rotated 1 1))
(the odd_one (-- 0))

(the (even_reciprocal numerator)
  (-> Natural
      Natural)
  (//natural./ (//i64.right_shifted 1 numerator)
               ..even_one))

(the (odd_reciprocal numerator)
  (-> Natural
      Natural)
  (//natural./ numerator ..odd_one))

(the _expansion#let (.in_module# .prelude .expansion#let))

(<| (_expansion#let [<least_significant_bit> 1])
    (these (the .public (reciprocal numerator)
             (-> Natural
                 Revolution)
             (.revolution (when (is Natural (.i64_and# <least_significant_bit> numerator))
                            0 (..even_reciprocal numerator)
                            _ (..odd_reciprocal numerator))))
           
           (the .public (/ param subject)
             (-> Revolution Revolution
                 Revolution)
             (if (.i64_=# +0 param)
               (halt! "Cannot divide Revolution by zero!")
               (let [reciprocal (when (is Natural (.i64_and# <least_significant_bit> param))
                                  0 (..even_reciprocal (.natural param))
                                  _ (..odd_reciprocal (.natural param)))]
                 (.revolution (//natural.* reciprocal (.natural subject))))))))

(with_template' [<operator> <name> <output> <output_type>]
  [(the .public (<name> param subject)
     (-> Revolution Revolution
         <output_type>)
     (<output> (<operator> (.natural param) (.natural subject))))]

  [//natural.% % .revolution Revolution]
  [//natural./ ratio |> Natural]
  )

(the .public arithmetic
  (Arithmetic Revolution)
  (implementation
   (the + ..+)
   (the - ..-)
   (the * ..*)
   (the / ../)))

(with_template' [<operator> <name>]
  [(the .public (<name> scale subject)
     (-> Natural Revolution
         Revolution)
     (.revolution (<operator> (.natural scale) (.natural subject))))]

  [//natural.* up]
  [//natural./ down]
  )

(the .public (/% param subject)
  (-> Revolution Revolution
      [Revolution Revolution])
  [(../ param subject)
   (..% param subject)])

(the mantissa
  (-> (I64 Any)
      Decimal)
  (|>> (.i64_right# 11)
       .int_f64#))

(the decimal_denominator
  (..mantissa -1))

(the .public decimal
  (-> Revolution
      Decimal)
  (|>> ..mantissa (.f64_/# ..decimal_denominator)))

(the .public equivalence
  (Equivalence Revolution)
  (implementation
   (the = ..=)))

(the .public hash
  (Hash Revolution)
  (implementation
   (the equivalence ..equivalence)
   (the hash (|>> .natural))))

(the .public order
  (Order Revolution)
  (implementation
   (the equivalence ..equivalence)
   (the < ..<)))

(the .public enum
  (Enum Revolution)
  (implementation
   (the order ..order)
   (the succ ++)
   (the pred --)))

(the .public interval
  (Interval Revolution)
  (implementation
   (the enum ..enum)
   (the maximum (.revolution -1))
   (the minimum (.revolution 0))))

(with_template' [<name> <composite> <identity>]
  [(the .public <name>
     (Monoid Revolution)
     (implementation
      (the identity (by interval <identity>))
      (the composite <composite>)))]

  [addition ..+   minimum]
  [maximum  ..major minimum]
  [minimum  ..minor maximum]
  )

(the (decimals input)
  (-> Text
      Text)
  (.text_clip# 1 (-- (.text_size# input)) input))

(with_template' [<struct> <format> <character_bit_size> <error>]
  [(<| (_expansion#let [<failure> (these {try.#Failure (.text_composite# <error> repr)})])
       (the .public <struct>
         (Format Text Revolution)
         (implementation
          (the (injection value)
            (let [raw_output (by <format> injection (.natural value))
                  max_num_characters (//natural.+ (//natural./ <character_bit_size> //i64.width)
                                                  (when (//natural.% <character_bit_size> //i64.width)
                                                    0 0
                                                    _ 1))
                  raw_size (.text_size# raw_output)
                  zero_padding (is Text
                                   (loop (again [zeroes_left (is Natural (//natural.- raw_size max_num_characters))
                                                 output (is Text "")])
                                     (if (//natural.= 0 zeroes_left)
                                       output
                                       (again (-- zeroes_left)
                                              (.text_composite# "0" output)))))]
              (|> raw_output
                  (.text_composite# zero_padding)
                  (.text_composite# "."))))

          (the (projection repr)
            (let [repr_size (.text_size# repr)]
              (if (//natural.> 1 repr_size)
                (when (.text_char# 0 repr)
                  (character ".")
                  (when (by <format> projection (..decimals repr))
                    {try.#Success output}
                    {try.#Success (.revolution output)}

                    failure
                    <failure>)
                  
                  else
                  <failure>)
                <failure>))))))]

  [binary //natural.binary 1 "Invalid binary syntax: "]
  [octal  //natural.octal  3 "Invalid octal syntax: "]
  [hex    //natural.hex    4 "Invalid hexadecimal syntax: "]
  )

... The following code allows one to encode/decode Revolution numbers as text.
... This is not a simple algorithm, and it requires subverting the Revolution
... abstraction a bit.
... It takes into account the fact that Revolution numbers are represented by
... Lux as 64-bit integers.
... A valid way to model them is as Lux's Natural type.
... This is a somewhat hackish way to do things, but it allows one to
... write the encoding/decoding algorithm once, in pure Lux, rather
... than having to implement it on the compiler for every platform
... targeted by Lux.
(every Digits
  (Array Natural))

(the (digits _)
  (-> Any
      Digits)
  (array.empty //i64.width))

(the (digit idx digits)
  (-> Natural Digits
      Natural)
  (|> digits
      (array.item idx)
      (try.else 0)))

(the digits#put!
  (-> Natural Natural Digits
      Digits)
  array.has!)

(the (digits#times_5! idx output)
  (-> Natural Digits
      Digits)
  (loop (again [idx idx
                carry 0
                output output])
    (if (//integer.< +0 (.integer idx))
      output
      (let [raw (|> (..digit idx output)
                    (//natural.* 5)
                    (//natural.+ carry))]
        (again (-- idx)
               (//natural./ 10 raw)
               (digits#put! idx (//natural.% 10 raw) output))))))

(the (power_digits power)
  (-> Natural
      Digits)
  (loop (again [times power
                output (|> (..digits [])
                           (digits#put! power 1))])
    (if (//integer.< +0 (.integer times))
      output
      (again (-- times)
             (digits#times_5! power output)))))

(the (injection digits)
  (-> Digits
      Text)
  (loop (again [idx (-- //i64.width)
                all_zeroes? true
                output ""])
    (if (//integer.< +0 (.integer idx))
      (if all_zeroes?
        "0"
        output)
      (let [digit (..digit idx digits)]
        (if (and (//natural.= 0 digit)
                 all_zeroes?)
          (again (-- idx) true output)
          (again (-- idx)
                 false
                 (.text_composite# (by //natural.base_10 injection digit)
                                   output)))))))

(the (digits#+! param subject)
  (-> Digits Digits
      Digits)
  (loop (again [idx (-- //i64.width)
                carry 0
                output (..digits [])])
    (if (//integer.< +0 (.integer idx))
      output
      (let [raw (all //natural.+
                     carry
                     (..digit idx param)
                     (..digit idx subject))]
        (again (-- idx)
               (//natural./ 10 raw)
               (digits#put! idx (//natural.% 10 raw) output))))))

(the (text_digits input)
  (-> Text
      (Maybe Digits))
  (let [length (.text_size# input)]
    (if (//natural.> //i64.width length)
      {.#None}
      (loop (again [idx 0
                    output (..digits [])])
        (if (//natural.< length idx)
          (when (.text_index# 0 (.text_clip# idx 1 input) "0123456789")
            {.#None}
            {.#None}

            {.#Some digit}
            (again (++ idx)
                   (digits#put! idx digit output)))
          {.#Some output})))))

(the (digits#< param subject)
  (-> Digits Digits
      Bit)
  (loop (again [idx 0])
    (and (//natural.< //i64.width idx)
         (let [pd (..digit idx param)
               sd (..digit idx subject)]
           (if (//natural.= pd sd)
             (again (++ idx))
             (//natural.< pd sd))))))

(the (digits#-!' idx param subject)
  (-> Natural Natural Digits
      Digits)
  (let [sd (..digit idx subject)]
    (if (//natural.< param sd)
      (let [diff (|> sd
                     (//natural.+ 10)
                     (//natural.- param))]
        (|> subject
            (digits#put! idx diff)
            (digits#-!' (-- idx) 1)))
      (digits#put! idx (//natural.- param sd) subject))))

(the (digits#-! param subject)
  (-> Digits Digits
      Digits)
  (loop (again [idx (-- //i64.width)
                output subject])
    (if (//integer.< +0 (.integer idx))
      output
      (again (-- idx)
             (digits#-!' idx (..digit idx param) output)))))

(the .public base_10
  (Format Text Revolution)
  (implementation
   (the (injection input)
     (when (.natural input)
       0
       ".0"

       input
       (let [last_idx (-- //i64.width)]
         (loop (again [idx last_idx
                       digits (..digits [])])
           (if (//integer.< +0 (.integer idx))
             (.text_composite# "." (..injection digits))
             (if (//i64.one? idx input)
               (let [digits' (digits#+! (power_digits (//natural.- idx last_idx))
                                        digits)]
                 (again (-- idx)
                        digits'))
               (again (-- idx)
                      digits)))))))

   (the (projection input)
     (let [dotted? (when (.text_index# 0 "." input)
                     {.#Some 0}
                     true

                     _
                     false)
           within_limits? (|> input
                              .text_size#
                              (//natural.<= (++ //i64.width)))]
       (if (and dotted? within_limits?)
         (when (|> input ..decimals ..text_digits)
           {.#Some digits}
           (loop (again [digits digits
                         idx 0
                         output 0])
             (if (//natural.< //i64.width idx)
               (let [power (power_digits idx)]
                 (if (digits#< power digits)
                   ... Skip power
                   (again digits (++ idx) output)
                   (again (digits#-! power digits)
                          (++ idx)
                          (//i64.one (//natural.- idx (-- //i64.width)) output))))
               {try.#Success (.revolution output)}))

           {.#None}
           {try.#Failure (.text_composite# "Wrong syntax for Revolution: " input)})
         {try.#Failure (.text_composite# "Wrong syntax for Revolution: " input)}))
     )))

(alias [base_02] ..binary)
(alias [base_08] ..octal)
... (alias [decimal] ..base_10)
(alias [base_16] ..hex)
