(.require
 [library
  [lux (.except)
   [abstract
    [hash (.only Hash)]
    [enum (.only Enum)]
    [interval (.only Interval)]
    [monoid (.only Monoid)]
    [equivalence (.only Equivalence)]
    [codec (.only Codec)]
    ["[0]" order (.only Order)]]
   [control
    ["[0]" function]
    ["[0]" maybe]
    ["[0]" try (.only Try)]]]])

(with_template [<extension> <output> <name>]
  [(def .public (<name> parameter subject)
     (-> Nat Nat <output>)
     (<extension> parameter subject))]

  ["lux i64 =" Bit =]
  ["lux i64 +" Nat +]
  ["lux i64 -" Nat -]
  )

(def high
  (-> (I64 Any) I64)
  (|>> ("lux i64 right-shift" 32)))

(def low
  (-> (I64 Any) I64)
  (let [mask (|> 1 ("lux i64 left-shift" 32) ("lux i64 -" 1))]
    (|>> ("lux i64 and" mask))))

(def .public (< reference sample)
  (-> Nat Nat Bit)
  (let [referenceH (..high reference)
        sampleH (..high sample)]
    (if ("lux i64 <" referenceH sampleH)
      true
      (if ("lux i64 =" referenceH sampleH)
        ("lux i64 <"
         (..low reference)
         (..low sample))
        false))))

(def .public (<= reference sample)
  (-> Nat Nat Bit)
  (or (..< reference sample)
      ("lux i64 =" reference sample)))

(def .public (> reference sample)
  (-> Nat Nat Bit)
  (..< sample reference))

(def .public (>= reference sample)
  (-> Nat Nat Bit)
  (or (..< sample reference)
      ("lux i64 =" reference sample)))

(with_template [<name> <test>]
  [(def .public (<name> left right)
     (-> Nat Nat Nat)
     (if (<test> right left)
       left
       right))]

  [min ..<]
  [max ..>]
  )

(def .public (* parameter subject)
  (-> Nat Nat Nat)
  (.nat ("lux i64 *"
         (.int parameter)
         (.int subject))))

(def .public (/ parameter subject)
  (-> Nat Nat Nat)
  (if ("lux i64 <" +0 (.int parameter))
    (if (..< parameter subject)
      0
      1)
    (let [quotient (|> subject
                       ("lux i64 right-shift" 1)
                       ("lux i64 /" (.int parameter))
                       ("lux i64 left-shift" 1))
          flat ("lux i64 *"
                (.int parameter)
                (.int quotient))
          remainder ("lux i64 -" flat subject)]
      (if (..< parameter remainder)
        quotient
        ("lux i64 +" 1 quotient)))))

(def .public (/% parameter subject)
  (-> Nat Nat [Nat Nat])
  (let [quotient (../ parameter subject)
        flat ("lux i64 *"
              (.int parameter)
              (.int quotient))]
    [quotient ("lux i64 -" flat subject)]))

(def .public (% parameter subject)
  (-> Nat Nat Nat)
  (let [flat ("lux i64 *"
              (.int parameter)
              (.int (../ parameter subject)))]
    ("lux i64 -" flat subject)))

(def .public (gcd a b)
  (-> Nat Nat Nat)
  (case b
    0 a
    _ (gcd b (..% b a))))

(def .public (co_prime? a b)
  (-> Nat Nat Bit)
  (..= 1 (..gcd a b)))

(`` (def .public (lcm a b)
      (-> Nat Nat Nat)
      (case [a b]
        (,, (with_template [<pattern>]
              [<pattern>
               0]

              [[_ 0]]
              [[0 _]]))

        _
        (|> a (../ (..gcd a b)) (..* b)))))

(def .public even?
  (-> Nat Bit)
  (|>> (..% 2) ("lux i64 =" 0)))

(def .public odd?
  (-> Nat Bit)
  (|>> ..even? not))

(def .public frac
  (-> Nat Frac)
  (|>> .int "lux i64 f64"))

(def .public equivalence
  (Equivalence Nat)
  (implementation
   (def = ..=)))

(def .public order
  (Order Nat)
  (implementation
   (def equivalence ..equivalence)
   (def < ..<)))

(def .public enum
  (Enum Nat)
  (implementation
   (def order ..order)
   (def succ ++)
   (def pred --)))

(def .public interval
  (Interval Nat)
  (implementation
   (def enum ..enum)
   (def top (-- 0))
   (def bottom 0)))

(with_template [<name> <composite> <identity>]
  [(def .public <name>
     (Monoid Nat)
     (implementation
      (def identity <identity>)
      (def composite <composite>)))]

  [addition       ..+   0]
  [multiplication ..*   1]
  [minimum        ..min (at ..interval top)]
  [maximum        ..max (at ..interval bottom)]
  )

(def (binary_character value)
  (-> Nat Text)
  (case value
    0 "0"
    1 "1"
    _ (undefined)))

(def (binary_value digit)
  (-> Nat (Maybe Nat))
  (case digit
    (char "0") {.#Some 0}
    (char "1") {.#Some 1}
    _ {.#None}))

(def (octal_character value)
  (-> Nat Text)
  (case value
    0 "0"
    1 "1"
    2 "2"
    3 "3"
    4 "4"
    5 "5"
    6 "6"
    7 "7"
    _ (undefined)))

(def (octal_value digit)
  (-> Nat (Maybe Nat))
  (case digit
    (char "0") {.#Some 0}
    (char "1") {.#Some 1}
    (char "2") {.#Some 2}
    (char "3") {.#Some 3}
    (char "4") {.#Some 4}
    (char "5") {.#Some 5}
    (char "6") {.#Some 6}
    (char "7") {.#Some 7}
    _ {.#None}))

(def (decimal_character value)
  (-> Nat Text)
  (case value
    0 "0"
    1 "1"
    2 "2"
    3 "3"
    4 "4"
    5 "5"
    6 "6"
    7 "7"
    8 "8"
    9 "9"
    _ (undefined)))

(def (decimal_value digit)
  (-> Nat (Maybe Nat))
  (case digit
    (char "0") {.#Some 0}
    (char "1") {.#Some 1}
    (char "2") {.#Some 2}
    (char "3") {.#Some 3}
    (char "4") {.#Some 4}
    (char "5") {.#Some 5}
    (char "6") {.#Some 6}
    (char "7") {.#Some 7}
    (char "8") {.#Some 8}
    (char "9") {.#Some 9}
    _ {.#None}))

(def (hexadecimal_character value)
  (-> Nat Text)
  (case value
    0 "0"
    1 "1"
    2 "2"
    3 "3"
    4 "4"
    5 "5"
    6 "6"
    7 "7"
    8 "8"
    9 "9"
    10 "A"
    11 "B"
    12 "C"
    13 "D"
    14 "E"
    15 "F"
    _ (undefined)))

(`` (def (hexadecimal_value digit)
      (-> Nat (Maybe Nat))
      (case digit
        (,, (with_template [<character> <number>]
              [(char <character>)
               {.#Some <number>}]

              ["0" 0] ["1" 1] ["2" 2] ["3" 3] ["4" 4]
              ["5" 5] ["6" 6] ["7" 7] ["8" 8] ["9" 9]))

        (,, (with_template [<lower> <upper> <number>]
              [(char <lower>)
               {.#Some <number>}
               
               (char <upper>)
               {.#Some <number>}]

              ["a" "A" 10] ["b" "B" 11] ["c" "C" 12]
              ["d" "D" 13] ["e" "E" 14] ["f" "F" 15]))
        
        _
        {.#None})))

(with_template [<shift> <struct> <to_character> <to_value> <error>]
  [(def .public <struct>
     (Codec Text Nat)
     (implementation
      (def encoded
        (let [mask (|> 1 ("lux i64 left-shift" <shift>) --)]
          (function (_ value)
            (loop (again [input value
                          output ""])
              (let [output' ("lux text concat"
                             (<to_character> ("lux i64 and" mask input))
                             output)]
                (case (is Nat ("lux i64 right-shift" <shift> input))
                  0
                  output'

                  input'
                  (again input' output')))))))

      (def (decoded repr)
        (let [input_size ("lux text size" repr)]
          (if (..> 0 input_size)
            (loop (again [idx 0
                          output 0])
              (if (..< input_size idx)
                (case (<to_value> ("lux text char" idx repr))
                  {.#Some digit_value}
                  (again (++ idx)
                         (|> output
                             ("lux i64 left-shift" <shift>)
                             ("lux i64 or" digit_value)))

                  _
                  {try.#Failure ("lux text concat" <error> repr)})
                {try.#Success output}))
            {try.#Failure ("lux text concat" <error> repr)})))))]

  [1 binary binary_character      binary_value      "Invalid binary syntax for Nat: "]
  [3 octal  octal_character       octal_value       "Invalid octal syntax for Nat: "]
  [4 hex    hexadecimal_character hexadecimal_value "Invalid hexadecimal syntax for Nat: "]
  )

(def .public decimal
  (Codec Text Nat)
  (implementation
   (def (encoded value)
     (loop (again [input value
                   output ""])
       (let [digit (decimal_character (..% 10 input))
             output' ("lux text concat" digit output)]
         (case (../ 10 input)
           0
           output'

           input'
           (again input' output')))))

   (def (decoded repr)
     (let [input_size ("lux text size" repr)]
       (with_expansions [<failure> {try.#Failure ("lux text concat" "Invalid decimal syntax for Nat: " repr)}]
         (if (..> 0 input_size)
           (loop (again [idx 0
                         output 0])
             (if (..< input_size idx)
               (case (decimal_value ("lux text char" idx repr))
                 {.#None}
                 <failure>

                 {.#Some digit_value}
                 (again (++ idx)
                        (|> output (..* 10) (..+ digit_value))))
               {try.#Success output}))
           <failure>))))))

(def .public hash
  (Hash Nat)
  (implementation
   (def equivalence ..equivalence)
   (def hash function.identity)))
