... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.require
 [library
  [lux (.except nat int rev)
   [abstract
    [hash (.only Hash)]
    [monoid (.only Monoid)]
    [equivalence (.only Equivalence)]
    [codec (.only Codec)]
    [order (.only Order)]
    [monad (.only do)]]
   [control
    ["[0]" maybe]
    ["[0]" try (.only Try) (.use "[1]#[0]" functor)]
    [function
     [predicate (.only Predicate)]]]
   [data
    ["[0]" text]]
   [meta
    ["[0]" location]]]]
 ["[0]" //
  ["[1][0]" i64]
  ["[1][0]" nat]
  ["[1][0]" int]
  ["[1][0]" rev]
  [//
   [arithmetic (.only Arithmetic)]]])

(with_template [<name> <value>]
  [(the .public <name>
     Dec
     <value>)]

  [e +2.7182818284590452354]
  [zero +0.0]
  )

(for .old
     (these (with_template [<name> <method>]
              [(the .public (<name> it)
                 (-> Dec
                     Dec)
                 (<method> it))]

              [exp    "jvm invokestatic:java.lang.Math:exp:double"]
              [log    "jvm invokestatic:java.lang.Math:log:double"]
              
              [ceil   "jvm invokestatic:java.lang.Math:ceil:double"]
              [floor  "jvm invokestatic:java.lang.Math:floor:double"]

              [root_2 "jvm invokestatic:java.lang.Math:sqrt:double"]
              [root_3 "jvm invokestatic:java.lang.Math:cbrt:double"]
              )
            
            (the .public (pow param subject)
              (-> Dec Dec
                  Dec)
              ("jvm invokestatic:java.lang.Math:pow:double,double" subject param)))

     .jvm
     (these (the !double
              (template (_ value)
                [(|> value
                     (as (Nominal "java.lang.Double"))
                     .jvm_object_cast#)]))
            
            (the !dec
              (template (_ value)
                [(|> value
                     .jvm_object_cast#
                     (is (Nominal "java.lang.Double"))
                     (as Dec))]))
            
            (with_template [<name> <method>]
              [(the .public <name>
                 (-> Dec
                     Dec)
                 (|>> !double
                      ["D"]
                      (.jvm_member_invoke_static# [] "java.lang.Math" <method> [])
                      !dec))]
              
              [exp    "exp"]
              [log    "log"]
              
              [ceil   "ceil"]
              [floor  "floor"]
              
              [root_2 "sqrt"]
              [root_3 "cbrt"]
              )
            
            (the .public (pow param subject)
              (-> Dec Dec
                  Dec)
              (|> (.jvm_member_invoke_static# [] "java.lang.Math" "pow" []
                                              ["D" (!double subject)] ["D" (!double param)])
                  !dec)))

     .js
     (these (with_template [<name> <method>]
              [(the .public <name>
                 (-> Dec
                     Dec)
                 (|>> []
                      (.js_apply# (.js_constant# <method>))
                      (as Dec)))]
              
              [exp    "Math.exp"]
              [log    "Math.log"]
              
              [ceil   "Math.ceil"]
              [floor  "Math.floor"]

              [root_2 "Math.sqrt"]
              [root_3 "Math.cbrt"]
              )
            
            (the .public (pow param subject)
              (-> Dec Dec
                  Dec)
              (as Dec (.js_apply# (.js_constant# "Math.pow") [subject param]))))

     .python
     (these (with_template [<name> <method>]
              [(the .public <name>
                 (-> Dec
                     Dec)
                 (|>> []
                      (.python_object_do# <method> (.python_import# "math"))
                      (as Dec)))]
              
              [exp    "exp"]
              [log    "log"]
              
              [ceil   "ceil"]
              [floor  "floor"]

              [root_2 "sqrt"]
              )
            
            (the .public (pow param subject)
              (-> Dec Dec
                  Dec)
              (as Dec (.python_object_do# "pow" (.python_import# "math") [subject param])))

            (the .public (root_3 it)
              (-> Dec
                  Dec)
              (if (.f64_<# +0.0 it)
                (|> it
                    (.f64_*# -1.0)
                    (..pow (.f64_/# +3.0 +1.0))
                    (.f64_*# -1.0))
                (|> it
                    (..pow (.f64_/# +3.0 +1.0))))))

     .lua
     (these (with_template [<name> <method>]
              [(the .public <name>
                 (-> Dec
                     Dec)
                 (|>> []
                      (.lua_apply# (.lua_constant# <method>))
                      (as Dec)))]
              
              [exp    "math.exp"]
              [log    "math.log"]
              
              [ceil   "math.ceil"]
              [floor  "math.floor"]

              [root_2 "math.sqrt"]
              )
            
            (the .public (pow param subject)
              (-> Dec Dec
                  Dec)
              (.lua_power# param subject))

            (the .public (root_3 it)
              (-> Dec
                  Dec)
              (if (.f64_<# +0.0 it)
                (|> it
                    (.f64_*# -1.0)
                    (..pow (.f64_/# +3.0 +1.0))
                    (.f64_*# -1.0))
                (|> it
                    (..pow (.f64_/# +3.0 +1.0))))))

     .ruby
     (these (with_template [<name> <method>]
              [(the .public <name>
                 (-> Dec
                     Dec)
                 (|>> []
                      (.ruby_apply# (.ruby_constant# <method>))
                      (as Dec)))]
              
              [exp    "Math.exp"]
              [log    "Math.log"]
              
              [root_2 "Math.sqrt"]
              [root_3 "Math.cbrt"]
              )

            (with_template [<name> <method>]
              [(the .public (<name> it)
                 (-> Dec
                     Dec)
                 (|> (.ruby_object_do# <method> it [])
                     (as Int)
                     (.int_f64#)))]

              [ceil  "ceil"]
              [floor "floor"]
              )

            (the .public (pow param subject)
              (-> Dec Dec
                  Dec)
              (as Dec (.ruby_object_do# "**" subject [param]))))

     .php
     (these (with_template [<name> <method>]
              [(the .public <name>
                 (-> Dec
                     Dec)
                 (|>> ("php apply" ("php constant" <method>))
                      (as Dec)))]
              
              [exp    "exp"]
              [log    "log"]

              [ceil   "ceil"]
              [floor  "floor"]
              
              [root_2 "sqrt"]
              )

            (the .public (pow param subject)
              (-> Dec Dec
                  Dec)
              (as Dec ("php apply" ("php constant" "pow") subject param)))

            (the .public root_3
              (-> Dec
                  Dec)
              (..pow (.f64_/# +3.0 +1.0))))

     .scheme
     (these (with_template [<name> <method>]
              [(the .public <name>
                 (-> Dec
                     Dec)
                 (|>> ("scheme apply" ("scheme constant" <method>))
                      (as Dec)))]
              
              [exp    "exp"]
              [log    "log"]

              [ceil   "ceiling"]
              [floor  "floor"]
              
              [root_2 "sqrt"]
              )

            (the .public (pow param subject)
              (-> Dec Dec
                  Dec)
              (as Dec ("scheme apply" ("scheme constant" "expt") subject param)))

            (the .public root_3
              (-> Dec
                  Dec)
              (..pow (.f64_/# +3.0 +1.0))))
     )

(the .public (round it)
  (-> Dec
      Dec)
  (let [floored (floor it)
        diff (.f64_-# floored it)]
    (cond (.f64_<# diff +0.5)
          (.f64_+# +1.0 floored)
          
          (.f64_<# -0.5 diff)
          (.f64_+# -1.0 floored)
          
          ... else
          floored)))

(the .public (log_by base it)
  (-> Dec Dec
      Dec)
  (.f64_/# (..log base)
           (..log it)))

(the .public (factorial it)
  (-> Nat
      Nat)
  (loop (again [acc 1
                it it])
    (if (//nat.> 1 it)
      (again (//nat.* it acc) (-- it))
      acc)))

(with_template [<name> <op>]
  [(the .public (<name> param subject)
     (-> Dec Dec
         Bit)
     (<op> param subject))]

  [= .f64_=#]
  [< .f64_<#]
  )

(the .public (<= reference it)
  (-> Dec Dec
      Bit)
  (or (.f64_<# reference it)
      (.f64_=# reference it)))

(the .public (> reference it)
  (-> Dec Dec
      Bit)
  (.f64_<# it reference))

(the .public (>= reference it)
  (-> Dec Dec
      Bit)
  (or (.f64_<# it reference)
      (.f64_=# it reference)))

(with_template [<comparison> <name>]
  [(the .public <name>
     (Predicate Dec)
     (<comparison> +0.0))]

  [..> positive?]
  [..< negative?]
  [..= zero?]
  )

(with_template [<name> <op>]
  [(the .public (<name> param subject)
     (-> Dec Dec
         Dec)
     (<op> param subject))]

  [+ .f64_+#]
  [- .f64_-#]
  [* .f64_*#]
  [/ .f64_/#]
  [% .f64_%#]
  )

(the .public arithmetic
  (Arithmetic Dec)
  (implementation
   (the + ..+)
   (the - ..-)
   (the * ..*)
   (the / ../)))

(the .public (/% param subject)
  (-> Dec Dec
      [Dec Dec])
  [(../ param subject)
   (..% param subject)])

(the .public opposite
  (-> Dec
      Dec)
  (..* -1.0))

(the .public (abs it)
  (-> Dec
      Dec)
  (if (..< +0.0 it)
    (..* -1.0 it)
    it))

(the .public (signum it)
  (-> Dec
      Dec)
  (cond (..= +0.0 it) +0.0
        (..< +0.0 it) -1.0
        ... else
        +1.0))

(the min_exponent -1022)
(the max_exponent (//int.dec +1023))

(with_template [<name> <test>]
  [(the .public (<name> left right)
     (-> Dec Dec
         Dec)
     (if (<test> right left)
       left
       right))]

  [min ..<]
  [max ..>]
  )

(the .public nat
  (-> Dec
      Nat)
  (|>> .f64_int# .nat))

(the .public int
  (-> Dec
      Int)
  (|>> .f64_int#))

(the mantissa_size Nat 52)
(the exponent_size Nat 11)

(the dec_denominator
  (|> -1
      (.i64_right# ..exponent_size)
      .int_f64#))

(the .public rev
  (-> Dec
      Rev)
  (|>> ..abs
       (..% +1.0)
       (..* ..dec_denominator)
       .f64_int#
       (.i64_left# ..exponent_size)))

(with_template [<name> <numerator>]
  [(the .public <name>
     Dec
     (../ +0.0 <numerator>))]

  [not_a_number      +0.0]
  [positive_infinity +1.0]
  )

(the .public negative_infinity
  Dec
  (..* -1.0 ..positive_infinity))

(the .public (not_a_number? it)
  (-> Dec
      Bit)
  (not (..= it it)))

(the .public (number? it)
  (-> Dec
      Bit)
  (not (or (..not_a_number? it)
           (..= ..positive_infinity it)
           (..= ..negative_infinity it))))

(the .public equivalence
  (Equivalence Dec)
  (implementation
   (the (= left right)
     (or (..= left right)
         (and (..not_a_number? left)
              (..not_a_number? right))))))

(the .public order
  (Order Dec)
  (implementation
   (the equivalence ..equivalence)
   (the < ..<)))

(the .public smallest
  Dec
  (..pow (//int.dec (//int.- (.int ..mantissa_size) ..min_exponent))
         +2.0))

(the .public biggest
  Dec
  (let [f2^-52 (..pow (//nat.dec (//nat.- ..mantissa_size 0)) +2.0)
        f2^+1023 (..pow ..max_exponent +2.0)]
    (|> +2.0
        (..- f2^-52)
        (..* f2^+1023))))

(with_template [<name> <composite> <identity>]
  [(the .public <name>
     (Monoid Dec)
     (implementation
      (the identity <identity>)
      (the composite <composite>)))]

  [addition       ..+   +0.0]
  [multiplication ..*   +1.0]
  [minimum        ..min ..biggest]
  [maximum        ..max (..* -1.0 ..biggest)]
  )

(the .public cannot_project
  Error
  (location.with (location.here)
    "Cannot decode."))

(the (decimal#injection it)
  (-> Dec
      Text)
  (<| (as Text)
      (for .old
           ("jvm invokestatic:java.lang.Double:toString:double" it)
           
           .jvm
           (|> it
               ..!double
               ["D"]
               (.jvm_member_invoke_static# [] "java.lang.Double" "toString" []))
           
           .js
           (.js_object_do# "toString" it [])

           .lua
           (.lua_apply# (.lua_constant# "string.format") ["%.17g" it])

           .python
           (.python_apply# (.python_constant# "repr") [it])

           .ruby
           (.ruby_object_do# "to_s" it []))))

(the with_projection_error
  (template (_ ,it)
    [(when (try ,it)
       {try.#Failure _}
       {try.#Failure ..cannot_project}

       success
       success)]))

(the .public decimal
  (Codec Text Dec)
  (implementation
   (the (injection it)
     (when it
       -0.0 (let [output (decimal#injection it)]
              (if (text.starts_with? "-" output)
                output
                (.text_composite# "+" output)))
       _ (if (..< +0.0 it)
           (decimal#injection it)
           (.text_composite# "+" (decimal#injection it)))))

   (the (projection it)
     (for .old
          (|> it
              (as (Nominal "java.lang.String"))
              "jvm invokestatic:java.lang.Double:parseDouble:java.lang.String"
              with_projection_error)

          .jvm
          (|> it
              (as (Nominal "java.lang.String"))
              .jvm_object_cast#
              ["Ljava/lang/String;"]
              (.jvm_member_invoke_static# [] "java.lang.Double" "parseDouble" [])
              ..!dec
              with_projection_error)

          .js
          (|> (.js_apply# (.js_constant# "parseFloat") [it])
              (as Dec)
              with_projection_error)

          .lua
          (|> (.lua_apply# (.lua_constant# "tonumber") [it])
              (as Dec)
              with_projection_error)

          .python
          (|> (.python_apply# (.python_constant# "float") [it])
              (as Dec)
              with_projection_error)

          .ruby
          (let [projection (as Dec (.ruby_object_do# "to_f" it []))]
            (with_expansions [,success {try.#Success projection}]
              (if (..= +0.0 projection)
                (when it
                  "0" ,success
                  "+0" ,success
                  "-0" ,success
                  
                  ".0" ,success
                  "+.0" ,success
                  "-.0" ,success
                  
                  "0.0" ,success
                  "+0.0" ,success
                  "-0.0" ,success

                  ... else
                  {try.#Failure ..cannot_project})
                ,success)))))))

(the log/2
  (-> Dec
      Dec)
  (let [base (..log +2.0)]
    (|>> ..log
         (../ base))))

(the double_bias Nat 1023)

(the exponent_mask (//i64.mask ..exponent_size))

(the exponent_offset ..mantissa_size)
(the sign_offset (//nat.+ ..exponent_size ..exponent_offset))

(with_template [<cast> <hex> <name>]
  [(the <name>
     (|> <hex>
         (of //nat.hex projection)
         try.trusted
         <cast>))]

  [.i64 "FFF8000000000000" not_a_number_bits]
  [.i64 "7FF0000000000000" positive_infinity_bits]
  [.i64 "FFF0000000000000" negative_infinity_bits]
  [.i64 "0000000000000000" positive_zero_bits]
  [.i64 "8000000000000000" negative_zero_bits]
  [.nat "7FF"              special_exponent_bits]
  )

(the smallest_exponent
  (..log/2 ..smallest))

(the .public (reciprocal it)
  (-> Dec
      Dec)
  (../ it
       +1.0))

(the .public (bits it)
  (-> Dec
      I64)
  (.i64 (cond (..not_a_number? it)
              ..not_a_number_bits

              (..= positive_infinity it)
              ..positive_infinity_bits

              (..= negative_infinity it)
              ..negative_infinity_bits

              (..= +0.0 it)
              (if (..= positive_infinity (reciprocal it))
                ... Positive zero
                ..positive_zero_bits
                ... Negative zero
                ..negative_zero_bits)

              ... else
              (let [sign_bit (if (..< +0.0 it)
                               1
                               0)
                    it (..abs it)
                    exponent (|> it
                                 ..log/2
                                 ..floor
                                 (..min ..max_exponent))
                    min_gap (..- (//int.dec ..min_exponent) exponent)
                    power (|> (//nat.dec ..mantissa_size)
                              (..+ (..min +0.0 min_gap))
                              (..- exponent))
                    max_gap (..- ..max_exponent power)
                    mantissa (|> it
                                 (..* (..pow (..min ..max_exponent power) +2.0))
                                 (..* (if (..> +0.0 max_gap)
                                        (..pow max_gap +2.0)
                                        +1.0)))
                    exponent_bits (|> (if (..< +0.0 min_gap)
                                        (|> (..int exponent)
                                            (//int.- (..int min_gap))
                                            --)
                                        (..int exponent))
                                      (//int.+ (.int ..double_bias))
                                      (//i64.and ..exponent_mask))
                    mantissa_bits (..int mantissa)]
                (all //i64.or
                     (//i64.left_shifted ..sign_offset sign_bit)
                     (//i64.left_shifted ..exponent_offset exponent_bits)
                     (//i64.zero ..mantissa_size mantissa_bits)))
              )))

(with_template [<getter> <size> <offset>]
  [(the <getter>
     (-> (I64 Any)
         I64)
     (let [mask (|> 1 (//i64.left_shifted <size>) -- (//i64.left_shifted <offset>))]
       (|>> (//i64.and mask) (//i64.right_shifted <offset>) .i64)))]

  [mantissa ..mantissa_size 0]
  [exponent ..exponent_size ..mantissa_size]
  [sign     1               ..sign_offset]
  )

(the .public (of_bits it)
  (-> I64
      Dec)
  (when [(is Nat (..exponent it))
         (is Nat (..mantissa it))
         (is Nat (..sign it))]
    [..special_exponent_bits 0 0]
    ..positive_infinity

    [..special_exponent_bits 0 1]
    ..negative_infinity

    [..special_exponent_bits _ _]
    ..not_a_number

    ... Positive zero
    [0 0 0] +0.0
    ... Negative zero
    [0 0 1] (..* -1.0 +0.0)

    [E M S]
    (let [sign (if (//nat.= 0 S)
                 +1.0
                 -1.0)
          [mantissa power] (if (//nat.< ..mantissa_size E)
                             [(if (//nat.= 0 E)
                                M
                                (//i64.one ..mantissa_size M))
                              (|> E
                                  (//nat.- ..double_bias)
                                  .int
                                  (//int.max ..min_exponent)
                                  (//int.- (.int ..mantissa_size)))]
                             [(//i64.one ..mantissa_size M)
                              (|> E (//nat.- ..double_bias) (//nat.- ..mantissa_size) .int)])
          exponent (..pow (//int.dec power) +2.0)]
      (|> (//nat.dec mantissa)
          (..* exponent)
          (..* sign)))))

(`` (the (representation_exponent codec representation)
      (-> (Codec Text Nat) Text
          (Try [Text Int]))
      (when [(.text_index# 0 "e+" representation)
             (.text_index# 0 "E+" representation)
             (.text_index# 0 "e-" representation)
             (.text_index# 0 "E-" representation)]
        (,, (with_template [<factor> <pattern>]
              [<pattern>
               (do try.monad
                 [.let [after_offset (//nat.+ 2 split_index)
                        after_length (//nat.- after_offset (.text_size# representation))]
                  exponent (|> representation
                               (.text_clip# after_offset after_length)
                               (of codec projection))]
                 (in [(.text_clip# 0 split_index representation)
                      (//int.* <factor> (.int exponent))]))]

              [+1 [{.#Some split_index} {.#None} {.#None} {.#None}]]
              [+1 [{.#None} {.#Some split_index} {.#None} {.#None}]]
              
              [-1 [{.#None} {.#None} {.#Some split_index} {.#None}]]
              [-1 [{.#None} {.#None} {.#None} {.#Some split_index}]]))
        
        _
        {try.#Success [representation +0]})))

(with_template [<struct> <nat> <int> <error>]
  [(the .public <struct>
     (Codec Text Dec)
     (implementation
      (the (injection value)
        (let [bits (..bits value)
              mantissa (..mantissa bits)
              exponent (//int.- (.int ..double_bias) (..exponent bits))
              sign (..sign bits)]
          (.text_composite# (when (.nat sign)
                              1 "-"
                              0 "+"
                              _ (undefined))
                            (of <nat> injection (.nat mantissa))
                            ".0E"
                            (of <int> injection exponent))))

      (the (projection representation)
        (let [negative? (text.starts_with? "-" representation)
              positive? (text.starts_with? "+" representation)]
          (if (or negative? positive?)
            (do [! try.monad]
              [[mantissa exponent] (..representation_exponent <nat> representation)
               [whole decimal] (when (.text_index# 0 "." mantissa)
                                 {.#Some split_index}
                                 (do !
                                   [.let [after_offset (++ split_index)
                                          after_length (//nat.- after_offset (.text_size# mantissa))]
                                    decimal (|> mantissa
                                                (.text_clip# after_offset after_length)
                                                (of <nat> projection))]
                                   (in [(.text_clip# 0 split_index mantissa)
                                        decimal]))

                                 {.#None}
                                 {try.#Failure (.text_composite# <error> representation)})
               .let [whole (.text_clip# 1 (-- (.text_size# whole)) whole)]
               mantissa (of <nat> projection (when decimal
                                               0 whole
                                               _ (.text_composite# whole (of <nat> injection decimal))))
               .let [sign (if negative? 1 0)]]
              (in (..of_bits
                   (all //i64.or
                        (//i64.left_shifted ..sign_offset (.i64 sign))
                        (//i64.left_shifted ..mantissa_size (.i64 (//int.+ (.int ..double_bias) exponent)))
                        (//i64.zero ..mantissa_size (.i64 mantissa))))))
            {try.#Failure (.text_composite# <error> representation)})))))]

  [binary //nat.binary //int.binary "Invalid binary syntax: "]
  [octal //nat.octal //int.octal "Invalid octaladecimal syntax: "]
  [hex //nat.hex //int.hex "Invalid hexadecimal syntax: "]
  )

(the .public hash
  (Hash Dec)
  (implementation
   (the equivalence ..equivalence)
   (the hash ..bits)))

(the .public (approximately? margin_of_error standard value)
  (-> Dec Dec Dec
      Bit)
  (|> value
      (..- standard)
      ..abs
      (..< margin_of_error)))

(the .public (mod divisor dividend)
  (-> Dec Dec Dec)
  (let [remainder (..% divisor dividend)]
    (if (or (and (..< +0.0 divisor)
                 (..> +0.0 remainder))
            (and (..> +0.0 divisor)
                 (..< +0.0 remainder)))
      (..+ divisor remainder)
      remainder)))

(with_template [<factor> <suffix> <codec> <as> <of>]
  [(the .public <as>
     (-> Dec
         Dec)
     (* <factor>))
   
   (the .public <of>
     (-> Dec
         Dec)
     (/ <factor>))
   
   (the .public <codec>
     (Codec Text Dec)
     (implementation
      (the injection
        (|>> <as>
             (of ..decimal injection)
             (text.suffix <suffix>)))

      (the (projection it)
        (when (text.split_by <suffix> it)
          {.#Some [it ""]}
          (|> it
              (of ..decimal projection)
              (try#each <of>))
          
          _
          {try.#Failure ..cannot_project}))))]

  ... https://en.wikipedia.org/wiki/Degree_(angle)
  [+360.0 "°" degree as_degree of_degree]

  ... https://en.wikipedia.org/wiki/Gradian
  [+400.0 "g" gradian as_gradian of_gradian]

  ... https://en.wikipedia.org/wiki/Percentage
  [+00,100.0 "%" percentage as_percentage of_percentage]

  ... https://en.wikipedia.org/wiki/Per_mille
  [+01,000.0 "‰" permille as_permille of_permille]

  ... https://en.wikipedia.org/wiki/Basis_point
  [+10,000.0 "‱" permyriad as_permyriad of_permyriad]
  )

(alias [base_02] ..binary)
(alias [base_08] ..octal)
(alias [base_10] ..decimal)
(alias [base_16] ..hex)

(with_template [,/% ,name]
  [(the .public ,name
     (-> Dec
         Dec)
     (,/% +1.0))]

  [../ whole]
  [..% partial]
  )
