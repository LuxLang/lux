(.module:
  [library
   [lux "*"
    [abstract
     [equivalence {"+" [Equivalence]}]
     [order {"+" [Order]}]
     [monoid {"+" [Monoid]}]
     [codec {"+" [Codec]}]
     [monad {"+" [do]}]]
    [control
     ["[0]" try {"+" [Try]}]
     ["[0]" exception {"+" [exception:]}]
     ["<>" parser
      ["<[0]>" text {"+" [Parser]}]
      ["<[0]>" code]]]
    [data
     ["[0]" product]
     ["[0]" text ("[1]\[0]" monoid)]]
    [macro
     [syntax {"+" [syntax:]}]
     ["[0]" code]]
    [math
     [number
      ["i" int ("[1]\[0]" decimal)]]]
    [type
     abstract]]]
  ["[0]" // "_"
   ["[1]" modulus {"+" [Modulus]}]])

(abstract: .public (Mod m)
  {}

  (Record
   [#modulus (Modulus m)
    #value Int])

  (def: .public (modular modulus value)
    (All (_ %) (-> (Modulus %) Int (Mod %)))
    (:abstraction [#modulus modulus
                   #value (i.mod (//.divisor modulus) value)]))

  (template [<name> <type> <side>]
    [(def: .public <name>
       (All (_ %) (-> (Mod %) <type>))
       (|>> :representation <side>))]

    [modulus (Modulus %) product.left]
    [value Int product.right]
    )
  
  (exception: .public [%] (incorrect_modulus {modulus (Modulus %)}
                                             {parsed Int})
    (exception.report
     ["Expected" (i\encoded (//.divisor modulus))]
     ["Actual" (i\encoded parsed)]))

  (def: separator
    " mod ")

  (def: intL
    (Parser Int)
    (<>.codec i.decimal
              (<text>.and (<text>.one_of "-+") (<text>.many <text>.decimal))))

  (implementation: .public (codec expected)
    (All (_ %) (-> (Modulus %) (Codec Text (Mod %))))

    (def: (encoded modular)
      (let [[_ value] (:representation modular)]
        ($_ text\composite
            (i\encoded value)
            ..separator
            (i\encoded (//.divisor expected)))))

    (def: decoded
      (<text>.result
       (do <>.monad
         [[value _ actual] ($_ <>.and intL (<text>.this ..separator) intL)
          _ (<>.assertion (exception.error ..incorrect_modulus [expected actual])
                          (i.= (//.divisor expected) actual))]
         (in (..modular expected value))))))

  (template [<name> <op>]
    [(def: .public (<name> reference subject)
       (All (_ %) (-> (Mod %) (Mod %) Bit))
       (let [[_ reference] (:representation reference)
             [_ subject] (:representation subject)]
         (<op> reference subject)))]

    [= i.=]
    [< i.<]
    [<= i.<=]
    [> i.>]
    [>= i.>=]
    )

  (implementation: .public equivalence
    (All (_ %) (Equivalence (Mod %)))

    (def: = ..=))

  (implementation: .public order
    (All (_ %) (Order (Mod %)))

    (def: &equivalence ..equivalence)
    (def: < ..<))

  (template [<name> <op>]
    [(def: .public (<name> param subject)
       (All (_ %) (-> (Mod %) (Mod %) (Mod %)))
       (let [[modulus param] (:representation param)
             [_ subject] (:representation subject)]
         (:abstraction [#modulus modulus
                        #value (|> subject
                                   (<op> param)
                                   (i.mod (//.divisor modulus)))])))]

    [+ i.+]
    [- i.-]
    [* i.*]
    )

  (template [<composition> <identity> <monoid>]
    [(implementation: .public (<monoid> modulus)
       (All (_ %) (-> (Modulus %) (Monoid (Mod %))))

       (def: identity
         (..modular modulus <identity>))
       (def: composite
         <composition>))]
    
    [..+ +0 addition]
    [..* +1 multiplication]
    )
  
  (def: .public (inverse modular)
    (All (_ %) (-> (Mod %) (Maybe (Mod %))))
    (let [[modulus value] (:representation modular)
          [[vk mk] gcd] (i.extended_gcd value (//.divisor modulus))]
      (case gcd
        +1 (#.Some (..modular modulus vk))
        _ #.None)))
  )

(exception: .public [r% s%] (moduli_are_not_equal {reference (Modulus r%)}
                                                  {subject (Modulus s%)})
  (exception.report
   ["Reference" (i\encoded (//.divisor reference))]
   ["Subject" (i\encoded (//.divisor subject))]))

(def: .public (adapter reference subject)
  (All (_ r% s%)
    (-> (Modulus r%) (Modulus s%)
        (Try (-> (Mod s%) (Mod r%)))))
  (if (//.= reference subject)
    (#try.Success (|>> ..value
                       (..modular reference)))
    (exception.except ..moduli_are_not_equal [reference subject])))
