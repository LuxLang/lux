(.using
  [library
   [lux "*"
    [abstract
     [codec {"+" Codec}]]
    [control
     ["[0]" try {"+" Try}]]
    [data
     ["[0]" text]]]]
  ["[0]" / "_"
   ["[1][0]" nat]
   ["[1][0]" int]
   ["[1][0]" rev]
   ["[1][0]" frac]])

(def: separator
  ",")

(def: (separator_prefixed? number)
  (-> Text Bit)
  (case ("lux text index" 0 ..separator number)
    {.#Some 0}
    #1

    _
    #0))

(def: without_separators
  (-> Text Text)
  (text.replaced ..separator ""))

(template [<macro> <nat> <int> <rev> <frac> <error>]
  [(macro: .public (<macro> tokens state)
     (case tokens
       {.#Item [meta {.#Text repr'}] {.#End}}
       (if (..separator_prefixed? repr')
         {try.#Failure <error>}
         (let [repr (..without_separators repr')]
           (case (# <nat> decoded repr)
             {try.#Success value}
             {try.#Success [state (list [meta {.#Nat value}])]}

             (^multi {try.#Failure _}
                     [(# <int> decoded repr)
                      {try.#Success value}])
             {try.#Success [state (list [meta {.#Int value}])]}

             (^multi {try.#Failure _}
                     [(# <rev> decoded repr)
                      {try.#Success value}])
             {try.#Success [state (list [meta {.#Rev value}])]}

             (^multi {try.#Failure _}
                     [(# <frac> decoded repr)
                      {try.#Success value}])
             {try.#Success [state (list [meta {.#Frac value}])]}

             _
             {try.#Failure <error>})))

       _
       {try.#Failure <error>}))]

  [bin /nat.binary /int.binary /rev.binary /frac.binary "Invalid binary syntax."]
  [oct /nat.octal  /int.octal  /rev.octal  /frac.octal "Invalid octal syntax."]
  [hex /nat.hex    /int.hex    /rev.hex    /frac.hex "Invalid hexadecimal syntax."]
  )
