("lux def" dummy_location
 ["" 0 0]
 #0)

("lux def" double_quote
 ("lux i64 char" +34)
 #0)

("lux def" \n
 ("lux i64 char" +10)
 #0)

("lux def" prelude_module
 "library/lux"
 #1)

... (type: .public Any
...   (Ex (_ a) a))
("lux def" Any
 ("lux type check type"
  {9 #1
     [..prelude_module "Any"]
     {8 #0
        {0 #0}
        {4 #0 1}}})
 #1)

... (type: .public Nothing
...   (All (_ a) a))
("lux def" Nothing
 ("lux type check type"
  {9 #1
     [..prelude_module "Nothing"]
     {7 #0
        {0 #0}
        {4 #0 1}}})
 #1)

... (type: .public (List a)
...   (Variant
...    {#End}
...    {#Item a (List a)}))
("lux def type tagged" List
 {9 #1
    [..prelude_module "List"]
    {7 #0
       {0 #0}
       {1 #0
          ... End
          Any
          ... Item
          {2 #0
             {4 #0 1}
             {9 #0
                {4 #0 1}
                {4 #0 0}}}}}}
 {"#End" "#Item"}
 #1)

("lux def" Bit
 ("lux type check type"
  {9 #1
     [..prelude_module "Bit"]
     {0 #0 "#Bit" {#End}}})
 #1)

("lux def" I64
 ("lux type check type"
  {9 #1
     [..prelude_module "I64"]
     {7 #0
        {0 #0}
        {0 #0 "#I64" {#Item {4 #0 1} {#End}}}}})
 #1)

("lux def" Nat
 ("lux type check type"
  {9 #1
     [..prelude_module "Nat"]
     {0 #0 "#I64" {#Item {0 #0 "#Nat" {#End}} {#End}}}})
 #1)

("lux def" Int
 ("lux type check type"
  {9 #1
     [..prelude_module "Int"]
     {0 #0 "#I64" {#Item {0 #0 "#Int" {#End}} {#End}}}})
 #1)

("lux def" Rev
 ("lux type check type"
  {9 #1
     [..prelude_module "Rev"]
     {0 #0 "#I64" {#Item {0 #0 "#Rev" {#End}} {#End}}}})
 #1)

("lux def" Frac
 ("lux type check type"
  {9 #1
     [..prelude_module "Frac"]
     {0 #0 "#Frac" {#End}}})
 #1)

("lux def" Text
 ("lux type check type"
  {9 #1
     [..prelude_module "Text"]
     {0 #0 "#Text" {#End}}})
 #1)

("lux def" Symbol
 ("lux type check type"
  {9 #1
     [..prelude_module "Symbol"]
     {2 #0 Text Text}})
 #1)

... (type: .public (Maybe a)
...   {#None}
...   {#Some a})
("lux def type tagged" Maybe
 {9 #1
    [..prelude_module "Maybe"]
    {7 #0
       {#End}
       {1 #0
          ... None
          Any
          ... Some
          {4 #0 1}}}}
 {"#None" "#Some"}
 #1)

... (type: .public Type
...   (Rec Type
...     (Variant
...      {#Primitive Text (List Type)}
...      {#Sum Type Type}
...      {#Product Type Type}
...      {#Function Type Type}
...      {#Parameter Nat}
...      {#Var Nat}
...      {#Ex Nat}
...      {#UnivQ (List Type) Type}
...      {#ExQ (List Type) Type}
...      {#Apply Type Type}
...      {#Named Symbol Type})))
("lux def type tagged" Type
 {9 #1 [..prelude_module "Type"]
    ({Type
      ({Type_List
        ({Type_Pair
          {9 #0
             {0 #0 ["" {#End}]}
             {7 #0
                {#End}
                {1 #0
                   ... Primitive
                   {2 #0 Text Type_List}
                   {1 #0
                      ... Sum
                      Type_Pair
                      {1 #0
                         ... Product
                         Type_Pair
                         {1 #0
                            ... Function
                            Type_Pair
                            {1 #0
                               ... Parameter
                               Nat
                               {1 #0
                                  ... Var
                                  Nat
                                  {1 #0
                                     ... Ex
                                     Nat
                                     {1 #0
                                        ... UnivQ
                                        {2 #0 Type_List Type}
                                        {1 #0
                                           ... ExQ
                                           {2 #0 Type_List Type}
                                           {1 #0
                                              ... Apply
                                              Type_Pair
                                              ... Named
                                              {2 #0 Symbol Type}}}}}}}}}}}}}}
         ("lux type check type" {2 #0 Type Type}))}
       ("lux type check type" {9 #0 Type List}))}
     ("lux type check type" {9 #0 {0 #0 ["" {#End}]} {4 #0 0}}))}
 {"#Primitive" "#Sum" "#Product" "#Function" "#Parameter" "#Var" "#Ex" "#UnivQ" "#ExQ" "#Apply" "#Named"}
 #1)

... (type: .public Location
...   (Record
...    [#module Text
...     #line   Nat
...     #column Nat]))
("lux def type tagged" Location
 {#Named [..prelude_module "Location"]
         {#Product Text {#Product Nat Nat}}}
 ["#module" "#line" "#column"]
 #1)

... (type: .public (Ann m v)
...   (Record
...    [#meta  m
...     #datum v]))
("lux def type tagged" Ann
 {#Named [..prelude_module "Ann"]
         {#UnivQ {#End}
                 {#UnivQ {#End}
                         {#Product
                          {#Parameter 3}
                          {#Parameter 1}}}}}
 ["#meta" "#datum"]
 #1)

... (type: .public (Code' w)
...   (Variant
...    {#Bit Bit}
...    {#Nat Nat}
...    {#Int Int}
...    {#Rev Rev}
...    {#Frac Frac}
...    {#Text Text}
...    {#Symbol Symbol}
...    {#Form (List (w (Code' w)))}
...    {#Variant (List (w (Code' w)))}
...    {#Tuple (List (w (Code' w)))}))
("lux def type tagged" Code'
 {#Named [..prelude_module "Code'"]
         ({Code
           ({Code_List
             {#UnivQ {#End}
                     {#Sum
                      ... Bit
                      Bit
                      {#Sum
                       ... Nat
                       Nat
                       {#Sum
                        ... Int
                        Int
                        {#Sum
                         ... Rev
                         Rev
                         {#Sum
                          ... Frac
                          Frac
                          {#Sum
                           ... Text
                           Text
                           {#Sum
                            ... Symbol
                            Symbol
                            {#Sum
                             ... Form
                             Code_List
                             {#Sum
                              ... Variant
                              Code_List
                              ... Tuple
                              Code_List
                              }}}}}}}}}
                     }}
            ("lux type check type" {#Apply Code List}))}
          ("lux type check type" {#Apply {#Apply {#Parameter 1}
                                                 {#Parameter 0}}
                                         {#Parameter 1}}))}
 {"#Bit" "#Nat" "#Int" "#Rev" "#Frac" "#Text" "#Symbol" "#Form" "#Variant" "#Tuple"}
 #1)

... (type: .public Code
...   (Ann Location (Code' (Ann Location))))
("lux def" Code
 ("lux type check type"
  {#Named [..prelude_module "Code"]
          ({w
            {#Apply {#Apply w Code'} w}}
           ("lux type check type" {#Apply Location Ann}))})
 #1)

("lux def" private
 #0
 #1)

("lux def" public
 #1
 #1)

("lux def" local
 #0
 #1)

("lux def" global
 #1
 #1)

("lux def" _ann
 ("lux type check"
  {#Function {#Apply {#Apply Location Ann} Code'}
             Code}
  ([_ data]
   [dummy_location data]))
 #0)

("lux def" bit$
 ("lux type check" {#Function Bit Code}
  ([_ value] (_ann {#Bit value})))
 #0)

("lux def" nat$
 ("lux type check" {#Function Nat Code}
  ([_ value] (_ann {#Nat value})))
 #0)

("lux def" int$
 ("lux type check" {#Function Int Code}
  ([_ value] (_ann {#Int value})))
 #0)

("lux def" rev$
 ("lux type check" {#Function Rev Code}
  ([_ value] (_ann {#Rev value})))
 #0)

("lux def" frac$
 ("lux type check" {#Function Frac Code}
  ([_ value] (_ann {#Frac value})))
 #0)

("lux def" text$
 ("lux type check" {#Function Text Code}
  ([_ text] (_ann {#Text text})))
 #0)

("lux def" symbol$
 ("lux type check" {#Function Symbol Code}
  ([_ name] (_ann {#Symbol name})))
 #0)

("lux def" local$
 ("lux type check" {#Function Text Code}
  ([_ name] (_ann {#Symbol ["" name]})))
 #0)

("lux def" form$
 ("lux type check" {#Function {#Apply Code List} Code}
  ([_ tokens] (_ann {#Form tokens})))
 #0)

("lux def" variant$
 ("lux type check" {#Function {#Apply Code List} Code}
  ([_ tokens] (_ann {#Variant tokens})))
 #0)

("lux def" tuple$
 ("lux type check" {#Function {#Apply Code List} Code}
  ([_ tokens] (_ann {#Tuple tokens})))
 #0)

... (type: .public Definition
...   [Bit Type Any])
("lux def" Definition
 ("lux type check type"
  {#Named [..prelude_module "Definition"]
          {#Product Bit {#Product Type Any}}})
 .public)

... (type: .public Alias
...   Symbol)
("lux def" Alias
 ("lux type check type"
  {#Named [..prelude_module "Alias"]
          Symbol})
 .public)

... (type: .public Label
...   [Bit Type (List Text) Nat])
("lux def" Label
 ("lux type check type"
  {#Named [..prelude_module "Label"]
          {#Product Bit {#Product Type {#Product {#Apply Text List} Nat}}}})
 .public)

... (type: .public Global
...   (Variant
...    {#Definition Definition}
...    {#Type [Bit Type (Either [Text (List Text)] [Text (List Text)])]}
...    {#Tag Label}
...    {#Slot Label}
...    {#Alias Alias}))
("lux def type tagged" Global
 {#Named [..prelude_module "Global"]
         {#Sum Definition
               {#Sum ({labels
                       {#Product Bit {#Product Type {#Sum labels labels}}}}
                      {#Product Text {#Apply Text List}})
                     {#Sum Label
                           {#Sum Label
                                 Alias}}}}}
 {"#Definition" "#Type" "#Tag" "#Slot" "#Alias"}
 .public)

... (type: .public (Bindings k v)
...   (Record
...    [#counter Nat
...     #mappings (List [k v])]))
("lux def type tagged" Bindings
 {#Named [..prelude_module "Bindings"]
         {#UnivQ {#End}
                 {#UnivQ {#End}
                         {#Product
                          ... counter
                          Nat
                          ... mappings
                          {#Apply {#Product {#Parameter 3}
                                            {#Parameter 1}}
                                  List}}}}}
 ["#counter" "#mappings"]
 .public)

... (type: .public Ref
...   {#Local Nat}
...   {#Captured Nat})
("lux def type tagged" Ref
 {#Named [..prelude_module "Ref"]
         {#Sum
          ... Local
          Nat
          ... Captured
          Nat}}
 {"#Local" "#Captured"}
 .public)

... TODO: Get rid of both #name & #inner
... (type: .public Scope
...   (Record
...    [#name     (List Text)
...     #inner    Nat
...     #locals   (Bindings Text [Type Nat])
...     #captured (Bindings Text [Type Ref])]))
("lux def type tagged" Scope
 {#Named [..prelude_module "Scope"]
         {#Product
          ... name
          {#Apply Text List}
          {#Product
           ... inner
           Nat
           {#Product
            ... locals
            {#Apply {#Product Type Nat} {#Apply Text Bindings}}
            ... captured
            {#Apply {#Product Type Ref} {#Apply Text Bindings}}}}}}
 ["#name" "#inner" "#locals" "#captured"]
 .public)

("lux def" Code_List
 ("lux type check type"
  {#Apply Code List})
 #0)

... (type: .public (Either l r)
...   (Variant
...    {#Left l}
...    {#Right r}))
("lux def type tagged" Either
 {#Named [..prelude_module "Either"]
         {#UnivQ {#End}
                 {#UnivQ {#End}
                         {#Sum
                          ... Left
                          {#Parameter 3}
                          ... Right
                          {#Parameter 1}}}}}
 {"#Left" "#Right"}
 .public)

... (type: .public Source
...   [Location Nat Text])
("lux def" Source
 ("lux type check type"
  {#Named [..prelude_module "Source"]
          {#Product Location {#Product Nat Text}}})
 .public)

... (type: .public Module_State
...   (Variant
...    #Active
...    #Compiled
...    #Cached))
("lux def type tagged" Module_State
 {#Named [..prelude_module "Module_State"]
         {#Sum
          ... #Active
          Any
          {#Sum
           ... #Compiled
           Any
           ... #Cached
           Any}}}
 {"#Active" "#Compiled" "#Cached"}
 .public)

... (type: .public Module
...   (Record
...    [#module_hash        Nat
...     #module_aliases     (List [Text Text])
...     #definitions        (List [Text Global])
...     #imports            (List Text)
...     #module_state       Module_State]))
("lux def type tagged" Module
 {#Named [..prelude_module "Module"]
         {#Product
          ... module_hash
          Nat
          {#Product
           ... module_aliases
           {#Apply {#Product Text Text} List}
           {#Product
            ... definitions
            {#Apply {#Product Text Global} List}
            {#Product
             ... imports
             {#Apply Text List}
             ... module_state
             Module_State
             }}}}}
 ["#module_hash" "#module_aliases" "#definitions" "#imports" "#module_state"]
 .public)

... (type: .public Type_Context
...   (Record
...    [#ex_counter Nat
...     #var_counter Nat
...     #var_bindings (List [Nat (Maybe Type)])]))
("lux def type tagged" Type_Context
 {#Named [..prelude_module "Type_Context"]
         {#Product ... ex_counter
          Nat
          {#Product ... var_counter
           Nat
           ... var_bindings
           {#Apply {#Product Nat {#Apply Type Maybe}}
                   List}}}}
 ["#ex_counter" "#var_counter" "#var_bindings"]
 .public)

... (type: .public Mode
...   #Build
...   #Eval
...   #Interpreter)
("lux def type tagged" Mode
 {#Named [..prelude_module "Mode"]
         {#Sum ... Build
          Any
          {#Sum ... Eval
           Any
           ... Interpreter
           Any}}}
 {"#Build" "#Eval" "#Interpreter"}
 .public)

... (type: .public Info
...   (Record
...    [#target        Text
...     #version       Text
...     #mode          Mode
...     #configuration (List [Text Text])]))
("lux def type tagged" Info
 {#Named [..prelude_module "Info"]
         {#Product
          ... target
          Text
          {#Product
           ... version
           Text
           {#Product
            ... mode
            Mode
            ... configuration
            {#Apply {#Product Text Text} List}}}}}
 ["#target" "#version" "#mode" "#configuration"]
 .public)

... (type: .public Lux
...   (Rec Lux
...     (Record
...      [#info            Info
...       #source          Source
...       #location        Location
...       #current_module  (Maybe Text)
...       #modules         (List [Text Module])
...       #scopes          (List Scope)
...       #type_context    Type_Context
...       #expected        (Maybe Type)
...       #seed            Nat
...       #scope_type_vars (List Nat)
...       #extensions      Any
...       #eval            (-> Type Code (-> Lux (Either Text [Lux Any])))
...       #host            Any])))
("lux def type tagged" Lux
 {#Named [..prelude_module "Lux"]
         ({Lux
           {#Apply {0 #0 ["" {#End}]}
                   {#UnivQ {#End}
                           {#Product
                            ... info
                            Info
                            {#Product
                             ... source
                             Source
                             {#Product
                              ... location
                              Location
                              {#Product
                               ... current_module
                               {#Apply Text Maybe}
                               {#Product
                                ... modules
                                {#Apply {#Product Text Module} List}
                                {#Product
                                 ... scopes
                                 {#Apply Scope List}
                                 {#Product
                                  ... type_context
                                  Type_Context
                                  {#Product
                                   ... expected
                                   {#Apply Type Maybe}
                                   {#Product
                                    ... seed
                                    Nat
                                    {#Product
                                     ... scope_type_vars
                                     {#Apply Nat List}
                                     {#Product
                                      ... extensions
                                      Any
                                      {#Product
                                       ... eval
                                       {#Function Type
                                                  {#Function Code
                                                             {#Function Lux
                                                                        {#Sum Text {#Product Lux Any}}}}}
                                       ... host
                                       Any}}}}}}}}}}}}}}}
          {#Apply {0 #0 ["" {#End}]} {#Parameter 0}})}
 ["#info" "#source" "#location" "#current_module" "#modules" "#scopes" "#type_context" "#expected" "#seed" "#scope_type_vars" "#extensions" "#eval" "#host"]
 .public)

... (type: .public (Meta a)
...   (-> Lux (Either Text [Lux a])))
("lux def" Meta
 ("lux type check type"
  {#Named [..prelude_module "Meta"]
          {#UnivQ {#End}
                  {#Function Lux
                             {#Apply {#Product Lux {#Parameter 1}}
                                     {#Apply Text Either}}}}})
 .public)

... (type: .public Macro'
...   (-> (List Code) (Meta (List Code))))
("lux def" Macro'
 ("lux type check type"
  {#Named [..prelude_module "Macro'"]
          {#Function Code_List {#Apply Code_List Meta}}})
 .public)

... (type: .public Macro
...   (Primitive "#Macro"))
("lux def" Macro
 ("lux type check type"
  {#Named [..prelude_module "Macro"]
          {#Primitive "#Macro" {#End}}})
 .public)

... Base functions & macros
("lux def" meta#in
 ("lux type check"
  {#UnivQ {#End}
          {#Function {#Parameter 1}
                     {#Function Lux
                                {#Apply {#Product Lux
                                                  {#Parameter 1}}
                                        {#Apply Text Either}}}}}
  ([_ val]
   ([_ state]
    {#Right [state val]})))
 #0)

("lux def" failure
 ("lux type check"
  {#UnivQ {#End}
          {#Function Text
                     {#Function Lux
                                {#Apply {#Product Lux
                                                  {#Parameter 1}}
                                        {#Apply Text Either}}}}}
  ([_ msg]
   ([_ state]
    {#Left msg})))
 #0)

("lux def" text#composite
 ("lux type check"
  {#Function Text {#Function Text Text}}
  ([_ x]
   ([_ y]
    ("lux text concat" x y))))
 #0)

("lux def" symbol_separator
 ("lux type check"
  Text
  ".")
 #0)

("lux def" symbol#encoded
 ("lux type check"
  {#Function Symbol Text}
  ([_ full_name]
   ({[module name]
     ({"" name
       _  (text#composite module (text#composite ..symbol_separator name))}
      module)}
    full_name)))
 #0)

... TODO: Allow asking the compiler for the name of the definition
... currently being defined. That name can then be fed into
... 'wrong_syntax_error' for easier maintenance of the error_messages.
("lux def" wrong_syntax_error
 ("lux type check"
  {#Function Symbol Text}
  ([_ it]
   (text#composite "Wrong syntax for " (symbol#encoded it))))
 #0)

("lux def" let''
 ("lux macro"
  ([_ tokens]
   ({{#Item lhs {#Item rhs {#Item body {#End}}}}
     (meta#in {#Item (form$ {#Item (variant$ {#Item lhs {#Item body {#End}}})
                                   {#Item rhs {#End}}})
                     {#End}})

     _
     (failure "Wrong syntax for let''")}
    tokens)))
 #0)

("lux def" function''
 ("lux macro"
  ([_ tokens]
   ({{#Item [_ {#Tuple {#Item arg args'}}] {#Item body {#End}}}
     (meta#in {#Item (_ann {#Form {#Item (_ann {#Tuple {#Item (_ann {#Symbol ["" ""]})
                                                              {#Item arg {#End}}}})
                                         {#Item ({{#End}
                                                  body

                                                  _
                                                  (_ann {#Form {#Item (_ann {#Symbol [..prelude_module "function''"]})
                                                                      {#Item (_ann {#Tuple args'})
                                                                             {#Item body {#End}}}}})}
                                                 args')
                                                {#End}}}})
                     {#End}})

     {#Item [_ {#Symbol ["" self]}] {#Item [_ {#Tuple {#Item arg args'}}] {#Item body {#End}}}}
     (meta#in {#Item (_ann {#Form {#Item (_ann {#Tuple {#Item (_ann {#Symbol ["" self]})
                                                              {#Item arg {#End}}}})
                                         {#Item ({{#End}
                                                  body

                                                  _
                                                  (_ann {#Form {#Item (_ann {#Symbol [..prelude_module "function''"]})
                                                                      {#Item (_ann {#Tuple args'})
                                                                             {#Item body {#End}}}}})}
                                                 args')
                                                {#End}}}})
                     {#End}})

     _
     (failure "Wrong syntax for function''")}
    tokens)))
 #0)

("lux def" as_def
 ("lux type check" {#Function Code {#Function Code {#Function Code Code}}}
  (function'' [name value export_policy]
              (form$ {#Item (text$ "lux def") {#Item name {#Item value {#Item export_policy {#End}}}}})))
 #0)

("lux def" as_checked
 ("lux type check" {#Function Code {#Function Code Code}}
  (function'' [type value]
              (form$ {#Item (text$ "lux type check") {#Item type {#Item value {#End}}}})))
 #0)

("lux def" as_function
 ("lux type check" {#Function Code {#Function {#Apply Code List} {#Function Code Code}}}
  (function'' as_function [self inputs output]
              ({{#End}
                output

                {#Item head tail}
                (_ann {#Form {#Item (_ann {#Tuple {#Item self {#Item head {#End}}}})
                                    {#Item (as_function (_ann {#Symbol ["" ""]}) tail output)
                                           {#End}}}})}
               inputs)))
 #0)

("lux def" as_macro
 ("lux type check" {#Function Code Code}
  (function'' [expression]
              (form$ {#Item (text$ "lux macro")
                            {#Item expression
                                   {#End}}})))
 #0)

("lux def" def:''
 ("lux macro"
  (function'' [tokens]
              ({{#Item [export_policy
                        {#Item [[_ {#Form {#Item [name args]}}]
                                {#Item [type {#Item [body {#End}]}]}]}]}
                (meta#in {#Item [(as_def name
                                         (as_checked type (as_function name args body))
                                         export_policy)
                                 {#End}]})

                {#Item [export_policy {#Item [name {#Item [type {#Item [body {#End}]}]}]}]}
                (meta#in {#Item [(as_def name (as_checked type body)
                                         export_policy)
                                 {#End}]})

                _
                (failure "Wrong syntax for def:''")}
               tokens)))
 #0)

("lux def" macro
 ("lux macro"
  (function'' [tokens]
              ({{#Item [_ {#Form {#Item name {#Item head tail}}}] {#Item body {#End}}}
                (meta#in {#Item (as_macro (as_function name {#Item head tail} body))
                                {#End}})

                _
                (failure (wrong_syntax_error [..prelude_module "macro"]))}
               tokens)))
 #1)

(def:'' .public comment
        Macro
        (macro (_ tokens)
          (meta#in {#End})))

(def:'' .private $'
        Macro
        (macro (_ tokens)
          ({{#Item x {#End}}
            (meta#in tokens)

            {#Item x {#Item y xs}}
            (meta#in {#Item (form$ {#Item (symbol$ [..prelude_module "$'"])
                                          {#Item (variant$ {#Item (symbol$ [..prelude_module "#Apply"])
                                                                  {#Item y {#Item x {#End}}}})
                                                 xs}})
                            {#End}})

            _
            (failure "Wrong syntax for $'")}
           tokens)))

(def:'' .private (list#mix f init xs)
        ... (All (_ a b) (-> (-> b a a) a (List b) a))
        {#UnivQ {#End} {#UnivQ {#End} {#Function {#Function {#Parameter 1}
                                                            {#Function {#Parameter 3}
                                                                       {#Parameter 3}}}
                                                 {#Function {#Parameter 3}
                                                            {#Function ($' List {#Parameter 1})
                                                                       {#Parameter 3}}}}}}
        ({{#End}
          init

          {#Item x xs'}
          (list#mix f (f x init) xs')}
         xs))

(def:'' .private (list#reversed list)
        {#UnivQ {#End}
                {#Function ($' List {#Parameter 1}) ($' List {#Parameter 1})}}
        (list#mix ("lux type check" {#UnivQ {#End}
                                            {#Function {#Parameter 1} {#Function ($' List {#Parameter 1}) ($' List {#Parameter 1})}}}
                   (function'' [head tail] {#Item head tail}))
                  {#End}
                  list))

(def:'' .private (list#each f xs)
        {#UnivQ {#End}
                {#UnivQ {#End}
                        {#Function {#Function {#Parameter 3} {#Parameter 1}}
                                   {#Function ($' List {#Parameter 3})
                                              ($' List {#Parameter 1})}}}}
        (list#mix (function'' [head tail] {#Item (f head) tail})
                  {#End}
                  (list#reversed xs)))

(def:'' .private Replacement_Environment
        Type
        ($' List {#Product Text Code}))

(def:'' .private (replacement_environment xs ys)
        {#Function ($' List Text) {#Function ($' List Code) Replacement_Environment}}
        ({[{#Item x xs'} {#Item y ys'}]
          {#Item [x y] (replacement_environment xs' ys')}

          _
          {#End}}
         [xs ys]))

(def:'' .private (text#= reference sample)
        {#Function Text {#Function Text Bit}}
        ("lux text =" reference sample))

(def:'' .private (replacement for environment)
        {#Function Text {#Function Replacement_Environment ($' Maybe Code)}}
        ({{#End}
          {#None}

          {#Item [k v] environment'}
          ({[#1] {#Some v}
            [#0] (replacement for environment')}
           (text#= k for))}
         environment))

(def:'' .private (with_replacements reps syntax)
        {#Function Replacement_Environment {#Function Code Code}}
        ({[_ {#Symbol "" name}]
          ({{#Some replacement}
            replacement

            {#None}
            syntax}
           (..replacement name reps))

          [meta {#Form parts}]
          [meta {#Form (list#each (with_replacements reps) parts)}]

          [meta {#Variant members}]
          [meta {#Variant (list#each (with_replacements reps) members)}]

          [meta {#Tuple members}]
          [meta {#Tuple (list#each (with_replacements reps) members)}]
          
          _
          syntax}
         syntax))

(def:'' .private (n/* param subject)
        {#Function Nat {#Function Nat Nat}}
        ("lux type as" Nat
         ("lux i64 *"
          ("lux type as" Int param)
          ("lux type as" Int subject))))

(def:'' .private (list#size list)
        {#UnivQ {#End}
                {#Function ($' List {#Parameter 1}) Nat}}
        (list#mix (function'' [_ acc] ("lux i64 +" 1 acc)) 0 list))

(def:'' .private (let$ binding value body)
        {#Function Code {#Function Code {#Function Code Code}}}
        (form$ {#Item (variant$ {#Item binding {#Item body {#End}}})
                      {#Item value {#End}}}))

(def:'' .private |#End|
        Code
        (variant$ {#Item (symbol$ [..prelude_module "#End"]) {#End}}))

(def:'' .private (|#Item| head tail)
        {#Function Code {#Function Code Code}}
        (variant$ {#Item (symbol$ [..prelude_module "#Item"])
                         {#Item head
                                {#Item tail
                                       {#End}}}}))

(def:'' .private (UnivQ$ body)
        {#Function Code Code}
        (variant$ {#Item (symbol$ [..prelude_module "#UnivQ"]) {#Item ..|#End| {#Item body {#End}}}}))

(def:'' .private (ExQ$ body)
        {#Function Code Code}
        (variant$ {#Item (symbol$ [..prelude_module "#ExQ"]) {#Item ..|#End| {#Item body {#End}}}}))

(def:'' .private quantification_level
        Text
        ("lux text concat" double_quote
         ("lux text concat" "quantification_level"
          double_quote)))

(def:'' .private quantified
        {#Function Code Code}
        (let$ (local$ ..quantification_level) (nat$ 0)))

(def:'' .private (quantified_type_parameter idx)
        {#Function Nat Code}
        (variant$ {#Item (symbol$ [..prelude_module "#Parameter"])
                         {#Item (form$ {#Item (text$ "lux i64 +")
                                              {#Item (local$ ..quantification_level)
                                                     {#Item (nat$ idx)
                                                            {#End}}}})
                                {#End}}}))

(def:'' .private (next_level depth)
        {#Function Nat Nat}
        ("lux i64 +" 2 depth))

(def:'' .private (self_id? id)
        {#Function Nat Bit}
        ("lux i64 =" id ("lux type as" Nat
                         ("lux i64 *" +2
                          ("lux i64 /" +2
                           ("lux type as" Int
                            id))))))

(def:'' .public (__adjusted_quantified_type__ permission depth type)
        {#Function Nat {#Function Nat {#Function Type Type}}}
        ({0
          ({... Jackpot!
            {#Parameter id}
            ({id'
              ({[#0] {#Parameter id'}
                [#1] {#Parameter ("lux i64 -" 2 id')}}
               (self_id? id))}
             ("lux i64 -" ("lux i64 -" depth id) 0))
            
            ... Recur
            {#Primitive name parameters}
            {#Primitive name (list#each (__adjusted_quantified_type__ permission depth)
                                        parameters)}

            {#Sum left right}
            {#Sum (__adjusted_quantified_type__ permission depth left)
                  (__adjusted_quantified_type__ permission depth right)}
            
            {#Product left right}
            {#Product (__adjusted_quantified_type__ permission depth left)
                      (__adjusted_quantified_type__ permission depth right)}
            
            {#Function input output}
            {#Function (__adjusted_quantified_type__ permission depth input)
                       (__adjusted_quantified_type__ permission depth output)}
            
            {#UnivQ environment body}
            {#UnivQ environment
                    (__adjusted_quantified_type__ permission (next_level depth) body)}
            
            {#ExQ environment body}
            {#ExQ environment
                  (__adjusted_quantified_type__ permission (next_level depth) body)}
            
            {#Apply parameter function}
            {#Apply (__adjusted_quantified_type__ permission depth parameter)
                    (__adjusted_quantified_type__ permission depth function)}

            ... Leave these alone.
            {#Named name anonymous} type
            {#Var id} type
            {#Ex id} type}
           type)

          _
          type}
         permission))

(def:'' .private (with_correct_quantification body)
        {#Function Code Code}
        (form$ {#Item (symbol$ [prelude_module "__adjusted_quantified_type__"])
                      {#Item (local$ ..quantification_level)
                             {#Item (nat$ 0)
                                    {#Item body
                                           {#End}}}}}))

(def:'' .private (with_quantification depth body)
        {#Function Nat {#Function Code Code}}
        ({g!level
          (let$ g!level
                (form$ {#Item (text$ "lux i64 +")
                              {#Item g!level
                                     {#Item (nat$ ("lux type as" Nat
                                                   ("lux i64 *" +2
                                                    ("lux type as" Int
                                                     depth))))
                                            {#End}}}})
                body)}
         (local$ ..quantification_level)))

(def:'' .private (initialized_quantification? lux)
        {#Function Lux Bit}
        ({[..#info _ ..#source _ ..#current_module _ ..#modules _
           ..#scopes scopes ..#type_context _ ..#host _
           ..#seed _ ..#expected _ ..#location _ ..#extensions _
           ..#scope_type_vars _ ..#eval _]
          (list#mix (function'' [scope verdict]
                                ({[#1] #1
                                  _ ({[..#name _ ..#inner _ ..#captured _
                                       ..#locals [..#counter _
                                                  ..#mappings locals]]
                                      (list#mix (function'' [local verdict]
                                                            ({[local _]
                                                              ({[#1] #1
                                                                _ ("lux text =" ..quantification_level local)}
                                                               verdict)}
                                                             local))
                                                #0
                                                locals)}
                                     scope)}
                                 verdict))
                    #0
                    scopes)}
         lux))

(def:'' .public All
        Macro
        (macro (_ tokens lux)
          ({{#Item [_ {#Form {#Item self_name args}}]
                   {#Item body {#End}}}
            {#Right [lux
                     {#Item ({raw
                              ({[#1] raw
                                [#0] (..quantified raw)}
                               (initialized_quantification? lux))}
                             ({{#End}
                               body

                               {#Item head tail}
                               (with_correct_quantification
                                 (let$ self_name (quantified_type_parameter 0)
                                       ({[_ raw]
                                         raw}
                                        (list#mix (function'' [parameter offset,body']
                                                              ({[offset body']
                                                                [("lux i64 +" 2 offset)
                                                                 (let$ parameter (quantified_type_parameter ("lux i64 +" offset 1))
                                                                       (UnivQ$ body'))]}
                                                               offset,body'))
                                                  [0 (with_quantification (list#size args)
                                                       body)]
                                                  args))))}
                              args))
                            {#End}}]}
            
            _
            {#Left "Wrong syntax for All"}}
           tokens)))

(def:'' .public Ex
        Macro
        (macro (_ tokens lux)
          ({{#Item [_ {#Form {#Item self_name args}}]
                   {#Item body {#End}}}
            {#Right [lux
                     {#Item ({raw
                              ({[#1] raw
                                [#0] (..quantified raw)}
                               (initialized_quantification? lux))}
                             ({{#End}
                               body

                               {#Item head tail}
                               (with_correct_quantification
                                 (let$ self_name (quantified_type_parameter 0)
                                       ({[_ raw]
                                         raw}
                                        (list#mix (function'' [parameter offset,body']
                                                              ({[offset body']
                                                                [("lux i64 +" 2 offset)
                                                                 (let$ parameter (quantified_type_parameter ("lux i64 +" offset 1))
                                                                       (ExQ$ body'))]}
                                                               offset,body'))
                                                  [0 (with_quantification (list#size args)
                                                       body)]
                                                  args))))}
                              args))
                            {#End}}]}
            
            _
            {#Left "Wrong syntax for Ex"}}
           tokens)))

(def:'' .public ->
        Macro
        (macro (_ tokens)
          ({{#Item output inputs}
            (meta#in {#Item (list#mix ("lux type check" {#Function Code {#Function Code Code}}
                                       (function'' [i o] (variant$ {#Item (symbol$ [..prelude_module "#Function"]) {#Item i {#Item o {#End}}}})))
                                      output
                                      inputs)
                            {#End}})
            
            _
            (failure "Wrong syntax for ->")}
           (list#reversed tokens))))

(def:'' .public list
        Macro
        (macro (_ xs)
          (meta#in {#Item (list#mix |#Item| |#End| (list#reversed xs))
                          {#End}})))

(def:'' .public partial_list
        Macro
        (macro (_ xs)
          ({{#Item last init}
            (meta#in (list (list#mix |#Item| last init)))

            _
            (failure "Wrong syntax for partial_list")}
           (list#reversed xs))))

(def:'' .public Union
        Macro
        (macro (_ tokens)
          ({{#End}
            (meta#in (list (symbol$ [..prelude_module "Nothing"])))

            {#Item last prevs}
            (meta#in (list (list#mix (function'' [left right] (variant$ (list (symbol$ [..prelude_module "#Sum"]) left right)))
                                     last
                                     prevs)))}
           (list#reversed tokens))))

(def:'' .public Tuple
        Macro
        (macro (_ tokens)
          ({{#End}
            (meta#in (list (symbol$ [..prelude_module "Any"])))

            {#Item last prevs}
            (meta#in (list (list#mix (function'' [left right] (variant$ (list (symbol$ [..prelude_module "#Product"]) left right)))
                                     last
                                     prevs)))}
           (list#reversed tokens))))

(def:'' .private function'
        Macro
        (macro (_ tokens)
          (let'' [name tokens'] ({{#Item [[_ {#Symbol ["" name]}] tokens']}
                                  [name tokens']

                                  _
                                  ["" tokens]}
                                 tokens)
                 ({{#Item [[_ {#Tuple args}] {#Item [body {#End}]}]}
                   ({{#End}
                     (failure "function' requires a non-empty arguments tuple.")
                     
                     {#Item [harg targs]}
                     (meta#in (list (form$ (list (tuple$ (list (local$ name)
                                                               harg))
                                                 (list#mix (function'' [arg body']
                                                                       (form$ (list (tuple$ (list (local$ "")
                                                                                                  arg))
                                                                                    body')))
                                                           body
                                                           (list#reversed targs))))))}
                    args)

                   _
                   (failure "Wrong syntax for function'")}
                  tokens'))))

(def:'' .private def:'''
        Macro
        (macro (_ tokens)
          ({{#Item [export_policy
                    {#Item [[_ {#Form {#Item [name args]}}]
                            {#Item [type {#Item [body {#End}]}]}]}]}
            (meta#in (list (form$ (list (text$ "lux def")
                                        name
                                        (form$ (list (text$ "lux type check")
                                                     type
                                                     (form$ (list (symbol$ [..prelude_module "function'"])
                                                                  name
                                                                  (tuple$ args)
                                                                  body))))
                                        export_policy))))

            {#Item [export_policy {#Item [name {#Item [type {#Item [body {#End}]}]}]}]}
            (meta#in (list (form$ (list (text$ "lux def")
                                        name
                                        (form$ (list (text$ "lux type check")
                                                     type
                                                     body))
                                        export_policy))))

            _
            (failure "Wrong syntax for def:'''")}
           tokens)))

(def:''' .public Or
         Macro
         ..Union)

(def:''' .public And
         Macro
         ..Tuple)

(def:''' .private (pairs xs)
         (All (_ a) (-> ($' List a) ($' Maybe ($' List (Tuple a a)))))
         ({{#Item x {#Item y xs'}}
           ({{#Some tail}
             {#Some {#Item [x y] tail}}
             
             {#None}
             {#None}}
            (pairs xs'))

           {#End}
           {#Some {#End}}

           _
           {#None}}
          xs))

(def:'' .private let'
        Macro
        (macro (_ tokens)
          ({{#Item [_ {#Tuple bindings}] {#Item body {#End}}}
            ({{#Some bindings}
              (meta#in (list (list#mix ("lux type check" (-> (Tuple Code Code) Code
                                                             Code)
                                        (function' [binding body]
                                                   ({[label value]
                                                     (form$ (list (variant$ (list label body)) value))}
                                                    binding)))
                                       body
                                       (list#reversed bindings))))
              
              {#None}
              (failure "Wrong syntax for let'")}
             (pairs bindings))

            _
            (failure "Wrong syntax for let'")}
           tokens)))

(def:''' .private (any? p xs)
         (All (_ a)
           (-> (-> a Bit) ($' List a) Bit))
         ({{#End}
           #0

           {#Item x xs'}
           ({[#1] #1
             [#0] (any? p xs')}
            (p x))}
          xs))

(def:''' .private (with_location content)
         (-> Code Code)
         (tuple$ (list (tuple$ (list (text$ "") (nat$ 0) (nat$ 0)))
                       content)))

(def:''' .private (untemplated_list tokens)
         (-> ($' List Code) Code)
         ({{#End}
           |#End|

           {#Item token tokens'}
           (|#Item| token (untemplated_list tokens'))}
          tokens))

(def:''' .private (list#composite xs ys)
         (All (_ a) (-> ($' List a) ($' List a) ($' List a)))
         (list#mix (function' [head tail] {#Item head tail})
                   ys
                   (list#reversed xs)))

(def:''' .private (right_associativity op a1 a2)
         (-> Code Code Code Code)
         ({[_ {#Form parts}]
           (form$ (list#composite parts (list a1 a2)))

           _
           (form$ (list op a1 a2))}
          op))

(def:''' .private (function#flipped func)
         (All (_ a b c)
           (-> (-> a b c) (-> b a c)))
         (function' [right left]
                    (func left right)))

(def:'' .public left
        Macro
        (macro (_ tokens)
          ({{#Item op tokens'}
            ({{#Item first nexts}
              (meta#in (list (list#mix (function#flipped (right_associativity op)) first nexts)))

              _
              (failure "Wrong syntax for left")}
             tokens')
            
            _
            (failure "Wrong syntax for left")}
           tokens)))

(def:'' .public right
        Macro
        (macro (_ tokens)
          ({{#Item op tokens'}
            ({{#Item last prevs}
              (meta#in (list (list#mix (right_associativity op) last prevs)))

              _
              (failure "Wrong syntax for right")}
             (list#reversed tokens'))
            
            _
            (failure "Wrong syntax for right")}
           tokens)))

(def:''' .public all Macro ..right)

... (type: (Monad m)
...   (Interface
...    (is (All (_ a) (-> a (m a)))
...        #in)
...    (is (All (_ a b) (-> (-> a (m b)) (m a) (m b)))
...        #then)))
("lux def type tagged" Monad
 {#Named [..prelude_module "Monad"]
         (All (_ !)
           (Tuple (All (_ a)
                    (-> a ($' ! a)))
                  (All (_ a b)
                    (-> (-> a ($' ! b))
                        ($' ! a)
                        ($' ! b)))))}
 ["#in" "#then"]
 #0)

(def:''' .private maybe_monad
         ($' Monad Maybe)
         [#in
          (function' [x] {#Some x})
          
          #then
          (function' [f ma]
                     ({{#None}   {#None}
                       {#Some a} (f a)}
                      ma))])

(def:''' .private meta_monad
         ($' Monad Meta)
         [#in
          (function' [x]
                     (function' [state]
                                {#Right state x}))
          
          #then
          (function' [f ma]
                     (function' [state]
                                ({{#Left msg}
                                  {#Left msg}

                                  {#Right [state' a]}
                                  (f a state')}
                                 (ma state))))])

(def:'' .private do
        Macro
        (macro (_ tokens)
          ({{#Item monad {#Item [_ {#Tuple bindings}] {#Item body {#End}}}}
            ({{#Some bindings}
              (let' [g!in (local$ "in")
                     g!then (local$ " then ")
                     body' (list#mix ("lux type check" (-> (Tuple Code Code) Code Code)
                                      (function' [binding body']
                                                 (let' [[var value] binding]
                                                       ({[_ {#Symbol [module short]}]
                                                         ({""
                                                           (form$ (list g!then
                                                                        (form$ (list (tuple$ (list (local$ "") var)) body'))
                                                                        value))

                                                           _
                                                           (form$ (list var value body'))}
                                                          module)
                                                         

                                                         _
                                                         (form$ (list g!then
                                                                      (form$ (list (tuple$ (list (local$ "") var)) body'))
                                                                      value))}
                                                        var))))
                                     body
                                     (list#reversed bindings))]
                    (meta#in (list (form$ (list (variant$ (list (tuple$ (list g!in g!then))
                                                                body'))
                                                monad)))))
              
              {#None}
              (failure "Wrong syntax for do")}
             (pairs bindings))

            _
            (failure "Wrong syntax for do")}
           tokens)))

(def:''' .private (monad#each m f xs)
         (All (_ m a b)
           (-> ($' Monad m)
               (-> a ($' m b))
               ($' List a)
               ($' m ($' List b))))
         (let' [[..#in in ..#then _] m]
               ({{#End}
                 (in {#End})
                 
                 {#Item x xs'}
                 (do m
                   [y (f x)
                    ys (monad#each m f xs')]
                   (in {#Item y ys}))}
                xs)))

(def:''' .private (monad#mix m f y xs)
         (All (_ m a b)
           (-> ($' Monad m)
               (-> a b ($' m b))
               b
               ($' List a)
               ($' m b)))
         (let' [[..#in in ..#then _] m]
               ({{#End}
                 (in y)
                 
                 {#Item x xs'}
                 (do m
                   [y' (f x y)]
                   (monad#mix m f y' xs'))}
                xs)))

(def:'' .public if
        Macro
        (macro (_ tokens)
          ({{#Item test {#Item then {#Item else {#End}}}}
            (meta#in (list (form$ (list (variant$ (list (bit$ #1)  then
                                                        (bit$ #0) else))
                                        test))))

            _
            (failure "Wrong syntax for if")}
           tokens)))

(def:''' .private PList
         Type
         (All (_ a) ($' List (Tuple Text a))))

(def:''' .private (plist#value k plist)
         (All (_ a)
           (-> Text ($' PList a) ($' Maybe a)))
         ({{#Item [[k' v] plist']}
           (if (text#= k k')
             {#Some v}
             (plist#value k plist'))

           {#End}
           {#None}}
          plist))

(def:''' .private (plist#with k v plist)
         (All (_ a)
           (-> Text a ($' PList a) ($' PList a)))
         ({{#Item [k' v'] plist'}
           (if (text#= k k')
             (partial_list [k v] plist')
             (partial_list [k' v'] (plist#with k v plist')))

           {#End}
           (list [k v])}
          plist))

(def:''' .private (global_symbol full_name state)
         (-> Symbol ($' Meta Symbol))
         (let' [[module name] full_name
                [..#info info ..#source    source  ..#current_module _ ..#modules modules
                 ..#scopes scopes ..#type_context types    ..#host    host
                 ..#seed seed ..#expected  expected ..#location  location ..#extensions extensions
                 ..#scope_type_vars scope_type_vars ..#eval _eval] state]
               ({{#Some [..#module_hash _ ..#module_aliases _ ..#definitions definitions ..#imports _ ..#module_state _]}
                 ({{#Some constant}
                   ({{#Definition _} {#Right [state full_name]}
                     {#Tag _} {#Right [state full_name]}
                     {#Slot _} {#Right [state full_name]}
                     {#Type _} {#Right [state full_name]}

                     {#Alias real_name}
                     {#Right [state real_name]}}
                    constant)

                   {#None}
                   {#Left (all text#composite "Unknown definition: " (symbol#encoded full_name))}}
                  (plist#value name definitions))
                 
                 {#None}
                 {#Left (all text#composite "Unknown module: " module " @ " (symbol#encoded full_name))}}
                (plist#value module modules))))

(def:''' .private (:List<Code> expression)
         (-> Code Code)
         (let' [type (variant$ (list (symbol$ [..prelude_module "#Apply"])
                                     (symbol$ [..prelude_module "Code"])
                                     (symbol$ [..prelude_module "List"])))]
               (form$ (list (text$ "lux type check") type expression))))

(def:''' .private (spliced replace? untemplated elems)
         (-> Bit (-> Code ($' Meta Code)) ($' List Code) ($' Meta Code))
         ({[#1] ({{#End}
                  (meta#in |#End|)
                  
                  {#Item lastI inits}
                  (do meta_monad
                    [lastO ({[_ {#Form {#Item [[_ {#Symbol ["" "~+"]}] {#Item [spliced {#End}]}]}}]
                             (in (:List<Code> spliced))

                             _
                             (do meta_monad
                               [lastO (untemplated lastI)]
                               (in (:List<Code> (|#Item| lastO |#End|))))}
                            lastI)]
                    (monad#mix meta_monad
                               (function' [leftI rightO]
                                          ({[_ {#Form {#Item [[_ {#Symbol ["" "~+"]}] {#Item [spliced {#End}]}]}}]
                                            (let' [g!in-module (form$ (list (text$ "lux in-module")
                                                                            (text$ ..prelude_module)
                                                                            (symbol$ [..prelude_module "list#composite"])))]
                                                  (in (form$ (list g!in-module (:List<Code> spliced) rightO))))

                                            _
                                            (do meta_monad
                                              [leftO (untemplated leftI)]
                                              (in (|#Item| leftO rightO)))}
                                           leftI))
                               lastO
                               inits))}
                 (list#reversed elems))
           [#0] (do meta_monad
                  [=elems (monad#each meta_monad untemplated elems)]
                  (in (untemplated_list =elems)))}
          replace?))

(def:''' .private (untemplated_text value)
         (-> Text Code)
         (with_location (variant$ (list (symbol$ [..prelude_module "#Text"]) (text$ value)))))

(def:''' .private (untemplated replace? subst token)
         (-> Bit Text Code ($' Meta Code))
         ({[_ [_ {#Bit value}]]
           (meta#in (with_location (variant$ (list (symbol$ [..prelude_module "#Bit"]) (bit$ value)))))

           [_ [_ {#Nat value}]]
           (meta#in (with_location (variant$ (list (symbol$ [..prelude_module "#Nat"]) (nat$ value)))))

           [_ [_ {#Int value}]]
           (meta#in (with_location (variant$ (list (symbol$ [..prelude_module "#Int"]) (int$ value)))))

           [_ [_ {#Rev value}]]
           (meta#in (with_location (variant$ (list (symbol$ [..prelude_module "#Rev"]) (rev$ value)))))
           
           [_ [_ {#Frac value}]]
           (meta#in (with_location (variant$ (list (symbol$ [..prelude_module "#Frac"]) (frac$ value)))))

           [_ [_ {#Text value}]]
           (meta#in (untemplated_text value))

           [#1 [_ {#Symbol [module name]}]]
           (do meta_monad
             [real_name ({""
                          (if (text#= "" subst)
                            (in [module name])
                            (global_symbol [subst name]))

                          _
                          (in [module name])}
                         module)
              .let' [[module name] real_name]]
             (meta#in (with_location (variant$ (list (symbol$ [..prelude_module "#Symbol"]) (tuple$ (list (text$ module) (text$ name))))))))

           [#0 [_ {#Symbol [module name]}]]
           (meta#in (with_location (variant$ (list (symbol$ [..prelude_module "#Symbol"]) (tuple$ (list (text$ module) (text$ name)))))))

           [#1 [_ {#Form {#Item [[_ {#Symbol ["" "~"]}] {#Item [unquoted {#End}]}]}}]]
           (meta#in (form$ (list (text$ "lux type check")
                                 (symbol$ [..prelude_module "Code"])
                                 unquoted)))

           [#1 [_ {#Form {#Item [[_ {#Symbol ["" "~!"]}] {#Item [dependent {#End}]}]}}]]
           (do meta_monad
             [independent (untemplated replace? subst dependent)]
             (in (with_location (variant$ (list (symbol$ [..prelude_module "#Form"])
                                                (untemplated_list (list (untemplated_text "lux in-module")
                                                                        (untemplated_text subst)
                                                                        independent)))))))

           [#1 [_ {#Form {#Item [[_ {#Symbol ["" "~'"]}] {#Item [keep_quoted {#End}]}]}}]]
           (untemplated #0 subst keep_quoted)

           [_ [meta {#Form elems}]]
           (do meta_monad
             [output (spliced replace? (untemplated replace? subst) elems)
              .let' [[_ output'] (with_location (variant$ (list (symbol$ [..prelude_module "#Form"]) output)))]]
             (in [meta output']))

           [_ [meta {#Variant elems}]]
           (do meta_monad
             [output (spliced replace? (untemplated replace? subst) elems)
              .let' [[_ output'] (with_location (variant$ (list (symbol$ [..prelude_module "#Variant"]) output)))]]
             (in [meta output']))

           [_ [meta {#Tuple elems}]]
           (do meta_monad
             [output (spliced replace? (untemplated replace? subst) elems)
              .let' [[_ output'] (with_location (variant$ (list (symbol$ [..prelude_module "#Tuple"]) output)))]]
             (in [meta output']))}
          [replace? token]))

(def:'' .public Primitive
        Macro
        (macro (_ tokens)
          ({{#Item [_ {#Text class_name}] {#End}}
            (meta#in (list (variant$ (list (symbol$ [..prelude_module "#Primitive"]) (text$ class_name) |#End|))))

            {#Item [_ {#Text class_name}] {#Item [_ {#Tuple params}] {#End}}}
            (meta#in (list (variant$ (list (symbol$ [..prelude_module "#Primitive"]) (text$ class_name) (untemplated_list params)))))

            _
            (failure "Wrong syntax for Primitive")}
           tokens)))

(def:'' .private (current_module_name state)
        ($' Meta Text)
        ({[..#info info ..#source    source  ..#current_module current_module ..#modules modules
           ..#scopes scopes ..#type_context types    ..#host    host
           ..#seed seed ..#expected  expected ..#location  location ..#extensions extensions
           ..#scope_type_vars scope_type_vars ..#eval _eval]
          ({{#Some module_name}
            {#Right [state module_name]}

            _
            {#Left "Cannot get the module name without a module!"}}
           current_module)}
         state))

(def:'' .public `
        Macro
        (macro (_ tokens)
          ({{#Item template {#End}}
            (do meta_monad
              [current_module current_module_name
               =template (untemplated #1 current_module template)]
              (in (list (form$ (list (text$ "lux type check")
                                     (symbol$ [..prelude_module "Code"])
                                     =template)))))

            _
            (failure "Wrong syntax for `")}
           tokens)))

(def:'' .public `'
        Macro
        (macro (_ tokens)
          ({{#Item template {#End}}
            (do meta_monad
              [=template (untemplated #1 "" template)]
              (in (list (form$ (list (text$ "lux type check") (symbol$ [..prelude_module "Code"]) =template)))))

            _
            (failure "Wrong syntax for `")}
           tokens)))

(def:'' .public '
        Macro
        (macro (_ tokens)
          ({{#Item template {#End}}
            (do meta_monad
              [=template (untemplated #0 "" template)]
              (in (list (form$ (list (text$ "lux type check") (symbol$ [..prelude_module "Code"]) =template)))))

            _
            (failure "Wrong syntax for '")}
           tokens)))

(def:'' .public |>
        Macro
        (macro (_ tokens)
          ({{#Item [init apps]}
            (meta#in (list (list#mix ("lux type check" (-> Code Code Code)
                                      (function' [app acc]
                                                 ({[_ {#Variant parts}]
                                                   (variant$ (list#composite parts (list acc)))

                                                   [_ {#Tuple parts}]
                                                   (tuple$ (list#composite parts (list acc)))

                                                   [_ {#Form parts}]
                                                   (form$ (list#composite parts (list acc)))

                                                   _
                                                   (` ((~ app) (~ acc)))}
                                                  app)))
                                     init
                                     apps)))

            _
            (failure "Wrong syntax for |>")}
           tokens)))

(def:'' .public <|
        Macro
        (macro (_ tokens)
          ({{#Item [init apps]}
            (meta#in (list (list#mix ("lux type check" (-> Code Code Code)
                                      (function' [app acc]
                                                 ({[_ {#Variant parts}]
                                                   (variant$ (list#composite parts (list acc)))

                                                   [_ {#Tuple parts}]
                                                   (tuple$ (list#composite parts (list acc)))

                                                   [_ {#Form parts}]
                                                   (form$ (list#composite parts (list acc)))

                                                   _
                                                   (` ((~ app) (~ acc)))}
                                                  app)))
                                     init
                                     apps)))

            _
            (failure "Wrong syntax for <|")}
           (list#reversed tokens))))

(def:''' .private (function#composite f g)
         (All (_ a b c)
           (-> (-> b c) (-> a b) (-> a c)))
         (function' [x] (f (g x))))

(def:''' .private (symbol_name x)
         (-> Code ($' Maybe Symbol))
         ({[_ {#Symbol sname}]
           {#Some sname}

           _
           {#None}}
          x))

(def:''' .private (symbol_short x)
         (-> Code ($' Maybe Text))
         ({[_ {#Symbol "" sname}]
           {#Some sname}

           _
           {#None}}
          x))

(def:''' .private (tuple_list tuple)
         (-> Code ($' Maybe ($' List Code)))
         ({[_ {#Tuple members}]
           {#Some members}

           _
           {#None}}
          tuple))

(def:''' .private (realized_template env template)
         (-> Replacement_Environment Code Code)
         ({[_ {#Symbol "" sname}]
           ({{#Some subst}
             subst

             _
             template}
            (..replacement sname env))

           [meta {#Form elems}]
           [meta {#Form (list#each (realized_template env) elems)}]

           [meta {#Tuple elems}]
           [meta {#Tuple (list#each (realized_template env) elems)}]

           [meta {#Variant elems}]
           [meta {#Variant (list#each (realized_template env) elems)}]

           _
           template}
          template))

(def:''' .private (every? p xs)
         (All (_ a)
           (-> (-> a Bit) ($' List a) Bit))
         (list#mix (function' [_2 _1] (if _1 (p _2) #0)) #1 xs))

(def:''' .private (high_bits value)
         (-> ($' I64 Any) I64)
         ("lux i64 right-shift" 32 value))

(def:''' .private low_mask
         I64
         (|> 1 ("lux i64 left-shift" 32) ("lux i64 -" 1)))

(def:''' .private (low_bits value)
         (-> ($' I64 Any) I64)
         ("lux i64 and" low_mask value))

(def:''' .private (n/< reference sample)
         (-> Nat Nat Bit)
         (let' [referenceH (high_bits reference)
                sampleH (high_bits sample)]
               (if ("lux i64 <" referenceH sampleH)
                 #1
                 (if ("lux i64 =" referenceH sampleH)
                   ("lux i64 <"
                    (low_bits reference)
                    (low_bits sample))
                   #0))))

(def:''' .private (list#conjoint xs)
         (All (_ a)
           (-> ($' List ($' List a)) ($' List a)))
         (list#mix list#composite {#End} (list#reversed xs)))

(def:'' .public with_template
        Macro
        (macro (_ tokens)
          ({{#Item [[_ {#Tuple bindings}] {#Item [[_ {#Tuple templates}] data]}]}
            ({[{#Some bindings'} {#Some data'}]
              (let' [apply ("lux type check" (-> Replacement_Environment ($' List Code))
                            (function' [env] (list#each (realized_template env) templates)))
                     num_bindings (list#size bindings')]
                    (if (every? (function' [size] ("lux i64 =" num_bindings size))
                                (list#each list#size data'))
                      (|> data'
                          (list#each (function#composite apply (replacement_environment bindings')))
                          list#conjoint
                          meta#in)
                      (failure (..wrong_syntax_error [..prelude_module "with_template"]))))

              _
              (failure (..wrong_syntax_error [..prelude_module "with_template"]))}
             [(monad#each maybe_monad symbol_short bindings)
              (monad#each maybe_monad tuple_list data)])

            _
            (failure (..wrong_syntax_error [..prelude_module "with_template"]))}
           tokens)))

(def:''' .private (n// param subject)
         (-> Nat Nat Nat)
         (if ("lux i64 <" +0 ("lux type as" Int param))
           (if (n/< param subject)
             0
             1)
           (let' [quotient (|> subject
                               ("lux i64 right-shift" 1)
                               ("lux i64 /" ("lux type as" Int param))
                               ("lux i64 left-shift" 1))
                  flat ("lux i64 *"
                        ("lux type as" Int param)
                        ("lux type as" Int quotient))
                  remainder ("lux i64 -" flat subject)]
                 (if (n/< param remainder)
                   quotient
                   ("lux i64 +" 1 quotient)))))

(def:''' .private (n/% param subject)
         (-> Nat Nat Nat)
         (let' [flat ("lux i64 *"
                      ("lux type as" Int param)
                      ("lux type as" Int (n// param subject)))]
               ("lux i64 -" flat subject)))

(def:''' .private (n/min left right)
         (-> Nat Nat Nat)
         (if (n/< right left)
           left
           right))

(def:''' .private (bit#encoded x)
         (-> Bit Text)
         (if x "#1" "#0"))

(def:''' .private (digit::format digit)
         (-> Nat Text)
         ({[0] "0"
           [1] "1" [2] "2" [3] "3"
           [4] "4" [5] "5" [6] "6"
           [7] "7" [8] "8" [9] "9"
           _ ("lux io error" "@digit::format Undefined behavior.")}
          digit))

(def:''' .private (nat#encoded value)
         (-> Nat Text)
         ({[0] "0"
           _ (let' [loop ("lux type check" (-> Nat Text Text)
                          (function' again [input output]
                                     (if ("lux i64 =" 0 input)
                                       output
                                       (again (n// 10 input)
                                              (text#composite (|> input (n/% 10) digit::format)
                                                              output)))))]
                   (loop value ""))}
          value))

(def:''' .private (int#abs value)
         (-> Int Int)
         (if ("lux i64 <" +0 value)
           ("lux i64 *" -1 value)
           value))

(def:''' .private (int#encoded value)
         (-> Int Text)
         (if ("lux i64 =" +0 value)
           "+0"
           (let' [sign (if ("lux i64 <" value +0)
                         "+"
                         "-")]
                 (("lux type check" (-> Int Text Text)
                   (function' again [input output]
                              (if ("lux i64 =" +0 input)
                                (text#composite sign output)
                                (again ("lux i64 /" +10 input)
                                       (text#composite (|> input ("lux i64 %" +10) ("lux type as" Nat) digit::format)
                                                       output)))))
                  (|> value ("lux i64 /" +10) int#abs)
                  (|> value ("lux i64 %" +10) int#abs ("lux type as" Nat) digit::format)))))

(def:''' .private (frac#encoded x)
         (-> Frac Text)
         ("lux f64 encode" x))

(def:''' .public (not x)
         (-> Bit Bit)
         (if x #0 #1))

(def:''' .private (macro_type? type)
         (-> Type Bit)
         ({{#Named ["library/lux" "Macro"] {#Primitive "#Macro" {#End}}}
           #1

           _
           #0}
          type))

(def:''' .private (named_macro' modules current_module module name)
         (-> ($' List (Tuple Text Module))
             Text Text Text
             ($' Maybe Macro))
         (do maybe_monad
           [$module (plist#value module modules)
            gdef (let' [[..#module_hash _ ..#module_aliases _ ..#definitions bindings ..#imports _ ..#module_state _] ("lux type check" Module $module)]
                       (plist#value name bindings))]
           ({{#Alias [r_module r_name]}
             (named_macro' modules current_module r_module r_name)

             {#Definition [exported? def_type def_value]}
             (if (macro_type? def_type)
               (if exported?
                 {#Some ("lux type as" Macro def_value)}
                 (if (text#= module current_module)
                   {#Some ("lux type as" Macro def_value)}
                   {#None}))
               {#None})

             {#Type [exported? type labels]}
             {#None}

             {#Tag _}
             {#None}

             {#Slot _}
             {#None}}
            ("lux type check" Global gdef))))

(def:''' .private (normal name)
         (-> Symbol ($' Meta Symbol))
         ({["" name]
           (do meta_monad
             [module_name ..current_module_name]
             (in [module_name name]))

           _
           (meta#in name)}
          name))

(def:''' .private (named_macro full_name)
         (-> Symbol ($' Meta ($' Maybe Macro)))
         (do meta_monad
           [current_module current_module_name]
           (let' [[module name] full_name]
                 (function' [state]
                            ({[..#info info ..#source source ..#current_module _ ..#modules modules
                               ..#scopes   scopes   ..#type_context   types   ..#host host
                               ..#seed   seed ..#expected expected
                               ..#location location ..#extensions extensions
                               ..#scope_type_vars scope_type_vars ..#eval _eval]
                              {#Right state (named_macro' modules current_module module name)}}
                             state)))))

(def:''' .private (macro? name)
         (-> Symbol ($' Meta Bit))
         (do meta_monad
           [name (normal name)
            output (named_macro name)]
           (in ({{#Some _} #1
                 {#None}   #0}
                output))))

(def:''' .private (list#interposed sep xs)
         (All (_ a)
           (-> a ($' List a) ($' List a)))
         ({{#End}
           xs

           {#Item [x {#End}]}
           xs

           {#Item [x xs']}
           (partial_list x sep (list#interposed sep xs'))}
          xs))

(def:''' .private (single_expansion token)
         (-> Code ($' Meta ($' List Code)))
         ({[_ {#Form {#Item [_ {#Symbol name}] args}}]
           (do meta_monad
             [name' (normal name)
              ?macro (named_macro name')]
             ({{#Some macro}
               (("lux type as" Macro' macro) args)
               
               {#None}
               (in (list token))}
              ?macro))

           _
           (meta#in (list token))}
          token))

(def:''' .private (expansion token)
         (-> Code ($' Meta ($' List Code)))
         ({[_ {#Form {#Item [_ {#Symbol name}] args}}]
           (do meta_monad
             [name' (normal name)
              ?macro (named_macro name')]
             ({{#Some macro}
               (do meta_monad
                 [top_level_expansion (("lux type as" Macro' macro) args)
                  recursive_expansion (monad#each meta_monad expansion top_level_expansion)]
                 (in (list#conjoint recursive_expansion)))
               
               {#None}
               (in (list token))}
              ?macro))

           _
           (meta#in (list token))}
          token))

(def:''' .private (full_expansion' full_expansion name args)
         (-> (-> Code ($' Meta ($' List Code))) Symbol ($' List Code) ($' Meta ($' List Code)))
         (do meta_monad
           [name' (normal name)
            ?macro (named_macro name')]
           ({{#Some macro}
             (do meta_monad
               [expansion (("lux type as" Macro' macro) args)
                expansion' (monad#each meta_monad full_expansion expansion)]
               (in (list#conjoint expansion')))
             
             {#None}
             (do meta_monad
               [args' (monad#each meta_monad full_expansion args)]
               (in (list (form$ {#Item (symbol$ name) (list#conjoint args')}))))}
            ?macro)))

(def:''' .private (in_module module meta)
         (All (_ a)
           (-> Text ($' Meta a) ($' Meta a)))
         (function' [lux]
                    ({[..#info info ..#source source
                       ..#current_module current_module ..#modules modules
                       ..#scopes scopes ..#type_context type_context
                       ..#host host ..#seed seed
                       ..#expected expected ..#location location
                       ..#extensions extensions ..#scope_type_vars scope_type_vars
                       ..#eval eval]
                      ({{#Left error}
                        {#Left error}
                        
                        {#Right [[..#info info' ..#source source'
                                  ..#current_module _ ..#modules modules'
                                  ..#scopes scopes' ..#type_context type_context'
                                  ..#host host' ..#seed seed'
                                  ..#expected expected' ..#location location'
                                  ..#extensions extensions' ..#scope_type_vars scope_type_vars'
                                  ..#eval eval']
                                 output]}
                        {#Right [[..#info info' ..#source source'
                                  ..#current_module current_module ..#modules modules'
                                  ..#scopes scopes' ..#type_context type_context'
                                  ..#host host' ..#seed seed'
                                  ..#expected expected' ..#location location'
                                  ..#extensions extensions' ..#scope_type_vars scope_type_vars'
                                  ..#eval eval']
                                 output]}}
                       (meta [..#info info ..#source source
                              ..#current_module {.#Some module} ..#modules modules
                              ..#scopes scopes ..#type_context type_context
                              ..#host host ..#seed seed
                              ..#expected expected ..#location location
                              ..#extensions extensions ..#scope_type_vars scope_type_vars
                              ..#eval eval]))}
                     lux)))

(def:''' .private (full_expansion expand_in_module?)
         (-> Bit Code ($' Meta ($' List Code)))
         (function' again [syntax]
                    ({[_ {#Form {#Item head tail}}]
                      ({[_ {#Form {#Item [_ {#Text "lux in-module"}]
                                         {#Item [_ {#Text module}]
                                                {#Item [_ {#Symbol name}]
                                                       {#End}}}}}]
                        (if expand_in_module?
                          (..in_module module (..full_expansion' again name tail))
                          (do meta_monad
                            [members' (monad#each meta_monad again {#Item head tail})]
                            (in (list (form$ (list#conjoint members'))))))

                        [_ {#Symbol name}]
                        (..full_expansion' again name tail)

                        _
                        (do meta_monad
                          [members' (monad#each meta_monad again {#Item head tail})]
                          (in (list (form$ (list#conjoint members')))))}
                       head)

                      [_ {#Variant members}]
                      (do meta_monad
                        [members' (monad#each meta_monad again members)]
                        (in (list (variant$ (list#conjoint members')))))

                      [_ {#Tuple members}]
                      (do meta_monad
                        [members' (monad#each meta_monad again members)]
                        (in (list (tuple$ (list#conjoint members')))))

                      _
                      (meta#in (list syntax))}
                     syntax)))

(def:''' .private (text#encoded original)
         (-> Text Text)
         (all text#composite ..double_quote original ..double_quote))

(def:''' .private (code#encoded code)
         (-> Code Text)
         ({[_ {#Bit value}]
           (bit#encoded value)

           [_ {#Nat value}]
           (nat#encoded value)

           [_ {#Int value}]
           (int#encoded value)

           [_ {#Rev value}]
           ("lux io error" "@code#encoded Undefined behavior.")
           
           [_ {#Frac value}]
           (frac#encoded value)

           [_ {#Text value}]
           (text#encoded value)
           
           [_ {#Symbol [module name]}]
           (symbol#encoded [module name])
           
           [_ {#Form xs}]
           (all text#composite "(" (|> xs
                                       (list#each code#encoded)
                                       (list#interposed " ")
                                       list#reversed
                                       (list#mix text#composite "")) ")")
           
           [_ {#Tuple xs}]
           (all text#composite "[" (|> xs
                                       (list#each code#encoded)
                                       (list#interposed " ")
                                       list#reversed
                                       (list#mix text#composite "")) "]")
           
           [_ {#Variant xs}]
           (all text#composite "{" (|> xs
                                       (list#each code#encoded)
                                       (list#interposed " ")
                                       list#reversed
                                       (list#mix text#composite "")) "}")}
          code))

(def:''' .private (normal_type type)
         (-> Code Code)
         ({[_ {#Variant {#Item [_ {#Symbol symbol}] parts}}]
           (` {(~ (symbol$ symbol)) (~+ (list#each normal_type parts))})

           [_ {#Tuple members}]
           (` (Tuple (~+ (list#each normal_type members))))

           [_ {#Form {#Item [_ {#Text "lux in-module"}]
                            {#Item [_ {#Text module}]
                                   {#Item type'
                                          {#End}}}}}]
           (` ("lux in-module" (~ (text$ module)) (~ (normal_type type'))))

           [_ {#Form {#Item [_ {#Symbol ["" "~"]}] {#Item expression {#End}}}}]
           expression

           [_0 {#Form {#Item [_1 {#Variant {#Item binding {#Item body {#End}}}}]
                             {#Item value
                                    {#End}}}}]
           [_0 {#Form {#Item [_1 {#Variant {#Item binding {#Item (normal_type body) {#End}}}}]
                             {#Item value
                                    {#End}}}}]

           [_0 {#Form {#Item [_1 {#Symbol ["library/lux" "__adjusted_quantified_type__"]}]
                             {#Item _permission
                                    {#Item _level
                                           {#Item body
                                                  {#End}}}}}}]
           [_0 {#Form {#Item [_1 {#Symbol [..prelude_module "__adjusted_quantified_type__"]}]
                             {#Item _permission
                                    {#Item _level
                                           {#Item (normal_type body)
                                                  {#End}}}}}}]

           [_ {#Form {#Item type_fn args}}]
           (list#mix ("lux type check" (-> Code Code Code)
                      (function' [arg type_fn] (` {.#Apply (~ arg) (~ type_fn)})))
                     (normal_type type_fn)
                     (list#each normal_type args))

           _
           type}
          type))

(def:'' .public type
        Macro
        (macro (_ tokens)
          ({{#Item type {#End}}
            (do meta_monad
              [initialized_quantification? (function' [lux] {#Right [lux (initialized_quantification? lux)]})]
              (if initialized_quantification?
                (do meta_monad
                  [type+ (full_expansion #0 type)]
                  ({{#Item type' {#End}}
                    (in (list (normal_type type')))

                    _
                    (failure "The expansion of the type-syntax had to yield a single element.")}
                   type+))
                (in (list (..quantified (` (..type (~ type))))))))

            _
            (failure "Wrong syntax for type")}
           tokens)))

(def:'' .public is
        Macro
        (macro (_ tokens)
          ({{#Item type {#Item value {#End}}}
            (meta#in (list (` ("lux type check"
                               (..type (~ type))
                               (~ value)))))

            _
            (failure "Wrong syntax for :")}
           tokens)))

(def:'' .public as
        Macro
        (macro (_ tokens)
          ({{#Item type {#Item value {#End}}}
            (meta#in (list (` ("lux type as"
                               (..type (~ type))
                               (~ value)))))

            _
            (failure "Wrong syntax for as")}
           tokens)))

(def:''' .private (empty? xs)
         (All (_ a)
           (-> ($' List a) Bit))
         ({{#End} #1
           _      #0}
          xs))

(with_template [<name> <type> <value>]
  [(def:''' .private (<name> xy)
            (All (_ a b)
              (-> (Tuple a b) <type>))
            (let' [[x y] xy]
                  <value>))]

  [product#left  a x]
  [product#right b y])

(def:''' .private (generated_symbol prefix state)
         (-> Text ($' Meta Code))
         ({[..#info info ..#source source ..#current_module _ ..#modules modules
            ..#scopes   scopes   ..#type_context   types   ..#host host
            ..#seed   seed ..#expected expected
            ..#location location ..#extensions extensions
            ..#scope_type_vars scope_type_vars ..#eval _eval]
           {#Right [..#info info ..#source source ..#current_module _ ..#modules modules
                    ..#scopes   scopes   ..#type_context   types   ..#host host
                    ..#seed   ("lux i64 +" 1 seed) ..#expected expected
                    ..#location location ..#extensions extensions
                    ..#scope_type_vars scope_type_vars ..#eval _eval]
                   (local$ (all text#composite "__gensym__" prefix (nat#encoded seed)))}}
          state))

(def:'' .public exec
        Macro
        (macro (_ tokens)
          ({{#Item value actions}
            (let' [dummy (local$ "")]
                  (meta#in (list (list#mix ("lux type check" (-> Code Code Code)
                                            (function' [pre post] (` ({(~ dummy) (~ post)}
                                                                      (~ pre)))))
                                           value
                                           actions))))

            _
            (failure "Wrong syntax for exec")}
           (list#reversed tokens))))

(def:'' .private def:'
        Macro
        (macro (_ tokens)
          (let' [parts (is (Maybe [Code Code (List Code) (Maybe Code) Code])
                           ({{#Item export_policy {#Item [_ {#Form {#Item name args}}] {#Item type {#Item body {#End}}}}}
                             {#Some [export_policy name args {#Some type} body]}
                             
                             {#Item export_policy {#Item name {#Item type {#Item body {#End}}}}}
                             {#Some [export_policy name {#End} {#Some type} body]}
                             
                             {#Item export_policy {#Item [_ {#Form {#Item name args}}] {#Item body {#End}}}}
                             {#Some [export_policy name args {#None} body]}
                             
                             {#Item export_policy {#Item name {#Item body {#End}}}}
                             {#Some [export_policy name {#End} {#None} body]}

                             _
                             {#None}}
                            tokens))]
                ({{#Some [export_policy name args ?type body]}
                  (let' [body' ({{#End}
                                 body

                                 _
                                 (` (function' (~ name) [(~+ args)] (~ body)))}
                                args)
                         body'' ({{#Some type}
                                  (` (is (~ type) (~ body')))
                                  
                                  {#None}
                                  body'}
                                 ?type)]
                        (meta#in (list (` ("lux def" (~ name)
                                           (~ body'')
                                           (~ export_policy))))))
                  
                  {#None}
                  (failure "Wrong syntax for def'")}
                 parts))))

(def:' .private (expander branches)
       (-> (List Code) (Meta (List Code)))
       ({{#Item [_ {#Form {#Item [_ {#Symbol name}] args}}]
                {#Item body
                       branches'}}
         (do meta_monad
           [??? (macro? name)]
           (if ???
             (do meta_monad
               [init_expansion (single_expansion (form$ (partial_list (symbol$ name) (form$ args) body branches')))]
               (expander init_expansion))
             (do meta_monad
               [sub_expansion (expander branches')]
               (in (partial_list (form$ (partial_list (symbol$ name) args))
                                 body
                                 sub_expansion)))))

         {#Item pattern {#Item body branches'}}
         (do meta_monad
           [sub_expansion (expander branches')]
           (in (partial_list pattern body sub_expansion)))

         {#End}
         (do meta_monad [] (in (list)))

         _
         (failure (all text#composite "'lux.case' expects an even number of tokens: " (|> branches
                                                                                          (list#each code#encoded)
                                                                                          (list#interposed " ")
                                                                                          list#reversed
                                                                                          (list#mix text#composite ""))))}
        branches))

(def:'' .public case
        Macro
        (macro (_ tokens)
          ({{#Item value branches}
            (do meta_monad
              [expansion (expander branches)]
              (in (list (` ((~ (variant$ expansion)) (~ value))))))

            _
            (failure "Wrong syntax for case")}
           tokens)))

(def:'' .public pattern
        Macro
        (macro (_ tokens)
          (case tokens
            {#Item [_ {#Form {#Item pattern {#End}}}] {#Item body branches}}
            (do meta_monad
              [pattern+ (full_expansion #1 pattern)]
              (case pattern+
                {#Item pattern' {#End}}
                (in (partial_list pattern' body branches))
                
                _
                (failure "`pattern` can only expand to 1 pattern.")))
            
            _
            (failure "Wrong syntax for `pattern` macro"))))

(def:'' .private pattern#or
        Macro
        (macro (_ tokens)
          (case tokens
            (pattern (partial_list [_ {#Form patterns}] body branches))
            (case patterns
              {#End}
              (failure "pattern#or cannot have 0 patterns")

              _
              (let' [pairs (|> patterns
                               (list#each (function' [pattern] (list pattern body)))
                               (list#conjoint))]
                    (meta#in (list#composite pairs branches))))
            _
            (failure "Wrong syntax for pattern#or"))))

(def:' .private (symbol? code)
       (-> Code Bit)
       (case code
         [_ {#Symbol _}]
         #1

         _
         #0))

(def:'' .public let
        Macro
        (macro (_ tokens)
          (case tokens
            (pattern (list [_ {#Tuple bindings}] body))
            (case (..pairs bindings)
              {#Some bindings}
              (|>  bindings
                   list#reversed
                   (list#mix (is (-> [Code Code] Code Code)
                                 (function' [lr body']
                                            (let' [[l r] lr]
                                                  (if (symbol? l)
                                                    (` ({(~ l) (~ body')} (~ r)))
                                                    (` (case (~ r) (~ l) (~ body')))))))
                             body)
                   list
                   meta#in)

              {#None}
              (failure "let requires an even number of parts"))

            _
            (failure "Wrong syntax for let"))))

(def:'' .public function
        Macro
        (macro (_ tokens)
          (case (is (Maybe [Text Code (List Code) Code])
                    (case tokens
                      (pattern (list [_ {#Form (partial_list [_ {#Symbol ["" name]}] head tail)}] body))
                      {#Some name head tail body}
                      
                      _
                      {#None}))
            {#Some g!name head tail body}
            (let [g!blank (local$ "")
                  nest (is (-> Code (-> Code Code Code))
                           (function' [g!name]
                                      (function' [arg body']
                                                 (if (symbol? arg)
                                                   (` ([(~ g!name) (~ arg)] (~ body')))
                                                   (` ([(~ g!name) (~ g!blank)]
                                                       (.case (~ g!blank) (~ arg) (~ body'))))))))]
              (meta#in (list (nest (..local$ g!name) head
                                   (list#mix (nest g!blank) body (list#reversed tail))))))

            {#None}
            (failure "Wrong syntax for function"))))

(def:' .private Parser
       Type
       {#Named [..prelude_module "Parser"]
               (..type (All (_ a)
                         (-> (List Code) (Maybe [(List Code) a]))))})

(def:' .private (parsed parser tokens)
       (All (_ a) (-> (Parser a) (List Code) (Maybe a)))
       (case (parser tokens)
         (pattern {#Some [(list) it]})
         {#Some it}

         _
         {#None}))

(def:' .private (inP it tokens)
       (All (_ a)
         (-> a (Parser a)))
       {#Some [tokens it]})

(def:' .private (orP leftP rightP tokens)
       (All (_ l r)
         (-> (Parser l)
             (Parser r)
             (Parser (Or l r))))
       (case (leftP tokens)
         {#Some [tokens left]}
         {#Some [tokens {#Left left}]}

         _
         (case (rightP tokens)
           {#Some [tokens right]}
           {#Some [tokens {#Right right}]}

           _
           {#None})))

(def:' .private (eitherP leftP rightP tokens)
       (All (_ a)
         (-> (Parser a)
             (Parser a)
             (Parser a)))
       (case (leftP tokens)
         {#None}
         (rightP tokens)

         it
         it))

(def:' .private (andP leftP rightP tokens)
       (All (_ l r)
         (-> (Parser l)
             (Parser r)
             (Parser [l r])))
       (do maybe_monad
         [left (leftP tokens)
          .let [[tokens left] left]
          right (rightP tokens)
          .let [[tokens right] right]]
         (in [tokens [left right]])))

(def:' .private (afterP leftP rightP tokens)
       (All (_ l r)
         (-> (Parser l)
             (Parser r)
             (Parser r)))
       (do maybe_monad
         [left (leftP tokens)
          .let [[tokens left] left]]
         (rightP tokens)))

(def:' .private (someP itP tokens)
       (All (_ a)
         (-> (Parser a)
             (Parser (List a))))
       (case (itP tokens)
         {#Some [tokens head]}
         (do maybe_monad
           [it (someP itP tokens)
            .let [[tokens tail] it]]
           (in [tokens (partial_list head tail)]))

         {#None}
         {#Some [tokens (list)]}))

(def:' .private (manyP itP tokens)
       (All (_ a)
         (-> (Parser a)
             (Parser (List a))))
       (do maybe_monad
         [it (itP tokens)
          .let [[tokens head] it]
          it (someP itP tokens)
          .let [[tokens tail] it]]
         (in [tokens (partial_list head tail)])))

(def:' .private (maybeP itP tokens)
       (All (_ a)
         (-> (Parser a)
             (Parser (Maybe a))))
       (case (itP tokens)
         {#Some [tokens it]}
         {#Some [tokens {#Some it}]}

         {#None}
         {#Some [tokens {#None}]}))

(def:' .private (tupleP itP tokens)
       (All (_ a)
         (-> (Parser a) (Parser a)))
       (case tokens
         (pattern (partial_list [_ {#Tuple input}] tokens'))
         (do maybe_monad
           [it (parsed itP input)]
           (in [tokens' it]))

         _
         {#None}))

(def:' .private (formP itP tokens)
       (All (_ a)
         (-> (Parser a) (Parser a)))
       (case tokens
         (pattern (partial_list [_ {#Form input}] tokens'))
         (do maybe_monad
           [it (parsed itP input)]
           (in [tokens' it]))

         _
         {#None}))

(def:' .private (bindingP tokens)
       (Parser [Text Code])
       (case tokens
         (pattern (partial_list [_ {#Symbol ["" name]}] value &rest))
         {#Some [&rest [name value]]}

         _
         {#None}))

(def:' .private (endP tokens)
       (Parser Any)
       (case tokens
         (pattern (list))
         {#Some [tokens []]}

         _
         {#None}))

(def:' .private (anyP tokens)
       (Parser Code)
       (case tokens
         (pattern (partial_list code tokens'))
         {#Some [tokens' code]}

         _
         {#None}))

(def:' .private (localP tokens)
       (-> (List Code) (Maybe [(List Code) Text]))
       (case tokens
         (pattern (partial_list [_ {#Symbol ["" local]}] tokens'))
         {#Some [tokens' local]}

         _
         {#None}))

(def:' .private (symbolP tokens)
       (-> (List Code) (Maybe [(List Code) Symbol]))
       (case tokens
         (pattern (partial_list [_ {#Symbol it}] tokens'))
         {#Some [tokens' it]}

         _
         {#None}))

(with_template [<parser> <item_type> <item_parser>]
  [(def:' .private (<parser> tokens)
          (-> (List Code) (Maybe (List <item_type>)))
          (case tokens
            {#End}
            {#Some {#End}}

            _
            (do maybe_monad
              [% (<item_parser> tokens)
               .let' [[tokens head] %]
               tail (<parser> tokens)]
              (in {#Item head tail}))))]

  [parametersP Text localP]
  [enhanced_parametersP Code anyP]
  )

(with_template [<parser> <parameter_type> <parameters_parser>]
  [(def:' .private (<parser> tokens)
          (Parser [Text (List <parameter_type>)])
          (case tokens
            (pattern (partial_list [_ {#Form local_declaration}] tokens'))
            (do maybe_monad
              [% (localP local_declaration)
               .let' [[local_declaration name] %]
               parameters (<parameters_parser> local_declaration)]
              (in [tokens' [name parameters]]))
            
            _
            (do maybe_monad
              [% (localP tokens)
               .let' [[tokens' name] %]]
              (in [tokens' [name {#End}]]))))]

  [local_declarationP Text parametersP]
  [enhanced_local_declarationP Code enhanced_parametersP]
  )

(def:' .private (export_policyP tokens)
       (-> (List Code) [(List Code) Code])
       (case tokens
         (pattern (partial_list candidate tokens'))
         (case candidate
           [_ {#Bit it}]
           [tokens' candidate]
           
           [_ {#Symbol ["" _]}]
           [tokens (` .private)]
           
           [_ {#Symbol it}]
           [tokens' candidate]

           _
           [tokens (` .private)])

         _
         [tokens (` .private)]))

(with_template [<parser> <parameter_type> <local>]
  [(def:' .private (<parser> tokens)
          (-> (List Code) (Maybe [(List Code) [Code Text (List <parameter_type>)]]))
          (do maybe_monad
            [.let' [[tokens export_policy] (export_policyP tokens)]
             % (<local> tokens)
             .let' [[tokens [name parameters]] %]]
            (in [tokens [export_policy name parameters]])))]

  [declarationP Text local_declarationP]
  [enhanced_declarationP Code enhanced_local_declarationP]
  )

(def:' .private (bodyP tokens)
       (-> (List Code) (Maybe [(List Code) [(Maybe Code) Code]]))
       (case tokens
         ... TB
         (pattern (partial_list type body tokens'))
         {#Some [tokens' [{#Some type} body]]}

         ... B
         (pattern (partial_list body tokens'))
         {#Some [tokens' [{#None} body]]}

         _
         {#None}))

(def:' .private (definitionP tokens)
       (-> (List Code) (Maybe [Code Text (List Code) (Maybe Code) Code]))
       (do maybe_monad
         [% (enhanced_declarationP tokens)
          .let' [[tokens [export_policy name parameters]] %]
          % (bodyP tokens)
          .let' [[tokens [?type body]] %]
          _ (endP tokens)]
         (in [export_policy name parameters ?type body])))

(def:'' .public def:
        Macro
        (macro (_ tokens)
          (case (definitionP tokens)
            {#Some [export_policy name parameters ?type body]}
            (let [body (case parameters
                         {#End}
                         body

                         _
                         (` (function ((~ (..local$ name)) (~+ parameters))
                              (~ body))))
                  body (case ?type
                         {#Some type}
                         (` (is (~ type)
                                (~ body)))
                         
                         {#None}
                         body)]
              (meta#in (list (` ("lux def" (~ (..local$ name))
                                 (~ body)
                                 (~ export_policy))))))
            
            {#None}
            (failure "Wrong syntax for def:"))))

(def:'' .public symbol
        Macro
        (macro (_ tokens)
          (case tokens
            (pattern (list [_ {#Symbol [module name]}]))
            (meta#in (list (` [(~ (text$ module)) (~ (text$ name))])))
            
            _
            (failure (..wrong_syntax_error [..prelude_module "symbol"])))))

(def: (list#one f xs)
  (All (_ a b)
    (-> (-> a (Maybe b)) (List a) (Maybe b)))
  (case xs
    {#End}
    {#None}

    {#Item x xs'}
    (case (f x)
      {#None}
      (list#one f xs')

      {#Some y}
      {#Some y})))

(with_template [<name> <form> <message>]
  [(def: .public <name>
     (macro (_ tokens)
       (case (list#reversed tokens)
         (pattern (partial_list last init))
         (meta#in (list (list#mix (is (-> Code Code Code)
                                      (function (_ pre post) (` <form>)))
                                  last
                                  init)))
         
         _
         (failure <message>))))]

  [and (if (~ pre) (~ post) #0) "'and' requires >=1 clauses."]
  [or  (if (~ pre) #1 (~ post)) "'or' requires >=1 clauses."])

(def: (index part text)
  (-> Text Text (Maybe Nat))
  ("lux text index" 0 part text))

(def: .public (panic! message)
  (-> Text Nothing)
  ("lux io error" message))

(def: maybe#else
  (macro (_ tokens state)
    (case tokens
      (pattern (list else maybe))
      (let [g!temp (is Code [dummy_location {#Symbol ["" ""]}])
            code (` (case (~ maybe)
                      {.#Some (~ g!temp)}
                      (~ g!temp)

                      {.#None}
                      (~ else)))]
        {#Right [state (list code)]})

      _
      {#Left "Wrong syntax for maybe#else"})))

(def: (text#all_split_by splitter input)
  (-> Text Text (List Text))
  (case (..index splitter input)
    {#None}
    (list input)

    {#Some idx}
    (partial_list ("lux text clip" 0 idx input)
                  (text#all_split_by splitter
                                     (let [after_offset ("lux i64 +" 1 idx)
                                           after_length ("lux i64 -"
                                                         after_offset
                                                         ("lux text size" input))]
                                       ("lux text clip" after_offset after_length input))))))

(def: (item idx xs)
  (All (_ a)
    (-> Nat (List a) (Maybe a)))
  (case xs
    {#End}
    {#None}

    {#Item x xs'}
    (if ("lux i64 =" 0 idx)
      {#Some x}
      (item ("lux i64 -" 1 idx) xs'))))

... https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B2-reduction
(def: (reduced env type)
  (-> (List Type) Type Type)
  (case type
    {#Sum left right}
    {#Sum (reduced env left) (reduced env right)}

    {#Product left right}
    {#Product (reduced env left) (reduced env right)}
    
    {#Apply arg func}
    {#Apply (reduced env arg) (reduced env func)}

    {#UnivQ ?local_env ?local_def}
    (case ?local_env
      {#End}
      {#UnivQ env ?local_def}

      _
      type)

    {#ExQ ?local_env ?local_def}
    (case ?local_env
      {#End}
      {#ExQ env ?local_def}

      _
      type)

    {#Function ?input ?output}
    {#Function (reduced env ?input) (reduced env ?output)}

    {#Parameter idx}
    (case (item idx env)
      {#Some parameter}
      parameter

      _
      type)
    
    {#Named name type}
    (reduced env type)

    _
    type
    ))

(def: (applied_type param type_fn)
  (-> Type Type (Maybe Type))
  (case type_fn
    {#UnivQ env body}
    {#Some (reduced (partial_list type_fn param env) body)}

    {#ExQ env body}
    {#Some (reduced (partial_list type_fn param env) body)}

    {#Apply A F}
    (do maybe_monad
      [type_fn* (applied_type A F)]
      (applied_type param type_fn*))

    {#Named name type}
    (applied_type param type)
    
    _
    {#None}))

(with_template [<name> <tag>]
  [(def: (<name> type)
     (-> Type (List Type))
     (case type
       {<tag> left right}
       (partial_list left (<name> right))

       _
       (list type)))]

  [flat_variant #Sum]
  [flat_tuple   #Product]
  [flat_lambda  #Function]
  )

(def: (flat_application type)
  (-> Type [Type (List Type)])
  (case type
    {#Apply head func'}
    (let [[func tail] (flat_application func')]
      [func {#Item head tail}])

    _
    [type (list)]))

(def: (interface_methods type)
  (-> Type (Maybe (List Type)))
  (case type
    {#Product _}
    {#Some (flat_tuple type)}

    {#Apply arg func}
    (do maybe_monad
      [output (applied_type arg func)]
      (interface_methods output))

    {#UnivQ _ body}
    (interface_methods body)

    {#ExQ _ body}
    (interface_methods body)

    {#Named name type}
    (interface_methods type)

    {#Sum _}
    {#None}
    
    _
    {#Some (list type)}))

(def: (module name)
  (-> Text (Meta Module))
  (function (_ state)
    (let [[..#info info ..#source    source  ..#current_module _ ..#modules modules
           ..#scopes scopes ..#type_context types    ..#host    host
           ..#seed seed ..#expected  expected ..#location  location ..#extensions extensions
           ..#scope_type_vars scope_type_vars ..#eval _eval] state]
      (case (plist#value name modules)
        {#Some module}
        {#Right state module}

        _
        {#Left (all text#composite "Unknown module: " name)}))))

(def: (type_slot [module name])
  (-> Symbol (Meta [Nat (List Symbol) Bit Type]))
  (do meta_monad
    [=module (..module module)
     .let [[..#module_hash _
            ..#module_aliases _
            ..#definitions definitions
            ..#imports _
            ..#module_state _] =module]]
    (case (plist#value name definitions)
      {#Some {#Slot [exported type group index]}}
      (meta#in [index
                (list#each (function (_ slot)
                             [module slot])
                           group)
                exported
                type])

      _
      (failure (text#composite "Unknown slot: " (symbol#encoded [module name]))))))

(def: (record_slots type)
  (-> Type (Meta (Maybe [(List Symbol) (List Type)])))
  (case type
    {#Apply arg func}
    (record_slots func)

    {#UnivQ env body}
    (record_slots body)

    {#ExQ env body}
    (record_slots body)

    {#Named [module name] unnamed}
    (do meta_monad
      [=module (..module module)
       .let [[..#module_hash _
              ..#module_aliases _
              ..#definitions definitions
              ..#imports _
              ..#module_state _] =module]]
      (case (plist#value name definitions)
        {#Some {#Type [exported? {#Named _ _type} {#Right slots}]}}
        (case (interface_methods _type)
          {#Some members}
          (meta#in {#Some [(list#each (function (_ slot) [module slot])
                                      {#Item slots})
                           members]})

          _
          (meta#in {#None}))

        _
        (record_slots unnamed)))
    
    _
    (meta#in {#None})))

(def: expected_type
  (Meta Type)
  (function (_ state)
    (let [[..#info info ..#source    source  ..#current_module _ ..#modules modules
           ..#scopes scopes ..#type_context types    ..#host    host
           ..#seed seed ..#expected  expected ..#location  location ..#extensions extensions
           ..#scope_type_vars scope_type_vars ..#eval _eval] state]
      (case expected
        {#Some type}
        {#Right state type}

        {#None}
        {#Left "Not expecting any type."}))))

(def: (type#encoded type)
  (-> Type Text)
  (case type
    {#Primitive name params}
    (case params
      {#End}
      name

      _
      (all text#composite "(" name " " (|> params (list#each type#encoded) (list#interposed " ") list#reversed (list#mix text#composite "")) ")"))

    {#Sum _}
    (all text#composite "{" (|> (flat_variant type) (list#each type#encoded) (list#interposed " ") list#reversed (list#mix text#composite "")) "}")
    
    {#Product _}
    (all text#composite "[" (|> (flat_tuple type) (list#each type#encoded) (list#interposed " ") list#reversed (list#mix text#composite "")) "]")

    {#Function _}
    (all text#composite "(-> " (|> (flat_lambda type) (list#each type#encoded) (list#interposed " ") list#reversed (list#mix text#composite "")) ")")

    {#Parameter id}
    (nat#encoded id)
    
    {#Var id}
    (all text#composite "-" (nat#encoded id))
    
    {#Ex id}
    (all text#composite "+" (nat#encoded id))
    
    {#UnivQ env body}
    (all text#composite "(All " (type#encoded body) ")")

    {#ExQ env body}
    (all text#composite "(Ex " (type#encoded body) ")")
    
    {#Apply _}
    (let [[func args] (flat_application type)]
      (all text#composite
           "(" (type#encoded func) " "
           (|> args (list#each type#encoded) (list#interposed " ") list#reversed (list#mix text#composite ""))
           ")"))
    
    {#Named name _}
    (symbol#encoded name)
    ))

(def: .public implementation
  (macro (_ tokens)
    (do meta_monad
      [tokens' (monad#each meta_monad expansion tokens)
       struct_type ..expected_type
       tags+type (record_slots struct_type)
       tags (is (Meta (List Symbol))
                (case tags+type
                  {#Some [tags _]}
                  (meta#in tags)

                  _
                  (failure (all text#composite
                                "No tags available for type: "
                                (type#encoded struct_type)))))
       .let [tag_mappings (is (List [Text Code])
                              (list#each (function (_ tag)
                                           [(product#right tag)
                                            (symbol$ tag)])
                                         tags))]
       members (monad#each meta_monad
                           (is (-> Code (Meta (List Code)))
                               (function (_ token)
                                 (case token
                                   (pattern [_ {#Form (list [_ {#Text "lux def"}] [_ {#Symbol ["" slot_name]}] value export_policy)}])
                                   (case (plist#value slot_name tag_mappings)
                                     {#Some tag}
                                     (in (list tag value))

                                     _
                                     (failure (text#composite "Unknown implementation member: " slot_name)))

                                   _
                                   (failure "Invalid implementation member."))))
                           (list#conjoint tokens'))]
      (in (list (tuple$ (list#conjoint members)))))))

(def: (text#interposed separator parts)
  (-> Text (List Text) Text)
  (case parts
    {#End}
    ""
    
    {#Item head tail}
    (list#mix (function (_ right left)
                (all text#composite left separator right))
              head
              tail)))

(def: (remainderP tokens)
  (-> (List Code) (Maybe (List Code)))
  (case tokens
    {#End}
    {#None}

    _
    {#Item tokens}))

(def: (implementationP tokens)
  (-> (List Code) (Maybe [Code Text (List Code) Code (List Code)]))
  (do maybe_monad
    [% (enhanced_declarationP tokens)
     .let' [[tokens [export_policy name parameters]] %]
     % (anyP tokens)
     .let' [[tokens type] %]
     tokens (remainderP tokens)]
    (in [export_policy name parameters type tokens])))

(def: .public implementation:
  (macro (_ tokens)
    (case (implementationP tokens)
      {#Some [export_policy name args type definitions]}
      (let [usage (case args
                    {#End}
                    (local$ name)

                    _
                    (` ((~ (local$ name)) (~+ args))))]
        (meta#in (list (` (..def: (~ export_policy) (~ usage)
                            (~ type)
                            (..implementation
                             (~+ definitions)))))))

      {#None}
      (failure "Wrong syntax for implementation:"))))

(def: (function#identity value)
  (All (_ a)
    (-> a a))
  value)

(def: (everyP itP tokens)
  (All (_ a)
    (-> (-> (List Code) (Maybe [(List Code) a]))
        (-> (List Code) (Maybe (List a)))))
  (case tokens
    {#Item _}
    (do maybe_monad
      [% (itP tokens)
       .let [[tokens' head] %]
       tail (case tokens'
              {#Item _}
              (everyP itP tokens')

              {#End}
              (in (list)))]
      (in (partial_list head tail)))

    {#End}
    {#Some (list)}))

(def: (caseP tokens)
  (-> (List Code) (Maybe [(List Code) [Text Code]]))
  (case tokens
    (pattern (partial_list [_ {#Variant (list [_ {#Symbol ["" niladic]}])}] tokens'))
    {#Some [tokens' [niladic (` .Any)]]}

    (pattern (partial_list [_ {#Variant (partial_list [_ {#Symbol ["" polyadic]}] caseT)}] tokens'))
    {#Some [tokens' [polyadic (` (..Tuple (~+ caseT)))]]}

    _
    {#None}))

(def: .public Variant
  (macro (_ tokens)
    (case (everyP caseP tokens)
      {#Some cases}
      (meta#in (list (` (..Union (~+ (list#each product#right cases))))
                     (variant$ (list#each (function (_ case)
                                            (text$ (product#left case)))
                                          cases))))
      
      {#None}
      (failure "Wrong syntax for Variant"))))

(def: (slotP tokens)
  (-> (List Code) (Maybe [(List Code) [Text Code]]))
  (case tokens
    (pattern (partial_list [_ {#Symbol ["" slot]}] type tokens'))
    {#Some [tokens' [slot type]]}

    _
    {#None}))

(def: .public Record
  (macro (_ tokens)
    (case tokens
      (pattern (list [_ {#Tuple record}]))
      (case (everyP slotP record)
        {#Some slots}
        (meta#in (list (` (..Tuple (~+ (list#each product#right slots))))
                       (tuple$ (list#each (function (_ slot)
                                            (text$ (product#left slot)))
                                          slots))))
        
        {#None}
        (failure "Wrong syntax for Record"))

      _
      (failure "Wrong syntax for Record"))))

(def: (typeP tokens)
  (-> (List Code) (Maybe [Code Text (List Text) Code]))
  (do maybe_monad
    [% (declarationP tokens)
     .let' [[tokens [export_policy name parameters]] %]
     % (anyP tokens)
     .let' [[tokens definition] %]
     _ (endP tokens)]
    (in [export_policy name parameters definition])))

(def: (textP tokens)
  (-> (List Code) (Maybe [(List Code) Text]))
  (case tokens
    (pattern (partial_list [_ {#Text it}] tokens'))
    {#Some [tokens' it]}

    _
    {#None}))

(def: (type_declaration it)
  (-> Code (Meta (Tuple Code (Maybe (Either (List Text) (List Text))))))
  ({[_ {#Form {#Item [_ {#Symbol declarer}] parameters}}]
    (do meta_monad
      [declaration (single_expansion (form$ (partial_list (symbol$ declarer) parameters)))]
      (case declaration
        (pattern (list type [_ {#Variant tags}]))
        (case (everyP textP tags)
          {#Some tags}
          (meta#in [type {#Some {#Left tags}}])
          
          {#None}
          (failure "Improper type-definition syntax"))

        (pattern (list type [_ {#Tuple slots}]))
        (case (everyP textP slots)
          {#Some slots}
          (meta#in [type {#Some {#Right slots}}])
          
          {#None}
          (failure "Improper type-definition syntax"))

        (pattern (list type))
        (meta#in [it {#None}])

        _
        (failure "Improper type-definition syntax")))

    type
    (meta#in [type {#None}])}
   it))

(def: .public type:
  (macro (_ tokens)
    (case (typeP tokens)
      {#Some [export_policy name args type_codes]}
      (do meta_monad
        [type+labels?? (..type_declaration type_codes)
         module_name current_module_name
         .let' [type_name (local$ name)
                [type labels??] type+labels??
                type' (is (Maybe Code)
                          (case args
                            {#End}
                            {#Some type}

                            _
                            {#Some (` (.All ((~ type_name) (~+ (list#each local$ args)))
                                        (~ type)))}))]]
        (case type'
          {#Some type''}
          (let [typeC (` {.#Named [(~ (text$ module_name))
                                   (~ (text$ name))]
                                  (.type (~ type''))})]
            (meta#in (list (case labels??
                             {#Some labels}
                             (` ("lux def type tagged" (~ type_name)
                                 (~ typeC)
                                 (~ (case labels
                                      {#Left tags}
                                      (` {(~+ (list#each text$ tags))})
                                      
                                      {#Right slots}
                                      (` [(~+ (list#each text$ slots))])))
                                 (~ export_policy)))
                             
                             _
                             (` ("lux def" (~ type_name)
                                 ("lux type check type"
                                  (~ typeC))
                                 (~ export_policy)))))))

          {#None}
          (failure "Wrong syntax for type:")))

      {#None}
      (failure "Wrong syntax for type:"))))

(type: Referral
  [Symbol (List Code)])

(type: Importation
  (Record
   [#import_name Text
    #import_alias (Maybe Text)
    #import_referrals (List Referral)]))

(def: referral_parser
  (Parser Referral)
  (formP (andP symbolP (someP anyP))))

(def: (referrals_parser aliased?)
  (-> Bit (Parser (List Referral)))
  (all eitherP
       (manyP referral_parser)
       (afterP endP
               (inP (if aliased?
                      (list [(symbol ..only) (list)])
                      (list))))
       (inP (list))))

(def: (text#split_at' at x)
  (-> Nat Text [Text Text])
  [("lux text clip" 0 at x)
   ("lux text clip" at (|> x "lux text size" ("lux i64 -" at)) x)])

(def: (text#split_by token sample)
  (-> Text Text (Maybe [Text Text]))
  (do ..maybe_monad
    [index (..index token sample)
     .let [[pre post'] (text#split_at' index sample)
           [_ post] (text#split_at' ("lux text size" token) post')]]
    (in [pre post])))

(def: (replaced pattern replacement template)
  (-> Text Text Text Text)
  ((is (-> Text Text Text)
       (function (again left right)
         (case (..text#split_by pattern right)
           {#Some [pre post]}
           (again (all "lux text concat" left pre replacement) post)

           {#None}
           ("lux text concat" left right))))
   "" template))

(def: (alias_stand_in index)
  (-> Nat Text)
  (all "lux text concat" "[" (nat#encoded index) "]"))

(def: (module_alias context aliased)
  (-> (List Text) Text Text)
  (product#right
   (list#mix (function (_ replacement [index aliased])
               [("lux i64 +" 1 index)
                (replaced (alias_stand_in index) replacement aliased)])
             [0 aliased]
             context)))

(def: .public module_separator
  "/")

(def: parallel_hierarchy_sigil
  "\")

(def: (normal_parallel_path' hierarchy root)
  (-> Text Text Text)
  (case [(text#split_by ..module_separator hierarchy)
         (text#split_by ..parallel_hierarchy_sigil root)]
    [{#Some [_ hierarchy']}
     {#Some ["" root']}]
    (normal_parallel_path' hierarchy' root')

    _
    (case root
      "" hierarchy
      _ (all text#composite root ..module_separator hierarchy))))

(def: (normal_parallel_path hierarchy root)
  (-> Text Text (Maybe Text))
  (case (text#split_by ..parallel_hierarchy_sigil root)
    {#Some ["" root']}
    {#Some (normal_parallel_path' hierarchy root')}

    _
    {#None}))

(def: (relative_ups relatives input)
  (-> Nat Text Nat)
  (case ("lux text index" relatives ..module_separator input)
    {#None}
    relatives

    {#Some found}
    (if ("lux i64 =" relatives found)
      (relative_ups ("lux i64 +" 1 relatives) input)
      relatives)))

(def: (list#after amount list)
  (All (_ a) (-> Nat (List a) (List a)))
  (case [amount list]
    (pattern#or [0 _] [_ {#End}])
    list

    [_ {#Item _ tail}]
    (list#after ("lux i64 -" 1 amount) tail)))

(def: (absolute_module_name nested? relative_root module)
  (-> Bit Text Text (Meta Text))
  (case (relative_ups 0 module)
    0
    (meta#in (if nested?
               (all "lux text concat" relative_root ..module_separator module)
               module))
    
    relatives
    (let [parts (text#all_split_by ..module_separator relative_root)
          jumps ("lux i64 -" 1 relatives)]
      (if (n/< (list#size parts) jumps)
        (let [prefix (|> parts
                         list#reversed
                         (list#after jumps)
                         list#reversed
                         (text#interposed ..module_separator))
              clean ("lux text clip" relatives (|> module "lux text size" ("lux i64 -" relatives)) module)
              output (case ("lux text size" clean)
                       0 prefix
                       _ (all text#composite prefix ..module_separator clean))]
          (meta#in output))
        (failure (all "lux text concat"
                      "Cannot climb the module hierarchy..." \n
                      "Importing module: " module \n
                      "   Relative Root: " relative_root \n))))))

(def: (imports_parser nested? relative_root context imports)
  (-> Bit Text (List Text) (List Code) (Meta (List Importation)))
  (do meta_monad
    [imports' (monad#each meta_monad
                          (is (-> Code (Meta (List Importation)))
                              (function (_ token)
                                (case token
                                  ... Nested
                                  (pattern [_ {#Tuple (partial_list [_ {#Symbol ["" module_name]}] extra)}])
                                  (do meta_monad
                                    [absolute_module_name (case (normal_parallel_path relative_root module_name)
                                                            {#Some parallel_path}
                                                            (in parallel_path)

                                                            {#None}
                                                            (..absolute_module_name nested? relative_root module_name))
                                     extra,referral (case (referrals_parser #0 extra)
                                                      {#Some extra,referral}
                                                      (in extra,referral)

                                                      {#None}
                                                      (failure ""))
                                     .let [[extra referral] extra,referral]
                                     sub_imports (imports_parser #1 absolute_module_name context extra)]
                                    (in (case referral
                                          {#End}
                                          sub_imports
                                          
                                          _
                                          (partial_list [#import_name absolute_module_name
                                                         #import_alias {#None}
                                                         #import_referrals referral]
                                                        sub_imports))))

                                  (pattern [_ {#Tuple (partial_list [_ {#Text alias}] [_ {#Symbol ["" module_name]}] extra)}])
                                  (do meta_monad
                                    [absolute_module_name (case (normal_parallel_path relative_root module_name)
                                                            {#Some parallel_path}
                                                            (in parallel_path)

                                                            {#None}
                                                            (..absolute_module_name nested? relative_root module_name))
                                     extra,referral (case (referrals_parser #1 extra)
                                                      {#Some extra,referral}
                                                      (in extra,referral)

                                                      {#None}
                                                      (failure ""))
                                     .let [[extra referral] extra,referral]
                                     .let [module_alias (..module_alias {#Item module_name context} alias)]
                                     sub_imports (imports_parser #1 absolute_module_name {#Item module_alias context} extra)]
                                    (in (case referral
                                          {#End}
                                          sub_imports
                                          
                                          _
                                          (partial_list [#import_name absolute_module_name
                                                         #import_alias {#Some module_alias}
                                                         #import_referrals referral]
                                                        sub_imports))))

                                  ... Unrecognized syntax.
                                  _
                                  (do meta_monad
                                    [current_module current_module_name]
                                    (failure (all text#composite
                                                  "Wrong syntax for import @ " current_module
                                                  \n (code#encoded token)))))))
                          imports)]
    (in (list#conjoint imports'))))

(def: (exported_definitions module state)
  (-> Text (Meta (List Text)))
  (let [[current_module modules] (case state
                                   [..#info info ..#source    source  ..#current_module current_module ..#modules modules
                                    ..#scopes scopes ..#type_context types    ..#host    host
                                    ..#seed seed ..#expected  expected ..#location  location ..#extensions extensions
                                    ..#scope_type_vars scope_type_vars ..#eval _eval]
                                   [current_module modules])]
    (case (plist#value module modules)
      {#Some =module}
      (let [to_alias (list#each (is (-> [Text Global]
                                        (List Text))
                                    (function (_ [name definition])
                                      (case definition
                                        {#Alias _}
                                        (list)

                                        {#Definition [exported? def_type def_value]}
                                        (if exported?
                                          (list name)
                                          (list))

                                        {#Type [exported? type labels]}
                                        (if exported?
                                          (list name)
                                          (list))

                                        {#Tag _}
                                        (list)

                                        {#Slot _}
                                        (list))))
                                (let [[..#module_hash _ ..#module_aliases _ ..#definitions definitions ..#imports _ ..#module_state _] =module]
                                  definitions))]
        {#Right state (list#conjoint to_alias)})
      
      {#None}
      {#Left (all text#composite
                  "Unknown module: " (text#encoded module) \n
                  "Current module: " (case current_module
                                       {#Some current_module}
                                       (text#encoded current_module)

                                       {#None}
                                       "???") \n
                                       "Known modules: " (|> modules
                                                             (list#each (function (_ [name module])
                                                                          (text$ name)))
                                                             tuple$
                                                             code#encoded))})
    ))

(def: (list#only p xs)
  (All (_ a)
    (-> (-> a Bit) (List a) (List a)))
  (case xs
    {#End}
    (list)

    {#Item x xs'}
    (if (p x)
      {#Item x (list#only p xs')}
      (list#only p xs'))))

(def: (is_member? cases name)
  (-> (List Text) Text Bit)
  (let [output (list#mix (function (_ case prev)
                           (or prev
                               (text#= case name)))
                         #0
                         cases)]
    output))

(def: (test_referrals current_module imported_module all_defs referred_defs)
  (-> Text Text (List Text) (List Text) (Meta (List Any)))
  (monad#each meta_monad
              (is (-> Text (Meta Any))
                  (function (_ _def)
                    (if (is_member? all_defs _def)
                      (meta#in [])
                      (failure (all text#composite _def " is not defined in module " imported_module " @ " current_module)))))
              referred_defs))

(def: (alias_definition imported_module def)
  (-> Text Text Code)
  (` ("lux def alias" (~ (local$ def)) (~ (symbol$ [imported_module def])))))

(def: .public only
  (macro (_ tokens)
    (case (..parsed (all ..andP
                         ..textP
                         ..textP
                         ..textP
                         (..someP ..localP))
                    tokens)
      {.#Some [current_module imported_module import_alias actual]}
      (do meta_monad
        [expected (exported_definitions imported_module)
         _ (test_referrals current_module imported_module expected actual)]
        (in (list#each (..alias_definition imported_module) actual)))

      {.#None}
      (failure (..wrong_syntax_error (symbol ..only))))))

(def: .public |>>
  (macro (_ tokens)
    (do meta_monad
      [g!_ (..generated_symbol "_")
       g!arg (..generated_symbol "arg")]
      (meta#in (list (` (function ((~ g!_) (~ g!arg)) (|> (~ g!arg) (~+ tokens)))))))))

(def: .public <<|
  (macro (_ tokens)
    (do meta_monad
      [g!_ (..generated_symbol "_")
       g!arg (..generated_symbol "arg")]
      (meta#in (list (` (function ((~ g!_) (~ g!arg)) (<| (~+ tokens) (~ g!arg)))))))))

(def: .public except
  (macro (_ tokens)
    (case (..parsed (all ..andP
                         ..textP
                         ..textP
                         ..textP
                         (..someP ..localP))
                    tokens)
      {.#Some [current_module imported_module import_alias actual]}
      (do meta_monad
        [expected (exported_definitions imported_module)
         _ (test_referrals current_module imported_module expected actual)]
        (in (|> expected
                (..list#only (|>> (is_member? actual) not))
                (list#each (..alias_definition imported_module)))))

      {.#None}
      (failure (..wrong_syntax_error (symbol ..except))))))

(def: (in_env name state)
  (-> Text Lux (Maybe Type))
  (case state
    [..#info info ..#source    source  ..#current_module _ ..#modules modules
     ..#scopes scopes ..#type_context types    ..#host    host
     ..#seed seed ..#expected  expected ..#location  location ..#extensions extensions
     ..#scope_type_vars scope_type_vars ..#eval _eval]
    (list#one (is (-> Scope (Maybe Type))
                  (function (_ env)
                    (case env
                      [..#name _
                       ..#inner _
                       ..#locals [..#counter _ ..#mappings locals]
                       ..#captured _]
                      (list#one (is (-> [Text [Type Any]] (Maybe Type))
                                    (function (_ [bname [type _]])
                                      (if (text#= name bname)
                                        {#Some type}
                                        {#None})))
                                locals))))
              scopes)))

(def: (definition_type name state)
  (-> Symbol Lux (Maybe Type))
  (let [[v_module v_name] name
        [..#info info ..#source    source  ..#current_module _ ..#modules modules
         ..#scopes scopes ..#type_context types    ..#host    host
         ..#seed seed ..#expected  expected ..#location  location ..#extensions extensions
         ..#scope_type_vars scope_type_vars ..#eval _eval] state]
    (case (plist#value v_module modules)
      {#None}
      {#None}

      {#Some [..#definitions definitions
              ..#module_hash _
              ..#module_aliases _
              ..#imports _
              ..#module_state _]}
      (case (plist#value v_name definitions)
        {#None}
        {#None}

        {#Some definition}
        (case definition
          {#Alias real_name}
          (definition_type real_name state)
          
          {#Definition [exported? def_type def_value]}
          {#Some def_type}

          {#Type [exported? type labels]}
          {#Some ..Type}

          {#Tag _}
          {#None}

          {#Slot _}
          {#None})))))

(def: (definition_value name state)
  (-> Symbol (Meta [Type Any]))
  (let [[v_module v_name] name
        [..#info info ..#source    source ..#current_module _  ..#modules modules
         ..#scopes scopes ..#type_context types    ..#host    host
         ..#seed seed ..#expected  expected ..#location  location ..#extensions extensions
         ..#scope_type_vars scope_type_vars ..#eval _eval] state]
    (case (plist#value v_module modules)
      {#None}
      {#Left (text#composite "Unknown definition: " (symbol#encoded name))}

      {#Some [..#definitions definitions
              ..#module_hash _
              ..#module_aliases _
              ..#imports _
              ..#module_state _]}
      (case (plist#value v_name definitions)
        {#None}
        {#Left (text#composite "Unknown definition: " (symbol#encoded name))}

        {#Some definition}
        (case definition
          {#Alias real_name}
          (definition_value real_name state)
          
          {#Definition [exported? def_type def_value]}
          {#Right [state [def_type def_value]]}

          {#Type [exported? type labels]}
          {#Right [state [..Type type]]}

          {#Tag _}
          {#Left (text#composite "Unknown definition: " (symbol#encoded name))}

          {#Slot _}
          {#Left (text#composite "Unknown definition: " (symbol#encoded name))})))))

(def: (type_variable idx bindings)
  (-> Nat (List [Nat (Maybe Type)]) (Maybe Type))
  (case bindings
    {#End}
    {#End}
    
    {#Item [var bound] bindings'}
    (if ("lux i64 =" idx var)
      bound
      (type_variable idx bindings'))))

(def: (type_definition full_name)
  (-> Symbol (Meta Type))
  (do meta_monad
    [.let [[module name] full_name]
     current_module current_module_name]
    (function (_ compiler)
      (let [temp (is (Either Text [Lux Type])
                     (if (text#= "" module)
                       (case (in_env name compiler)
                         {#Some struct_type}
                         {#Right [compiler struct_type]}

                         _
                         (case (definition_type [current_module name] compiler)
                           {#Some struct_type}
                           {#Right [compiler struct_type]}

                           _
                           {#Left (all text#composite "Unknown var: " (symbol#encoded full_name))}))
                       (case (definition_type full_name compiler)
                         {#Some struct_type}
                         {#Right [compiler struct_type]}

                         _
                         {#Left (all text#composite "Unknown var: " (symbol#encoded full_name))})))]
        (case temp
          {#Right [compiler {#Var type_id}]}
          (let [[..#info _ ..#source _ ..#current_module _ ..#modules _
                 ..#scopes _ ..#type_context type_context ..#host _
                 ..#seed _ ..#expected _ ..#location _ ..#extensions extensions
                 ..#scope_type_vars _ ..#eval _eval] compiler
                 [..#ex_counter _ ..#var_counter _ ..#var_bindings var_bindings] type_context]
            (case (type_variable type_id var_bindings)
              {#None}
              temp

              {#Some actualT}
              {#Right [compiler actualT]}))

          _
          temp))
      )))

(def: (zipped_2 xs ys)
  (All (_ a b)
    (-> (List a) (List b) (List [a b])))
  (case xs
    {#Item x xs'}
    (case ys
      {#Item y ys'}
      (partial_list [x y] (zipped_2 xs' ys'))

      _
      (list))
    
    _
    (list)))

(def: .public open
  (macro (_ tokens)
    (case tokens
      (pattern (partial_list [_ {#Form (list [_ {#Text alias}])}] body branches))
      (do meta_monad
        [g!temp (..generated_symbol "temp")]
        (in (partial_list g!temp (` (..open (~ g!temp) (~ (text$ alias)) (~ body))) branches)))

      (pattern (list [_ {#Symbol name}] [_ {#Text alias}] body))
      (do meta_monad
        [init_type (type_definition name)
         struct_evidence (record_slots init_type)]
        (case struct_evidence
          {#None}
          (failure (text#composite "Can only 'open' structs: " (type#encoded init_type)))

          {#Some tags&members}
          (do meta_monad
            [full_body ((is (-> Symbol [(List Symbol) (List Type)] Code (Meta Code))
                            (function (again source [tags members] target)
                              (let [locals (list#each (function (_ [t_module t_name])
                                                        [[t_module t_name]
                                                         ["" (..module_alias (list t_name) alias)]])
                                                      tags)
                                    pattern (case locals
                                              (pattern (list [slot binding]))
                                              (symbol$ binding)

                                              _
                                              (|> locals
                                                  (list#each (function (_ [slot binding])
                                                               (list (symbol$ slot)
                                                                     (symbol$ binding))))
                                                  list#conjoint
                                                  tuple$))]
                                (do meta_monad
                                  [enhanced_target (monad#mix meta_monad
                                                              (function (_ [[_ m_local] m_type] enhanced_target)
                                                                (do meta_monad
                                                                  [m_implementation (record_slots m_type)]
                                                                  (case m_implementation
                                                                    {#Some m_tags&members}
                                                                    (again m_local
                                                                           m_tags&members
                                                                           enhanced_target)

                                                                    {#None}
                                                                    (in enhanced_target))))
                                                              target
                                                              (zipped_2 locals members))]
                                  (in (` ({(~ pattern) (~ enhanced_target)} (~ (symbol$ source)))))))))
                        name tags&members body)]
            (in (list full_body)))))

      _
      (failure "Wrong syntax for open"))))

(def: .public cond
  (macro (_ tokens)
    (case (list#reversed tokens)
      (pattern (partial_list else branches'))
      (case (pairs branches')
        {#Some branches'}
        (meta#in (list (list#mix (is (-> [Code Code] Code Code)
                                     (function (_ branch else)
                                       (let [[then ?] branch]
                                         (` (if (~ ?) (~ then) (~ else))))))
                                 else
                                 branches')))

        {#None}
        (failure "cond requires an uneven number of arguments."))
      
      _
      (failure "Wrong syntax for cond"))))

(def: (enumeration' idx xs)
  (All (_ a)
    (-> Nat (List a) (List [Nat a])))
  (case xs
    {#Item x xs'}
    {#Item [idx x] (enumeration' ("lux i64 +" 1 idx) xs')}

    {#End}
    {#End}))

(def: (enumeration xs)
  (All (_ a)
    (-> (List a) (List [Nat a])))
  (enumeration' 0 xs))

(def: .public the
  (macro (_ tokens)
    (case tokens
      (pattern (list [_ {#Symbol slot'}] record))
      (do meta_monad
        [slot (normal slot')
         output (..type_slot slot)
         .let [[idx tags exported? type] output]
         g!_ (..generated_symbol "_")
         g!output (..generated_symbol "")]
        (case (interface_methods type)
          {#Some members}
          (let [pattern (|> (zipped_2 tags (enumeration members))
                            (list#each (is (-> [Symbol [Nat Type]] (List Code))
                                           (function (_ [[r_module r_name] [r_idx r_type]])
                                             (list (symbol$ [r_module r_name])
                                                   (if ("lux i64 =" idx r_idx)
                                                     g!output
                                                     g!_)))))
                            list#conjoint
                            tuple$)]
            (meta#in (list (` ({(~ pattern) (~ g!output)} (~ record))))))

          _
          (failure "the can only use records.")))

      (pattern (list [_ {#Tuple slots}] record))
      (meta#in (list (list#mix (is (-> Code Code Code)
                                   (function (_ slot inner)
                                     (` (..the (~ slot) (~ inner)))))
                               record
                               slots)))

      (pattern (list selector))
      (do meta_monad
        [g!_ (..generated_symbol "_")
         g!record (..generated_symbol "record")]
        (in (list (` (function ((~ g!_) (~ g!record)) (..the (~ selector) (~ g!record)))))))
      
      _
      (failure "Wrong syntax for the"))))

(def: (open_declaration imported_module alias tags my_tag_index [module short] source type)
  (-> Text Text (List Symbol) Nat Symbol Code Type (Meta (List Code)))
  (do meta_monad
    [output (record_slots type)
     g!_ (..generated_symbol "g!_")
     .let [g!output (local$ short)
           pattern (|> tags
                       enumeration
                       (list#each (function (_ [tag_idx tag])
                                    (if ("lux i64 =" my_tag_index tag_idx)
                                      g!output
                                      g!_)))
                       tuple$)
           source+ (` ({(~ pattern) (~ g!output)} (~ source)))]]
    (case output
      {#Some [tags' members']}
      (do meta_monad
        [decls' (monad#each meta_monad
                            (is (-> [Nat Symbol Type] (Meta (List Code)))
                                (function (_ [sub_tag_index sname stype])
                                  (open_declaration imported_module alias tags' sub_tag_index sname source+ stype)))
                            (enumeration (zipped_2 tags' members')))]
        (in (list#conjoint decls')))

      _
      (in (list (` ("lux def" (~ (local$ (..module_alias (list short imported_module) alias)))
                    (~ source+)
                    #0)))))))

(def: (implementation_declarations imported_module alias implementation)
  (-> Text Text Symbol (Meta (List Code)))
  (do meta_monad
    [interface (type_definition implementation)
     output (record_slots interface)]
    (case output
      {#Some [slots terms]}
      (do meta_monad
        [.let [g!implementation (symbol$ implementation)]
         declarations (monad#each meta_monad (is (-> [Nat Symbol Type] (Meta (List Code)))
                                                 (function (_ [index slot_label slot_type])
                                                   (open_declaration imported_module alias slots index slot_label g!implementation slot_type)))
                                  (enumeration (zipped_2 slots terms)))]
        (in (list#conjoint declarations)))

      _
      (failure (all text#composite
                    "Can only 'open:' structs: " (symbol#encoded implementation)
                    " : " (type#encoded interface))))))

(def: (localized module global)
  (-> Text Symbol Symbol)
  (case global
    ["" local]
    [module local]

    _
    global))

(def: .public open:
  (macro (_ tokens)
    (case (..parsed (all ..andP
                         (..maybeP (all ..andP
                                        ..textP
                                        ..textP
                                        ..textP))
                         ..textP
                         (..orP (..manyP ..symbolP)
                                (..manyP ..anyP)))
                    tokens)
      {.#Some [current_module,imported_module,import_alias alias implementations]}
      (let [[current_module imported_module import_alias]
            (case current_module,imported_module,import_alias
              {#Some [current_module imported_module import_alias]}
              [current_module imported_module import_alias]
              
              {#None}
              ["" "" ""])]
        (case implementations
          {#Left implementations}
          (do meta_monad
            [declarations (|> implementations
                              (list#each (localized imported_module))
                              (monad#each meta_monad (implementation_declarations import_alias alias)))]
            (in (list#conjoint declarations)))
          
          {#Right implementations}
          (do meta_monad
            [pre_defs,implementations (is (Meta [(List Code) (List Code)])
                                          (monad#mix meta_monad
                                                     (function (_ it [pre_defs implementations])
                                                       (case it
                                                         [_ {#Symbol _}]
                                                         (in [pre_defs
                                                              {#Item it implementations}])
                                                         
                                                         _
                                                         (do meta_monad
                                                           [g!implementation (..generated_symbol "implementation")]
                                                           (in [{#Item (` ("lux def" (~ g!implementation) (~ it) #0)) pre_defs}
                                                                {#Item g!implementation implementations}]))))
                                                     [(list) (list)]
                                                     implementations))
             .let [[pre_defs implementations] pre_defs,implementations]]
            (in (|> pre_defs
                    {#Item (` (..open:
                                (~ (text$ current_module))
                                (~ (text$ imported_module))
                                (~ (text$ import_alias))
                                (~ (text$ alias))
                                (~+ implementations)))}
                    list#reversed)))))
      

      {.#None}
      (failure (..wrong_syntax_error (symbol ..open:))))))

(def: (imported_by? import_name module_name)
  (-> Text Text (Meta Bit))
  (do meta_monad
    [module (module module_name)
     .let [[..#module_hash _ ..#module_aliases _ ..#definitions _ ..#imports imports ..#module_state _] module]]
    (in (is_member? imports import_name))))

(def: (referrals module_name extra)
  (-> Text (List Code) (Meta (List Referral)))
  (do meta_monad
    [extra,referral (case (referrals_parser #0 extra)
                      {#Some extra,referral}
                      (in extra,referral)

                      {#None}
                      (failure ""))
     .let [[extra referral] extra,referral]
     current_module current_module_name]
    (case extra
      {#End}
      (in referral)

      _
      (failure (all text#composite "Wrong syntax for refer @ " current_module
                    \n (|> extra
                           (list#each code#encoded)
                           (list#interposed " ")
                           (list#mix text#composite "")))))))

(def: refer
  (macro (_ tokens)
    (case tokens
      (pattern (partial_list [_ {#Text imported_module}] [_ {#Text alias}] options))
      (do meta_monad
        [referrals (..referrals imported_module options)
         current_module ..current_module_name]
        (in (list#each (function (_ [macro parameters])
                         (` ((~ (symbol$ macro))
                             (~ (text$ current_module))
                             (~ (text$ imported_module))
                             (~ (text$ alias))
                             (~+ parameters))))
                       referrals)))

      _
      (failure (..wrong_syntax_error (symbol ..refer))))))

(def: .public with
  (macro (_ tokens)
    (case (..parsed (..andP ..anyP ..anyP)
                    tokens)
      {.#Some [implementation expression]}
      (meta#in (list (` (..let [(..open (~ (text$ (alias_stand_in 0)))) (~ implementation)]
                          (~ expression)))))

      {.#None}
      (failure (..wrong_syntax_error (symbol ..with))))))

(def: .public at
  (macro (_ tokens)
    (case tokens
      (pattern (list implementation [_ {#Symbol member}]))
      (meta#in (list (` (..with (~ implementation) (~ (symbol$ member))))))

      (pattern (partial_list struct member args))
      (meta#in (list (` ((..at (~ struct) (~ member)) (~+ args)))))
      
      _
      (failure (..wrong_syntax_error (symbol ..at))))))

(def: .public has
  (macro (_ tokens)
    (case tokens
      (pattern (list [_ {#Symbol slot'}] value record))
      (do meta_monad
        [slot (normal slot')
         output (..type_slot slot)
         .let [[idx tags exported? type] output]]
        (case (interface_methods type)
          {#Some members}
          (do meta_monad
            [pattern' (monad#each meta_monad
                                  (is (-> [Symbol [Nat Type]] (Meta [Symbol Nat Code]))
                                      (function (_ [r_slot_name [r_idx r_type]])
                                        (do meta_monad
                                          [g!slot (..generated_symbol "")]
                                          (meta#in [r_slot_name r_idx g!slot]))))
                                  (zipped_2 tags (enumeration members)))]
            (let [pattern (|> pattern'
                              (list#each (is (-> [Symbol Nat Code] (List Code))
                                             (function (_ [r_slot_name r_idx r_var])
                                               (list (symbol$ r_slot_name)
                                                     r_var))))
                              list#conjoint
                              tuple$)
                  output (|> pattern'
                             (list#each (is (-> [Symbol Nat Code] (List Code))
                                            (function (_ [r_slot_name r_idx r_var])
                                              (list (symbol$ r_slot_name)
                                                    (if ("lux i64 =" idx r_idx)
                                                      value
                                                      r_var)))))
                             list#conjoint
                             tuple$)]
              (meta#in (list (` ({(~ pattern) (~ output)} (~ record)))))))

          _
          (failure "has can only use records.")))

      (pattern (list [_ {#Tuple slots}] value record))
      (case slots
        {#End}
        (failure "Wrong syntax for has")

        _
        (do meta_monad
          [bindings (monad#each meta_monad
                                (is (-> Code (Meta Code))
                                    (function (_ _) (..generated_symbol "temp")))
                                slots)
           .let [pairs (zipped_2 slots bindings)
                 update_expr (list#mix (is (-> [Code Code] Code Code)
                                           (function (_ [s b] v)
                                             (` (..has (~ s) (~ v) (~ b)))))
                                       value
                                       (list#reversed pairs))
                 [_ accesses'] (list#mix (is (-> [Code Code] [Code (List (List Code))] [Code (List (List Code))])
                                             (function (_ [new_slot new_binding] [old_record accesses'])
                                               [(` (the (~ new_slot) (~ new_binding)))
                                                {#Item (list new_binding old_record) accesses'}]))
                                         [record (is (List (List Code)) {#End})]
                                         pairs)
                 accesses (list#conjoint (list#reversed accesses'))]]
          (in (list (` (let [(~+ accesses)]
                         (~ update_expr)))))))
      
      (pattern (list selector value))
      (do meta_monad
        [g!_ (..generated_symbol "_")
         g!record (..generated_symbol "record")]
        (in (list (` (function ((~ g!_) (~ g!record))
                       (..has (~ selector) (~ value) (~ g!record)))))))

      (pattern (list selector))
      (do meta_monad
        [g!_ (..generated_symbol "_")
         g!value (..generated_symbol "value")
         g!record (..generated_symbol "record")]
        (in (list (` (function ((~ g!_) (~ g!value) (~ g!record))
                       (..has (~ selector) (~ g!value) (~ g!record)))))))

      _
      (failure "Wrong syntax for has"))))

(def: .public revised
  (macro (_ tokens)
    (case tokens
      (pattern (list [_ {#Symbol slot'}] fun record))
      (do meta_monad
        [slot (normal slot')
         output (..type_slot slot)
         .let [[idx tags exported? type] output]]
        (case (interface_methods type)
          {#Some members}
          (do meta_monad
            [pattern' (monad#each meta_monad
                                  (is (-> [Symbol [Nat Type]] (Meta [Symbol Nat Code]))
                                      (function (_ [r_slot_name [r_idx r_type]])
                                        (do meta_monad
                                          [g!slot (..generated_symbol "")]
                                          (meta#in [r_slot_name r_idx g!slot]))))
                                  (zipped_2 tags (enumeration members)))]
            (let [pattern (|> pattern'
                              (list#each (is (-> [Symbol Nat Code] (List Code))
                                             (function (_ [r_slot_name r_idx r_var])
                                               (list (symbol$ r_slot_name)
                                                     r_var))))
                              list#conjoint
                              tuple$)
                  output (|> pattern'
                             (list#each (is (-> [Symbol Nat Code] (List Code))
                                            (function (_ [r_slot_name r_idx r_var])
                                              (list (symbol$ r_slot_name)
                                                    (if ("lux i64 =" idx r_idx)
                                                      (` ((~ fun) (~ r_var)))
                                                      r_var)))))
                             list#conjoint
                             tuple$)]
              (meta#in (list (` ({(~ pattern) (~ output)} (~ record)))))))

          _
          (failure "revised can only use records.")))

      (pattern (list [_ {#Tuple slots}] fun record))
      (case slots
        {#End}
        (failure "Wrong syntax for revised")

        _
        (do meta_monad
          [g!record (..generated_symbol "record")
           g!temp (..generated_symbol "temp")]
          (in (list (` (let [(~ g!record) (~ record)
                             (~ g!temp) (the [(~+ slots)] (~ g!record))]
                         (has [(~+ slots)] ((~ fun) (~ g!temp)) (~ g!record))))))))

      (pattern (list selector fun))
      (do meta_monad
        [g!_ (..generated_symbol "_")
         g!record (..generated_symbol "record")]
        (in (list (` (function ((~ g!_) (~ g!record))
                       (..revised (~ selector) (~ fun) (~ g!record)))))))

      (pattern (list selector))
      (do meta_monad
        [g!_ (..generated_symbol "_")
         g!fun (..generated_symbol "fun")
         g!record (..generated_symbol "record")]
        (in (list (` (function ((~ g!_) (~ g!fun) (~ g!record))
                       (..revised (~ selector) (~ g!fun) (~ g!record)))))))
      
      _
      (failure "Wrong syntax for revised"))))

(def: .private pattern#template
  (macro (_ tokens)
    (case tokens
      (pattern (partial_list [_ {#Form (list [_ {#Tuple bindings}]
                                             [_ {#Tuple templates}])}]
                             [_ {#Form data}]
                             branches))
      (case (is (Maybe (List Code))
                (do maybe_monad
                  [bindings' (monad#each maybe_monad symbol_short bindings)
                   data' (monad#each maybe_monad tuple_list data)]
                  (let [num_bindings (list#size bindings')]
                    (if (every? (|>> ("lux i64 =" num_bindings))
                                (list#each list#size data'))
                      (let [apply (is (-> Replacement_Environment (List Code))
                                      (function (_ env) (list#each (realized_template env) templates)))]
                        (|> data'
                            (list#each (function#composite apply (replacement_environment bindings')))
                            list#conjoint
                            in))
                      {#None}))))
        {#Some output}
        (meta#in (list#composite output branches))
        
        {#None}
        (failure "Wrong syntax for pattern#template"))
      
      _
      (failure "Wrong syntax for pattern#template"))))

(with_template [<name> <extension>]
  [(def: .public <name>
     (All (_ s)
       (-> (I64 s) (I64 s)))
     (|>> (<extension> 1)))]

  [++ "lux i64 +"]
  [-- "lux i64 -"]
  )

(def: (interleaved xs ys)
  (All (_ a)
    (-> (List a) (List a) (List a)))
  (case xs
    {#End}
    {#End}
    
    {#Item x xs'}
    (case ys
      {#End}
      {#End}
      
      {#Item y ys'}
      (partial_list x y (interleaved xs' ys')))))

(def: (type_code type)
  (-> Type Code)
  (case type
    {#Primitive name params}
    (` {.#Primitive (~ (text$ name)) (~ (untemplated_list (list#each type_code params)))})

    (pattern#template [<tag>]
                      [{<tag> left right}
                       (` {<tag> (~ (type_code left)) (~ (type_code right))})])
    ([.#Sum] [.#Product]
     [.#Function]
     [.#Apply])

    (pattern#template [<tag>]
                      [{<tag> id}
                       (` {<tag> (~ (nat$ id))})])
    ([.#Parameter] [.#Var] [.#Ex])

    (pattern#template [<tag>]
                      [{<tag> env type}
                       (let [env' (untemplated_list (list#each type_code env))]
                         (` {<tag> (~ env') (~ (type_code type))}))])
    ([.#UnivQ] [.#ExQ])
    
    {#Named [module name] anonymous}
    ... TODO: Generate the explicit type definition instead of using
    ... the "symbol$" shortcut below.
    ... (` {.#Named [(~ (text$ module)) (~ (text$ name))]
    ...     (~ (type_code anonymous))})
    (symbol$ [module name])))

(def: .public loop
  (macro (_ tokens)
    (let [?params (case tokens
                    (pattern (list [_ {#Form (list name [_ {#Tuple bindings}])}] body))
                    {#Some [name bindings body]}

                    _
                    {#None})]
      (case ?params
        {#Some [name bindings body]}
        (case (pairs bindings)
          {#Some pairs}
          (let [vars (list#each product#left pairs)
                inits (list#each product#right pairs)]
            (if (every? symbol? inits)
              (do meta_monad
                [inits' (is (Meta (List Symbol))
                            (case (monad#each maybe_monad symbol_name inits)
                              {#Some inits'} (meta#in inits')
                              {#None}        (failure "Wrong syntax for loop")))
                 init_types (monad#each meta_monad type_definition inits')
                 expected ..expected_type]
                (meta#in (list (` (("lux type check"
                                    (-> (~+ (list#each type_code init_types))
                                        (~ (type_code expected)))
                                    (function ((~ name) (~+ vars))
                                      (~ body)))
                                   (~+ inits))))))
              (do meta_monad
                [aliases (monad#each meta_monad
                                     (is (-> Code (Meta Code))
                                         (function (_ _) (..generated_symbol "")))
                                     inits)]
                (meta#in (list (` (..let [(~+ (..interleaved aliases inits))]
                                    (..loop ((~ name) [(~+ (..interleaved vars aliases))])
                                      (~ body)))))))))

          {#None}
          (failure "Wrong syntax for loop"))

        {#None}
        (failure "Wrong syntax for loop")))))

(def: (with_expansions' label tokens target)
  (-> Text (List Code) Code (List Code))
  (case target
    (pattern#or [_ {#Bit _}] [_ {#Nat _}] [_ {#Int _}] [_ {#Rev _}] [_ {#Frac _}] [_ {#Text _}])
    (list target)

    [_ {#Symbol [module name]}]
    (if (and (text#= "" module)
             (text#= label name))
      tokens
      (list target))

    (pattern#template [<tag>]
                      [[location {<tag> elems}]
                       (list [location {<tag> (list#conjoint (list#each (with_expansions' label tokens) elems))}])])
    ([#Form]
     [#Variant]
     [#Tuple])))

(def: .public with_expansions
  (macro (_ tokens)
    (case (parsed (andP (tupleP (someP bindingP)) (someP anyP)) tokens)
      {#Some [bindings bodies]}
      (loop (again [bindings bindings
                    map (is (PList (List Code))
                            (list))])
        (let [normal (is (-> Code (List Code))
                         (function (_ it)
                           (list#mix (function (_ [binding expansion] it)
                                       (list#conjoint (list#each (with_expansions' binding expansion) it)))
                                     (list it)
                                     map)))]
          (case bindings
            {#Item [var_name expr] &rest}
            (do meta_monad
              [expansion (case (normal expr)
                           (pattern (list expr))
                           (single_expansion expr)

                           _
                           (failure (all text#composite
                                         "Incorrect expansion in with_expansions"
                                         " | Binding: " (text#encoded var_name)
                                         " | Expression: " (code#encoded expr))))]
              (again &rest (plist#with var_name expansion map)))
            
            {#End}
            (at meta_monad #in (list#conjoint (list#each normal bodies))))))
      
      {#None}
      (failure "Wrong syntax for with_expansions"))))

(def: (flat_alias type)
  (-> Type Type)
  (case type
    (pattern#template [<name>]
                      [{#Named ["library/lux" <name>] _}
                       type])
    (["Bit"]
     ["Nat"]
     ["Int"]
     ["Rev"]
     ["Frac"]
     ["Text"])
    
    {#Named _ type'}
    (flat_alias type')
    
    _
    type))

(def: (static_simple_literal name)
  (-> Symbol (Meta Code))
  (do meta_monad
    [type+value (definition_value name)
     .let [[type value] type+value]]
    (case (flat_alias type)
      (pattern#template [<name> <type> <wrapper>]
                        [{#Named ["library/lux" <name>] _}
                         (in (<wrapper> (as <type> value)))])
      (["Bit"  Bit  bit$]
       ["Nat"  Nat  nat$]
       ["Int"  Int  int$]
       ["Rev"  Rev  rev$]
       ["Frac" Frac frac$]
       ["Text" Text text$])
      
      _
      (failure (text#composite "Cannot anti-quote type: " (symbol#encoded name))))))

(def: (static_literal token)
  (-> Code (Meta Code))
  (case token
    [_ {#Symbol [def_module def_name]}]
    (if (text#= "" def_module)
      (do meta_monad
        [current_module current_module_name]
        (static_simple_literal [current_module def_name]))
      (static_simple_literal [def_module def_name]))

    (pattern#template [<tag>]
                      [[meta {<tag> parts}]
                       (do meta_monad
                         [=parts (monad#each meta_monad static_literal parts)]
                         (in [meta {<tag> =parts}]))])
    ([#Form]
     [#Variant]
     [#Tuple])

    _
    (meta#in token)
    ... TODO: Figure out why this doesn't work:
    ... (at meta_monad in token)
    ))

(def: .public static
  (macro (_ tokens)
    (case tokens
      (pattern (list pattern))
      (do meta_monad
        [pattern' (static_literal pattern)]
        (in (list pattern')))
      
      _
      (failure "Wrong syntax for 'static'."))))

(type: Multi_Level_Case
  [Code (List [Code Code])])

(def: (case_level^ level)
  (-> Code (Meta [Code Code]))
  (case level
    (pattern [_ {#Tuple (list expr binding)}])
    (meta#in [expr binding])

    _
    (meta#in [level (` #1)])
    ))

(def: (multi_level_case^ levels)
  (-> (List Code) (Meta Multi_Level_Case))
  (case levels
    {#End}
    (failure "Multi-level patterns cannot be empty.")

    {#Item init extras}
    (do meta_monad
      [extras' (monad#each meta_monad case_level^ extras)]
      (in [init extras']))))

(def: (multi_level_case$ g!_ [[init_pattern levels] body])
  (-> Code [Multi_Level_Case Code] (List Code))
  (let [inner_pattern_body (list#mix (function (_ [calculation pattern] success)
                                       (let [bind? (case pattern
                                                     [_ {#Symbol _}]
                                                     #1

                                                     _
                                                     #0)]
                                         (` (case (~ calculation)
                                              (~ pattern)
                                              (~ success)

                                              (~+ (if bind?
                                                    (list)
                                                    (list g!_ (` {.#None}))))))))
                                     (` {.#Some (~ body)})
                                     (is (List [Code Code]) (list#reversed levels)))]
    (list init_pattern inner_pattern_body)))

(def: pattern#multi
  (macro (_ tokens)
    (case tokens
      (pattern (partial_list [_meta {#Form levels}] body next_branches))
      (do meta_monad
        [mlc (multi_level_case^ levels)
         .let [initial_bind? (case mlc
                               [[_ {#Symbol _}] _]
                               #1

                               _
                               #0)]
         expected ..expected_type
         g!temp (..generated_symbol "temp")]
        (in (list g!temp
                  (` ({{.#Some (~ g!temp)}
                       (~ g!temp)

                       {.#None}
                       (case (~ g!temp)
                         (~+ next_branches))}
                      ("lux type check" {.#Apply (~ (type_code expected)) Maybe}
                       (case (~ g!temp)
                         (~+ (multi_level_case$ g!temp [mlc body]))

                         (~+ (if initial_bind?
                               (list)
                               (list g!temp (` {.#None})))))))))))
      
      _
      (failure "Wrong syntax for pattern#multi"))))

(def: .public (same? reference sample)
  (All (_ a)
    (-> a a Bit))
  ("lux is" reference sample))

(def: .public as_expected
  (macro (_ tokens)
    (case tokens
      (pattern (list expr))
      (do meta_monad
        [type ..expected_type]
        (in (list (` ("lux type as" (~ (type_code type)) (~ expr))))))
      
      _
      (failure (..wrong_syntax_error (symbol ..as_expected))))))

(def: location
  (Meta Location)
  (function (_ compiler)
    {#Right [compiler (the #location compiler)]}))

(def: .public undefined
  (macro (_ tokens)
    (case tokens
      {#End}
      (do meta_monad
        [location ..location
         .let [[module line column] location
               location (all "lux text concat" (text#encoded module) "," (nat#encoded line) "," (nat#encoded column))
               message (all "lux text concat" "Undefined behavior @ " location)]]
        (in (list (` (..panic! (~ (text$ message)))))))
      
      _
      (failure (..wrong_syntax_error (symbol ..undefined))))))

(def: .public type_of
  (macro (_ tokens)
    (case tokens
      (pattern (list [_ {#Symbol var_name}]))
      (do meta_monad
        [var_type (type_definition var_name)]
        (in (list (type_code var_type))))

      (pattern (list expression))
      (do meta_monad
        [g!temp (..generated_symbol "g!temp")]
        (in (list (` (let [(~ g!temp) (~ expression)]
                       (..type_of (~ g!temp)))))))

      _
      (failure (..wrong_syntax_error (symbol ..type_of))))))

(def: (templateP tokens)
  (-> (List Code) (Maybe [Text (List Text) (List Code)]))
  (do maybe_monad
    [% (local_declarationP tokens)
     .let' [[tokens [name parameters]] %]
     % (tupleP (someP anyP) tokens)
     .let' [[tokens templates] %]
     _ (endP tokens)]
    (in [name parameters templates])))

(def: .public template
  (macro (_ tokens)
    (case (templateP tokens)
      {#Some [name args input_templates]}
      (do meta_monad
        [g!tokens (..generated_symbol "tokens")
         g!compiler (..generated_symbol "compiler")
         g!_ (..generated_symbol "_")
         .let [rep_env (list#each (function (_ arg)
                                    [arg (` ((~' ~) (~ (local$ arg))))])
                                  args)]
         this_module current_module_name]
        (in (list (` (..macro ((~ (local$ name)) (~ g!tokens) (~ g!compiler))
                       (case (~ g!tokens)
                         (pattern (list (~+ (list#each local$ args))))
                         {.#Right [(~ g!compiler)
                                   (list (~+ (list#each (function (_ template)
                                                          (` (`' (~ (with_replacements rep_env
                                                                      template)))))
                                                        input_templates)))]}
                         
                         (~ g!_)
                         {.#Left "Invalid syntax."}))))))

      {#None}
      (failure (..wrong_syntax_error (symbol ..template))))))

(with_template [<name> <to>]
  [(def: .public <name>
     (template (<name> it)
       [(..|> it (..is (..I64 ..Any)) (..as <to>))]))]

  [i64 ..I64]
  [nat ..Nat]
  [int ..Int]
  [rev ..Rev]
  )

(def: .public these
  (macro (_ tokens compiler)
    {#Right [compiler tokens]}))

(def: .public char
  (macro (_ tokens compiler)
    (case tokens
      (pattern#multi (pattern (list [_ {#Text input}]))
                     (|> input "lux text size" ("lux i64 =" 1)))
      (|> input ("lux text char" 0)
          nat$ list
          [compiler] {#Right})

      _
      {#Left (..wrong_syntax_error (symbol ..char))})))

(def: target
  (Meta Text)
  (function (_ compiler)
    {#Right [compiler (the [#info #target] compiler)]}))

(def: (platform_name choice)
  (-> Code (Meta Text))
  (case choice
    [_ {#Text platform}]
    (..meta#in platform)

    [_ {#Symbol symbol}]
    (do meta_monad
      [symbol (..global_symbol symbol)
       type+value (..definition_value symbol)
       .let [[type value] type+value]]
      (case (..flat_alias type)
        (pattern#or {#Primitive "#Text" {#End}}
                    {#Named ["library/lux" "Text"] {#Primitive "#Text" {#End}}})
        (in (as ..Text value))

        _
        (failure (all text#composite
                      "Invalid target platform (must be a value of type Text): " (symbol#encoded symbol)
                      " : " (..code#encoded (..type_code type))))))

    _
    (failure (all text#composite
                  "Invalid target platform syntax: " (..code#encoded choice)
                  \n "Must be either a text literal or a symbol."))))

(def: (target_pick target options default)
  (-> Text (List [Code Code]) (Maybe Code) (Meta (List Code)))
  (case options
    {#End}
    (case default
      {#None}
      (failure (all text#composite "No code for target platform: " target))

      {#Some default}
      (meta#in (list default)))

    {#Item [key pick] options'}
    (do meta_monad
      [platform (..platform_name key)]
      (if (text#= target platform)
        (meta#in (list pick))
        (target_pick target options' default)))))

(def: .public for
  (macro (_ tokens)
    (case (..parsed (..andP (..someP (..andP ..anyP ..anyP))
                            (..maybeP ..anyP))
                    tokens)
      {.#Some [options default]}
      (do meta_monad
        [target ..target]
        (target_pick target options default))

      {.#None}
      (failure (..wrong_syntax_error (symbol ..for))))))

... TODO: Delete "scope_type_vars" (including the #scope_type_vars Lux state) and "parameter" ASAP.
(for "{old}" (these (def: (scope_type_vars state)
                      (Meta (List Nat))
                      (case state
                        [..#info info ..#source    source ..#current_module _   ..#modules modules
                         ..#scopes scopes ..#type_context types    ..#host    host
                         ..#seed seed ..#expected  expected ..#location  location ..#extensions extensions
                         ..#scope_type_vars scope_type_vars ..#eval _eval]
                        {#Right [state scope_type_vars]}))

                    (def: .public parameter
                      (macro (_ tokens)
                        (case tokens
                          (pattern (list [_ {#Nat idx}]))
                          (do meta_monad
                            [stvs ..scope_type_vars]
                            (case (..item idx (list#reversed stvs))
                              {#Some var_id}
                              (in (list (` {.#Ex (~ (nat$ var_id))})))

                              {#None}
                              (failure (text#composite "Indexed-type does not exist: " (nat#encoded idx)))))

                          _
                          (failure (..wrong_syntax_error (symbol ..$)))))))
     (these (def: .public parameter "")))

(def: (refer_code imported_module alias referrals)
  (-> Text Text (List Referral) Code)
  (` ((~! ..refer)
      (~ (text$ imported_module))
      (~ (text$ alias))
      (~+ (list#each (function (_ [macro parameters])
                       (` ((~ (symbol$ macro)) (~+ parameters))))
                     referrals)))))

(def: .public using
  (macro (_ _imports)
    (do meta_monad
      [current_module ..current_module_name
       imports (imports_parser #0 current_module {#End} _imports)
       .let [=imports (|> imports
                          (list#each (is (-> Importation Code)
                                         (function (_ [module_name m_alias =refer])
                                           (` [(~ (text$ module_name)) (~ (text$ (..maybe#else "" m_alias)))]))))
                          tuple$)
             =refers (list#each (is (-> Importation Code)
                                    (function (_ [module_name m_alias =refer])
                                      (refer_code module_name (..maybe#else "" m_alias) =refer)))
                                imports)
             =module (` ("lux def module" (~ =imports)))]
       g!_ (..generated_symbol "")]
      (in {#Item =module
                 (for "Python"
                      ... TODO: Remove this hack once Jython is no longer being used as the Python interpreter.
                      ... Without it, I get this strange error
                      ... {library/lux/tool/compiler/language/lux/generation.no_buffer_for_saving_code}
                      ... Artifact ID: 0
                      ... Which only ever happens for the Python compiler.
                      (partial_list (` ("lux def" (~ g!_) [] #0))
                                    =refers)
                      =refers)}))))

(def: (embedded_expansions code)
  (-> Code (Meta [(List [Code Code]) Code]))
  (case code
    (pattern [ann {#Form (list [_ {#Symbol ["" "~~"]}] expansion)}])
    (do meta_monad
      [g!expansion (..generated_symbol "g!expansion")]
      (in [(list [g!expansion expansion]) g!expansion]))

    (pattern#template [<tag>]
                      [[ann {<tag> parts}]
                       (do meta_monad
                         [=parts (monad#each meta_monad embedded_expansions parts)]
                         (in [(list#mix list#composite (list) (list#each product#left =parts))
                              [ann {<tag> (list#each product#right =parts)}]]))])
    ([#Form]
     [#Variant]
     [#Tuple])
    
    _
    (meta#in [(list) code])))

(def: .public ``
  (macro (_ tokens)
    (case tokens
      (pattern (list raw))
      (do meta_monad
        [=raw (..embedded_expansions raw)
         .let [[labels labelled] =raw]]
        (in (list (` (with_expansions [(~+ (|> labels
                                               (list#each (function (_ [label expansion]) (list label expansion)))
                                               list#conjoint))]
                       (~ labelled))))))

      _
      (failure (..wrong_syntax_error (symbol ..``))))))

(def: .public false
  Bit
  #0)

(def: .public true
  Bit
  #1)

(def: .public try
  (macro (_ tokens)
    (case tokens
      (pattern (list expression))
      (do meta_monad
        [g!_ (..generated_symbol "g!_")]
        (in (list (` ("lux try"
                      (.function ((~ g!_) (~ g!_))
                        (~ expression)))))))

      _
      (..failure (..wrong_syntax_error (symbol ..try))))))

(def: (methodP tokens)
  (-> (List Code) (Maybe [(List Code) [Text Code]]))
  (case tokens
    (pattern (partial_list [_ {#Form (list [_ {#Text "lux type check"}]
                                           type
                                           [_ {#Symbol ["" name]}])}]
                           tokens'))
    {#Some [tokens' [name type]]}

    _
    {#None}))

(def: .public Interface
  (macro (_ tokens)
    (do meta_monad
      [methods' (monad#each meta_monad expansion tokens)]
      (case (everyP methodP (list#conjoint methods'))
        {#Some methods}
        (in (list (` (..Tuple (~+ (list#each product#right methods))))
                  (tuple$ (list#each (|>> product#left text$) methods))))

        {#None}
        (failure "Wrong syntax for Interface")))))

(def: (recursive_type g!self g!dummy name body)
  (-> Code Code Text Code Code)
  (` {.#Apply (..Primitive "")
              (.All ((~ g!self) (~ g!dummy))
                (~ (let$ (local$ name) (` {.#Apply (..Primitive "") (~ g!self)})
                         body)))}))

(def: .public Rec
  (macro (_ tokens)
    (case tokens
      (pattern (list [_ {#Symbol "" name}] body))
      (do meta_monad
        [body' (expansion body)
         g!self (generated_symbol "g!self")
         g!dummy (generated_symbol "g!dummy")]
        (case body'
          (pattern (list body' labels))
          (in (list (..recursive_type g!self g!dummy name body') labels))

          (pattern (list body'))
          (in (list (..recursive_type g!self g!dummy name body')))

          _
          (failure "Wrong syntax for Rec")))

      _
      (failure "Wrong syntax for Rec"))))
