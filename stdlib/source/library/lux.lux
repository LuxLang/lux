... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.def# prelude
       (.is# (.type# "name_of_module")
             "library/lux")
       #1)

(.def# Type
       (.is# (.type# "type")
             {9 #1
                [..prelude "Type"]
                (.type# "type")})
       #1)

(.def# Name
       (.is# Type
             {9 #1
                [..prelude "Name"]
                (.type# "name")})
       #1)

(.def# Bit
       (.is# Type
             {9 #1
                [..prelude "Bit"]
                {#0 (.type_name# "bit") {#0}}})
       #1)

(.def# Natural
       (.is# Type
             {9 #1
                [..prelude "Natural"]
                {#0 (.type_name# "i64") {#1 {#0 (.type_name# "natural") {#0}} {#0}}}})
       #1)

... (every .public Any
...   (for_some (_ it) it))
(.def# Any
       (.is# Type
             {9 #1
                [..prelude "Any"]
                {8 #0
                   {#0}
                   {4 #0 1}}})
       #1)

... (every .public (Stack it)
...   (Variant
...    {#Empty}
...    {#Top it (Stack it)}))
(.def# Stack
       (.is# Type
             {9 #1
                [..prelude "Stack"]
                {7 #0
                   {#0}
                   {1 #0
                      ... End
                      Any
                      ... Item
                      {2 #0
                         {4 #0 1}
                         {9 #0
                            {4 #0 1}
                            {4 #0 0}}}}}})
       #1)

... (every .public (Maybe it)
...   (Variant
...    {#None}
...    {#Some it}))
(.def# Maybe
       (.is# Type
             {9 #1
                [..prelude "Maybe"]
                {7 #0
                   {#0}
                   {1 #0
                      ... None
                      Any
                      ... Some
                      {4 #0 1}}}})
       #1)

... (every .public Label
...   [(Maybe [Natural Bit (Stack Name)])
...    Type])
(.def# Label
       (.is# Type
             {9 #1 [..prelude "Label"]
                {2 #0
                   {9 #0 {2 #0 Natural
                            {2 #0 Bit
                               {9 #0 Name Stack}}}
                      Maybe}
                   Type}})
       #1)

(.def# Tag
       (.is# Type
             {9 #1 [..prelude "Tag"]
                {#0 (.type_name# "tag") {#0}}})
       #1)

(.def# Slot
       (.is# Type
             {9 #1 [..prelude "Slot"]
                {#0 (.type_name# "slot") {#0}}})
       #1)

(.def# tag
       (.is# {3 #0 Label
                Tag}
             (.function# _ it (.as# Tag it)))
       #0)

(.def# slot
       (.is# {3 #0 Label
                Slot}
             (.function# _ it (.as# Slot it)))
       #0)

(.def# maybe_tags
       (.is# {9 #0 Name Stack}
             {#1 [[..prelude "#None"]
                  {#1 [[..prelude "#Some"]
                       {#0}]}]})
       #0)
(.def# #None (..tag [{#1 [0 #0 ..maybe_tags]} Maybe]) #1)
(.def# #Some (..tag [{#1 [0 #1 ..maybe_tags]} Maybe]) #1)

(.def# stack_tags
       (.is# {9 #0 Name Stack}
             {#1 [[..prelude "#Empty"]
                  {#1 [[..prelude "#Top"]
                       {#0}]}]})
       #0)
(.def# #Empty (..tag [{#1 [0 #0 ..stack_tags]} Stack]) #1)
(.def# #Top (..tag [{#1 [0 #1 ..stack_tags]} Stack]) #1)

(.def# type_tags
       (.is# {9 #0 Name Stack}
             {#1 [[..prelude "#Nominal"]
                  {#1 [[..prelude "#Sum"]
                       {#1 [[..prelude "#Product"]
                            {#1 [[..prelude "#Function"]
                                 {#1 [[..prelude "#Parameter"]
                                      {#1 [[..prelude "#Variable"]
                                           {#1 [[..prelude "#Opaque"]
                                                {#1 [[..prelude "#Universal"]
                                                     {#1 [[..prelude "#Existential"]
                                                          {#1 [[..prelude "#Reification"]
                                                               {#1 [[..prelude "#Named"]
                                                                    {#0}]}]}]}]}]}]}]}]}]}]}]})
       #0)
(.def# #Nominal (..tag [{#Some [0 #0 ..type_tags]} Type]) #1)
(.def# #Sum (..tag [{#Some [1 #0 ..type_tags]} Type]) #1)
(.def# #Product (..tag [{#Some [2 #0 ..type_tags]} Type]) #1)
(.def# #Function (..tag [{#Some [3 #0 ..type_tags]} Type]) #1)
(.def# #Parameter (..tag [{#Some [4 #0 ..type_tags]} Type]) #1)
(.def# #Variable (..tag [{#Some [5 #0 ..type_tags]} Type]) #1)
... https://en.wikipedia.org/wiki/Opaque_data_type
(.def# #Opaque (..tag [{#Some [6 #0 ..type_tags]} Type]) #1)
... https://en.wikipedia.org/wiki/Universal_quantification
(.def# #Universal (..tag [{#Some [7 #0 ..type_tags]} Type]) #1)
... https://en.wikipedia.org/wiki/Existential_quantification
(.def# #Existential (..tag [{#Some [8 #0 ..type_tags]} Type]) #1)
(.def# #Reification (..tag [{#Some [9 #0 ..type_tags]} Type]) #1)
(.def# #Named (..tag [{#Some [9 #1 ..type_tags]} Type]) #1)

(.def# provenance#dummy
       (.is# (.type# "provenance")
             ["" 0 0])
       #0)

... (every .public Nothing
...   (for_any (_ it) it))
(.def# Nothing
       (.is# Type
             {#Named [..prelude "Nothing"]
                     {#Universal {#Empty}
                                 {#Parameter 1}}})
       #1)

(.def# I64
       (.is# Type
             {#Named [..prelude "I64"]
                     {#Universal {#Empty}
                                 {#Nominal (.type_name# "i64") {#Top {#Parameter 1} {#Empty}}}}})
       #1)

(.def# Integer
       (.is# Type
             {#Named [..prelude "Integer"]
                     {#Nominal (.type_name# "i64") {#Top {#Nominal (.type_name# "integer") {#Empty}} {#Empty}}}})
       #1)

(.def# Revolution
       (.is# Type
             {#Named [..prelude "Revolution"]
                     {#Nominal (.type_name# "i64") {#Top {#Nominal (.type_name# "revolution") {#Empty}} {#Empty}}}})
       #1)

(.def# Decimal
       (.is# Type
             {#Named [..prelude "Decimal"]
                     {#Nominal (.type_name# "decimal") {#Empty}}})
       #1)

(.def# Text
       (.is# Type
             {#Named [..prelude "Text"]
                     {#Nominal (.type_name# "text") {#Empty}}})
       #1)

(.def# Error
       (.is# Type
             {#Named [..prelude "Error"]
                     ..Text})
       #1)

... (every .public Provenance
...   (Record
...    [#module Text
...     #line   Natural
...     #column Natural]))
(.def# Provenance
       (.is# Type
             {#Named [..prelude "Provenance"]
                     (.type# "provenance")})
       #1)
(.def# provenance_slots
       (.is# {#Reification Name Stack}
             {#Top [..prelude "#module"]
                   {#Top [..prelude "#line"]
                         {#Top [..prelude "#column"]
                               {#Empty}}}})
       #0)
(.def# #module (slot [{#Some [0 #0 ..provenance_slots]} Provenance]) #1)
(.def# #line (slot [{#Some [1 #0 ..provenance_slots]} Provenance]) #1)
(.def# #column (slot [{#Some [1 #1 ..provenance_slots]} Provenance]) #1)

... (every .public (Annotated m v)
...   (Record
...    [#meta  m
...     #datum v]))
(.def# Annotated
       (.is# Type
             {#Named [..prelude "Annotated"]
                     {#Universal {#Empty}
                                 {#Universal {#Empty}
                                             {#Product
                                              {#Parameter 3}
                                              {#Parameter 1}}}}})
       #1)
(.def# ann_slots
       (.is# {#Reification Name Stack}
             {#Top [..prelude "#meta"]
                   {#Top [..prelude "#datum"]
                         {#Empty}}})
       #0)
(.def# #meta (slot [{#Some [0 #0 ..ann_slots]} Annotated]) #1)
(.def# #datum (slot [{#Some [0 #1 ..ann_slots]} Annotated]) #1)

(.def# Code
       (.is# Type
             {#Named [..prelude "Code"]
                     (.type# "code")})
       #1)
(.def# code_tags
       (.is# {#Reification Name Stack}
             {#Top [..prelude "#Bit"]
                   {#Top [..prelude "#Natural"]
                         {#Top [..prelude "#Integer"]
                               {#Top [..prelude "#Revolution"]
                                     {#Top [..prelude "#Decimal"]
                                           {#Top [..prelude "#Text"]
                                                 {#Top [..prelude "#Name"]
                                                       {#Top [..prelude "#Form"]
                                                             {#Top [..prelude "#Variant"]
                                                                   {#Top [..prelude "#Tuple"]
                                                                         {#Empty}}}}}}}}}}})
       #0)
(.def# #Bit (tag [{#Some [0 #0 ..code_tags]} Code]) #1)
(.def# #Natural (tag [{#Some [1 #0 ..code_tags]} Code]) #1)
(.def# #Integer (tag [{#Some [2 #0 ..code_tags]} Code]) #1)
(.def# #Revolution (tag [{#Some [3 #0 ..code_tags]} Code]) #1)
(.def# #Decimal (tag [{#Some [4 #0 ..code_tags]} Code]) #1)
(.def# #Text (tag [{#Some [5 #0 ..code_tags]} Code]) #1)
(.def# #Name (tag [{#Some [6 #0 ..code_tags]} Code]) #1)
(.def# #Form (tag [{#Some [7 #0 ..code_tags]} Code]) #1)
(.def# #Variant (tag [{#Some [8 #0 ..code_tags]} Code]) #1)
(.def# #Tuple (tag [{#Some [8 #1 ..code_tags]} Code]) #1)

(.def# private
       #0
       #1)

(.def# public
       #1
       #1)

(.def# local
       #0
       #1)

(.def# global
       #1
       #1)

(.def# annotated
       (.is# {#Universal {#Empty}
                         {#Function {#Parameter 1}
                                    {#Product Provenance {#Parameter 1}}}}
             (.function# _ it
                         [provenance#dummy it]))
       #0)

(.def# code#bit
       (.is# {#Function Bit
                        Code}
             (.function# _ value {#Bit (annotated value)}))
       #0)

(.def# code#natural
       (.is# {#Function Natural
                        Code}
             (.function# _ value {#Natural (annotated value)}))
       #0)

(.def# code#integer
       (.is# {#Function Integer
                        Code}
             (.function# _ value {#Integer (annotated value)}))
       #0)

(.def# code#revolution
       (.is# {#Function Revolution
                        Code}
             (.function# _ value {#Revolution (annotated value)}))
       #0)

(.def# code#decimal
       (.is# {#Function Decimal
                        Code}
             (.function# _ value {#Decimal (annotated value)}))
       #0)

(.def# code#text
       (.is# {#Function Text
                        Code}
             (.function# _ text {#Text (annotated text)}))
       #0)

(.def# code#name
       (.is# {#Function Name
                        Code}
             (.function# _ name {#Name (annotated name)}))
       #0)

(.def# code#local
       (.is# {#Function Text
                        Code}
             (.function# _ name {#Name (annotated ["" name])}))
       #0)

(.def# List
       (.is# Type
             {#Named [..prelude "List"]
                     {#Universal {#Empty}
                                 {#Nominal (.type_name# "list") {#Top {#Parameter 1} {#Empty}}}}})
       .public)

(.def# code#form
       (.is# {#Function {#Reification Code List}
                        Code}
             (.function# _ tokens {#Form (annotated tokens)}))
       #0)

(.def# code#variant
       (.is# {#Function {#Reification Code List}
                        Code}
             (.function# _ tokens {#Variant (annotated tokens)}))
       #0)

(.def# code#tuple
       (.is# {#Function {#Reification Code List}
                        Code}
             (.function# _ tokens {#Tuple (annotated tokens)}))
       #0)

... (every .public Definition
...   [Type Any])
(.def# Definition
       (.is# Type
             {#Named [..prelude "Definition"]
                     {#Product Type Any}})
       .public)

... (every .public Default
...   Definition)
(.def# Default
       (.is# Type
             {#Named [..prelude "Default"]
                     Definition})
       .public)

... (every .public Alias
...   Name)
(.def# Alias
       (.is# Type
             {#Named [..prelude "Alias"]
                     Name})
       .public)

... (every .public Global
...   (Variant
...    {#Definition Definition}
...    {#Alias Alias}
...    {#Default Default}))
(.def# Global
       (.is# Type
             {#Named [..prelude "Global"]
                     {#Sum Definition
                           {#Sum Alias
                                 Default}}})
       .public)

(.def# global_tags
       (.is# {#Reification Name Stack}
             {#Top [..prelude "#Definition"]
                   {#Top [..prelude "#Alias"]
                         {#Top [..prelude "#Default"]
                               {#Empty}}}})
       #0)
(.def# #Definition (tag [{#Some [0 #0 ..global_tags]} Global]) .public)
(.def# #Alias (tag [{#Some [1 #0 ..global_tags]} Global]) .public)
(.def# #Default (tag [{#Some [1 #1 ..global_tags]} Global]) .public)

... (every .public (Bindings k v)
...   (Record
...    [#counter Natural
...     #mappings (Stack [k v])]))
(.def# Bindings
       (.is# Type
             {#Named [..prelude "Bindings"]
                     {#Universal {#Empty}
                                 {#Universal {#Empty}
                                             {#Product
                                              ... counter
                                              Natural
                                              ... mappings
                                              {#Reification {#Product {#Parameter 3}
                                                                      {#Parameter 1}}
                                                            Stack}}}}})
       .public)

(.def# bindings_slots
       (.is# {#Reification Name Stack}
             {#Top [..prelude "#counter"]
                   {#Top [..prelude "#mappings"]
                         {#Empty}}})
       #0)
(.def# #counter (slot [{#Some [0 #0 ..bindings_slots]} Bindings]) .public)
(.def# #mappings (slot [{#Some [0 #1 ..bindings_slots]} Bindings]) .public)

... (every .public Ref
...   {#Local Natural}
...   {#Captured Natural})
(.def# Ref
       (.is# Type
             {#Named [..prelude "Ref"]
                     {#Sum
                      ... Local
                      Natural
                      ... Captured
                      Natural}})
       .public)

(.def# ref_tags
       (.is# {#Reification Name Stack}
             {#Top [..prelude "#Local"]
                   {#Top [..prelude "#Captured"]
                         {#Empty}}})
       #0)
(.def# #Local (tag [{#Some [0 #0 ..ref_tags]} Ref]) .public)
(.def# #Captured (tag [{#Some [0 #1 ..ref_tags]} Ref]) .public)

... TODO: Get rid of both #scope_name & #inner_scopes
... (every .public Scope
...   (Record
...    [#scope_name (Stack Text)
...     #inner_scopes Natural
...     #locals (Bindings Text [Type Natural])
...     #captured (Bindings Text [Type Ref])]))
(.def# Scope
       (.is# Type
             {#Named [..prelude "Scope"]
                     {#Product
                      ... name
                      {#Reification Text Stack}
                      {#Product
                       ... inner
                       Natural
                       {#Product
                        ... locals
                        {#Reification {#Product Type Natural} {#Reification Text Bindings}}
                        ... captured
                        {#Reification {#Product Type Ref} {#Reification Text Bindings}}}}}})
       .public)

(.def# scope_slots
       (.is# {#Reification Name Stack}
             {#Top [..prelude "#scope_name"]
                   {#Top [..prelude "#inner_scopes"]
                         {#Top [..prelude "#locals"]
                               {#Top [..prelude "#captured"]
                                     {#Empty}}}}})
       #0)
(.def# #scope_name (slot [{#Some [0 #0 ..scope_slots]} Scope]) .public)
(.def# #inner_scopes (slot [{#Some [1 #0 ..scope_slots]} Scope]) .public)
(.def# #locals (slot [{#Some [2 #0 ..scope_slots]} Scope]) .public)
(.def# #captured (slot [{#Some [2 #1 ..scope_slots]} Scope]) .public)

... (every .public (Either l r)
...   (Variant
...    {#Left l}
...    {#Right r}))
(.def# Either
       (.is# Type
             {#Named [..prelude "Either"]
                     {#Universal {#Empty}
                                 {#Universal {#Empty}
                                             {#Sum
                                              ... Left
                                              {#Parameter 3}
                                              ... Right
                                              {#Parameter 1}}}}})
       .public)

(.def# either_tags
       (.is# {#Reification Name Stack}
             {#Top [..prelude "#Left"]
                   {#Top [..prelude "#Right"]
                         {#Empty}}})
       #0)
(.def# #Left (tag [{#Some [0 #0 ..either_tags]} Either]) .public)
(.def# #Right (tag [{#Some [0 #1 ..either_tags]} Either]) .public)

... (every .public Source
...   [Provenance Natural Text])
(.def# Source
       (.is# Type
             {#Named [..prelude "Source"]
                     {#Product Provenance {#Product Natural Text}}})
       .public)

... (every .public Module_State
...   (Variant
...    #Active
...    #Compiled
...    #Cached))
(.def# Module_State
       (.is# Type
             {#Named [..prelude "Module_State"]
                     {#Sum
                      ... #Active
                      Any
                      {#Sum
                       ... #Compiled
                       Any
                       ... #Cached
                       Any}}})
       .public)

(.def# module_state_tags
       (.is# {#Reification Name Stack}
             {#Top [..prelude "#Active"]
                   {#Top [..prelude "#Compiled"]
                         {#Top [..prelude "#Cached"]
                               {#Empty}}}})
       #0)
(.def# #Active (tag [{#Some [0 #0 ..module_state_tags]} Module_State]) .public)
(.def# #Compiled (tag [{#Some [1 #0 ..module_state_tags]} Module_State]) .public)
(.def# #Cached (tag [{#Some [1 #1 ..module_state_tags]} Module_State]) .public)

(.def# Module
       (.is# Type
             {#Named [..prelude "Module"]
                     (.type# "module")})
       .public)

(.def# module_slots
       (.is# {#Reification Name Stack}
             {#Top [..prelude "#module_hash"]
                   {#Top [..prelude "#module_aliases"]
                         {#Top [..prelude "#definitions"]
                               {#Top [..prelude "#imports"]
                                     {#Top [..prelude "#module_state"]
                                           {#Empty}}}}}})
       #0)
(.def# #module_hash (slot [{#Some [0 #0 ..module_slots]} Module]) .public)
(.def# #module_aliases (slot [{#Some [1 #0 ..module_slots]} Module]) .public)
(.def# #definitions (slot [{#Some [2 #0 ..module_slots]} Module]) .public)
(.def# #imports (slot [{#Some [3 #0 ..module_slots]} Module]) .public)
(.def# #module_state (slot [{#Some [3 #1 ..module_slots]} Module]) .public)

(.def# Type_Context
       (.is# Type
             {#Named [..prelude "Type_Context"]
                     (.type# "type_context")})
       .public)

(.def# type_context_slots
       (.is# {#Reification Name Stack}
             {#Top [..prelude "#ex_counter"]
                   {#Top [..prelude "#var_counter"]
                         {#Top [..prelude "#var_bindings"]
                               {#Empty}}}})
       #0)
(.def# #ex_counter (slot [{#Some [0 #0 ..type_context_slots]} Type_Context]) .public)
(.def# #var_counter (slot [{#Some [1 #0 ..type_context_slots]} Type_Context]) .public)
(.def# #var_bindings (slot [{#Some [1 #1 ..type_context_slots]} Type_Context]) .public)

... (every .public Mode
...   (Variant
...    {#Build}
...    {#Eval}
...    {#Interpreter}))
(.def# Mode
       (.is# Type
             {#Named [..prelude "Mode"]
                     {#Sum
                      ... Build
                      Any
                      {#Sum
                       ... Eval
                       Any
                       ... Interpreter
                       Any}}})
       .public)

(.def# mode_tags
       (.is# {#Reification Name Stack}
             {#Top [..prelude "#Build"]
                   {#Top [..prelude "#Eval"]
                         {#Top [..prelude "#Interpreter"]
                               {#Empty}}}})
       #0)
(.def# #Build (tag [{#Some [0 #0 ..mode_tags]} Mode]) .public)
(.def# #Eval (tag [{#Some [1 #0 ..mode_tags]} Mode]) .public)
(.def# #Interpreter (tag [{#Some [1 #1 ..mode_tags]} Mode]) .public)

(.def# Info
       (.is# Type
             (.type# "info"))
       .public)

(.def# info_slots
       (.is# {#Reification Name Stack}
             {#Top [..prelude "#target"]
                   {#Top [..prelude "#version"]
                         {#Top [..prelude "#mode"]
                               {#Top [..prelude "#configuration"]
                                     {#Empty}}}}})
       #0)
(.def# #target (slot [{#Some [0 #0 ..info_slots]} Info]) .public)
(.def# #version (slot [{#Some [1 #0 ..info_slots]} Info]) .public)
(.def# #mode (slot [{#Some [2 #0 ..info_slots]} Info]) .public)
(.def# #configuration (slot [{#Some [2 #1 ..info_slots]} Info]) .public)

(.def# Lux
       (.is# Type
             {#Named [..prelude "Lux"]
                     (.type# "lux")})
       .public)

(.def# lux_slots
       (.is# {#Reification Name Stack}
             {#Top [..prelude "#info"]
                   {#Top [..prelude "#source"]
                         {#Top [..prelude "#provenance"]
                               {#Top [..prelude "#current_module"]
                                     {#Top [..prelude "#modules"]
                                           {#Top [..prelude "#scopes"]
                                                 {#Top [..prelude "#type_context"]
                                                       {#Top [..prelude "#expected"]
                                                             {#Top [..prelude "#seed"]
                                                                   {#Top [..prelude "#eval"]
                                                                         {#Empty}}}}}}}}}}})
       #0)
(.def# #info (slot [{#Some [0 #0 ..lux_slots]} Lux]) .public)
(.def# #source (slot [{#Some [1 #0 ..lux_slots]} Lux]) .public)
(.def# #provenance (slot [{#Some [2 #0 ..lux_slots]} Lux]) .public)
(.def# #current_module (slot [{#Some [3 #0 ..lux_slots]} Lux]) .public)
(.def# #modules (slot [{#Some [4 #0 ..lux_slots]} Lux]) .public)
(.def# #scopes (slot [{#Some [5 #0 ..lux_slots]} Lux]) .public)
(.def# #type_context (slot [{#Some [6 #0 ..lux_slots]} Lux]) .public)
(.def# #expected (slot [{#Some [7 #0 ..lux_slots]} Lux]) .public)
(.def# #seed (slot [{#Some [8 #0 ..lux_slots]} Lux]) .public)
(.def# #eval (slot [{#Some [8 #1 ..lux_slots]} Lux]) .public)

... (every .public (Meta a)
...   (-> Lux (Either Text [Lux a])))
(.def# Meta
       (.is# Type
             {#Named [..prelude "Meta"]
                     {#Universal {#Empty}
                                 {#Function Lux
                                            {#Reification {#Product Lux {#Parameter 1}}
                                                          {#Reification Text Either}}}}})
       .public)

... (every .public Macro'
...   (-> (Stack Code) (Meta (Stack Code))))
(.def# Macro'
       (.is# Type
             {#Named [..prelude "Macro'"]
                     {#Function {#Reification Code List}
                                {#Reification {#Reification Code List} Meta}}})
       .public)

(.def# Macro
       (.is# Type
             {#Named [..prelude "Macro"]
                     {#Nominal (.type_name# "macro") {#Empty}}})
       .public)

... Base functions & macros
(.def# meta#in
       (.is# {#Universal {#Empty}
                         {#Function {#Parameter 1}
                                    {#Reification {#Parameter 1} Meta}}}
             (.function# _ val
                         (.function# _ state
                                     {#Right [state val]})))
       #0)

(.def# failure
       (.is# {#Universal {#Empty}
                         {#Function Text
                                    {#Reification {#Parameter 1} Meta}}}
             (.function# _ msg
                         (.function# _ state
                                     {#Left msg})))
       #0)

(.def# text#composite
       (.is# {#Function Text {#Function Text Text}}
             (.function# _ x
                         (.function# _ y
                                     (.text_composite# x y))))
       #0)

... https://en.wikipedia.org/wiki/Delimiter
(.def# name_delimiter
       (.is# Text
             ".")
       #0)

(.def# name#as
       (.is# {#Function Name
                        Text}
             (.function# _ full_name
                         (.when# full_name
                                 [module name]
                                 (.when# module
                                         "" name
                                         _  (.text_composite# module ..name_delimiter name)))))
       #0)

(.def# \''
       (.is# Text
             (.int_char# +34))
       #0)

(.def# wrong_syntax
       (.is# Error
             "Wrong syntax.")
       #1)

(.def# list#as_stack
       (.is# {#Universal {#Empty}
                         {#Function {#Reification {#Parameter 1} List}
                                    {#Reification {#Parameter 1} Stack}}}
             (.function# _ it
                         ((.is# {#Universal {#Empty}
                                            {#Function {#Reification {#Parameter 1} List}
                                                       {#Function Natural
                                                                  {#Function {#Reification {#Parameter 1} Stack}
                                                                             {#Reification {#Parameter 1} Stack}}}}}
                                (.function# next it
                                            (.function# _ remaining
                                                        (.function# _ value
                                                                    (.when# remaining
                                                                            0 value
                                                                            _ (.when# (.i64_-# 1 remaining)
                                                                                      address
                                                                                      (next it address
                                                                                            {#Top (.list_item# address it)
                                                                                                  value})))))))
                          it
                          (.list_size# it)
                          {#Empty})))
       .private)

(.def# list
       (.as# Macro
             (.is# Macro'
                   (.function# _ tokens
                               (meta#in (.list# (code#form (.list_composite# (.list# (code#name [..prelude "list#"]))
                                                                             tokens)))))))
       .public)

(.def# list#of_stack
       (.is# {#Universal {#Empty}
                         {#Function {#Reification {#Parameter 1} Stack}
                                    {#Reification {#Parameter 1} List}}}
             (.function# _ it
                         (.when# it
                                 {#Empty}
                                 (list)

                                 {#Top head tail}
                                 ((.is# {#Universal {#Empty}
                                                    {#Function {#Reification {#Parameter 1} Stack}
                                                               {#Function {#Reification {#Parameter 1} List}
                                                                          {#Reification {#Parameter 1} List}}}}
                                        (.function# next it
                                                    (.function# _ value
                                                                (.when# it
                                                                        {#Empty}
                                                                        value

                                                                        {#Top head tail}
                                                                        (next tail
                                                                              (.list_composite# value (list head)))))))
                                  tail
                                  (list head)))))
       .private)

(.def# let''
       (.as# Macro
             (.is# Macro'
                   (.function# _ tokens
                               (.when# tokens
                                       (.list# lhs rhs body)
                                       (meta#in (list (code#form (list (code#name [..prelude "when#"]) rhs lhs body))))

                                       _
                                       (failure ..wrong_syntax)))))
       #0)

(.def# code#function
       (.is# {#Function Code {#Function {#Reification Code Stack} {#Function Code Code}}}
             (.function# code#function self
                         (.function# _ inputs
                                     (.function# _ output
                                                 (.when# inputs
                                                         {#Empty}
                                                         output

                                                         {#Top head tail}
                                                         (code#form (list (code#name [..prelude "function#"])
                                                                          self
                                                                          head
                                                                          (code#function (code#name ["" ""]) tail output))))))))
       #0)

(.def# function'
       (.as# Macro
             (.is# Macro'
                   (.function# _ tokens
                               (.when# tokens
                                       (.list# {#Form _ self,arguments}
                                               body)
                                       (.when# (list#as_stack self,arguments)
                                               {#Top self arguments}
                                               (meta#in (list (code#function self arguments body)))

                                               else
                                               (failure ..wrong_syntax))

                                       _
                                       (failure ..wrong_syntax)))))
       #0)

(.def# code#def
       (.is# {#Function Code {#Function Code {#Function Code Code}}}
             (function' (_ name value export_policy)
                        (code#form (list (code#name [..prelude "def#"])
                                         name
                                         value
                                         export_policy))))
       #0)

(.def# code#checked
       (.is# {#Function Code {#Function Code Code}}
             (function' (_ type value)
                        (code#form (list (code#name [..prelude "is#"])
                                         type
                                         value))))
       #0)

(.def# code#macro
       (.is# {#Function Code
                        Code}
             (function' (_ expression)
                        (code#form (list (code#name [..prelude "as#"])
                                         (code#name [..prelude "Macro"])
                                         (code#form (list (code#name [..prelude "is#"])
                                                          (code#name [..prelude "Macro'"])
                                                          expression))))))
       #0)

(.def# the'
       (.as# Macro
             (.is# Macro'
                   (function' (_ tokens)
                              (.when# tokens
                                      (.list# export_policy
                                              {#Form _ name,arguments}
                                              type
                                              body)
                                      (.when# (list#as_stack name,arguments)
                                              {#Top name arguments}
                                              (meta#in (list (code#def name
                                                                       (code#checked type
                                                                                     (code#function name arguments
                                                                                                    body))
                                                                       export_policy)))
                                              
                                              else
                                              (failure ..wrong_syntax))

                                      (.list# export_policy name type body)
                                      (meta#in (list (code#def name
                                                               (code#checked type
                                                                             body)
                                                               export_policy)))

                                      _
                                      (failure ..wrong_syntax)))))
       #0)

(.def# macro
       (.as# Macro
             (.is# Macro'
                   (function' (_ tokens)
                              (.when# tokens
                                      (.list# {#Form _ name,arguments} body)
                                      (.when# (list#as_stack name,arguments)
                                              {#Top name arguments}
                                              (meta#in (list (code#macro (code#function name arguments body))))

                                              else
                                              (failure ..wrong_syntax))

                                      _
                                      (failure ..wrong_syntax)))))
       #1)

(the' .public comment
      Macro
      (macro (_ tokens)
        (meta#in (list))))

(the' .private (stack#mix f init xs)
      ... (for_any (_ a b) (-> (-> b a a) a (Stack b) a))
      {#Universal {#Empty}
                  {#Universal {#Empty}
                              {#Function {#Function {#Parameter 1}
                                                    {#Function {#Parameter 3}
                                                               {#Parameter 3}}}
                                         {#Function {#Parameter 3}
                                                    {#Function {#Reification {#Parameter 1} Stack}
                                                               {#Parameter 3}}}}}}
      (.when# xs
              {#Empty}
              init

              {#Top x xs'}
              (stack#mix f (f x init) xs')))

(the' .private $
      Macro
      (macro (_ tokens)
        (.when# (list#as_stack tokens)
                {#Top abstraction parameters}
                (meta#in (list (stack#mix (function' (_ parameter abstraction)
                                                     (code#variant (list (code#name [..prelude "#Reification"])
                                                                         parameter
                                                                         abstraction)))
                                          abstraction
                                          parameters)))

                _
                (failure ..wrong_syntax))))

(the' .private (stack#reversed stack)
      {#Universal {#Empty}
                  {#Function ($ Stack {#Parameter 1})
                             ($ Stack {#Parameter 1})}}
      (stack#mix (.is# {#Universal {#Empty}
                                   {#Function {#Parameter 1} {#Function ($ Stack {#Parameter 1}) ($ Stack {#Parameter 1})}}}
                       (function' (_ head tail)
                                  {#Top head tail}))
                 {#Empty}
                 stack))

(the' .private (stack#each f xs)
      {#Universal {#Empty}
                  {#Universal {#Empty}
                              {#Function {#Function {#Parameter 3} {#Parameter 1}}
                                         {#Function ($ Stack {#Parameter 3})
                                                    ($ Stack {#Parameter 1})}}}}
      (stack#mix (function' (_ head tail)
                            {#Top (f head) tail})
                 {#Empty}
                 (stack#reversed xs)))

(the' .private (list#each value it)
      {#Universal {#Empty}
                  {#Universal {#Empty}
                              {#Function {#Function {#Parameter 3} {#Parameter 1}}
                                         {#Function ($ List {#Parameter 3})
                                                    ($ List {#Parameter 1})}}}}
      (list#of_stack (stack#each value (list#as_stack it))))

(the' .private (list#size it)
      {#Universal {#Empty}
                  {#Function ($ List {#Parameter 1})
                             Natural}}
      (.list_size# it))

(the' .private (text#= expected actual)
      {#Function Text {#Function Text Bit}}
      (.text_=# expected actual))

(the' .private (n#* param subject)
      {#Function Natural {#Function Natural Natural}}
      (.as# Natural
            (.int_*# (.as# Integer param)
                     (.as# Integer subject))))

(the' .private (stack#size stack)
      {#Universal {#Empty}
                  {#Function ($ Stack {#Parameter 1})
                             Natural}}
      (stack#mix (function' (_ _ acc)
                            (.i64_+# 1 acc))
                 0
                 stack))

(the' .private (code#let binding value body)
      {#Function Code {#Function Code {#Function Code Code}}}
      (code#form (list (code#name [..prelude "when#"])
                       value
                       binding
                       body)))

(the' .private |#Empty|
      Code
      (code#variant (list (code#name [..prelude "#Empty"]))))

(the' .private (|#Top| head tail)
      {#Function Code {#Function Code Code}}
      (code#variant (list (code#name [..prelude "#Top"])
                          head
                          tail)))

(the' .private (code#Universal body)
      {#Function Code
                 Code}
      (code#variant (list (code#name [..prelude "#Universal"])
                          ..|#Empty|
                          body)))

(the' .private (code#Existential body)
      {#Function Code
                 Code}
      (code#variant (list (code#name [..prelude "#Existential"])
                          ..|#Empty|
                          body)))

(the' .private quantification_level
      Text
      (.text_composite# \'' "quantification_level" \''))

(the' .private quantified
      {#Function Code
                 Code}
      (code#let (code#local ..quantification_level) (code#natural 0)))

(the' .private (quantified_type_parameter idx)
      {#Function Natural
                 Code}
      (code#variant (list (code#name [..prelude "#Parameter"])
                          (code#form (list (code#name [..prelude "i64_+#"])
                                           (code#local ..quantification_level)
                                           (code#natural idx))))))

(the' .private (next_level depth)
      {#Function Natural
                 Natural}
      (.i64_+# 2 depth))

(the' .private (self_id? id)
      {#Function Natural
                 Bit}
      (.i64_=# id
               (.as# Natural
                     (.int_*# +2
                              (.int_/# +2
                                       (.as# Integer
                                             id))))))

(the' .public (__adjusted_quantified_type__ permission depth type)
      {#Function Natural {#Function Natural {#Function Type Type}}}
      (.when# permission
              0
              (.when# type
                      ... Jackpot!
                      {#Parameter id}
                      (.when# (.i64_-# (.i64_-# depth id) 0)
                              id'
                              (.when# (self_id? id)
                                      [#0] {#Parameter id'}
                                      [#1] {#Parameter (.i64_-# 2 id')}))
                      
                      ... Recur
                      {#Nominal name parameters}
                      {#Nominal name (stack#each (__adjusted_quantified_type__ permission depth)
                                                 parameters)}

                      {#Sum left right}
                      {#Sum (__adjusted_quantified_type__ permission depth left)
                            (__adjusted_quantified_type__ permission depth right)}
                      
                      {#Product left right}
                      {#Product (__adjusted_quantified_type__ permission depth left)
                                (__adjusted_quantified_type__ permission depth right)}
                      
                      {#Function input output}
                      {#Function (__adjusted_quantified_type__ permission depth input)
                                 (__adjusted_quantified_type__ permission depth output)}
                      
                      {#Universal environment body}
                      {#Universal environment
                                  (__adjusted_quantified_type__ permission (next_level depth) body)}
                      
                      {#Existential environment body}
                      {#Existential environment
                                    (__adjusted_quantified_type__ permission (next_level depth) body)}
                      
                      {#Reification parameter function}
                      {#Reification (__adjusted_quantified_type__ permission depth parameter)
                                    (__adjusted_quantified_type__ permission depth function)}

                      ... Leave these alone.
                      {#Named name anonymous} type
                      {#Variable id} type
                      {#Opaque id} type)

              _
              type))

(the' .private (with_correct_quantification body)
      {#Function Code
                 Code}
      (code#form (list (code#name [prelude "__adjusted_quantified_type__"])
                       (code#local ..quantification_level)
                       (code#natural 0)
                       body)))

(the' .private (with_quantification depth body)
      {#Function Natural {#Function Code Code}}
      (.when# (code#local ..quantification_level)
              'level
              (code#let 'level
                        (code#form (list (code#name [..prelude "i64_+#"])
                                         'level
                                         (code#natural (.as# Natural
                                                             (.int_*# +2
                                                                      (.as# Integer
                                                                            depth))))))
                        body)))

(the' .private (initialized_quantification? lux)
      {#Function Lux
                 Bit}
      (.when# lux
              [..#info _ ..#source _ ..#current_module _ ..#modules _
               ..#scopes scopes ..#type_context _
               ..#seed _ ..#expected _ ..#provenance _ ..#eval _]
              (stack#mix (function' (_ scope verdict)
                                    (.when# verdict
                                            [#1] #1
                                            _ (.when# scope
                                                      [..#scope_name _ ..#inner_scopes _ ..#captured _
                                                       ..#locals [..#counter _
                                                                  ..#mappings locals]]
                                                      (stack#mix (function' (_ local verdict)
                                                                            (.when# local
                                                                                    [local _]
                                                                                    (.when# verdict
                                                                                            [#1] #1
                                                                                            _ (.text_=# ..quantification_level local))))
                                                                 #0
                                                                 locals))))
                         #0
                         scopes)))

(the' .public for_any
      Macro
      (macro (_ tokens lux)
        (.when# tokens
                (.list# {#Form _ self_name,args}
                        body)
                (.when# (list#as_stack self_name,args)
                        {#Top self_name args}
                        {#Right [lux
                                 (.list# (.when# (.when# args
                                                         {#Empty}
                                                         body

                                                         {#Top head tail}
                                                         (with_correct_quantification
                                                           (code#let self_name (quantified_type_parameter 0)
                                                                     (.when# (stack#mix (function' (_ parameter offset,body')
                                                                                                   (.when# offset,body'
                                                                                                           [offset body']
                                                                                                           [(.i64_+# 2 offset)
                                                                                                            (code#let parameter (quantified_type_parameter (.i64_+# offset 1))
                                                                                                                      (code#Universal body'))]))
                                                                                        [0 (with_quantification (stack#size args)
                                                                                             body)]
                                                                                        args)
                                                                             [_ raw]
                                                                             raw))))
                                                 raw
                                                 (.when# (initialized_quantification? lux)
                                                         [#1] raw
                                                         [#0] (..quantified raw))))]}

                        else
                        {#Left ..wrong_syntax})
                
                _
                {#Left ..wrong_syntax})))

(the' .public for_some
      Macro
      (macro (_ tokens lux)
        (.when# tokens
                (.list# {#Form _ self_name,args}
                        body)
                (.when# (list#as_stack self_name,args)
                        {#Top self_name args}
                        {#Right [lux
                                 (.list# (.when# (.when# args
                                                         {#Empty}
                                                         body

                                                         {#Top head tail}
                                                         (with_correct_quantification
                                                           (code#let self_name (quantified_type_parameter 0)
                                                                     (.when# (stack#mix (function' (_ parameter offset,body')
                                                                                                   (.when# offset,body'
                                                                                                           [offset body']
                                                                                                           [(.i64_+# 2 offset)
                                                                                                            (code#let parameter (quantified_type_parameter (.i64_+# offset 1))
                                                                                                                      (code#Existential body'))]))
                                                                                        [0 (with_quantification (stack#size args)
                                                                                             body)]
                                                                                        args)
                                                                             [_ raw]
                                                                             raw))))
                                                 raw
                                                 (.when# (initialized_quantification? lux)
                                                         [#1] raw
                                                         [#0] (..quantified raw))))]}

                        else
                        {#Left ..wrong_syntax})
                
                _
                {#Left ..wrong_syntax})))

(the' .public ->
      Macro
      (macro (_ tokens)
        (.when# (stack#reversed (list#as_stack tokens))
                {#Top output inputs}
                (meta#in (.list# (stack#mix (.is# {#Function Code {#Function Code Code}}
                                                  (function' (_ domain co_domain)
                                                             (code#variant (list (code#name [..prelude "#Function"])
                                                                                 domain
                                                                                 co_domain))))
                                            output
                                            inputs)))
                
                _
                (failure ..wrong_syntax))))

(the' .public stack
      Macro
      (macro (_ it)
        (meta#in (list (stack#mix |#Top| |#Empty| (stack#reversed (list#as_stack it)))))))

(the' .private stack#partial
      Macro
      (macro (_ it)
        (.when# (stack#reversed (list#as_stack it))
                {#Top last init}
                (meta#in (list (stack#mix |#Top| last init)))

                _
                (failure ..wrong_syntax))))

(the' .public Union
      Macro
      (macro (_ tokens)
        (.when# (stack#reversed (list#as_stack tokens))
                {#Empty}
                (meta#in (list (code#name [..prelude "Nothing"])))

                {#Top last prevs}
                (meta#in (list (stack#mix (function' (_ left right)
                                                     (code#variant (list (code#name [..prelude "#Sum"]) left right)))
                                          last
                                          prevs))))))

(the' .public Tuple
      Macro
      (macro (_ tokens)
        (.when# (stack#reversed (list#as_stack tokens))
                {#Empty}
                (meta#in (list (code#name [..prelude "Any"])))

                {#Top last prevs}
                (meta#in (list (stack#mix (function' (_ left right)
                                                     (code#variant (list (code#name [..prelude "#Product"]) left right)))
                                          last
                                          prevs))))))

(the' .public Or
      Macro
      ..Union)

(the' .public And
      Macro
      ..Tuple)

(the' .private (pairs xs)
      (for_any (_ it)
        (-> ($ Stack it)
            ($ Maybe ($ Stack (Tuple it it)))))
      (.when# xs
              {#Top x {#Top y xs'}}
              (.when# (pairs xs')
                      {#Some tail}
                      {#Some {#Top [x y] tail}}
                      
                      {#None}
                      {#None})

              {#Empty}
              {#Some {#Empty}}

              _
              {#None}))

(the' .private let'
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# {#Tuple _ bindings} body)
                (.when# (pairs (list#as_stack bindings))
                        {#Some bindings}
                        (meta#in (list (stack#mix (.is# (-> (Tuple Code Code) Code
                                                            Code)
                                                        (function' (_ binding body)
                                                                   (.when# binding
                                                                           [label value]
                                                                           (code#form (list (code#name [..prelude "when#"])
                                                                                            value
                                                                                            label
                                                                                            body)))))
                                                  body
                                                  (stack#reversed bindings))))
                        
                        {#None}
                        (failure ..wrong_syntax))

                _
                (failure ..wrong_syntax))))

(the' .private (any? p xs)
      (for_any (_ it)
        (-> (-> it Bit) ($ Stack it)
            Bit))
      (.when# xs
              {#Empty}
              #0

              {#Top x xs'}
              (.when# (p x)
                      [#1] #1
                      [#0] (any? p xs'))))

(the' .private (code#provenance @)
      (-> Provenance
          Code)
      (let' [[module line column] @]
            (code#tuple (list (code#text module) (code#natural line) (code#natural column)))))

(the' .private no_provenance
      Code
      (code#provenance ..provenance#dummy))

(the' .private (untemplated_stack tokens)
      (-> ($ Stack Code)
          Code)
      (.when# tokens
              {#Empty}
              |#Empty|

              {#Top token tokens'}
              (|#Top| token (untemplated_stack tokens'))))

(the' .private (code#list tokens)
      (-> ($ List Code)
          Code)
      (code#form (.list_composite# (list (code#name [..prelude "list#"]))
                                   tokens)))

(the' .private (stack#composite xs ys)
      (for_any (_ it)
        (-> ($ Stack it) ($ Stack it)
            ($ Stack it)))
      (stack#mix (function' (_ head tail) {#Top head tail})
                 ys
                 (stack#reversed xs)))

(the' .private (right_associativity op a1 a2)
      (-> Code Code Code
          Code)
      (code#form (.list_composite# (.when# op
                                           {#Form _ parts}
                                           parts

                                           _
                                           (list op))
                                   (list a1 a2))))

(the' .private (function#flipped func)
      (for_any (_ left right output)
        (-> (-> left right output)
            (-> right left output)))
      (function' (_ right left)
                 (func left right)))

... https://en.wikipedia.org/wiki/Operator_associativity
(the' .public left_associative
      Macro
      (macro (_ tokens)
        (.when# (list#as_stack tokens)
                {#Top op {#Top first nexts}}
                (meta#in (list (stack#mix (function#flipped (right_associativity op)) first nexts)))
                
                _
                (failure ..wrong_syntax))))

(the' .public right_associative
      Macro
      (macro (_ tokens)
        (.when# (list#as_stack tokens)
                {#Top op tokens'}
                (.when# (stack#reversed tokens')
                        {#Top last prevs}
                        (meta#in (list (stack#mix (right_associativity op) last prevs)))

                        _
                        (failure ..wrong_syntax))
                
                _
                (failure ..wrong_syntax))))

(the' .public all Macro ..right_associative)

... (every (Monad m)
...   (Interface
...    (is (for_any (_ a) (-> a (m a)))
...        #in)
...    (is (for_any (_ a b) (-> (-> a (m b)) (m a) (m b)))
...        #then)))
(.def# Monad
       (.is# Type
             {#Named [..prelude "Monad"]
                     (for_any (_ !)
                       (Tuple (for_any (_ a)
                                (-> a ($ ! a)))
                              (for_any (_ a b)
                                (-> (-> a ($ ! b))
                                    (-> ($ ! a) ($ ! b))))))})
       #0)

(.def# monad_slots
       (.is# {#Reification Name Stack}
             {#Top [..prelude "#in"]
                   {#Top [..prelude "#then"]
                         {#Empty}}})
       #0)
(.def# #in (slot [{#Some [0 #0 ..monad_slots]} Monad]) .private)
(.def# #then (slot [{#Some [0 #1 ..monad_slots]} Monad]) .private)

(the' .private maybe#monad
      ($ Monad Maybe)
      [#in
       (function' (_ x) {#Some x})
       
       #then
       (function' (_ f ma)
                  (.when# ma
                          {#None}
                          {#None}
                          
                          {#Some a}
                          (f a)))])

(the' .private meta#monad
      ($ Monad Meta)
      [#in
       (function' (_ x)
                  (function' (_ state)
                             {#Right state x}))
       
       #then
       (function' (_ f ma)
                  (function' (_ state)
                             (.when# (ma state)
                                     {#Right [state' a]}
                                     (f a state')

                                     {#Left msg}
                                     {#Left msg})))])

(the' .private do
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# monad {#Tuple _ bindings} body)
                (.when# (pairs (list#as_stack bindings))
                        {#Some bindings}
                        (let' ['in (code#local "in")
                               'then (code#local " then ")
                               body' (stack#mix (.is# (-> (Tuple Code Code) Code Code)
                                                      (function' (_ binding body')
                                                                 (let' [[var value] binding]
                                                                       (.when# var
                                                                               {#Name _ [module proper]}
                                                                               (.when# module
                                                                                       ""
                                                                                       (code#form (list 'then
                                                                                                        (code#form (list (code#name [..prelude "function#"])
                                                                                                                         (code#local "")
                                                                                                                         var
                                                                                                                         body'))
                                                                                                        value))

                                                                                       _
                                                                                       (code#form (list var value body')))
                                                                               

                                                                               _
                                                                               (code#form (list 'then
                                                                                                (code#form (list (code#name [..prelude "function#"])
                                                                                                                 (code#local "")
                                                                                                                 var
                                                                                                                 body'))
                                                                                                value))))))
                                                body
                                                (stack#reversed bindings))]
                              (meta#in (list (code#form (list (code#name [..prelude "when#"])
                                                              monad
                                                              (code#tuple (list 'in 'then))
                                                              body')))))
                        
                        {#None}
                        (failure ..wrong_syntax))

                _
                (failure ..wrong_syntax))))

(the' .private (monad#each m f xs)
      (for_any (_ ! input output)
        (-> ($ Monad !)
            (-> input ($ ! output))
            ($ Stack input)
            ($ ! ($ Stack output))))
      (let' [[..#in in ..#then _] m]
            (.when# xs
                    {#Empty}
                    (in {#Empty})
                    
                    {#Top x xs'}
                    (do m
                      [y (f x)
                       ys (monad#each m f xs')]
                      (in {#Top y ys})))))

(the' .private (monad#each#meta $ items)
      (for_any (_ input output)
        (-> (-> input
                ($ Meta output))
            (-> ($ Stack input)
                ($ Meta ($ Stack output)))))
      (function' (_ lux)
                 ((.is# (for_any (_ input output)
                          (-> Lux (-> input ($ Meta output)) ($ Stack input) ($ Stack output)
                              ($ Either Text (And Lux ($ Stack output)))))
                        (function' (again lux $ items output)
                                   (.when# items
                                           {#Empty}
                                           {#Right [lux (stack#reversed output)]}
                                           
                                           {#Top head tail}
                                           (.when# ($ head lux)
                                                   {#Right [lux head]}
                                                   (again lux $ tail {#Top head output})

                                                   {#Left failure}
                                                   {#Left failure}))))
                  lux
                  $
                  items
                  {#Empty})))

(the' .private (monad#mix m f y xs)
      (for_any (_ ! mix input)
        (-> ($ Monad !)
            (-> input mix ($ ! mix))
            mix
            ($ Stack input)
            ($ ! mix)))
      (let' [[..#in in ..#then _] m]
            (.when# xs
                    {#Empty}
                    (in y)
                    
                    {#Top x xs'}
                    (do m
                      [y' (f x y)]
                      (monad#mix m f y' xs')))))

(the' .public if
      Macro
      (macro (_ tokens)
        (.when# (stack#reversed (list#as_stack tokens))
                {#Top else then,test/*}
                (.when# (pairs then,test/*)
                        {.#Some then,test/*}
                        (meta#in (list (stack#mix (function' (_ then,test else)
                                                             (.when# then,test
                                                                     [then test]
                                                                     (code#form (list (code#name [..prelude "when#"])
                                                                                      test
                                                                                      (code#bit #1) then
                                                                                      (code#bit #0) else))))
                                                  else then,test/*)))

                        else
                        (failure ..wrong_syntax))

                _
                (failure ..wrong_syntax))))

(the' .private Property_Stack
      Type
      (for_any (_ it)
        ($ Stack (Tuple Text it))))

(the' .private Property_List
      Type
      (for_any (_ it)
        ($ List (And Text it))))

(the' .private (property#value expected it)
      (for_any (_ it)
        (-> Text ($ Property_List it)
            ($ Maybe it)))
      (let' [limit (list#size it)]
            ((.is# (for_any (_ it)
                     (-> ($ Property_List it) Natural
                         ($ Maybe it)))
                   (function' (_ it)
                              (function' (property#value item)
                                         (if (.int_<# (.as# Integer limit)
                                                      (.as# Integer item))
                                             (let' [[actual value] (.list_item# item it)]
                                                   (if (text#= expected actual)
                                                       {#Some value}
                                                       (property#value (.i64_+# 1 item))))
                                             {#None}))))
             it 0)))

(the' .private (property#with k v property_stack)
      (for_any (_ it)
        (-> Text it ($ Property_Stack it)
            ($ Property_Stack it)))
      (.when# property_stack
              {#Top [k' v'] property_stack'}
              (if (text#= k k')
                  (stack#partial [k v] property_stack')
                  (stack#partial [k' v'] (property#with k v property_stack')))

              {#Empty}
              (stack [k v])))

(the' .private (global_name full_name state)
      (-> Name
          ($ Meta Name))
      (let' [[module name] full_name
             [..#info info ..#source    source  ..#current_module _ ..#modules modules
              ..#scopes scopes ..#type_context types ..#seed seed
              ..#expected  expected ..#provenance  provenance ..#eval _eval] state]
            (.when# (property#value module modules)
                    {#Some [..#module_hash _ ..#module_aliases _ ..#definitions definitions ..#imports _ ..#module_state _]}
                    (.when# (property#value name definitions)
                            {#Some [_ constant]}
                            (.when# constant
                                    {#Definition _}
                                    {#Right [state full_name]}

                                    {#Alias real_name}
                                    {#Right [state real_name]}

                                    {#Default _}
                                    {#Left (.text_composite# "Unknown definition: " (name#as full_name))})

                            {#None}
                            {#Left (.text_composite# "Unknown definition: " (name#as full_name))})
                    
                    {#None}
                    {#Left (.text_composite# "Unknown module: " module " @ " (name#as full_name))})))

(the' .private (untemplated_text value)
      (-> Text
          Code)
      (code#variant (list (code#name [..prelude "#Text"])
                          ..no_provenance
                          (code#text value))))

(the' .public UnQuote
      Type
      {#Named [..prelude "UnQuote"]
              {#Nominal ".Macro/UnQuote" {#Empty}}})

(the' .public (unquote it)
      (-> Macro
          UnQuote)
      (.as# UnQuote it))

(the' .public (unquote_macro it)
      (-> UnQuote
          Macro')
      (.as# Macro' it))

(the' .public Spliced_UnQuote
      Type
      {#Named [..prelude "Spliced_UnQuote"]
              {#Nominal ".Macro/Spliced_UnQuote" {#Empty}}})

(the' .public (spliced_unquote it)
      (-> Macro
          Spliced_UnQuote)
      (.as# Spliced_UnQuote it))

(the' .public (spliced_unquote_macro it)
      (-> Spliced_UnQuote
          Macro')
      (.as# Macro' it))

(the' .private (stack#one f xs)
      (for_any (_ input output)
        (-> (-> input ($ Maybe output)) ($ Stack input)
            ($ Maybe output)))
      (.when# xs
              {#Empty}
              {#None}

              {#Top x xs'}
              (.when# (f x)
                      {#None}
                      (stack#one f xs')

                      {#Some y}
                      {#Some y})))

(the' .private (in_env name state)
      (-> Text Lux
          ($ Maybe Type))
      (let' [[..#info info ..#source    source  ..#current_module _ ..#modules modules
              ..#scopes scopes ..#type_context types ..#seed seed
              ..#expected  expected ..#provenance  provenance ..#eval _eval] state]
            (stack#one (.is# (-> Scope ($ Maybe Type))
                             (function' (_ env)
                                        (let' [[..#scope_name _
                                                ..#inner_scopes _
                                                ..#locals [..#counter _ ..#mappings locals]
                                                ..#captured _] env]
                                              (stack#one (.is# (-> (Tuple Text (Tuple Type Any)) ($ Maybe Type))
                                                               (function' (_ it)
                                                                          (let' [[bname [type _]] it]
                                                                                (if (text#= name bname)
                                                                                    {#Some type}
                                                                                    {#None}))))
                                                         locals))))
                       scopes)))

(the' .private (available? expected_module current_module exported?)
      (-> Text ($ Maybe Text) Bit
          Bit)
      (if exported?
          #1
          (.when# current_module
                  {.#None}
                  #0
                  
                  {.#Some current_module}
                  (text#= expected_module current_module))))

(the' .private (definition_value name state)
      (-> Name
          ($ Meta (Tuple Type Any)))
      (let' [[expected_module expected_proper] name
             [..#info info
              ..#source source
              ..#current_module current_module
              ..#modules modules
              ..#scopes scopes
              ..#type_context types
              ..#seed seed
              ..#expected expected
              ..#provenance provenance
              ..#eval _eval] state]
            (.when# (property#value expected_module modules)
                    {#None}
                    {#Left (.text_composite# "Unknown definition: " (name#as name))}

                    {#Some [..#definitions definitions
                            ..#module_hash _
                            ..#module_aliases _
                            ..#imports _
                            ..#module_state _]}
                    (.when# (property#value expected_proper definitions)
                            {#None}
                            {#Left (.text_composite# "Unknown definition: " (name#as name))}

                            {#Some [exported? definition]}
                            (.when# definition
                                    {#Alias real_name}
                                    (definition_value real_name state)
                                    
                                    {#Definition [def_type def_value]}
                                    (if (available? expected_module current_module exported?)
                                        {#Right [state [def_type def_value]]}
                                        {#Left (.text_composite# "Unavailable definition: " (name#as name))})

                                    {#Default _}
                                    {#Left (.text_composite# "Unknown definition: " (name#as name))})))))

(the' .private (global_value global lux)
      (-> Name
          ($ Meta ($ Maybe (Tuple Type Any))))
      (let' [[module proper] global]
            (.when# (.when# module
                            "" (.when# (in_env proper lux)
                                       {#None}
                                       (definition_value global lux)
                                       
                                       {#Some _}
                                       {#Left (.text_composite# "Not a global value: " (name#as global))})

                            _
                            (definition_value global lux))
                    {#Right [lux' type,value]}
                    {#Right [lux' {#Some type,value}]}
                    
                    {#Left error}
                    {#Right [lux {#None}]})))

(the' .private (and' left right)
      (-> Bit Bit
          Bit)
      (if left
          right
          #0))

(the' .private (name#= left right)
      (-> Name Name
          Bit)
      (let' [[moduleL properL] left
             [moduleR properR] right]
            (all and'
                 (text#= moduleL moduleR)
                 (text#= properL properR))))

(the' .private (every? ?)
      (for_any (_ it)
        (-> (-> it Bit) ($ Stack it)
            Bit))
      (stack#mix (function' (_ _2 _1)
                            (if _1
                                (? _2)
                                #0))
                 #1))

(the' .private (zipped_2 xs ys)
      (for_any (_ left right)
        (-> ($ Stack left) ($ Stack right)
            ($ Stack (Tuple left right))))
      (.when# xs
              {#Top x xs'}
              (.when# ys
                      {#Top y ys'}
                      (stack#partial [x y] (zipped_2 xs' ys'))

                      _
                      (stack))
              
              _
              (stack)))

(the' .private (type#= left right)
      (-> Type Type
          Bit)
      (.when# [left right]
              [{#Nominal nameL parametersL} {#Nominal nameR parametersR}]
              (all and'
                   (text#= nameL nameR)
                   (.i64_=# (stack#size parametersL) (stack#size parametersR))
                   (every? (function' (_ l,r)
                                      (let' [[itL itR] l,r]
                                            (type#= itL itR)))
                           (zipped_2 parametersL parametersR)))

              [{#Sum leftL rightL} {#Sum leftR rightR}]
              (all and'
                   (type#= leftL leftR)
                   (type#= rightL rightR))

              [{#Product leftL rightL} {#Product leftR rightR}]
              (all and'
                   (type#= leftL leftR)
                   (type#= rightL rightR))

              [{#Function leftL rightL} {#Function leftR rightR}]
              (all and'
                   (type#= leftL leftR)
                   (type#= rightL rightR))

              [{#Reification leftL rightL} {#Reification leftR rightR}]
              (all and'
                   (type#= leftL leftR)
                   (type#= rightL rightR))

              [{#Parameter idL} {#Parameter idR}]
              (.i64_=# idL idR)

              [{#Variable idL} {#Variable idR}]
              (.i64_=# idL idR)

              [{#Opaque idL} {#Opaque idR}]
              (.i64_=# idL idR)

              [{#Universal envL bodyL} {#Universal envR bodyR}]
              (all and'
                   (.i64_=# (stack#size envL) (stack#size envR))
                   (every? (function' (_ l,r)
                                      (let' [[itL itR] l,r]
                                            (type#= itL itR)))
                           (zipped_2 envL envR))
                   (type#= bodyL bodyR))

              [{#Existential envL bodyL} {#Existential envR bodyR}]
              (all and'
                   (.i64_=# (stack#size envL) (stack#size envR))
                   (every? (function' (_ l,r)
                                      (let' [[itL itR] l,r]
                                            (type#= itL itR)))
                           (zipped_2 envL envR))
                   (type#= bodyL bodyR))

              [{#Named nameL anonL} anonR]
              (type#= anonL anonR)

              [anonL {#Named nameR anonR}]
              (type#= anonL anonR)

              _
              #0))

(the' .private (one_expansion it)
      (-> ($ Meta ($ List Code))
          ($ Meta Code))
      (do meta#monad
        [it it]
        (.when# it
                (.list# it)
                (in it)

                _
                (failure "Must expand to 1 element."))))

(the' .private (current_module_name state)
      ($ Meta Text)
      (.when# state
              [..#info info ..#source    source  ..#current_module current_module ..#modules modules
               ..#scopes scopes ..#type_context types ..#seed seed
               ..#expected  expected ..#provenance  provenance ..#eval _eval]
              (.when# current_module
                      {#Some module_name}
                      {#Right [state module_name]}

                      _
                      {#Left "Cannot get the module name without a module!"})))

(the' .private (normal name)
      (-> Name
          ($ Meta Name))
      (.when# name
              ["" name]
              (do meta#monad
                [module_name ..current_module_name]
                (in [module_name name]))

              _
              (meta#in name)))

(the' .private (with_provenance provenance it)
      (-> Provenance
          (-> Code
              Code))
      (.when# it
              {#Bit _ it}
              {#Bit provenance it}

              {#Natural _ it}
              {#Natural provenance it}

              {#Integer _ it}
              {#Integer provenance it}

              {#Revolution _ it}
              {#Revolution provenance it}

              {#Decimal _ it}
              {#Decimal provenance it}

              {#Text _ it}
              {#Text provenance it}

              {#Name _ it}
              {#Name provenance it}

              {#Form _ it}
              {#Form provenance it}

              {#Variant _ it}
              {#Variant provenance it}

              {#Tuple _ it}
              {#Tuple provenance it}
              ))

(the' .private (untemplated_composite tag @composite untemplated replace? subst elements)
      (-> Text Provenance (-> Bit Text Code ($ Meta Code)) Bit Text ($ Stack Code)
          ($ Meta Code))
      (do meta#monad
        [.let' [empty_list (code#form (list (code#name [..prelude "list#"])))
                composite_list (.is# (-> Code Code
                                         Code)
                                     (function' (_ before after)
                                                (code#form (list (code#name [..prelude "list_composite#"]) before after))))
                singleton_list (.is# (-> Code Code)
                                     (function' (_ it)
                                                (code#form (list (code#name [..prelude "list#"]) it))))
                expanded_list (.is# (-> Code Code ($ Meta Code))
                                    (function' (_ head tail)
                                               (do meta#monad
                                                 [head (untemplated replace? subst head)]
                                                 (in (composite_list (singleton_list head)
                                                                     tail)))))]
         output (if replace?
                    (monad#mix meta#monad
                               (function' (_ head tail)
                                          (.when# head
                                                  {#Form @composite global,parameters}
                                                  (.when# (list#as_stack global,parameters)
                                                          {#Top {#Name @name global} parameters}
                                                          (do meta#monad
                                                            [|global| (..normal global)
                                                             ?type,value (global_value |global|)]
                                                            (.when# ?type,value
                                                                    {#Some [type value]}
                                                                    (if (type#= Spliced_UnQuote type)
                                                                        (do meta#monad
                                                                          [.let' [it (spliced_unquote_macro (.as# Spliced_UnQuote value))]
                                                                           output (one_expansion (it (.list_composite# (list tail) (list#of_stack parameters))))]
                                                                          (in (with_provenance @composite output)))
                                                                        (expanded_list head tail))
                                                                    
                                                                    {#None}
                                                                    (expanded_list head tail)))

                                                          else
                                                          (expanded_list head tail))

                                                  _
                                                  (expanded_list head tail)))
                               empty_list
                               (stack#reversed elements))
                    (do meta#monad
                      [=elements (monad#each#meta (untemplated replace? subst) elements)]
                      (in (code#list (list#of_stack =elements)))))]
        (in (with_provenance @composite
              (code#variant (list (code#name [..prelude tag])
                                  ..no_provenance
                                  output))))))

(the' .private untemplated_form
      (-> Provenance (-> Bit Text Code ($ Meta Code)) Bit Text ($ Stack Code)
          ($ Meta Code))
      (untemplated_composite "#Form"))

(the' .private untemplated_variant
      (-> Provenance (-> Bit Text Code ($ Meta Code)) Bit Text ($ Stack Code)
          ($ Meta Code))
      (untemplated_composite "#Variant"))

(the' .private untemplated_tuple
      (-> Provenance (-> Bit Text Code ($ Meta Code)) Bit Text ($ Stack Code)
          ($ Meta Code))
      (untemplated_composite "#Tuple"))

(the' .private (untemplated replace? subst token)
      (-> Bit Text Code
          ($ Meta Code))
      (.when# [replace? token]
              [_ {#Bit @token value}]
              (meta#in (code#variant (list (code#name [..prelude "#Bit"])
                                           ..no_provenance
                                           (code#bit value))))

              [_ {#Natural @token value}]
              (meta#in (code#variant (list (code#name [..prelude "#Natural"])
                                           ..no_provenance
                                           (code#natural value))))

              [_ {#Integer @token value}]
              (meta#in (code#variant (list (code#name [..prelude "#Integer"])
                                           ..no_provenance
                                           (code#integer value))))

              [_ {#Revolution @token value}]
              (meta#in (code#variant (list (code#name [..prelude "#Revolution"])
                                           ..no_provenance
                                           (code#revolution value))))
              
              [_ {#Decimal @token value}]
              (meta#in (code#variant (list (code#name [..prelude "#Decimal"])
                                           ..no_provenance
                                           (code#decimal value))))

              [_ {#Text @token value}]
              (meta#in (untemplated_text value))

              [#1 {#Name @token [module name]}]
              (do meta#monad
                [real_name (.when# module
                                   ""
                                   (if (text#= "" subst)
                                       (in [module name])
                                       (global_name [subst name]))

                                   _
                                   (in [module name]))
                 .let' [[module name] real_name]]
                (meta#in (code#variant (list (code#name [..prelude "#Name"])
                                             (code#provenance [module 0 0])
                                             (code#tuple (list (code#text module) (code#text name)))))))

              [#0 {#Name @token [module name]}]
              (meta#in (code#variant (list (code#name [..prelude "#Name"])
                                           (code#provenance @token)
                                           (code#tuple (list (code#text module) (code#text name))))))

              [#1 {#Form @composite elements}]
              (.when# (list#as_stack elements)
                      {#Top {#Name @name global} parameters}
                      (do meta#monad
                        [|global| (..normal global)
                         ?type,value (global_value |global|)]
                        (.when# ?type,value
                                {#Some [type value]}
                                (if (type#= UnQuote type)
                                    (do meta#monad
                                      [.let' [it (unquote_macro (.as# UnQuote value))]
                                       output (one_expansion (it (list#of_stack parameters)))]
                                      (in (with_provenance @composite
                                            output)))
                                    (untemplated_form @composite untemplated replace? subst {#Top {#Name @name global} parameters}))
                                
                                {#None}
                                (untemplated_form @composite untemplated replace? subst {#Top {#Name @name global} parameters})))

                      elements
                      (untemplated_form @composite untemplated replace? subst elements))

              [_ {#Form @composite elements}]
              (untemplated_form @composite untemplated replace? subst (list#as_stack elements))

              [_ {#Variant @composite elements}]
              (untemplated_variant @composite untemplated replace? subst (list#as_stack elements))

              [_ {#Tuple @composite elements}]
              (untemplated_tuple @composite untemplated replace? subst (list#as_stack elements))))

(the' .public Nominal
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# {#Text _ class_name})
                (meta#in (list (code#variant (list (code#name [..prelude "#Nominal"])
                                                   (code#text class_name)
                                                   |#Empty|))))

                (.list# {#Text _ class_name}
                        {#Tuple _ params})
                (meta#in (list (code#variant (list (code#name [..prelude "#Nominal"])
                                                   (code#text class_name)
                                                   (untemplated_stack (list#as_stack params))))))

                _
                (failure ..wrong_syntax))))

(the' .public `
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# template)
                (do meta#monad
                  [current_module current_module_name
                   =template (untemplated #1 current_module template)]
                  (in (list (code#form (list (code#name [..prelude "is#"])
                                             (code#name [..prelude "Code"])
                                             =template)))))

                _
                (failure ..wrong_syntax))))

(the' .public complete_quote Macro `)

(the' .public `'
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# template)
                (do meta#monad
                  [=template (untemplated #1 "" template)]
                  (in (list (code#form (list (code#name [..prelude "is#"])
                                             (code#name [..prelude "Code"])
                                             =template)))))

                _
                (failure ..wrong_syntax))))

(the' .public incomplete_quote Macro `')

(the' .public '
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# template)
                (do meta#monad
                  [=template (untemplated #0 "" template)]
                  (in (list (code#form (list (code#name [..prelude "is#"])
                                             (code#name [..prelude "Code"])
                                             =template)))))

                _
                (failure ..wrong_syntax))))

(the' .public quote Macro ')

(the' .public ,
      UnQuote
      (..unquote
       (macro (_ tokens)
         (.when# tokens
                 (.list# it)
                 (meta#in (list (code#form (list (code#name [..prelude "is#"])
                                                 (code#name [..prelude "Code"])
                                                 it))))

                 _
                 (failure ..wrong_syntax)))))

(the' .public but UnQuote ,)

(the' .public ,'
      UnQuote
      (..unquote
       (macro (_ tokens)
         (.when# tokens
                 (.list# it)
                 (do meta#monad
                   [current_module ..current_module_name
                    it (untemplated #0 current_module it)]
                   (in (list it)))

                 _
                 (failure ..wrong_syntax)))))

(the' .public verbatim UnQuote ,')

(the' .public |>
      Macro
      (macro (_ tokens)
        (.when# (list#as_stack tokens)
                {#Top [init apps]}
                (meta#in (list (stack#mix (.is# (-> Code Code Code)
                                                (function' (_ app acc)
                                                           (.when# app
                                                                   {#Variant _ parts}
                                                                   (code#variant (.list_composite# parts (list acc)))

                                                                   {#Tuple _ parts}
                                                                   (code#tuple (.list_composite# parts (list acc)))

                                                                   {#Form _ parts}
                                                                   (code#form (.list_composite# parts (list acc)))

                                                                   _
                                                                   (` ((, app) (, acc))))))
                                          init
                                          apps)))

                _
                (failure ..wrong_syntax))))

(the' .public <|
      Macro
      (macro (_ tokens)
        (.when# (stack#reversed (list#as_stack tokens))
                {#Top [init apps]}
                (meta#in (list (stack#mix (.is# (-> Code Code Code)
                                                (function' (_ app acc)
                                                           (.when# app
                                                                   {#Variant _ parts}
                                                                   (code#variant (.list_composite# parts (list acc)))

                                                                   {#Tuple _ parts}
                                                                   (code#tuple (.list_composite# parts (list acc)))

                                                                   {#Form _ parts}
                                                                   (code#form (.list_composite# parts (list acc)))

                                                                   _
                                                                   (` ((, app) (, acc))))))
                                          init
                                          apps)))

                _
                (failure ..wrong_syntax))))

(the' .private |Stack<Code>|
      (-> Code
          Code)
      (function' (_ it)
                 (` (..is# {..#Reification ..Code ..Stack}
                           ((..in_module# (, (code#text ..prelude)) ..list#as_stack)
                            (, it))))))

(the' .public ,*
      Spliced_UnQuote
      (..spliced_unquote
       (macro (_ tokens)
         (.when# tokens
                 (.list# tail it)
                 (meta#in (list (` ( .list_composite# (, it) (, tail)))))

                 _
                 (failure ..wrong_syntax)))))

(the' .public also Spliced_UnQuote ,*)

(the' .private meta#failure
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# 'error)
                (meta#in (list (` {.#Left (, 'error)})))

                _
                (failure ..wrong_syntax))))

(the' .private meta#return
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# 'lux 'term)
                (meta#in (list (` {.#Right [(, 'lux) (, 'term)]})))

                _
                (failure ..wrong_syntax))))

(the' .private meta#let
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# 'lux
                        {#Tuple _ (.list# 'binding 'term)}
                        'body)
                (meta#in (list (` (.when# ((, 'term) (, 'lux))
                                          {.#Right [(, 'lux) (, 'binding)]}
                                          (, 'body)

                                          {.#Left (, 'lux)}
                                          {.#Left (, 'lux)}))))

                _
                (failure ..wrong_syntax))))

(the' .private (function#composite f g)
      (for_any (_ start middle end)
        (-> (-> middle end) (-> start middle)
            (-> start end)))
      (function' (_ x)
                 (f (g x))))

(the' .private (full_name x)
      (-> Code
          ($ Maybe Name))
      (.when# x
              {#Name _ sname}
              {#Some sname}

              _
              {#None}))

(the' .private (proper_name x)
      (-> Code
          ($ Maybe Text))
      (.when# x
              {#Name _ ["" sname]}
              {#Some sname}

              _
              {#None}))

(the' .private (tuple_list tuple)
      (-> Code
          ($ Maybe ($ List Code)))
      (.when# tuple
              {#Tuple _ members}
              {#Some members}

              _
              {#None}))

(the' .private (high_bits value)
      (-> ($ I64 Any)
          I64)
      (.i64_right# 32 value))

(the' .private low_mask
      I64
      (|> 1 (.i64_left# 32) (.i64_-# 1)))

(the' .private (low_bits value)
      (-> ($ I64 Any)
          I64)
      (.i64_and# low_mask value))

(the' .private (n#< reference it)
      (-> Natural Natural
          Bit)
      (let' [referenceH (high_bits reference)
             itH (high_bits it)]
            (if (.int_<# referenceH itH)
                #1
                (if (.i64_=# referenceH itH)
                    (.int_<# (low_bits reference)
                             (low_bits it))
                    #0))))

(the' .private (stack#conjoint xs)
      (for_any (_ it)
        (-> ($ Stack ($ Stack it))
            ($ Stack it)))
      (stack#mix stack#composite {#Empty} (stack#reversed xs)))

(the' .public name
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# {#Name _ [module name]})
                (meta#in (list (code#tuple (list (code#text module) (code#text name)))))

                _
                (failure ..wrong_syntax))))

(the' .private Replacement_Environment
      Type
      ($ Stack {#Product Text Code}))

(the' .private (replacement_environment xs ys)
      {#Function ($ Stack Text) {#Function ($ Stack Code) Replacement_Environment}}
      (.when# [xs ys]
              [{#Top x xs'} {#Top y ys'}]
              {#Top [x y] (replacement_environment xs' ys')}

              _
              {#Empty}))

(the' .private (replacement for environment)
      {#Function Text {#Function Replacement_Environment ($ Maybe Code)}}
      (.when# environment
              {#Empty}
              {#None}

              {#Top [k v] environment'}
              (.when# (text#= k for)
                      [#1] {#Some v}
                      [#0] (replacement for environment'))))

(the' .private (realized_template env template)
      (-> Replacement_Environment Code
          Code)
      (.when# template
              {#Name _ ["" sname]}
              (.when# (..replacement sname env)
                      {#Some subst}
                      subst

                      _
                      template)

              {#Form meta it}
              {#Form meta (list#each (realized_template env) it)}

              {#Tuple meta it}
              {#Tuple meta (list#each (realized_template env) it)}

              {#Variant meta it}
              {#Variant meta (list#each (realized_template env) it)}

              _
              template))

(the' .private with_template
      Macro
      (macro (_ tokens)
        (.when# (list#as_stack tokens)
                {#Top {#Tuple _ bindings}
                      {#Top {#Tuple _ templates}
                            data}}
                (.when# [(monad#each maybe#monad ..proper_name (list#as_stack bindings))
                         (monad#each maybe#monad ..tuple_list data)]
                        [{#Some bindings'} {#Some data'}]
                        (let' [reification (.is# (-> Replacement_Environment ($ Stack Code))
                                                 (function' (_ env)
                                                            (stack#each (realized_template env) (list#as_stack templates))))
                               num_bindings (stack#size bindings')]
                              (if (every? (function' (_ size)
                                                     (.i64_=# num_bindings size))
                                          (stack#each list#size data'))
                                  (|> data'
                                      (stack#each (all function#composite
                                                       reification
                                                       (replacement_environment bindings')
                                                       list#as_stack))
                                      stack#conjoint
                                      list#of_stack
                                      meta#in)
                                  (failure ..wrong_syntax)))

                        _
                        (failure ..wrong_syntax))

                _
                (failure ..wrong_syntax))))

(the' .private (n#/ param subject)
      (-> Natural Natural
          Natural)
      (if (.int_<# +0 (.as# Integer param))
          (if (n#< param subject)
              0
              1)
          (let' [quotient (|> subject
                              (.i64_right# 1)
                              (.int_/# (.as# Integer param))
                              (.i64_left# 1))
                 flat (.int_*# (.as# Integer param)
                               (.as# Integer quotient))
                 remainder (.i64_-# flat subject)]
                (if (n#< param remainder)
                    quotient
                    (.i64_+# 1 quotient)))))

(the' .private (n#% param subject)
      (-> Natural Natural
          Natural)
      (let' [flat (.int_*# (.as# Integer param)
                           (.as# Integer (n#/ param subject)))]
            (.i64_-# flat subject)))

(the' .private (bit#as x)
      (-> Bit
          Text)
      (if x "#1" "#0"))

(the' .private (digit::injection digit)
      (-> Natural
          Text)
      (.when# digit
              [0] "0"
              [1] "1" [2] "2" [3] "3"
              [4] "4" [5] "5" [6] "6"
              [7] "7" [8] "8" [9] "9"
              _ (.error# "@digit::injection Undefined behavior.")))

(the' .private (natural#as value)
      (-> Natural
          Text)
      (.when# value
              [0] "0"
              _ (let' [loop (.is# (-> Natural Text Text)
                                  (function' (again input output)
                                             (if (.i64_=# 0 input)
                                                 output
                                                 (again (n#/ 10 input)
                                                        (.text_composite# (|> input (n#% 10) digit::injection)
                                                                          output)))))]
                      (loop value ""))))

(the' .private (integer#abs value)
      (-> Integer
          Integer)
      (if (.int_<# +0 value)
          (.int_*# -1 value)
          value))

(the' .private (integer#as value)
      (-> Integer
          Text)
      (if (.i64_=# +0 value)
          "+0"
          (let' [sign (if (.int_<# value +0)
                          "+"
                          "-")]
                ((.is# (-> Integer Text Text)
                       (function' (again input output)
                                  (if (.i64_=# +0 input)
                                      (.text_composite# sign output)
                                      (again (.int_/# +10 input)
                                             (.text_composite# (|> input (.int_%# +10) (.as# Natural) digit::injection)
                                                               output)))))
                 (|> value (.int_/# +10) integer#abs)
                 (|> value (.int_%# +10) integer#abs (.as# Natural) digit::injection)))))

(the' .public (not x)
      (-> Bit
          Bit)
      (if x #0 #1))

(the' .private (named_macro' modules current_module module name)
      (-> ($ Property_List Module) Text Text Text
          ($ Maybe Macro))
      (do maybe#monad
        [$module (property#value module modules)
         exported?,gdef (let' [[..#module_hash _ ..#module_aliases _ ..#definitions bindings ..#imports _ ..#module_state _] (.is# Module $module)]
                              (property#value name bindings))
         .let' [[exported? gdef] exported?,gdef]]
        (.when# (.is# Global gdef)
                {#Alias [r_module r_name]}
                (named_macro' modules current_module r_module r_name)

                {#Definition [def_type def_value]}
                (if (type#= ..Macro def_type)
                    (if exported?
                        {#Some (.as# Macro def_value)}
                        (if (text#= module current_module)
                            {#Some (.as# Macro def_value)}
                            {#None}))
                    {#None})

                {#Default _}
                {#None})))

(the' .private (named_macro full_name)
      (-> Name
          ($ Meta ($ Maybe Macro)))
      (<| (function' (_ lux))
          (meta#let lux [current_module current_module_name])
          (let' [[module name] full_name
                 [..#info info ..#source source ..#current_module _ ..#modules modules
                  ..#scopes   scopes   ..#type_context   types ..#seed   seed
                  ..#expected expected ..#provenance provenance ..#eval _eval] lux])
          (meta#return lux (named_macro' modules current_module module name))))

(the' .private (macro? name)
      (-> Name
          ($ Meta Bit))
      (<| (function' (_ lux))
          (meta#let lux [name (normal name)])
          (meta#let lux [output (named_macro name)])
          (meta#return lux (.when# output
                                   {#Some _} #1
                                   {#None}   #0))))

(the' .private (stack#interposed sep xs)
      (for_any (_ it)
        (-> it ($ Stack it)
            ($ Stack it)))
      (.when# xs
              {#Empty}
              xs

              {#Top [x {#Empty}]}
              xs

              {#Top [x xs']}
              (stack#partial x sep (stack#interposed sep xs'))))

(the' .private (text#as original)
      (-> Text
          Text)
      (.text_composite# \'' original \''))

(the' .private (code#as code)
      (-> Code
          Text)
      (.when# code
              {#Bit _ value}
              (bit#as value)

              {#Natural _ value}
              (natural#as value)

              {#Integer _ value}
              (integer#as value)

              {#Revolution _ value}
              (.error# "@code#as Undefined behavior.")
              
              {#Decimal _ value}
              (.error# "@code#as Undefined behavior.")

              {#Text _ value}
              (text#as value)
              
              {#Name _ [module name]}
              (name#as [module name])
              
              {#Form _ it}
              (.text_composite#
               "("
               (|> it
                   list#as_stack
                   (stack#each code#as)
                   (stack#interposed " ")
                   stack#reversed
                   (stack#mix text#composite ""))
               ")")
              
              {#Tuple _ it}
              (.text_composite#
               "["
               (|> it
                   list#as_stack
                   (stack#each code#as)
                   (stack#interposed " ")
                   stack#reversed
                   (stack#mix text#composite ""))
               "]")
              
              {#Variant _ it}
              (.text_composite#
               "{"
               (|> it
                   list#as_stack
                   (stack#each code#as)
                   (stack#interposed " ")
                   stack#reversed
                   (stack#mix text#composite ""))
               "}")))

(the' .private (single_expansion token)
      (-> Code
          ($ Meta ($ List Code)))
      (.when# token
              {#Form _ name,args}
              (.when# (list#as_stack name,args)
                      {#Top {#Name _ name} args}
                      (<| (function' (_ lux))
                          (meta#let lux [name' (normal name)])
                          (meta#let lux [?macro (named_macro name')])
                          (.when# ?macro
                                  {#Some macro}
                                  (((.as# Macro' macro) (list#of_stack args)) lux)
                                  
                                  {#None}
                                  (meta#return lux (list token))))

                      else
                      (meta#in (list token)))

              _
              (meta#in (list token))))

(the' .private (complete_expansion token)
      (-> Code
          ($ Meta ($ List Code)))
      (.when# token
              {#Form _ name,args}
              (.when# (list#as_stack name,args)
                      {#Top {#Name _ name} args}
                      (<| (function' (_ lux))
                          (meta#let lux [name' (normal name)])
                          (meta#let lux [?macro (named_macro name')])
                          (.when# ?macro
                                  {#Some macro}
                                  (<| (meta#let lux [maximum_level_expansion ((.as# Macro' macro) (list#of_stack args))])
                                      (meta#let lux [recursive_expansion (monad#each#meta complete_expansion (list#as_stack maximum_level_expansion))])
                                      (meta#return lux (list#of_stack (stack#conjoint (stack#each list#as_stack recursive_expansion)))))
                                  
                                  {#None}
                                  (meta#return lux (list token))))

                      _
                      (meta#in (list token)))

              _
              (meta#in (list token))))

(the' .public exec
      Macro
      (macro (_ tokens)
        (.when# (stack#reversed (list#as_stack tokens))
                {#Top value actions}
                (let' [dummy (code#local "")]
                      (meta#in (list (stack#mix (.is# (-> Code Code Code)
                                                      (function' (_ pre post)
                                                                 (` (.when# (, pre)
                                                                            (, dummy)
                                                                            (, post)))))
                                                value
                                                actions))))

                _
                (failure ..wrong_syntax))))

(the' .private (type_reification abstraction parameters)
      (-> Code ($ Stack Code)
          Code)
      (stack#mix (.is# (-> Code Code Code)
                       (function' (_ parameter abstraction)
                                  (` {.#Reification (, parameter) (, abstraction)})))
                 abstraction
                 parameters))

(the' .private (normal_type_reification normal_type abstraction parameters)
      (-> (-> Code ($ Meta Code)) Code ($ Stack Code)
          ($ Meta Code))
      (<| (function' (_ lux))
          (meta#let lux [parameters (monad#each#meta normal_type parameters)])
          (meta#return lux (type_reification abstraction parameters))))

(the' .public type_must_have_singular_expansion
      Error
      "The expansion of the type-syntax has to yield a single element.")

(the' .private (expanded_type_reification normal_type @ binding parameters)
      (-> (-> Code ($ Meta Code)) Provenance Name ($ List Code)
          ($ Meta Code))
      (<| (function' (_ lux))
          (meta#let lux [binding (normal binding)])
          (meta#let lux [?macro (named_macro binding)])
          (.when# ?macro
                  {#Some macro}
                  (<| (meta#let lux [expansion ((.as# Macro' macro) parameters)])
                      (.when# expansion
                              (.list# singular)
                              (meta#return lux (` (..type (, singular))))

                              else
                              (meta#failure ..type_must_have_singular_expansion)))
                  
                  {#None}
                  ((normal_type_reification normal_type {#Name @ binding} (list#as_stack parameters)) lux))))

(the' .private (normal_type type' it)
      (-> (-> Code ($ Meta Code)) Code
          ($ Meta Code))
      (.when# it
              {#Variant _ (.list# {#Name _ ["library/lux" "#Named"]}
                                  name
                                  anonymous)}
              (<| (function' (_ lux))
                  (meta#let lux [anonymous (normal_type type' anonymous)])
                  (meta#return lux (` {..#Named (, name) (, anonymous)})))

              {#Form _ (.list# {#Name _ ["library/lux" "in_module#"]}
                               {#Text _ module}
                               it')}
              (<| (function' (_ lux))
                  (meta#let lux [it' (normal_type type' it')])
                  (meta#return lux (` (.in_module# (, (code#text module)) (, it')))))

              {#Form _ (.list# {#Name _ ["" ","]}
                               expression)}
              (meta#in expression)

              {#Form @form (.list# {#Name @name ["library/lux" "when#"]}
                                   value
                                   binding
                                   body)}
              (<| (function' (_ lux))
                  (meta#return lux {#Form @form (list {#Name @name ["library/lux" "when#"]}
                                                      value
                                                      binding
                                                      (` (..type (, body))))}))

              {#Form @form (.list# {#Name @name ["library/lux" "__adjusted_quantified_type__"]}
                                   _permission
                                   _level
                                   body)}
              (<| (function' (_ lux))
                  (meta#let lux [body (normal_type type' body)])
                  (meta#return lux {#Form @form (list {#Name @name [..prelude "__adjusted_quantified_type__"]}
                                                      _permission
                                                      _level
                                                      body)}))

              {#Form _ (.list# {#Form _ (.list# {#Name _ ["library/lux" "in_module#"]}
                                                {#Text _ "library/lux"}
                                                {#Name _ ["library/lux" "type"]})}
                               it')}
              (type' it')

              {#Variant _ it}
              (<| (function' (_ lux))
                  (meta#let lux [it (monad#each#meta (normal_type type') (list#as_stack it))])
                  (meta#return lux (` {(,* (list#of_stack it))})))

              {#Tuple _ it}
              (<| (function' (_ lux))
                  (meta#let lux [it (monad#each#meta (normal_type type') (list#as_stack it))])
                  (meta#return lux (` (Tuple (,* (list#of_stack it))))))

              {#Form _ binding,parameters}
              (.when# (list#as_stack binding,parameters)
                      {#Top {#Name @binding binding}
                            parameters}
                      (<| (function' (_ lux))
                          (.when# binding
                                  ["" local]
                                  (.when# (in_env local lux)
                                          {.#Some type_of_local}
                                          ((normal_type_reification (normal_type type') {#Name @binding binding} parameters) lux)
                                          
                                          not_a_local
                                          ((expanded_type_reification (normal_type type') @binding binding (list#of_stack parameters)) lux))
                                  
                                  [module global]
                                  ((expanded_type_reification (normal_type type') @binding binding (list#of_stack parameters)) lux)))

                      {#Top type_fn args}
                      (<| (function' (_ lux))
                          (meta#let lux [type_fn (normal_type type' type_fn)])
                          (meta#let lux [args (monad#each#meta (normal_type type') args)])
                          (meta#return lux (type_reification type_fn args)))

                      _
                      (meta#in it))

              _
              (meta#in it)))

(the' .private (with_quantification' body lux)
      (-> ($ Meta Code)
          ($ Meta Code))
      (let' [[..#info info/pre
              ..#source source/pre
              ..#current_module current_module/pre
              ..#modules modules/pre
              ..#scopes scopes/pre
              ..#type_context type_context/pre
              ..#seed seed/pre
              ..#expected expected/pre
              ..#provenance provenance/pre
              ..#eval eval/pre] lux]
            (.when# (body [..#info info/pre
                           ..#source source/pre
                           ..#current_module current_module/pre
                           ..#modules modules/pre
                           ..#scopes (stack#partial [#scope_name (stack)
                                                     #inner_scopes 0
                                                     #locals [#counter 0
                                                              #mappings (stack [..quantification_level [.Natural (.as# Natural -1)]])]
                                                     #captured [#counter 0
                                                                #mappings (stack)]]
                                                    scopes/pre)
                           ..#type_context type_context/pre
                           ..#seed seed/pre
                           ..#expected expected/pre
                           ..#provenance provenance/pre
                           ..#eval eval/pre])
                    {..#Right [lux/post output]}
                    (let' [[..#info info/post
                            ..#source source/post
                            ..#current_module current_module/post
                            ..#modules modules/post
                            ..#scopes scopes/post
                            ..#type_context type_context/post
                            ..#seed seed/post
                            ..#expected expected/post
                            ..#provenance provenance/post
                            ..#eval eval/post] lux/post]
                          {..#Right [[..#info info/post
                                      ..#source source/post
                                      ..#current_module current_module/post
                                      ..#modules modules/post
                                      ..#scopes scopes/pre
                                      ..#type_context type_context/post
                                      ..#seed seed/post
                                      ..#expected expected/post
                                      ..#provenance provenance/post
                                      ..#eval eval/post]
                                     output]})
                    
                    failure
                    failure)))

(the' .private (type' it)
      (-> Code
          ($ Meta Code))
      (<| (function' (_ lux))
          (if (initialized_quantification? lux)
              ((normal_type type' it) lux)
              (<| (meta#let lux [it (with_quantification'
                                      (type' it))])
                  (meta#return lux (..quantified it))))))

(the' .public type
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# it)
                (<| (function' (_ lux))
                    (meta#let lux [it (type' it)])
                    (meta#return lux (list it)))

                _
                (failure ..wrong_syntax))))

(the' .public is
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# type term)
                (meta#in (list (` (.is# (..type (, type))
                                        (, term)))))

                _
                (failure ..wrong_syntax))))

(the' .public as
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# type value)
                (meta#in (list (` (.as# (..type (, type))
                                        (, value)))))

                _
                (failure ..wrong_syntax))))

(the' .private (empty? xs)
      (for_any (_ it)
        (-> ($ Stack it)
            Bit))
      (.when# xs
              {#Empty} #1
              _      #0))

(with_template [<name> <side>]
  [(the' .private (<name> left,right)
         (for_any (_ left right)
           (-> (Tuple left right)
               <side>))
         (let' [[left right] left,right]
               <side>))]

  [product#left  left]
  [product#right right]
  )

(the' .private (generated_name prefix state)
      (-> Text
          ($ Meta Code))
      (.when# state
              [..#info info ..#source source ..#current_module _ ..#modules modules
               ..#scopes   scopes   ..#type_context   types ..#seed   seed
               ..#expected expected ..#provenance provenance ..#eval _eval]
              {#Right [..#info info ..#source source ..#current_module _ ..#modules modules
                       ..#scopes   scopes   ..#type_context   types ..#seed   (.i64_+# 1 seed)
                       ..#expected expected ..#provenance provenance ..#eval _eval]
                      (code#local (.text_composite# "__gensym__" prefix (natural#as seed)))}))

(with_template [<name> <tag>]
  [(the' .private (<name> type)
         (type (-> Type
                   (Stack Type)))
         (.when# type
                 {<tag> left right}
                 (stack#partial left (<name> right))

                 _
                 (stack type)))]

  [flat_variant #Sum]
  [flat_tuple   #Product]
  [flat_lambda  #Function]
  )

(the' .private (flat_reification type)
      (type (-> Type
                [Type (Stack Type)]))
      (.when# type
              {#Reification head func'}
              (let' [[func tail] (flat_reification func')]
                    [func {#Top head tail}])

              _
              [type (stack)]))

(the' .private (type#as type)
      (-> Type
          Text)
      (.when# type
              {#Nominal name params}
              (.text_composite#
               "(Nominal " (text#as name)
               (|> params
                   (stack#each (function' (_ it)
                                          (|> it
                                              type#as
                                              (.text_composite# " "))))
                   stack#reversed
                   (stack#mix text#composite ""))
               ")")

              {#Sum _}
              (.text_composite# "{" (|> (flat_variant type) (stack#each type#as) (stack#interposed " ") stack#reversed (stack#mix text#composite "")) "}")
              
              {#Product _}
              (.text_composite# "[" (|> (flat_tuple type) (stack#each type#as) (stack#interposed " ") stack#reversed (stack#mix text#composite "")) "]")

              {#Function _}
              (.text_composite# "(-> " (|> (flat_lambda type) (stack#each type#as) (stack#interposed " ") stack#reversed (stack#mix text#composite "")) ")")

              {#Parameter id}
              (natural#as id)
              
              {#Variable id}
              (.text_composite# "-" (natural#as id))
              
              {#Opaque id}
              (.text_composite# "+" (natural#as id))
              
              {#Universal env body}
              (.text_composite# "(for_any " (type#as body) ")")

              {#Existential env body}
              (.text_composite# "(for_some " (type#as body) ")")
              
              {#Reification _}
              (let' [[func args] (flat_reification type)]
                    (.text_composite#
                     "(" (type#as func) " "
                     (|> args (stack#each type#as) (stack#interposed " ") stack#reversed (stack#mix text#composite ""))
                     ")"))
              
              {#Named name _}
              (name#as name)))

(the' .private (meta#try it)
      (type (for_any (_ it)
              (-> (Meta it)
                  (Meta (Either Text it)))))
      (function' (_ state)
                 (.when# (it state)
                         {#Left error}
                         {#Right [state {#Left error}]}
                         
                         {#Right [state output]}
                         {#Right [state {#Right output}]})))

(the' .private (anonymous_type it)
      (-> Type
          Type)
      (.when# it
              {#Named _ it}
              (anonymous_type it)
              
              _
              it))

(the' .private error#the
      Macro
      (macro (_ tokens)
        (meta#in (list (` (..the' ..public (,* tokens)
                                  Error
                                  (name#as (..name (,* tokens)))))))))

(error#the not_a_static_value)

(the' .private static'
      (type (-> Bit Code
                (Meta Code)))
      (let' [simple_literal (is (-> Name
                                    (Meta Code))
                                (function' (_ name)
                                           (do meta#monad
                                             [type+value (meta#try (definition_value name))]
                                             (.when# type+value
                                                     {#Left error}
                                                     (in (code#name name))
                                                     
                                                     {#Right [type value]}
                                                     (.when# (anonymous_type type)
                                                             {#Nominal name_of_type {#Empty}}
                                                             (if (text#= name_of_type (.type_name# "bit"))
                                                                 (in (code#bit (as Bit value)))

                                                                 (text#= name_of_type (.type_name# "decimal"))
                                                                 (in (code#decimal (as Decimal value)))

                                                                 (text#= name_of_type (.type_name# "text"))
                                                                 (in (code#text (as Text value)))

                                                                 (if (text#= name_of_type (.type_name# "tag"))
                                                                     #1
                                                                     ... else
                                                                     (text#= name_of_type (.type_name# "slot")))
                                                                 (in (code#name name))

                                                                 ... else
                                                                 (failure ..not_a_static_value))

                                                             {#Nominal name_of_type {#Top {#Nominal name_of_specialization {#Empty}} {#Empty}}}
                                                             (if (text#= name_of_type (.type_name# "i64"))
                                                                 (if (text#= name_of_specialization (.type_name# "natural"))
                                                                     (in (code#natural (as Natural value)))

                                                                     (text#= name_of_specialization (.type_name# "integer"))
                                                                     (in (code#integer (as Integer value)))

                                                                     (text#= name_of_specialization (.type_name# "revolution"))
                                                                     (in (code#revolution (as Revolution value)))

                                                                     ... else
                                                                     (failure ..not_a_static_value))

                                                                 ... else
                                                                 (failure ..not_a_static_value))

                                                             _
                                                             (failure ..not_a_static_value))))))]
            (function' (literal only_global? token)
                       (.when# token
                               {#Name _ [def_module def_name]}
                               (if (text#= "" def_module)
                                   (if only_global?
                                       (meta#in (code#name [def_module def_name]))
                                       (do meta#monad
                                         [current_module current_module_name]
                                         (simple_literal [current_module def_name])))
                                   (simple_literal [def_module def_name]))

                               {#Form meta parts}
                               (do meta#monad
                                 [=parts (monad#each#meta (literal only_global?) (list#as_stack parts))]
                                 (in {#Form meta (list#of_stack =parts)}))

                               {#Variant meta parts}
                               (do meta#monad
                                 [=parts (monad#each#meta (literal only_global?) (list#as_stack parts))]
                                 (in {#Variant meta (list#of_stack =parts)}))

                               {#Tuple meta parts}
                               (do meta#monad
                                 [=parts (monad#each#meta (literal only_global?) (list#as_stack parts))]
                                 (in {#Tuple meta (list#of_stack =parts)}))

                               _
                               ... TODO: Figure out why this doesn't work:
                               ... (meta#in token)
                               (meta#in token)))))

(the' .public static
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# pattern)
                (do meta#monad
                  [pattern' (static' #0 pattern)]
                  (in (list pattern')))
                
                _
                (failure ..wrong_syntax))))

(the' .public Pattern
      Type
      {#Named [..prelude "Pattern"]
              (Nominal ".Macro/Pattern")})

(the' .public (pattern it)
      (-> Macro
          Pattern)
      (.as# Pattern it))

(the' .public (pattern_macro it)
      (-> Pattern
          Macro')
      (.as# Macro' it))

(the' .private (total_expansion' total_expansion @name name args)
      (-> (-> Code ($ Meta ($ List Code))) Provenance Name ($ List Code)
          ($ Meta ($ List Code)))
      (<| (function' (_ lux))
          (meta#let lux [name' (normal name)])
          (meta#let lux [?macro (named_macro name')])
          (.when# ?macro
                  {#Some macro}
                  (<| (meta#let lux [expansion ((.as# Macro' macro) args)])
                      (meta#let lux [expansion' (monad#each#meta total_expansion (list#as_stack expansion))])
                      (meta#return lux (list#of_stack (stack#conjoint (stack#each list#as_stack expansion')))))
                  
                  {#None}
                  (<| (meta#let lux [args' (monad#each#meta total_expansion (list#as_stack args))])
                      (meta#return lux (list (code#form (list#of_stack {#Top {#Name @name name}
                                                                             (stack#conjoint (stack#each list#as_stack args'))}))))))))

(the' .private (total_expansion syntax)
      (-> Code
          ($ Meta ($ List Code)))
      (.when# syntax
              {#Form _ it}
              (.when# (list#as_stack it)
                      {#Top {#Name @name name} tail}
                      (..total_expansion' total_expansion @name name (list#of_stack tail))

                      it
                      (<| (function' (_ lux))
                          (meta#let lux [members' (monad#each#meta total_expansion it)])
                          (meta#return lux (list (code#form (list#of_stack (stack#conjoint (stack#each list#as_stack members'))))))))

              {#Variant _ members}
              (<| (function' (_ lux))
                  (meta#let lux [members' (monad#each#meta total_expansion (list#as_stack members))])
                  (meta#return lux (list (code#variant (list#of_stack (stack#conjoint (stack#each list#as_stack members')))))))

              {#Tuple _ members}
              (<| (function' (_ lux))
                  (meta#let lux [members' (monad#each#meta total_expansion (list#as_stack members))])
                  (meta#return lux (list (code#tuple (list#of_stack (stack#conjoint (stack#each list#as_stack members')))))))

              _
              (meta#in (list syntax))))

(the' .private (when_expansion#macro when_expansion pattern body branches)
      (type (-> (-> (Stack Code) (Meta (Stack Code))) Code Code (Stack Code)
                (Meta (Stack Code))))
      (do meta#monad
        [pattern (one_expansion (total_expansion pattern))
         pattern (static' #1 pattern)
         branches (when_expansion branches)]
        (in (stack#partial pattern body
                           branches))))

(the' .private (when_expansion branches)
      (type (-> (Stack Code)
                (Meta (Stack Code))))
      (.when# branches
              {#Top {#Form @composite global,parameters}
                    {#Top body
                          branches'}}
              (.when# (list#as_stack global,parameters)
                      {#Top {#Name @name global} parameters}
                      (do meta#monad
                        [|global| (..normal global)
                         ?type,value (global_value |global|)]
                        (.when# ?type,value
                                {#Some [type value]}
                                (if (type#= Pattern type)
                                    (do meta#monad
                                      [branches'' ((pattern_macro (.as# Pattern value))
                                                   (list#of_stack (stack#partial (code#form (list#of_stack parameters)) body
                                                                                 branches')))]
                                      (when_expansion (list#as_stack branches'')))
                                    (when_expansion#macro when_expansion
                                                          {#Form @composite (list#of_stack {#Top {#Name @name global} parameters})}
                                                          body
                                                          branches'))
                                
                                {#None}
                                (when_expansion#macro when_expansion
                                                      {#Form @composite (list#of_stack {#Top {#Name @name global} parameters})}
                                                      body
                                                      branches')))

                      _
                      (failure (.text_composite# "'when' expects an even number of tokens: "
                                                 (|> branches
                                                     (stack#each code#as)
                                                     (stack#interposed " ")
                                                     stack#reversed
                                                     (stack#mix text#composite "")))))

              {#Top pattern {#Top body branches'}}
              (when_expansion#macro when_expansion pattern body branches')

              {#Empty}
              (meta#in (stack))

              _
              (failure (.text_composite# "'when' expects an even number of tokens: "
                                         (|> branches
                                             (stack#each code#as)
                                             (stack#interposed " ")
                                             stack#reversed
                                             (stack#mix text#composite ""))))))

(the' .public when
      Macro
      (macro (_ tokens)
        (.when# (list#as_stack tokens)
                {#Top value branches}
                (do meta#monad
                  [expansion (when_expansion branches)]
                  (in (list (` (.when# (, value) (,* (list#of_stack expansion)))))))

                _
                (failure ..wrong_syntax))))

(the' .private ^#or
      Pattern
      (pattern
       (macro (_ tokens)
         (when (list#as_stack tokens)
           (stack#partial {#Form _ patterns} body branches)
           (when patterns
             (list)
             (failure "^#or cannot have 0 patterns")

             _
             (let' [pairs (|> patterns
                              list#as_stack
                              (stack#each (function' (_ pattern)
                                                     (stack pattern body)))
                              stack#conjoint)]
                   (meta#in (list#of_stack (stack#composite pairs branches)))))
           _
           (failure ..wrong_syntax)))))

(the' .private (name? code)
      (type (-> Code
                Bit))
      (when code
        {#Name _ _}
        #1

        _
        #0))

(the' .public bindings_must_be_pairs
      Error
      "Bindings must be pairs (i.e. they must be an even number).")

(the' .public let
      Macro
      (macro (_ tokens)
        (when tokens
          (list {#Tuple _ bindings} body)
          (when (..pairs (list#as_stack bindings))
            {#Some bindings}
            (|>  bindings
                 stack#reversed
                 (stack#mix (is (-> [Code Code] Code Code)
                                (function' (_ lr body')
                                           (let' [[l r] lr]
                                                 (if (name? l)
                                                     (` (.when# (, r) (, l) (, body')))
                                                     (` (when (, r) (, l) (, body')))))))
                            body)
                 list
                 meta#in)

            {#None}
            (failure ..bindings_must_be_pairs))

          _
          (failure ..wrong_syntax))))

(the' .public function
      Macro
      (macro (_ tokens)
        (when (is (Maybe [Text Code (Stack Code) Code])
                  (when tokens
                    (list {#Form _ name,head,tail}
                          body)
                    (when (list#as_stack name,head,tail)
                      (stack#partial {#Name _ ["" name]} head tail)
                      {#Some name head tail body}

                      _
                      {#None})
                    
                    _
                    {#None}))
          {#Some 'name head tail body}
          (let ['blank (code#local "")
                nest (is (-> Code (-> Code Code Code))
                         (function' (_ 'name)
                                    (function' (_ arg body')
                                               (if (name? arg)
                                                   (` (.function# (, 'name) (, arg) (, body')))
                                                   (` (.function# (, 'name) (, 'blank)
                                                                  (.when (, 'blank) (, arg) (, body'))))))))]
            (meta#in (list (nest (..code#local 'name) head
                                 (stack#mix (nest 'blank) body (stack#reversed tail))))))

          {#None}
          (failure ..wrong_syntax))))

(the' .private Projection
      Type
      {#Named [..prelude "Projection"]
              (type (for_any (_ it)
                      (-> (Stack Code)
                          (Maybe [(Stack Code) it]))))})

(the' .private (parsed projection tokens)
      (type (for_any (_ it)
              (-> (Projection it) (Stack Code)
                  (Maybe it))))
      (when (projection tokens)
        {#Some [(stack) it]}
        {#Some it}

        _
        {#None}))

(the' .private (inP it tokens)
      (type (for_any (_ it)
              (-> it
                  (Projection it))))
      {#Some [tokens it]})

(the' .private (orP leftP rightP tokens)
      (type (for_any (_ left right)
              (-> (Projection left)
                  (Projection right)
                  (Projection (Or left right)))))
      (when (leftP tokens)
        {#Some [tokens left]}
        {#Some [tokens {#Left left}]}

        _
        (when (rightP tokens)
          {#Some [tokens right]}
          {#Some [tokens {#Right right}]}

          _
          {#None})))

(the' .private (eitherP leftP rightP tokens)
      (type (for_any (_ it)
              (-> (Projection it) (Projection it)
                  (Projection it))))
      (when (leftP tokens)
        {#None}
        (rightP tokens)

        it
        it))

(the' .private (andP leftP rightP tokens)
      (type (for_any (_ left right)
              (-> (Projection left) (Projection right)
                  (Projection (And left right)))))
      (do maybe#monad
        [left (leftP tokens)
         .let [[tokens left] left]
         right (rightP tokens)
         .let [[tokens right] right]]
        (in [tokens [left right]])))

(the' .private (afterP leftP rightP tokens)
      (type (for_any (_ _ it)
              (-> (Projection _) (Projection it)
                  (Projection it))))
      (do maybe#monad
        [left (leftP tokens)
         .let [[tokens left] left]]
        (rightP tokens)))

(the' .private (someP itP tokens)
      (type (for_any (_ it)
              (-> (Projection it)
                  (Projection (Stack it)))))
      (when (itP tokens)
        {#Some [tokens head]}
        (do maybe#monad
          [it (someP itP tokens)
           .let [[tokens tail] it]]
          (in [tokens (stack#partial head tail)]))

        {#None}
        {#Some [tokens (stack)]}))

(the' .private (manyP itP tokens)
      (type (for_any (_ it)
              (-> (Projection it)
                  (Projection (Stack it)))))
      (do maybe#monad
        [it (itP tokens)
         .let [[tokens head] it]
         it (someP itP tokens)
         .let [[tokens tail] it]]
        (in [tokens (stack#partial head tail)])))

(the' .private (maybeP itP tokens)
      (type (for_any (_ it)
              (-> (Projection it)
                  (Projection (Maybe it)))))
      (when (itP tokens)
        {#Some [tokens it]}
        {#Some [tokens {#Some it}]}

        {#None}
        {#Some [tokens {#None}]}))

(the' .private (tupleP itP tokens)
      (type (for_any (_ it)
              (-> (Projection it)
                  (Projection it))))
      (when tokens
        (stack#partial {#Tuple _ input} tokens')
        (do maybe#monad
          [it (parsed itP (list#as_stack input))]
          (in [tokens' it]))

        _
        {#None}))

(the' .private (formP itP tokens)
      (type (for_any (_ it)
              (-> (Projection it)
                  (Projection it))))
      (when tokens
        (stack#partial {#Form _ input} tokens')
        (do maybe#monad
          [it (parsed itP (list#as_stack input))]
          (in [tokens' it]))

        _
        {#None}))

(the' .private (bindingP tokens)
      (type (Projection [Text Code]))
      (when tokens
        (stack#partial {#Name _ ["" name]} value &rest)
        {#Some [&rest [name value]]}

        _
        {#None}))

(the' .private (endP tokens)
      (type (Projection Any))
      (when tokens
        (stack)
        {#Some [tokens []]}

        _
        {#None}))

(the' .private (anyP tokens)
      (type (Projection Code))
      (when tokens
        (stack#partial code tokens')
        {#Some [tokens' code]}

        _
        {#None}))

(the' .private (localP tokens)
      (type (Projection Text))
      (when tokens
        (stack#partial {#Name _ ["" local]} tokens')
        {#Some [tokens' local]}

        _
        {#None}))

(the' .private (nameP tokens)
      (type (Projection Name))
      (when tokens
        (stack#partial {#Name _ it} tokens')
        {#Some [tokens' it]}

        _
        {#None}))

(with_template [<projection> <item_type> <item_of>]
  [(the' .private (<projection> tokens)
         (type (-> (Stack Code)
                   (Maybe (Stack <item_type>))))
         (when tokens
           {#Empty}
           {#Some {#Empty}}

           _
           (do maybe#monad
             [% (<item_of> tokens)
              .let [[tokens head] %]
              tail (<projection> tokens)]
             (in {#Top head tail}))))]

  [parametersP Text localP]
  [enhanced_parametersP Code anyP]
  )

(with_template [<projection> <parameter_type> <parameters_of>]
  [(the' .private (<projection> tokens)
         (type (Projection [Text (Stack <parameter_type>)]))
         (when tokens
           (stack#partial {#Form _ local_declaration} tokens')
           (do maybe#monad
             [% (localP (list#as_stack local_declaration))
              .let [[local_declaration name] %]
              parameters (<parameters_of> local_declaration)]
             (in [tokens' [name parameters]]))
           
           _
           (do maybe#monad
             [% (localP tokens)
              .let [[tokens' name] %]]
             (in [tokens' [name {#Empty}]]))))]

  [local_declarationP Text parametersP]
  [enhanced_local_declarationP Code enhanced_parametersP]
  )

(the' .private (export_policyP tokens)
      (type (Projection Code))
      {.#Some (when tokens
                (stack#partial candidate tokens')
                (when candidate
                  {#Name _ ["" _]}
                  [tokens (` .private)]

                  (^#or {#Bit _ it}
                        {#Name _ it})
                  [tokens' candidate]
                  
                  _
                  [tokens (` .private)])

                _
                [tokens (` .private)])})

(with_template [<projection> <parameter_type> <local>]
  [(the' .private (<projection> tokens)
         (type (Projection [Code Text (Stack <parameter_type>)]))
         (do maybe#monad
           [% (export_policyP tokens)
            .let [[tokens export_policy] %]
            % (<local> tokens)
            .let [[tokens [name parameters]] %]]
           (in [tokens [export_policy name parameters]])))]

  [declarationP Text local_declarationP]
  [enhanced_declarationP Code enhanced_local_declarationP]
  )

(the' .private (bodyP tokens)
      (type (Projection [(Maybe Code) Code]))
      (when tokens
        ... TB
        (stack#partial type body tokens')
        {#Some [tokens' [{#Some type} body]]}

        ... B
        (stack#partial body tokens')
        {#Some [tokens' [{#None} body]]}

        _
        {#None}))

(the' .private (definitionP tokens)
      (type (-> (Stack Code)
                (Maybe [Code
                        Text
                        (Stack Code)
                        (Maybe Code)
                        Code])))
      (do maybe#monad
        [% (enhanced_declarationP tokens)
         .let [[tokens [export_policy name parameters]] %]
         % (bodyP tokens)
         .let [[tokens [?type body]] %]
         _ (endP tokens)]
        (in [export_policy name parameters ?type body])))

... https://en.wikipedia.org/wiki/List_of_English_determiners
(the' .public the
      Macro
      (macro (_ tokens)
        (when (definitionP (list#as_stack tokens))
          {#Some [export_policy name parameters ?type body]}
          (let [body (when parameters
                       {#Empty}
                       body

                       _
                       (` (function ((, (..code#local name)) (,* (list#of_stack parameters)))
                            (, body))))
                body (when ?type
                       {#Some type}
                       (` (is (, type)
                              (, body)))
                       
                       {#None}
                       body)]
            (meta#in (list (` (.def# (, (..code#local name))
                                     (, body)
                                     (, export_policy))))))
          
          {#None}
          (failure ..wrong_syntax))))

(with_template [<name> <nullary> <form>]
  [(the .public <name>
     (macro (_ tokens)
       (meta#in (list (when (stack#reversed (list#as_stack tokens))
                        (stack#partial last init)
                        (stack#mix (is (-> Code Code Code)
                                       (function (_ pre post) (` <form>)))
                                   last
                                   init)
                        
                        _
                        (` <nullary>))))))]

  [and #1 (if (, pre) (, post) #0)]
  [or  #0 (if (, pre) #1 (, post))]
  )

(the (index part text)
  (-> Text Text
      (Maybe Natural))
  (.text_index# 0 part text))

... https://en.wikipedia.org/wiki/Halting_problem
(the .public (halt! message)
  (-> Text
      Nothing)
  (.error# message))

(the maybe#else
  (macro (_ tokens)
    (when tokens
      (list else maybe)
      (do meta#monad
        ['temp (..generated_name "'temp")]
        (in (list (` (when (, maybe)
                       {.#Some (, 'temp)}
                       (, 'temp)

                       {.#None}
                       (, else))))))

      _
      (failure ..wrong_syntax))))

(the (text#all_split_by splitter input)
  (-> Text Text
      (Stack Text))
  (when (..index splitter input)
    {#None}
    (stack input)

    {#Some idx}
    (stack#partial (.text_clip# 0 idx input)
                   (text#all_split_by splitter
                                      (let [after_offset (.i64_+# 1 idx)
                                            after_length (.i64_-# after_offset
                                                                  (.text_size# input))]
                                        (.text_clip# after_offset after_length input))))))

(the (item idx xs)
  (for_any (_ it)
    (-> Natural (Stack it)
        (Maybe it)))
  (when xs
    {#Empty}
    {#None}

    {#Top x xs'}
    (if (.i64_=# 0 idx)
        {#Some x}
        (item (.i64_-# 1 idx) xs'))))

... https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B2-reduction
(the (reduced env type)
  (-> (Stack Type) Type
      Type)
  (when type
    {#Sum left right}
    {#Sum (reduced env left) (reduced env right)}

    {#Product left right}
    {#Product (reduced env left) (reduced env right)}
    
    {#Reification arg func}
    {#Reification (reduced env arg) (reduced env func)}

    {#Universal ?local_env ?local_def}
    (when ?local_env
      {#Empty}
      {#Universal env ?local_def}

      _
      type)

    {#Existential ?local_env ?local_def}
    (when ?local_env
      {#Empty}
      {#Existential env ?local_def}

      _
      type)

    {#Function ?input ?output}
    {#Function (reduced env ?input) (reduced env ?output)}

    {#Parameter idx}
    (when (item idx env)
      {#Some parameter}
      parameter

      _
      type)
    
    {#Named name type}
    (reduced env type)

    _
    type
    ))

(the (applied_type param type_fn)
  (-> Type Type
      (Maybe Type))
  (when type_fn
    {#Universal env body}
    {#Some (reduced (stack#partial type_fn param env) body)}

    {#Existential env body}
    {#Some (reduced (stack#partial type_fn param env) body)}

    {#Reification A F}
    (do maybe#monad
      [type_fn* (applied_type A F)]
      (applied_type param type_fn*))

    {#Named name type}
    (applied_type param type)
    
    _
    {#None}))

(the (interface_methods type)
  (-> Type (Maybe (Stack Type)))
  (when type
    {#Product _}
    {#Some (flat_tuple type)}

    {#Reification arg func}
    (do maybe#monad
      [output (applied_type arg func)]
      (interface_methods output))

    {#Universal _ body}
    (interface_methods body)

    {#Existential _ body}
    (interface_methods body)

    {#Named name type}
    (interface_methods type)

    {#Sum _}
    {#None}
    
    _
    {#Some (stack type)}))

(the (module name)
  (-> Text
      (Meta Module))
  (function (_ state)
    (let [[..#info info ..#source    source  ..#current_module _ ..#modules modules
           ..#scopes scopes ..#type_context types ..#seed seed
           ..#expected  expected ..#provenance  provenance ..#eval _eval] state]
      (when (property#value name modules)
        {#Some module}
        {#Right state module}

        _
        {#Left (.text_composite# "Unknown module: " name)}))))

(the (type_slot [module name])
  (-> Name
      (Meta [Bit Label]))
  (do meta#monad
    [=module (..module module)
     .let [[..#module_hash _
            ..#module_aliases _
            ..#definitions definitions
            ..#imports _
            ..#module_state _] =module]]
    (when (property#value name definitions)
      {#Some [exported {#Definition [type value]}]}
      (meta#in [exported (as Label value)])

      _
      (failure (.text_composite# "Unknown slot: " (name#as [module name]))))))

(the (slot_family expected_module expected_record)
  (-> Text Type
      (Meta (Maybe (Stack Name))))
  (do meta#monad
    [module (..module expected_module)
     actual_module ..current_module_name
     .let [[..#module_hash _
            ..#module_aliases _
            ..#definitions definitions
            ..#imports _
            ..#module_state _] module]]
    (in ((is (-> (Stack [Text [Bit Global]])
                 (Maybe (Stack Name)))
             (function (again remaining)
               (when remaining
                 {#Top [slot head] tail}
                 (when head
                   [exported? {#Definition [type value]}]
                   (if (and (type#= Slot type)
                            (or exported?
                                (text#= expected_module actual_module)))
                       (let [[label actual_record] (as Label value)]
                         (if (type#= expected_record actual_record)
                             (when label
                               {#Some [lefts right? family]}
                               {#Some family}
                               
                               {#None}
                               {#Some (stack [expected_module slot])})
                             (again tail)))
                       (again tail))

                   _
                   (again tail))

                 {#Empty}
                 {#None})))
         (list#as_stack definitions)))))

(the (record_slots type)
  (-> Type
      (Meta (Maybe [(Stack Name) (Stack Type)])))
  (when type
    {#Reification arg func}
    (record_slots func)

    {#Universal env body}
    (record_slots body)

    {#Existential env body}
    (record_slots body)

    {#Named [module name] unnamed}
    (do meta#monad
      [=module (..module module)
       .let [[..#module_hash _
              ..#module_aliases _
              ..#definitions definitions
              ..#imports _
              ..#module_state _] =module]]
      (when (property#value name definitions)
        {#Some [exported? {#Definition [type value]}]}
        (if (type#= Type type)
            (do meta#monad
              [slots (slot_family module (as Type value))]
              (when [slots (interface_methods (as Type value))]
                [{#Some slots} {#Some members}]
                (in {#Some [slots members]})

                _
                (record_slots unnamed)))
            (in {#None}))

        _
        (record_slots unnamed)))
    
    _
    (meta#in {#None})))

(the expected_type
  (Meta Type)
  (function (_ state)
    (let [[..#info info ..#source    source  ..#current_module _ ..#modules modules
           ..#scopes scopes ..#type_context types ..#seed seed
           ..#expected  expected ..#provenance  provenance ..#eval _eval] state]
      (when expected
        {#Some type}
        {#Right state type}

        {#None}
        {#Left "Not expecting any type."}))))

(the \n
  Text
  (.int_char# +10))

(the (provenance#as it)
  (-> Provenance
      Text)
  (let [... https://en.wikipedia.org/wiki/Delimiter
        delimiter ","
        [file line column] it]
    (.text_composite# "@"
                      (text#as file) delimiter
                      (natural#as line) delimiter
                      (natural#as column))))

(the (provenance#with provenance error)
  (-> Provenance Text
      Text)
  (.text_composite# (provenance#as provenance) \n
                    error))

(the provenance#here
  (macro (_ tokens compiler)
    (when tokens
      (list)
      (let [[..#info _
             ..#source _
             ..#current_module _
             ..#modules _
             ..#scopes _
             ..#type_context _
             ..#seed _
             ..#expected _
             ..#provenance provenance
             ..#eval _] compiler
             [.#module module .#line line .#column column] provenance]
        {.#Right [compiler
                  (list (` (.is .Provenance
                                [.#module (, {.#Text ..provenance#dummy module})
                                 .#line (, {.#Natural ..provenance#dummy line})
                                 .#column (, {.#Natural ..provenance#dummy column})])))]})

      _
      {.#Left ..wrong_syntax})))

(the .public invalid_implementation_member
  Error
  (provenance#with (provenance#here)
                   "Invalid implementation member."))

(the .public implementation
  (macro (_ tokens)
    (do meta#monad
      [tokens' (monad#each#meta complete_expansion (list#as_stack tokens))
       implementation_type ..expected_type
       tags+type (record_slots implementation_type)
       tags (is (Meta (Stack Name))
                (when tags+type
                  {#Some [tags _]}
                  (meta#in tags)

                  _
                  (failure (.text_composite# "No tags available for type: "
                                             (type#as implementation_type)))))
       .let [tag_mappings (is (Property_List Code)
                              (list#each (function (_ tag)
                                           [(product#right tag)
                                            (code#name tag)])
                                         (list#of_stack tags)))]
       members (monad#each#meta (is (-> Code (Meta (Stack Code)))
                                    (function (_ token)
                                      (when token
                                        {#Form _ (list {#Name _ [..prelude "def#"]}
                                                       {#Name _ ["" slot_name]}
                                                       value
                                                       export_policy)}
                                        (when (property#value slot_name tag_mappings)
                                          {#Some tag}
                                          (in (stack tag value))

                                          _
                                          (failure (.text_composite# "Unknown implementation member: " slot_name)))

                                        _
                                        (failure ..invalid_implementation_member))))
                                (stack#conjoint (stack#each list#as_stack tokens')))]
      (in (list (code#tuple (list#of_stack (stack#conjoint members))))))))

(the (text#interposed delimiter parts)
  (-> Text (Stack Text)
      Text)
  (when parts
    {#Empty}
    ""
    
    {#Top head tail}
    (stack#mix (function (_ right left)
                 (.text_composite# left delimiter right))
               head
               tail)))

(the (everyP itP tokens)
  (for_any (_ it)
    (-> (-> (Stack Code) (Maybe [(Stack Code) it]))
        (-> (Stack Code) (Maybe (Stack it)))))
  (when tokens
    {#Top _}
    (do maybe#monad
      [% (itP tokens)
       .let [[tokens' head] %]
       tail (when tokens'
              {#Top _}
              (everyP itP tokens')

              {#Empty}
              (in (stack)))]
      (in (stack#partial head tail)))

    {#Empty}
    {#Some (stack)}))

(the (whenP tokens)
  (-> (Stack Code)
      (Maybe [(Stack Code) [Text Code]]))
  (when tokens
    (stack#partial {#Variant _ it}
                   tokens')
    (when (list#as_stack it)
      (stack {#Name _ ["" niladic]})
      {#Some [tokens' [niladic (` .Any)]]}

      (stack#partial {#Name _ ["" polyadic]}
                     whenT)
      {#Some [tokens' [polyadic (` (..Tuple (,* (list#of_stack whenT))))]]}

      else
      {#None})

    _
    {#None}))

(the .public Variant
  (macro (_ tokens)
    (when (everyP whenP (list#as_stack tokens))
      {#Some whens}
      (meta#in (list (` (..Union (,* (list#of_stack (stack#each product#right whens)))))
                     (code#variant (list#of_stack (stack#each (function (_ when)
                                                                (code#text (product#left when)))
                                                              whens)))))
      
      {#None}
      (failure ..wrong_syntax))))

(the (slotP tokens)
  (-> (Stack Code)
      (Maybe [(Stack Code) [Text Code]]))
  (when tokens
    (stack#partial {#Name _ ["" slot]} type tokens')
    {#Some [tokens' [slot type]]}

    _
    {#None}))

(the .public Record
  (macro (_ tokens)
    (when tokens
      (list {#Tuple _ record})
      (when (everyP slotP (list#as_stack record))
        {#Some slots}
        (meta#in (list (` (..Tuple (,* (list#of_stack (stack#each product#right slots)))))
                       (code#tuple (list#of_stack (stack#each (function (_ slot)
                                                                (code#text (product#left slot)))
                                                              slots)))))
        
        {#None}
        (failure ..wrong_syntax))

      _
      (failure ..wrong_syntax))))

(the (typeP tokens)
  (-> (Stack Code)
      (Maybe [Code Text (Stack Text) Code]))
  (do maybe#monad
    [% (declarationP tokens)
     .let [[tokens [export_policy name parameters]] %]
     % (anyP tokens)
     .let [[tokens definition] %]
     _ (endP tokens)]
    (in [export_policy name parameters definition])))

(the (textP tokens)
  (-> (Stack Code)
      (Maybe [(Stack Code) Text]))
  (when tokens
    (stack#partial {#Text _ it} tokens')
    {#Some [tokens' it]}

    _
    {#None}))

(the .public improper_type_definition
  Error
  (provenance#with (provenance#here)
                   "Improper type definition syntax."))

(the (type_declaration it)
  (-> Code
      (Meta [Code (Maybe (Either (Stack Text) (Stack Text)))]))
  (when it
    {#Form _ declarer,parameters}
    (when (list#as_stack declarer,parameters)
      {#Top {#Name _ declarer} parameters}
      (do meta#monad
        [declaration (single_expansion (code#form (list#of_stack (stack#partial (code#name declarer) parameters))))]
        (when declaration
          (list type {#Variant _ tags})
          (when (everyP textP (list#as_stack tags))
            {#Some tags}
            (meta#in [type {#Some {#Left tags}}])
            
            {#None}
            (failure ..improper_type_definition))

          (list type {#Tuple _ slots})
          (when (everyP textP (list#as_stack slots))
            {#Some slots}
            (meta#in [type {#Some {#Right slots}}])
            
            {#None}
            (failure ..improper_type_definition))

          (list type)
          (meta#in [it {#None}])

          _
          (failure ..improper_type_definition)))

      else
      (meta#in [it {#None}]))

    type
    (meta#in [type {#None}])))

(the (enumeration' idx xs)
  (for_any (_ it)
    (-> Natural (Stack it)
        (Stack [Natural it])))
  (when xs
    {#Top x xs'}
    {#Top [idx x] (enumeration' (.i64_+# 1 idx) xs')}

    {#Empty}
    {#Empty}))

(the (enumeration xs)
  (for_any (_ it)
    (-> (Stack it)
        (Stack [Natural it])))
  (enumeration' 0 xs))

(the (label_definitions module export_policy associated_type label_type family labels)
  (-> Text Code Code Code Code (Stack Text)
      (Stack Code))
  (when (stack#reversed labels)
    (stack single)
    (stack (` (the (, export_policy) (, (code#local single))
                (<| (as (, label_type))
                    (is Label)
                    [{#None} (, associated_type)]))))

    (stack#partial right lefts)
    (stack#partial
     (` (the (, family)
          (Stack Name)
          (stack (,* (list#of_stack (stack#each (function (_ it)
                                                  (` [(, (code#text module)) (, (code#text it))]))
                                                labels))))))
     (` (the (, export_policy) (, (code#local right))
          (<| (as (, label_type))
              (is Label)
              [{#Some [(, (code#natural (.i64_-# 1 (stack#size lefts)))) #1 (, family)]} (, associated_type)])))
     (stack#each (function (_ [lefts it])
                   (` (the (, export_policy) (, (code#local it))
                        (<| (as (, label_type))
                            (is Label)
                            [{#Some [(, (code#natural lefts)) #0 (, family)]} (, associated_type)]))))
                 (enumeration (stack#reversed lefts))))

    _
    (stack)))

... https://en.wikipedia.org/wiki/List_of_English_determiners
(the .public every
  (macro (_ tokens)
    (when (typeP (list#as_stack tokens))
      {#Some [export_policy name args type_codes]}
      (do meta#monad
        [type+labels?? (..type_declaration type_codes)
         module_name current_module_name
         'cohort (..generated_name "'cohort")
         .let [type_name (code#local name)
               [it labels??] type+labels??
               it' (is (Maybe Code)
                       (when args
                         {#Empty}
                         {#Some it}

                         _
                         {#Some (` (.for_any ((, type_name) (,* (list#of_stack (stack#each code#local args))))
                                     (, it)))}))]]
        (when it'
          {#Some it''}
          (do meta#monad
            [it'' (type' it'')
             .let [itC (` {.#Named [(, (code#text module_name))
                                    (, (code#text name))]
                                   (, it'')})
                   type_definition (` (the (, export_policy) (, type_name)
                                        Type
                                        (, itC)))]]
            (in (when labels??
                  {#Some labels}
                  (list#of_stack (stack#partial type_definition
                                                (when labels
                                                  {#Left tags}
                                                  (label_definitions module_name export_policy type_name (` Tag) 'cohort tags)
                                                  
                                                  {#Right slots}
                                                  (label_definitions module_name export_policy type_name (` Slot) 'cohort slots))))
                  
                  _
                  (list type_definition))))

          {#None}
          (failure ..wrong_syntax)))

      {#None}
      (failure ..wrong_syntax))))

(every Referral
  [Name (Stack Code)])

(every Importation
  (Record
   [#import_name Text
    #import_alias (Maybe Text)
    #import_referrals (Stack Referral)]))

(the referral_of
  (Projection Referral)
  (formP (andP nameP (someP anyP))))

(the (referrals_of aliased?)
  (-> Bit
      (Projection (Stack Referral)))
  (all eitherP
       (manyP referral_of)
       (afterP endP
               (inP (if aliased?
                        (stack [(name ..only) (stack)])
                        (stack))))
       (inP (stack))))

(the (text#split_at' at x)
  (-> Natural Text
      [Text Text])
  [(.text_clip# 0 at x)
   (.text_clip# at (|> x .text_size# (.i64_-# at)) x)])

(the (text#split_by token it)
  (-> Text Text
      (Maybe [Text Text]))
  (do ..maybe#monad
    [index (..index token it)
     .let [[pre post'] (text#split_at' index it)
           [_ post] (text#split_at' (.text_size# token) post')]]
    (in [pre post])))

(the (replaced pattern replacement template)
  (-> Text Text Text
      Text)
  ((is (-> Text Text Text)
       (function (again left right)
         (when (..text#split_by pattern right)
           {#Some [pre post]}
           (again (.text_composite# left pre replacement) post)

           {#None}
           (.text_composite# left right))))
   "" template))

(the (alias_stand_in index)
  (-> Natural
      Text)
  (.text_composite# "[" (natural#as index) "]"))

(the (module_alias context aliased)
  (-> (Stack Text) Text
      Text)
  (product#right
   (stack#mix (function (_ replacement [index aliased])
                [(.i64_+# 1 index)
                 (replaced (alias_stand_in index) replacement aliased)])
              [0 aliased]
              context)))

... https://en.wikipedia.org/wiki/Delimiter
(the .public module_delimiter
  "/")

(the parallel_hierarchy_sigil
  "\")

(the (normal_parallel_path' hierarchy root)
  (-> Text Text
      Text)
  (when [(text#split_by ..module_delimiter hierarchy)
         (text#split_by ..parallel_hierarchy_sigil root)]
    [{#Some [_ hierarchy']}
     {#Some ["" root']}]
    (normal_parallel_path' hierarchy' root')

    _
    (when root
      "" hierarchy
      _ (.text_composite# root ..module_delimiter hierarchy))))

(the (normal_parallel_path hierarchy root)
  (-> Text Text
      (Maybe Text))
  (when (text#split_by ..parallel_hierarchy_sigil root)
    {#Some ["" root']}
    {#Some (normal_parallel_path' hierarchy root')}

    _
    {#None}))

(the (relative_ups relatives input)
  (-> Natural Text
      Natural)
  (when (.text_index# relatives ..module_delimiter input)
    {#None}
    relatives

    {#Some found}
    (if (.i64_=# relatives found)
        (relative_ups (.i64_+# 1 relatives) input)
        relatives)))

(the (stack#after amount stack)
  (for_any (_ it)
    (-> Natural (Stack it)
        (Stack it)))
  (when [amount stack]
    (^#or [0 _]
          [_ {#Empty}])
    stack

    [_ {#Top _ tail}]
    (stack#after (.i64_-# 1 amount) tail)))

(the (absolute_module_name nested? relative_root module)
  (-> Bit Text Text
      (Meta Text))
  (when (relative_ups 0 module)
    0
    (meta#in (if nested?
                 (.text_composite# relative_root ..module_delimiter module)
                 module))
    
    relatives
    (let [parts (text#all_split_by ..module_delimiter relative_root)
          jumps (.i64_-# 1 relatives)]
      (if (n#< (stack#size parts) jumps)
          (let [prefix (|> parts
                           stack#reversed
                           (stack#after jumps)
                           stack#reversed
                           (text#interposed ..module_delimiter))
                clean (.text_clip# relatives (|> module .text_size# (.i64_-# relatives)) module)
                output (when (.text_size# clean)
                         0 prefix
                         _ (.text_composite# prefix ..module_delimiter clean))]
            (meta#in output))
          (failure (.text_composite# "Cannot climb the module hierarchy..." \n
                                     "Importing module: " module \n
                                     "   Relative Root: " relative_root \n))))))

(the (imports_of nested? relative_root context imports)
  (-> Bit Text (Stack Text) (Stack Code)
      (Meta (Stack Importation)))
  (do meta#monad
    [imports' (monad#each#meta (is (-> Code (Meta (Stack Importation)))
                                   (function (_ token)
                                     (when token
                                       ... Nested
                                       {#Tuple _ token}
                                       (when (list#as_stack token)
                                         (stack#partial {#Name _ ["" module_name]}
                                                        extra)
                                         (do meta#monad
                                           [absolute_module_name (when (normal_parallel_path relative_root module_name)
                                                                   {#Some parallel_path}
                                                                   (in parallel_path)

                                                                   {#None}
                                                                   (..absolute_module_name nested? relative_root module_name))
                                            extra,referral (when (referrals_of #0 extra)
                                                             {#Some extra,referral}
                                                             (in extra,referral)

                                                             {#None}
                                                             (failure ""))
                                            .let [[extra referral] extra,referral]
                                            sub_imports (imports_of #1 absolute_module_name context extra)]
                                           (in (when referral
                                                 {#Empty}
                                                 sub_imports
                                                 
                                                 _
                                                 (stack#partial [#import_name absolute_module_name
                                                                 #import_alias {#None}
                                                                 #import_referrals referral]
                                                                sub_imports))))

                                         (stack#partial {#Text _ alias}
                                                        {#Name _ ["" module_name]}
                                                        extra)
                                         (do meta#monad
                                           [absolute_module_name (when (normal_parallel_path relative_root module_name)
                                                                   {#Some parallel_path}
                                                                   (in parallel_path)

                                                                   {#None}
                                                                   (..absolute_module_name nested? relative_root module_name))
                                            extra,referral (when (referrals_of #1 extra)
                                                             {#Some extra,referral}
                                                             (in extra,referral)

                                                             {#None}
                                                             (failure ""))
                                            .let [[extra referral] extra,referral]
                                            .let [module_alias (..module_alias {#Top module_name context} alias)]
                                            sub_imports (imports_of #1 absolute_module_name {#Top module_alias context} extra)]
                                           (in (when referral
                                                 {#Empty}
                                                 sub_imports
                                                 
                                                 _
                                                 (stack#partial [#import_name absolute_module_name
                                                                 #import_alias {#Some module_alias}
                                                                 #import_referrals referral]
                                                                sub_imports))))

                                         else
                                         (failure ..wrong_syntax))

                                       ... Unrecognized syntax.
                                       else
                                       (failure ..wrong_syntax))))
                               imports)]
    (in (stack#conjoint imports'))))

(the (exported_definitions module state)
  (-> Text
      (Meta (Stack Text)))
  (let [[current_module modules] (when state
                                   [..#info info ..#source    source  ..#current_module current_module ..#modules modules
                                    ..#scopes scopes ..#type_context types ..#seed seed
                                    ..#expected  expected ..#provenance  provenance ..#eval _eval]
                                   [current_module modules])]
    (when (property#value module modules)
      {#Some =module}
      (let [to_alias (stack#each (is (-> [Text [Bit Global]]
                                         (Stack Text))
                                     (function (_ [name [exported? definition]])
                                       (when definition
                                         {#Alias _}
                                         (if exported?
                                             (stack name)
                                             (stack))

                                         {#Definition [def_type def_value]}
                                         (if exported?
                                             (stack name)
                                             (stack))

                                         {#Default _}
                                         (stack))))
                                 (let [[..#module_hash _ ..#module_aliases _ ..#definitions definitions ..#imports _ ..#module_state _] =module]
                                   (list#as_stack definitions)))]
        {#Right state (stack#conjoint to_alias)})
      
      {#None}
      {#Left (.text_composite# "Unknown module: " (text#as module) \n
                               "Current module: " (when current_module
                                                    {#Some current_module}
                                                    (text#as current_module)

                                                    {#None}
                                                    "???") \n
                                                    "Known modules: " (|> modules
                                                                          (list#each (function (_ [name module])
                                                                                       (code#text name)))
                                                                          code#tuple
                                                                          code#as))})
    ))

(the (stack#only p xs)
  (for_any (_ it)
    (-> (-> it Bit) (Stack it)
        (Stack it)))
  (when xs
    {#Empty}
    (stack)

    {#Top x xs'}
    (if (p x)
        {#Top x (stack#only p xs')}
        (stack#only p xs'))))

(the (is_member? whens name)
  (-> (Stack Text) Text
      Bit)
  (let [output (stack#mix (function (_ when prev)
                            (or prev
                                (text#= when name)))
                          #0
                          whens)]
    output))

(the (test_referrals current_module imported_module all_defs referred_defs)
  (-> Text Text (Stack Text) (Stack Text)
      (Meta (Stack Any)))
  (monad#each#meta (is (-> Text (Meta Any))
                       (function (_ _def)
                         (if (is_member? all_defs _def)
                             (meta#in [])
                             (failure (.text_composite# _def " is not defined in module " imported_module " @ " current_module)))))
                   referred_defs))

(the (alias_definition imported_module def)
  (-> Text Text
      Code)
  (` (.def# (, (code#local def))
            (, (code#name [imported_module def]))
            .private)))

(the .public only
  (macro (_ tokens)
    (when (..parsed (all ..andP
                         ..textP
                         ..textP
                         ..textP
                         (..someP ..localP))
                    (list#as_stack tokens))
      {.#Some [current_module imported_module import_alias actual]}
      (do meta#monad
        [expected (exported_definitions imported_module)
         _ (test_referrals current_module imported_module expected actual)]
        (in (list#of_stack (stack#each (..alias_definition imported_module) actual))))

      {.#None}
      (failure ..wrong_syntax))))

(the .public |>>
  (macro (_ tokens)
    (do meta#monad
      ['_ (..generated_name "_")
       'arg (..generated_name "arg")]
      (meta#in (list (` (function ((, '_) (, 'arg))
                          (|> (, 'arg)
                              (,* tokens)))))))))

(the .public <<|
  (macro (_ tokens)
    (do meta#monad
      ['_ (..generated_name "_")
       'arg (..generated_name "arg")]
      (meta#in (list (` (function ((, '_) (, 'arg))
                          (<| (,* tokens)
                              (, 'arg)))))))))

(the .public except
  (macro (_ tokens)
    (when (..parsed (all ..andP
                         ..textP
                         ..textP
                         ..textP
                         (..someP ..localP))
                    (list#as_stack tokens))
      {.#Some [current_module imported_module import_alias actual]}
      (do meta#monad
        [expected (exported_definitions imported_module)
         _ (test_referrals current_module imported_module expected actual)]
        (in (|> expected
                (..stack#only (|>> (is_member? actual) not))
                (stack#each (..alias_definition imported_module))
                list#of_stack)))

      {.#None}
      (failure ..wrong_syntax))))

(the (definition_type name state)
  (-> Name Lux
      (Maybe Type))
  (let [[expected_module expected_proper] name
        [..#info info ..#source    source  ..#current_module _ ..#modules modules
         ..#scopes scopes ..#type_context types ..#seed seed
         ..#expected  expected ..#provenance  provenance ..#eval _eval] state]
    (when (property#value expected_module modules)
      {#None}
      {#None}

      {#Some [..#definitions definitions
              ..#module_hash _
              ..#module_aliases _
              ..#imports _
              ..#module_state _]}
      (when (property#value expected_proper definitions)
        {#None}
        {#None}

        {#Some [exported? definition]}
        (when definition
          {#Alias real_name}
          (definition_type real_name state)
          
          {#Definition [def_type def_value]}
          {#Some def_type}

          {#Default _}
          {#None})))))

(the (type_variable expected context)
  (-> Natural (List [Natural (Maybe Type)])
      (Maybe Type))
  (let [limit (.list_size# context)]
    ((is (-> Natural
             (Maybe Type))
         (function (type_variable item)
           (if (.int_<# (.as# Integer limit)
                        (.as# Integer item))
               (let [[actual bound] (.list_item# item context)]
                 (if (.i64_=# expected actual)
                     bound
                     (type_variable (.i64_+# 1 item))))
               {.#None})))
     0)))

(every .public (Change it)
  (-> it
      it))

(the (clean_type variables it)
  (-> (List [Natural (Maybe Type)])
      (Change Type))
  (when it
    {#Nominal name parameters}
    {#Nominal name (stack#each (clean_type variables) parameters)}
    
    {#Sum left right}
    {#Sum (clean_type variables left)
          (clean_type variables right)}

    {#Product left right}
    {#Product (clean_type variables left)
              (clean_type variables right)}

    {#Function left right}
    {#Function (clean_type variables left)
               (clean_type variables right)}

    {#Reification left right}
    {#Reification (clean_type variables left)
                  (clean_type variables right)}

    {#Universal environment unquantified}
    {#Universal (stack#each (clean_type variables) environment)
                (clean_type variables unquantified)}
    
    {#Existential environment unquantified}
    {#Existential (stack#each (clean_type variables) environment)
                  (clean_type variables unquantified)}
    
    {#Named name anonymous}
    it

    {#Parameter _}
    it
    
    {#Opaque _}
    it
    
    {#Variable id}
    (when (type_variable id variables)
      {#None}
      it

      {#Some {#Variable _}}
      it

      {#Some it}
      (clean_type variables it))))

(the (type_definition full_name)
  (-> Name
      (Meta Type))
  (do meta#monad
    [.let [[module name] full_name]
     current_module current_module_name]
    (function (_ compiler)
      (let [temp (is (Either Text [Lux Type])
                     (if (text#= "" module)
                         (when (in_env name compiler)
                           {#Some implementation_type}
                           {#Right [compiler implementation_type]}

                           _
                           (when (definition_type [current_module name] compiler)
                             {#Some implementation_type}
                             {#Right [compiler implementation_type]}

                             _
                             {#Left (.text_composite# "Unknown var: " (name#as full_name))}))
                         (when (definition_type full_name compiler)
                           {#Some implementation_type}
                           {#Right [compiler implementation_type]}

                           _
                           {#Left (.text_composite# "Unknown var: " (name#as full_name))})))]
        (when temp
          {#Right [compiler temp]}
          (let [[..#info _ ..#source _ ..#current_module _ ..#modules _
                 ..#scopes _ ..#type_context type_context ..#seed _
                 ..#expected _ ..#provenance _ ..#eval _eval] compiler
                 [..#ex_counter _ ..#var_counter _ ..#var_bindings var_bindings] type_context]
            {#Right [compiler (clean_type var_bindings temp)]})

          _
          temp)))))

(the (stack#all choice items)
  (for_any (_ input output)
    (-> (-> input (Maybe output)) (Stack input)
        (Stack output)))
  (when items
    {#Top head tail}
    (when (choice head)
      {#Some head}
      {#Top head (stack#all choice tail)}
      
      {#None}
      (stack#all choice tail))
    
    {#Empty}
    {#Empty}))

(every Implementation_Interface
  [(Stack Name) (Stack Type)])

(the (open_layer alias [tags members])
  (-> Text Implementation_Interface
      (Meta [Code (Stack [Name Implementation_Interface])]))
  (do meta#monad
    [pattern (monad#each#meta (function (_ [slot slot_type])
                                (do meta#monad
                                  [.let [[_ slot_name] slot
                                         local ["" (..module_alias (stack slot_name) alias)]]
                                   implementation (record_slots slot_type)]
                                  (in [(stack (code#name slot)
                                              (code#name local))
                                       [local implementation]])))
                              (zipped_2 tags members))]
    (in [(|> pattern
             (stack#each product#left)
             stack#conjoint
             list#of_stack
             code#tuple)
         (stack#all (function (_ [_ [sub_binding sub_implementation]])
                      (do maybe#monad
                        [sub_implementation sub_implementation]
                        (in [sub_binding sub_implementation])))
                    pattern)])))

(the (open_layers alias interfaces body)
  (-> Text (Stack Implementation_Interface) Code
      (Meta [Code Code]))
  (do meta#monad
    [layer (monad#each#meta (open_layer alias) interfaces)
     .let [pattern (code#tuple (list#of_stack (stack#each product#left layer)))
           next (|> layer
                    (stack#each product#right)
                    stack#conjoint)]]
    (when next
      {#Empty}
      (in [pattern body])

      _
      (do meta#monad
        [.let [sub_value (code#tuple (list#of_stack (stack#each (|>> product#left code#name) next)))]
         sub_pattern,sub_body (open_layers alias (stack#each product#right next) body)
         .let [[sub_pattern sub_body] sub_pattern,sub_body]]
        (in [pattern (` (when (, sub_value)
                          (, sub_pattern)
                          (, sub_body)))])))))

(the .public open
  (pattern
   (macro (_ tokens)
     (when (list#as_stack tokens)
       (stack#partial {#Form _ (list {#Text _ alias})}
                      body
                      branches)
       (do meta#monad
         ['temp (..generated_name "temp")]
         (in (.list_composite# (list 'temp
                                     (` (..when (, 'temp)
                                          (..open (, 'temp) (, (code#text alias)))
                                          (, body))))
                               (list#of_stack branches))))

       (stack#partial {#Form _ (list {#Name @temp_var name}
                                     {#Text _ alias})}
                      body
                      branches)
       (do meta#monad
         [init_type (type_definition name)
          implementation_evidence (record_slots init_type)]
         (when implementation_evidence
           {#None}
           (failure (.text_composite# "Can only 'open' implementations: " (type#as init_type)))

           {#Some tags,members}
           (do meta#monad
             [pattern,body (open_layers alias (stack tags,members) body)
              .let [[pattern body] pattern,body]]
             (in (.list_composite# (list pattern body)
                                   (list#of_stack branches))))))

       _
       (failure ..wrong_syntax)))))

(every (Try it)
  (Variant
   {#Failure Text}
   {#Success it}))

(the .public cannot_access
  Error
  (provenance#with (provenance#here)
                   "Cannot synthesize access pattern."))

(the (access_pattern '_ 'output lefts right? members)
  (-> Code Code Natural Bit (Stack Type)
      (Try (Stack Code)))
  (when ((is (-> Natural (Stack Type) (Stack Code)
                 (Stack Code))
             (function (again index input output)
               (when input
                 (stack#partial head tail)
                 (if (.i64_=# index (if right?
                                        (.i64_+# 1 lefts)
                                        lefts))
                     (stack#reversed (stack#partial 'output output))
                     (again (.i64_+# 1 index) tail (stack#partial '_ output)))

                 (stack)
                 (stack))))
         0 members (stack))
    (stack)
    {#Failure ..cannot_access}

    pattern
    {#Success pattern}))

(the .public its
  (macro (_ tokens)
    (when tokens
      (list {#Name _ slot'} record)
      (do meta#monad
        [slot (normal slot')
         output (..type_slot slot)
         .let [[exported? [label' type]] output]]
        (when label'
          {.#None}
          (in (list record))
          
          {.#Some [lefts right? family]}
          (do meta#monad
            ['_ (..generated_name "_")
             'output (..generated_name "")
             .let [idx (if right?
                           (is Natural (.i64_+# 1 lefts))
                           lefts)
                   pattern (|> (enumeration family)
                               (stack#each (is (-> [Natural Name] (Stack Code))
                                               (function (_ [r_idx slot])
                                                 (stack (code#name slot)
                                                        (if (.i64_=# idx r_idx)
                                                            'output
                                                            '_)))))
                               stack#conjoint)]]
            (in (list (` (..when (, record) [(,* (list#of_stack pattern))] (, 'output))))))))

      (list {#Tuple _ slots} record)
      (meta#in (list (stack#mix (is (-> Code Code Code)
                                    (function (_ slot inner)
                                      (` (..its (, slot) (, inner)))))
                                record
                                (list#as_stack slots))))

      (list selector)
      (do meta#monad
        ['_ (..generated_name "_")
         'record (..generated_name "record")]
        (in (list (` (function ((, '_) (, 'record)) (..its (, selector) (, 'record)))))))
      
      _
      (failure ..wrong_syntax))))

(the (open_declaration imported_module alias tags my_tag_index [module proper] source type)
  (-> Text Text (Stack Name) Natural Name Code Type
      (Meta (Stack Code)))
  (do meta#monad
    [output (record_slots type)
     '_ (..generated_name "'_")
     .let ['output (code#local proper)
           pattern (|> tags
                       enumeration
                       (stack#each (function (_ [tag_idx tag])
                                     (if (.i64_=# my_tag_index tag_idx)
                                         'output
                                         '_)))
                       list#of_stack
                       code#tuple)
           source+ (` (..when (, source) (, pattern) (, 'output)))]]
    (when output
      {#Some [tags' members']}
      (do meta#monad
        [decls' (monad#each#meta (is (-> [Natural Name Type] (Meta (Stack Code)))
                                     (function (_ [sub_tag_index sname stype])
                                       (open_declaration imported_module alias tags' sub_tag_index sname source+ stype)))
                                 (enumeration (zipped_2 tags' members')))]
        (in (stack#conjoint decls')))

      _
      (in (stack (` (.def# (, (code#local (..module_alias (stack proper imported_module) alias)))
                           (, source+)
                           #0)))))))

(the (implementation_declarations imported_module alias implementation)
  (-> Text Text Name
      (Meta (Stack Code)))
  (do meta#monad
    [interface (type_definition implementation)
     output (record_slots interface)]
    (when output
      {#Some [slots terms]}
      (do meta#monad
        [.let ['implementation (code#name implementation)]
         declarations (monad#each#meta (is (-> [Natural Name Type] (Meta (Stack Code)))
                                           (function (_ [index slot_label slot_type])
                                             (open_declaration imported_module alias slots index slot_label 'implementation slot_type)))
                                       (enumeration (zipped_2 slots terms)))]
        (in (stack#conjoint declarations)))

      _
      (failure (.text_composite# "Can only 'use' implementations: " (name#as implementation)
                                 " : " (type#as interface))))))

(the (localized module global)
  (-> Text Name
      Name)
  (when global
    ["" local]
    [module local]

    _
    global))

(the .public use
  (macro (_ tokens)
    (when (..parsed (all ..andP
                         (..maybeP (all ..andP
                                        ..textP
                                        ..textP
                                        ..textP))
                         ..textP
                         (..orP (..manyP ..nameP)
                                (..manyP ..anyP)))
                    (list#as_stack tokens))
      {.#Some [current_module,imported_module,import_alias alias implementations]}
      (let [[current_module imported_module import_alias]
            (when current_module,imported_module,import_alias
              {#Some [current_module imported_module import_alias]}
              [current_module imported_module import_alias]
              
              {#None}
              ["" "" ""])]
        (when implementations
          {#Left implementations}
          (do meta#monad
            [declarations (|> implementations
                              (stack#each (localized imported_module))
                              (monad#each#meta (implementation_declarations import_alias alias)))]
            (in (list#of_stack (stack#conjoint declarations))))
          
          {#Right implementations}
          (do meta#monad
            [pre_defs,implementations (is (Meta [(Stack Code) (Stack Code)])
                                          (monad#mix meta#monad
                                                     (function (_ it [pre_defs implementations])
                                                       (when it
                                                         {#Name _ _}
                                                         (in [pre_defs
                                                              {#Top it implementations}])
                                                         
                                                         _
                                                         (do meta#monad
                                                           ['implementation (..generated_name "implementation")]
                                                           (in [{#Top (` (.def# (, 'implementation) (, it) #0)) pre_defs}
                                                                {#Top 'implementation implementations}]))))
                                                     [(stack) (stack)]
                                                     implementations))
             .let [[pre_defs implementations] pre_defs,implementations]]
            (in (|> pre_defs
                    {#Top (` (..use
                              (, (code#text current_module))
                              (, (code#text imported_module))
                              (, (code#text import_alias))
                              (, (code#text alias))
                              (,* (list#of_stack implementations))))}
                    stack#reversed
                    list#of_stack)))))
      

      {.#None}
      (failure ..wrong_syntax))))

(the (imported_by? import_name module_name)
  (-> Text Text
      (Meta Bit))
  (do meta#monad
    [module (module module_name)
     .let [[..#module_hash _ ..#module_aliases _ ..#definitions _ ..#imports imports ..#module_state _] module]]
    (in (is_member? (list#as_stack imports) import_name))))

(the (referrals module_name extra)
  (-> Text (Stack Code)
      (Meta (Stack Referral)))
  (do meta#monad
    [extra,referral (when (referrals_of #0 extra)
                      {#Some extra,referral}
                      (in extra,referral)

                      {#None}
                      (failure ""))
     .let [[extra referral] extra,referral]
     current_module current_module_name]
    (when extra
      {#Empty}
      (in referral)

      _
      (failure (.text_composite# ..wrong_syntax
                                 \n "@ " current_module
                                 \n (|> extra
                                        (stack#each code#as)
                                        (stack#interposed " ")
                                        (stack#mix text#composite "")))))))

(the .public refer
  (macro (_ tokens)
    (when (list#as_stack tokens)
      (stack#partial {#Text _ imported_module}
                     {#Text _ alias}
                     options)
      (do meta#monad
        [referrals (..referrals imported_module options)
         current_module ..current_module_name]
        (in (list#of_stack (stack#each (function (_ [macro parameters])
                                         (` ((, (code#name macro))
                                             (, (code#text current_module))
                                             (, (code#text imported_module))
                                             (, (code#text alias))
                                             (,* (list#of_stack parameters)))))
                                       referrals))))

      _
      (failure ..wrong_syntax))))

(the .public with
  (macro (_ tokens)
    (when (..parsed (..andP ..anyP ..anyP)
                    (list#as_stack tokens))
      {.#Some [implementation expression]}
      (meta#in (list (` (..let [(..open (, (code#text (alias_stand_in 0)))) (, implementation)]
                          (, expression)))))

      {.#None}
      (failure ..wrong_syntax))))

(the .public by
  (macro (_ tokens)
    (when (list#as_stack tokens)
      (stack implementation
             {#Name _ member})
      (meta#in (list (` (..with (, implementation) (, (code#name member))))))

      (stack#partial implementation member args)
      (meta#in (list (` ((..by (, implementation) (, member)) (,* (list#of_stack args))))))
      
      _
      (failure ..wrong_syntax))))

(the .public has
  (macro (_ tokens)
    (when tokens
      (list {#Name _ slot'} value record)
      (do meta#monad
        [slot (normal slot')
         output (..type_slot slot)
         .let [[exported? [label' type]] output]]
        (when label'
          {.#None}
          (in (list value))

          {.#Some [lefts right? family]}
          (do meta#monad
            [pattern' (monad#each#meta (is (-> [Natural Name] (Meta [Name Natural Code]))
                                           (function (_ [r_idx r_slot_name])
                                             (do meta#monad
                                               ['slot (..generated_name "")]
                                               (in [r_slot_name r_idx 'slot]))))
                                       (enumeration family))
             .let [pattern (|> pattern'
                               (stack#each (is (-> [Name Natural Code] (Stack Code))
                                               (function (_ [r_slot_name r_idx r_var])
                                                 (stack (code#name r_slot_name)
                                                        r_var))))
                               stack#conjoint)
                   idx (if right?
                           (is Natural (.i64_+# 1 lefts))
                           lefts)
                   output (|> pattern'
                              (stack#each (is (-> [Name Natural Code] (Stack Code))
                                              (function (_ [r_slot_name r_idx r_var])
                                                (stack (code#name r_slot_name)
                                                       (if (.i64_=# idx r_idx)
                                                           value
                                                           r_var)))))
                              stack#conjoint)]]
            (in (list (` (..when (, record) [(,* (list#of_stack pattern))] [(,* (list#of_stack output))])))))))

      (list {#Tuple _ slots}
            value
            record)
      (when slots
        (list)
        (failure ..wrong_syntax)

        _
        (do meta#monad
          [bindings (monad#each#meta (is (-> Code (Meta Code))
                                         (function (_ _)
                                           (..generated_name "temp")))
                                     (list#as_stack slots))
           .let [pairs (zipped_2 (list#as_stack slots) bindings)
                 update_expr (stack#mix (is (-> [Code Code] Code Code)
                                            (function (_ [s b] v)
                                              (` (..has (, s) (, v) (, b)))))
                                        value
                                        (stack#reversed pairs))
                 [_ accesses'] (stack#mix (is (-> [Code Code] [Code (Stack (Stack Code))] [Code (Stack (Stack Code))])
                                              (function (_ [new_slot new_binding] [old_record accesses'])
                                                [(` (its (, new_slot) (, new_binding)))
                                                 {#Top (stack new_binding old_record) accesses'}]))
                                          [record (is (Stack (Stack Code)) {#Empty})]
                                          pairs)
                 accesses (stack#conjoint (stack#reversed accesses'))]]
          (in (list (` (let [(,* (list#of_stack accesses))]
                         (, update_expr)))))))
      
      (list selector value)
      (do meta#monad
        ['_ (..generated_name "_")
         'record (..generated_name "record")]
        (in (list (` (function ((, '_) (, 'record))
                       (..has (, selector) (, value) (, 'record)))))))

      (list selector)
      (do meta#monad
        ['_ (..generated_name "_")
         'value (..generated_name "value")
         'record (..generated_name "record")]
        (in (list (` (function ((, '_) (, 'value) (, 'record))
                       (..has (, selector) (, 'value) (, 'record)))))))

      _
      (failure ..wrong_syntax))))

(the .public revised
  (macro (_ tokens)
    (when tokens
      (list {#Name _ slot'} fun record)
      (do meta#monad
        [slot (normal slot')
         output (..type_slot slot)
         .let [[exported? [label' type]] output]]
        (when label'
          {.#None}
          (in (list (` ((, fun) (, record)))))

          {.#Some [lefts right? family]}
          (do meta#monad
            [pattern' (monad#each#meta (is (-> [Natural Name] (Meta [Name Natural Code]))
                                           (function (_ [r_idx r_slot_name])
                                             (do meta#monad
                                               ['slot (..generated_name "")]
                                               (in [r_slot_name r_idx 'slot]))))
                                       (enumeration family))
             .let [pattern (|> pattern'
                               (stack#each (is (-> [Name Natural Code] (Stack Code))
                                               (function (_ [r_slot_name r_idx r_var])
                                                 (stack (code#name r_slot_name)
                                                        r_var))))
                               stack#conjoint)
                   idx (if right?
                           (is Natural (.i64_+# 1 lefts))
                           lefts)
                   output (|> pattern'
                              (stack#each (is (-> [Name Natural Code] (Stack Code))
                                              (function (_ [r_slot_name r_idx r_var])
                                                (stack (code#name r_slot_name)
                                                       (if (.i64_=# idx r_idx)
                                                           (` ((, fun) (, r_var)))
                                                           r_var)))))
                              stack#conjoint)]]
            (in (list (` (..when (, record) [(,* (list#of_stack pattern))] [(,* (list#of_stack output))])))))))

      (list {#Tuple _ slots} fun record)
      (when slots
        (list)
        (failure ..wrong_syntax)

        _
        (do meta#monad
          ['record (..generated_name "record")
           'temp (..generated_name "temp")]
          (in (list (` (let [(, 'record) (, record)
                             (, 'temp) (its [(,* slots)] (, 'record))]
                         (has [(,* slots)] ((, fun) (, 'temp)) (, 'record))))))))

      (list selector fun)
      (do meta#monad
        ['_ (..generated_name "_")
         'record (..generated_name "record")]
        (in (list (` (function ((, '_) (, 'record))
                       (..revised (, selector) (, fun) (, 'record)))))))

      (list selector)
      (do meta#monad
        ['_ (..generated_name "_")
         'fun (..generated_name "fun")
         'record (..generated_name "record")]
        (in (list (` (function ((, '_) (, 'fun) (, 'record))
                       (..revised (, selector) (, 'fun) (, 'record)))))))
      
      _
      (failure ..wrong_syntax))))

(the .private with_template#pattern
  (pattern
   (macro (_ tokens)
     (when (list#as_stack tokens)
       (stack#partial {#Form _ (list {#Tuple _ bindings}
                                     {#Tuple _ templates})}
                      {#Form _ data}
                      branches)
       (when (is (Maybe (Stack Code))
                 (do maybe#monad
                   [bindings' (monad#each maybe#monad ..proper_name (list#as_stack bindings))
                    data' (monad#each maybe#monad ..tuple_list (list#as_stack data))]
                   (let [num_bindings (stack#size bindings')]
                     (if (every? (|>> list#size (.i64_=# num_bindings))
                                 data')
                         (let [reification (is (-> Replacement_Environment
                                                   (Stack Code))
                                               (function (_ env)
                                                 (stack#each (realized_template env)
                                                             (list#as_stack templates))))]
                           (|> data'
                               (stack#each (|>> list#as_stack
                                                (replacement_environment bindings')
                                                reification))
                               stack#conjoint
                               in))
                         {#None}))))
         {#Some output}
         (meta#in (list#of_stack (stack#composite output branches)))
         
         {#None}
         (failure ..wrong_syntax))
       
       _
       (failure ..wrong_syntax)))))

(with_template [<name> <extension>]
  [(the .public <name>
     (for_any (_ it)
       (-> (I64 it)
           (I64 it)))
     (|>> (<extension> 1)))]

  [++ .i64_+#]
  [-- .i64_-#]
  )

(the (interleaved xs ys)
  (for_any (_ it)
    (-> (Stack it) (Stack it)
        (Stack it)))
  (when xs
    {#Empty}
    {#Empty}
    
    {#Top x xs'}
    (when ys
      {#Empty}
      {#Empty}
      
      {#Top y ys'}
      (stack#partial x y (interleaved xs' ys')))))

(the (type_code type)
  (-> Type
      Code)
  (when type
    {#Nominal name params}
    (` {.#Nominal (, (code#text name)) (, (untemplated_stack (stack#each type_code params)))})

    (with_template#pattern [<tag>]
      [{<tag> left right}
       (` {<tag> (, (type_code left)) (, (type_code right))})])
    ([.#Sum] [.#Product]
     [.#Function]
     [.#Reification])

    (with_template#pattern [<tag>]
      [{<tag> id}
       (` {<tag> (, (code#natural id))})])
    ([.#Parameter] [.#Variable] [.#Opaque])

    (with_template#pattern [<tag>]
      [{<tag> env type}
       (let [env' (untemplated_stack (stack#each type_code env))]
         (` {<tag> (, env') (, (type_code type))}))])
    ([.#Universal] [.#Existential])
    
    {#Named [module name] anonymous}
    ... TODO: Generate the explicit type definition instead of using
    ... the "code#name" shortcut below.
    ... (` {.#Named [(, (code#text module)) (, (code#text name))]
    ...     (, (type_code anonymous))})
    (code#name [module name])))

(the .public loop
  (macro (_ tokens)
    (let [?params (when tokens
                    (list {#Form _ (list name {#Tuple _ bindings})}
                          body)
                    {#Some [name bindings body]}

                    _
                    {#None})]
      (when ?params
        {#Some [name bindings body]}
        (when (pairs (list#as_stack bindings))
          {#Some pairs}
          (let [vars (stack#each product#left pairs)
                inits (stack#each product#right pairs)]
            (if (every? name? inits)
                (do meta#monad
                  [inits' (is (Meta (Stack Name))
                              (when (monad#each maybe#monad ..full_name inits)
                                {#Some inits'}
                                (meta#in inits')
                                
                                {#None}
                                (failure ..wrong_syntax)))
                   init_types (monad#each#meta type_definition inits')
                   expected ..expected_type]
                  (meta#in (list (` ((.is# (-> (,* (list#of_stack (stack#each type_code init_types)))
                                               (, (type_code expected)))
                                           (function ((, name) (,* (list#of_stack vars)))
                                             (, body)))
                                     (,* (list#of_stack inits)))))))
                (do meta#monad
                  [aliases (monad#each#meta (is (-> Code (Meta Code))
                                                (function (_ _) (..generated_name "")))
                                            inits)]
                  (meta#in (list (` (..let [(,* (list#of_stack (..interleaved aliases inits)))]
                                      (..loop ((, name) [(,* (list#of_stack (..interleaved vars aliases)))])
                                        (, body)))))))))

          {#None}
          (failure ..wrong_syntax))

        {#None}
        (failure ..wrong_syntax)))))

(the expansion#let
  (let [expansion#let' (is (-> Text (List Code) Code
                               (Stack Code))
                           (function (expansion#let' label tokens target)
                             (when target
                               (^#or {#Bit _ _}
                                     {#Natural _ _}
                                     {#Integer _ _}
                                     {#Revolution _ _}
                                     {#Decimal _ _}
                                     {#Text _ _})
                               (stack target)

                               {#Name _ [module name]}
                               (if (and (text#= "" module)
                                        (text#= label name))
                                   (list#as_stack tokens)
                                   (stack target))

                               (with_template#pattern [<tag>]
                                 [{<tag> provenance elems}
                                  (stack (|> elems
                                             list#as_stack
                                             (stack#each (expansion#let' label tokens))
                                             stack#conjoint
                                             list#of_stack
                                             {<tag> provenance}))])
                               ([#Form]
                                [#Variant]
                                [#Tuple]))))]
    (macro (_ tokens)
      (when (parsed (andP (tupleP (someP bindingP)) anyP)
                    (list#as_stack tokens))
        {#Some [bindings body]}
        (loop (again [bindings bindings
                      map (is (Property_Stack (List Code))
                              (stack))])
          (let [normal (is (-> Code (Stack Code))
                           (function (_ it)
                             (stack#mix (function (_ [binding expansion] it)
                                          (stack#conjoint (stack#each (expansion#let' binding expansion) it)))
                                        (stack it)
                                        map)))]
            (when bindings
              {#Top [var_name expr] &rest}
              (do meta#monad
                [expansion (when (normal expr)
                             (stack expr)
                             (single_expansion expr)

                             _
                             (failure (.text_composite# "Incorrect expansion in expansion#let"
                                                        " | Binding: " (text#as var_name)
                                                        " | Expression: " (code#as expr))))]
                (again &rest (property#with var_name expansion map)))
              
              {#Empty}
              (meta#in (list#of_stack (normal body))))))
        
        {#None}
        (failure ..wrong_syntax)))))

(the .public (same? expected actual)
  (for_any (_ it)
    (-> it it
        Bit))
  (.is?# expected actual))

(the .public as_expected
  (macro (_ tokens)
    (when tokens
      (list expr)
      (do meta#monad
        [type ..expected_type]
        (in (list (` (.as# (, (type_code type))
                           (, expr))))))
      
      _
      (failure ..wrong_syntax))))

(the .public undefined
  (let [provenance (is (Meta Provenance)
                       (function (_ compiler)
                         {#Right [compiler (its #provenance compiler)]}))]
    (macro (_ tokens)
      (when tokens
        (list)
        (do meta#monad
          [provenance provenance
           .let [message (.text_composite# "Undefined behavior at " (provenance#as provenance))]]
          (exec
            (.log!# (.text_composite# "WARNING: " message))
            (in (list (` (..halt! (, (code#text message))))))))
        
        _
        (failure ..wrong_syntax)))))

(the .public type_of
  (macro (_ tokens)
    (when tokens
      (list {#Name _ ["" local]})
      (do meta#monad
        [type (type_definition ["" local])]
        (in (list (` (..type ((,' ,) (, (type_code type))))))))

      (list {#Name _ global})
      (do meta#monad
        [type (type_definition global)
         .let [code#name (is (-> Name Code)
                             (function (_ [module name])
                               (code#tuple (list (code#text module)
                                                 (code#text name)))))]]
        (in (list (` (..type ((,' ,) {..#Reification {..#Named (, (code#name global))
                                                               (, (type_code type))}
                                                     {..#Named (, (code#name (name ..type_of)))
                                                               (, (type_code ..Nothing))}}))))))

      (list expression)
      (do meta#monad
        ['temp (..generated_name "'temp")]
        (in (list (` (let [(, 'temp) (, expression)]
                       (..type_of (, 'temp)))))))

      _
      (failure ..wrong_syntax))))

(the (with_replacements reps syntax)
  (-> Replacement_Environment Code
      Code)
  (when syntax
    {#Name _ ["" proper]}
    (when (..replacement proper reps)
      {#Some replacement}
      replacement

      {#None}
      syntax)

    {#Form meta parts}
    {#Form meta (list#of_stack (stack#each (with_replacements reps) (list#as_stack parts)))}

    {#Variant meta members}
    {#Variant meta (list#of_stack (stack#each (with_replacements reps) (list#as_stack members)))}

    {#Tuple meta members}
    {#Tuple meta (list#of_stack (stack#each (with_replacements reps) (list#as_stack members)))}
    
    _
    syntax))

(the template#macro
  (let [templateP (is (-> (Stack Code)
                          (Maybe [Text (Stack Text) (Stack Code)]))
                      (function (_ tokens)
                        (do maybe#monad
                          [% (local_declarationP tokens)
                           .let [[tokens [name parameters]] %]
                           % (tupleP (someP anyP) tokens)
                           .let [[tokens templates] %]
                           _ (endP tokens)]
                          (in [name parameters templates]))))
        simple_replacement_environment (is (-> (Stack Text)
                                               Replacement_Environment)
                                           (stack#each (function (_ arg)
                                                         [arg (` ((,' ,) (, (code#local arg))))])))
        instantiated_template (is (-> Replacement_Environment Code
                                      Code)
                                  (function (_ replacement_environment template)
                                    (` (`' (, (with_replacements replacement_environment
                                                template))))))]
    (macro (_ tokens)
      (when (templateP (list#as_stack tokens))
        {#Some [name args input_templates]}
        (do meta#monad
          ['tokens (..generated_name "tokens")
           'compiler (..generated_name "compiler")
           '_ (..generated_name "_")
           this_module ..current_module_name]
          (in (list (` (..macro ((, (code#local name)) (, 'tokens) (, 'compiler))
                         (when (, 'tokens)
                           (list (,* (list#of_stack (stack#each code#local args))))
                           {.#Right [(, 'compiler)
                                     (list (,* (list#of_stack (stack#each (instantiated_template (simple_replacement_environment args))
                                                                          input_templates))))]}
                           
                           (, '_)
                           {.#Left ..wrong_syntax}))))))

        {#None}
        (failure ..wrong_syntax)))))

(with_template [<name> <to>]
  [(the .public <name>
     (template#macro
      (<name> it)
      [(..|> it
             (..is (..I64 ..Any))
             (..as <to>))]))]

  [i64 ..I64]
  [natural ..Natural]
  [integer ..Integer]
  [revolution ..Revolution]
  )

(the .public these
  (macro (_ tokens compiler)
    {#Right [compiler tokens]}))

(the .public character
  (macro (_ tokens compiler)
    (when tokens
      (list {#Text _ input})
      (if (|> input .text_size# (.i64_=# 1))
          (|> input (.text_char# 0)
              code#natural list
              [compiler] {#Right})
          {#Left ..wrong_syntax})

      _
      {#Left ..wrong_syntax})))

(the (eval type code)
  (-> Type Code
      (Meta Any))
  (do meta#monad
    [eval (function (_ lux)
            {#Right [lux (.as# (.type# "eval")
                               (its #eval lux))]})]
    (eval type code)))

(every .public Target
  Text)

(with_template [<name> <value>]
  [(the .public <name>
     Target
     <value>)]
  
  ... Available.
  [js          "JavaScript"]
  [jvm         "JVM"]
  [lua         "Lua"]
  [python      "Python"]
  [ruby        "Ruby"]
  ... Not available yet.
  [c++         "C++"]
  [common_lisp "Common Lisp"]
  [php         "PHP"]
  [r           "R"]
  )

(the .public for
  (let [target (is (Meta Target)
                   (function (_ compiler)
                     {#Right [compiler (its [#info #target] compiler)]}))
        platform_name (is (-> Code
                              (Meta Target))
                          (function (_ it)
                            (do meta#monad
                              [it (eval Target it)]
                              (in (as Target it)))))
        target_pick (is (-> Text (Stack [Code Code]) (Maybe Code)
                            (Meta (List Code)))
                        (function (target_pick target options default)
                          (when options
                            {#Empty}
                            (when default
                              {#None}
                              (failure (.text_composite# "No code for target platform: " target))

                              {#Some default}
                              (meta#in (list default)))

                            {#Top [key pick] options'}
                            (do meta#monad
                              [platform (platform_name key)]
                              (if (text#= target platform)
                                  (meta#in (list pick))
                                  (target_pick target options' default))))))]
    (macro (_ tokens)
      (when (..parsed (..andP (..someP (..andP ..anyP ..anyP))
                              (..maybeP ..anyP))
                      (list#as_stack tokens))
        {.#Some [options default]}
        (do meta#monad
          [target target]
          (target_pick target options default))

        {.#None}
        (failure ..wrong_syntax)))))

(the .public using
  (let [refer_code (is (-> Text Text (Stack Referral)
                           Code)
                       (function (_ imported_module alias referrals)
                         (` (..refer (, (code#text imported_module))
                                     (, (code#text alias))
                                     (,* (list#of_stack (stack#each (function (_ [macro parameters])
                                                                      (` ((, (code#name macro)) (,* (list#of_stack parameters)))))
                                                                    referrals)))))))]
    (macro (_ _imports)
      (do meta#monad
        [current_module ..current_module_name
         imports (imports_of #0 current_module {#Empty} (list#as_stack _imports))
         .let [referrals (list#each (is (-> Importation
                                            Code)
                                        (function (_ [module_name m_alias =refer])
                                          (refer_code module_name (..maybe#else "" m_alias) =refer)))
                                    (list#of_stack imports))
               importations (list#each (is (-> Importation
                                               Code)
                                           (function (_ [module_name m_alias =refer])
                                             (` [(, (code#text module_name)) (, (code#text (..maybe#else "" m_alias)))])))
                                       (list#of_stack imports))]]
        (in (.list_composite# (list (` (.module# [(,* importations)])))
                              referrals))))))

(every Immediate_UnQuote
  (Nominal "#Macro/Immediate_UnQuote"))

(the immediate_unquote
  (-> Macro
      Immediate_UnQuote)
  (|>> (as Immediate_UnQuote)))

(the immediate_unquote_macro
  (-> Immediate_UnQuote
      Macro')
  (|>> (as Macro')))

(the .public ,,
  (..immediate_unquote
   (macro (_ it)
     (when it
       (list it)
       (meta#in (list it))

       _
       (failure ..wrong_syntax)))))

(the aggregate_embedded_expansions
  (template#macro
   (_ embedded_expansions <@> <tag> <*>)
   [(do meta#monad
      [<*>' (monad#each#meta embedded_expansions <*>)]
      (in [(|> <*>'
               stack#reversed
               (stack#each (|>> product#left list#as_stack))
               (stack#mix stack#composite (stack))
               list#of_stack)
           {<tag> <@> (list#of_stack (stack#each product#right <*>'))}]))]))

(the (embedded_expansions code)
  (-> Code
      (Meta [(List Code) Code]))
  (when code
    {#Form @ original_name,parameters}
    (when (list#as_stack original_name,parameters)
      (stack#partial {#Name @name original_name}
                     parameters)
      (<| (expansion#let [<failure> (aggregate_embedded_expansions embedded_expansions @ #Form (stack#partial {#Name @name original_name} parameters))])
          (do meta#monad
            [resolved_name (..normal original_name)
             ?resolved_name (meta#try (..global_name resolved_name))]
            (when ?resolved_name
              {#Left _}
              <failure>

              {#Right resolved_name}
              (do meta#monad
                [?type,value (meta#try (..definition_value resolved_name))]
                (when ?type,value
                  {#Left _}
                  <failure>

                  {#Right [type value]}
                  (if (type#= ..Immediate_UnQuote type)
                      (do meta#monad
                        [bound ((immediate_unquote_macro (as Immediate_UnQuote value)) (list#of_stack parameters))
                         'expansion (..generated_name "'expansion")]
                        (in [(.list_composite# (list 'expansion) bound)
                             'expansion]))
                      <failure>))))))

      else
      (aggregate_embedded_expansions embedded_expansions @ #Form (list#as_stack original_name,parameters)))

    (with_template#pattern [<tag>]
      [{<tag> @ parts}
       (aggregate_embedded_expansions embedded_expansions @ <tag> (list#as_stack parts))])
    ([#Variant]
     [#Tuple])
    
    _
    (meta#in [(list)
              code])))

(the .public ``
  (macro (_ tokens)
    (when tokens
      (list raw)
      (do meta#monad
        [=raw (..embedded_expansions raw)
         .let [[labels labelled] =raw]]
        ((as Macro' ..expansion#let)
         (list (code#tuple labels)
               labelled)))

      _
      (failure ..wrong_syntax))))

(with_template [<bit> <name>]
  [(the .public <name> Bit <bit>)]

  [#0 false]
  [#1 true]
  )

(the .public try
  (macro (_ tokens)
    (when tokens
      (list expression)
      (do meta#monad
        ['_ (..generated_name "'_")]
        (in (list (` (.try# (.function ((, '_) (, '_))
                              (, expression)))))))

      _
      (..failure ..wrong_syntax))))

(the (methodP tokens)
  (-> (Stack Code)
      (Maybe [(Stack Code) [Text Code]]))
  (when tokens
    (stack#partial {#Form _ (list {#Name _ [..prelude "is#"]}
                                  type
                                  {#Name _ ["" name]})}
                   tokens')
    {#Some [tokens' [name type]]}

    _
    {#None}))

... [Scrap your type classes](https://www.haskellforall.com/2012/05/scrap-your-type-classes.html)
(the .public Interface
  (macro (_ tokens)
    (do meta#monad
      [methods' (monad#each#meta complete_expansion (list#as_stack tokens))]
      (when (everyP methodP (stack#conjoint (stack#each list#as_stack methods')))
        {#Some methods}
        (in (list (` (..Tuple (,* (list#of_stack (stack#each product#right methods)))))
                  (code#tuple (list#of_stack (stack#each (|>> product#left code#text) methods)))))

        {#None}
        (failure ..wrong_syntax)))))

(the .public Rec
  (let [recursive_type (is (-> Code Code Text Code
                               Code)
                           (function (recursive_type 'self 'dummy name body)
                             (` {.#Reification (..Nominal "")
                                               (.for_any ((, 'self) (, 'dummy))
                                                 (, (code#let (code#local name) (` {.#Reification (..Nominal "") (, 'self)})
                                                              body)))})))]
    (macro (_ tokens)
      (when tokens
        (list {#Name _ ["" name]} body)
        (do meta#monad
          [body' (complete_expansion body)
           'self (generated_name "'self")
           'dummy (generated_name "'dummy")]
          (when body'
            (list body' labels)
            (in (list (recursive_type 'self 'dummy name body')
                      labels))

            (list body')
            (in (list (recursive_type 'self 'dummy name body')))

            _
            (failure ..wrong_syntax)))

        _
        (failure ..wrong_syntax)))))

(with_template [<type>]
  [(the .public <type>
     Type
     (let [[_ proper] (name <type>)]
       {#Named [..prelude proper]
               {.#Nominal (.text_composite# "#Extension/" proper) (stack)}}))]

  [Analysis]
  [Synthesis]
  [Translation]
  [Declaration]
  )

(the .public alias
  (macro (_ tokens)
    (when (parsed (andP (tupleP (manyP localP))
                        nameP)
                  (list#as_stack tokens))
      {#Some [alias/+ original]}
      (meta#in (list#of_stack (stack#each (function (_ it)
                                            (` (the .public (, (code#local it))
                                                 (, (code#name original)))))
                                          alias/+)))
      
      {#None}
      (failure ..wrong_syntax))))

(alias [F64 Double]
       ..Decimal)

(alias [alias? identical?]
       ..same?)

(the .public variant
  (macro (_ it)
    (meta#in (list (` {(,* it)})))))

(alias [|]
       ..variant)

(the .public tuple
  (macro (_ it)
    (meta#in (list (` [(,* it)])))))

(alias [& record]
       ..tuple)

(the .public unless
  (template#macro
   (_ ,when ,else ,then)
   [(..if ,when ,then ,else)]))

(alias [for_all for_every]
       ..for_any)

(alias [there_exists]
       ..for_some)

... https://en.wikipedia.org/wiki/Up_tack
(alias [False Falsum]
       ..Nothing)

... https://en.wikipedia.org/wiki/Tee_(symbol)
(alias [True Verum]
       ..Any)

(the .public <-
  (macro (_ parameters)
    (meta#in (list (` (.-> (,* parameters)))))))

... https://en.wikipedia.org/wiki/Number#Classification
(alias [N Nat]
       ..Natural)

(alias [Z Int]
       ..Integer)

(alias [Rev]
       ..Revolution)

(the .public match?
  (macro (_ tokens)
    (when (parsed (andP anyP
                        anyP)
                  (list#as_stack tokens))
      {#Some [pattern term]}
      (do meta#monad
        ['else (generated_name "'else")]
        (in (list (` (..when (, term)
                       (, pattern)
                       ..true

                       (, 'else)
                       ..false)))))
      
      {#None}
      (failure ..wrong_syntax))))

(every .public (Can ability)
  (for_some (_ entity)
    [entity
     (ability entity)]))

(the .public (can ability entity)
  (for_any (_ ability it)
    (-> (ability it) it
        (Can ability it)))
  [entity ability])

(the .public (ability [entity ability])
  (for_any (_ ability it)
    (-> (Can ability it)
        (ability it)))
  ability)

(the .public (entity [entity ability])
  (for_any (_ ability it)
    (-> (Can ability it)
        it))
  entity)

(the .public text
  (macro (_ tokens)
    (meta#in (list (` (.text_composite# (,* tokens)))))))
