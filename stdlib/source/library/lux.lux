... This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
... If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

(.def# prelude
       (.is# (.type# "name_of_module")
             "library/lux")
       1b)

(.def# Type
       (.is# (.type# "type")
             {4 1b
                [..prelude "Type"]
                (.type# "type")})
       1b)

(.def# Name
       (.is# Type
             {4 1b
                [..prelude "Name"]
                (.type# "name")})
       1b)

(.def# Bit
       (.is# Type
             {4 1b
                [..prelude "Bit"]
                {0 0b (.type_name# "bit") (.list#)}})
       1b)

(.def# not
       (.is# {0 0b
                (.type_name# "function")
                (.list# [0b ..Bit]
                        [1b ..Bit])}
             (.function# _ it
                         (.when# it
                                 0b 1b
                                 1b 0b)))
       1b)

(.def# false
       (.is# Bit
             0b)
       1b)

(.def# true
       (.is# Bit
             (..not ..false))
       1b)

(.def# public
       ..true
       1b)

(.def# private
       (..not ..public)
       ..public)

(.def# local
       ..private
       ..public)

(.def# global
       (not ..local)
       ..public)

(.def# Polarity
       (.is# Type
             ..Bit)
       ..public)

(.def# contra_variant
       (.is# Polarity
             ..false)
       ..public)

(.def# co_variant
       (.is# Polarity
             (..not ..contra_variant))
       ..public)

... https://en.wikipedia.org/wiki/Quantifier_(logic)
(.def# Quantification
       (.is# Type
             ..Bit)
       ..public)

... https://en.wikipedia.org/wiki/Universal_quantification
(.def# universal
       (.is# Quantification
             ..false)
       ..public)

... https://en.wikipedia.org/wiki/Existential_quantification
(.def# existential
       (.is# Quantification
             (..not ..universal))
       ..public)

(.def# Parameter
       (.is# Type
             ..Bit)
       ..public)

(.def# abstraction
       (.is# Parameter
             0b)
       ..public)

(.def# argument
       (.is# Parameter
             (..not ..abstraction))
       ..public)

... https://en.wikipedia.org/wiki/Quality_(philosophy)
(.def# Quality
       (.is# Type
             ..Bit)
       ..public)

(.def# general
       (.is# Quality
             0b)
       ..public)

(.def# special
       (.is# Quality
             (..not ..abstraction))
       ..public)

(.def# Natural
       (.is# Type
             {4 1b
                [..prelude "Natural"]
                {0 0b (.type_name# "i64")
                   (.list# [..co_variant {0b (.type_name# "natural") (.list#)}])}})
       ..public)

... (every .public Any
...   (for_some (_ it) it))
(.def# Any
       (.is# Type
             {4 1b
                [..prelude "Any"]
                {3 0b
                   .existential
                   {0b}
                   {1 0b ..argument 0}}})
       ..public)

... (every .public (Stack it)
...   (Variant
...    {#Empty}
...    {#Top it (Stack it)}))
(.def# Stack
       (.is# Type
             {4 1b
                [..prelude "Stack"]
                {3 0b
                   .universal
                   {0b}
                   {0 0b
                      (.type_name# "sum")
                      (.list# [..co_variant Any]
                              [..co_variant {0 0b
                                               (.type_name# "product")
                                               (.list# [..co_variant {1 0b ..argument 0}]
                                                       [..co_variant {4 0b
                                                                        {1 0b ..argument 0}
                                                                        {1 0b ..abstraction 0}}])}])}}})
       ..public)

... (every .public (Maybe it)
...   (Variant
...    {#None}
...    {#Some it}))
(.def# Maybe
       (.is# Type
             {4 1b
                [..prelude "Maybe"]
                {3 0b
                   .universal
                   {0b}
                   {0 0b
                      (.type_name# "sum")
                      (.list# [..co_variant Any]
                              [..co_variant {1 0b ..argument 0}])}}})
       ..public)

(.def# Label
       (.is# Type
             {4 1b [..prelude "Label"]
                (.type# "label")})
       ..public)

(.def# Tag
       (.is# Type
             {4 1b [..prelude "Tag"]
                {0b (.type_name# "tag") (.list#)}})
       ..public)

(.def# Slot
       (.is# Type
             {4 1b [..prelude "Slot"]
                {0b (.type_name# "slot") (.list#)}})
       ..public)

(.def# Sum
       (.is# {0 0b
                (.type_name# "function")
                (.list# [..contra_variant ..Type]
                        [..co_variant {0 0b
                                         (.type_name# "function")
                                         (.list# [..contra_variant ..Type]
                                                 [..co_variant ..Type])}])}
             (.function# _ left
                         (.function# _ right
                                     {0 0b
                                        (.type_name# "sum")
                                        (.list# [..co_variant left]
                                                [..co_variant right])})))
       ..private)

(.def# Product
       (.is# {0 0b
                (.type_name# "function")
                (.list# [..contra_variant ..Type]
                        [..co_variant {0 0b
                                         (.type_name# "function")
                                         (.list# [..contra_variant ..Type]
                                                 [..co_variant ..Type])}])}
             (.function# _ left
                         (.function# _ right
                                     {0 0b
                                        (.type_name# "product")
                                        (.list# [..co_variant left]
                                                [..co_variant right])})))
       ..private)

(.def# Function
       (.is# {0 0b
                (.type_name# "function")
                (.list# [..contra_variant ..Type]
                        [..co_variant {0 0b
                                         (.type_name# "function")
                                         (.list# [..contra_variant ..Type]
                                                 [..co_variant ..Type])}])}
             (.function# _ left
                         (.function# _ right
                                     {0 0b
                                        (.type_name# "function")
                                        (.list# [..contra_variant left]
                                                [..co_variant right])})))
       ..private)

(.def# tag
       (.is# (Function Label
                       Tag)
             (.function# _ it (.as# (Function Label Tag) it)))
       ..private)

(.def# slot
       (.is# (Function Label
                       Slot)
             (.function# _ it (.as# (Function Label Slot) it)))
       ..private)

(.def# Array'
       (.is# Type
             {4 1b [..prelude "Array'"]
                {3 0b .universal {0b}
                   {3 0b .universal {0b}
                      {0 0b (.type_name# "array") (.list# [..contra_variant {1 0b ..argument 1}]
                                                          [..co_variant {1 0b ..argument 0}])}}}})
       .public)

(.def# Array
       (.is# Type
             {4 1b [..prelude "Array"]
                {3 0b .universal {0b}
                   {0 0b (.type_name# "array") (.list# [..contra_variant {1 0b ..argument 0}]
                                                       [..co_variant {1 0b ..argument 0}])}}})
       .public)

(.def# List
       (.is# Type
             {4 1b [..prelude "List"]
                {3 0b .universal {0b}
                   {0 0b (.type_name# "list") (.list# [..co_variant {1 0b ..argument 0}])}}})
       .public)

(.def# every_tag_of_maybe
       (.is# {4 0b Name List}
             (.list# [..prelude "#None"]
                     [..prelude "#Some"]))
       ..private)
(.def# #None (..tag [{1b [0 0b ..every_tag_of_maybe]} Maybe]) ..public)
(.def# #Some (..tag [{1b [0 1b ..every_tag_of_maybe]} Maybe]) ..public)

(.def# every_tag_of_stack
       (.is# {4 0b Name List}
             (.list# [..prelude "#Empty"]
                     [..prelude "#Top"]))
       ..private)
(.def# #Empty (..tag [{1b [0 0b ..every_tag_of_stack]} Stack]) ..public)
(.def# #Top (..tag [{1b [0 1b ..every_tag_of_stack]} Stack]) ..public)

(.def# every_tag_of_type
       (.is# {4 0b Name List}
             (.list# [..prelude "#Nominal"]
                     [..prelude "#Parameter"]
                     [..prelude "#Variable"]
                     [..prelude "#Quantification"]
                     [..prelude "#Reification"]
                     [..prelude "#Named"]))
       ..private)
(.def# #Nominal (..tag [{#Some [0 0b ..every_tag_of_type]} Type]) ..public)
(.def# #Parameter (..tag [{#Some [1 0b ..every_tag_of_type]} Type]) ..public)
(.def# #Variable (..tag [{#Some [2 0b ..every_tag_of_type]} Type]) ..public)
(.def# #Quantification (..tag [{#Some [3 0b ..every_tag_of_type]} Type]) ..public)
(.def# #Reification (..tag [{#Some [4 0b ..every_tag_of_type]} Type]) ..public)
(.def# #Named (..tag [{#Some [4 1b ..every_tag_of_type]} Type]) ..public)

(.def# provenance#dummy
       (.is# (.type# "provenance")
             ["" 0 0])
       ..private)

... (every .public Nothing
...   (for_any (_ it) it))
(.def# Nothing
       (.is# Type
             {#Named [..prelude "Nothing"]
                     {#Quantification .universal {#Empty}
                                      {#Parameter ..argument 0}}})
       ..public)

(.def# I64
       (.is# Type
             {#Named [..prelude "I64"]
                     {#Quantification .universal {#Empty}
                                      {#Nominal (.type_name# "i64") (.list# [..co_variant {#Parameter ..argument 0}])}}})
       ..public)

(.def# Integer
       (.is# Type
             {#Named [..prelude "Integer"]
                     {#Nominal (.type_name# "i64") (.list# [..co_variant {#Nominal (.type_name# "integer") (.list#)}])}})
       ..public)

(.def# Revolution
       (.is# Type
             {#Named [..prelude "Revolution"]
                     {#Nominal (.type_name# "i64") (.list# [..co_variant {#Nominal (.type_name# "revolution") (.list#)}])}})
       ..public)

(.def# Decimal
       (.is# Type
             {#Named [..prelude "Decimal"]
                     {#Nominal (.type_name# "decimal") (.list#)}})
       ..public)

(.def# Text
       (.is# Type
             {#Named [..prelude "Text"]
                     {#Nominal (.type_name# "text") (.list#)}})
       ..public)

(.def# Error
       (.is# Type
             {#Named [..prelude "Error"]
                     ..Text})
       ..public)

... (every .public Provenance
...   (Record
...    [#module Text
...     #line   Natural
...     #column Natural]))
(.def# Provenance
       (.is# Type
             {#Named [..prelude "Provenance"]
                     (.type# "provenance")})
       ..public)
(.def# every_slot_of_provenance
       (.is# {#Reification Name List}
             (.list# [..prelude "#module"]
                     [..prelude "#line"]
                     [..prelude "#column"]))
       ..private)
(.def# #module (slot [{#Some [0 0b ..every_slot_of_provenance]} Provenance]) ..public)
(.def# #line (slot [{#Some [1 0b ..every_slot_of_provenance]} Provenance]) ..public)
(.def# #column (slot [{#Some [1 1b ..every_slot_of_provenance]} Provenance]) ..public)

... (every .public (Annotated m v)
...   (Record
...    [#meta  m
...     #datum v]))
(.def# Annotated
       (.is# Type
             {#Named [..prelude "Annotated"]
                     {#Quantification .universal {#Empty}
                                      {#Quantification .universal {#Empty}
                                                       (Product {#Parameter ..argument 1}
                                                                {#Parameter ..argument 0})}}})
       ..public)
(.def# every_slot_of_ann
       (.is# {#Reification Name List}
             (.list# [..prelude "#meta"]
                     [..prelude "#datum"]))
       ..private)
(.def# #meta (slot [{#Some [0 0b ..every_slot_of_ann]} Annotated]) ..public)
(.def# #datum (slot [{#Some [0 1b ..every_slot_of_ann]} Annotated]) ..public)

(.def# Code
       (.is# Type
             {#Named [..prelude "Code"]
                     (.type# "code")})
       ..public)
(.def# every_tag_of_code
       (.is# {#Reification Name List}
             (.list# [..prelude "#Bit"]
                     [..prelude "#Natural"]
                     [..prelude "#Integer"]
                     [..prelude "#Revolution"]
                     [..prelude "#Decimal"]
                     [..prelude "#Text"]
                     [..prelude "#Name"]
                     [..prelude "#Form"]
                     [..prelude "#Variant"]
                     [..prelude "#Tuple"]))
       ..private)
(.def# #Bit (tag [{#Some [0 0b ..every_tag_of_code]} Code]) ..public)
(.def# #Natural (tag [{#Some [1 0b ..every_tag_of_code]} Code]) ..public)
(.def# #Integer (tag [{#Some [2 0b ..every_tag_of_code]} Code]) ..public)
(.def# #Revolution (tag [{#Some [3 0b ..every_tag_of_code]} Code]) ..public)
(.def# #Decimal (tag [{#Some [4 0b ..every_tag_of_code]} Code]) ..public)
(.def# #Text (tag [{#Some [5 0b ..every_tag_of_code]} Code]) ..public)
(.def# #Name (tag [{#Some [6 0b ..every_tag_of_code]} Code]) ..public)
(.def# #Form (tag [{#Some [7 0b ..every_tag_of_code]} Code]) ..public)
(.def# #Variant (tag [{#Some [8 0b ..every_tag_of_code]} Code]) ..public)
(.def# #Tuple (tag [{#Some [8 1b ..every_tag_of_code]} Code]) ..public)

(.def# annotated
       (.is# {#Quantification .universal {#Empty}
                              (Function {#Parameter ..argument 0}
                                        (Product Provenance {#Parameter ..argument 0}))}
             (.function# _ it
                         [provenance#dummy it]))
       ..private)

(.def# code#bit
       (.is# (Function Bit
                       Code)
             (.function# _ value {#Bit (annotated value)}))
       ..private)

(.def# code#natural
       (.is# (Function Natural
                       Code)
             (.function# _ value {#Natural (annotated value)}))
       ..private)

(.def# code#integer
       (.is# (Function Integer
                       Code)
             (.function# _ value {#Integer (annotated value)}))
       ..private)

(.def# code#revolution
       (.is# (Function Revolution
                       Code)
             (.function# _ value {#Revolution (annotated value)}))
       ..private)

(.def# code#decimal
       (.is# (Function Decimal
                       Code)
             (.function# _ value {#Decimal (annotated value)}))
       ..private)

(.def# code#text
       (.is# (Function Text
                       Code)
             (.function# _ text {#Text (annotated text)}))
       ..private)

(.def# code#name
       (.is# (Function Name
                       Code)
             (.function# _ name {#Name (annotated name)}))
       ..private)

(.def# code#local
       (.is# (Function Text
                       Code)
             (.function# _ name (code#name ["" name])))
       ..private)

(.def# 'prelude
       (.is# (Function Text
                       Code)
             (.function# _ it (code#name [..prelude it])))
       ..private)

(.def# code#form
       (.is# (Function {#Reification Code List}
                       Code)
             (.function# _ tokens {#Form (annotated tokens)}))
       ..private)

(.def# code#variant
       (.is# (Function {#Reification Code List}
                       Code)
             (.function# _ tokens {#Variant (annotated tokens)}))
       ..private)

(.def# code#tuple
       (.is# (Function {#Reification Code List}
                       Code)
             (.function# _ tokens {#Tuple (annotated tokens)}))
       ..private)

(.def# 'list
       (.is# (Function {#Reification Code List}
                       Code)
             (.when# ('prelude "list#")
                     'list#
                     (.function# _ tokens
                                 (code#form (.list_composite# (.list# 'list#) tokens)))))
       ..private)

(.def# Definition
       (.is# Type
             {#Named [..prelude "Definition"]
                     (.type# "definition")})
       .public)

(.def# Alias
       (.is# Type
             {#Named [..prelude "Alias"]
                     (.type# "alias")})
       .public)

(.def# Global
       (.is# Type
             {#Named [..prelude "Global"]
                     (.type# "global")})
       .public)

(.def# every_tag_of_global
       (.is# {#Reification Name List}
             (.list# [..prelude "#Alias"]
                     [..prelude "#Definition"]))
       ..private)
(.def# #Alias (tag [{#Some [0 0b ..every_tag_of_global]} Global]) .public)
(.def# #Definition (tag [{#Some [0 1b ..every_tag_of_global]} Global]) .public)

(.def# Bindings
       (.is# Type
             {#Named [..prelude "Bindings"]
                     (.type# "bindings")})
       .public)

(.def# every_slot_of_bindings
       (.is# {#Reification Name List}
             (.list# [..prelude "#counter"]
                     [..prelude "#mappings"]))
       ..private)
(.def# #counter (slot [{#Some [0 0b ..every_slot_of_bindings]} Bindings]) .public)
(.def# #mappings (slot [{#Some [0 1b ..every_slot_of_bindings]} Bindings]) .public)

... (every .public Ref
...   {#Local Natural}
...   {#Captured Natural})
(.def# Ref
       (.is# Type
             {#Named [..prelude "Ref"]
                     (Sum Natural
                          Natural)})
       .public)

(.def# every_tag_of_ref
       (.is# {#Reification Name List}
             (.list# [..prelude "#Local"]
                     [..prelude "#Captured"]))
       ..private)
(.def# #Local (tag [{#Some [0 0b ..every_tag_of_ref]} Ref]) .public)
(.def# #Captured (tag [{#Some [0 1b ..every_tag_of_ref]} Ref]) .public)

(.def# Scope
       (.is# Type
             {#Named [..prelude "Scope"]
                     (.type# "scope")})
       .public)

(.def# every_slot_of_scope
       (.is# {#Reification Name List}
             (.list# [..prelude "#locals"]
                     [..prelude "#captured"]))
       ..private)
(.def# #locals (slot [{#Some [0 0b ..every_slot_of_scope]} Scope]) .public)
(.def# #captured (slot [{#Some [0 1b ..every_slot_of_scope]} Scope]) .public)

... (every .public (Either l r)
...   (Variant
...    {#Left l}
...    {#Right r}))
(.def# Either
       (.is# Type
             {#Named [..prelude "Either"]
                     {#Quantification .universal {#Empty}
                                      {#Quantification .universal {#Empty}
                                                       (Sum {#Parameter ..argument 1}
                                                            {#Parameter ..argument 0})}}})
       .public)

(.def# every_tag_of_either
       (.is# {#Reification Name List}
             (.list# [..prelude "#Left"]
                     [..prelude "#Right"]))
       ..private)
(.def# #Left (tag [{#Some [0 0b ..every_tag_of_either]} Either]) .public)
(.def# #Right (tag [{#Some [0 1b ..every_tag_of_either]} Either]) .public)

... (every .public Source
...   [Provenance Natural Text])
(.def# Source
       (.is# Type
             {#Named [..prelude "Source"]
                     (Product Provenance (Product Natural Text))})
       .public)

... (every .public Module_State
...   (Variant
...    {#Active}
...    {#Compiled}
...    {#Cached}))
(.def# Module_State
       (.is# Type
             {#Named [..prelude "Module_State"]
                     (Sum Any
                          (Sum Any
                               Any))})
       .public)

(.def# every_tag_of_module_state
       (.is# {#Reification Name List}
             (.list# [..prelude "#Active"]
                     [..prelude "#Compiled"]
                     [..prelude "#Cached"]))
       ..private)
(.def# #Active (tag [{#Some [0 0b ..every_tag_of_module_state]} Module_State]) .public)
(.def# #Compiled (tag [{#Some [1 0b ..every_tag_of_module_state]} Module_State]) .public)
(.def# #Cached (tag [{#Some [1 1b ..every_tag_of_module_state]} Module_State]) .public)

(.def# Module
       (.is# Type
             {#Named [..prelude "Module"]
                     (.type# "module")})
       .public)

(.def# every_slot_of_module
       (.is# {#Reification Name List}
             (.list# [..prelude "#module_hash"]
                     [..prelude "#module_aliases"]
                     [..prelude "#definitions"]
                     [..prelude "#imports"]
                     [..prelude "#module_state"]))
       ..private)
(.def# #module_hash (slot [{#Some [0 0b ..every_slot_of_module]} Module]) .public)
(.def# #module_aliases (slot [{#Some [1 0b ..every_slot_of_module]} Module]) .public)
(.def# #definitions (slot [{#Some [2 0b ..every_slot_of_module]} Module]) .public)
(.def# #imports (slot [{#Some [3 0b ..every_slot_of_module]} Module]) .public)
(.def# #module_state (slot [{#Some [3 1b ..every_slot_of_module]} Module]) .public)

(.def# Type_Context
       (.is# Type
             {#Named [..prelude "Type_Context"]
                     (.type# "type_context")})
       .public)

(.def# every_slot_of_type_context
       (.is# {#Reification Name List}
             (.list# [..prelude "#ex_counter"]
                     [..prelude "#var_counter"]
                     [..prelude "#var_bindings"]))
       ..private)
(.def# #ex_counter (slot [{#Some [0 0b ..every_slot_of_type_context]} Type_Context]) .public)
(.def# #var_counter (slot [{#Some [1 0b ..every_slot_of_type_context]} Type_Context]) .public)
(.def# #var_bindings (slot [{#Some [1 1b ..every_slot_of_type_context]} Type_Context]) .public)

... (every .public Mode
...   (Variant
...    {#Build}
...    {#Eval}
...    {#Interpreter}))
(.def# Mode
       (.is# Type
             {#Named [..prelude "Mode"]
                     (Sum Any
                          (Sum Any
                               Any))})
       .public)

(.def# every_tag_of_mode
       (.is# {#Reification Name List}
             (.list# [..prelude "#Build"]
                     [..prelude "#Eval"]
                     [..prelude "#Interpreter"]))
       ..private)
(.def# #Build (tag [{#Some [0 0b ..every_tag_of_mode]} Mode]) .public)
(.def# #Eval (tag [{#Some [1 0b ..every_tag_of_mode]} Mode]) .public)
(.def# #Interpreter (tag [{#Some [1 1b ..every_tag_of_mode]} Mode]) .public)

(.def# Info
       (.is# Type
             (.type# "info"))
       .public)

(.def# every_slot_of_info
       (.is# {#Reification Name List}
             (.list# [..prelude "#target"]
                     [..prelude "#version"]
                     [..prelude "#mode"]
                     [..prelude "#configuration"]))
       ..private)
(.def# #target (slot [{#Some [0 0b ..every_slot_of_info]} Info]) .public)
(.def# #version (slot [{#Some [1 0b ..every_slot_of_info]} Info]) .public)
(.def# #mode (slot [{#Some [2 0b ..every_slot_of_info]} Info]) .public)
(.def# #configuration (slot [{#Some [2 1b ..every_slot_of_info]} Info]) .public)

(.def# Lux
       (.is# Type
             {#Named [..prelude "Lux"]
                     (.type# "lux")})
       .public)

(.def# every_slot_of_lux
       (.is# {#Reification Name List}
             (.list# [..prelude "#info"]
                     [..prelude "#source"]
                     [..prelude "#provenance"]
                     [..prelude "#current_module"]
                     [..prelude "#modules"]
                     [..prelude "#scopes"]
                     [..prelude "#type_context"]
                     [..prelude "#expected"]
                     [..prelude "#seed"]
                     [..prelude "#eval"]))
       ..private)
(.def# #info (slot [{#Some [0 0b ..every_slot_of_lux]} Lux]) .public)
(.def# #source (slot [{#Some [1 0b ..every_slot_of_lux]} Lux]) .public)
(.def# #provenance (slot [{#Some [2 0b ..every_slot_of_lux]} Lux]) .public)
(.def# #current_module (slot [{#Some [3 0b ..every_slot_of_lux]} Lux]) .public)
(.def# #modules (slot [{#Some [4 0b ..every_slot_of_lux]} Lux]) .public)
(.def# #scopes (slot [{#Some [5 0b ..every_slot_of_lux]} Lux]) .public)
(.def# #type_context (slot [{#Some [6 0b ..every_slot_of_lux]} Lux]) .public)
(.def# #expected (slot [{#Some [7 0b ..every_slot_of_lux]} Lux]) .public)
(.def# #seed (slot [{#Some [8 0b ..every_slot_of_lux]} Lux]) .public)
(.def# #eval (slot [{#Some [8 1b ..every_slot_of_lux]} Lux]) .public)

... (every .public (Meta a)
...   (-> Lux (Either Text [Lux a])))
(.def# Meta
       (.is# Type
             {#Named [..prelude "Meta"]
                     {#Quantification .universal {#Empty}
                                      (Function Lux
                                                {#Reification (Product Lux {#Parameter ..argument 0})
                                                              {#Reification Text Either}})}})
       .public)

... (every .public Macro'
...   (-> (List Code)
...       (Meta (List Code))))
(.def# Macro'
       (.is# Type
             {#Named [..prelude "Macro'"]
                     (Function {#Reification Code List}
                               {#Reification {#Reification Code List} Meta})})
       .public)

(.def# Macro
       (.is# Type
             {#Named [..prelude "Macro"]
                     {#Nominal (.type_name# "macro") (.list#)}})
       .public)

... Base functions & macros
(.def# meta#pure
       (.is# {#Quantification .universal {#Empty}
                              (Function {#Parameter ..argument 0}
                                        {#Reification {#Parameter ..argument 0} Meta})}
             (.function# _ val
                         (.function# _ state
                                     {#Right [state val]})))
       ..private)

(.def# failure
       (.is# {#Quantification .universal {#Empty}
                              (Function Text
                                        {#Reification {#Parameter ..argument 0} Meta})}
             (.function# _ msg
                         (.function# _ state
                                     {#Left msg})))
       ..private)

(.def# list
       (.as# (Function Macro' Macro)
             (.function# _ tokens
                         (meta#pure (.list# ('list tokens)))))
       .public)

(.def# list#as_stack
       (.is# {#Quantification .universal {#Empty}
                              (Function {#Reification {#Parameter ..argument 0} List}
                                        {#Reification {#Parameter ..argument 0} Stack})}
             (.function# _ it
                         ((.is# {#Quantification .universal {#Empty}
                                                 (Function {#Reification {#Parameter ..argument 0} List}
                                                           (Function Natural
                                                                     (Function {#Reification {#Parameter ..argument 0} Stack}
                                                                               {#Reification {#Parameter ..argument 0} Stack})))}
                                (.function# next it
                                            (.function# _ remaining
                                                        (.function# _ value
                                                                    (.when# remaining
                                                                            0 value
                                                                            _ (.when# (.i64_-# 1 remaining)
                                                                                      address
                                                                                      (next it address
                                                                                            {#Top (.list_item# address it)
                                                                                                  value})))))))
                          it
                          (.list_size# it)
                          {#Empty})))
       .private)

(.def# list#of_stack
       (.is# {#Quantification .universal {#Empty}
                              (Function {#Reification {#Parameter ..argument 0} Stack}
                                        {#Reification {#Parameter ..argument 0} List})}
             (.function# _ it
                         (.when# it
                                 {#Empty}
                                 (list)

                                 {#Top head tail}
                                 ((.is# {#Quantification .universal {#Empty}
                                                         (Function {#Reification {#Parameter ..argument 0} Stack}
                                                                   (Function {#Reification {#Parameter ..argument 0} List}
                                                                             {#Reification {#Parameter ..argument 0} List}))}
                                        (.function# next it
                                                    (.function# _ value
                                                                (.when# it
                                                                        {#Empty}
                                                                        value

                                                                        {#Top head tail}
                                                                        (next tail
                                                                              (.list_composite# value (list head)))))))
                                  tail
                                  (list head)))))
       .private)

(.def# \''
       (.is# Text
             (.int_char# +34))
       ..private)

(.def# wrong_syntax
       (.is# Error
             "Wrong syntax.")
       ..public)

(.def# 'function
       (.is# (Function Code (Function {#Reification Code Stack} (Function Code Code)))
             (.when# ('prelude "function#")
                     'extension
                     (.function# 'function self
                                 (.function# _ inputs
                                             (.function# _ output
                                                         (.when# inputs
                                                                 {#Empty}
                                                                 output

                                                                 {#Top head tail}
                                                                 (code#form (list 'extension
                                                                                  self
                                                                                  head
                                                                                  ('function (code#name ["" ""]) tail output)))))))))
       ..private)

(.def# function'
       (.as# (Function Macro' Macro)
             (.function# _ tokens
                         (.when# tokens
                                 (.list# {#Form _ self,arguments}
                                         body)
                                 (.when# (list#as_stack self,arguments)
                                         {#Top self arguments}
                                         (meta#pure (list ('function self arguments body)))

                                         else
                                         (failure ..wrong_syntax))

                                 _
                                 (failure ..wrong_syntax))))
       ..private)

(.def# 'when#
       (.is# Code
             ('prelude "when#"))
       .private)

(.def# 'let
       (.is# (Function Code (Function Code (Function Code Code)))
             (function' (_ binding value body)
                        (code#form (list 'when#
                                         value
                                         binding
                                         body))))
       .private)

(.def# code#def
       (.is# (Function Code (Function Code (Function Code Code)))
             (function' (_ name value export_policy)
                        (code#form (list ('prelude "def#")
                                         name
                                         value
                                         export_policy))))
       ..private)

(.def# code#is
       (.is# (Function Code (Function Code Code))
             (.when# ('prelude "is#")
                     'is#
                     (function' (_ type value)
                                (code#form (list 'is#
                                                 type
                                                 value)))))
       ..private)

(.def# the'
       (.as# (Function Macro' Macro)
             (function' (_ tokens)
                        (.when# tokens
                                (.list# export_policy
                                        {#Form _ name,arguments}
                                        type
                                        body)
                                (.when# (list#as_stack name,arguments)
                                        {#Top name arguments}
                                        (meta#pure (list (code#def name
                                                                   (code#is type
                                                                            ('function name arguments
                                                                                       body))
                                                                   export_policy)))
                                        
                                        else
                                        (failure ..wrong_syntax))

                                (.list# export_policy name type body)
                                (meta#pure (list (code#def name
                                                           (code#is type
                                                                    body)
                                                           export_policy)))

                                _
                                (failure ..wrong_syntax))))
       ..private)

(.def# '#Nominal
       (.is# Code
             ('prelude "#Nominal"))
       .private)

(.def# 'Function
       (.is# (Function Code (Function Code Code))
             (function' (_ domain co_domain)
                        (code#variant (list '#Nominal
                                            (code#text (.type_name# "function"))
                                            ('list (list (code#tuple (list (code#bit ..contra_variant)
                                                                           domain))
                                                         (code#tuple (list (code#bit ..co_variant)
                                                                           co_domain))))))))
       ..private)

(.def# 'Bit
       (.is# Code
             ('prelude "Bit"))
       ..private)

(.def# 'Predicate
       (.is# (Function Code Code)
             (function' (_ it)
                        ('Function it 'Bit)))
       ..private)

(.def# Predicate
       (.as# (Function Macro' Macro)
             (function' (_ tokens)
                        (.when# tokens
                                (.list# it)
                                (meta#pure (list ('Predicate it)))

                                _
                                (failure ..wrong_syntax))))
       ..private)

(.def# 'as#
       (.is# (Function Code (Function Code Code))
             (function' (_ 'coercion 'it)
                        (code#form (list ('prelude "as#")
                                         'coercion
                                         'it))))
       ..private)

(.def# 'macro
       (.is# (Function Code
                       Code)
             (function' (_ expression)
                        ('as# ('Function ('prelude "Macro'")
                                         ('prelude "Macro"))
                              expression)))
       ..private)

(.def# macro
       (.as# (Function Macro' Macro)
             (function' (_ tokens)
                        (.when# tokens
                                (.list# {#Form _ name,arguments} body)
                                (.when# (list#as_stack name,arguments)
                                        {#Top name arguments}
                                        (meta#pure (list ('macro ('function name arguments body))))

                                        else
                                        (failure ..wrong_syntax))

                                _
                                (failure ..wrong_syntax))))
       ..public)

(the' .public comment
      Macro
      (macro (_ tokens)
        (meta#pure (list))))

(the' .private (stack#mix f init xs)
      ... (for_any (_ a b) (-> (-> b a a) a (Stack b) a))
      {#Quantification .universal {#Empty}
                       {#Quantification .universal {#Empty}
                                        (Function (Function {#Parameter ..argument 0}
                                                            (Function {#Parameter ..argument 1}
                                                                      {#Parameter ..argument 1}))
                                                  (Function {#Parameter ..argument 1}
                                                            (Function {#Reification {#Parameter ..argument 0} Stack}
                                                                      {#Parameter ..argument 1})))}}
      (.when# xs
              {#Empty}
              init

              {#Top x xs'}
              (stack#mix f (f x init) xs')))

(the' .private $
      Macro
      (macro (_ tokens)
        (.when# (list#as_stack tokens)
                {#Top abstraction parameters}
                (meta#pure (list (stack#mix (function' (_ parameter abstraction)
                                                       (code#variant (list ('prelude "#Reification")
                                                                           parameter
                                                                           abstraction)))
                                            abstraction
                                            parameters)))

                _
                (failure ..wrong_syntax))))

(the' .public Change
      Type
      {#Named [..prelude "Change"]
              {#Quantification .universal {#Empty}
                               (Function {#Parameter ..argument 0}
                                         {#Parameter ..argument 0})}})

(the' .private stack#reversed
      {#Quantification .universal {#Empty}
                       ($ Change ($ Stack {#Parameter ..argument 0}))}
      (stack#mix (function' (_ head tail)
                            {#Top head tail})
                 {#Empty}))

(the' .private (list#mix' mix complete partial)
      ... (for_any (_ a b) (-> (-> Natural b a a) a (List b) a))
      {#Quantification .universal {#Empty}
                       {#Quantification .universal {#Empty}
                                        (Function (Function Natural
                                                            (Function {#Parameter ..argument 0}
                                                                      ($ Change {#Parameter ..argument 1})))
                                                  (Function {#Parameter ..argument 1}
                                                            (Function {#Reification {#Parameter ..argument 0} List}
                                                                      {#Parameter ..argument 1})))}}
      (.when# (.list_size# partial)
              limit
              ((.is# {#Quantification .universal {#Empty}
                                      {#Quantification .universal {#Empty}
                                                       (Function Natural
                                                                 (Function (Function Natural
                                                                                     (Function {#Parameter ..argument 0}
                                                                                               ($ Change {#Parameter ..argument 1})))
                                                                           (Function {#Parameter ..argument 1}
                                                                                     (Function {#Reification {#Parameter ..argument 0} List}
                                                                                               {#Parameter ..argument 1}))))}}
                     (function' (list#mix' item mix complete partial)
                                (.when# (.int_<# (.as# (Function Natural Integer) limit)
                                                 (.as# (Function Natural Integer) item))
                                        1b
                                        (list#mix' (.i64_+# 1 item)
                                                   mix
                                                   (mix item
                                                        (.list_item# item partial)
                                                        complete)
                                                   partial)
                                        
                                        0b
                                        complete)))
               0 mix complete partial)))

(the' .private (list#mix mix complete partial)
      ... (for_any (_ a b) (-> (-> b a a) a (List b) a))
      {#Quantification .universal {#Empty}
                       {#Quantification .universal {#Empty}
                                        (Function (Function {#Parameter ..argument 0}
                                                            ($ Change {#Parameter ..argument 1}))
                                                  (Function {#Parameter ..argument 1}
                                                            (Function {#Reification {#Parameter ..argument 0} List}
                                                                      {#Parameter ..argument 1})))}}
      (list#mix' (function' (_ item input output)
                            (mix input output))
                 complete
                 partial))

(the' ..private 'Array
      ($ Change Code)
      (function' (_ 'it)
                 (code#variant (list '#Nominal
                                     (code#text (.type_name# "array"))
                                     ('list (list (code#tuple (list (code#bit ..contra_variant)
                                                                    'it))
                                                  (code#tuple (list (code#bit ..co_variant)
                                                                    'it))))))))

(the' ..private 'List
      ($ Change Code)
      (function' (_ 'it)
                 (code#variant (list '#Nominal
                                     (code#text (.type_name# "list"))
                                     ('list (list (code#tuple (list (code#bit ..co_variant)
                                                                    'it))))))))

(the' .private '#Empty
      Code
      (code#variant (list ('prelude "#Empty"))))

(the' .private ('#Top head tail)
      (Function Code ($ Change Code))
      (code#variant (list ('prelude "#Top")
                          head
                          tail)))

(the' .private '#Parameter
      Code
      ('prelude "#Parameter"))

(the' .private '#Quantification
      Code
      ('prelude "#Quantification"))

(the' .private list#of_array
      Macro
      (.when# (code#variant (list '#Parameter
                                  (code#bit ..argument)
                                  (code#natural 0)))
              'argument_0
              (macro (_ tokens)
                (.when# tokens
                        (.list# 'it)
                        (meta#pure (list ('as# (code#variant (list '#Quantification
                                                                   (code#bit .universal)
                                                                   '#Empty
                                                                   ('Function ('Array 'argument_0)
                                                                              ('List 'argument_0))))
                                               'it)))

                        _
                        (failure ..wrong_syntax)))))

(the' .private list#as_array
      Macro
      (.when# (code#variant (list '#Parameter
                                  (code#bit ..argument)
                                  (code#natural 0)))
              'argument_0
              (macro (_ tokens)
                (.when# tokens
                        (.list# 'it)
                        (meta#pure (list ('as# (code#variant (list '#Quantification
                                                                   (code#bit .universal)
                                                                   '#Empty
                                                                   ('Function ('List 'argument_0)
                                                                              ('Array 'argument_0))))
                                               'it)))

                        _
                        (failure ..wrong_syntax)))))

(the' .private (array#clone it)
      {#Quantification .universal {#Empty}
                       ($ Change ($ Array {#Parameter ..argument 0}))}
      (list#mix' (function' (_ address item output)
                            (.array_has# address item output))
                 (.array# (.array_size# it))
                 (list#of_array it)))

(the' .private (list#each' value it)
      {#Quantification .universal {#Empty}
                       {#Quantification .universal {#Empty}
                                        (Function (Function Natural
                                                            (Function {#Parameter ..argument 1}
                                                                      {#Parameter ..argument 0}))
                                                  (Function ($ List {#Parameter ..argument 1})
                                                            ($ List {#Parameter ..argument 0})))}}
      (list#of_array (list#mix' (function' (_ address item output)
                                           (.array_has# address (value address item) output))
                                (.array# (.list_size# it))
                                it)))

(the' .private (list#each value it)
      {#Quantification .universal {#Empty}
                       {#Quantification .universal {#Empty}
                                        (Function (Function {#Parameter ..argument 1}
                                                            {#Parameter ..argument 0})
                                                  (Function ($ List {#Parameter ..argument 1})
                                                            ($ List {#Parameter ..argument 0})))}}
      (list#each' (function' (_ address item) (value item))
                  it))

(the' .private (list#reversed it)
      {#Quantification .universal {#Empty}
                       ($ Change ($ List {#Parameter ..argument 0}))}
      (list#of_array (.when# (.list_size# it)
                             size
                             (.when# (.i64_-# 1 size)
                                     last
                                     (list#mix' (function' (_ address item output)
                                                           (.array_has# (.i64_-# address last) item output))
                                                (.array# size)
                                                it)))))

(the' .private (list#first to_retain it)
      {#Quantification .universal {#Empty}
                       (Function Natural
                                 ($ Change ($ List {#Parameter ..argument 0})))}
      (.when# (.list_size# it)
              available
              (.when# (.int_<# (.as# (Function Natural Integer) available)
                               (.as# (Function Natural Integer) to_retain))
                      1b
                      ((.is# {#Quantification .universal {#Empty}
                                              (Function {#Reification {#Parameter ..argument 0} List}
                                                        (Function Natural
                                                                  (Function {#Reification {#Parameter ..argument 0} Array}
                                                                            {#Reification {#Parameter ..argument 0} List})))}
                             (function' (_ input)
                                        (function' (list#first address output)
                                                   (.when# (.int_<# (.as# (Function Natural Integer) to_retain)
                                                                    (.as# (Function Natural Integer) address))
                                                           1b
                                                           (list#first (.i64_+# 1 address)
                                                                       (.array_has# address
                                                                                    (.list_item# address input)
                                                                                    output))
                                                           
                                                           0b
                                                           (.as# {#Quantification .universal {#Empty}
                                                                                  (Function ($ Array {#Parameter ..argument 0})
                                                                                            ($ List {#Parameter ..argument 0}))}
                                                                 output)))))
                       it 0 (.array# to_retain))

                      0b
                      it)))

(the' .private (list#after to_remove it)
      {#Quantification .universal {#Empty}
                       (Function Natural
                                 ($ Change ($ List {#Parameter ..argument 0})))}
      (.when# (.list_size# it)
              available
              (.when# (.int_<# (.as# (Function Natural Integer) available)
                               (.as# (Function Natural Integer) to_remove))
                      1b
                      (.when# (.i64_-# to_remove available)
                              to_retain
                              ((.is# {#Quantification .universal {#Empty}
                                                      (Function {#Reification {#Parameter ..argument 0} List}
                                                                (Function Natural
                                                                          (Function {#Reification {#Parameter ..argument 0} Array}
                                                                                    {#Reification {#Parameter ..argument 0} List})))}
                                     (function' (_ input)
                                                (function' (list#after address output)
                                                           (.when# (.int_<# (.as# (Function Natural Integer) to_retain)
                                                                            (.as# (Function Natural Integer) address))
                                                                   1b
                                                                   (list#after (.i64_+# 1 address)
                                                                               (.array_has# address
                                                                                            (.list_item# (.i64_+# to_remove address) input)
                                                                                            output))
                                                                   
                                                                   0b
                                                                   (.as# {#Quantification .universal {#Empty}
                                                                                          (Function ($ Array {#Parameter ..argument 0})
                                                                                                    ($ List {#Parameter ..argument 0}))}
                                                                         output)))))
                               it 0 (.array# to_retain)))

                      0b
                      (.list#))))

(the' .private (list#split cut_off it)
      {#Quantification .universal {#Empty}
                       (Function Natural
                                 (Function ($ List {#Parameter ..argument 0})
                                           (Product ($ List {#Parameter ..argument 0})
                                                    ($ List {#Parameter ..argument 0}))))}
      [(list#first cut_off it)
       (list#after cut_off it)])

(the' .private (stack#size it)
      {#Quantification .universal {#Empty}
                       (Function ($ Stack {#Parameter ..argument 0})
                                 Natural)}
      (stack#mix (function' (_ _ acc)
                            (.i64_+# 1 acc))
                 0
                 it))

(the' .private (code#universal_quantification body)
      ($ Change Code)
      (code#variant (list '#Quantification
                          (code#bit .universal)
                          ..'#Empty
                          body)))

(the' .private (code#existential_quantification body)
      ($ Change Code)
      (code#variant (list '#Quantification
                          (code#bit .existential)
                          ..'#Empty
                          body)))

(the' .public text
      Macro
      (macro (_ tokens)
        (meta#pure (list (code#form (.list_composite# (list ('prelude "text_composite#"))
                                                      tokens))))))

(the' .private quantification_level
      Text
      (text \'' "quantification_level" \''))

(the' .private quantified
      ($ Change Code)
      ('let (code#local ..quantification_level) (code#natural 0)))

(the' .private 'i64_+#
      Code
      ('prelude "i64_+#"))

(the' .private (quantified_abstraction idx)
      (Function Natural
                Code)
      (code#variant (list '#Parameter
                          (code#bit ..abstraction)
                          (code#form (list 'i64_+#
                                           (code#local ..quantification_level)
                                           (code#natural idx))))))

(the' .private (quantified_argument idx)
      (Function Natural
                Code)
      (code#variant (list '#Parameter
                          (code#bit ..argument)
                          (code#form (list 'i64_+#
                                           (code#local ..quantification_level)
                                           (code#natural idx))))))

(the' .private (next_level depth)
      ($ Change Natural)
      (.i64_+# 1 depth))

(the' .public (__adjusted_quantified_type__ permission depth type)
      (Function Natural (Function Natural ($ Change Type)))
      (.when# permission
              0
              (.when# type
                      ... Jackpot!
                      {#Parameter parameter id}
                      (.when# (.i64_-# (.i64_-# depth id) 0)
                              id'
                              {#Parameter parameter (.i64_-# 1 id')})
                      
                      ... Recur
                      {#Nominal name parameters}
                      {#Nominal name (list#each (function' (_ it)
                                                           (.when# it
                                                                   [polarity it]
                                                                   [polarity (__adjusted_quantified_type__ permission depth it)]))
                                                parameters)}

                      {#Quantification quantification environment body}
                      {#Quantification quantification
                                       environment
                                       (__adjusted_quantified_type__ permission (next_level depth) body)}
                      
                      {#Reification parameter function}
                      {#Reification (__adjusted_quantified_type__ permission depth parameter)
                                    (__adjusted_quantified_type__ permission depth function)}

                      ... Leave these alone.
                      {#Named _} type
                      {#Variable _} type)

              _
              type))

(the' .private (with_correct_quantification body)
      ($ Change Code)
      (code#form (list (code#name [prelude "__adjusted_quantified_type__"])
                       (code#local ..quantification_level)
                       (code#natural 0)
                       body)))

(the' .private (with_quantification depth body)
      (Function Natural ($ Change Code))
      (.when# (code#local ..quantification_level)
              'quantification_level
              ('let 'quantification_level
                    (code#form (list 'i64_+#
                                     (code#natural depth)
                                     'quantification_level))
                    body)))

(the' .private (initialized_quantification? lux)
      (Predicate Lux)
      (.when# lux
              [..#info _ ..#source _ ..#current_module _ ..#modules _
               ..#scopes scopes ..#type_context _
               ..#seed _ ..#expected _ ..#provenance _ ..#eval _]
              (stack#mix (function' (_ scope verdict)
                                    (.when# verdict
                                            1b 1b
                                            _ (.when# scope
                                                      [..#captured _
                                                       ..#locals [..#counter _
                                                                  ..#mappings locals]]
                                                      (list#mix' (function' (_ _ local verdict)
                                                                            (.when# local
                                                                                    [local _]
                                                                                    (.when# verdict
                                                                                            1b 1b
                                                                                            _ (.text_=# ..quantification_level local))))
                                                                 0b
                                                                 locals))))
                         0b
                         scopes)))

(the' .public for_any
      Macro
      (macro (_ tokens lux)
        (.when# tokens
                (.list# {#Form _ self_name,args}
                        body)
                (.when# (list#as_stack self_name,args)
                        {#Top self_name args}
                        {#Right [lux
                                 (.list# (.when# (.when# args
                                                         {#Empty}
                                                         body

                                                         {#Top head tail}
                                                         (with_correct_quantification
                                                           ('let self_name (quantified_abstraction 0)
                                                                 (.when# (stack#mix (function' (_ parameter offset,body')
                                                                                               (.when# offset,body'
                                                                                                       [offset body']
                                                                                                       [(.i64_+# 1 offset)
                                                                                                        ('let parameter (quantified_argument offset)
                                                                                                              (code#universal_quantification body'))]))
                                                                                    [0 (with_quantification (stack#size args)
                                                                                         body)]
                                                                                    args)
                                                                         [_ raw]
                                                                         raw))))
                                                 raw
                                                 (.when# (initialized_quantification? lux)
                                                         1b raw
                                                         0b (..quantified raw))))]}

                        else
                        {#Left ..wrong_syntax})
                
                _
                {#Left ..wrong_syntax})))

(the' .public for_some
      Macro
      (macro (_ tokens lux)
        (.when# tokens
                (.list# {#Form _ self_name,args}
                        body)
                (.when# (list#as_stack self_name,args)
                        {#Top self_name args}
                        {#Right [lux
                                 (.list# (.when# (.when# args
                                                         {#Empty}
                                                         body

                                                         {#Top head tail}
                                                         (with_correct_quantification
                                                           ('let self_name (quantified_abstraction 0)
                                                                 (.when# (stack#mix (function' (_ parameter offset,body')
                                                                                               (.when# offset,body'
                                                                                                       [offset body']
                                                                                                       [(.i64_+# 1 offset)
                                                                                                        ('let parameter (quantified_argument offset)
                                                                                                              (code#existential_quantification body'))]))
                                                                                    [0 (with_quantification (stack#size args)
                                                                                         body)]
                                                                                    args)
                                                                         [_ raw]
                                                                         raw))))
                                                 raw
                                                 (.when# (initialized_quantification? lux)
                                                         1b raw
                                                         0b (..quantified raw))))]}

                        else
                        {#Left ..wrong_syntax})
                
                _
                {#Left ..wrong_syntax})))

(the' .public ->
      Macro
      (macro (_ tokens)
        (.when# (list#split 1 (list#reversed tokens))
                [(.list# output) inputs]
                (meta#pure (list (list#mix ..'Function output inputs)))
                
                _
                (failure ..wrong_syntax))))

(the' .public stack
      Macro
      (macro (_ it)
        (meta#pure (list (list#mix' (function' (_ _ head tail)
                                               ('#Top head tail))
                                    '#Empty
                                    (list#reversed it))))))

(the' .public Union
      Macro
      (macro (_ tokens)
        (meta#pure (list (.when# (list#as_stack (list#reversed tokens))
                                 {#Empty}
                                 ('prelude "Nothing")

                                 {#Top last prevs}
                                 (stack#mix (function' (_ left right)
                                                       (code#variant (list '#Nominal
                                                                           (code#text (.type_name# "sum"))
                                                                           ('list (list (code#tuple (list (code#bit ..co_variant) left))
                                                                                        (code#tuple (list (code#bit ..co_variant) right)))))))
                                            last
                                            prevs))))))

(the' .public Tuple
      Macro
      (macro (_ tokens)
        (meta#pure (list (.when# (list#as_stack (list#reversed tokens))
                                 {#Empty}
                                 ('prelude "Any")

                                 {#Top last prevs}
                                 (stack#mix (function' (_ left right)
                                                       (code#variant (list '#Nominal
                                                                           (code#text (.type_name# "product"))
                                                                           ('list (list (code#tuple (list (code#bit ..co_variant) left))
                                                                                        (code#tuple (list (code#bit ..co_variant) right)))))))
                                            last
                                            prevs))))))

(the' .public Or
      Macro
      ..Union)

(the' .public And
      Macro
      ..Tuple)

(the' .private (pairs xs)
      (for_any (_ it)
        (-> ($ Stack it)
            ($ Maybe ($ Stack (Tuple it it)))))
      (.when# xs
              {#Top x {#Top y xs'}}
              (.when# (pairs xs')
                      {#Some tail}
                      {#Some {#Top [x y] tail}}
                      
                      {#None}
                      {#None})

              {#Empty}
              {#Some {#Empty}}

              _
              {#None}))

(the' .private let'
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# {#Tuple _ bindings} body)
                (.when# (pairs (list#as_stack bindings))
                        {#Some bindings}
                        (meta#pure (list (stack#mix (.is# (-> (Tuple Code Code) Code
                                                              Code)
                                                          (function' (_ binding body)
                                                                     (.when# binding
                                                                             [label value]
                                                                             ('let label value body))))
                                                    body
                                                    (stack#reversed bindings))))
                        
                        {#None}
                        (failure ..wrong_syntax))

                _
                (failure ..wrong_syntax))))

(the' .private (code#provenance @)
      (-> Provenance
          Code)
      (let' [[module line column] @]
            (code#tuple (list (code#text module) (code#natural line) (code#natural column)))))

(the' .private no_provenance
      Code
      (code#provenance ..provenance#dummy))

(the' .private (right_associativity op a1 a2)
      (-> Code Code Code
          Code)
      (code#form (.list_composite# (.when# op
                                           {#Form _ parts}
                                           parts

                                           _
                                           (list op))
                                   (list a1 a2))))

(the' .private (function#flipped func)
      (for_any (_ left right output)
        (-> (-> left right output)
            (-> right left output)))
      (function' (_ right left)
                 (func left right)))

... https://en.wikipedia.org/wiki/Operator_associativity
(the' .public left_associative
      Macro
      (macro (_ tokens)
        (.when# (.list_size# tokens)
                0 (failure ..wrong_syntax)
                1 (failure ..wrong_syntax)
                2 (meta#pure (list (.list_item# 2 tokens)))
                _ (.when# [(.list_item# 0 tokens) (.list_item# 1 tokens)]
                          [op first]
                          (meta#pure (list (list#mix (function#flipped (right_associativity op)) first (list#after 2 tokens))))))))

(the' .public right_associative
      Macro
      (macro (_ tokens)
        (.when# (list#split 1 tokens)
                [(.list# op) tokens']
                (.when# (list#split 1 (list#reversed tokens'))
                        [(.list# last) prevs]
                        (meta#pure (list (list#mix (right_associativity op) last prevs)))

                        _
                        (failure ..wrong_syntax))
                
                _
                (failure ..wrong_syntax))))

(the' .public per Macro ..left_associative)
(the' .public all Macro ..right_associative)

... (every (Monad m)
...   (Interface
...    (is (for_any (_ a) (-> a (m a)))
...        #pure)
...    (is (for_any (_ a b) (-> (-> a (m b)) (m a) (m b)))
...        #then)))
(.def# Monad
       (.is# Type
             {#Named [..prelude "Monad"]
                     (for_any (_ !)
                       (Tuple (for_any (_ a)
                                (-> a ($ ! a)))
                              (for_any (_ a b)
                                (-> (-> a ($ ! b))
                                    (-> ($ ! a) ($ ! b))))))})
       0b)

(.def# every_slot_of_monad
       (.is# {#Reification Name List}
             (.list# [..prelude "#pure"]
                     [..prelude "#then"]))
       ..private)
(.def# #pure (slot [{#Some [0 0b ..every_slot_of_monad]} Monad]) .private)
(.def# #then (slot [{#Some [0 1b ..every_slot_of_monad]} Monad]) .private)

(the' .private maybe#monad
      ($ Monad Maybe)
      [#pure
       (function' (_ x) {#Some x})
       
       #then
       (function' (_ f ma)
                  (.when# ma
                          {#None}
                          {#None}
                          
                          {#Some a}
                          (f a)))])

(the' .private meta#monad
      ($ Monad Meta)
      [#pure
       (function' (_ x)
                  (function' (_ state)
                             {#Right state x}))
       
       #then
       (function' (_ f ma)
                  (function' (_ state)
                             (.when# (ma state)
                                     {#Right [state' a]}
                                     (f a state')

                                     {#Left msg}
                                     {#Left msg})))])

(the' .private with_monad
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# monad {#Tuple _ bindings} body)
                (.when# (pairs (list#as_stack bindings))
                        {#Some bindings}
                        (let' ['pure (code#local "pure")
                               'then (code#local " then ")
                               body' (stack#mix (.is# (-> (Tuple Code Code) Code Code)
                                                      (function' (_ binding body')
                                                                 (let' [[var value] binding]
                                                                       (.when# var
                                                                               {#Name _ [module proper]}
                                                                               (.when# module
                                                                                       ""
                                                                                       (code#form (list 'then
                                                                                                        ('function (code#local "")
                                                                                                                   (stack var)
                                                                                                                   body')
                                                                                                        value))

                                                                                       _
                                                                                       (code#form (list var value body')))
                                                                               

                                                                               _
                                                                               (code#form (list 'then
                                                                                                ('function (code#local "")
                                                                                                           (stack var)
                                                                                                           body')
                                                                                                value))))))
                                                body
                                                (stack#reversed bindings))]
                              (meta#pure (list ('let (code#tuple (list 'pure 'then)) monad body'))))
                        
                        {#None}
                        (failure ..wrong_syntax))

                _
                (failure ..wrong_syntax))))

(the' .private (monad#mix ! mix initial_state)
      (for_any (_ ! mix input)
        (-> ($ Monad !)
            (-> input mix ($ ! mix))
            (-> mix ($ List input) ($ ! mix))))
      (list#mix (function' (_ partial state)
                           (with_monad !
                             [state state]
                             (mix partial state)))
                (let' [[..#pure pure ..#then _] !]
                      (pure initial_state))))

(the' .private (monad#each ! value)
      (for_any (_ ! input output)
        (-> ($ Monad !)
            (-> input
                ($ ! output))
            (-> ($ List input)
                ($ ! ($ List output)))))
      (monad#mix !
                 (function' (_ head tail)
                            (with_monad !
                              [head (value head)]
                              (pure (.list_composite# tail (list head)))))
                 (list)))

(the' .public if
      Macro
      (macro (_ tokens)
        (.when# (list#as_stack (list#reversed tokens))
                {#Top else then,test/*}
                (.when# (pairs then,test/*)
                        {#Some then,test/*}
                        (meta#pure (list (stack#mix (function' (_ then,test else)
                                                               (.when# then,test
                                                                       [then test]
                                                                       (code#form (list 'when#
                                                                                        test
                                                                                        (code#bit 1b) then
                                                                                        (code#bit 0b) else))))
                                                    else then,test/*)))

                        else
                        (failure ..wrong_syntax))

                _
                (failure ..wrong_syntax))))

(the' .private Property_List
      Type
      (for_any (_ it)
        ($ List (And Text it))))

(the' .private (property#address expected it)
      (for_any (_ it)
        (-> Text ($ Property_List it)
            ($ Maybe Natural)))
      (let' [limit (.list_size# it)]
            ((.is# (for_any (_ it)
                     (-> ($ Property_List it) Natural
                         ($ Maybe Natural)))
                   (function' (_ it)
                              (function' (property#address item)
                                         (if (.int_<# (.as# (-> Natural Integer) limit)
                                                      (.as# (-> Natural Integer) item))
                                             (let' [[actual value] (.list_item# item it)]
                                                   (if (.text_=# expected actual)
                                                       {#Some item}
                                                       (property#address (.i64_+# 1 item))))
                                             {#None}))))
             it 0)))

(the' .private (property#value expected it)
      (for_any (_ it)
        (-> Text ($ Property_List it)
            ($ Maybe it)))
      (.when# (property#address expected it)
              {#Some address}
              (let' [[key value] (.list_item# address it)]
                    {#Some value})

              {#None}
              {#None}))

(the' .private (property#with key value it)
      (for_any (_ it)
        (-> Text it
            ($ Change ($ Property_List it))))
      (.when# (property#address key it)
              {#Some address}
              (list#of_array (.array_has# address [key value] (array#clone (list#as_array it))))
              
              {#None}
              (.list_composite# it (list [key value]))))

... https://en.wikipedia.org/wiki/Delimiter
(the' ..private name_delimiter
      Text
      ".")

(the' ..private (name#as full_name)
      (-> Name
          Text)
      (.when# full_name
              [module name]
              (.when# module
                      "" name
                      _  (text module ..name_delimiter name))))

(the' ..private (default? it)
      (-> Type
          Bit)
      (.when# it
              {#Nominal name_of_type (.list# [1b type_of_default])}
              (.text_=# name_of_type (.type_name# "default"))

              else
              false))

(the' .private (global_name full_name state)
      (-> Name
          ($ Meta Name))
      (let' [[module name] full_name
             [..#info info ..#source    source  ..#current_module _ ..#modules modules
              ..#scopes scopes ..#type_context types ..#seed seed
              ..#expected  expected ..#provenance  provenance ..#eval _eval] state]
            (.when# (property#value module modules)
                    {#Some [..#module_hash _ ..#module_aliases _ ..#definitions definitions ..#imports _ ..#module_state _]}
                    (.when# (property#value name definitions)
                            {#Some [_ constant]}
                            (.when# constant
                                    {#Alias real_name}
                                    {#Right [state real_name]}

                                    {#Definition [type value]}
                                    (if (default? type)
                                        {#Left (text "Unknown definition: " (name#as full_name))}
                                        {#Right [state full_name]}))

                            {#None}
                            {#Left (text "Unknown definition: " (name#as full_name))})
                    
                    {#None}
                    {#Left (text "Unknown module: " module " @ " (name#as full_name))})))

(the' .private (untemplated_text value)
      (-> Text
          Code)
      (code#variant (list ('prelude "#Text")
                          ..no_provenance
                          (code#text value))))

(the' .private UnQuote
      Type
      {#Named [..prelude "UnQuote"]
              {#Nominal ".Macro/UnQuote" (.list#)}})

(the' .private (unquote it)
      (-> Macro
          UnQuote)
      (.as# (-> Macro UnQuote) it))

(the' .private (unquote_macro it)
      (-> UnQuote
          Macro')
      (.as# (-> UnQuote Macro') it))

(the' .private Spliced_UnQuote
      Type
      {#Named [..prelude "Spliced_UnQuote"]
              {#Nominal ".Macro/Spliced_UnQuote" (.list#)}})

(the' .private (spliced_unquote it)
      (-> Macro
          Spliced_UnQuote)
      (.as# (-> Macro Spliced_UnQuote) it))

(the' .private (spliced_unquote_macro it)
      (-> Spliced_UnQuote
          Macro')
      (.as# (-> Spliced_UnQuote Macro') it))

(the' .private (list#one choice it)
      (for_any (_ input output)
        (-> (-> input ($ Maybe output))
            (-> ($ List input) ($ Maybe output))))
      (.when# (.list_size# it)
              limit
              ((.is# (for_any (_ input output)
                       (-> (-> input ($ Maybe output)) ($ List input)
                           (-> Natural ($ Maybe output))))
                     (function' (_ choice it)
                                (function' (list#one item)
                                           (if (.int_<# (.as# (-> Natural Integer) limit)
                                                        (.as# (-> Natural Integer) item))
                                               (.when# (choice (.list_item# item it))
                                                       {#None}
                                                       (list#one (.i64_+# 1 item))

                                                       choice
                                                       choice)
                                               {#None}))))
               choice it 0)))

(the' .private list#conjoint
      (for_any (_ it)
        (-> ($ List ($ List it))
            ($ List it)))
      (list#mix' (function' (_ _ right left)
                            (.list_composite# left right))
                 (list)))

(the' .private (list#all choice it)
      (for_any (_ input output)
        (-> (-> input ($ Maybe output))
            (-> ($ List input) ($ List output))))
      (list#conjoint (list#each (function' (_ it)
                                           (.when# (choice it)
                                                   {#None} (list)
                                                   {#Some it} (list it)))
                                it)))

(the' .private (stack#one f xs)
      (for_any (_ input output)
        (-> (-> input ($ Maybe output)) ($ Stack input)
            ($ Maybe output)))
      (.when# xs
              {#Empty}
              {#None}

              {#Top x xs'}
              (.when# (f x)
                      {#None}
                      (stack#one f xs')

                      {#Some y}
                      {#Some y})))

(the' .private (in_env name state)
      (-> Text Lux
          ($ Maybe Type))
      (let' [[..#info info ..#source    source  ..#current_module _ ..#modules modules
              ..#scopes scopes ..#type_context types ..#seed seed
              ..#expected  expected ..#provenance  provenance ..#eval _eval] state]
            (stack#one (.is# (-> Scope ($ Maybe Type))
                             (function' (_ env)
                                        (let' [[..#locals [..#counter _ ..#mappings locals]
                                                ..#captured _] env]
                                              (list#one (.is# (-> (Tuple Text (Tuple Type Any)) ($ Maybe Type))
                                                              (function' (_ it)
                                                                         (let' [[bname [type _]] it]
                                                                               (if (.text_=# name bname)
                                                                                   {#Some type}
                                                                                   {#None}))))
                                                        locals))))
                       scopes)))

(the' .private (available? expected_module current_module exported?)
      (-> Text ($ Maybe Text) Bit
          Bit)
      (if exported?
          1b
          (.when# current_module
                  {#None}
                  0b
                  
                  {#Some current_module}
                  (.text_=# expected_module current_module))))

(the' .private (and' left right)
      (-> Bit Bit
          Bit)
      (if left
          right
          0b))

(the' .private (definition_value name state)
      (-> Name
          ($ Meta (Tuple Type Any)))
      (let' [[expected_module expected_proper] name
             [..#info info
              ..#source source
              ..#current_module current_module
              ..#modules modules
              ..#scopes scopes
              ..#type_context types
              ..#seed seed
              ..#expected expected
              ..#provenance provenance
              ..#eval _eval] state]
            (.when# (property#value expected_module modules)
                    {#None}
                    {#Left (text "Unknown definition: " (name#as name))}

                    {#Some [..#definitions definitions
                            ..#module_hash _
                            ..#module_aliases _
                            ..#imports _
                            ..#module_state _]}
                    (.when# (property#value expected_proper definitions)
                            {#None}
                            {#Left (text "Unknown definition: " (name#as name))}

                            {#Some [exported? definition]}
                            (.when# definition
                                    {#Alias real_name}
                                    (definition_value real_name state)
                                    
                                    {#Definition [def_type def_value]}
                                    (if (default? def_type)
                                        {#Left (text "No value for default: " (name#as name))}
                                        (if (available? expected_module current_module exported?)
                                            {#Right [state [def_type def_value]]}
                                            {#Left (text "Unavailable definition: " (name#as name))})))))))

(the' .private (global_value global lux)
      (-> Name
          ($ Meta ($ Maybe (Tuple Type Any))))
      (let' [[module proper] global]
            (.when# (.when# module
                            "" (.when# (in_env proper lux)
                                       {#None}
                                       (definition_value global lux)
                                       
                                       {#Some _}
                                       {#Left (text "Not a global value: " (name#as global))})

                            _
                            (definition_value global lux))
                    {#Right [lux' type,value]}
                    {#Right [lux' {#Some type,value}]}
                    
                    {#Left error}
                    {#Right [lux {#None}]})))

(the' .private (bit#= reference it)
      (-> Bit
          (Predicate Bit))
      (if reference
          it
          (not it)))

(the' .private (name#= left right)
      (-> Name
          (Predicate Name))
      (let' [[moduleL properL] left
             [moduleR properR] right]
            (all and'
                 (.text_=# moduleL moduleR)
                 (.text_=# properL properR))))

(the' .private (list#every? ?)
      (for_any (_ it)
        (-> (Predicate it)
            (Predicate ($ List it))))
      (list#mix' (function' (_ _ _2 _1)
                            (if _1
                                (? _2)
                                0b))
                 1b))

(the' .private (natural#minor left right)
      (-> Natural Natural
          Natural)
      (if (.int_<# (.as# (-> Natural Integer) left)
                   (.as# (-> Natural Integer) right))
          right
          left))

(the' .private (list#zipped_2 left right)
      (for_any (_ left right)
        (-> ($ List left) ($ List right)
            ($ List (Tuple left right))))
      (.when# (natural#minor (.list_size# left) (.list_size# right))
              limit
              ((.is# (for_any (_ left right)
                       (-> ($ List left) ($ List right)
                           (-> Natural ($ Change ($ List (Tuple left right))))))
                     (function' (_ left right)
                                (function' (list#zipped_2 item output)
                                           (if (.int_<# (.as# (-> Natural Integer) limit)
                                                        (.as# (-> Natural Integer) item))
                                               (list#zipped_2 (.i64_+# 1 item)
                                                              (.list_composite# output
                                                                                (list [(.list_item# item left)
                                                                                       (.list_item# item right)])))
                                               output))))
               left right 0 (list))))

(the' .private (stack#every? ?)
      (for_any (_ it)
        (-> (Predicate it)
            (Predicate ($ Stack it))))
      (stack#mix (function' (_ _2 _1)
                            (if _1
                                (? _2)
                                0b))
                 1b))

(the' .private (stack#zipped_2 xs ys)
      (for_any (_ left right)
        (-> ($ Stack left) ($ Stack right)
            ($ Stack (Tuple left right))))
      (.when# xs
              {#Top x xs'}
              (.when# ys
                      {#Top y ys'}
                      {#Top [x y] (stack#zipped_2 xs' ys')}

                      _
                      (stack))
              
              _
              (stack)))

(the' .private (type#= left right)
      (-> Type
          (Predicate Type))
      (.when# [left right]
              [{#Nominal nameL parametersL} {#Nominal nameR parametersR}]
              (all and'
                   (.text_=# nameL nameR)
                   (.i64_=# (.list_size# parametersL)
                            (.list_size# parametersR))
                   (list#every? (function' (_ l,r)
                                           (let' [[[polarityL itL] [polarityR itR]] l,r]
                                                 (and' (bit#= polarityL polarityR)
                                                       (type#= itL itR))))
                                (list#zipped_2 parametersL parametersR)))

              [{#Reification leftL rightL} {#Reification leftR rightR}]
              (all and'
                   (type#= leftL leftR)
                   (type#= rightL rightR))

              [{#Parameter parameter_of_reference idL} {#Parameter parameter_of_it idR}]
              (and' (bit#= parameter_of_reference parameter_of_it)
                    (.i64_=# idL idR))

              [{#Variable quality_of_reference idL} {#Variable quality_of_it idR}]
              (and' (bit#= quality_of_reference quality_of_it)
                    (.i64_=# idL idR))

              [{#Quantification quantification_of_reference envL bodyL} {#Quantification quantification_of_it envR bodyR}]
              (all and'
                   (bit#= quantification_of_reference quantification_of_it)
                   (.i64_=# (stack#size envL) (stack#size envR))
                   (stack#every? (function' (_ l,r)
                                            (let' [[[abstraction_of_reference argument_of_reference] [abstraction_of_it argument_of_it]] l,r]
                                                  (and' (type#= abstraction_of_reference abstraction_of_it)
                                                        (type#= argument_of_reference argument_of_it))))
                                 (stack#zipped_2 envL envR))
                   (type#= bodyL bodyR))

              [{#Named nameL anonL} anonR]
              (type#= anonL anonR)

              [anonL {#Named nameR anonR}]
              (type#= anonL anonR)

              _
              0b))

(the' .private (one_expansion it)
      (-> ($ Meta ($ List Code))
          ($ Meta Code))
      (with_monad meta#monad
        [it it]
        (.when# it
                (.list# it)
                (pure it)

                _
                (failure "Must expand to 1 element."))))

(the' .private (current_module_name state)
      ($ Meta Text)
      (.when# state
              [..#info info ..#source    source  ..#current_module current_module ..#modules modules
               ..#scopes scopes ..#type_context types ..#seed seed
               ..#expected  expected ..#provenance  provenance ..#eval _eval]
              (.when# current_module
                      {#Some module_name}
                      {#Right [state module_name]}

                      _
                      {#Left "Cannot get the module name without a module!"})))

(the' .private (normal name)
      (-> Name
          ($ Meta Name))
      (.when# name
              ["" name]
              (with_monad meta#monad
                [module_name ..current_module_name]
                (pure [module_name name]))

              _
              (meta#pure name)))

(the' .private (with_provenance provenance it)
      (-> Provenance
          (-> Code
              Code))
      (.when# it
              {#Bit _ it}
              {#Bit provenance it}

              {#Natural _ it}
              {#Natural provenance it}

              {#Integer _ it}
              {#Integer provenance it}

              {#Revolution _ it}
              {#Revolution provenance it}

              {#Decimal _ it}
              {#Decimal provenance it}

              {#Text _ it}
              {#Text provenance it}

              {#Name _ it}
              {#Name provenance it}

              {#Form _ it}
              {#Form provenance it}

              {#Variant _ it}
              {#Variant provenance it}

              {#Tuple _ it}
              {#Tuple provenance it}
              ))

(the' .private (untemplated_composite tag @composite untemplated replace? subst elements)
      (-> Code Provenance
          (-> Bit Text Code ($ Meta Code))
          (-> Bit Text ($ List Code) ($ Meta Code)))
      (with_monad meta#monad
        [.let' [empty_list ('list (list))
                composite_list (.is# (-> Code Code
                                         Code)
                                     (function' (_ before after)
                                                (code#form (list ('prelude "list_composite#") before after))))
                singleton_list (.is# (-> Code Code)
                                     (function' (_ it) ('list (list it))))
                expanded_list (.is# (-> Code Code ($ Meta Code))
                                    (function' (_ head tail)
                                               (with_monad meta#monad
                                                 [head (untemplated replace? subst head)]
                                                 (pure (composite_list (singleton_list head)
                                                                       tail)))))]
         output (if replace?
                    (monad#mix meta#monad
                               (function' (_ head tail)
                                          (.when# head
                                                  {#Form @composite global,parameters}
                                                  (.when# (list#split 1 global,parameters)
                                                          [(.list# {#Name @name global}) parameters]
                                                          (with_monad meta#monad
                                                            [|global| (..normal global)
                                                             ?type,value (global_value |global|)]
                                                            (.when# ?type,value
                                                                    {#Some [type value]}
                                                                    (if (type#= Spliced_UnQuote type)
                                                                        (with_monad meta#monad
                                                                          [.let' [it (spliced_unquote_macro (.as# (-> Any Spliced_UnQuote) value))]
                                                                           output (one_expansion (it (.list_composite# (list tail) parameters)))]
                                                                          (pure (with_provenance @composite output)))
                                                                        (expanded_list head tail))
                                                                    
                                                                    {#None}
                                                                    (expanded_list head tail)))

                                                          else
                                                          (expanded_list head tail))

                                                  _
                                                  (expanded_list head tail)))
                               empty_list
                               (list#reversed elements))
                    (with_monad meta#monad
                      [=elements (monad#each meta#monad (untemplated replace? subst) elements)]
                      (pure ('list =elements))))]
        (pure (with_provenance @composite
                (code#variant (list tag
                                    ..no_provenance
                                    output))))))

(the' .private untemplated_form
      (-> Provenance
          (-> Bit Text Code ($ Meta Code))
          (-> Bit Text ($ List Code) ($ Meta Code)))
      (untemplated_composite ('prelude "#Form")))

(the' .private untemplated_variant
      (-> Provenance
          (-> Bit Text Code ($ Meta Code))
          (-> Bit Text ($ List Code) ($ Meta Code)))
      (untemplated_composite ('prelude "#Variant")))

(the' .private untemplated_tuple
      (-> Provenance
          (-> Bit Text Code ($ Meta Code))
          (-> Bit Text ($ List Code) ($ Meta Code)))
      (untemplated_composite ('prelude "#Tuple")))

(the' .private (untemplated replace? subst token)
      (-> Bit Text Code
          ($ Meta Code))
      (.when# [replace? token]
              [_ {#Bit @token value}]
              (meta#pure (code#variant (list ('prelude "#Bit")
                                             ..no_provenance
                                             (code#bit value))))

              [_ {#Natural @token value}]
              (meta#pure (code#variant (list ('prelude "#Natural")
                                             ..no_provenance
                                             (code#natural value))))

              [_ {#Integer @token value}]
              (meta#pure (code#variant (list ('prelude "#Integer")
                                             ..no_provenance
                                             (code#integer value))))

              [_ {#Revolution @token value}]
              (meta#pure (code#variant (list ('prelude "#Revolution")
                                             ..no_provenance
                                             (code#revolution value))))
              
              [_ {#Decimal @token value}]
              (meta#pure (code#variant (list ('prelude "#Decimal")
                                             ..no_provenance
                                             (code#decimal value))))

              [_ {#Text @token value}]
              (meta#pure (untemplated_text value))

              [1b {#Name @token [module name]}]
              (with_monad meta#monad
                [real_name (.when# module
                                   ""
                                   (if (.text_=# "" subst)
                                       (pure [module name])
                                       (global_name [subst name]))

                                   _
                                   (pure [module name]))
                 .let' [[module name] real_name]]
                (meta#pure (code#variant (list ('prelude "#Name")
                                               (code#provenance [module 0 0])
                                               (code#tuple (list (code#text module) (code#text name)))))))

              [0b {#Name @token [module name]}]
              (meta#pure (code#variant (list ('prelude "#Name")
                                             (code#provenance @token)
                                             (code#tuple (list (code#text module) (code#text name))))))

              [1b {#Form @composite elements}]
              (.when# (list#split 1 elements)
                      [(.list# {#Name @name global}) parameters]
                      (with_monad meta#monad
                        [|global| (..normal global)
                         ?type,value (global_value |global|)]
                        (.when# ?type,value
                                {#Some [type value]}
                                (if (type#= UnQuote type)
                                    (with_monad meta#monad
                                      [.let' [it (unquote_macro (.as# (-> Any UnQuote) value))]
                                       output (one_expansion (it parameters))]
                                      (pure (with_provenance @composite
                                              output)))
                                    (untemplated_form @composite untemplated replace? subst (.list_composite# (list {#Name @name global}) parameters)))
                                
                                {#None}
                                (untemplated_form @composite untemplated replace? subst (.list_composite# (list {#Name @name global}) parameters))))

                      else
                      (untemplated_form @composite untemplated replace? subst elements))

              [_ {#Form @composite elements}]
              (untemplated_form @composite untemplated replace? subst elements)

              [_ {#Variant @composite elements}]
              (untemplated_variant @composite untemplated replace? subst elements)

              [_ {#Tuple @composite elements}]
              (untemplated_tuple @composite untemplated replace? subst elements)))

(the' .public Nominal
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# {#Text _ class_name})
                (meta#pure (list (code#variant (list '#Nominal (code#text class_name) ('list (list))))))

                (.list# {#Text _ class_name}
                        {#Tuple _ params})
                (meta#pure (list (code#variant (list '#Nominal (code#text class_name) ('list params)))))

                _
                (failure ..wrong_syntax))))

(the' .private 'Code
      Code
      ('prelude "Code"))

(the' .public `
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# template)
                (with_monad meta#monad
                  [current_module current_module_name
                   =template (untemplated 1b current_module template)]
                  (pure (list (code#is ..'Code =template))))

                _
                (failure ..wrong_syntax))))

(the' .public complete_quote Macro `)

(the' .public `'
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# template)
                (with_monad meta#monad
                  [=template (untemplated 1b "" template)]
                  (pure (list (code#is ..'Code =template))))

                _
                (failure ..wrong_syntax))))

(the' .public incomplete_quote Macro `')

(the' .public '
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# template)
                (with_monad meta#monad
                  [=template (untemplated 0b "" template)]
                  (pure (list (code#is ..'Code =template))))

                _
                (failure ..wrong_syntax))))

(the' .public quote Macro ')

(the' .public ,
      UnQuote
      (..unquote
       (macro (_ tokens)
         (.when# tokens
                 (.list# it)
                 (meta#pure (list (code#is ..'Code it)))

                 _
                 (failure ..wrong_syntax)))))

(the' .public but UnQuote ,)

(the' .public ,'
      UnQuote
      (..unquote
       (macro (_ tokens)
         (.when# tokens
                 (.list# it)
                 (with_monad meta#monad
                   [current_module ..current_module_name
                    it (untemplated 0b current_module it)]
                   (pure (list it)))

                 _
                 (failure ..wrong_syntax)))))

(the' .public verbatim UnQuote ,')

(the' .public ,*
      Spliced_UnQuote
      (..spliced_unquote
       (macro (_ tokens)
         (.when# tokens
                 (.list# tail it)
                 (meta#pure (list (` ( .list_composite# (, it) (, tail)))))

                 _
                 (failure ..wrong_syntax)))))

(the' .public also Spliced_UnQuote ,*)

(the' .public |>
      Macro
      (macro (_ tokens)
        (.when# (list#split 1 tokens)
                [(.list# init) apps]
                (meta#pure (list (list#mix (.is# (-> Code Code Code)
                                                 (function' (_ app acc)
                                                            (.when# app
                                                                    {#Variant _ parts}
                                                                    (` {(,* parts) (, acc)})

                                                                    {#Tuple _ parts}
                                                                    (` [(,* parts) (, acc)])

                                                                    {#Form _ parts}
                                                                    (` ((,* parts) (, acc)))

                                                                    _
                                                                    (` ((, app) (, acc))))))
                                           init
                                           apps)))

                _
                (failure ..wrong_syntax))))

(the' .public <|
      Macro
      (macro (_ tokens)
        (.when# (list#split 1 (list#reversed tokens))
                [(.list# init) apps]
                (meta#pure (list (list#mix (.is# (-> Code Code Code)
                                                 (function' (_ app acc)
                                                            (.when# app
                                                                    {#Variant _ parts}
                                                                    (` {(,* parts) (, acc)})

                                                                    {#Tuple _ parts}
                                                                    (` [(,* parts) (, acc)])

                                                                    {#Form _ parts}
                                                                    (` ((,* parts) (, acc)))

                                                                    _
                                                                    (` ((, app) (, acc))))))
                                           init
                                           apps)))

                _
                (failure ..wrong_syntax))))

(the' .private meta#failure
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# 'error)
                (meta#pure (list (` {..#Left (, 'error)})))

                _
                (failure ..wrong_syntax))))

(the' .private meta#return
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# 'lux 'term)
                (meta#pure (list (` {..#Right [(, 'lux) (, 'term)]})))

                _
                (failure ..wrong_syntax))))

(the' .private meta#let
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# 'lux
                        {#Tuple _ (.list# 'binding 'term)}
                        'body)
                (meta#pure (list (` (.when# ((, 'term) (, 'lux))
                                            {..#Right [(, 'lux) (, 'binding)]}
                                            (, 'body)

                                            {..#Left (, 'lux)}
                                            {..#Left (, 'lux)}))))

                _
                (failure ..wrong_syntax))))

(the' .private (function#composite f g)
      (for_any (_ start middle end)
        (-> (-> middle end) (-> start middle)
            (-> start end)))
      (function' (_ x)
                 (f (g x))))

(the' .private (full_name x)
      (-> Code
          ($ Maybe Name))
      (.when# x
              {#Name _ sname}
              {#Some sname}

              _
              {#None}))

(the' .private (proper_name x)
      (-> Code
          ($ Maybe Text))
      (.when# x
              {#Name _ ["" sname]}
              {#Some sname}

              _
              {#None}))

(the' .private (tuple_list tuple)
      (-> Code
          ($ Maybe ($ List Code)))
      (.when# tuple
              {#Tuple _ members}
              {#Some members}

              _
              {#None}))

(the' .private (high_bits value)
      (-> ($ I64 Any)
          I64)
      (.i64_right# 32 value))

(the' .private low_mask
      I64
      (|> 1 (.i64_left# 32) (.i64_-# 1)))

(the' .private (low_bits value)
      (-> ($ I64 Any)
          I64)
      (.i64_and# low_mask value))

(the' .private (natural#< reference it)
      (-> Natural
          (Predicate Natural))
      (let' [referenceH (high_bits reference)
             itH (high_bits it)]
            (if (.int_<# referenceH itH)
                1b
                (if (.i64_=# referenceH itH)
                    (.int_<# (low_bits reference)
                             (low_bits it))
                    0b))))

(the' .public name
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# {#Name _ [module name]})
                (meta#pure (list (code#tuple (list (code#text module) (code#text name)))))

                _
                (failure ..wrong_syntax))))

(the' .private Replacement_Environment
      Type
      ($ Property_List Code))

(the' .private replacement_environment
      (Function ($ List Text) (Function ($ List Code) Replacement_Environment))
      list#zipped_2)

(the' .private (replacement for)
      (Function Text (Function Replacement_Environment ($ Maybe Code)))
      (list#one (function' (_ variable,value)
                           (let' [[variable value] variable,value]
                                 (.when# (.text_=# for variable)
                                         1b {#Some value}
                                         0b {#None})))))

(the' .private (realized_template env template)
      (-> Replacement_Environment
          ($ Change Code))
      (.when# template
              {#Name _ ["" sname]}
              (.when# (..replacement sname env)
                      {#Some subst}
                      subst

                      _
                      template)

              {#Form meta it}
              {#Form meta (list#each (realized_template env) it)}

              {#Tuple meta it}
              {#Tuple meta (list#each (realized_template env) it)}

              {#Variant meta it}
              {#Variant meta (list#each (realized_template env) it)}

              _
              template))

(the' .private with_template
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# {#Tuple _ bindings} {#Tuple _ templates} {#Tuple _ data})
                (.when# [(monad#each maybe#monad ..proper_name bindings)
                         (monad#each maybe#monad ..tuple_list data)]
                        [{#Some bindings'} {#Some data'}]
                        (let' [reification (.is# (-> Replacement_Environment ($ List Code))
                                                 (function' (_ env)
                                                            (list#each (realized_template env)
                                                                       templates)))
                               num_bindings (.list_size# bindings')]
                              (if (list#every? (function' (_ it) (|> it .list_size# (.i64_=# num_bindings)))
                                               data')
                                  (|> data'
                                      (list#each (all function#composite
                                                      reification
                                                      (replacement_environment bindings')))
                                      list#conjoint
                                      meta#pure)
                                  (failure ..wrong_syntax)))

                        _
                        (failure ..wrong_syntax))

                _
                (failure ..wrong_syntax))))

(the' .public these
      Macro
      (macro (_ tokens compiler)
        {#Right [compiler tokens]}))

(these (the' .private (list#item address it)
             (for_any (_ it)
               (-> Natural ($ List it)
                   ($ Maybe it)))
             (if (natural#< (.list_size# it) address)
                 {#Some (.list_item# address it)}
                 {#None}))

       (the' .private (natural#next it)
             ($ Change Natural)
             (.i64_+# 1 it))

       (the' .private Projection
             Type
             {#Named [..prelude "Projection"]
                     (for_any (_ it)
                       (-> (And Natural ($ List Code))
                           ($ Maybe (And (And Natural ($ List Code)) it))))})

       (the' .private (?#pure it tape)
             (for_any (_ it)
               (-> it
                   ($ Projection it)))
             {#Some [tape it]})

       (the' .private (?#each value it
                              tape)
             (for_any (_ cause effect)
               (-> (-> cause
                       effect)
                   (-> ($ Projection cause)
                       ($ Projection effect))))
             (.when# (it tape)
                     {#Some [tape it]}
                     {#Some [tape (value it)]}

                     {#None}
                     {#None}))

       (the' .private (?#value tape projection)
             (for_any (_ it)
               (-> ($ List Code) ($ Projection it)
                   ($ Maybe it)))
             (let' [expected (.list_size# tape)]
                   (.when# (projection [0 tape])
                           {#Some [[items_read _] it]}
                           (if (.i64_=# expected items_read)
                               {#Some it}
                               {#None})

                           _
                           {#None})))

       (the' .private (?#or left right tape)
             (for_any (_ left right)
               (-> ($ Projection left) ($ Projection right)
                   ($ Projection (Or left right))))
             (.when# (left tape)
                     {#Some [tape left]}
                     {#Some [tape {#Left left}]}

                     _
                     (.when# (right tape)
                             {#Some [tape right]}
                             {#Some [tape {#Right right}]}

                             _
                             {#None})))

       (the' .private (?#either left right tape)
             (for_any (_ it)
               (-> ($ Projection it)
                   ($ Change ($ Projection it))))
             (.when# (left tape)
                     {#None}
                     (right tape)

                     some
                     some))

       (the' .private (?#and left right tape)
             (for_any (_ left right)
               (-> ($ Projection left) ($ Projection right)
                   ($ Projection (And left right))))
             (with_monad maybe#monad
               [left (left tape)
                .let' [[tape left] left]
                right (right tape)
                .let' [[tape right] right]]
               (pure [tape [left right]])))

       (the' .private (?#after left right tape)
             (for_any (_ _ it)
               (-> ($ Projection _)
                   ($ Change ($ Projection it))))
             (with_monad maybe#monad
               [left (left tape)
                .let' [[tape left] left]]
               (right tape)))

       (the' .private (?#some it tape)
             (for_any (_ it)
               (-> ($ Projection it)
                   ($ Projection ($ List it))))
             (.when# (it tape)
                     {#Some [tape head]}
                     (with_monad maybe#monad
                       [tail (?#some it tape)
                        .let' [[tape tail] tail]]
                       (pure [tape (.list_composite# (list head) tail)]))

                     {#None}
                     {#Some [tape (list)]}))

       (the' .private (?#rest tape)
             ($ Projection ($ List Code))
             (let' [[to_skip tape] tape]
                   {#Some [[(.list_size# tape) tape]
                           (list#after to_skip tape)]}))

       (the' .private (?#many it tape)
             (for_any (_ it)
               (-> ($ Projection it)
                   ($ Projection ($ List it))))
             (with_monad maybe#monad
               [head (it tape)
                .let' [[tape head] head]
                tail (?#some it tape)
                .let' [[tape tail] tail]]
               (pure [tape (.list_composite# (list head) tail)])))

       (the' .private (?#maybe it tape)
             (for_any (_ it)
               (-> ($ Projection it)
                   ($ Projection ($ Maybe it))))
             (.when# (it tape)
                     {#Some [tape it]}
                     {#Some [tape {#Some it}]}

                     {#None}
                     {#Some [tape {#None}]}))

       (with_template [,name ,tag]
         [(the' .private (,name it tape)
                (for_any (_ it)
                  ($ Change ($ Projection it)))
                (let' [[address tape] tape]
                      (.when# (list#item address tape)
                              {#Some {,tag _ complex}}
                              (with_monad maybe#monad
                                [it (?#value complex it)]
                                (pure [[(natural#next address) tape]
                                       it]))

                              else
                              {#None})))]

         [[?#variant #Variant]
          [?#tuple #Tuple]
          [?#form #Form]])

       (the' .private (?#binding tape)
             ($ Projection (And Text Code))
             (let' [[address tape] tape
                    address_of_value (natural#next address)]
                   (.when# [(list#item address tape)
                            (list#item address_of_value tape)]
                           [{#Some {#Name _ ["" name]}} {#Some value}]
                           {#Some [[(natural#next address_of_value) tape]
                                   [name value]]}

                           _
                           {#None})))

       (the' .private (?#any tape)
             ($ Projection Code)
             (let' [[address tape] tape]
                   (.when# (list#item address tape)
                           {#Some it}
                           {#Some [[(natural#next address) tape]
                                   it]}

                           else
                           {#None})))

       (the' .private (?#local tape)
             ($ Projection Text)
             (let' [[address tape] tape]
                   (.when# (list#item address tape)
                           {#Some {#Name _ ["" it]}}
                           {#Some [[(natural#next address) tape]
                                   it]}

                           else
                           {#None})))

       (the' .private (?#global tape)
             ($ Projection Name)
             (let' [[address tape] tape]
                   (.when# (list#item address tape)
                           {#Some {#Name _ ["" _]}}
                           {#None}

                           {#Some {#Name _ it}}
                           {#Some [[(natural#next address) tape]
                                   it]}

                           else
                           {#None})))

       (with_template [,name ,type ,tag]
         [(the' .private (,name tape)
                ($ Projection ,type)
                (let' [[address tape] tape]
                      (.when# (list#item address tape)
                              {#Some {,tag _ it}}
                              {#Some [[(natural#next address) tape]
                                      it]}

                              else
                              {#None})))]

         [[?#bit Bit #Bit]
          [?#natural Natural #Natural]
          [?#text Text #Text]
          [?#name Name #Name]])

       (the' .private (?#this_name reference tape)
             (-> Name
                 ($ Projection Any))
             (.when# (?#name tape)
                     {#Some [tape it]}
                     (if (name#= reference it)
                         {#Some [tape []]}
                         {#None})

                     else
                     {#None}))
       )

(the' .private (natural#/ param subject)
      (-> Natural
          ($ Change Natural))
      (if (.int_<# +0 (.as# (-> Natural Integer) param))
          (if (natural#< param subject)
              0
              1)
          (let' [quotient (|> subject
                              (.i64_right# 1)
                              (.int_/# (.as# (-> Natural Integer) param))
                              (.i64_left# 1))
                 flat (.int_x# (.as# (-> Natural Integer) param)
                               (.as# (-> Natural Integer) quotient))
                 remainder (.i64_-# flat subject)]
                (if (natural#< param remainder)
                    quotient
                    (.i64_+# 1 quotient)))))

(the' .private (natural#% param subject)
      (-> Natural
          ($ Change Natural))
      (let' [flat (.int_x# (.as# (-> Natural Integer) param)
                           (.as# (-> Natural Integer) (natural#/ param subject)))]
            (.i64_-# flat subject)))

(the' .private (bit#as_text it)
      (-> Bit
          Text)
      (if it
          "1b"
          "0b"))

(the' .private (digit::injection digit)
      (-> Natural
          Text)
      (.when# digit
              [0] "0"
              [1] "1" [2] "2" [3] "3"
              [4] "4" [5] "5" [6] "6"
              [7] "7" [8] "8" [9] "9"
              _ (.error# "@digit::injection Undefined behavior.")))

(the' .private (natural#as value)
      (-> Natural
          Text)
      (.when# value
              [0] "0"
              _ (let' [loop (.is# (-> Natural ($ Change Text))
                                  (function' (again input output)
                                             (if (.i64_=# 0 input)
                                                 output
                                                 (again (natural#/ 10 input)
                                                        (text (|> input (natural#% 10) digit::injection)
                                                              output)))))]
                      (loop value ""))))

(the' .private (integer#abs value)
      ($ Change Integer)
      (if (.int_<# +0 value)
          (.int_x# -1 value)
          value))

(the' .private (integer#as value)
      (-> Integer
          Text)
      (if (.i64_=# +0 value)
          "+0"
          (let' [sign (if (.int_<# value +0)
                          "+"
                          "-")]
                ((.is# (-> Integer ($ Change Text))
                       (function' (again input output)
                                  (if (.i64_=# +0 input)
                                      (text sign output)
                                      (again (.int_/# +10 input)
                                             (text (|> input (.int_%# +10) (.as# (-> Integer Natural)) digit::injection)
                                                   output)))))
                 (|> value (.int_/# +10) integer#abs)
                 (|> value (.int_%# +10) integer#abs (.as# (-> Integer Natural)) digit::injection)))))

(the' .private (named_macro' modules current_module module name)
      (-> ($ Property_List Module) Text Text Text
          ($ Maybe Macro))
      (with_monad maybe#monad
        [$module (property#value module modules)
         exported?,gdef (let' [[..#module_hash _ ..#module_aliases _ ..#definitions bindings ..#imports _ ..#module_state _] (.is# Module $module)]
                              (property#value name bindings))
         .let' [[exported? gdef] exported?,gdef]]
        (.when# (.is# Global gdef)
                {#Alias [r_module r_name]}
                (named_macro' modules current_module r_module r_name)

                {#Definition [def_type def_value]}
                (if (type#= ..Macro def_type)
                    (if exported?
                        {#Some (.as# (-> Any Macro) def_value)}
                        (if (.text_=# module current_module)
                            {#Some (.as# (-> Any Macro) def_value)}
                            {#None}))
                    {#None}))))

(the' .private (named_macro full_name)
      (-> Name
          ($ Meta ($ Maybe Macro)))
      (<| (function' (_ lux))
          (meta#let lux [current_module current_module_name])
          (let' [[module name] full_name
                 [..#info info ..#source source ..#current_module _ ..#modules modules
                  ..#scopes   scopes   ..#type_context   types ..#seed   seed
                  ..#expected expected ..#provenance provenance ..#eval _eval] lux])
          (meta#return lux (named_macro' modules current_module module name))))

(the' .private (macro? name)
      (-> Name
          ($ Meta Bit))
      (<| (function' (_ lux))
          (meta#let lux [name (normal name)])
          (meta#let lux [output (named_macro name)])
          (meta#return lux (.when# output
                                   {#Some _} 1b
                                   {#None}   0b))))

(the' .private (text#as original)
      (-> Text
          Text)
      (text \'' original \''))

(the' .private (text#enclosed delimiters it)
      (-> (Product Text Text)
          ($ Change Text))
      (.when# delimiters
              [<' '>]
              (text <' it '>)))

(the' .private (list#interposed delimiter it)
      (for_any (_ it)
        (-> it
            ($ Change ($ List it))))
      (.when# (.list_size# it)
              0 it
              1 it
              
              size
              (let' [interpositions (.i64_-# 1 size)
                     new_size (.i64_+# interpositions size)]
                    (|> it
                        (list#mix' (function' (_ address item it)
                                              (let' [address (.i64_+# address address)]
                                                    (|> it
                                                        (.array_has# address item)
                                                        (.array_has# (.i64_+# 1 address) delimiter))))
                                   (.array# new_size))
                        (.as# (for_any (_ it)
                                (-> ($ Array it)
                                    ($ List it))))))))

(the' .private (text#composite x y)
      (-> Text Text
          Text)
      (text x y))

(the' .private (code#as_text code)
      (-> Code
          Text)
      (.when# code
              {#Bit _ value}
              (bit#as_text value)

              {#Natural _ value}
              (natural#as value)

              {#Integer _ value}
              (integer#as value)

              {#Revolution _ value}
              (.error# "@code#as_text Undefined behavior.")
              
              {#Decimal _ value}
              (.error# "@code#as_text Undefined behavior.")

              {#Text _ value}
              (text#as value)
              
              {#Name _ [module name]}
              (name#as [module name])
              
              {#Form _ it}
              (|> it
                  (list#each code#as_text)
                  (list#interposed " ")
                  list#reversed
                  (list#mix text#composite "")
                  (text#enclosed ["(" ")"]))
              
              {#Tuple _ it}
              (|> it
                  (list#each code#as_text)
                  (list#interposed " ")
                  list#reversed
                  (list#mix text#composite "")
                  (text#enclosed ["[" "]"]))
              
              {#Variant _ it}
              (|> it
                  (list#each code#as_text)
                  (list#interposed " ")
                  list#reversed
                  (list#mix text#composite "")
                  (text#enclosed ["{" "}"]))))

(the' .private (single_expansion token)
      (-> Code
          ($ Meta ($ List Code)))
      (.when# (?#value (list token)
                       (?#form (?#and ?#name ?#rest)))
              {#Some [name args]}
              (<| (function' (_ lux))
                  (meta#let lux [name' (normal name)])
                  (meta#let lux [?macro (named_macro name')])
                  (.when# ?macro
                          {#Some macro}
                          (((.as# (-> Macro Macro') macro) args) lux)
                          
                          {#None}
                          (meta#return lux (list token))))

              _
              (meta#pure (list token))))

(the' .private (complete_expansion token)
      (-> Code
          ($ Meta ($ List Code)))
      (.when# (?#value (list token)
                       (?#form (?#and ?#name ?#rest)))
              {#Some [name args]}
              (<| (function' (_ lux))
                  (meta#let lux [name' (normal name)])
                  (meta#let lux [?macro (named_macro name')])
                  (.when# ?macro
                          {#Some macro}
                          (<| (meta#let lux [maximum_level_expansion ((.as# (-> Macro Macro') macro) args)])
                              (meta#let lux [recursive_expansion (.is# ($ Meta ($ List ($ List Code)))
                                                                       (monad#each meta#monad complete_expansion maximum_level_expansion))])
                              (meta#return lux (list#conjoint recursive_expansion)))
                          
                          {#None}
                          (meta#return lux (list token))))

              _
              (meta#pure (list token))))

(the' .public exec
      Macro
      (macro (_ tokens)
        (.when# (?#value (list#reversed tokens)
                         (?#and ?#any ?#rest))
                {#Some [value actions]}
                (let' [dummy (code#local "")]
                      (meta#pure (list (list#mix (.is# (-> Code ($ Change Code))
                                                       (function' (_ pre post)
                                                                  (` (.when# (, pre)
                                                                             (, dummy)
                                                                             (, post)))))
                                                 value
                                                 actions))))

                else
                (failure ..wrong_syntax))))

(the' .private (type_reification abstraction parameters)
      (-> Code ($ List Code)
          Code)
      (list#mix (.is# (-> Code ($ Change Code))
                      (function' (_ parameter abstraction)
                                 (` {..#Reification (, parameter) (, abstraction)})))
                abstraction
                parameters))

(the' .private (normal_type_reification normal_type abstraction parameters)
      (-> (-> Code ($ Meta Code)) Code ($ List Code)
          ($ Meta Code))
      (<| (function' (_ lux))
          (meta#let lux [parameters (.is# ($ Meta ($ List Code))
                                          (monad#each meta#monad normal_type parameters))])
          (meta#return lux (type_reification abstraction parameters))))

(the' .private (expanded_type_reification normal_type @ binding parameters)
      (-> (-> Code ($ Meta Code)) Provenance Name ($ List Code)
          ($ Meta Code))
      (<| (function' (_ lux))
          (meta#let lux [binding (normal binding)])
          (meta#let lux [?macro (named_macro binding)])
          (.when# ?macro
                  {#Some macro}
                  (<| (meta#let lux [expansion ((.as# (-> Macro Macro') macro) parameters)])
                      (.when# expansion
                              (.list# singular)
                              (meta#return lux (` (..type (, singular))))

                              else
                              (meta#failure "The expansion of the type-syntax has to yield a single element.")))
                  
                  {#None}
                  ((normal_type_reification normal_type {#Name @ binding} parameters) lux))))

(the' .private (normal_type type' it)
      ($ Change (-> Code ($ Meta Code)))
      (.when# it
              {#Variant _ (.list# {#Name _ ["library/lux" "#Named"]}
                                  name
                                  anonymous)}
              (<| (function' (_ lux))
                  (meta#let lux [anonymous (normal_type type' anonymous)])
                  (meta#return lux (` {..#Named (, name) (, anonymous)})))

              {#Form _ (.list# {#Name _ ["library/lux" "in_module#"]}
                               {#Text _ module}
                               it')}
              (<| (function' (_ lux))
                  (meta#let lux [it' (normal_type type' it')])
                  (meta#return lux (` (.in_module# (, (code#text module)) (, it')))))

              {#Form _ (.list# {#Name _ ["" ","]}
                               expression)}
              (meta#pure expression)

              {#Form @form (.list# {#Name @name ["library/lux" "when#"]}
                                   value
                                   binding
                                   body)}
              (<| (function' (_ lux))
                  (meta#return lux {#Form @form (list {#Name @name ["library/lux" "when#"]}
                                                      value
                                                      binding
                                                      (` (..type (, body))))}))

              {#Form @form (.list# {#Name @name ["library/lux" "__adjusted_quantified_type__"]}
                                   _permission
                                   _level
                                   body)}
              (<| (function' (_ lux))
                  (meta#let lux [body (normal_type type' body)])
                  (meta#return lux {#Form @form (list {#Name @name [..prelude "__adjusted_quantified_type__"]}
                                                      _permission
                                                      _level
                                                      body)}))

              {#Form _ (.list# {#Form _ (.list# {#Name _ ["library/lux" "in_module#"]}
                                                {#Text _ "library/lux"}
                                                {#Name _ ["library/lux" "type"]})}
                               it')}
              (type' it')

              {#Variant _ it}
              (<| (function' (_ lux))
                  (meta#let lux [it (.is# ($ Meta ($ List Code))
                                          (monad#each meta#monad (normal_type type') it))])
                  (meta#return lux (` {(,* it)})))

              {#Tuple _ (.list# {#Bit _ polarity} it)}
              (<| (function' (_ lux))
                  (meta#let lux [it (.is# ($ Meta Code)
                                          (normal_type type' it))])
                  (meta#return lux (` [(, (code#bit polarity)) (, it)])))

              {#Tuple _ it}
              (<| (function' (_ lux))
                  (meta#let lux [it (.is# ($ Meta ($ List Code))
                                          (monad#each meta#monad (normal_type type') it))])
                  (meta#return lux (` (Tuple (,* it)))))

              {#Form _ binding,parameters}
              (.when# (list#split 1 binding,parameters)
                      [(.list# {#Name @name ["library/lux" "list#"]})
                       members]
                      (<| (function' (_ lux))
                          (meta#let lux [members (.is# ($ Meta ($ List Code))
                                                       (monad#each meta#monad (normal_type type') members))])
                          (meta#return lux ('list members)))

                      [(.list# {#Name @binding binding})
                       parameters]
                      (<| (function' (_ lux))
                          (.when# binding
                                  ["" local]
                                  (.when# (in_env local lux)
                                          {#Some type_of_local}
                                          ((normal_type_reification (normal_type type') {#Name @binding binding} parameters) lux)
                                          
                                          not_a_local
                                          ((expanded_type_reification (normal_type type') @binding binding parameters) lux))
                                  
                                  [module global]
                                  ((expanded_type_reification (normal_type type') @binding binding parameters) lux)))

                      [(.list# type_fn)
                       args]
                      (<| (function' (_ lux))
                          (meta#let lux [type_fn (normal_type type' type_fn)])
                          (meta#let lux [args (.is# ($ Meta ($ List Code))
                                                    (monad#each meta#monad (normal_type type') args))])
                          (meta#return lux (type_reification type_fn args)))

                      _
                      (meta#pure it))

              _
              (meta#pure it)))

(the' .private (with_quantification' body lux)
      ($ Change ($ Meta Code))
      (let' [[..#info info/pre
              ..#source source/pre
              ..#current_module current_module/pre
              ..#modules modules/pre
              ..#scopes scopes/pre
              ..#type_context type_context/pre
              ..#seed seed/pre
              ..#expected expected/pre
              ..#provenance provenance/pre
              ..#eval eval/pre] lux]
            (.when# (body [..#info info/pre
                           ..#source source/pre
                           ..#current_module current_module/pre
                           ..#modules modules/pre
                           ..#scopes {#Top [#locals [#counter 0
                                                     #mappings (list [..quantification_level [.Natural (.as# (-> Integer Natural) -1)]])]
                                            #captured [#counter 0
                                                       #mappings (list)]]
                                           scopes/pre}
                           ..#type_context type_context/pre
                           ..#seed seed/pre
                           ..#expected expected/pre
                           ..#provenance provenance/pre
                           ..#eval eval/pre])
                    {..#Right [lux/post output]}
                    (let' [[..#info info/post
                            ..#source source/post
                            ..#current_module current_module/post
                            ..#modules modules/post
                            ..#scopes scopes/post
                            ..#type_context type_context/post
                            ..#seed seed/post
                            ..#expected expected/post
                            ..#provenance provenance/post
                            ..#eval eval/post] lux/post]
                          {..#Right [[..#info info/post
                                      ..#source source/post
                                      ..#current_module current_module/post
                                      ..#modules modules/post
                                      ..#scopes scopes/pre
                                      ..#type_context type_context/post
                                      ..#seed seed/post
                                      ..#expected expected/post
                                      ..#provenance provenance/post
                                      ..#eval eval/post]
                                     output]})
                    
                    failure
                    failure)))

(the' .private (type' it)
      (-> Code
          ($ Meta Code))
      (<| (function' (_ lux))
          (if (initialized_quantification? lux)
              ((normal_type type' it) lux)
              (<| (meta#let lux [it (with_quantification'
                                      (type' it))])
                  (meta#return lux (..quantified it))))))

(the' .public type
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# it)
                (<| (function' (_ lux))
                    (meta#let lux [it (type' it)])
                    (meta#return lux (list it)))

                _
                (failure ..wrong_syntax))))

(the' .public is
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# type term)
                (meta#pure (list (` (.is# (..type (, type))
                                          (, term)))))

                _
                (failure ..wrong_syntax))))

(the' .public as
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# type value)
                (meta#pure (list (` (.as# (..type (, type))
                                          (, value)))))

                _
                (failure ..wrong_syntax))))

(with_template [<name> <side>]
  [(the' .private (<name> left,right)
         (for_any (_ left right)
           (-> (Tuple left right)
               <side>))
         (let' [[left right] left,right]
               <side>))]

  [[product#left  left]
   [product#right right]])

(the' .private (generated_name prefix state)
      (-> Text
          ($ Meta Code))
      (.when# state
              [..#info info ..#source source ..#current_module _ ..#modules modules
               ..#scopes   scopes   ..#type_context   types ..#seed   seed
               ..#expected expected ..#provenance provenance ..#eval _eval]
              {#Right [..#info info ..#source source ..#current_module _ ..#modules modules
                       ..#scopes   scopes   ..#type_context   types ..#seed   (.i64_+# 1 seed)
                       ..#expected expected ..#provenance provenance ..#eval _eval]
                      (code#local (text "__gensym__" prefix (natural#as seed)))}))

(the' .private (flat_reification it)
      (type (-> Type
                [Type (List Type)]))
      (.when# it
              {#Reification head func'}
              (let' [[abstraction tail] (flat_reification func')]
                    [abstraction (.list_composite# (list head) tail)])

              _
              [it (list)]))

(the' .private (type#as_text type)
      (-> Type
          Text)
      (.when# type
              {#Nominal name params}
              (text "(Nominal " (text#as name)
                    (|> params
                        (list#each (function' (_ it)
                                              (.when# it
                                                      [polarity it]
                                                      (text " "
                                                            "[" (bit#as_text polarity)
                                                            " " (type#as_text it)
                                                            "]"))))
                        list#reversed
                        (list#mix' (function' (_ _ left right) (text left right))
                                   ""))
                    ")")

              {#Parameter parameter id}
              (text "(" (if parameter
                            "argument"
                            "abstraction")
                    " " (natural#as id)
                    ")")
              
              {#Variable quality id}
              (if (bit#= .general quality)
                  (text "-" (natural#as id))
                  (text "+" (natural#as id)))

              {#Quantification quantification env body}
              (text "("
                    (if (bit#= .universal quantification)
                        "for_any"
                        "for_some")
                    " "
                    (type#as_text body)
                    ")")

              {#Reification _}
              (let' [[func args] (flat_reification type)]
                    (text "(" (type#as_text func) " "
                          (|> args
                              (list#each type#as_text)
                              (list#interposed " ")
                              list#reversed
                              (list#mix text#composite ""))
                          ")"))
              
              {#Named name _}
              (name#as name)))

(the' .private (meta#try it)
      (type (for_any (_ it)
              (-> (Meta it)
                  (Meta (Either Text it)))))
      (function' (_ state)
                 (.when# (it state)
                         {#Left error}
                         {#Right [state {#Left error}]}
                         
                         {#Right [state output]}
                         {#Right [state {#Right output}]})))

(the' .private (anonymous_type it)
      ($ Change Type)
      (.when# it
              {#Named _ it}
              (anonymous_type it)
              
              _
              it))

(the' .private error#the
      Macro
      (macro (_ tokens)
        (meta#pure (list (` (..the' ..public (,* tokens)
                                    Error
                                    (name#as (..name (,* tokens)))))))))

(error#the not_a_static_value)

(the' .private static'
      (type (-> Bit Code
                (Meta Code)))
      (let' [simple_literal (is (-> Name
                                    (Meta Code))
                                (function' (_ name)
                                           (with_monad meta#monad
                                             [type+value (meta#try (definition_value name))]
                                             (.when# type+value
                                                     {#Left error}
                                                     (pure (code#name name))
                                                     
                                                     {#Right [type value]}
                                                     (.when# (anonymous_type type)
                                                             {#Nominal name_of_type (.list#)}
                                                             (if (.text_=# name_of_type (.type_name# "bit"))
                                                                 (pure (code#bit (as (-> Any Bit) value)))

                                                                 (.text_=# name_of_type (.type_name# "decimal"))
                                                                 (pure (code#decimal (as (-> Any Decimal) value)))

                                                                 (.text_=# name_of_type (.type_name# "text"))
                                                                 (pure (code#text (as (-> Any Text) value)))

                                                                 (if (.text_=# name_of_type (.type_name# "tag"))
                                                                     1b
                                                                     ... else
                                                                     (.text_=# name_of_type (.type_name# "slot")))
                                                                 (pure (code#name name))

                                                                 ... else
                                                                 (failure (text ..not_a_static_value " "  name_of_type)))

                                                             {#Nominal name_of_type (.list# [1b {#Nominal name_of_specialization (.list#)}])}
                                                             (if (.text_=# name_of_type (.type_name# "i64"))
                                                                 (if (.text_=# name_of_specialization (.type_name# "natural"))
                                                                     (pure (code#natural (as (-> Any Natural) value)))

                                                                     (.text_=# name_of_specialization (.type_name# "integer"))
                                                                     (pure (code#integer (as (-> Any Integer) value)))

                                                                     (.text_=# name_of_specialization (.type_name# "revolution"))
                                                                     (pure (code#revolution (as (-> Any Revolution) value)))

                                                                     ... else
                                                                     (failure (text ..not_a_static_value " "  name_of_type)))

                                                                 ... else
                                                                 (failure (text ..not_a_static_value " "  name_of_type)))

                                                             else
                                                             (failure (text ..not_a_static_value " " (type#as_text else))))))))]
            (function' (literal only_global? token)
                       (.when# token
                               {#Name _ [def_module def_name]}
                               (if (.text_=# "" def_module)
                                   (if only_global?
                                       (meta#pure (code#name [def_module def_name]))
                                       (with_monad meta#monad
                                         [current_module current_module_name]
                                         (simple_literal [current_module def_name])))
                                   (simple_literal [def_module def_name]))

                               {#Form meta parts}
                               (with_monad meta#monad
                                 [=parts (monad#each meta#monad (literal only_global?) parts)]
                                 (pure {#Form meta =parts}))

                               {#Variant meta parts}
                               (with_monad meta#monad
                                 [=parts (monad#each meta#monad (literal only_global?) parts)]
                                 (pure {#Variant meta =parts}))

                               {#Tuple meta parts}
                               (with_monad meta#monad
                                 [=parts (monad#each meta#monad (literal only_global?) parts)]
                                 (pure {#Tuple meta =parts}))

                               _
                               ... TODO: Figure out why this doesn't work:
                               ... (meta#pure token)
                               (meta#pure token)))))

(the' .public static
      Macro
      (macro (_ tokens)
        (.when# tokens
                (.list# pattern)
                (with_monad meta#monad
                  [pattern' (static' 0b pattern)]
                  (pure (list pattern')))
                
                _
                (failure ..wrong_syntax))))

(the' .public Pattern
      Type
      {#Named [..prelude "Pattern"]
              (Nominal ".Macro/Pattern")})

(the' .public (pattern it)
      (-> Macro
          Pattern)
      (as (-> Macro Pattern)
          it))

(the' .private (total_expansion' total_expansion name args)
      (-> (-> Code ($ Meta ($ List Code))) Name ($ List Code)
          ($ Meta ($ List Code)))
      (<| (function' (_ lux))
          (meta#let lux [name' (normal name)])
          (meta#let lux [?macro (named_macro name')])
          (.when# ?macro
                  {#Some macro}
                  (<| (meta#let lux [expansion ((as (-> Macro Macro') macro) args)])
                      (meta#let lux [expansion' (.is# ($ Meta ($ List ($ List Code)))
                                                      (monad#each meta#monad total_expansion expansion))])
                      (meta#return lux (list#conjoint expansion')))
                  
                  {#None}
                  (<| (meta#let lux [args' (.is# ($ Meta ($ List ($ List Code)))
                                                 (monad#each meta#monad total_expansion args))])
                      (meta#return lux (list (` ((, (code#name name)) (,* (list#conjoint args'))))))))))

(the' .private (total_expansion syntax)
      (type (-> Code
                (Meta (List Code))))
      (.when# (|> (all ?#or
                       (?#variant ?#rest)
                       (?#tuple ?#rest)
                       (?#form (?#and ?#name ?#rest))
                       (?#form ?#rest))
                  (.is# (type (Projection (Or (List Code)
                                              (List Code)
                                              (Or [Name (List Code)]
                                                  (List Code))))))
                  (?#value (list syntax)))
              {#Some {0 0b variant}}
              (<| (function' (_ lux))
                  (meta#let lux [variant (.is# (type (Meta (List (List Code))))
                                               (monad#each meta#monad total_expansion variant))])
                  (meta#return lux (list (code#variant (list#conjoint variant)))))
              
              {#Some {1 0b tuple}}
              (<| (function' (_ lux))
                  (meta#let lux [tuple (.is# (type (Meta (List (List Code))))
                                             (monad#each meta#monad total_expansion tuple))])
                  (meta#return lux (list (code#tuple (list#conjoint tuple)))))

              {#Some {2 0b [name tail]}}
              (..total_expansion' total_expansion name tail)
              
              {#Some {2 1b form}}
              (<| (function' (_ lux))
                  (meta#let lux [form (.is# (type (Meta (List (List Code))))
                                            (monad#each meta#monad total_expansion form))])
                  (meta#return lux (list (code#form (list#conjoint form)))))
              
              else
              (meta#pure (list syntax))))

(the' .private (when_expansion#macro pattern body
                                     when_expansion branches)
      (type (-> Code Code
                (Change (-> (List Code) (Meta (List Code))))))
      (with_monad meta#monad
        [pattern (one_expansion (total_expansion pattern))
         pattern (static' 1b pattern)
         branches (when_expansion branches)]
        (pure (.list_composite# (list pattern body)
                                branches))))

(the' .private (when_expansion branches)
      (type (-> (List Code)
                (Meta (List Code))))
      (.when# (|> (?#or (all ?#and
                             (?#or (?#form (?#and ?#name ?#rest))
                                   ?#any)
                             ?#any
                             ?#rest)
                        (?#pure []))
                  (?#value branches))
              {#Some {#Left [global|pattern body branches']}}
              (.when# global|pattern
                      {#Left [global parameters]}
                      (with_monad meta#monad
                        [|global| (..normal global)
                         ?type,value (global_value |global|)]
                        (.when# ?type,value
                                {#Some [type value]}
                                (if (type#= Pattern type)
                                    (with_monad meta#monad
                                      [branches'' ((as (-> Any Macro') value)
                                                   (.list_composite# (list (code#form parameters) body)
                                                                     branches'))]
                                      (when_expansion branches''))
                                    (when_expansion#macro (` ((, (code#name global)) (,* parameters)))
                                                          body
                                                          when_expansion
                                                          branches'))
                                
                                {#None}
                                (when_expansion#macro (` ((, (code#name global)) (,* parameters)))
                                                      body
                                                      when_expansion
                                                      branches')))

                      {#Right pattern}
                      (when_expansion#macro pattern body when_expansion branches'))

              {#Some {#Right _}}
              (meta#pure (list))
              
              else
              (failure ..wrong_syntax)))

(the' .public when
      Macro
      (macro (_ tokens)
        (.when# (|> (?#and ?#any ?#rest)
                    (?#value tokens))
                {#Some [value branches]}
                (with_monad meta#monad
                  [expansion (when_expansion branches)]
                  (pure (list (` (.when# (, value) (,* expansion))))))

                else
                (failure ..wrong_syntax))))

(the' .public let
      Macro
      (macro (_ tokens)
        (when (|> (?#and (?#tuple (?#some (?#and ?#any ?#any)))
                         ?#any)
                  (?#value tokens))
          {#Some [bindings body]}
          (|>  bindings
               list#reversed
               (list#mix (is (-> [Code Code] (Change Code))
                             (function' (_ lr body')
                                        (let' [[l r] lr]
                                              (` (when (, r) (, l) (, body'))))))
                         body)
               list
               meta#pure)

          else
          (failure ..wrong_syntax))))

(the' .private (name? code)
      (Predicate Code)
      (when code
        {#Name _ _}
        1b

        _
        0b))

(the' .public function
      Macro
      (macro (_ tokens)
        (when (|> (?#and (?#form (all ?#and ?#local ?#any ?#rest))
                         ?#any)
                  (?#value tokens))
          {#Some ['name head tail] body}
          (let ['blank (code#local "")
                nest (is (-> Code Code (Change Code))
                         (function' (_ 'name arg body')
                                    (if (name? arg)
                                        (` (.function# (, 'name) (, arg) (, body')))
                                        (` (.function# (, 'name) (, 'blank)
                                                       (.when (, 'blank) (, arg) (, body')))))))]
            (meta#pure (list (nest (code#local 'name) head
                                   (list#mix (nest 'blank) body (list#reversed tail))))))

          else
          (failure ..wrong_syntax))))

(the' .private ?#export
      (type (Projection Code))
      (all ?#either
           (?#each code#name ?#global)
           (?#each code#bit ?#bit)
           (?#pure (` .private))))

(with_template [,global ,local ,type_of_parameter ,parameters]
  [(the' .private ,local
         (type (Projection [Text (List ,type_of_parameter)]))
         (?#either (?#form (?#and ?#local ,parameters))
                   (?#and ?#local (?#pure (list)))))

   (the' .private ,global
         (type (Projection [Code Text (List ,type_of_parameter)]))
         (all ?#and
              ?#export
              ,local))]

  [[?#simple_global_declaration ?#simple_local_declaration Text (?#some ?#local)]
   [?#complex_global_declaration ?#complex_local_declaration Code ?#rest]])

(the' .private Body
      Type
      (type [(Maybe Code) Code]))

(the' .private ?#body
      (type (Projection Body))
      (?#either (?#and (?#each (function (_ it) {#Some it})
                               ?#any)
                       ?#any)
                (?#and (?#pure {#None})
                       ?#any)))

(the' .private ?#definition
      (type (Projection [[Code Text (List Code)]
                         Body]))
      (?#and ?#complex_global_declaration
             ?#body))

... https://en.wikipedia.org/wiki/List_of_English_determiners
(the' .public the
      Macro
      (macro (_ tokens)
        (when (?#value tokens ?#definition)
          {#Some [[export_policy name parameters] [?type body]]}
          (let [body (when parameters
                       (list)
                       body

                       _
                       (` (function ((, (code#local name)) (,* parameters))
                            (, body))))
                body (when ?type
                       {#Some type}
                       (` (is (, type)
                              (, body)))
                       
                       {#None}
                       body)]
            (meta#pure (list (` (.def# (, (code#local name))
                                       (, body)
                                       (, export_policy))))))
          
          {#None}
          (failure ..wrong_syntax))))

(with_template [<nullary> <form> <name>]
  [(the .public <name>
     (macro (_ tokens)
       (meta#pure (list (when (|> (?#and ?#any ?#rest)
                                  (?#value (list#reversed tokens)))
                          {.#Some [last init]}
                          (list#mix (is (-> Code (Change Code))
                                        (function (_ pre post) (` <form>)))
                                    last
                                    init)
                          
                          else
                          (` <nullary>))))))]

  [[0b (if (, pre) 1b (, post)) or]
   [1b (if (, pre) (, post) 0b) and]])

... https://en.wikipedia.org/wiki/Halting_problem
(the .public (halt! message)
  (-> Text
      Nothing)
  (.error# message))

(the maybe#else
  (macro (_ tokens)
    (when tokens
      (list else maybe)
      (with_monad meta#monad
        ['temp (..generated_name "'temp")]
        (pure (list (` (when (, maybe)
                         {..#Some (, 'temp)}
                         (, 'temp)

                         {..#None}
                         (, else))))))

      _
      (failure ..wrong_syntax))))

(the (stack#item idx xs)
  (for_any (_ it)
    (-> Natural (Stack it)
        (Maybe it)))
  (when xs
    {#Empty}
    {#None}

    {#Top x xs'}
    (if (.i64_=# 0 idx)
        {#Some x}
        (stack#item (.i64_-# 1 idx) xs'))))

... https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B2-reduction
(the (reduced env type)
  (-> (Stack [Type Type])
      (Change Type))
  (when type
    {#Nominal name parameters}
    {#Nominal name (list#each (function (_ [polarity it])
                                [polarity (reduced env it)])
                              parameters)}

    {#Reification arg func}
    {#Reification (reduced env arg) (reduced env func)}

    {#Quantification quantification ?local_env ?local_def}
    (when ?local_env
      {#Empty}
      {#Quantification quantification env ?local_def}

      _
      type)

    {#Parameter parameter idx}
    (when (stack#item idx env)
      {#Some [abstraction argument]}
      (when parameter
        .abstraction abstraction
        .argument argument)

      _
      type)
    
    {#Named name type}
    (reduced env type)

    _
    type))

(the (applied_type param type_fn)
  (-> Type Type
      (Maybe Type))
  (when type_fn
    {#Quantification quantification env body}
    {#Some (reduced {#Top [type_fn param] env} body)}

    {#Reification A F}
    (with_monad maybe#monad
      [type_fn* (applied_type A F)]
      (applied_type param type_fn*))

    {#Named name type}
    (applied_type param type)
    
    _
    {#None}))

(the sum_type (.type_name# "sum"))
(the product_type (.type_name# "product"))
(the (flat_product it)
  (-> Type
      (List Type))
  (when it
    {#Nominal ..product_type (list [..co_variant left]
                                   [..co_variant right])}
    (.list_composite# (list left) (flat_product right))

    _
    (list it)))

(the (interface_methods type)
  (-> Type
      (Maybe (List Type)))
  (when type
    {#Nominal ..product_type _}
    {#Some (flat_product type)}

    {#Reification arg func}
    (with_monad maybe#monad
      [output (applied_type arg func)]
      (interface_methods output))

    {#Quantification quantification _ it}
    (interface_methods it)

    {#Named name it}
    (interface_methods it)

    {#Nominal ..sum_type _}
    {#None}
    
    _
    {#Some (list type)}))

(the (module name)
  (-> Text
      (Meta Module))
  (function (_ state)
    (let [[..#info info ..#source    source  ..#current_module _ ..#modules modules
           ..#scopes scopes ..#type_context types ..#seed seed
           ..#expected  expected ..#provenance  provenance ..#eval _eval] state]
      (when (property#value name modules)
        {#Some module}
        {#Right state module}

        _
        {#Left (text "Unknown module: " name)}))))

(the (type_slot [module name])
  (-> Name
      (Meta [Bit Label]))
  (with_monad meta#monad
    [=module (..module module)
     .let [[..#module_hash _
            ..#module_aliases _
            ..#definitions definitions
            ..#imports _
            ..#module_state _] =module]]
    (when (property#value name definitions)
      {#Some [exported {#Definition [type value]}]}
      (meta#pure [exported (as (-> Any Label) value)])

      _
      (failure (text "Unknown slot: " (name#as [module name]))))))

(the (slot_family expected_module expected_record)
  (-> Text Type
      (Meta (Maybe (List Name))))
  (with_monad meta#monad
    [module (..module expected_module)
     actual_module ..current_module_name
     .let [[..#module_hash _
            ..#module_aliases _
            ..#definitions definitions
            ..#imports _
            ..#module_state _] module]]
    (pure (list#one (function (_ [slot head])
                      (when head
                        [exported? {#Definition [type value]}]
                        (if (and (type#= Slot type)
                                 (or exported?
                                     (.text_=# expected_module actual_module)))
                            (let [[label actual_record] (as (-> Any Label) value)]
                              (if (type#= expected_record actual_record)
                                  {#Some (when label
                                           {#Some [lefts right? family]}
                                           family
                                           
                                           {#None}
                                           (list [expected_module slot]))}
                                  {#None}))
                            {#None})

                        _
                        {#None}))
                    definitions))))

(the (every_slot type)
  (-> Type
      (Meta (Maybe [(List Name) (List Type)])))
  (when type
    {#Reification arg func}
    (every_slot func)

    {#Quantification quantification env body}
    (every_slot body)

    {#Named [module name] unnamed}
    (with_monad meta#monad
      [=module (..module module)
       .let [[..#module_hash _
              ..#module_aliases _
              ..#definitions definitions
              ..#imports _
              ..#module_state _] =module]]
      (when (property#value name definitions)
        {#Some [exported? {#Definition [type value]}]}
        (if (type#= Type type)
            (with_monad meta#monad
              [slots (slot_family module (as (-> Any Type) value))]
              (when [slots (interface_methods (as (-> Any Type) value))]
                [{#Some slots} {#Some members}]
                (pure {#Some [slots members]})

                _
                (every_slot unnamed)))
            (pure {#None}))

        _
        (every_slot unnamed)))
    
    _
    (meta#pure {#None})))

(the expected_type
  (Meta Type)
  (function (_ state)
    (let [[..#info info
           ..#source source
           ..#current_module _
           ..#modules modules
           ..#scopes scopes
           ..#type_context types
           ..#seed seed
           ..#expected expected
           ..#provenance provenance
           ..#eval _eval] state]
      (when expected
        {#Some type}
        {#Right [state type]}

        {#None}
        {#Left "Not expecting any type."}))))

(the .public implementation
  (macro (_ tokens)
    (with_monad meta#monad
      [tokens' (monad#each meta#monad complete_expansion tokens)
       implementation_type ..expected_type
       tags+type (every_slot implementation_type)
       tags (is (Meta (List Name))
                (when tags+type
                  {#Some [tags _]}
                  (meta#pure tags)

                  _
                  (failure (text "No tags available for type: "
                                 (type#as_text implementation_type)))))
       .let [tag_mappings (is (Property_List Code)
                              (list#each (function (_ tag)
                                           [(product#right tag)
                                            (code#name tag)])
                                         tags))]
       members (monad#each meta#monad
                           (is (-> Code (Meta (List Code)))
                               (function (_ token)
                                 (when token
                                   {#Form _ (list {#Name _ [..prelude "def#"]}
                                                  {#Name _ ["" slot_name]}
                                                  value
                                                  export_policy)}
                                   (when (property#value slot_name tag_mappings)
                                     {#Some tag}
                                     (pure (list tag value))

                                     _
                                     (failure (text "Unknown member of implementation: " slot_name)))

                                   _
                                   (failure "Invalid member of implementation."))))
                           (list#conjoint tokens'))]
      (pure (list (code#tuple (list#conjoint members)))))))

(the ?#case
  (Projection [Text Code])
  (?#variant (?#and ?#local
                    (?#each (function (_ it)
                              (when it
                                (list)
                                (` ..Any)

                                (list it)
                                it

                                else
                                (` (..Tuple (,* else)))))
                            ?#rest))))

(the .public Variant
  (macro (_ tokens)
    (when (?#value tokens (?#some ?#case))
      {#Some whens}
      (meta#pure (list (` (..Union (,* (list#each product#right whens))))
                       (code#variant (list#each (function (_ when)
                                                  (code#text (product#left when)))
                                                whens))))
      
      {#None}
      (failure ..wrong_syntax))))

(the ?#property
  (Projection [Text Code])
  (?#and ?#local ?#any))

(the .public Record
  (macro (_ tokens)
    (when tokens
      (list {#Tuple _ record})
      (when (?#value record (?#some ?#property))
        {#Some slots}
        (meta#pure (list (` (..Tuple (,* (list#each product#right slots))))
                         (code#tuple (list#each (function (_ slot)
                                                  (code#text (product#left slot)))
                                                slots))))
        
        {#None}
        (failure ..wrong_syntax))

      _
      (failure ..wrong_syntax))))

(the ?#definition_of_type
  (Projection [[Code Text (List Text)] Code])
  (?#and ?#simple_global_declaration
         ?#any))

(the (declaration_of_type it)
  (-> Code
      (Meta [Code (Maybe (Either (List Text) (List Text)))]))
  (when (?#value (list it)
                 (?#form (?#and ?#name ?#rest)))
    {#Some [declarer parameters]}
    (with_monad meta#monad
      [declaration (single_expansion (` ((, (code#name declarer)) (,* parameters))))]
      (when declaration
        (list type {#Variant _ tags})
        (when (?#value tags (?#some ?#text))
          {#Some tags}
          (meta#pure [type {#Some {#Left tags}}])
          
          {#None}
          (failure ..wrong_syntax))

        (list type {#Tuple _ slots})
        (when (?#value slots (?#some ?#text))
          {#Some slots}
          (meta#pure [type {#Some {#Right slots}}])
          
          {#None}
          (failure ..wrong_syntax))

        (list type)
        (meta#pure [it {#None}])

        _
        (failure ..wrong_syntax)))

    else
    (meta#pure [it {#None}])))

(the enumeration
  (for_any (_ it)
    (-> (List it)
        (List [Natural it])))
  (list#each' (function (_ address it)
                [address it])))

(the (complex#right? arity label)
  (-> Natural
      (Predicate Natural))
  (.i64_=# (.i64_-# 1 arity)
           label))

(the (complex#lefts arity label)
  (-> Natural
      (Change Natural))
  (if (complex#right? arity label)
      (.i64_-# 1 label)
      label))

(the (label_definitions module export_policy associated_type label_type family labels)
  (-> Text Code Code Code Code (List Text)
      Code)
  (when (.list_size# labels)
    0 (` (these))
    1 (let [single (.list_item# 0 labels)]
        (` (the (, export_policy) (, (code#local single))
             (<| (as (-> Label (, label_type)))
                 [{#None} (, associated_type)]))))
    _ (let [arity (.list_size# labels)]
        (` (these (the (, family)
                    (List Name)
                    (list (,* (list#each (function (_ it)
                                           (` [(, (code#text module)) (, (code#text it))]))
                                         labels))))
                  (,* (list#each (function (_ [label it])
                                   (` (the (, export_policy) (, (code#local it))
                                        (<| (as (-> Label (, label_type)))
                                            [{#Some [(, (code#natural (complex#lefts arity label)))
                                                     (, (code#bit (complex#right? arity label)))
                                                     (, family)]}]
                                            (, associated_type)))))
                                 (enumeration labels))))))))

... https://en.wikipedia.org/wiki/List_of_English_determiners
(the .public every
  (macro (_ tokens)
    (when (?#value tokens ?#definition_of_type)
      {#Some [[export_policy name args] type_codes]}
      (with_monad meta#monad
        [type+labels?? (..declaration_of_type type_codes)
         module_name current_module_name
         'cohort (..generated_name "'cohort")
         .let [type_name (code#local name)
               [it labels??] type+labels??
               it' (is (Maybe Code)
                       (when args
                         (list)
                         {#Some it}

                         _
                         {#Some (` (.for_any ((, type_name) (,* (list#each code#local args)))
                                     (, it)))}))]]
        (when it'
          {#Some it''}
          (with_monad meta#monad
            [it'' (type' it'')
             .let [itC (` {..#Named [(, (code#text module_name))
                                     (, (code#text name))]
                                    (, it'')})
                   type_definition (` (the (, export_policy) (, type_name)
                                        Type
                                        (, itC)))]]
            (pure (list (when labels??
                          {#Some labels}
                          (` (these (, type_definition)
                                    (, (when labels
                                         {#Left tags}
                                         (label_definitions module_name export_policy type_name (` Tag) 'cohort tags)
                                         
                                         {#Right slots}
                                         (label_definitions module_name export_policy type_name (` Slot) 'cohort slots)))))
                          
                          _
                          type_definition))))

          {#None}
          (failure ..wrong_syntax)))

      {#None}
      (failure ..wrong_syntax))))

(every Referral
  [Name (List Code)])

(every Importation
  (Record
   [#import_name Text
    #import_alias (Maybe Text)
    #import_referrals (List Referral)]))

(the ?#referral
  (Projection Referral)
  (?#form (?#and ?#name ?#rest)))

(the (?#end [address tape])
  (Projection Any)
  (if (.i64_=# address (.list_size# tape))
      {#Some [[address tape] []]}
      {#None}))

(the (?#referrals aliased?)
  (-> Bit
      (Projection [(List Referral)
                   (List Code)]))
  (?#and (all ?#either
              (?#many ?#referral)
              (?#after ?#end
                       (?#pure (if aliased?
                                   (list [(name ..only) (list)])
                                   (list))))
              (?#pure (list)))
         ?#rest))

(the (text#split_at' at x)
  (-> Natural Text
      [Text Text])
  [(.text_clip# 0 at x)
   (.text_clip# at (|> x .text_size# (.i64_-# at)) x)])

(the (text#split_by token it)
  (-> Text Text
      (Maybe [Text Text]))
  (with_monad ..maybe#monad
    [index (.text_index# 0 token it)
     .let [[pre post'] (text#split_at' index it)
           [_ post] (text#split_at' (.text_size# token) post')]]
    (pure [pre post])))

(the (replaced pattern replacement template)
  (-> Text Text
      (Change Text))
  ((is (-> Text (Change Text))
       (function (again left right)
         (when (..text#split_by pattern right)
           {#Some [pre post]}
           (again (text left pre replacement) post)

           {#None}
           (text left right))))
   "" template))

(the (alias_stand_in index)
  (-> Natural
      Text)
  (text "[" (natural#as index) "]"))

(the Context_Of_Module
  (type (Stack Text)))

(the (module_alias context aliased)
  (-> Context_Of_Module
      (Change Text))
  (|> context
      (stack#mix (function (_ replacement [index aliased])
                   [(.i64_+# 1 index)
                    (replaced (alias_stand_in index) replacement aliased)])
                 [0 aliased])
      product#right))

... https://en.wikipedia.org/wiki/Delimiter
(the .public module_delimiter
  "/")

(the parallel_hierarchy_sigil
  "\")

(the (normal_parallel_path' hierarchy root)
  (-> Text
      (Change Text))
  (when [(text#split_by ..module_delimiter hierarchy)
         (text#split_by ..parallel_hierarchy_sigil root)]
    [{#Some [_ hierarchy']}
     {#Some ["" root']}]
    (normal_parallel_path' hierarchy' root')

    _
    (when root
      "" hierarchy
      _ (text root ..module_delimiter hierarchy))))

(the (normal_parallel_path hierarchy root)
  (-> Text Text
      (Maybe Text))
  (when (text#split_by ..parallel_hierarchy_sigil root)
    {#Some ["" root']}
    {#Some (normal_parallel_path' hierarchy root')}

    _
    {#None}))

(the (relative_ups relatives input)
  (-> Natural Text
      Natural)
  (when (.text_index# relatives ..module_delimiter input)
    {#None}
    relatives

    {#Some found}
    (if (.i64_=# relatives found)
        (relative_ups (.i64_+# 1 relatives) input)
        relatives)))

(the (?#pattern ?#it ?#body)
  (for_any (_ it body)
    (-> (Projection it) (Projection body)
        (Projection [it body (List Code)])))
  (all ?#and
       (?#form ?#it)
       ?#body
       ?#rest))

(the ^#or
  (pattern
   (macro (_ tokens)
     (when (|> (?#pattern ?#rest ?#any)
               (?#value tokens))
       {#Some [patterns body branches]}
       (when patterns
         (list)
         (failure "^#or cannot have 0 patterns")

         _
         (let' [pairs (|> patterns
                          (list#each (function' (_ pattern) (list pattern body)))
                          list#conjoint)]
               (meta#pure (.list_composite# pairs branches))))
       
       _
       (failure ..wrong_syntax)))))

(the .public (same? expected actual)
  (for_any (_ it)
    (-> it
        (Predicate it)))
  (.is?# expected actual))

(the (text#interposed delimiter parts)
  (-> Text (List Text)
      Text)
  (let [it ""]
    (list#mix (function (_ right left)
                (if (same? it left)
                    right
                    (text left delimiter right)))
              it
              parts)))

(the (text#all_split_by splitter input)
  (-> Text Text
      (List Text))
  (when (.text_index# 0 splitter input)
    {#None}
    (list input)

    {#Some idx}
    (.list_composite# (list (.text_clip# 0 idx input))
                      (text#all_split_by splitter
                                         (let [after_offset (.i64_+# 1 idx)
                                               after_length (.i64_-# after_offset
                                                                     (.text_size# input))]
                                           (.text_clip# after_offset after_length input))))))

(the \n
  Text
  (.int_char# +10))

(the (absolute_module_name nested? relative_root module)
  (-> Bit Text Text
      (Meta Text))
  (when (relative_ups 0 module)
    0
    (meta#pure (if nested?
                   (text relative_root ..module_delimiter module)
                   module))
    
    relatives
    (let [parts (text#all_split_by ..module_delimiter relative_root)
          jumps (.i64_-# 1 relatives)]
      (if (natural#< (.list_size# parts) jumps)
          (let [prefix (|> parts
                           list#reversed
                           (list#after jumps)
                           list#reversed
                           (text#interposed ..module_delimiter))
                clean (.text_clip# relatives (|> module .text_size# (.i64_-# relatives)) module)
                output (when (.text_size# clean)
                         0 prefix
                         _ (text prefix ..module_delimiter clean))]
            (meta#pure output))
          (failure (text "Cannot climb the module hierarchy..." \n
                         "Importing module: " module \n
                         "   Relative Root: " relative_root \n))))))

(the (imports_of nested? relative_root context imports)
  (-> Bit Text Context_Of_Module (List Code)
      (Meta (List Importation)))
  (with_monad meta#monad
    [imports' (monad#each meta#monad
                          (is (-> Code (Meta (List Importation)))
                              (function (_ token)
                                (when (?#value (list token)
                                               (?#tuple (?#or (all ?#and
                                                                   ?#local
                                                                   (?#referrals 0b))
                                                              (all ?#and
                                                                   ?#text
                                                                   ?#local
                                                                   (?#referrals 1b)))))
                                  {#Some {#Left [module_name referral extra]}}
                                  (with_monad meta#monad
                                    [absolute_module_name (when (normal_parallel_path relative_root module_name)
                                                            {#Some parallel_path}
                                                            (pure parallel_path)

                                                            {#None}
                                                            (..absolute_module_name nested? relative_root module_name))
                                     sub_imports (imports_of 1b absolute_module_name context extra)]
                                    (pure (when referral
                                            (list)
                                            sub_imports
                                            
                                            _
                                            (.list_composite# (list [#import_name absolute_module_name
                                                                     #import_alias {#None}
                                                                     #import_referrals referral])
                                                              sub_imports))))

                                  {#Some {#Right [alias module_name referral extra]}}
                                  (with_monad meta#monad
                                    [absolute_module_name (when (normal_parallel_path relative_root module_name)
                                                            {#Some parallel_path}
                                                            (pure parallel_path)

                                                            {#None}
                                                            (..absolute_module_name nested? relative_root module_name))
                                     .let [module_alias (..module_alias {#Top module_name context} alias)]
                                     sub_imports (imports_of 1b absolute_module_name {#Top module_alias context} extra)]
                                    (pure (when referral
                                            (list)
                                            sub_imports
                                            
                                            _
                                            (.list_composite# (list [#import_name absolute_module_name
                                                                     #import_alias {#Some module_alias}
                                                                     #import_referrals referral])
                                                              sub_imports))))

                                  else
                                  (failure ..wrong_syntax))))
                          imports)]
    (pure (list#conjoint imports'))))

(the (exported_definitions module state)
  (-> Text
      (Meta (List Text)))
  (let [[current_module modules] (when state
                                   [..#info info ..#source    source  ..#current_module current_module ..#modules modules
                                    ..#scopes scopes ..#type_context types ..#seed seed
                                    ..#expected  expected ..#provenance  provenance ..#eval _eval]
                                   [current_module modules])]
    (when (property#value module modules)
      {#Some =module}
      (let [to_alias (list#each (is (-> [Text [Bit Global]]
                                        (List Text))
                                    (function (_ [name [exported? definition]])
                                      (when definition
                                        {#Alias _}
                                        (if exported?
                                            (list name)
                                            (list))

                                        {#Definition [def_type def_value]}
                                        (if (and exported?
                                                 (not (default? def_type)))
                                            (list name)
                                            (list)))))
                                (let [[..#module_hash _ ..#module_aliases _ ..#definitions definitions ..#imports _ ..#module_state _] =module]
                                  definitions))]
        {#Right state (list#conjoint to_alias)})
      
      {#None}
      {#Left (text "Unknown module: " (text#as module) \n
                   "Current module: " (when current_module
                                        {#Some current_module}
                                        (text#as current_module)

                                        {#None}
                                        "???") \n
                                        "Known modules: " (|> modules
                                                              (list#each (function (_ [name module])
                                                                           (code#text name)))
                                                              code#tuple
                                                              code#as_text))})
    ))

(the (list#member? whens name)
  (-> (List Text)
      (Predicate Text))
  (list#mix (function (_ when prev)
              (or prev
                  (.text_=# when name)))
            0b
            whens))

(the (test_referrals current_module imported_module all_defs)
  (-> Text Text (List Text)
      (-> (List Text)
          (Meta (List Any))))
  (monad#each meta#monad
              (is (-> Text (Meta Any))
                  (function (_ _def)
                    (if (list#member? all_defs _def)
                        (meta#pure [])
                        (failure (text _def " is not defined in module " imported_module " @ " current_module)))))))

(the (alias_definition imported_module def)
  (-> Text Text
      Code)
  (` (.def# (, (code#local def))
            (, (code#name [imported_module def]))
            .private)))

(the .public only
  (macro (_ tokens)
    (when (?#value tokens
                   (all ?#and
                        ?#text
                        ?#text
                        ?#text
                        (?#some ?#local)))
      {#Some [current_module imported_module import_alias actual]}
      (with_monad meta#monad
        [expected (exported_definitions imported_module)
         _ (test_referrals current_module imported_module expected actual)]
        (pure (list#each (..alias_definition imported_module) actual)))

      {#None}
      (failure ..wrong_syntax))))

(the .public |>>
  (macro (_ tokens)
    (with_monad meta#monad
      ['_ (..generated_name "_")
       'arg (..generated_name "arg")]
      (meta#pure (list (` (function ((, '_) (, 'arg))
                            (|> (, 'arg)
                                (,* tokens)))))))))

(the .public <<|
  (macro (_ tokens)
    (with_monad meta#monad
      ['_ (..generated_name "_")
       'arg (..generated_name "arg")]
      (meta#pure (list (` (function ((, '_) (, 'arg))
                            (<| (,* tokens)
                                (, 'arg)))))))))

... TO WITH_MONAD: Stop needing this hack.
(the (array#empty size it)
  (for_any (_ it)
    (-> Natural (List it)
        (Array it)))
  (.array# size))

(the (list#only ? it)
  (for_any (_ it)
    (-> (Predicate it)
        (Change (List it))))
  (let [size_of_input (.list_size# it)
        output (array#empty size_of_input it)
        size_of_output (list#mix' (function (_ address_of_input input address_of_output)
                                    (if (? input)
                                        (exec
                                          (.array_has# address_of_output input output)
                                          (.i64_+# 1 address_of_output))
                                        address_of_output))
                                  0
                                  it)]
    (if (.i64_=# size_of_input size_of_output)
        (list#of_array output)
        (list#first size_of_output (list#of_array output)))))

(the .public except
  (macro (_ tokens)
    (when (?#value tokens
                   (all ?#and
                        ?#text
                        ?#text
                        ?#text
                        (?#some ?#local)))
      {#Some [current_module imported_module import_alias actual]}
      (with_monad meta#monad
        [expected (exported_definitions imported_module)
         _ (test_referrals current_module imported_module expected actual)]
        (pure (|> expected
                  (list#only (|>> (list#member? actual) not))
                  (list#each (..alias_definition imported_module)))))

      {#None}
      (failure ..wrong_syntax))))

(the (definition_type name state)
  (-> Name Lux
      (Maybe Type))
  (let [[expected_module expected_proper] name
        [..#info info ..#source    source  ..#current_module _ ..#modules modules
         ..#scopes scopes ..#type_context types ..#seed seed
         ..#expected  expected ..#provenance  provenance ..#eval _eval] state]
    (when (property#value expected_module modules)
      {#None}
      {#None}

      {#Some [..#definitions definitions
              ..#module_hash _
              ..#module_aliases _
              ..#imports _
              ..#module_state _]}
      (when (property#value expected_proper definitions)
        {#None}
        {#None}

        {#Some [exported? definition]}
        (when definition
          {#Alias real_name}
          (definition_type real_name state)
          
          {#Definition [def_type def_value]}
          {#Some def_type})))))

(the (type_variable expected context)
  (-> Natural (List [Natural (Maybe Type)])
      (Maybe Type))
  (let [limit (.list_size# context)]
    ((is (-> Natural
             (Maybe Type))
         (function (type_variable item)
           (if (.int_<# (as (-> Natural Integer) limit)
                        (as (-> Natural Integer) item))
               (let [[actual bound] (.list_item# item context)]
                 (if (.i64_=# expected actual)
                     bound
                     (type_variable (.i64_+# 1 item))))
               {#None})))
     0)))

(the (stack#each value it)
  (for_any (_ cause effect)
    (-> (-> cause effect)
        (-> (Stack cause) (Stack effect))))
  (stack#mix (function' (_ head tail)
                        {#Top (value head) tail})
             {#Empty}
             (stack#reversed it)))

(the (clean_type variables it)
  (-> (List [Natural (Maybe Type)])
      (Change Type))
  (when it
    {#Nominal name parameters}
    {#Nominal name (list#each (function (_ [parammeter it])
                                [parammeter (clean_type variables it)])
                              parameters)}

    {#Reification left right}
    {#Reification (clean_type variables left)
                  (clean_type variables right)}

    {#Quantification quantification environment unquantified}
    {#Quantification quantification
                     (stack#each (function (_ [abstraction argument])
                                   [(clean_type variables abstraction)
                                    (clean_type variables argument)])
                                 environment)
                     (clean_type variables unquantified)}
    
    {#Named name anonymous}
    it

    {#Parameter _}
    it
    
    {#Variable .special _}
    it
    
    {#Variable .general id}
    (when (type_variable id variables)
      {#None}
      it

      {#Some {#Variable _}}
      it

      {#Some it}
      (clean_type variables it))))

(the (type_definition full_name)
  (-> Name
      (Meta Type))
  (with_monad meta#monad
    [.let [[module name] full_name]
     current_module current_module_name]
    (function (_ compiler)
      (let [temp (is (Either Text [Lux Type])
                     (if (.text_=# "" module)
                         (when (in_env name compiler)
                           {#Some implementation_type}
                           {#Right [compiler implementation_type]}

                           _
                           (when (definition_type [current_module name] compiler)
                             {#Some implementation_type}
                             {#Right [compiler implementation_type]}

                             _
                             {#Left (text "Unknown var: " (name#as full_name))}))
                         (when (definition_type full_name compiler)
                           {#Some implementation_type}
                           {#Right [compiler implementation_type]}

                           _
                           {#Left (text "Unknown var: " (name#as full_name))})))]
        (when temp
          {#Right [compiler temp]}
          (let [[..#info _ ..#source _ ..#current_module _ ..#modules _
                 ..#scopes _ ..#type_context type_context ..#seed _
                 ..#expected _ ..#provenance _ ..#eval _eval] compiler
                 [..#ex_counter _ ..#var_counter _ ..#var_bindings var_bindings] type_context]
            {#Right [compiler (clean_type var_bindings temp)]})

          _
          temp)))))

(every Implementation_Interface
  [(List Name) (List Type)])

(the (open_layer alias [tags members])
  (-> Text Implementation_Interface
      (Meta [Code (List [Name Implementation_Interface])]))
  (with_monad meta#monad
    [pattern (monad#each meta#monad
                         (function (_ [slot slot_type])
                           (with_monad meta#monad
                             [.let [[_ slot_name] slot
                                    local ["" (..module_alias (stack slot_name) alias)]]
                              implementation (every_slot slot_type)]
                             (pure [(list (code#name slot)
                                          (code#name local))
                                    [local implementation]])))
                         (list#zipped_2 tags members))]
    (pure [(|> pattern
               (list#each product#left)
               list#conjoint
               code#tuple)
           (list#all (function (_ [_ [sub_binding sub_implementation]])
                       (with_monad maybe#monad
                         [sub_implementation sub_implementation]
                         (pure [sub_binding sub_implementation])))
                     pattern)])))

(the (open_layers alias interfaces body)
  (-> Text (List Implementation_Interface) Code
      (Meta [Code Code]))
  (with_monad meta#monad
    [layer (monad#each meta#monad (open_layer alias) interfaces)
     .let [pattern (code#tuple (list#each product#left layer))
           next (|> layer
                    (list#each product#right)
                    list#conjoint)]]
    (when next
      (list)
      (pure [pattern body])

      _
      (with_monad meta#monad
        [.let [sub_value (code#tuple (list#each (|>> product#left code#name) next))]
         sub_pattern,sub_body (open_layers alias (list#each product#right next) body)
         .let [[sub_pattern sub_body] sub_pattern,sub_body]]
        (pure [pattern (` (when (, sub_value)
                            (, sub_pattern)
                            (, sub_body)))])))))

(the .public open
  (pattern
   (macro (_ tokens)
     (when (|> (?#pattern (?#or ?#text
                                (?#and ?#name ?#text))
                          ?#any)
               (?#value tokens))
       {#Some [it body branches]}
       (when it
         {#Left alias}
         (with_monad meta#monad
           ['temp (..generated_name "temp")]
           (pure (.list_composite# (list 'temp
                                         (` (..when (, 'temp)
                                              (..open (, 'temp) (, (code#text alias)))
                                              (, body))))
                                   branches)))
         
         {#Right [name alias]}
         (with_monad meta#monad
           [init_type (type_definition name)
            implementation_evidence (every_slot init_type)]
           (when implementation_evidence
             {#None}
             (failure (text "Can only 'open' implementations: " (type#as_text init_type)))

             {#Some tags,members}
             (with_monad meta#monad
               [pattern,body (open_layers alias (list tags,members) body)
                .let [[pattern body] pattern,body]]
               (pure (.list_composite# (list pattern body)
                                       branches))))))

       else
       (failure ..wrong_syntax)))))

(the .public its
  (macro (_ tokens)
    (when tokens
      (list {#Name _ slot'} record)
      (with_monad meta#monad
        [slot (normal slot')
         output (..type_slot slot)
         .let [[exported? [label' type]] output]]
        (when label'
          {#None}
          (pure (list record))
          
          {#Some [lefts right? family]}
          (with_monad meta#monad
            ['_ (..generated_name "_")
             'output (..generated_name "")
             .let [idx (if right?
                           (is Natural (.i64_+# 1 lefts))
                           lefts)
                   pattern (|> (enumeration family)
                               (list#each (is (-> [Natural Name] (List Code))
                                              (function (_ [r_idx slot])
                                                (list (code#name slot)
                                                      (if (.i64_=# idx r_idx)
                                                          'output
                                                          '_)))))
                               list#conjoint)]]
            (pure (list (` (..when (, record) [(,* pattern)] (, 'output))))))))

      (list {#Tuple _ slots} record)
      (meta#pure (list (list#mix' (function (_ _ slot inner)
                                    (` (..its (, slot) (, inner))))
                                  record
                                  slots)))

      (list selector)
      (with_monad meta#monad
        ['_ (..generated_name "_")
         'record (..generated_name "record")]
        (pure (list (` (function ((, '_) (, 'record)) (..its (, selector) (, 'record)))))))
      
      _
      (failure ..wrong_syntax))))

(the (open_declaration imported_module alias tags my_tag_index [module proper] source type)
  (-> Text Text (List Name) Natural Name Code Type
      (Meta (List Code)))
  (with_monad meta#monad
    [output (every_slot type)
     '_ (..generated_name "'_")
     .let ['output (code#local proper)
           pattern (|> tags
                       enumeration
                       (list#each (function (_ [tag_idx tag])
                                    (if (.i64_=# my_tag_index tag_idx)
                                        'output
                                        '_)))
                       code#tuple)
           source+ (` (..when (, source) (, pattern) (, 'output)))]]
    (when output
      {#Some [tags' members']}
      (with_monad meta#monad
        [decls' (monad#each meta#monad
                            (is (-> [Natural Name Type]
                                    (Meta (List Code)))
                                (function (_ [sub_tag_index sname stype])
                                  (open_declaration imported_module alias tags' sub_tag_index sname source+ stype)))
                            (enumeration (list#zipped_2 tags' members')))]
        (pure (list#conjoint decls')))

      _
      (pure (list (` (.def# (, (code#local (..module_alias (stack proper imported_module) alias)))
                            (, source+)
                            ..private)))))))

(the (implementation_declarations imported_module alias implementation)
  (-> Text Text Name
      (Meta (List Code)))
  (with_monad meta#monad
    [interface (type_definition implementation)
     output (every_slot interface)]
    (when output
      {#Some [slots terms]}
      (with_monad meta#monad
        [.let ['implementation (code#name implementation)]
         declarations (monad#each meta#monad
                                  (is (-> [Natural Name Type]
                                          (Meta (List Code)))
                                      (function (_ [index slot_label slot_type])
                                        (open_declaration imported_module alias slots index slot_label 'implementation slot_type)))
                                  (enumeration (list#zipped_2 slots terms)))]
        (pure (list#conjoint declarations)))

      _
      (failure (text "Can only 'use' implementations: " (name#as implementation)
                     " : " (type#as_text interface))))))

(the (localized module global)
  (-> Text
      (Change Name))
  (when global
    ["" local]
    [module local]

    _
    global))

(the .public use
  (macro (_ tokens)
    (when (?#value tokens
                   (all ?#and
                        (?#maybe (all ?#and
                                      ?#text
                                      ?#text
                                      ?#text))
                        ?#text
                        (?#or (?#many ?#name)
                              (?#many ?#any))))
      {#Some [current_module,imported_module,import_alias alias implementations]}
      (let [[current_module imported_module import_alias]
            (when current_module,imported_module,import_alias
              {#Some [current_module imported_module import_alias]}
              [current_module imported_module import_alias]
              
              {#None}
              ["" "" ""])]
        (when implementations
          {#Left implementations}
          (with_monad meta#monad
            [declarations (|> implementations
                              (list#each (localized imported_module))
                              (monad#each meta#monad (implementation_declarations import_alias alias)))]
            (pure (list#conjoint declarations)))
          
          {#Right implementations}
          (with_monad meta#monad
            [pre_defs,implementations (is (Meta [(List Code) (List Code)])
                                          (monad#mix meta#monad
                                                     (function (_ it [pre_defs implementations])
                                                       (when it
                                                         {#Name _ _}
                                                         (pure [pre_defs
                                                                (.list_composite# (list it) implementations)])
                                                         
                                                         _
                                                         (with_monad meta#monad
                                                           ['implementation (..generated_name "implementation")]
                                                           (pure [(.list_composite# (list (` (.def# (, 'implementation) (, it) ..private)))
                                                                                    pre_defs)
                                                                  (.list_composite# (list 'implementation) implementations)]))))
                                                     [(list) (list)]
                                                     implementations))
             .let [[pre_defs implementations] pre_defs,implementations]]
            (pure (list (` (these (,* (list#reversed pre_defs))
                                  (..use (, (code#text current_module))
                                         (, (code#text imported_module))
                                         (, (code#text import_alias))
                                         (, (code#text alias))
                                         (,* implementations)))))))))
      
      {#None}
      (failure ..wrong_syntax))))

(the refer
  (macro (_ tokens)
    (when (?#value tokens
                   (all ?#and
                        ?#text
                        ?#text
                        (?#referrals 0b)))
      {#Some [imported_module alias referrals (list)]}
      (with_monad meta#monad
        [current_module ..current_module_name]
        (pure (list#each (function (_ [macro parameters])
                           (` ((, (code#name macro))
                               (, (code#text current_module))
                               (, (code#text imported_module))
                               (, (code#text alias))
                               (,* parameters))))
                         referrals)))

      else
      (failure ..wrong_syntax))))

(the .public with
  (macro (_ tokens)
    (when (?#value tokens
                   (?#and ?#any ?#any))
      {#Some [implementation expression]}
      (meta#pure (list (` (..let [(..open (, (code#text (alias_stand_in 0)))) (, implementation)]
                            (, expression)))))

      {#None}
      (failure ..wrong_syntax))))

(the .public by
  (macro (_ tokens)
    (when (?#value tokens
                   (all ?#and
                        ?#any
                        ?#local
                        ?#rest))
      {#Some [implementation member args]}
      (let ['member (` (..with (, implementation) (, (code#local member))))]
        (meta#pure (list (when args
                           (list)
                           'member
                           
                           else
                           (` ((, 'member) (,* args)))))))

      else
      (failure ..wrong_syntax))))

(the .public has
  (macro (_ tokens)
    (when tokens
      (list {#Name _ slot'} value record)
      (with_monad meta#monad
        [slot (normal slot')
         output (..type_slot slot)
         .let [[exported? [label' type]] output]]
        (when label'
          {#None}
          (pure (list value))

          {#Some [lefts right? family]}
          (with_monad meta#monad
            [pattern' (monad#each meta#monad
                                  (is (-> [Natural Name]
                                          (Meta [Name Natural Code]))
                                      (function (_ [r_idx r_slot_name])
                                        (with_monad meta#monad
                                          ['slot (..generated_name "")]
                                          (pure [r_slot_name r_idx 'slot]))))
                                  (enumeration family))
             .let [pattern (|> pattern'
                               (list#each (is (-> [Name Natural Code]
                                                  (List Code))
                                              (function (_ [r_slot_name r_idx r_var])
                                                (list (code#name r_slot_name)
                                                      r_var))))
                               list#conjoint)
                   idx (if right?
                           (is Natural (.i64_+# 1 lefts))
                           lefts)
                   output (|> pattern'
                              (list#each (is (-> [Name Natural Code]
                                                 (List Code))
                                             (function (_ [r_slot_name r_idx r_var])
                                               (list (code#name r_slot_name)
                                                     (if (.i64_=# idx r_idx)
                                                         value
                                                         r_var)))))
                              list#conjoint)]]
            (pure (list (` (..when (, record)
                             [(,* pattern)]
                             [(,* output)])))))))

      (list {#Tuple _ slots}
            value
            record)
      (when slots
        (list)
        (failure ..wrong_syntax)

        _
        (with_monad meta#monad
          [bindings (monad#each meta#monad
                                (is (-> Code
                                        (Meta Code))
                                    (function (_ _)
                                      (..generated_name "temp")))
                                slots)
           .let [pairs (list#zipped_2 slots bindings)
                 update_expr (list#mix (is (-> [Code Code]
                                               (Change Code))
                                           (function (_ [s b] v)
                                             (` (..has (, s) (, v) (, b)))))
                                       value
                                       (list#reversed pairs))
                 [_ accesses] (list#mix (is (-> [Code Code]
                                                (Change [Code (List Code)]))
                                            (function (_ [new_slot new_binding] [old_record accesses'])
                                              [(` (its (, new_slot) (, new_binding)))
                                               (.list_composite# accesses' (list new_binding old_record))]))
                                        [record (is (List Code) (list))]
                                        pairs)]]
          (pure (list (` (let [(,* accesses)]
                           (, update_expr)))))))
      
      (list selector value)
      (with_monad meta#monad
        ['_ (..generated_name "_")
         'record (..generated_name "record")]
        (pure (list (` (function ((, '_) (, 'record))
                         (..has (, selector) (, value) (, 'record)))))))

      (list selector)
      (with_monad meta#monad
        ['_ (..generated_name "_")
         'value (..generated_name "value")
         'record (..generated_name "record")]
        (pure (list (` (function ((, '_) (, 'value) (, 'record))
                         (..has (, selector) (, 'value) (, 'record)))))))

      _
      (failure ..wrong_syntax))))

(the .public revised
  (macro (_ tokens)
    (when tokens
      (list {#Name _ slot'} fun record)
      (with_monad meta#monad
        [slot (normal slot')
         output (..type_slot slot)
         .let [[exported? [label' type]] output]]
        (when label'
          {#None}
          (pure (list (` ((, fun) (, record)))))

          {#Some [lefts right? family]}
          (with_monad meta#monad
            [pattern' (monad#each meta#monad
                                  (is (-> [Natural Name]
                                          (Meta [Name Natural Code]))
                                      (function (_ [r_idx r_slot_name])
                                        (with_monad meta#monad
                                          ['slot (..generated_name "")]
                                          (pure [r_slot_name r_idx 'slot]))))
                                  (enumeration family))
             .let [pattern (|> pattern'
                               (list#each (is (-> [Name Natural Code]
                                                  (List Code))
                                              (function (_ [r_slot_name r_idx r_var])
                                                (list (code#name r_slot_name)
                                                      r_var))))
                               list#conjoint)
                   idx (if right?
                           (is Natural (.i64_+# 1 lefts))
                           lefts)
                   output (|> pattern'
                              (list#each (is (-> [Name Natural Code]
                                                 (List Code))
                                             (function (_ [r_slot_name r_idx r_var])
                                               (list (code#name r_slot_name)
                                                     (if (.i64_=# idx r_idx)
                                                         (` ((, fun) (, r_var)))
                                                         r_var)))))
                              list#conjoint)]]
            (pure (list (` (..when (, record)
                             [(,* pattern)]
                             [(,* output)])))))))

      (list {#Tuple _ slots} fun record)
      (when slots
        (list)
        (failure ..wrong_syntax)

        _
        (with_monad meta#monad
          ['record (..generated_name "record")
           'temp (..generated_name "temp")]
          (pure (list (` (let [(, 'record) (, record)
                               (, 'temp) (its [(,* slots)] (, 'record))]
                           (has [(,* slots)] ((, fun) (, 'temp)) (, 'record))))))))

      (list selector fun)
      (with_monad meta#monad
        ['_ (..generated_name "_")
         'record (..generated_name "record")]
        (pure (list (` (function ((, '_) (, 'record))
                         (..revised (, selector) (, fun) (, 'record)))))))

      (list selector)
      (with_monad meta#monad
        ['_ (..generated_name "_")
         'fun (..generated_name "fun")
         'record (..generated_name "record")]
        (pure (list (` (function ((, '_) (, 'fun) (, 'record))
                         (..revised (, selector) (, 'fun) (, 'record)))))))
      
      _
      (failure ..wrong_syntax))))

(the .private with_template#pattern
  (pattern
   (macro (_ tokens)
     (when (|> (?#pattern (?#and (?#tuple ?#rest)
                                 (?#tuple ?#rest))
                          (?#form ?#rest))
               (?#value tokens))
       {#Some [[bindings templates] data branches]}
       (when (is (Maybe (List Code))
                 (with_monad maybe#monad
                   [bindings' (monad#each maybe#monad ..proper_name bindings)
                    data' (monad#each maybe#monad ..tuple_list data)]
                   (let [num_bindings (.list_size# bindings')]
                     (if (list#every? (|>> .list_size# (.i64_=# num_bindings))
                                      data')
                         (let [reification (is (-> Replacement_Environment
                                                   (List Code))
                                               (function (_ env)
                                                 (list#each (realized_template env)
                                                            templates)))]
                           (|> data'
                               (list#each (|>> (replacement_environment bindings')
                                               reification))
                               list#conjoint
                               pure))
                         {#None}))))
         {#Some output}
         (meta#pure (.list_composite# output branches))
         
         {#None}
         (failure ..wrong_syntax))
       
       _
       (failure ..wrong_syntax)))))

(with_template [<name> <extension>]
  [(the .public <name>
     (for_any (_ it)
       (Change (I64 it)))
     (|>> (<extension> 1)))]

  [[++ .i64_+#]
   [-- .i64_-#]])

(the (interleaved left right)
  (for_any (_ it)
    (-> (List it)
        (Change (List it))))
  (|> (list#zipped_2 left right)
      (list#each (function (_ [left right])
                   (list left right)))
      list#conjoint))

(the 'stack
  (-> (Stack Code)
      Code)
  (|>> stack#reversed
       (stack#mix '#Top '#Empty)))

(the (type_code type)
  (-> Type
      Code)
  (when type
    {#Nominal name params}
    (` {..#Nominal (, (code#text name)) (, ('list (list#each (function (_ [polarity it])
                                                               (` [(, (code#bit polarity))
                                                                   (, (type_code it))]))
                                                             params)))})

    {#Reification left right}
    (` {..#Reification (, (type_code left)) (, (type_code right))})

    {#Parameter parameter id}
    (` {..#Parameter (, (code#bit parameter))
                     (, (code#natural id))})

    {..#Variable quality id}
    (` {..#Variable (, (code#bit quality)) (, (code#natural id))})

    {#Quantification quantification env type}
    (` {..#Quantification (, (code#bit quantification))
                          (, ('stack (stack#each (function (_ [abstraction argument])
                                                   (` [(, (type_code abstraction))
                                                       (, (type_code argument))]))
                                                 env)))
                          (, (type_code type))})
    
    {#Named [module name] anonymous}
    ... TODO: Generate the explicit type definition instead of using
    ... the "code#name" shortcut below.
    ... (` {..#Named [(, (code#text module)) (, (code#text name))]
    ...     (, (type_code anonymous))})
    (code#name [module name])))

(the .public loop
  (macro (_ tokens)
    (when (?#value tokens
                   (?#and (?#form (?#and ?#any (?#tuple (?#some (?#and ?#any ?#any)))))
                          ?#any))
      {#Some [[name bindings] body]}
      (let [vars (list#each product#left bindings)
            inits (list#each product#right bindings)]
        (if (list#every? name? inits)
            (with_monad meta#monad
              [inits' (is (Meta (List Name))
                          (when (monad#each maybe#monad ..full_name inits)
                            {#Some inits'}
                            (meta#pure inits')
                            
                            {#None}
                            (failure ..wrong_syntax)))
               init_types (monad#each meta#monad type_definition inits')
               expected ..expected_type]
              (meta#pure (list (` ((.is# (-> (,* (list#each type_code init_types))
                                             (, (type_code expected)))
                                         (function ((, name) (,* vars))
                                           (, body)))
                                   (,* inits))))))
            (with_monad meta#monad
              [aliases (monad#each meta#monad
                                   (is (-> Code
                                           (Meta Code))
                                       (function (_ _) (..generated_name "")))
                                   inits)]
              (meta#pure (list (` (..let [(,* (..interleaved aliases inits))]
                                    (..loop ((, name) [(,* (..interleaved vars aliases))])
                                      (, body)))))))))

      else
      (failure ..wrong_syntax))))

(the expansion#let
  (let [expansion#let' (is (-> Text (List Code) Code
                               (List Code))
                           (function (expansion#let' label tokens target)
                             (when target
                               (^#or {#Bit _ _}
                                     {#Natural _ _}
                                     {#Integer _ _}
                                     {#Revolution _ _}
                                     {#Decimal _ _}
                                     {#Text _ _})
                               (list target)

                               {#Name _ [module name]}
                               (if (and (.text_=# "" module)
                                        (.text_=# label name))
                                   tokens
                                   (list target))

                               (with_template#pattern [<tag>]
                                 [{<tag> provenance elems}
                                  (|> elems
                                      (list#each (expansion#let' label tokens))
                                      list#conjoint
                                      {<tag> provenance}
                                      list)])
                               ([#Form]
                                [#Variant]
                                [#Tuple]))))]
    (macro (_ tokens)
      (when (?#value tokens
                     (?#and (?#tuple (?#some ?#binding)) ?#any))
        {#Some [bindings body]}
        (let [normal (is (-> (Property_List (List Code)) Code
                             (List Code))
                         (function (_ map it)
                           (list#mix (function (_ [binding expansion] it)
                                       (list#conjoint (list#each (expansion#let' binding expansion) it)))
                                     (list it)
                                     map)))]
          (with_monad meta#monad
            [map (is (Meta (Property_List (List Code)))
                     (monad#mix meta#monad
                                (function (_ [var_name expr] map)
                                  (with_monad meta#monad
                                    [expansion (when (normal map expr)
                                                 (list expr)
                                                 (single_expansion expr)

                                                 _
                                                 (failure (text "Incorrect expansion in expansion#let"
                                                                " | Binding: " (text#as var_name)
                                                                " | Expression: " (code#as_text expr))))]
                                    (pure (property#with var_name expansion map))))
                                (list)
                                bindings))]
            (meta#pure (normal map body))))
        
        {#None}
        (failure ..wrong_syntax)))))

(the .public as_expected
  (macro (_ tokens)
    (when tokens
      (list expr)
      (with_monad meta#monad
        [type ..expected_type]
        (pure (list (` (.as# (-> Any
                                 (, (type_code type)))
                             (, expr))))))
      
      _
      (failure ..wrong_syntax))))

(the (provenance#as it)
  (-> Provenance
      Text)
  (let [... https://en.wikipedia.org/wiki/Delimiter
        delimiter ","
        [file line column] it]
    (text "@"
          (text#as file) delimiter
          (natural#as line) delimiter
          (natural#as column))))

(the .public undefined
  (let [provenance (is (Meta Provenance)
                       (function (_ compiler)
                         {#Right [compiler (its #provenance compiler)]}))]
    (macro (_ tokens)
      (when tokens
        (list)
        (with_monad meta#monad
          [provenance provenance
           .let [message (text "Undefined behavior at " (provenance#as provenance))]]
          (exec
            (.log!# (text "WARNING: " message))
            (pure (list (` (..halt! (, (code#text message))))))))
        
        _
        (failure ..wrong_syntax)))))

(the .public type_of
  (macro (_ tokens)
    (when tokens
      (list {#Name _ ["" local]})
      (with_monad meta#monad
        [type (type_definition ["" local])]
        (pure (list (` (..type ((,' ,) (, (type_code type))))))))

      (list {#Name _ global})
      (with_monad meta#monad
        [type (type_definition global)
         .let [code#name (is (-> Name
                                 Code)
                             (function (_ [module name])
                               (code#tuple (list (code#text module)
                                                 (code#text name)))))]]
        (pure (list (` (..type ((,' ,) {..#Reification {..#Named (, (code#name global))
                                                                 (, (type_code type))}
                                                       {..#Named (, (code#name (name ..type_of)))
                                                                 (, (type_code ..Nothing))}}))))))

      (list expression)
      (with_monad meta#monad
        ['temp (..generated_name "'temp")]
        (pure (list (` (let [(, 'temp) (, expression)]
                         (..type_of (, 'temp)))))))

      _
      (failure ..wrong_syntax))))

(the (with_replacements reps syntax)
  (-> Replacement_Environment
      (Change Code))
  (when syntax
    {#Name _ ["" proper]}
    (when (..replacement proper reps)
      {#Some replacement}
      replacement

      {#None}
      syntax)

    {#Form meta parts}
    {#Form meta (list#each (with_replacements reps) parts)}

    {#Variant meta members}
    {#Variant meta (list#each (with_replacements reps) members)}

    {#Tuple meta members}
    {#Tuple meta (list#each (with_replacements reps) members)}
    
    _
    syntax))

(the template#macro
  (let [?#template (is (Projection [[Text (List Text)] (List Code)])
                       (?#and ?#simple_local_declaration
                              (?#tuple ?#rest)))
        simple_replacement_environment (is (-> (List Text)
                                               Replacement_Environment)
                                           (list#each (function (_ arg)
                                                        [arg (` ((,' ,) (, (code#local arg))))])))
        instantiated_template (is (-> Replacement_Environment
                                      (Change Code))
                                  (function (_ replacement_environment template)
                                    (` (`' (, (with_replacements replacement_environment
                                                template))))))]
    (macro (_ tokens)
      (when (?#value tokens ?#template)
        {#Some [[name args] input_templates]}
        (with_monad meta#monad
          ['tokens (..generated_name "tokens")
           'compiler (..generated_name "compiler")
           '_ (..generated_name "_")
           this_module ..current_module_name]
          (pure (list (` (..macro ((, (code#local name)) (, 'tokens) (, 'compiler))
                           (when (, 'tokens)
                             (list (,* (list#each code#local args)))
                             {..#Right [(, 'compiler)
                                        (list (,* (list#each (instantiated_template (simple_replacement_environment args))
                                                             input_templates)))]}
                             
                             (, '_)
                             {..#Left ..wrong_syntax}))))))

        else
        (failure ..wrong_syntax)))))

(with_template [<name> <to>]
  [(the .public <name>
     (template#macro
      (<name> ,it)
      [(..as (-> (..I64 ..Any)
                 <to>)
             ,it)]))]

  [[i64 ..I64]
   [natural ..Natural]
   [integer ..Integer]
   [revolution ..Revolution]])

(the .public character
  (macro (_ tokens compiler)
    (when tokens
      (list {#Text _ input})
      (if (|> input .text_size# (.i64_=# 1))
          (|> input (.text_char# 0)
              code#natural list
              [compiler] {#Right})
          {#Left ..wrong_syntax})

      _
      {#Left ..wrong_syntax})))

(the Eval
  ... (.type# "eval")
  (type (-> ..Type ..Code
            (Meta Any))))

(the (eval type code)
  (-> Type Code
      (Meta Any))
  (with_monad meta#monad
    [eval (function (_ lux)
            {#Right [lux (as (-> Any Eval)
                             (its #eval lux))]})]
    (eval type code)))

(every .public Target
  Text)

(with_template [<name> <value>]
  [(the .public <name>
     Target
     <value>)]
  
  [ ... Available.
   [js          "JavaScript"]
   [jvm         "JVM"]
   [lua         "Lua"]
   [python      "Python"]
   [ruby        "Ruby"]
   ... Not available yet.
   [c++         "C++"]
   [common_lisp "Common Lisp"]
   [php         "PHP"]
   [r           "R"]])

(the .public for
  (let [target (is (Meta Target)
                   (function (_ compiler)
                     {#Right [compiler (its [#info #target] compiler)]}))
        platform_name (is (-> Code
                              (Meta Target))
                          (function (_ it)
                            (with_monad meta#monad
                              [it (eval Target it)]
                              (pure (as (-> Any Target) it)))))]
    (macro (_ tokens)
      (when (?#value tokens
                     (?#and (?#some (?#and ?#any ?#any))
                            (?#maybe ?#any)))
        {#Some [options default]}
        (with_monad meta#monad
          [target target
           options (monad#each meta#monad
                               (function (_ [platform pick])
                                 (with_monad meta#monad
                                   [platform (platform_name platform)]
                                   (pure [platform pick])))
                               options)]
          (when (list#one (function (_ [platform pick])
                            (if (.text_=# target platform)
                                {#Some pick}
                                {#None}))
                          options)
            {#Some pick}
            (meta#pure (list pick))

            {#None}
            (when default
              {#Some default}
              (meta#pure (list default))
              
              {#None}
              (failure (text "No code for target platform: " target)))))

        {#None}
        (failure ..wrong_syntax)))))

(the .public using
  (let [refer_code (is (-> Text Text (List Referral)
                           Code)
                       (function (_ imported_module alias referrals)
                         (` (..refer (, (code#text imported_module))
                                     (, (code#text alias))
                                     (,* (list#each (function (_ [macro parameters])
                                                      (` ((, (code#name macro)) (,* parameters))))
                                                    referrals))))))]
    (macro (_ _imports)
      (with_monad meta#monad
        [current_module ..current_module_name
         imports (imports_of 0b current_module {#Empty} _imports)
         .let [referrals (list#each (is (-> Importation
                                            Code)
                                        (function (_ [module_name m_alias =refer])
                                          (refer_code module_name (..maybe#else "" m_alias) =refer)))
                                    imports)
               importations (list#each (is (-> Importation
                                               Code)
                                           (function (_ [module_name m_alias =refer])
                                             (` [(, (code#text module_name)) (, (code#text (..maybe#else "" m_alias)))])))
                                       imports)]]
        (pure (list (` (these (.module# [(,* importations)])
                              (,* referrals)))))))))

(every Immediate_UnQuote
  (Nominal "#Macro/Immediate_UnQuote"))

(the .public ,,
  (as (-> Macro
          Immediate_UnQuote)
      (macro (_ it)
        (when it
          (list it)
          (meta#pure (list it))

          _
          (failure ..wrong_syntax)))))

(the aggregate_embedded_expansions
  (template#macro
   (_ embedded_expansions <@> <tag> <*>)
   [(with_monad meta#monad
      [<*>' (monad#each meta#monad embedded_expansions <*>)]
      (pure [(|> <*>'
                 list#reversed
                 (list#each product#left)
                 list#conjoint)
             {<tag> <@> (list#each product#right <*>')}]))]))

(the (embedded_expansions code)
  (-> Code
      (Meta [(List Code) Code]))
  (when code
    {#Form @ original_name,parameters}
    (when (list#item 0 original_name,parameters)
      {#Some {#Name @name original_name}}
      (<| (let [parameters (list#after 1 original_name,parameters)])
          (expansion#let [<failure> (aggregate_embedded_expansions embedded_expansions @ #Form (.list_composite# (list {#Name @name original_name}) parameters))])
          (with_monad meta#monad
            [resolved_name (..normal original_name)
             ?resolved_name (meta#try (..global_name resolved_name))]
            (when ?resolved_name
              {#Left _}
              <failure>

              {#Right resolved_name}
              (with_monad meta#monad
                [?type,value (meta#try (..definition_value resolved_name))]
                (when ?type,value
                  {#Left _}
                  <failure>

                  {#Right [type value]}
                  (if (type#= ..Immediate_UnQuote type)
                      (with_monad meta#monad
                        [bound ((as (-> Any Macro') value) parameters)
                         'expansion (..generated_name "'expansion")]
                        (pure [(.list_composite# (list 'expansion) bound)
                               'expansion]))
                      <failure>))))))

      else
      (aggregate_embedded_expansions embedded_expansions @ #Form original_name,parameters))

    (with_template#pattern [<tag>]
      [{<tag> @ parts}
       (aggregate_embedded_expansions embedded_expansions @ <tag> parts)])
    ([#Variant]
     [#Tuple])
    
    _
    (meta#pure [(list)
                code])))

(the .public ``
  (macro (_ tokens)
    (when tokens
      (list raw)
      (with_monad meta#monad
        [=raw (..embedded_expansions raw)
         .let [[labels labelled] =raw]]
        ((as (-> Macro Macro') ..expansion#let)
         (list (code#tuple labels)
               labelled)))

      _
      (failure ..wrong_syntax))))

(the .public try
  (macro (_ tokens)
    (when tokens
      (list expression)
      (with_monad meta#monad
        ['_ (..generated_name "'_")]
        (pure (list (` (.try# (.function ((, '_) (, '_))
                                (, expression)))))))

      _
      (..failure ..wrong_syntax))))

(the ?#method
  (Projection [Code Text])
  (?#form (?#after (?#this_name [..prelude "is#"])
                   (?#and ?#any
                          ?#local))))

... [Scrap your type classes](https://www.haskellforall.com/2012/05/scrap-your-type-classes.html)
(the .public Interface
  (macro (_ tokens)
    (with_monad meta#monad
      [methods' (monad#each meta#monad complete_expansion tokens)]
      (when (?#value (list#conjoint methods')
                     (?#some ?#method))
        {#Some methods}
        (pure (list (` (..Tuple (,* (list#each product#left methods))))
                    (code#tuple (list#each (|>> product#right code#text) methods))))

        {#None}
        (failure ..wrong_syntax)))))

(the .public Rec
  (let [recursive_type (is (-> Code Code Text
                               (Change Code))
                           (function (recursive_type 'self 'dummy name body)
                             (` {..#Reification (..Nominal "")
                                                (.for_any ((, 'self) (, 'dummy))
                                                  (, ('let (code#local name) (` {..#Reification (..Nominal "") (, 'self)})
                                                           body)))})))]
    (macro (_ tokens)
      (when tokens
        (list {#Name _ ["" name]} body)
        (with_monad meta#monad
          [body' (complete_expansion body)
           'self (generated_name "'self")
           'dummy (generated_name "'dummy")]
          (when body'
            (list body' labels)
            (pure (list (recursive_type 'self 'dummy name body')
                        labels))

            (list body')
            (pure (list (recursive_type 'self 'dummy name body')))

            _
            (failure ..wrong_syntax)))

        _
        (failure ..wrong_syntax)))))

(with_template [<type>]
  [(the .public <type>
     Type
     (let [[_ proper] (name <type>)]
       {#Named [..prelude proper]
               {#Nominal (text "#Extension/" proper) (list)}}))]

  [[Analysis]
   [Synthesis]
   [Translation]
   [Declaration]])

(the .public alias
  (macro (_ tokens)
    (when (?#value tokens
                   (?#and (?#tuple (?#many ?#local))
                          ?#name))
      {#Some [alias/+ original]}
      (meta#pure (list#each (function (_ it)
                              (` (the .public (, (code#local it))
                                   (, (code#name original)))))
                            alias/+))
      
      {#None}
      (failure ..wrong_syntax))))

(alias [F64 Double]
       ..Decimal)

(alias [alias? identical?]
       ..same?)

(the .public variant
  (macro (_ it)
    (meta#pure (list (` {(,* it)})))))

(alias [|]
       ..variant)

(the .public tuple
  (macro (_ it)
    (meta#pure (list (` [(,* it)])))))

(alias [& record]
       ..tuple)

(the .public unless
  (template#macro
   (_ ,when ,else ,then)
   [(..if ,when ,then ,else)]))

(alias [for_all for_every]
       ..for_any)

(alias [there_exists]
       ..for_some)

... https://en.wikipedia.org/wiki/Up_tack
(alias [False Falsum]
       ..Nothing)

... https://en.wikipedia.org/wiki/Tee_(symbol)
(alias [True Verum]
       ..Any)

... https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)
(the .public <-
  (macro (_ parameters)
    (meta#pure (list (` (.-> (,* (list#reversed parameters))))))))

... https://en.wikipedia.org/wiki/Number#Classification
(alias [N Nat]
       ..Natural)

(alias [Z Int]
       ..Integer)

(alias [Rev]
       ..Revolution)

(the .public match?
  (macro (_ tokens)
    (when (?#value tokens
                   (?#and ?#any
                          ?#any))
      {#Some [pattern term]}
      (with_monad meta#monad
        ['else (generated_name "'else")]
        (pure (list (` (..when (, term)
                         (, pattern)
                         ..true

                         (, 'else)
                         ..false)))))
      
      {#None}
      (failure ..wrong_syntax))))

(every .public (Can ability)
  (for_some (_ entity)
    [entity
     (ability entity)]))

(the .public (can ability entity)
  (for_any (_ ability it)
    (-> (ability it) it
        (Can ability it)))
  [entity ability])

(the .public (ability [entity ability])
  (for_any (_ ability it)
    (-> (Can ability it)
        (ability it)))
  ability)

(the .public (entity [entity ability])
  (for_any (_ ability it)
    (-> (Can ability it)
        it))
  entity)
