{
    "docs": [
        {
            "location": "/", 
            "text": "What is Lux?\n\n\nLux is a new programming language in the making.\n\n\nIt's meant to be a functional, statically-typed Lisp that will run on several platforms, such as the Java Virtual Machine and JavaScript interpreters.\n\n\nWhat's the current version?\n\n\n0.5.0\n\n\nHow far ahead is the project?\n\n\nLux is in the \nbeta\n stage.\n\n\nThe JVM compiler is pretty stable and the standard library has grown to a respectable size.\n\n\nAlso, new experimental support for Android has been added.\n\n\nHow can I use it?\n\n\nYou should use the Leiningen plugin for Lux to compile your programs and manage your dependencies.\n\n\nYou can find it here: https://github.com/LuxLang/lux/tree/master/lux-lein\n\n\nAfter compiling your program, this will generate a directory named \"target\" and put all the .class files there.\n\n\nThen, you can run the program like this:\n\n\njava -jar target/jvm/program.jar\n\n\n\nSample\n\n\nTo take a look at sample Lux projects, check these repositories:\n\n\n\n\nhttps://github.com/LuxLang/tutorial1\n\n\nhttps://github.com/LuxLang/lux/tree/master/luxdoc\n\n\n\n\nThe \nluxdoc\n program was actually used to generate the documentation for the standard library (located here: https://luxlang.github.io/lux/)\n\n\nWhat's the license?\n\n\nMozilla Public License v2.0\n\n\nWhat's interesting about the language?\n\n\nInspirations\n\n\nThe language is mostly inspired by the following 3 languages:\n\n\n\n\nHaskell (functional programming)\n\n\nClojure (syntax, overall look \n feel)\n\n\nML (module system)\n\n\n\n\nThe compiler is even implemented in Clojure.\n\n\nTypes\n\n\nThey are implemented as plain-old data-structures whose expressions get eval'ed by the compiler and integrated into the type-checker.\n\n\nThat means it's actually possible to generate types via functions and macros.\n\n\nModule system\n\n\nThe module system is heavily inspired by ML, and both signatures and structures are supported.\n\n\nThe main difference between Lux and ML is that ML separates signatures and structures from the rest of the language, whereas Lux implements them on top of the base language.\n\n\nHow?\n\n\nBy implementing signatures as record-types and structures as actual records.\n\n\nBut, why not just use type-classes?\n\n\nHaskell's type-class system forces the user to only specify 1 instance for any given type-class and its argument.\n\n\nIf there are more than 1 possible valid instances (as is the case for Monoid of Int), you have to resort to \nnewtype hacks\n to be able to provide alternative implementations.\n\n\nBy using a system like ML's, that problem is averted.\n\n\nAdditionally, by hosting the module system on top of records, which are regular values, you get the further benefit that structures can be parameterized at run-time just like any other value.\n\n\nYou can also write functions that take and return structures (as \nfunctors\n do in ML), and you can generate structures on the fly.\n\n\n\n\nAlso, Lux now offers a mechanism for easy polymorphism, just like Haskell's type-classes, but built upon it's module system, thanks to the \nlux/type/auto\n module and its \n:::\n macro.\n\n\nYou can learn more about that by reading the book and the documentation.\n\n\n\n\nFunctional programming\n\n\nWhile the means to do Java-interop are provided, Lux is commited to functional programming.\n\n\nFunctions are curried and partial application is as simple as just applying a function to less arguments than it needs (as in Haskell).\n\n\ne.g.\n\n\n(map (i.+ 1) (list 1 2 3 4 5))\n\n\n\nMacros\n\n\nUnlike in most other lisps, Lux macros are monadic.\n\n\nThe \n(Lux a)\n type is the one responsible for the magic by threading \nCompiler\n instances through macros.\n\n\nYou can use \nmacro:\n to define these monadic macros.\n\n\nAlternatively, you can use the \nsyntax:\n macro, which also offers monadic parsing of Code tokens for convenience.\n\n\nCustom pattern-matching\n\n\nWait... wut?\n\n\nCustom pattern-matching basically means that you can use macros to provide custom syntax and features on top of the pattern-matching macro \ncase\n.\n\n\nFor instance, the \nlist\n and \nlist\n macros are used to build lists.\nBut you can also use them to destructure lists inside pattern-matching:\n\n\n(case (: (List Int) (list 1 2 3))\n  (#Cons x (#Cons y (#Cons z #Nil)))\n  (#Some ($_ i.* x y z))\n\n  _\n  #None)\n\n(case (: (List Int) (list 1 2 3))\n  (^ (list x y z))\n  (#Some ($_ i.* x y z))\n\n  _\n  #None)\n\n\n\nThere is also the special \n^or\n macro, which introduces \nor patterns\n:\n\n\n(type: Weekday\n  #Monday\n  #Tuesday\n  #Wednesday\n  #Thursday\n  #Friday\n  #Saturday\n  #Sunday))\n\n(def: (weekend? day)\n  (-\n Weekday Bool)\n  (case day\n    (^or #Saturday #Sunday)\n    true\n\n    _\n    false))\n\n\n\n\n\nPlease note: ^ and ^or are just macros like any other and anyone can implement them.\n\n\n\n\nIs there a community for this?\n\n\nCome join the discussion group at: https://groups.google.com/forum/#!forum/lux-programming-language\n\n\nIf you want to communicate with me directly, just email me at luxlisp@gmail.com\n\n\nAlso, you can chat with us on Gitter:\n\n\n\nHow can I edit Lux code?\n\n\nCheck out the Emacs plugin for it: https://github.com/LuxLang/lux/tree/master/lux-mode\n\n\nWhere do I learn Lux?\n\n\nThe main resource is the book: https://www.gitbook.com/book/luxlang/the-lux-programming-language/details\n\n\nIt will always be up-to-date with the latest stable version of the language.\n\n\nAlso, you can check out the documentation for the currently available modules: https://luxlang.github.io/lux/\n\n\nFinally, you can check out the Lux DevLog, where I talk about different topics related to Lux and post tutorials: http://luxlang.blogspot.com/\n\n\nHow can I contribute?\n\n\nFor starters, you can check out the Trello board for Lux development: https://trello.com/b/VRQhvXjs/lux-jvm-compiler\n\n\nI'll be putting there tasks that people can contribute to; both in the compiler and outside (like plugins for editors).\n\n\nWriting libraries in Lux will also help a lot in making this a more practical language for day to day use.\n\n\nCommunication is done over Gitter and the Google group.\n\n\nCopyright (c) 2014-2017 Eduardo Julian. All rights reserved.", 
            "title": "Home"
        }, 
        {
            "location": "/#what-is-lux", 
            "text": "Lux is a new programming language in the making.  It's meant to be a functional, statically-typed Lisp that will run on several platforms, such as the Java Virtual Machine and JavaScript interpreters.", 
            "title": "What is Lux?"
        }, 
        {
            "location": "/#whats-the-current-version", 
            "text": "0.5.0", 
            "title": "What's the current version?"
        }, 
        {
            "location": "/#how-far-ahead-is-the-project", 
            "text": "Lux is in the  beta  stage.  The JVM compiler is pretty stable and the standard library has grown to a respectable size.  Also, new experimental support for Android has been added.", 
            "title": "How far ahead is the project?"
        }, 
        {
            "location": "/#how-can-i-use-it", 
            "text": "You should use the Leiningen plugin for Lux to compile your programs and manage your dependencies.  You can find it here: https://github.com/LuxLang/lux/tree/master/lux-lein  After compiling your program, this will generate a directory named \"target\" and put all the .class files there.  Then, you can run the program like this:  java -jar target/jvm/program.jar", 
            "title": "How can I use it?"
        }, 
        {
            "location": "/#sample", 
            "text": "To take a look at sample Lux projects, check these repositories:   https://github.com/LuxLang/tutorial1  https://github.com/LuxLang/lux/tree/master/luxdoc   The  luxdoc  program was actually used to generate the documentation for the standard library (located here: https://luxlang.github.io/lux/)", 
            "title": "Sample"
        }, 
        {
            "location": "/#whats-the-license", 
            "text": "Mozilla Public License v2.0", 
            "title": "What's the license?"
        }, 
        {
            "location": "/#whats-interesting-about-the-language", 
            "text": "", 
            "title": "What's interesting about the language?"
        }, 
        {
            "location": "/#inspirations", 
            "text": "The language is mostly inspired by the following 3 languages:   Haskell (functional programming)  Clojure (syntax, overall look   feel)  ML (module system)   The compiler is even implemented in Clojure.", 
            "title": "Inspirations"
        }, 
        {
            "location": "/#types", 
            "text": "They are implemented as plain-old data-structures whose expressions get eval'ed by the compiler and integrated into the type-checker.  That means it's actually possible to generate types via functions and macros.", 
            "title": "Types"
        }, 
        {
            "location": "/#module-system", 
            "text": "The module system is heavily inspired by ML, and both signatures and structures are supported.  The main difference between Lux and ML is that ML separates signatures and structures from the rest of the language, whereas Lux implements them on top of the base language.  How?  By implementing signatures as record-types and structures as actual records.", 
            "title": "Module system"
        }, 
        {
            "location": "/#but-why-not-just-use-type-classes", 
            "text": "Haskell's type-class system forces the user to only specify 1 instance for any given type-class and its argument.  If there are more than 1 possible valid instances (as is the case for Monoid of Int), you have to resort to  newtype hacks  to be able to provide alternative implementations.  By using a system like ML's, that problem is averted.  Additionally, by hosting the module system on top of records, which are regular values, you get the further benefit that structures can be parameterized at run-time just like any other value.  You can also write functions that take and return structures (as  functors  do in ML), and you can generate structures on the fly.   Also, Lux now offers a mechanism for easy polymorphism, just like Haskell's type-classes, but built upon it's module system, thanks to the  lux/type/auto  module and its  :::  macro.  You can learn more about that by reading the book and the documentation.", 
            "title": "But, why not just use type-classes?"
        }, 
        {
            "location": "/#functional-programming", 
            "text": "While the means to do Java-interop are provided, Lux is commited to functional programming.  Functions are curried and partial application is as simple as just applying a function to less arguments than it needs (as in Haskell).  e.g.  (map (i.+ 1) (list 1 2 3 4 5))", 
            "title": "Functional programming"
        }, 
        {
            "location": "/#macros", 
            "text": "Unlike in most other lisps, Lux macros are monadic.  The  (Lux a)  type is the one responsible for the magic by threading  Compiler  instances through macros.  You can use  macro:  to define these monadic macros.  Alternatively, you can use the  syntax:  macro, which also offers monadic parsing of Code tokens for convenience.", 
            "title": "Macros"
        }, 
        {
            "location": "/#custom-pattern-matching", 
            "text": "", 
            "title": "Custom pattern-matching"
        }, 
        {
            "location": "/#wait-wut", 
            "text": "Custom pattern-matching basically means that you can use macros to provide custom syntax and features on top of the pattern-matching macro  case .  For instance, the  list  and  list  macros are used to build lists.\nBut you can also use them to destructure lists inside pattern-matching:  (case (: (List Int) (list 1 2 3))\n  (#Cons x (#Cons y (#Cons z #Nil)))\n  (#Some ($_ i.* x y z))\n\n  _\n  #None)\n\n(case (: (List Int) (list 1 2 3))\n  (^ (list x y z))\n  (#Some ($_ i.* x y z))\n\n  _\n  #None)  There is also the special  ^or  macro, which introduces  or patterns :  (type: Weekday\n  #Monday\n  #Tuesday\n  #Wednesday\n  #Thursday\n  #Friday\n  #Saturday\n  #Sunday))\n\n(def: (weekend? day)\n  (-  Weekday Bool)\n  (case day\n    (^or #Saturday #Sunday)\n    true\n\n    _\n    false))   Please note: ^ and ^or are just macros like any other and anyone can implement them.", 
            "title": "Wait... wut?"
        }, 
        {
            "location": "/#is-there-a-community-for-this", 
            "text": "Come join the discussion group at: https://groups.google.com/forum/#!forum/lux-programming-language  If you want to communicate with me directly, just email me at luxlisp@gmail.com  Also, you can chat with us on Gitter:", 
            "title": "Is there a community for this?"
        }, 
        {
            "location": "/#how-can-i-edit-lux-code", 
            "text": "Check out the Emacs plugin for it: https://github.com/LuxLang/lux/tree/master/lux-mode", 
            "title": "How can I edit Lux code?"
        }, 
        {
            "location": "/#where-do-i-learn-lux", 
            "text": "The main resource is the book: https://www.gitbook.com/book/luxlang/the-lux-programming-language/details  It will always be up-to-date with the latest stable version of the language.  Also, you can check out the documentation for the currently available modules: https://luxlang.github.io/lux/  Finally, you can check out the Lux DevLog, where I talk about different topics related to Lux and post tutorials: http://luxlang.blogspot.com/", 
            "title": "Where do I learn Lux?"
        }, 
        {
            "location": "/#how-can-i-contribute", 
            "text": "For starters, you can check out the Trello board for Lux development: https://trello.com/b/VRQhvXjs/lux-jvm-compiler  I'll be putting there tasks that people can contribute to; both in the compiler and outside (like plugins for editors).  Writing libraries in Lux will also help a lot in making this a more practical language for day to day use.  Communication is done over Gitter and the Google group.", 
            "title": "How can I contribute?"
        }, 
        {
            "location": "/#copyright-c-2014-2017-eduardo-julian-all-rights-reserved", 
            "text": "", 
            "title": "Copyright (c) 2014-2017 Eduardo Julian. All rights reserved."
        }, 
        {
            "location": "/lux/", 
            "text": "lux\n\n\nTypes\n\n\nAST\n\n\nThe type of AST nodes for Lux syntax.\n\n\n(type: AST\n  (Meta Cursor (AST' (Meta Cursor))))\n\n\n\n\nAST'\n\n\n(type: (AST' w)\n  (#BoolS Bool)\n  (#NatS Nat)\n  (#IntS Int)\n  (#FracS Frac)\n  (#RealS Real)\n  (#CharS Char)\n  (#TextS Text)\n  (#SymbolS Ident)\n  (#TagS Ident)\n  (#FormS (List (w (AST' w))))\n  (#TupleS (List (w (AST' w))))\n  (#RecordS (List [(w (AST' w)) (w (AST' w))])))\n\n\n\n\nAnalysis\n\n\n(type: Analysis\n  (Meta [Type Cursor] Void))\n\n\n\n\nAnn-Value\n\n\nThe value of an individual annotation.\n\n\n(type: #rec Ann-Value\n  (#BoolM Bool)\n  (#NatM Nat)\n  (#IntM Int)\n  (#FracM Frac)\n  (#RealM Real)\n  (#CharM Char)\n  (#TextM Text)\n  (#IdentM Ident)\n  (#ListM (List Ann-Value))\n  (#DictM (List [Text Ann-Value])))\n\n\n\n\nAnns\n\n\nA set of annotations associated with a definition.\n\n\n(type: Anns\n  (List [Ident Ann-Value]))\n\n\n\n\nBindings\n\n\n(type: (Bindings k v)\n  {#counter Nat\n   #mappings (List [k v])})\n\n\n\n\nBool\n\n\nYour standard, run-of-the-mill boolean values.\n\n\n(type: Bool\n  (host java.lang.Boolean))\n\n\n\n\nBottom\n\n\nThe type of things whose type is unknown or undefined.\n\n\nUseful for expressions that cause errors or other \"extraordinary\" conditions.\n\n\n(type: Bottom\n  (All [a] a))\n\n\n\n\nChar\n\n\nYour standard, run-of-the-mill character values.\n\n\n(type: Char\n  (host java.lang.Character))\n\n\n\n\nCompiler\n\n\nRepresents the state of the Lux compiler during a run.\n\n\nIt is provided to macros during their invocation, so they can access compiler data.\n\n\nCaveat emptor: Avoid fiddling with it, unless you know what you're doing.\n\n\n(type: Compiler\n  {#info Compiler-Info\n   #source Source\n   #cursor Cursor\n   #modules (List [Text Module])\n   #scopes (List Scope)\n   #type-vars (Bindings Nat (Maybe Type))\n   #expected (Maybe Type)\n   #seed Nat\n   #scope-type-vars (List Nat)\n   #host Void})\n\n\n\n\nCompiler-Info\n\n\nInformation about the current version and type of compiler that is running.\n\n\n(type: Compiler-Info\n  {#compiler-name Text\n   #compiler-version Text\n   #compiler-mode Compiler-Mode})\n\n\n\n\nCompiler-Mode\n\n\nA sign that shows the conditions under which the compiler is running.\n\n\n(type: Compiler-Mode\n  #Release\n  #Debug\n  #Eval\n  #REPL)\n\n\n\n\nCursor\n\n\nCursors are for specifying the location of AST nodes in Lux files during compilation.\n\n\n(type: Cursor\n  {#module Text\n   #line Int\n   #column Int})\n\n\n\n\nDef\n\n\nRepresents all the data associated with a definition: its type, its annotations, and its value.\n\n\n(type: Def\n  [Type Anns Void])\n\n\n\n\nEither\n\n\nA choice between two values of different types.\n\n\n(type: (Either l r)\n  (#Left l)\n  (#Right r))\n\n\n\n\nFrac\n\n\nFractional numbers that live in the interval [0,1).\n\n\nUseful for probability, and other domains that work within that interval.\n\n\n(type: Frac\n  (host #Frac))\n\n\n\n\nIdent\n\n\nAn identifier.\n\n\nIt is used as part of Lux syntax to represent symbols and tags.\n\n\n(type: Ident\n  [Text Text])\n\n\n\n\nInt\n\n\nYour standard, run-of-the-mill integer numbers.\n\n\n(type: Int\n  (host java.lang.Long))\n\n\n\n\nList\n\n\nA potentially empty list of values.\n\n\n(type: (List a)\n  #Nil\n  (#Cons a (List a)))\n\n\n\n\nLux\n\n\nComputations that can have access to the state of the compiler.\n\n\nThese computations may fail, or modify the state of the compiler.\n\n\n(type: (Lux a)\n  (-\n Compiler (Either Text [Compiler a])))\n\n\n\n\nMacro\n\n\nFunctions that run at compile-time and allow you to transform and extend the language in powerful ways.\n\n\n(type: Macro\n  (-\n (List AST) (Lux (List AST))))\n\n\n\n\nMaybe\n\n\nA potentially missing value.\n\n\n(type: (Maybe a)\n  #None\n  (#Some a))\n\n\n\n\nMeta\n\n\nThe type of things that can have meta-data of arbitrary types.\n\n\n(type: (Meta m v)\n  {#meta m\n   #datum v})\n\n\n\n\nModule\n\n\nAll the information contained within a Lux module.\n\n\n(type: Module\n  {#module-hash Int\n   #module-aliases (List [Text Text])\n   #defs (List [Text Def])\n   #imports (List Text)\n   #tags (List [Text Nat (List Ident) Bool Type])\n   #types (List [Text (List Ident) Bool Type])\n   #module-anns Anns})\n\n\n\n\nNat\n\n\nNatural numbers (unsigned integers).\n\n\nThey start at zero (+0) and extend in the positive direction.\n\n\n(type: Nat\n  (host #Nat))\n\n\n\n\nReal\n\n\nYour standard, run-of-the-mill floating-point numbers.\n\n\n(type: Real\n  (host java.lang.Double))\n\n\n\n\nScope\n\n\n(type: Scope\n  {#name (List Text)\n   #inner-closures Int\n   #locals (Bindings Text Analysis)\n   #closure (Bindings Text Analysis)})\n\n\n\n\nSource\n\n\n(type: Source\n  (List (Meta Cursor Text)))\n\n\n\n\nText\n\n\nYour standard, run-of-the-mill string values.\n\n\n(type: Text\n  (host java.lang.String))\n\n\n\n\nTop\n\n\nThe type of things whose type doesn't matter.\n\n\nIt can be used to write functions or data-structures that can take, or return, anything.\n\n\n(type: Top\n  (Ex [a] a))\n\n\n\n\nType\n\n\nThis type represents the data-structures that are used to specify types themselves.\n\n\n(type: #rec Type\n  (#HostT Text (List Type))\n  #VoidT\n  #UnitT\n  (#SumT Type Type)\n  (#ProdT Type Type)\n  (#LambdaT Type Type)\n  (#BoundT Nat)\n  (#VarT Nat)\n  (#ExT Nat)\n  (#UnivQ (List Type) Type)\n  (#ExQ (List Type) Type)\n  (#AppT Type Type)\n  (#NamedT Ident Type))\n\n\n\n\nUnit\n\n\nAn unusual type that only possesses a single value: []\n\n\n(type: Unit\n  Unit)\n\n\n\n\nVoid\n\n\nAn unusual type that possesses no value, and thus can't be instantiated.\n\n\n(type: Void\n  Void)\n\n\n\n\nMacros\n\n\n$\n\n\n## Allows you to refer to the type-variables in a polymorphic function's type, by their index.\n## In the example below, +0 corresponds to the 'a' variable.\n(def: #export (from-list list)\n  (All [a] (-\n (List a) (Vector a)))\n  (List/fold add\n             (: (Vector ($ +0))\n                empty)\n             list))\n\n\n\n\n$_\n\n\n## Right-association for the application of binary functions over variadic arguments.\n($_ Text/append \nHello, \n name \n.\\nHow are you?\n)\n\n## =\n\n(Text/append \nHello, \n (Text/append name \n.\\nHow are you?\n))\n\n\n\n\n\n\n## Tuple types:\n(\n Text Int Bool)\n\n## The empty tuple, a.k.a. Unit.\n(\n)\n\n\n\n\n'\n\n\n## Quotation as a macro.\n(' \nYOLO\n)\n\n\n\n\n-\n\n\n## Function types:\n(-\n Int Int Int)\n\n## This is the type of a function that takes 2 Ints and returns an Int.\n\n\n\n\n:\n\n\n## The type-annotation macro.\n(: (List Int) (list 1 2 3))\n\n\n\n\n:!\n\n\n## The type-coercion macro.\n(:! Dinosaur (list 1 2 3))\n\n\n\n\n:!!\n\n\n## Coerces the given expression to the type of whatever is expected.\n(: Dinosaur (:!! (list 1 2 3)))\n\n\n\n\n::\n\n\n## Allows accessing the value of a structure's member.\n(:: Codec\nText,Int\n encode)\n\n## Also allows using that value as a function.\n(:: Codec\nText,Int\n encode 123)\n\n\n\n\n|\n\n\n## Reverse piping macro.\n(\n| (fold Text/append \n) (interpose \n \n) (map -\nText) elems)\n\n## =\n\n(fold Text/append \n\n      (interpose \n \n\n                 (map -\nText elems)))\n\n\n\n\n@post\n\n\n## Post-conditions.\n## Given a predicate and an expression to run, evaluates the expression and then tests the output with the predicate.\n## If the predicate returns true, returns the value of the expression.\n## Otherwise, an error is raised.\n(@post i.even?\n       (i.+ 2 2))\n\n\n\n\n@pre\n\n\n## Pre-conditions.\n## Given a test and an expression to run, only runs the expression if the test passes.\n## Otherwise, an error is raised.\n(@pre (i.= 4 (i.+ 2 2))\n      (foo 123 456 789))\n\n\n\n\nAll\n\n\n## Universal quantification.\n(All [a]\n  (-\n a a))\n\n## A name can be provided, to specify a recursive type.\n(All List [a]\n  (| Unit\n     [a (List a)]))\n\n\n\n\nEx\n\n\n## Existential quantification.\n(Ex [a]\n  [(Codec Text a)\n   a])\n\n## A name can be provided, to specify a recursive type.\n(Ex Self [a]\n  [(Codec Text a)\n   a\n   (List (Self a))])\n\n\n\n\nRec\n\n\n## Parameter-less recursive types.\n## A name has to be given to the whole type, to use it within it's body.\n(Rec Self\n  [Int (List Self)])\n\n\n\n\n^\n\n\n## Macro-expanding patterns.\n## It's a special macro meant to be used with 'case'.\n(case (: (List Int) (list 1 2 3))\n  (^ (list x y z))\n  (#Some ($_ i.* x y z))\n\n  _\n  #None)\n\n\n\n\n^=\n\n\n## Multi-level pattern matching.\n## Useful in situations where the result of a branch depends on further refinements on the values being matched.\n## For example:\n(case (split (size static) uri)\n  (^=\n (#lux;Some[chunk uri']) [(Text/= static chunk) true])\n  (match-uri endpoint? parts' uri')\n\n  _\n  (#lux;Left(format \nStatic part \n (%t static) \n doesn't match URI: \n uri)))\n\n## Short-cuts can be taken when using boolean tests.\n## The example above can be rewritten as...\n(case (split (size static) uri)\n  (^=\n (#lux;Some[chunk uri']) (Text/= static chunk))\n  (match-uri endpoint? parts' uri')\n\n  _\n  (#lux;Left(format \nStatic part \n (%t static) \n doesn't match URI: \n uri)))\n\n\n\n\n^@\n\n\n## Allows you to simultaneously bind and de-structure a value.\n(def: (hash (^@ set [Hash\na\n _]))\n  (List/fold (lambda [elem acc] (n.+ (:: Hash\na\n hash elem) acc))\n             +0\n             (to-list set)))\n\n\n\n\n^open\n\n\n## Same as the \nopen\n macro, but meant to be used as a pattern-matching macro for generating local bindings.\n## Can optionally take a \nprefix\n text for the generated local bindings.\n(def: #export (range (^open) from to)\n  (All [a] (-\n (Enum a) a a (List a)))\n  (range' \n= succ from to))\n\n\n\n\n^or\n\n\n## Or-patterns.\n## It's a special macro meant to be used with 'case'.\n(type: Weekday\n  #Monday\n  #Tuesday\n  #Wednesday\n  #Thursday\n  #Friday\n  #Saturday\n  #Sunday)\n\n(def: (weekend? day)\n  (-\n Weekday Bool)\n  (case day\n    (^or #Saturday #Sunday)\n    true\n\n    _\n    false))\n\n\n\n\n^slots\n\n\n## Allows you to extract record members as local variables with the same names.\n## For example:\n(let [(^slots [#foo #bar #baz]) quux]\n  (f foo bar baz))\n\n\n\n\n^template\n\n\n## It's similar to do-template, but meant to be used during pattern-matching.\n(def: (beta-reduce env type)\n  (-\n (List Type) Type Type)\n  (case type\n    (#;HostT name params)\n    (#;HostT name (List/map (beta-reduce env) params))\n\n    (^template [\ntag\n]\n      (\ntag\n left right)\n      (\ntag\n (beta-reduce env left) (beta-reduce env right)))\n    ([#;SumT] [#;ProdT])\n\n    (^template [\ntag\n]\n      (\ntag\n left right)\n      (\ntag\n (beta-reduce env left) (beta-reduce env right)))\n    ([#;LambdaT]\n     [#;AppT])\n\n    (^template [\ntag\n]\n      (\ntag\n old-env def)\n      (case old-env\n        #;Nil\n        (\ntag\n env def)\n\n        _\n        type))\n    ([#;UnivQ]\n     [#;ExQ])\n\n    (#;BoundT idx)\n    (default type (list;at idx env))\n\n    _\n    type\n    ))\n\n\n\n\n^|\n\n\n## Pipes the value being pattern-matched against prior to binding it to a variable.\n(case input\n  (^|\n value [n.inc (n.% +10) (n.max +1)])\n  (foo value))\n\n\n\n\n^~\n\n\n## Use global defs with simple values, such as text, int, real, bool and char, in place of literals in patterns.\n## The definitions must be properly-qualified (though you may use one of the short-cuts Lux provides).\n(def: (empty?' node)\n  (All [K V] (-\n (Node K V) Bool))\n  (case node\n    (^~ (#Base lux;clean-bitmap_))\n    true\n\n    _\n    false))\n\n\n\n\n_$\n\n\n## Left-association for the application of binary functions over variadic arguments.\n(_$ Text/append \nHello, \n name \n.\\nHow are you?\n)\n\n## =\n\n(Text/append (Text/append \nHello, \n name) \n.\\nHow are you?\n)\n\n\n\n\n`\n\n\n## Hygienic quasi-quotation as a macro. Unquote (~) and unquote-splice (~@) must also be used as forms.\n## All unprefixed macros will receive their parent module's prefix if imported; otherwise will receive the prefix of the module on which the quasi-quote is being used.\n(` (def: (~ name)\n     (lambda [(~@ args)]\n       (~ body))))\n\n\n\n\n`'\n\n\n## Unhygienic quasi-quotation as a macro. Unquote (~) and unquote-splice (~@) must also be used as forms.\n(`' (def: (~ name)\n      (lambda [(~@ args)]\n        (~ body))))\n\n\n\n\nand\n\n\nShort-circuiting \nand\n.\n(and true false true) ## =\n false\n\n\n\n\ncase\n\n\n## The pattern-matching macro.\n## Allows the usage of macros within the patterns to provide custom syntax.\n(case (: (List Int) (list 1 2 3))\n  (#Cons x (#Cons y (#Cons z #Nil)))\n  (#Some ($_ i.* x y z))\n\n  _\n  #None)\n\n\n\n\ncomment\n\n\n## Throws away any code given to it.\n## Great for commenting-out code, while retaining syntax high-lighting and formatting in your text editor.\n(comment 1 2 3 4)\n\n\n\n\ncond\n\n\n## Branching structures with multiple test conditions.\n(cond (n.even? num) \neven\n\n      (n.odd? num) \nodd\n\n      ## else-branch\n      \n???\n)\n\n\n\n\ndef:\n\n\n## Defines global constants/functions.\n(def: (rejoin-pair pair)\n  (-\n [AST AST] (List AST))\n  (let [[left right] pair]\n    (list left right)))\n\n(def: branching-exponent\n  Int\n  5)\n\n\n\n\ndefault\n\n\n## Allows you to provide a default value that will be used\n## if a (Maybe x) value turns out to be #;None.\n(default 20 (#;Some 10)) =\n 10\n\n(default 20 #;None) =\n 20\n\n\n\n\ndo-template\n\n\n## By specifying a pattern (with holes), and the input data to fill those holes, repeats the pattern as many times as necessary.\n(do-template [\nname\n \ndiff\n]\n             [(def: #export \nname\n\n                (-\n Int Int)\n                (i.+ \ndiff\n))]\n\n             [i.inc  1]\n             [i.dec -1])\n\n\n\n\ndoc\n\n\n## Creates code documentation, embedding text as comments and properly formatting the forms it's being given.\n\n## For Example:\n(doc \nAllows arbitrary looping, using the \\\nrecur\\\n form to re-start the loop.\n      Can be used in monadic code to create monadic loops.\n\n     (loop [count 0\n            x init]\n       (if (\n 10 count)\n         (recur (i.inc count) (f x))\n         x)))\n\n\n\n\nexec\n\n\n## Sequential execution of expressions (great for side-effects).\n(exec\n  (log! \n#1\n)\n  (log! \n#2\n)\n  (log! \n#3\n)\n  \nYOLO\n)\n\n\n\n\nget@\n\n\n## Accesses the value of a record at a given tag.\n(get@ #field my-record)\n\n## Can also work with multiple levels of nesting:\n(get@ [#foo #bar #baz] my-record)\n\n## And, if only the slot/path is given, generates an\n## accessor function:\n(let [getter (get@ [#foo #bar #baz])]\n  (getter my-record))\n\n\n\n\nhost\n\n\n## Macro to treat host-types as Lux-types.\n(host java.lang.Object)\n\n(host java.util.List [java.lang.Long])\n\n\n\n\nident-for\n\n\n## Given a symbol or a tag, gives back a 2 tuple with the prefix and name parts, both as Text.\n(ident-for #lux;doc)\n\n## =\n\n[\nlux\n \ndoc\n]\n\n\n\n\nif\n\n\nPicks which expression to evaluate based on a boolean test value.\n\n(if true\n  \nOh, yeah!\n\n  \nAw hell naw!\n)\n\n== \nOh, yeah!\n\n\n\n\n\nlambda\n\n\n## Syntax for creating functions.\n## Allows for giving the function itself a name, for the sake of recursion.\n(: (All [a b] (-\n a b a))\n   (lambda [x y] x))\n\n(: (All [a b] (-\n a b a))\n   (lambda const [x y] x))\n\n\n\n\nlet\n\n\n## Creates local bindings.\n## Can (optionally) use pattern-matching macros when binding.\n(let [x (foo bar)\n      y (baz quux)]\n  (op x y))\n\n\n\n\nlet%\n\n\n## Controlled macro-expansion.\n## Bind an arbitraty number of ASTs resulting from macro-expansion to local bindings.\n## Wherever a binding appears, the bound ASTs will be spliced in there.\n(test: \nAST operations \n structures\n\n  (let% [\ntests\n (do-template [\nexpr\n \ntext\n \npattern\n]\n                   [(compare \npattern\n \nexpr\n)\n                    (compare \ntext\n (:: AST/encode show \nexpr\n))\n                    (compare true (:: Eq\nAST\n = \nexpr\n \nexpr\n))]\n\n                   [(bool true)                             \ntrue\n       [[\n -1 -1] (#lux;BoolStrue)]]\n                   [(bool false)                            \nfalse\n      [_ (#lux;BoolSfalse)]]\n                   [(int 123)                               \n123\n        [_ (#lux;IntS123)]]\n                   [(real 123.0)                            \n123.0\n      [_ (#lux;RealS123.0)]]\n                   [(char #\n\\n\n)                            \n#\\\\\n\\\\n\\\\\n [_ (#lux;CharS#\n\\n\n)]]\n                   [(text \n\\\\n\n)                            \n\\\\\n\\\\n\\\\\n  [_ (#lux;TextS\n\\\\n\n)]]\n                   [(tag [\nyolo\n \nlol\n])                    \n#yolo;lol\n  [_ (#lux;TagS[\nyolo\n \nlol\n])]]\n                   [(symbol [\nyolo\n \nlol\n])                 \nyolo;lol\n   [_ (#lux;SymbolS[\nyolo\n \nlol\n])]]\n                   [(form (list (bool true) (int 123)))     \n(true 123)\n (^ [_ (#lux;FormS(list [_ (#lux;BoolStrue)] [_ (#lux;IntS123)]))])]\n                   [(tuple (list (bool true) (int 123)))    \n[true 123]\n (^ [_ (#lux;TupleS(list [_ (#lux;BoolStrue)] [_ (#lux;IntS123)]))])]\n                   [(record (list [(bool true) (int 123)])) \n{true 123}\n (^ [_ (#lux;RecordS(list [[_ (#lux;BoolStrue)] [_ (#lux;IntS123)]]))])]\n                   [(local-tag \nlol\n)                       \n#lol\n       [_ (#lux;TagS[\n \nlol\n])]]\n                   [(local-symbol \nlol\n)                    \nlol\n        [_ (#lux;SymbolS[\n \nlol\n])]])]\n\n    (test-all \ntests\n)))\n\n\n\n\nlist\n\n\n## List-construction macro.\n(list 1 2 3)\n\n\n\n\nlist\n\n\n## List-construction macro, with the last element being a tail-list.\n## In other words, this macro prepends elements to another list.\n(list\n 1 2 3 (list 4 5 6))\n\n\n\n\nloop\n\n\n## Allows arbitrary looping, using the \nrecur\n form to re-start the loop.\n## Can be used in monadic code to create monadic loops.\n(loop [count 0\n       x init]\n  (if (\n 10 count)\n    (recur (i.inc count) (f x))\n    x))\n\n\n\n\nmacro:\n\n\nMacro-definition macro.\n\n(macro: #export (ident-for tokens)\n  (case tokens\n    (^template [\ntag\n]\n     (^ (list [_ (\ntag\n [prefix name])]))\n     (return (list (` [(~ (text$ prefix)) (~ (text$ name))]))))\n    ([#;SymbolS] [#;TagS])\n\n    _\n    (fail \nWrong syntax for ident-for\n)))\n\n\n\n\nmodule:\n\n\nModule-definition macro.\n\nCan take optional annotations and allows the specification of modules to import.\n\n## Examples\n(;module: {#;doc \nSome documentation...\n}\n  lux\n  (lux (control (monad #as M #refer #all))\n       (data (text #open (\nText/\n Monoid\nText\n))\n             (struct (list #open (\nList/\n Monad\nList\n)))\n             maybe\n             (ident #open (\nIdent/\n Codec\nText,Ident\n)))\n       meta\n       (macro ast))\n  (.. (type #open (\n Eq\nType\n))))\n\n(;module: {#;doc \nSome documentation...\n}\n  lux\n  (lux (control [\nM\n monad #*])\n       (data [text \nText/\n Monoid\nText\n]\n             (struct [list \nList/\n Monad\nList\n])\n             maybe\n             [ident \nIdent/\n Codec\nText,Ident\n])\n       meta\n       (macro ast))\n  (.. [type \n Eq\nType\n]))\n\n\n\n\nopen\n\n\n## Opens a structure and generates a definition for each of its members (including nested members).\n## For example:\n(open Number\nInt\n \ni:\n)\n## Will generate:\n(def: i:+ (:: Number\nInt\n +))\n(def: i:- (:: Number\nInt\n -))\n(def: i:* (:: Number\nInt\n *))\n...\n\n\n\n\nor\n\n\nShort-circuiting \nor\n.\n(or true false true) ## =\n true\n\n\n\n\nset@\n\n\n## Sets the value of a record at a given tag.\n(set@ #name \nLux\n lang)\n\n## Can also work with multiple levels of nesting:\n(set@ [#foo #bar #baz] value my-record)\n\n## And, if only the slot/path and (optionally) the value are given, generates a\n## mutator function:\n(let [setter (set@ [#foo #bar #baz] value)]\n  (setter my-record))\n\n(let [setter (set@ [#foo #bar #baz])]\n  (setter value my-record))\n\n\n\n\nsig:\n\n\n## Definition of signatures ala ML.\n(sig: #export (Ord a)\n  (: (Eq a)\n     eq)\n  (: (-\n a a Bool)\n     \n)\n  (: (-\n a a Bool)\n     \n=)\n  (: (-\n a a Bool)\n     \n)\n  (: (-\n a a Bool)\n     \n=))\n\n\n\n\nstruct\n\n\nNot meant to be used directly. Prefer \nstruct:\n.\n\n\n\n\nstruct:\n\n\n## Definition of structures ala ML.\n(struct: #export Ord\nInt\n (Ord Int)\n  (def: eq Eq\nInt\n)\n  (def: (\n test subject)\n    (lux;\n test subject))\n  (def: (\n= test subject)\n    (or (lux;\n test subject)\n        (lux;= test subject)))\n  (def: (lux;\n test subject)\n    (lux;\n test subject))\n  (def: (lux;\n= test subject)\n    (or (lux;\n test subject)\n        (lux;= test subject))))\n\n\n\n\ntemplate:\n\n\n## Define macros in the style of do-template and ^template.\n## For simple macros that don't need any fancy features.\n(template: (square x)\n  (i.* x x))\n\n\n\n\ntype\n\n\n## Takes a type expression and returns it's representation as data-structure.\n(type (All [a] (Maybe (List a))))\n\n\n\n\ntype-of\n\n\n## Generates the type corresponding to a given definition or variable.\n(let [my-num (: Int 123)]\n  (type-of my-num))\n\n## ==\nInt\n\n\n\n\ntype:\n\n\n## The type-definition macro.\n(type: (List a)\n  #Nil\n  (#Cons a (List a)))\n\n\n\n\nundefined\n\n\n## Meant to be used as a stand-in for functions with undefined implementations.\n## Undefined expressions will type-check against everything, so they make good dummy implementations.\n(def: (square x)\n  (-\n Int Int)\n  (undefined))\n\n## If an undefined expression is ever evaluated, it will raise an error.\n\n\n\n\nupdate@\n\n\n## Modifies the value of a record at a given tag, based on some function.\n(update@ #age i.inc person)\n\n## Can also work with multiple levels of nesting:\n(update@ [#foo #bar #baz] func my-record)\n\n## And, if only the slot/path and (optionally) the value are given, generates a\n## mutator function:\n(let [updater (update@ [#foo #bar #baz] func)]\n  (updater my-record))\n\n(let [updater (update@ [#foo #bar #baz])]\n  (updater func my-record))\n\n\n\n\nwith-cursor\n\n\n## Given some text, appends to it a prefix for identifying where the text comes from.\n## For example:\n(with-cursor (format \nUser: \n user-id))\n\n## Would be the same as:\n(format \n[the-module,the-line,the-column] \n (format \nUser: \n user-id))\n\n\n\n\n|\n\n\n## Variant types:\n(| Text Int Bool)\n\n## The empty tuple, a.k.a. Void.\n(|)\n\n\n\n\n|\n\n\n## Piping macro.\n(|\n elems (map -\nText) (interpose \n \n) (fold Text/append \n))\n\n## =\n\n(fold Text/append \n\n      (interpose \n \n\n                 (map -\nText elems)))\n\n\n\n\n|\n.\n\n\n## Similar to the piping macro, but rather than taking an initial object to work on, creates a function for taking it.\n(|\n (map -\nText) (interpose \n \n) (fold Text/append \n))\n## =\n\n(lambda [\nsomething\n]\n  (fold Text/append \n\n         (interpose \n \n\n                    (map -\nText \nsomething\n))))\n\n\n\n\nValues\n\n\n.\n\n\nFunction composition.\n\n\n\n\n(All [a b c] (-\n (-\n b c) (-\n a b) a c))\n\n\n(error! message)\n\n\n## Causes an error, with the given error message.\n(error! \nOH NO!\n)\n\n\n\n\n(-\n Text Bottom)\n\n\nf.%\n\n\nFrac(tional) remainder.\n\n\n\n\n(-\n Frac Frac Frac)\n\n\nf.*\n\n\nFrac(tional) multiplication.\n\n\n\n\n(-\n Frac Frac Frac)\n\n\nf.+\n\n\nFrac(tional) addition.\n\n\n\n\n(-\n Frac Frac Frac)\n\n\nf.-\n\n\nFrac(tional) substraction.\n\n\n\n\n(-\n Frac Frac Frac)\n\n\nf./\n\n\nFrac(tional) division.\n\n\n\n\n(-\n Frac Frac Frac)\n\n\nf.\n\n\nFractional less-than.\n\n\n\n\n(-\n Frac Frac Bool)\n\n\nf.\n=\n\n\nFractional less-than-equal.\n\n\n\n\n(-\n Frac Frac Bool)\n\n\nf.=\n\n\nFractional equality.\n\n\n\n\n(-\n Frac Frac Bool)\n\n\nf.\n\n\nFractional greater-than.\n\n\n\n\n(-\n Frac Frac Bool)\n\n\nf.\n=\n\n\nFractional greater-than-equal.\n\n\n\n\n(-\n Frac Frac Bool)\n\n\nf.max\n\n\nFrac(tional) maximum.\n\n\n\n\n(-\n Frac Frac Frac)\n\n\nf.min\n\n\nFrac(tional) minimum.\n\n\n\n\n(-\n Frac Frac Frac)\n\n\n(frac-to-real input)\n\n\n(-\n Frac Real)\n\n\ni.%\n\n\nInt(eger) remainder.\n\n\n\n\n(-\n Int Int Int)\n\n\ni.*\n\n\nInt(eger) multiplication.\n\n\n\n\n(-\n Int Int Int)\n\n\ni.+\n\n\nInt(eger) addition.\n\n\n\n\n(-\n Int Int Int)\n\n\ni.-\n\n\nInt(eger) substraction.\n\n\n\n\n(-\n Int Int Int)\n\n\ni./\n\n\nInt(eger) division.\n\n\n\n\n(-\n Int Int Int)\n\n\ni.\n\n\nInteger less-than.\n\n\n\n\n(-\n Int Int Bool)\n\n\ni.\n=\n\n\nInteger less-than-equal.\n\n\n\n\n(-\n Int Int Bool)\n\n\ni.=\n\n\nInteger equality.\n\n\n\n\n(-\n Int Int Bool)\n\n\ni.\n\n\nInteger greater-than.\n\n\n\n\n(-\n Int Int Bool)\n\n\ni.\n=\n\n\nInteger greater-than-equal.\n\n\n\n\n(-\n Int Int Bool)\n\n\n(i.dec value)\n\n\nDecrement function.\n\n\n\n\n(-\n Int Int)\n\n\n(i.even? n)\n\n\n(-\n Int Bool)\n\n\n(i.inc value)\n\n\nIncrement function.\n\n\n\n\n(-\n Int Int)\n\n\ni.max\n\n\nInt(eger) maximum.\n\n\n\n\n(-\n Int Int Int)\n\n\ni.min\n\n\nInt(eger) minimum.\n\n\n\n\n(-\n Int Int Int)\n\n\n(i.odd? n)\n\n\n(-\n Int Bool)\n\n\n(id x)\n\n\nIdentity function.\n\nDoes nothing to it's argument and just returns it.\n\n\n\n\n(All [a] (-\n a a))\n\n\n(int-to-nat input)\n\n\n(-\n Int Nat)\n\n\n(int-to-real n)\n\n\n(-\n Int Real)\n\n\n(is left right)\n\n\n## Tests whether the 2 values are identical (not just \nequal\n).\n## This one should succeed:\n(let [value 5]\n  (is 5 5))\n\n## This one should fail:\n(is 5 (i.+ 2 3))\n\n\n\n\n(All [a] (-\n a a Bool))\n\n\nlog!\n\n\nLogs message to standard output.\n\nUseful for debugging.\n\n\n\n\n(-\n Text Unit)\n\n\nn.%\n\n\nNat(ural) remainder.\n\n\n\n\n(-\n Nat Nat Nat)\n\n\nn.*\n\n\nNat(ural) multiplication.\n\n\n\n\n(-\n Nat Nat Nat)\n\n\nn.+\n\n\nNat(ural) addition.\n\n\n\n\n(-\n Nat Nat Nat)\n\n\nn.-\n\n\nNat(ural) substraction.\n\n\n\n\n(-\n Nat Nat Nat)\n\n\nn./\n\n\nNat(ural) division.\n\n\n\n\n(-\n Nat Nat Nat)\n\n\nn.\n\n\nNatural less-than.\n\n\n\n\n(-\n Nat Nat Bool)\n\n\nn.\n=\n\n\nNatural less-than-equal.\n\n\n\n\n(-\n Nat Nat Bool)\n\n\nn.=\n\n\nNatural equality.\n\n\n\n\n(-\n Nat Nat Bool)\n\n\nn.\n\n\nNatural greater-than.\n\n\n\n\n(-\n Nat Nat Bool)\n\n\nn.\n=\n\n\nNatural greater-than-equal.\n\n\n\n\n(-\n Nat Nat Bool)\n\n\n(n.dec value)\n\n\nDecrement function.\n\n\n\n\n(-\n Nat Nat)\n\n\n(n.even? n)\n\n\n(-\n Nat Bool)\n\n\n(n.inc value)\n\n\nIncrement function.\n\n\n\n\n(-\n Nat Nat)\n\n\nn.max\n\n\nNat(ural) maximum.\n\n\n\n\n(-\n Nat Nat Nat)\n\n\nn.min\n\n\nNat(ural) minimum.\n\n\n\n\n(-\n Nat Nat Nat)\n\n\n(n.odd? n)\n\n\n(-\n Nat Bool)\n\n\n(nat-to-int input)\n\n\n(-\n Nat Int)\n\n\nnot\n\n\n## Boolean negation.\n\n(not true) == false\n\n(not false) == true\n\n\n\n\n(-\n Bool Bool)\n\n\nr.%\n\n\nReal remainder.\n\n\n\n\n(-\n Real Real Real)\n\n\nr.*\n\n\nReal multiplication.\n\n\n\n\n(-\n Real Real Real)\n\n\nr.+\n\n\nReal addition.\n\n\n\n\n(-\n Real Real Real)\n\n\nr.-\n\n\nReal substraction.\n\n\n\n\n(-\n Real Real Real)\n\n\nr./\n\n\nReal division.\n\n\n\n\n(-\n Real Real Real)\n\n\nr.\n\n\nReal less-than.\n\n\n\n\n(-\n Real Real Bool)\n\n\nr.\n=\n\n\nReal less-than-equal.\n\n\n\n\n(-\n Real Real Bool)\n\n\nr.=\n\n\nReal equality.\n\n\n\n\n(-\n Real Real Bool)\n\n\nr.\n\n\nReal greater-than.\n\n\n\n\n(-\n Real Real Bool)\n\n\nr.\n=\n\n\nReal greater-than-equal.\n\n\n\n\n(-\n Real Real Bool)\n\n\nr.max\n\n\nReal minimum.\n\n\n\n\n(-\n Real Real Real)\n\n\nr.min\n\n\nReal minimum.\n\n\n\n\n(-\n Real Real Real)\n\n\n(real-to-frac input)\n\n\n(-\n Real Frac)\n\n\n(real-to-int n)\n\n\n(-\n Real Int)", 
            "title": "Lux"
        }, 
        {
            "location": "/lux/#lux", 
            "text": "", 
            "title": "lux"
        }, 
        {
            "location": "/lux/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux/#ast", 
            "text": "The type of AST nodes for Lux syntax.  (type: AST\n  (Meta Cursor (AST' (Meta Cursor))))", 
            "title": "AST"
        }, 
        {
            "location": "/lux/#ast_1", 
            "text": "(type: (AST' w)\n  (#BoolS Bool)\n  (#NatS Nat)\n  (#IntS Int)\n  (#FracS Frac)\n  (#RealS Real)\n  (#CharS Char)\n  (#TextS Text)\n  (#SymbolS Ident)\n  (#TagS Ident)\n  (#FormS (List (w (AST' w))))\n  (#TupleS (List (w (AST' w))))\n  (#RecordS (List [(w (AST' w)) (w (AST' w))])))", 
            "title": "AST'"
        }, 
        {
            "location": "/lux/#analysis", 
            "text": "(type: Analysis\n  (Meta [Type Cursor] Void))", 
            "title": "Analysis"
        }, 
        {
            "location": "/lux/#ann-value", 
            "text": "The value of an individual annotation.  (type: #rec Ann-Value\n  (#BoolM Bool)\n  (#NatM Nat)\n  (#IntM Int)\n  (#FracM Frac)\n  (#RealM Real)\n  (#CharM Char)\n  (#TextM Text)\n  (#IdentM Ident)\n  (#ListM (List Ann-Value))\n  (#DictM (List [Text Ann-Value])))", 
            "title": "Ann-Value"
        }, 
        {
            "location": "/lux/#anns", 
            "text": "A set of annotations associated with a definition.  (type: Anns\n  (List [Ident Ann-Value]))", 
            "title": "Anns"
        }, 
        {
            "location": "/lux/#bindings", 
            "text": "(type: (Bindings k v)\n  {#counter Nat\n   #mappings (List [k v])})", 
            "title": "Bindings"
        }, 
        {
            "location": "/lux/#bool", 
            "text": "Your standard, run-of-the-mill boolean values.  (type: Bool\n  (host java.lang.Boolean))", 
            "title": "Bool"
        }, 
        {
            "location": "/lux/#bottom", 
            "text": "The type of things whose type is unknown or undefined.  Useful for expressions that cause errors or other \"extraordinary\" conditions.  (type: Bottom\n  (All [a] a))", 
            "title": "Bottom"
        }, 
        {
            "location": "/lux/#char", 
            "text": "Your standard, run-of-the-mill character values.  (type: Char\n  (host java.lang.Character))", 
            "title": "Char"
        }, 
        {
            "location": "/lux/#compiler", 
            "text": "Represents the state of the Lux compiler during a run.  It is provided to macros during their invocation, so they can access compiler data.  Caveat emptor: Avoid fiddling with it, unless you know what you're doing.  (type: Compiler\n  {#info Compiler-Info\n   #source Source\n   #cursor Cursor\n   #modules (List [Text Module])\n   #scopes (List Scope)\n   #type-vars (Bindings Nat (Maybe Type))\n   #expected (Maybe Type)\n   #seed Nat\n   #scope-type-vars (List Nat)\n   #host Void})", 
            "title": "Compiler"
        }, 
        {
            "location": "/lux/#compiler-info", 
            "text": "Information about the current version and type of compiler that is running.  (type: Compiler-Info\n  {#compiler-name Text\n   #compiler-version Text\n   #compiler-mode Compiler-Mode})", 
            "title": "Compiler-Info"
        }, 
        {
            "location": "/lux/#compiler-mode", 
            "text": "A sign that shows the conditions under which the compiler is running.  (type: Compiler-Mode\n  #Release\n  #Debug\n  #Eval\n  #REPL)", 
            "title": "Compiler-Mode"
        }, 
        {
            "location": "/lux/#cursor", 
            "text": "Cursors are for specifying the location of AST nodes in Lux files during compilation.  (type: Cursor\n  {#module Text\n   #line Int\n   #column Int})", 
            "title": "Cursor"
        }, 
        {
            "location": "/lux/#def", 
            "text": "Represents all the data associated with a definition: its type, its annotations, and its value.  (type: Def\n  [Type Anns Void])", 
            "title": "Def"
        }, 
        {
            "location": "/lux/#either", 
            "text": "A choice between two values of different types.  (type: (Either l r)\n  (#Left l)\n  (#Right r))", 
            "title": "Either"
        }, 
        {
            "location": "/lux/#frac", 
            "text": "Fractional numbers that live in the interval [0,1).  Useful for probability, and other domains that work within that interval.  (type: Frac\n  (host #Frac))", 
            "title": "Frac"
        }, 
        {
            "location": "/lux/#ident", 
            "text": "An identifier.  It is used as part of Lux syntax to represent symbols and tags.  (type: Ident\n  [Text Text])", 
            "title": "Ident"
        }, 
        {
            "location": "/lux/#int", 
            "text": "Your standard, run-of-the-mill integer numbers.  (type: Int\n  (host java.lang.Long))", 
            "title": "Int"
        }, 
        {
            "location": "/lux/#list", 
            "text": "A potentially empty list of values.  (type: (List a)\n  #Nil\n  (#Cons a (List a)))", 
            "title": "List"
        }, 
        {
            "location": "/lux/#lux_1", 
            "text": "Computations that can have access to the state of the compiler.  These computations may fail, or modify the state of the compiler.  (type: (Lux a)\n  (-  Compiler (Either Text [Compiler a])))", 
            "title": "Lux"
        }, 
        {
            "location": "/lux/#macro", 
            "text": "Functions that run at compile-time and allow you to transform and extend the language in powerful ways.  (type: Macro\n  (-  (List AST) (Lux (List AST))))", 
            "title": "Macro"
        }, 
        {
            "location": "/lux/#maybe", 
            "text": "A potentially missing value.  (type: (Maybe a)\n  #None\n  (#Some a))", 
            "title": "Maybe"
        }, 
        {
            "location": "/lux/#meta", 
            "text": "The type of things that can have meta-data of arbitrary types.  (type: (Meta m v)\n  {#meta m\n   #datum v})", 
            "title": "Meta"
        }, 
        {
            "location": "/lux/#module", 
            "text": "All the information contained within a Lux module.  (type: Module\n  {#module-hash Int\n   #module-aliases (List [Text Text])\n   #defs (List [Text Def])\n   #imports (List Text)\n   #tags (List [Text Nat (List Ident) Bool Type])\n   #types (List [Text (List Ident) Bool Type])\n   #module-anns Anns})", 
            "title": "Module"
        }, 
        {
            "location": "/lux/#nat", 
            "text": "Natural numbers (unsigned integers).  They start at zero (+0) and extend in the positive direction.  (type: Nat\n  (host #Nat))", 
            "title": "Nat"
        }, 
        {
            "location": "/lux/#real", 
            "text": "Your standard, run-of-the-mill floating-point numbers.  (type: Real\n  (host java.lang.Double))", 
            "title": "Real"
        }, 
        {
            "location": "/lux/#scope", 
            "text": "(type: Scope\n  {#name (List Text)\n   #inner-closures Int\n   #locals (Bindings Text Analysis)\n   #closure (Bindings Text Analysis)})", 
            "title": "Scope"
        }, 
        {
            "location": "/lux/#source", 
            "text": "(type: Source\n  (List (Meta Cursor Text)))", 
            "title": "Source"
        }, 
        {
            "location": "/lux/#text", 
            "text": "Your standard, run-of-the-mill string values.  (type: Text\n  (host java.lang.String))", 
            "title": "Text"
        }, 
        {
            "location": "/lux/#top", 
            "text": "The type of things whose type doesn't matter.  It can be used to write functions or data-structures that can take, or return, anything.  (type: Top\n  (Ex [a] a))", 
            "title": "Top"
        }, 
        {
            "location": "/lux/#type", 
            "text": "This type represents the data-structures that are used to specify types themselves.  (type: #rec Type\n  (#HostT Text (List Type))\n  #VoidT\n  #UnitT\n  (#SumT Type Type)\n  (#ProdT Type Type)\n  (#LambdaT Type Type)\n  (#BoundT Nat)\n  (#VarT Nat)\n  (#ExT Nat)\n  (#UnivQ (List Type) Type)\n  (#ExQ (List Type) Type)\n  (#AppT Type Type)\n  (#NamedT Ident Type))", 
            "title": "Type"
        }, 
        {
            "location": "/lux/#unit", 
            "text": "An unusual type that only possesses a single value: []  (type: Unit\n  Unit)", 
            "title": "Unit"
        }, 
        {
            "location": "/lux/#void", 
            "text": "An unusual type that possesses no value, and thus can't be instantiated.  (type: Void\n  Void)", 
            "title": "Void"
        }, 
        {
            "location": "/lux/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux/#_1", 
            "text": "## Allows you to refer to the type-variables in a polymorphic function's type, by their index.\n## In the example below, +0 corresponds to the 'a' variable.\n(def: #export (from-list list)\n  (All [a] (-  (List a) (Vector a)))\n  (List/fold add\n             (: (Vector ($ +0))\n                empty)\n             list))", 
            "title": "$"
        }, 
        {
            "location": "/lux/#_", 
            "text": "## Right-association for the application of binary functions over variadic arguments.\n($_ Text/append  Hello,   name  .\\nHow are you? )\n\n## = \n(Text/append  Hello,   (Text/append name  .\\nHow are you? ))", 
            "title": "$_"
        }, 
        {
            "location": "/lux/#_2", 
            "text": "## Tuple types:\n(  Text Int Bool)\n\n## The empty tuple, a.k.a. Unit.\n( )", 
            "title": "&amp;"
        }, 
        {
            "location": "/lux/#_3", 
            "text": "## Quotation as a macro.\n('  YOLO )", 
            "title": "'"
        }, 
        {
            "location": "/lux/#-", 
            "text": "## Function types:\n(-  Int Int Int)\n\n## This is the type of a function that takes 2 Ints and returns an Int.", 
            "title": "-&gt;"
        }, 
        {
            "location": "/lux/#_4", 
            "text": "## The type-annotation macro.\n(: (List Int) (list 1 2 3))", 
            "title": ":"
        }, 
        {
            "location": "/lux/#_5", 
            "text": "## The type-coercion macro.\n(:! Dinosaur (list 1 2 3))", 
            "title": ":!"
        }, 
        {
            "location": "/lux/#_6", 
            "text": "## Coerces the given expression to the type of whatever is expected.\n(: Dinosaur (:!! (list 1 2 3)))", 
            "title": ":!!"
        }, 
        {
            "location": "/lux/#_7", 
            "text": "## Allows accessing the value of a structure's member.\n(:: Codec Text,Int  encode)\n\n## Also allows using that value as a function.\n(:: Codec Text,Int  encode 123)", 
            "title": "::"
        }, 
        {
            "location": "/lux/#_8", 
            "text": "## Reverse piping macro.\n( | (fold Text/append  ) (interpose    ) (map - Text) elems)\n\n## = \n(fold Text/append  \n      (interpose    \n                 (map - Text elems)))", 
            "title": "&lt;|"
        }, 
        {
            "location": "/lux/#post", 
            "text": "## Post-conditions.\n## Given a predicate and an expression to run, evaluates the expression and then tests the output with the predicate.\n## If the predicate returns true, returns the value of the expression.\n## Otherwise, an error is raised.\n(@post i.even?\n       (i.+ 2 2))", 
            "title": "@post"
        }, 
        {
            "location": "/lux/#pre", 
            "text": "## Pre-conditions.\n## Given a test and an expression to run, only runs the expression if the test passes.\n## Otherwise, an error is raised.\n(@pre (i.= 4 (i.+ 2 2))\n      (foo 123 456 789))", 
            "title": "@pre"
        }, 
        {
            "location": "/lux/#all", 
            "text": "## Universal quantification.\n(All [a]\n  (-  a a))\n\n## A name can be provided, to specify a recursive type.\n(All List [a]\n  (| Unit\n     [a (List a)]))", 
            "title": "All"
        }, 
        {
            "location": "/lux/#ex", 
            "text": "## Existential quantification.\n(Ex [a]\n  [(Codec Text a)\n   a])\n\n## A name can be provided, to specify a recursive type.\n(Ex Self [a]\n  [(Codec Text a)\n   a\n   (List (Self a))])", 
            "title": "Ex"
        }, 
        {
            "location": "/lux/#rec", 
            "text": "## Parameter-less recursive types.\n## A name has to be given to the whole type, to use it within it's body.\n(Rec Self\n  [Int (List Self)])", 
            "title": "Rec"
        }, 
        {
            "location": "/lux/#_9", 
            "text": "## Macro-expanding patterns.\n## It's a special macro meant to be used with 'case'.\n(case (: (List Int) (list 1 2 3))\n  (^ (list x y z))\n  (#Some ($_ i.* x y z))\n\n  _\n  #None)", 
            "title": "^"
        }, 
        {
            "location": "/lux/#_10", 
            "text": "## Multi-level pattern matching.\n## Useful in situations where the result of a branch depends on further refinements on the values being matched.\n## For example:\n(case (split (size static) uri)\n  (^=  (#lux;Some[chunk uri']) [(Text/= static chunk) true])\n  (match-uri endpoint? parts' uri')\n\n  _\n  (#lux;Left(format  Static part   (%t static)   doesn't match URI:   uri)))\n\n## Short-cuts can be taken when using boolean tests.\n## The example above can be rewritten as...\n(case (split (size static) uri)\n  (^=  (#lux;Some[chunk uri']) (Text/= static chunk))\n  (match-uri endpoint? parts' uri')\n\n  _\n  (#lux;Left(format  Static part   (%t static)   doesn't match URI:   uri)))", 
            "title": "^=&gt;"
        }, 
        {
            "location": "/lux/#_11", 
            "text": "## Allows you to simultaneously bind and de-structure a value.\n(def: (hash (^@ set [Hash a  _]))\n  (List/fold (lambda [elem acc] (n.+ (:: Hash a  hash elem) acc))\n             +0\n             (to-list set)))", 
            "title": "^@"
        }, 
        {
            "location": "/lux/#open", 
            "text": "## Same as the  open  macro, but meant to be used as a pattern-matching macro for generating local bindings.\n## Can optionally take a  prefix  text for the generated local bindings.\n(def: #export (range (^open) from to)\n  (All [a] (-  (Enum a) a a (List a)))\n  (range'  = succ from to))", 
            "title": "^open"
        }, 
        {
            "location": "/lux/#or", 
            "text": "## Or-patterns.\n## It's a special macro meant to be used with 'case'.\n(type: Weekday\n  #Monday\n  #Tuesday\n  #Wednesday\n  #Thursday\n  #Friday\n  #Saturday\n  #Sunday)\n\n(def: (weekend? day)\n  (-  Weekday Bool)\n  (case day\n    (^or #Saturday #Sunday)\n    true\n\n    _\n    false))", 
            "title": "^or"
        }, 
        {
            "location": "/lux/#slots", 
            "text": "## Allows you to extract record members as local variables with the same names.\n## For example:\n(let [(^slots [#foo #bar #baz]) quux]\n  (f foo bar baz))", 
            "title": "^slots"
        }, 
        {
            "location": "/lux/#template", 
            "text": "## It's similar to do-template, but meant to be used during pattern-matching.\n(def: (beta-reduce env type)\n  (-  (List Type) Type Type)\n  (case type\n    (#;HostT name params)\n    (#;HostT name (List/map (beta-reduce env) params))\n\n    (^template [ tag ]\n      ( tag  left right)\n      ( tag  (beta-reduce env left) (beta-reduce env right)))\n    ([#;SumT] [#;ProdT])\n\n    (^template [ tag ]\n      ( tag  left right)\n      ( tag  (beta-reduce env left) (beta-reduce env right)))\n    ([#;LambdaT]\n     [#;AppT])\n\n    (^template [ tag ]\n      ( tag  old-env def)\n      (case old-env\n        #;Nil\n        ( tag  env def)\n\n        _\n        type))\n    ([#;UnivQ]\n     [#;ExQ])\n\n    (#;BoundT idx)\n    (default type (list;at idx env))\n\n    _\n    type\n    ))", 
            "title": "^template"
        }, 
        {
            "location": "/lux/#_12", 
            "text": "## Pipes the value being pattern-matched against prior to binding it to a variable.\n(case input\n  (^|  value [n.inc (n.% +10) (n.max +1)])\n  (foo value))", 
            "title": "^|&gt;"
        }, 
        {
            "location": "/lux/#_13", 
            "text": "## Use global defs with simple values, such as text, int, real, bool and char, in place of literals in patterns.\n## The definitions must be properly-qualified (though you may use one of the short-cuts Lux provides).\n(def: (empty?' node)\n  (All [K V] (-  (Node K V) Bool))\n  (case node\n    (^~ (#Base lux;clean-bitmap_))\n    true\n\n    _\n    false))", 
            "title": "^~"
        }, 
        {
            "location": "/lux/#__1", 
            "text": "## Left-association for the application of binary functions over variadic arguments.\n(_$ Text/append  Hello,   name  .\\nHow are you? )\n\n## = \n(Text/append (Text/append  Hello,   name)  .\\nHow are you? )", 
            "title": "_$"
        }, 
        {
            "location": "/lux/#_14", 
            "text": "## Hygienic quasi-quotation as a macro. Unquote (~) and unquote-splice (~@) must also be used as forms.\n## All unprefixed macros will receive their parent module's prefix if imported; otherwise will receive the prefix of the module on which the quasi-quote is being used.\n(` (def: (~ name)\n     (lambda [(~@ args)]\n       (~ body))))", 
            "title": "`"
        }, 
        {
            "location": "/lux/#_15", 
            "text": "## Unhygienic quasi-quotation as a macro. Unquote (~) and unquote-splice (~@) must also be used as forms.\n(`' (def: (~ name)\n      (lambda [(~@ args)]\n        (~ body))))", 
            "title": "`'"
        }, 
        {
            "location": "/lux/#and", 
            "text": "Short-circuiting  and .\n(and true false true) ## =  false", 
            "title": "and"
        }, 
        {
            "location": "/lux/#case", 
            "text": "## The pattern-matching macro.\n## Allows the usage of macros within the patterns to provide custom syntax.\n(case (: (List Int) (list 1 2 3))\n  (#Cons x (#Cons y (#Cons z #Nil)))\n  (#Some ($_ i.* x y z))\n\n  _\n  #None)", 
            "title": "case"
        }, 
        {
            "location": "/lux/#comment", 
            "text": "## Throws away any code given to it.\n## Great for commenting-out code, while retaining syntax high-lighting and formatting in your text editor.\n(comment 1 2 3 4)", 
            "title": "comment"
        }, 
        {
            "location": "/lux/#cond", 
            "text": "## Branching structures with multiple test conditions.\n(cond (n.even? num)  even \n      (n.odd? num)  odd \n      ## else-branch\n       ??? )", 
            "title": "cond"
        }, 
        {
            "location": "/lux/#def_1", 
            "text": "## Defines global constants/functions.\n(def: (rejoin-pair pair)\n  (-  [AST AST] (List AST))\n  (let [[left right] pair]\n    (list left right)))\n\n(def: branching-exponent\n  Int\n  5)", 
            "title": "def:"
        }, 
        {
            "location": "/lux/#default", 
            "text": "## Allows you to provide a default value that will be used\n## if a (Maybe x) value turns out to be #;None.\n(default 20 (#;Some 10)) =  10\n\n(default 20 #;None) =  20", 
            "title": "default"
        }, 
        {
            "location": "/lux/#do-template", 
            "text": "## By specifying a pattern (with holes), and the input data to fill those holes, repeats the pattern as many times as necessary.\n(do-template [ name   diff ]\n             [(def: #export  name \n                (-  Int Int)\n                (i.+  diff ))]\n\n             [i.inc  1]\n             [i.dec -1])", 
            "title": "do-template"
        }, 
        {
            "location": "/lux/#doc", 
            "text": "## Creates code documentation, embedding text as comments and properly formatting the forms it's being given.\n\n## For Example:\n(doc  Allows arbitrary looping, using the \\ recur\\  form to re-start the loop.\n      Can be used in monadic code to create monadic loops. \n     (loop [count 0\n            x init]\n       (if (  10 count)\n         (recur (i.inc count) (f x))\n         x)))", 
            "title": "doc"
        }, 
        {
            "location": "/lux/#exec", 
            "text": "## Sequential execution of expressions (great for side-effects).\n(exec\n  (log!  #1 )\n  (log!  #2 )\n  (log!  #3 )\n   YOLO )", 
            "title": "exec"
        }, 
        {
            "location": "/lux/#get", 
            "text": "## Accesses the value of a record at a given tag.\n(get@ #field my-record)\n\n## Can also work with multiple levels of nesting:\n(get@ [#foo #bar #baz] my-record)\n\n## And, if only the slot/path is given, generates an\n## accessor function:\n(let [getter (get@ [#foo #bar #baz])]\n  (getter my-record))", 
            "title": "get@"
        }, 
        {
            "location": "/lux/#host", 
            "text": "## Macro to treat host-types as Lux-types.\n(host java.lang.Object)\n\n(host java.util.List [java.lang.Long])", 
            "title": "host"
        }, 
        {
            "location": "/lux/#ident-for", 
            "text": "## Given a symbol or a tag, gives back a 2 tuple with the prefix and name parts, both as Text.\n(ident-for #lux;doc)\n\n## = \n[ lux   doc ]", 
            "title": "ident-for"
        }, 
        {
            "location": "/lux/#if", 
            "text": "Picks which expression to evaluate based on a boolean test value.\n\n(if true\n   Oh, yeah! \n   Aw hell naw! )\n\n==  Oh, yeah!", 
            "title": "if"
        }, 
        {
            "location": "/lux/#lambda", 
            "text": "## Syntax for creating functions.\n## Allows for giving the function itself a name, for the sake of recursion.\n(: (All [a b] (-  a b a))\n   (lambda [x y] x))\n\n(: (All [a b] (-  a b a))\n   (lambda const [x y] x))", 
            "title": "lambda"
        }, 
        {
            "location": "/lux/#let", 
            "text": "## Creates local bindings.\n## Can (optionally) use pattern-matching macros when binding.\n(let [x (foo bar)\n      y (baz quux)]\n  (op x y))", 
            "title": "let"
        }, 
        {
            "location": "/lux/#let_1", 
            "text": "## Controlled macro-expansion.\n## Bind an arbitraty number of ASTs resulting from macro-expansion to local bindings.\n## Wherever a binding appears, the bound ASTs will be spliced in there.\n(test:  AST operations   structures \n  (let% [ tests  (do-template [ expr   text   pattern ]\n                   [(compare  pattern   expr )\n                    (compare  text  (:: AST/encode show  expr ))\n                    (compare true (:: Eq AST  =  expr   expr ))]\n\n                   [(bool true)                              true        [[  -1 -1] (#lux;BoolStrue)]]\n                   [(bool false)                             false       [_ (#lux;BoolSfalse)]]\n                   [(int 123)                                123         [_ (#lux;IntS123)]]\n                   [(real 123.0)                             123.0       [_ (#lux;RealS123.0)]]\n                   [(char # \\n )                             #\\\\ \\\\n\\\\  [_ (#lux;CharS# \\n )]]\n                   [(text  \\\\n )                             \\\\ \\\\n\\\\   [_ (#lux;TextS \\\\n )]]\n                   [(tag [ yolo   lol ])                     #yolo;lol   [_ (#lux;TagS[ yolo   lol ])]]\n                   [(symbol [ yolo   lol ])                  yolo;lol    [_ (#lux;SymbolS[ yolo   lol ])]]\n                   [(form (list (bool true) (int 123)))      (true 123)  (^ [_ (#lux;FormS(list [_ (#lux;BoolStrue)] [_ (#lux;IntS123)]))])]\n                   [(tuple (list (bool true) (int 123)))     [true 123]  (^ [_ (#lux;TupleS(list [_ (#lux;BoolStrue)] [_ (#lux;IntS123)]))])]\n                   [(record (list [(bool true) (int 123)]))  {true 123}  (^ [_ (#lux;RecordS(list [[_ (#lux;BoolStrue)] [_ (#lux;IntS123)]]))])]\n                   [(local-tag  lol )                        #lol        [_ (#lux;TagS[   lol ])]]\n                   [(local-symbol  lol )                     lol         [_ (#lux;SymbolS[   lol ])]])]\n\n    (test-all  tests )))", 
            "title": "let%"
        }, 
        {
            "location": "/lux/#list_1", 
            "text": "## List-construction macro.\n(list 1 2 3)", 
            "title": "list"
        }, 
        {
            "location": "/lux/#list_2", 
            "text": "## List-construction macro, with the last element being a tail-list.\n## In other words, this macro prepends elements to another list.\n(list  1 2 3 (list 4 5 6))", 
            "title": "list&amp;"
        }, 
        {
            "location": "/lux/#loop", 
            "text": "## Allows arbitrary looping, using the  recur  form to re-start the loop.\n## Can be used in monadic code to create monadic loops.\n(loop [count 0\n       x init]\n  (if (  10 count)\n    (recur (i.inc count) (f x))\n    x))", 
            "title": "loop"
        }, 
        {
            "location": "/lux/#macro_1", 
            "text": "Macro-definition macro.\n\n(macro: #export (ident-for tokens)\n  (case tokens\n    (^template [ tag ]\n     (^ (list [_ ( tag  [prefix name])]))\n     (return (list (` [(~ (text$ prefix)) (~ (text$ name))]))))\n    ([#;SymbolS] [#;TagS])\n\n    _\n    (fail  Wrong syntax for ident-for )))", 
            "title": "macro:"
        }, 
        {
            "location": "/lux/#module_1", 
            "text": "Module-definition macro.\n\nCan take optional annotations and allows the specification of modules to import.\n\n## Examples\n(;module: {#;doc  Some documentation... }\n  lux\n  (lux (control (monad #as M #refer #all))\n       (data (text #open ( Text/  Monoid Text ))\n             (struct (list #open ( List/  Monad List )))\n             maybe\n             (ident #open ( Ident/  Codec Text,Ident )))\n       meta\n       (macro ast))\n  (.. (type #open (  Eq Type ))))\n\n(;module: {#;doc  Some documentation... }\n  lux\n  (lux (control [ M  monad #*])\n       (data [text  Text/  Monoid Text ]\n             (struct [list  List/  Monad List ])\n             maybe\n             [ident  Ident/  Codec Text,Ident ])\n       meta\n       (macro ast))\n  (.. [type   Eq Type ]))", 
            "title": "module:"
        }, 
        {
            "location": "/lux/#open_1", 
            "text": "## Opens a structure and generates a definition for each of its members (including nested members).\n## For example:\n(open Number Int   i: )\n## Will generate:\n(def: i:+ (:: Number Int  +))\n(def: i:- (:: Number Int  -))\n(def: i:* (:: Number Int  *))\n...", 
            "title": "open"
        }, 
        {
            "location": "/lux/#or_1", 
            "text": "Short-circuiting  or .\n(or true false true) ## =  true", 
            "title": "or"
        }, 
        {
            "location": "/lux/#set", 
            "text": "## Sets the value of a record at a given tag.\n(set@ #name  Lux  lang)\n\n## Can also work with multiple levels of nesting:\n(set@ [#foo #bar #baz] value my-record)\n\n## And, if only the slot/path and (optionally) the value are given, generates a\n## mutator function:\n(let [setter (set@ [#foo #bar #baz] value)]\n  (setter my-record))\n\n(let [setter (set@ [#foo #bar #baz])]\n  (setter value my-record))", 
            "title": "set@"
        }, 
        {
            "location": "/lux/#sig", 
            "text": "## Definition of signatures ala ML.\n(sig: #export (Ord a)\n  (: (Eq a)\n     eq)\n  (: (-  a a Bool)\n      )\n  (: (-  a a Bool)\n      =)\n  (: (-  a a Bool)\n      )\n  (: (-  a a Bool)\n      =))", 
            "title": "sig:"
        }, 
        {
            "location": "/lux/#struct", 
            "text": "Not meant to be used directly. Prefer  struct: .", 
            "title": "struct"
        }, 
        {
            "location": "/lux/#struct_1", 
            "text": "## Definition of structures ala ML.\n(struct: #export Ord Int  (Ord Int)\n  (def: eq Eq Int )\n  (def: (  test subject)\n    (lux;  test subject))\n  (def: ( = test subject)\n    (or (lux;  test subject)\n        (lux;= test subject)))\n  (def: (lux;  test subject)\n    (lux;  test subject))\n  (def: (lux; = test subject)\n    (or (lux;  test subject)\n        (lux;= test subject))))", 
            "title": "struct:"
        }, 
        {
            "location": "/lux/#template_1", 
            "text": "## Define macros in the style of do-template and ^template.\n## For simple macros that don't need any fancy features.\n(template: (square x)\n  (i.* x x))", 
            "title": "template:"
        }, 
        {
            "location": "/lux/#type_1", 
            "text": "## Takes a type expression and returns it's representation as data-structure.\n(type (All [a] (Maybe (List a))))", 
            "title": "type"
        }, 
        {
            "location": "/lux/#type-of", 
            "text": "## Generates the type corresponding to a given definition or variable.\n(let [my-num (: Int 123)]\n  (type-of my-num))\n\n## ==\nInt", 
            "title": "type-of"
        }, 
        {
            "location": "/lux/#type_2", 
            "text": "## The type-definition macro.\n(type: (List a)\n  #Nil\n  (#Cons a (List a)))", 
            "title": "type:"
        }, 
        {
            "location": "/lux/#undefined", 
            "text": "## Meant to be used as a stand-in for functions with undefined implementations.\n## Undefined expressions will type-check against everything, so they make good dummy implementations.\n(def: (square x)\n  (-  Int Int)\n  (undefined))\n\n## If an undefined expression is ever evaluated, it will raise an error.", 
            "title": "undefined"
        }, 
        {
            "location": "/lux/#update", 
            "text": "## Modifies the value of a record at a given tag, based on some function.\n(update@ #age i.inc person)\n\n## Can also work with multiple levels of nesting:\n(update@ [#foo #bar #baz] func my-record)\n\n## And, if only the slot/path and (optionally) the value are given, generates a\n## mutator function:\n(let [updater (update@ [#foo #bar #baz] func)]\n  (updater my-record))\n\n(let [updater (update@ [#foo #bar #baz])]\n  (updater func my-record))", 
            "title": "update@"
        }, 
        {
            "location": "/lux/#with-cursor", 
            "text": "## Given some text, appends to it a prefix for identifying where the text comes from.\n## For example:\n(with-cursor (format  User:   user-id))\n\n## Would be the same as:\n(format  [the-module,the-line,the-column]   (format  User:   user-id))", 
            "title": "with-cursor"
        }, 
        {
            "location": "/lux/#_16", 
            "text": "## Variant types:\n(| Text Int Bool)\n\n## The empty tuple, a.k.a. Void.\n(|)", 
            "title": "|"
        }, 
        {
            "location": "/lux/#_17", 
            "text": "## Piping macro.\n(|  elems (map - Text) (interpose    ) (fold Text/append  ))\n\n## = \n(fold Text/append  \n      (interpose    \n                 (map - Text elems)))", 
            "title": "|&gt;"
        }, 
        {
            "location": "/lux/#_18", 
            "text": "## Similar to the piping macro, but rather than taking an initial object to work on, creates a function for taking it.\n(|  (map - Text) (interpose    ) (fold Text/append  ))\n## = \n(lambda [ something ]\n  (fold Text/append  \n         (interpose    \n                    (map - Text  something ))))", 
            "title": "|&gt;."
        }, 
        {
            "location": "/lux/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux/#_19", 
            "text": "Function composition.  (All [a b c] (-  (-  b c) (-  a b) a c))", 
            "title": "."
        }, 
        {
            "location": "/lux/#error-message", 
            "text": "## Causes an error, with the given error message.\n(error!  OH NO! )  (-  Text Bottom)", 
            "title": "(error! message)"
        }, 
        {
            "location": "/lux/#f", 
            "text": "Frac(tional) remainder.  (-  Frac Frac Frac)", 
            "title": "f.%"
        }, 
        {
            "location": "/lux/#f_1", 
            "text": "Frac(tional) multiplication.  (-  Frac Frac Frac)", 
            "title": "f.*"
        }, 
        {
            "location": "/lux/#f_2", 
            "text": "Frac(tional) addition.  (-  Frac Frac Frac)", 
            "title": "f.+"
        }, 
        {
            "location": "/lux/#f-", 
            "text": "Frac(tional) substraction.  (-  Frac Frac Frac)", 
            "title": "f.-"
        }, 
        {
            "location": "/lux/#f_3", 
            "text": "Frac(tional) division.  (-  Frac Frac Frac)", 
            "title": "f./"
        }, 
        {
            "location": "/lux/#f_4", 
            "text": "Fractional less-than.  (-  Frac Frac Bool)", 
            "title": "f.&lt;"
        }, 
        {
            "location": "/lux/#f_5", 
            "text": "Fractional less-than-equal.  (-  Frac Frac Bool)", 
            "title": "f.&lt;="
        }, 
        {
            "location": "/lux/#f_6", 
            "text": "Fractional equality.  (-  Frac Frac Bool)", 
            "title": "f.="
        }, 
        {
            "location": "/lux/#f_7", 
            "text": "Fractional greater-than.  (-  Frac Frac Bool)", 
            "title": "f.&gt;"
        }, 
        {
            "location": "/lux/#f_8", 
            "text": "Fractional greater-than-equal.  (-  Frac Frac Bool)", 
            "title": "f.&gt;="
        }, 
        {
            "location": "/lux/#fmax", 
            "text": "Frac(tional) maximum.  (-  Frac Frac Frac)", 
            "title": "f.max"
        }, 
        {
            "location": "/lux/#fmin", 
            "text": "Frac(tional) minimum.  (-  Frac Frac Frac)", 
            "title": "f.min"
        }, 
        {
            "location": "/lux/#frac-to-real-input", 
            "text": "(-  Frac Real)", 
            "title": "(frac-to-real input)"
        }, 
        {
            "location": "/lux/#i", 
            "text": "Int(eger) remainder.  (-  Int Int Int)", 
            "title": "i.%"
        }, 
        {
            "location": "/lux/#i_1", 
            "text": "Int(eger) multiplication.  (-  Int Int Int)", 
            "title": "i.*"
        }, 
        {
            "location": "/lux/#i_2", 
            "text": "Int(eger) addition.  (-  Int Int Int)", 
            "title": "i.+"
        }, 
        {
            "location": "/lux/#i-", 
            "text": "Int(eger) substraction.  (-  Int Int Int)", 
            "title": "i.-"
        }, 
        {
            "location": "/lux/#i_3", 
            "text": "Int(eger) division.  (-  Int Int Int)", 
            "title": "i./"
        }, 
        {
            "location": "/lux/#i_4", 
            "text": "Integer less-than.  (-  Int Int Bool)", 
            "title": "i.&lt;"
        }, 
        {
            "location": "/lux/#i_5", 
            "text": "Integer less-than-equal.  (-  Int Int Bool)", 
            "title": "i.&lt;="
        }, 
        {
            "location": "/lux/#i_6", 
            "text": "Integer equality.  (-  Int Int Bool)", 
            "title": "i.="
        }, 
        {
            "location": "/lux/#i_7", 
            "text": "Integer greater-than.  (-  Int Int Bool)", 
            "title": "i.&gt;"
        }, 
        {
            "location": "/lux/#i_8", 
            "text": "Integer greater-than-equal.  (-  Int Int Bool)", 
            "title": "i.&gt;="
        }, 
        {
            "location": "/lux/#idec-value", 
            "text": "Decrement function.  (-  Int Int)", 
            "title": "(i.dec value)"
        }, 
        {
            "location": "/lux/#ieven-n", 
            "text": "(-  Int Bool)", 
            "title": "(i.even? n)"
        }, 
        {
            "location": "/lux/#iinc-value", 
            "text": "Increment function.  (-  Int Int)", 
            "title": "(i.inc value)"
        }, 
        {
            "location": "/lux/#imax", 
            "text": "Int(eger) maximum.  (-  Int Int Int)", 
            "title": "i.max"
        }, 
        {
            "location": "/lux/#imin", 
            "text": "Int(eger) minimum.  (-  Int Int Int)", 
            "title": "i.min"
        }, 
        {
            "location": "/lux/#iodd-n", 
            "text": "(-  Int Bool)", 
            "title": "(i.odd? n)"
        }, 
        {
            "location": "/lux/#id-x", 
            "text": "Identity function.\n\nDoes nothing to it's argument and just returns it.  (All [a] (-  a a))", 
            "title": "(id x)"
        }, 
        {
            "location": "/lux/#int-to-nat-input", 
            "text": "(-  Int Nat)", 
            "title": "(int-to-nat input)"
        }, 
        {
            "location": "/lux/#int-to-real-n", 
            "text": "(-  Int Real)", 
            "title": "(int-to-real n)"
        }, 
        {
            "location": "/lux/#is-left-right", 
            "text": "## Tests whether the 2 values are identical (not just  equal ).\n## This one should succeed:\n(let [value 5]\n  (is 5 5))\n\n## This one should fail:\n(is 5 (i.+ 2 3))  (All [a] (-  a a Bool))", 
            "title": "(is left right)"
        }, 
        {
            "location": "/lux/#log", 
            "text": "Logs message to standard output.\n\nUseful for debugging.  (-  Text Unit)", 
            "title": "log!"
        }, 
        {
            "location": "/lux/#n", 
            "text": "Nat(ural) remainder.  (-  Nat Nat Nat)", 
            "title": "n.%"
        }, 
        {
            "location": "/lux/#n_1", 
            "text": "Nat(ural) multiplication.  (-  Nat Nat Nat)", 
            "title": "n.*"
        }, 
        {
            "location": "/lux/#n_2", 
            "text": "Nat(ural) addition.  (-  Nat Nat Nat)", 
            "title": "n.+"
        }, 
        {
            "location": "/lux/#n-", 
            "text": "Nat(ural) substraction.  (-  Nat Nat Nat)", 
            "title": "n.-"
        }, 
        {
            "location": "/lux/#n_3", 
            "text": "Nat(ural) division.  (-  Nat Nat Nat)", 
            "title": "n./"
        }, 
        {
            "location": "/lux/#n_4", 
            "text": "Natural less-than.  (-  Nat Nat Bool)", 
            "title": "n.&lt;"
        }, 
        {
            "location": "/lux/#n_5", 
            "text": "Natural less-than-equal.  (-  Nat Nat Bool)", 
            "title": "n.&lt;="
        }, 
        {
            "location": "/lux/#n_6", 
            "text": "Natural equality.  (-  Nat Nat Bool)", 
            "title": "n.="
        }, 
        {
            "location": "/lux/#n_7", 
            "text": "Natural greater-than.  (-  Nat Nat Bool)", 
            "title": "n.&gt;"
        }, 
        {
            "location": "/lux/#n_8", 
            "text": "Natural greater-than-equal.  (-  Nat Nat Bool)", 
            "title": "n.&gt;="
        }, 
        {
            "location": "/lux/#ndec-value", 
            "text": "Decrement function.  (-  Nat Nat)", 
            "title": "(n.dec value)"
        }, 
        {
            "location": "/lux/#neven-n", 
            "text": "(-  Nat Bool)", 
            "title": "(n.even? n)"
        }, 
        {
            "location": "/lux/#ninc-value", 
            "text": "Increment function.  (-  Nat Nat)", 
            "title": "(n.inc value)"
        }, 
        {
            "location": "/lux/#nmax", 
            "text": "Nat(ural) maximum.  (-  Nat Nat Nat)", 
            "title": "n.max"
        }, 
        {
            "location": "/lux/#nmin", 
            "text": "Nat(ural) minimum.  (-  Nat Nat Nat)", 
            "title": "n.min"
        }, 
        {
            "location": "/lux/#nodd-n", 
            "text": "(-  Nat Bool)", 
            "title": "(n.odd? n)"
        }, 
        {
            "location": "/lux/#nat-to-int-input", 
            "text": "(-  Nat Int)", 
            "title": "(nat-to-int input)"
        }, 
        {
            "location": "/lux/#not", 
            "text": "## Boolean negation.\n\n(not true) == false\n\n(not false) == true  (-  Bool Bool)", 
            "title": "not"
        }, 
        {
            "location": "/lux/#r", 
            "text": "Real remainder.  (-  Real Real Real)", 
            "title": "r.%"
        }, 
        {
            "location": "/lux/#r_1", 
            "text": "Real multiplication.  (-  Real Real Real)", 
            "title": "r.*"
        }, 
        {
            "location": "/lux/#r_2", 
            "text": "Real addition.  (-  Real Real Real)", 
            "title": "r.+"
        }, 
        {
            "location": "/lux/#r-", 
            "text": "Real substraction.  (-  Real Real Real)", 
            "title": "r.-"
        }, 
        {
            "location": "/lux/#r_3", 
            "text": "Real division.  (-  Real Real Real)", 
            "title": "r./"
        }, 
        {
            "location": "/lux/#r_4", 
            "text": "Real less-than.  (-  Real Real Bool)", 
            "title": "r.&lt;"
        }, 
        {
            "location": "/lux/#r_5", 
            "text": "Real less-than-equal.  (-  Real Real Bool)", 
            "title": "r.&lt;="
        }, 
        {
            "location": "/lux/#r_6", 
            "text": "Real equality.  (-  Real Real Bool)", 
            "title": "r.="
        }, 
        {
            "location": "/lux/#r_7", 
            "text": "Real greater-than.  (-  Real Real Bool)", 
            "title": "r.&gt;"
        }, 
        {
            "location": "/lux/#r_8", 
            "text": "Real greater-than-equal.  (-  Real Real Bool)", 
            "title": "r.&gt;="
        }, 
        {
            "location": "/lux/#rmax", 
            "text": "Real minimum.  (-  Real Real Real)", 
            "title": "r.max"
        }, 
        {
            "location": "/lux/#rmin", 
            "text": "Real minimum.  (-  Real Real Real)", 
            "title": "r.min"
        }, 
        {
            "location": "/lux/#real-to-frac-input", 
            "text": "(-  Real Frac)", 
            "title": "(real-to-frac input)"
        }, 
        {
            "location": "/lux/#real-to-int-n", 
            "text": "(-  Real Int)", 
            "title": "(real-to-int n)"
        }, 
        {
            "location": "/lux_cli/", 
            "text": "lux/cli\n\n\nTypes\n\n\nCLI\n\n\nA command-line interface parser.\n\n\n(type: (CLI a)\n  (-\n (lux;List lux;Text) (lux/data/error;Error [(lux;List lux;Text) a])))\n\n\n\n\nMacros\n\n\nprogram:\n\n\n## Defines the entry-point to a program (similar to the \nmain\n function/method in other programming languages).\n## Can take a list of all the input parameters to the program, or can destructure them using CLI-option combinators from the lux/cli module.\n(program: all-args\n  (do Monad\nIO\n\n    [foo init-program\n     bar (do-something all-args)]\n    (wrap [])))\n\n(program: (name)\n  (io (log! (Text/append \nHello, \n name))))\n\n(program: ([config config^])\n  (do Monad\nIO\n\n    [data (init-program config)]\n    (do-something data)))\n\n\n\n\nStructs\n\n\nApplicative\nCLI\n\n\n(lux/control/applicative;Applicative CLI)\n\n\nFunctor\nCLI\n\n\n(lux/control/functor;Functor CLI)\n\n\nMonad\nCLI\n\n\n(lux/control/monad;Monad CLI)\n\n\nValues\n\n\n(alt optL optR)\n\n\nHeterogeneous alternative combinator.\n\n\n\n\n(All [a b] (-\n (CLI a) (CLI b) (CLI (| a b))))\n\n\nany\n\n\nJust returns the next input without applying any logic.\n\n\n\n\n(CLI lux;Text)\n\n\n(assert message test)\n\n\nFails with the given message if the test is false.\n\n\n\n\n(-\n lux;Text lux;Bool (CLI lux;Unit))\n\n\n(either pl pr)\n\n\nHomogeneous alternative combinator.\n\n\n\n\n(All [a] (-\n (CLI a) (CLI a) (CLI a)))\n\n\nend\n\n\nEnsures there are no more inputs.\n\n\n\n\n(CLI lux;Unit)\n\n\n(flag names)\n\n\nChecks that a given flag (with multiple possible names) is set.\n\n\n\n\n(-\n (lux;List lux;Text) (CLI lux;Bool))\n\n\n(many opt)\n\n\n1-or-more combinator.\n\n\n\n\n(All [a] (-\n (CLI a) (CLI (lux;List a))))\n\n\n(not opt)\n\n\nThe opposite of the given CLI.\n\n\n\n\n(All [a] (-\n (CLI a) (CLI lux;Unit)))\n\n\n(opt opt)\n\n\nOptionality combinator.\n\n\n\n\n(All [a] (-\n (CLI a) (CLI (lux;Maybe a))))\n\n\n(option names)\n\n\nChecks that a given option (with multiple possible names) has a value.\n\n\n\n\n(-\n (lux;List lux;Text) (CLI lux;Text))\n\n\n(parse parser)\n\n\nParses the next input with a parsing function.\n\n\n\n\n(All [a] (-\n (-\n lux;Text (lux/data/error;Error a)) (CLI a)))\n\n\n(run opt inputs)\n\n\n(All [a] (-\n (CLI a) (lux;List lux;Text) (lux/data/error;Error a)))\n\n\n(seq optL optR)\n\n\nSequencing combinator.\n\n\n\n\n(All [a b] (-\n (CLI a) (CLI b) (CLI [a b])))\n\n\n(some opt)\n\n\n0-or-more combinator.\n\n\n\n\n(All [a] (-\n (CLI a) (CLI (lux;List a))))", 
            "title": "Lux cli"
        }, 
        {
            "location": "/lux_cli/#luxcli", 
            "text": "", 
            "title": "lux/cli"
        }, 
        {
            "location": "/lux_cli/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_cli/#cli", 
            "text": "A command-line interface parser.  (type: (CLI a)\n  (-  (lux;List lux;Text) (lux/data/error;Error [(lux;List lux;Text) a])))", 
            "title": "CLI"
        }, 
        {
            "location": "/lux_cli/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_cli/#program", 
            "text": "## Defines the entry-point to a program (similar to the  main  function/method in other programming languages).\n## Can take a list of all the input parameters to the program, or can destructure them using CLI-option combinators from the lux/cli module.\n(program: all-args\n  (do Monad IO \n    [foo init-program\n     bar (do-something all-args)]\n    (wrap [])))\n\n(program: (name)\n  (io (log! (Text/append  Hello,   name))))\n\n(program: ([config config^])\n  (do Monad IO \n    [data (init-program config)]\n    (do-something data)))", 
            "title": "program:"
        }, 
        {
            "location": "/lux_cli/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_cli/#applicativecli", 
            "text": "(lux/control/applicative;Applicative CLI)", 
            "title": "Applicative&lt;CLI&gt;"
        }, 
        {
            "location": "/lux_cli/#functorcli", 
            "text": "(lux/control/functor;Functor CLI)", 
            "title": "Functor&lt;CLI&gt;"
        }, 
        {
            "location": "/lux_cli/#monadcli", 
            "text": "(lux/control/monad;Monad CLI)", 
            "title": "Monad&lt;CLI&gt;"
        }, 
        {
            "location": "/lux_cli/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_cli/#alt-optl-optr", 
            "text": "Heterogeneous alternative combinator.  (All [a b] (-  (CLI a) (CLI b) (CLI (| a b))))", 
            "title": "(alt optL optR)"
        }, 
        {
            "location": "/lux_cli/#any", 
            "text": "Just returns the next input without applying any logic.  (CLI lux;Text)", 
            "title": "any"
        }, 
        {
            "location": "/lux_cli/#assert-message-test", 
            "text": "Fails with the given message if the test is false.  (-  lux;Text lux;Bool (CLI lux;Unit))", 
            "title": "(assert message test)"
        }, 
        {
            "location": "/lux_cli/#either-pl-pr", 
            "text": "Homogeneous alternative combinator.  (All [a] (-  (CLI a) (CLI a) (CLI a)))", 
            "title": "(either pl pr)"
        }, 
        {
            "location": "/lux_cli/#end", 
            "text": "Ensures there are no more inputs.  (CLI lux;Unit)", 
            "title": "end"
        }, 
        {
            "location": "/lux_cli/#flag-names", 
            "text": "Checks that a given flag (with multiple possible names) is set.  (-  (lux;List lux;Text) (CLI lux;Bool))", 
            "title": "(flag names)"
        }, 
        {
            "location": "/lux_cli/#many-opt", 
            "text": "1-or-more combinator.  (All [a] (-  (CLI a) (CLI (lux;List a))))", 
            "title": "(many opt)"
        }, 
        {
            "location": "/lux_cli/#not-opt", 
            "text": "The opposite of the given CLI.  (All [a] (-  (CLI a) (CLI lux;Unit)))", 
            "title": "(not opt)"
        }, 
        {
            "location": "/lux_cli/#opt-opt", 
            "text": "Optionality combinator.  (All [a] (-  (CLI a) (CLI (lux;Maybe a))))", 
            "title": "(opt opt)"
        }, 
        {
            "location": "/lux_cli/#option-names", 
            "text": "Checks that a given option (with multiple possible names) has a value.  (-  (lux;List lux;Text) (CLI lux;Text))", 
            "title": "(option names)"
        }, 
        {
            "location": "/lux_cli/#parse-parser", 
            "text": "Parses the next input with a parsing function.  (All [a] (-  (-  lux;Text (lux/data/error;Error a)) (CLI a)))", 
            "title": "(parse parser)"
        }, 
        {
            "location": "/lux_cli/#run-opt-inputs", 
            "text": "(All [a] (-  (CLI a) (lux;List lux;Text) (lux/data/error;Error a)))", 
            "title": "(run opt inputs)"
        }, 
        {
            "location": "/lux_cli/#seq-optl-optr", 
            "text": "Sequencing combinator.  (All [a b] (-  (CLI a) (CLI b) (CLI [a b])))", 
            "title": "(seq optL optR)"
        }, 
        {
            "location": "/lux_cli/#some-opt", 
            "text": "0-or-more combinator.  (All [a] (-  (CLI a) (CLI (lux;List a))))", 
            "title": "(some opt)"
        }, 
        {
            "location": "/lux_codata_cont/", 
            "text": "lux/codata/cont\n\n\nTypes\n\n\nCont\n\n\nDelimited continuations.\n\n\n(type: (Cont a)\n  (All [b] (-\n (-\n a c) c)))\n\n\n\n\nMacros\n\n\n@lazy\n\n\n## Delays the evaluation of an expression, by wrapping it in a continuation 'thunk'.\n(@lazy (some-computation some-input))\n\n\n\n\nStructs\n\n\nApplicative\nCont\n\n\n(lux/control/applicative;Applicative Cont)\n\n\nFunctor\nCont\n\n\n(lux/control/functor;Functor Cont)\n\n\nMonad\nCont\n\n\n(lux/control/monad;Monad Cont)\n\n\nValues\n\n\n(call/cc f)\n\n\nCall with current continuation.\n\n\n\n\n(All [a b c] (-\n (-\n (-\n a (Cont b c)) (Cont a c)) (Cont a c)))\n\n\n(run thunk)\n\n\nForces a continuation thunk to be evaluated.\n\n\n\n\n(All [a] (-\n (Cont a) a))", 
            "title": "Lux codata cont"
        }, 
        {
            "location": "/lux_codata_cont/#luxcodatacont", 
            "text": "", 
            "title": "lux/codata/cont"
        }, 
        {
            "location": "/lux_codata_cont/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_codata_cont/#cont", 
            "text": "Delimited continuations.  (type: (Cont a)\n  (All [b] (-  (-  a c) c)))", 
            "title": "Cont"
        }, 
        {
            "location": "/lux_codata_cont/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_codata_cont/#lazy", 
            "text": "## Delays the evaluation of an expression, by wrapping it in a continuation 'thunk'.\n(@lazy (some-computation some-input))", 
            "title": "@lazy"
        }, 
        {
            "location": "/lux_codata_cont/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_codata_cont/#applicativecont", 
            "text": "(lux/control/applicative;Applicative Cont)", 
            "title": "Applicative&lt;Cont&gt;"
        }, 
        {
            "location": "/lux_codata_cont/#functorcont", 
            "text": "(lux/control/functor;Functor Cont)", 
            "title": "Functor&lt;Cont&gt;"
        }, 
        {
            "location": "/lux_codata_cont/#monadcont", 
            "text": "(lux/control/monad;Monad Cont)", 
            "title": "Monad&lt;Cont&gt;"
        }, 
        {
            "location": "/lux_codata_cont/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_codata_cont/#callcc-f", 
            "text": "Call with current continuation.  (All [a b c] (-  (-  (-  a (Cont b c)) (Cont a c)) (Cont a c)))", 
            "title": "(call/cc f)"
        }, 
        {
            "location": "/lux_codata_cont/#run-thunk", 
            "text": "Forces a continuation thunk to be evaluated.  (All [a] (-  (Cont a) a))", 
            "title": "(run thunk)"
        }, 
        {
            "location": "/lux_codata_env/", 
            "text": "lux/codata/env\n\n\nTypes\n\n\nEnv\n\n\nComputations that have access to some environmental value.\n\n\n(type: (Env r a)\n  (-\n r a))\n\n\n\n\nStructs\n\n\nApplicative\nEnv\n\n\n(All [a] (lux/control/applicative;Applicative (Env a)))\n\n\n(EnvT Monad\nM\n)\n\n\nMonad transformer for Env.\n\n\n\n\n(All [a] (-\n (lux/control/monad;Monad a) (All [b] (lux/control/monad;Monad (All [c] (Env b (a c)))))))\n\n\nFunctor\nEnv\n\n\n(All [a] (lux/control/functor;Functor (Env a)))\n\n\nMonad\nEnv\n\n\n(All [a] (lux/control/monad;Monad (Env a)))\n\n\nValues\n\n\nask\n\n\nGet the environment.\n\n\n\n\n(All [a] (Env a a))\n\n\nlift-env\n\n\nLift monadic values to the Env wrapper.\n\n\n\n\n(All [a b c] (-\n (a c) (Env b (a c))))\n\n\n(local change env-proc)\n\n\nRun computation with a locally-modified environment.\n\n\n\n\n(All [a b] (-\n (-\n a a) (Env a b) (Env a b)))\n\n\n(run env env-proc)\n\n\n(All [a b] (-\n a (Env a b) b))", 
            "title": "Lux codata env"
        }, 
        {
            "location": "/lux_codata_env/#luxcodataenv", 
            "text": "", 
            "title": "lux/codata/env"
        }, 
        {
            "location": "/lux_codata_env/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_codata_env/#env", 
            "text": "Computations that have access to some environmental value.  (type: (Env r a)\n  (-  r a))", 
            "title": "Env"
        }, 
        {
            "location": "/lux_codata_env/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_codata_env/#applicativeenv", 
            "text": "(All [a] (lux/control/applicative;Applicative (Env a)))", 
            "title": "Applicative&lt;Env&gt;"
        }, 
        {
            "location": "/lux_codata_env/#envt-monadm", 
            "text": "Monad transformer for Env.  (All [a] (-  (lux/control/monad;Monad a) (All [b] (lux/control/monad;Monad (All [c] (Env b (a c)))))))", 
            "title": "(EnvT Monad&lt;M&gt;)"
        }, 
        {
            "location": "/lux_codata_env/#functorenv", 
            "text": "(All [a] (lux/control/functor;Functor (Env a)))", 
            "title": "Functor&lt;Env&gt;"
        }, 
        {
            "location": "/lux_codata_env/#monadenv", 
            "text": "(All [a] (lux/control/monad;Monad (Env a)))", 
            "title": "Monad&lt;Env&gt;"
        }, 
        {
            "location": "/lux_codata_env/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_codata_env/#ask", 
            "text": "Get the environment.  (All [a] (Env a a))", 
            "title": "ask"
        }, 
        {
            "location": "/lux_codata_env/#lift-env", 
            "text": "Lift monadic values to the Env wrapper.  (All [a b c] (-  (a c) (Env b (a c))))", 
            "title": "lift-env"
        }, 
        {
            "location": "/lux_codata_env/#local-change-env-proc", 
            "text": "Run computation with a locally-modified environment.  (All [a b] (-  (-  a a) (Env a b) (Env a b)))", 
            "title": "(local change env-proc)"
        }, 
        {
            "location": "/lux_codata_env/#run-env-env-proc", 
            "text": "(All [a b] (-  a (Env a b) b))", 
            "title": "(run env env-proc)"
        }, 
        {
            "location": "/lux_codata_function/", 
            "text": "lux/codata/function\n\n\nStructs\n\n\nMonoid\nFunction\n\n\n(lux/control/monoid;Monoid (All [a] (-\n a a)))\n\n\nValues\n\n\n(const c)\n\n\nCreate constant functions.\n\n\n\n\n(All [a b] (-\n a b a))\n\n\n(flip f)\n\n\nFlips the order of the arguments of a function.\n\n\n\n\n(All [a b c] (-\n (-\n a b c) b a c))", 
            "title": "Lux codata function"
        }, 
        {
            "location": "/lux_codata_function/#luxcodatafunction", 
            "text": "", 
            "title": "lux/codata/function"
        }, 
        {
            "location": "/lux_codata_function/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_codata_function/#monoidfunction", 
            "text": "(lux/control/monoid;Monoid (All [a] (-  a a)))", 
            "title": "Monoid&lt;Function&gt;"
        }, 
        {
            "location": "/lux_codata_function/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_codata_function/#const-c", 
            "text": "Create constant functions.  (All [a b] (-  a b a))", 
            "title": "(const c)"
        }, 
        {
            "location": "/lux_codata_function/#flip-f", 
            "text": "Flips the order of the arguments of a function.  (All [a b c] (-  (-  a b c) b a c))", 
            "title": "(flip f)"
        }, 
        {
            "location": "/lux_codata_io/", 
            "text": "lux/codata/io\n\n\n\n\nA method for abstracting I/O and effectful computations to make it safe while writing pure functional code.\n\n\n\n\nTypes\n\n\nIO\n\n\nA type that represents synchronous, effectful computations that may interact with the outside world.\n\n\n(type: (IO a)\n  (-\n lux;Void a))\n\n\n\n\nMacros\n\n\nio\n\n\n## Delays the evaluation of an expression, by wrapping it in an IO 'thunk'.\n## Great for wrapping effectful computations (which won't be performed until the IO is \nrun\n).\n(io (exec\n      (log! msg)\n      \nSome value...\n))\n\n\n\n\nStructs\n\n\nApplicative\nIO\n\n\n(lux/control/applicative;Applicative IO)\n\n\nFunctor\nIO\n\n\n(lux/control/functor;Functor IO)\n\n\nMonad\nIO\n\n\n(lux/control/monad;Monad IO)\n\n\nValues\n\n\n(run action)\n\n\nA way to execute IO computations and perform their side-effects.\n\n\n\n\n(All [a] (-\n (IO a) a))", 
            "title": "Lux codata io"
        }, 
        {
            "location": "/lux_codata_io/#luxcodataio", 
            "text": "A method for abstracting I/O and effectful computations to make it safe while writing pure functional code.", 
            "title": "lux/codata/io"
        }, 
        {
            "location": "/lux_codata_io/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_codata_io/#io", 
            "text": "A type that represents synchronous, effectful computations that may interact with the outside world.  (type: (IO a)\n  (-  lux;Void a))", 
            "title": "IO"
        }, 
        {
            "location": "/lux_codata_io/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_codata_io/#io_1", 
            "text": "## Delays the evaluation of an expression, by wrapping it in an IO 'thunk'.\n## Great for wrapping effectful computations (which won't be performed until the IO is  run ).\n(io (exec\n      (log! msg)\n       Some value... ))", 
            "title": "io"
        }, 
        {
            "location": "/lux_codata_io/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_codata_io/#applicativeio", 
            "text": "(lux/control/applicative;Applicative IO)", 
            "title": "Applicative&lt;IO&gt;"
        }, 
        {
            "location": "/lux_codata_io/#functorio", 
            "text": "(lux/control/functor;Functor IO)", 
            "title": "Functor&lt;IO&gt;"
        }, 
        {
            "location": "/lux_codata_io/#monadio", 
            "text": "(lux/control/monad;Monad IO)", 
            "title": "Monad&lt;IO&gt;"
        }, 
        {
            "location": "/lux_codata_io/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_codata_io/#run-action", 
            "text": "A way to execute IO computations and perform their side-effects.  (All [a] (-  (IO a) a))", 
            "title": "(run action)"
        }, 
        {
            "location": "/lux_codata_state/", 
            "text": "lux/codata/state\n\n\nTypes\n\n\nState\n\n\nStateful computations.\n\n\n(type: (State s a)\n  (-\n s [s a]))\n\n\n\n\nState'\n\n\nStateful computations decorated by a monad.\n\n\n(type: (State' M s a)\n  (-\n s (M [s a])))\n\n\n\n\nStructs\n\n\nApplicative\nState\n\n\n(All [a] (lux/control/applicative;Applicative (State a)))\n\n\nFunctor\nState\n\n\n(All [a] (lux/control/functor;Functor (State a)))\n\n\nMonad\nState\n\n\n(All [a] (lux/control/monad;Monad (State a)))\n\n\n(StateT Monad\nM\n)\n\n\nA monad transformer to create composite stateful computations.\n\n\n\n\n(All [a b] (-\n (lux/control/monad;Monad a) (lux/control/monad;Monad (State' a b))))\n\n\nValues\n\n\nget\n\n\nRead the current state.\n\n\n\n\n(All [a] (State a a))\n\n\n(lift-state Monad\nM\n ma)\n\n\nLift monadic values to the State' wrapper.\n\n\n\n\n(All [a b c] (-\n (lux/control/monad;Monad a) (a c) (State' a b c)))\n\n\n(local change action)\n\n\nRun computation with a locally-modified state.\n\n\n\n\n(All [a b] (-\n (-\n a a) (State a b) (State a b)))\n\n\n(put new-state)\n\n\nSet the new state.\n\n\n\n\n(All [a] (-\n a (State a lux;Unit)))\n\n\n(run state action)\n\n\nRun a stateful computation.\n\n\n\n\n(All [a b] (-\n a (State a b) [a b]))\n\n\n(run' state action)\n\n\nRun a stateful computation decorated by a monad.\n\n\n\n\n(All [a b c] (-\n b (State' a b c) (a [b c])))\n\n\n(update change)\n\n\nCompute the new state.\n\n\n\n\n(All [a] (-\n (-\n a a) (State a lux;Unit)))\n\n\n(use user)\n\n\nRun function on current state.\n\n\n\n\n(All [a b] (-\n (-\n a b) (State a b)))", 
            "title": "Lux codata state"
        }, 
        {
            "location": "/lux_codata_state/#luxcodatastate", 
            "text": "", 
            "title": "lux/codata/state"
        }, 
        {
            "location": "/lux_codata_state/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_codata_state/#state", 
            "text": "Stateful computations.  (type: (State s a)\n  (-  s [s a]))", 
            "title": "State"
        }, 
        {
            "location": "/lux_codata_state/#state_1", 
            "text": "Stateful computations decorated by a monad.  (type: (State' M s a)\n  (-  s (M [s a])))", 
            "title": "State'"
        }, 
        {
            "location": "/lux_codata_state/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_codata_state/#applicativestate", 
            "text": "(All [a] (lux/control/applicative;Applicative (State a)))", 
            "title": "Applicative&lt;State&gt;"
        }, 
        {
            "location": "/lux_codata_state/#functorstate", 
            "text": "(All [a] (lux/control/functor;Functor (State a)))", 
            "title": "Functor&lt;State&gt;"
        }, 
        {
            "location": "/lux_codata_state/#monadstate", 
            "text": "(All [a] (lux/control/monad;Monad (State a)))", 
            "title": "Monad&lt;State&gt;"
        }, 
        {
            "location": "/lux_codata_state/#statet-monadm", 
            "text": "A monad transformer to create composite stateful computations.  (All [a b] (-  (lux/control/monad;Monad a) (lux/control/monad;Monad (State' a b))))", 
            "title": "(StateT Monad&lt;M&gt;)"
        }, 
        {
            "location": "/lux_codata_state/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_codata_state/#get", 
            "text": "Read the current state.  (All [a] (State a a))", 
            "title": "get"
        }, 
        {
            "location": "/lux_codata_state/#lift-state-monadm-ma", 
            "text": "Lift monadic values to the State' wrapper.  (All [a b c] (-  (lux/control/monad;Monad a) (a c) (State' a b c)))", 
            "title": "(lift-state Monad&lt;M&gt; ma)"
        }, 
        {
            "location": "/lux_codata_state/#local-change-action", 
            "text": "Run computation with a locally-modified state.  (All [a b] (-  (-  a a) (State a b) (State a b)))", 
            "title": "(local change action)"
        }, 
        {
            "location": "/lux_codata_state/#put-new-state", 
            "text": "Set the new state.  (All [a] (-  a (State a lux;Unit)))", 
            "title": "(put new-state)"
        }, 
        {
            "location": "/lux_codata_state/#run-state-action", 
            "text": "Run a stateful computation.  (All [a b] (-  a (State a b) [a b]))", 
            "title": "(run state action)"
        }, 
        {
            "location": "/lux_codata_state/#run-state-action_1", 
            "text": "Run a stateful computation decorated by a monad.  (All [a b c] (-  b (State' a b c) (a [b c])))", 
            "title": "(run' state action)"
        }, 
        {
            "location": "/lux_codata_state/#update-change", 
            "text": "Compute the new state.  (All [a] (-  (-  a a) (State a lux;Unit)))", 
            "title": "(update change)"
        }, 
        {
            "location": "/lux_codata_state/#use-user", 
            "text": "Run function on current state.  (All [a b] (-  (-  a b) (State a b)))", 
            "title": "(use user)"
        }, 
        {
            "location": "/lux_codata_struct_stream/", 
            "text": "lux/codata/struct/stream\n\n\nTypes\n\n\nStream\n\n\nAn infinite stream of lazily-evaluated values.\n\n\n(type: (Stream a)\n  (lux/codata/cont;Cont [a (Stream a)]))\n\n\n\n\nMacros\n\n\n^stream\n\n\n## Allows destructuring of streams in pattern-matching expressions.\n## Caveat emptor: Only use it for destructuring, and not for testing values within the streams.\n(let [(^stream\n x y z _tail) (some-stream-func 1 2 3)]\n  (func x y z))\n\n\n\n\nStructs\n\n\nCoMonad\nStream\n\n\n(lux/control/comonad;CoMonad Stream)\n\n\nFunctor\nStream\n\n\n(lux/control/functor;Functor Stream)\n\n\nValues\n\n\n(at idx s)\n\n\n(All [a] (-\n lux;Nat (Stream a) a))\n\n\n(cycle xs)\n\n\nGo over the elements of a list forever.\n\nThe list shouldn't be empty.\n\n\n\n\n(All [a] (-\n (lux;List a) (lux;Maybe (Stream a))))\n\n\n(drop pred xs)\n\n\n(All [a] (-\n lux;Nat (Stream a) (Stream a)))\n\n\n(drop-while pred xs)\n\n\n(All [a] (-\n (-\n a lux;Bool) (Stream a) (Stream a)))\n\n\n(filter p xs)\n\n\n(All [a] (-\n (-\n a lux;Bool) (Stream a) (Stream a)))\n\n\n(head s)\n\n\n(All [a] (-\n (Stream a) a))\n\n\n(iterate f x)\n\n\nCreate a stream by applying a function to a value, and to its result, on and on...\n\n\n\n\n(All [a] (-\n (-\n a a) a (Stream a)))\n\n\n(partition p xs)\n\n\nSplit a stream in two based on a predicate.\n\nThe left side contains all entries for which the predicate is true.\n\nThe right side contains all entries for which the predicate is false.\n\n\n\n\n(All [a] (-\n (-\n a lux;Bool) (Stream a) [(Stream a) (Stream a)]))\n\n\n(repeat x)\n\n\nRepeat a value forever.\n\n\n\n\n(All [a] (-\n a (Stream a)))\n\n\n(split pred xs)\n\n\n(All [a] (-\n lux;Nat (Stream a) [(lux;List a) (Stream a)]))\n\n\n(split-while pred xs)\n\n\n(All [a] (-\n (-\n a lux;Bool) (Stream a) [(lux;List a) (Stream a)]))\n\n\n(tail s)\n\n\n(All [a] (-\n (Stream a) (Stream a)))\n\n\n(take pred xs)\n\n\n(All [a] (-\n lux;Nat (Stream a) (lux;List a)))\n\n\n(take-while pred xs)\n\n\n(All [a] (-\n (-\n a lux;Bool) (Stream a) (lux;List a)))\n\n\n(unfold step init)\n\n\nA stateful way of infinitely calculating the values of a stream.\n\n\n\n\n(All [a b] (-\n (-\n a [a b]) a (Stream b)))", 
            "title": "Lux codata struct stream"
        }, 
        {
            "location": "/lux_codata_struct_stream/#luxcodatastructstream", 
            "text": "", 
            "title": "lux/codata/struct/stream"
        }, 
        {
            "location": "/lux_codata_struct_stream/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_codata_struct_stream/#stream", 
            "text": "An infinite stream of lazily-evaluated values.  (type: (Stream a)\n  (lux/codata/cont;Cont [a (Stream a)]))", 
            "title": "Stream"
        }, 
        {
            "location": "/lux_codata_struct_stream/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_codata_struct_stream/#stream_1", 
            "text": "## Allows destructuring of streams in pattern-matching expressions.\n## Caveat emptor: Only use it for destructuring, and not for testing values within the streams.\n(let [(^stream  x y z _tail) (some-stream-func 1 2 3)]\n  (func x y z))", 
            "title": "^stream&amp;"
        }, 
        {
            "location": "/lux_codata_struct_stream/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_codata_struct_stream/#comonadstream", 
            "text": "(lux/control/comonad;CoMonad Stream)", 
            "title": "CoMonad&lt;Stream&gt;"
        }, 
        {
            "location": "/lux_codata_struct_stream/#functorstream", 
            "text": "(lux/control/functor;Functor Stream)", 
            "title": "Functor&lt;Stream&gt;"
        }, 
        {
            "location": "/lux_codata_struct_stream/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_codata_struct_stream/#at-idx-s", 
            "text": "(All [a] (-  lux;Nat (Stream a) a))", 
            "title": "(at idx s)"
        }, 
        {
            "location": "/lux_codata_struct_stream/#cycle-xs", 
            "text": "Go over the elements of a list forever.\n\nThe list shouldn't be empty.  (All [a] (-  (lux;List a) (lux;Maybe (Stream a))))", 
            "title": "(cycle xs)"
        }, 
        {
            "location": "/lux_codata_struct_stream/#drop-pred-xs", 
            "text": "(All [a] (-  lux;Nat (Stream a) (Stream a)))", 
            "title": "(drop pred xs)"
        }, 
        {
            "location": "/lux_codata_struct_stream/#drop-while-pred-xs", 
            "text": "(All [a] (-  (-  a lux;Bool) (Stream a) (Stream a)))", 
            "title": "(drop-while pred xs)"
        }, 
        {
            "location": "/lux_codata_struct_stream/#filter-p-xs", 
            "text": "(All [a] (-  (-  a lux;Bool) (Stream a) (Stream a)))", 
            "title": "(filter p xs)"
        }, 
        {
            "location": "/lux_codata_struct_stream/#head-s", 
            "text": "(All [a] (-  (Stream a) a))", 
            "title": "(head s)"
        }, 
        {
            "location": "/lux_codata_struct_stream/#iterate-f-x", 
            "text": "Create a stream by applying a function to a value, and to its result, on and on...  (All [a] (-  (-  a a) a (Stream a)))", 
            "title": "(iterate f x)"
        }, 
        {
            "location": "/lux_codata_struct_stream/#partition-p-xs", 
            "text": "Split a stream in two based on a predicate.\n\nThe left side contains all entries for which the predicate is true.\n\nThe right side contains all entries for which the predicate is false.  (All [a] (-  (-  a lux;Bool) (Stream a) [(Stream a) (Stream a)]))", 
            "title": "(partition p xs)"
        }, 
        {
            "location": "/lux_codata_struct_stream/#repeat-x", 
            "text": "Repeat a value forever.  (All [a] (-  a (Stream a)))", 
            "title": "(repeat x)"
        }, 
        {
            "location": "/lux_codata_struct_stream/#split-pred-xs", 
            "text": "(All [a] (-  lux;Nat (Stream a) [(lux;List a) (Stream a)]))", 
            "title": "(split pred xs)"
        }, 
        {
            "location": "/lux_codata_struct_stream/#split-while-pred-xs", 
            "text": "(All [a] (-  (-  a lux;Bool) (Stream a) [(lux;List a) (Stream a)]))", 
            "title": "(split-while pred xs)"
        }, 
        {
            "location": "/lux_codata_struct_stream/#tail-s", 
            "text": "(All [a] (-  (Stream a) (Stream a)))", 
            "title": "(tail s)"
        }, 
        {
            "location": "/lux_codata_struct_stream/#take-pred-xs", 
            "text": "(All [a] (-  lux;Nat (Stream a) (lux;List a)))", 
            "title": "(take pred xs)"
        }, 
        {
            "location": "/lux_codata_struct_stream/#take-while-pred-xs", 
            "text": "(All [a] (-  (-  a lux;Bool) (Stream a) (lux;List a)))", 
            "title": "(take-while pred xs)"
        }, 
        {
            "location": "/lux_codata_struct_stream/#unfold-step-init", 
            "text": "A stateful way of infinitely calculating the values of a stream.  (All [a b] (-  (-  a [a b]) a (Stream b)))", 
            "title": "(unfold step init)"
        }, 
        {
            "location": "/lux_compiler/", 
            "text": "lux/compiler\n\n\n\n\nFunctions for extracting information from the state of the compiler.\n\n\n\n\nMacros\n\n\nwith-gensyms\n\n\n## Creates new symbols and offers them to the body expression.\n(syntax: #export (synchronized lock body)\n  (with-gensyms [g!lock g!body g!_]\n    (wrap (list (` (let [(~ g!lock) (~ lock)\n                         (~ g!_) (lux;_jvm_monitorenter(~ g!lock))\n                         (~ g!body) (~ body)\n                         (~ g!_) (lux;_jvm_monitorexit(~ g!lock))]\n                     (~ g!body)))))))\n\n\n\n\nStructs\n\n\nApplicative\nLux\n\n\n(lux/control/applicative;Applicative lux;Lux)\n\n\nFunctor\nLux\n\n\n(lux/control/functor;Functor lux;Lux)\n\n\nMonad\nLux\n\n\n(lux/control/monad;Monad lux;Lux)\n\n\nValues\n\n\n(assert message test)\n\n\nFails with the given message if the test is false.\n\n\n\n\n(-\n lux;Text lux;Bool (lux;Lux lux;Unit))\n\n\ncurrent-module\n\n\n(lux;Lux lux;Module)\n\n\ncurrent-module-name\n\n\n(lux;Lux lux;Text)\n\n\ncursor\n\n\nThe cursor of the current expression being analyzed.\n\n\n\n\n(lux;Lux lux;Cursor)\n\n\n(defs module-name)\n\n\nThe entire list of definitions in a module (including the unexported/private ones).\n\n\n\n\n(-\n lux;Text (lux;Lux (lux;List [lux;Text lux;Def])))\n\n\n(either left right)\n\n\nPick whichever computation succeeds.\n\n\n\n\n(All [a] (-\n (lux;Lux a) (lux;Lux a) (lux;Lux a)))\n\n\nexpected-type\n\n\nThe expected type of the current expression being analyzed.\n\n\n\n\n(lux;Lux lux;Type)\n\n\nexport?\n\n\nChecks whether a definition is exported.\n\n\n\n\n(-\n lux;Anns lux;Bool)\n\n\n(exports module-name)\n\n\nAll the exported definitions in a module.\n\n\n\n\n(-\n lux;Text (lux;Lux (lux;List [lux;Text lux;Def])))\n\n\n(fail msg)\n\n\nFails with the given message.\n\n\n\n\n(All [a] (-\n lux;Text (lux;Lux a)))\n\n\n(find-def name)\n\n\nLooks-up a definition's whole data in the available modules (including the current one).\n\n\n\n\n(-\n lux;Ident (lux;Lux lux;Def))\n\n\n(find-def-type name)\n\n\nLooks-up a definition's type in the available modules (including the current one).\n\n\n\n\n(-\n lux;Ident (lux;Lux lux;Type))\n\n\n(find-macro ident)\n\n\n(-\n lux;Ident (lux;Lux (lux;Maybe lux;Macro)))\n\n\n(find-module name)\n\n\n(-\n lux;Text (lux;Lux lux;Module))\n\n\n(find-type name)\n\n\nLooks-up the type of either a local variable or a definition.\n\n\n\n\n(-\n lux;Ident (lux;Lux lux;Type))\n\n\n(find-type-def name)\n\n\nFinds the value of a type definition (such as Int, Top or Compiler).\n\n\n\n\n(-\n lux;Ident (lux;Lux lux;Type))\n\n\n(find-var-type name)\n\n\nLooks-up the type of a local variable somewhere in the environment.\n\n\n\n\n(-\n lux;Text (lux;Lux lux;Type))\n\n\n(flag-set? flag-name anns)\n\n\nFinds out whether an annotation-as-a-flag is set (has value 'true').\n\n\n\n\n(-\n lux;Ident lux;Anns lux;Bool)\n\n\n(func-args anns)\n\n\nLooks up the arguments of a function.\n\n\n\n\n(-\n lux;Anns (lux;List lux;Text))\n\n\n(gensym prefix)\n\n\nGenerates a unique identifier as an AST node (ready to be used in code templates).\n\nA prefix can be given (or just be empty text \n) to better identify the code for debugging purposes.\n\n\n\n\n(-\n lux;Text (lux;Lux lux;AST))\n\n\n(get-ann tag anns)\n\n\nLooks-up a particular annotation's value within the set of annotations.\n\n\n\n\n(-\n lux;Ident lux;Anns (lux;Maybe lux;Ann-Value))\n\n\n(get-bool-ann tag anns)\n\n\n(-\n lux;Ident lux;Anns (lux;Maybe lux;Bool))\n\n\n(get-char-ann tag anns)\n\n\n(-\n lux;Ident lux;Anns (lux;Maybe lux;Char))\n\n\nget-compiler\n\n\nObtains the current state of the compiler.\n\n\n\n\n(lux;Lux lux;Compiler)\n\n\n(get-dict-ann tag anns)\n\n\n(-\n lux;Ident lux;Anns (lux;Maybe (lux;List [lux;Text lux;Ann-Value])))\n\n\n(get-doc anns)\n\n\nLooks-up a definition's documentation.\n\n\n\n\n(-\n lux;Anns (lux;Maybe lux;Text))\n\n\n(get-ident-ann tag anns)\n\n\n(-\n lux;Ident lux;Anns (lux;Maybe lux;Ident))\n\n\n(get-int-ann tag anns)\n\n\n(-\n lux;Ident lux;Anns (lux;Maybe lux;Int))\n\n\n(get-list-ann tag anns)\n\n\n(-\n lux;Ident lux;Anns (lux;Maybe (lux;List lux;Ann-Value)))\n\n\n(get-real-ann tag anns)\n\n\n(-\n lux;Ident lux;Anns (lux;Maybe lux;Real))\n\n\n(get-text-ann tag anns)\n\n\n(-\n lux;Ident lux;Anns (lux;Maybe lux;Text))\n\n\nhidden?\n\n\nChecks whether a definition is hidden.\n\n\n\n\n(-\n lux;Anns lux;Bool)\n\n\n(imported-modules module-name)\n\n\nAll the modules imported by a specified module.\n\n\n\n\n(-\n lux;Text (lux;Lux (lux;List lux;Text)))\n\n\nlocals\n\n\nAll the local variables currently in scope, separated in different scopes.\n\n\n\n\n(lux;Lux (lux;List (lux;List [lux;Text lux;Type])))\n\n\n(macro-expand syntax)\n\n\nGiven code that requires applying a macro, expands repeatedly until no more direct macro-calls are left.\n\nOtherwise, returns the code as-is.\n\n\n\n\n(-\n lux;AST (lux;Lux (lux;List lux;AST)))\n\n\n(macro-expand-1 token)\n\n\nWorks just like macro-expand, except that it ensures that the output is a single AST token.\n\n\n\n\n(-\n lux;AST (lux;Lux lux;AST))\n\n\n(macro-expand-all syntax)\n\n\nExpands all macro-calls everywhere recursively, until only primitive/base code remains.\n\n\n\n\n(-\n lux;AST (lux;Lux (lux;List lux;AST)))\n\n\n(macro-expand-once syntax)\n\n\nGiven code that requires applying a macro, does it once and returns the result.\n\nOtherwise, returns the code as-is.\n\n\n\n\n(-\n lux;AST (lux;Lux (lux;List lux;AST)))\n\n\nmacro?\n\n\nChecks whether a definition is a macro.\n\n\n\n\n(-\n lux;Anns lux;Bool)\n\n\n(module-exists? module)\n\n\n(-\n lux;Text (lux;Lux lux;Bool))\n\n\nmodules\n\n\nAll the available modules (including the current one).\n\n\n\n\n(lux;Lux (lux;List [lux;Text lux;Module]))\n\n\n(normalize ident)\n\n\nIf given an identifier without a module prefix, gives it the current module's name as prefix.\n\nOtherwise, returns the identifier as-is.\n\n\n\n\n(-\n lux;Ident (lux;Lux lux;Ident))\n\n\n(resolve-tag tag)\n\n\nGiven a tag, finds out what is its index, its related tag-list and it's associated type.\n\n\n\n\n(-\n lux;Ident (lux;Lux [lux;Nat (lux;List lux;Ident) lux;Type]))\n\n\n(run compiler action)\n\n\n(All [a] (-\n lux;Compiler (lux;Lux a) (lux/data/error;Error a)))\n\n\n(run' compiler action)\n\n\n(All [a] (-\n lux;Compiler (lux;Lux a) (lux/data/error;Error [lux;Compiler a])))\n\n\nsig?\n\n\nChecks whether a definition is a signature.\n\n\n\n\n(-\n lux;Anns lux;Bool)\n\n\nstruct?\n\n\nChecks whether a definition is a structure.\n\n\n\n\n(-\n lux;Anns lux;Bool)\n\n\n(tag-lists module)\n\n\nAll the tag-lists defined in a module, with their associated types.\n\n\n\n\n(-\n lux;Text (lux;Lux (lux;List [(lux;List lux;Ident) lux;Type])))\n\n\n(tags-of type-name)\n\n\nAll the tags associated with a type definition.\n\n\n\n\n(-\n lux;Ident (lux;Lux (lux;List lux;Ident)))\n\n\n(type-args anns)\n\n\nLooks up the arguments of a parameterized type.\n\n\n\n\n(-\n lux;Anns (lux;List lux;Text))\n\n\ntype-rec?\n\n\nChecks whether a definition is a recursive type.\n\n\n\n\n(-\n lux;Anns lux;Bool)\n\n\ntype?\n\n\nChecks whether a definition is a type.\n\n\n\n\n(-\n lux;Anns lux;Bool)\n\n\n(un-alias def-name)\n\n\nGiven an aliased definition's name, returns the original definition being referenced.\n\n\n\n\n(-\n lux;Ident (lux;Lux lux;Ident))", 
            "title": "Lux compiler"
        }, 
        {
            "location": "/lux_compiler/#luxcompiler", 
            "text": "Functions for extracting information from the state of the compiler.", 
            "title": "lux/compiler"
        }, 
        {
            "location": "/lux_compiler/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_compiler/#with-gensyms", 
            "text": "## Creates new symbols and offers them to the body expression.\n(syntax: #export (synchronized lock body)\n  (with-gensyms [g!lock g!body g!_]\n    (wrap (list (` (let [(~ g!lock) (~ lock)\n                         (~ g!_) (lux;_jvm_monitorenter(~ g!lock))\n                         (~ g!body) (~ body)\n                         (~ g!_) (lux;_jvm_monitorexit(~ g!lock))]\n                     (~ g!body)))))))", 
            "title": "with-gensyms"
        }, 
        {
            "location": "/lux_compiler/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_compiler/#applicativelux", 
            "text": "(lux/control/applicative;Applicative lux;Lux)", 
            "title": "Applicative&lt;Lux&gt;"
        }, 
        {
            "location": "/lux_compiler/#functorlux", 
            "text": "(lux/control/functor;Functor lux;Lux)", 
            "title": "Functor&lt;Lux&gt;"
        }, 
        {
            "location": "/lux_compiler/#monadlux", 
            "text": "(lux/control/monad;Monad lux;Lux)", 
            "title": "Monad&lt;Lux&gt;"
        }, 
        {
            "location": "/lux_compiler/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_compiler/#assert-message-test", 
            "text": "Fails with the given message if the test is false.  (-  lux;Text lux;Bool (lux;Lux lux;Unit))", 
            "title": "(assert message test)"
        }, 
        {
            "location": "/lux_compiler/#current-module", 
            "text": "(lux;Lux lux;Module)", 
            "title": "current-module"
        }, 
        {
            "location": "/lux_compiler/#current-module-name", 
            "text": "(lux;Lux lux;Text)", 
            "title": "current-module-name"
        }, 
        {
            "location": "/lux_compiler/#cursor", 
            "text": "The cursor of the current expression being analyzed.  (lux;Lux lux;Cursor)", 
            "title": "cursor"
        }, 
        {
            "location": "/lux_compiler/#defs-module-name", 
            "text": "The entire list of definitions in a module (including the unexported/private ones).  (-  lux;Text (lux;Lux (lux;List [lux;Text lux;Def])))", 
            "title": "(defs module-name)"
        }, 
        {
            "location": "/lux_compiler/#either-left-right", 
            "text": "Pick whichever computation succeeds.  (All [a] (-  (lux;Lux a) (lux;Lux a) (lux;Lux a)))", 
            "title": "(either left right)"
        }, 
        {
            "location": "/lux_compiler/#expected-type", 
            "text": "The expected type of the current expression being analyzed.  (lux;Lux lux;Type)", 
            "title": "expected-type"
        }, 
        {
            "location": "/lux_compiler/#export", 
            "text": "Checks whether a definition is exported.  (-  lux;Anns lux;Bool)", 
            "title": "export?"
        }, 
        {
            "location": "/lux_compiler/#exports-module-name", 
            "text": "All the exported definitions in a module.  (-  lux;Text (lux;Lux (lux;List [lux;Text lux;Def])))", 
            "title": "(exports module-name)"
        }, 
        {
            "location": "/lux_compiler/#fail-msg", 
            "text": "Fails with the given message.  (All [a] (-  lux;Text (lux;Lux a)))", 
            "title": "(fail msg)"
        }, 
        {
            "location": "/lux_compiler/#find-def-name", 
            "text": "Looks-up a definition's whole data in the available modules (including the current one).  (-  lux;Ident (lux;Lux lux;Def))", 
            "title": "(find-def name)"
        }, 
        {
            "location": "/lux_compiler/#find-def-type-name", 
            "text": "Looks-up a definition's type in the available modules (including the current one).  (-  lux;Ident (lux;Lux lux;Type))", 
            "title": "(find-def-type name)"
        }, 
        {
            "location": "/lux_compiler/#find-macro-ident", 
            "text": "(-  lux;Ident (lux;Lux (lux;Maybe lux;Macro)))", 
            "title": "(find-macro ident)"
        }, 
        {
            "location": "/lux_compiler/#find-module-name", 
            "text": "(-  lux;Text (lux;Lux lux;Module))", 
            "title": "(find-module name)"
        }, 
        {
            "location": "/lux_compiler/#find-type-name", 
            "text": "Looks-up the type of either a local variable or a definition.  (-  lux;Ident (lux;Lux lux;Type))", 
            "title": "(find-type name)"
        }, 
        {
            "location": "/lux_compiler/#find-type-def-name", 
            "text": "Finds the value of a type definition (such as Int, Top or Compiler).  (-  lux;Ident (lux;Lux lux;Type))", 
            "title": "(find-type-def name)"
        }, 
        {
            "location": "/lux_compiler/#find-var-type-name", 
            "text": "Looks-up the type of a local variable somewhere in the environment.  (-  lux;Text (lux;Lux lux;Type))", 
            "title": "(find-var-type name)"
        }, 
        {
            "location": "/lux_compiler/#flag-set-flag-name-anns", 
            "text": "Finds out whether an annotation-as-a-flag is set (has value 'true').  (-  lux;Ident lux;Anns lux;Bool)", 
            "title": "(flag-set? flag-name anns)"
        }, 
        {
            "location": "/lux_compiler/#func-args-anns", 
            "text": "Looks up the arguments of a function.  (-  lux;Anns (lux;List lux;Text))", 
            "title": "(func-args anns)"
        }, 
        {
            "location": "/lux_compiler/#gensym-prefix", 
            "text": "Generates a unique identifier as an AST node (ready to be used in code templates).\n\nA prefix can be given (or just be empty text  ) to better identify the code for debugging purposes.  (-  lux;Text (lux;Lux lux;AST))", 
            "title": "(gensym prefix)"
        }, 
        {
            "location": "/lux_compiler/#get-ann-tag-anns", 
            "text": "Looks-up a particular annotation's value within the set of annotations.  (-  lux;Ident lux;Anns (lux;Maybe lux;Ann-Value))", 
            "title": "(get-ann tag anns)"
        }, 
        {
            "location": "/lux_compiler/#get-bool-ann-tag-anns", 
            "text": "(-  lux;Ident lux;Anns (lux;Maybe lux;Bool))", 
            "title": "(get-bool-ann tag anns)"
        }, 
        {
            "location": "/lux_compiler/#get-char-ann-tag-anns", 
            "text": "(-  lux;Ident lux;Anns (lux;Maybe lux;Char))", 
            "title": "(get-char-ann tag anns)"
        }, 
        {
            "location": "/lux_compiler/#get-compiler", 
            "text": "Obtains the current state of the compiler.  (lux;Lux lux;Compiler)", 
            "title": "get-compiler"
        }, 
        {
            "location": "/lux_compiler/#get-dict-ann-tag-anns", 
            "text": "(-  lux;Ident lux;Anns (lux;Maybe (lux;List [lux;Text lux;Ann-Value])))", 
            "title": "(get-dict-ann tag anns)"
        }, 
        {
            "location": "/lux_compiler/#get-doc-anns", 
            "text": "Looks-up a definition's documentation.  (-  lux;Anns (lux;Maybe lux;Text))", 
            "title": "(get-doc anns)"
        }, 
        {
            "location": "/lux_compiler/#get-ident-ann-tag-anns", 
            "text": "(-  lux;Ident lux;Anns (lux;Maybe lux;Ident))", 
            "title": "(get-ident-ann tag anns)"
        }, 
        {
            "location": "/lux_compiler/#get-int-ann-tag-anns", 
            "text": "(-  lux;Ident lux;Anns (lux;Maybe lux;Int))", 
            "title": "(get-int-ann tag anns)"
        }, 
        {
            "location": "/lux_compiler/#get-list-ann-tag-anns", 
            "text": "(-  lux;Ident lux;Anns (lux;Maybe (lux;List lux;Ann-Value)))", 
            "title": "(get-list-ann tag anns)"
        }, 
        {
            "location": "/lux_compiler/#get-real-ann-tag-anns", 
            "text": "(-  lux;Ident lux;Anns (lux;Maybe lux;Real))", 
            "title": "(get-real-ann tag anns)"
        }, 
        {
            "location": "/lux_compiler/#get-text-ann-tag-anns", 
            "text": "(-  lux;Ident lux;Anns (lux;Maybe lux;Text))", 
            "title": "(get-text-ann tag anns)"
        }, 
        {
            "location": "/lux_compiler/#hidden", 
            "text": "Checks whether a definition is hidden.  (-  lux;Anns lux;Bool)", 
            "title": "hidden?"
        }, 
        {
            "location": "/lux_compiler/#imported-modules-module-name", 
            "text": "All the modules imported by a specified module.  (-  lux;Text (lux;Lux (lux;List lux;Text)))", 
            "title": "(imported-modules module-name)"
        }, 
        {
            "location": "/lux_compiler/#locals", 
            "text": "All the local variables currently in scope, separated in different scopes.  (lux;Lux (lux;List (lux;List [lux;Text lux;Type])))", 
            "title": "locals"
        }, 
        {
            "location": "/lux_compiler/#macro-expand-syntax", 
            "text": "Given code that requires applying a macro, expands repeatedly until no more direct macro-calls are left.\n\nOtherwise, returns the code as-is.  (-  lux;AST (lux;Lux (lux;List lux;AST)))", 
            "title": "(macro-expand syntax)"
        }, 
        {
            "location": "/lux_compiler/#macro-expand-1-token", 
            "text": "Works just like macro-expand, except that it ensures that the output is a single AST token.  (-  lux;AST (lux;Lux lux;AST))", 
            "title": "(macro-expand-1 token)"
        }, 
        {
            "location": "/lux_compiler/#macro-expand-all-syntax", 
            "text": "Expands all macro-calls everywhere recursively, until only primitive/base code remains.  (-  lux;AST (lux;Lux (lux;List lux;AST)))", 
            "title": "(macro-expand-all syntax)"
        }, 
        {
            "location": "/lux_compiler/#macro-expand-once-syntax", 
            "text": "Given code that requires applying a macro, does it once and returns the result.\n\nOtherwise, returns the code as-is.  (-  lux;AST (lux;Lux (lux;List lux;AST)))", 
            "title": "(macro-expand-once syntax)"
        }, 
        {
            "location": "/lux_compiler/#macro", 
            "text": "Checks whether a definition is a macro.  (-  lux;Anns lux;Bool)", 
            "title": "macro?"
        }, 
        {
            "location": "/lux_compiler/#module-exists-module", 
            "text": "(-  lux;Text (lux;Lux lux;Bool))", 
            "title": "(module-exists? module)"
        }, 
        {
            "location": "/lux_compiler/#modules", 
            "text": "All the available modules (including the current one).  (lux;Lux (lux;List [lux;Text lux;Module]))", 
            "title": "modules"
        }, 
        {
            "location": "/lux_compiler/#normalize-ident", 
            "text": "If given an identifier without a module prefix, gives it the current module's name as prefix.\n\nOtherwise, returns the identifier as-is.  (-  lux;Ident (lux;Lux lux;Ident))", 
            "title": "(normalize ident)"
        }, 
        {
            "location": "/lux_compiler/#resolve-tag-tag", 
            "text": "Given a tag, finds out what is its index, its related tag-list and it's associated type.  (-  lux;Ident (lux;Lux [lux;Nat (lux;List lux;Ident) lux;Type]))", 
            "title": "(resolve-tag tag)"
        }, 
        {
            "location": "/lux_compiler/#run-compiler-action", 
            "text": "(All [a] (-  lux;Compiler (lux;Lux a) (lux/data/error;Error a)))", 
            "title": "(run compiler action)"
        }, 
        {
            "location": "/lux_compiler/#run-compiler-action_1", 
            "text": "(All [a] (-  lux;Compiler (lux;Lux a) (lux/data/error;Error [lux;Compiler a])))", 
            "title": "(run' compiler action)"
        }, 
        {
            "location": "/lux_compiler/#sig", 
            "text": "Checks whether a definition is a signature.  (-  lux;Anns lux;Bool)", 
            "title": "sig?"
        }, 
        {
            "location": "/lux_compiler/#struct", 
            "text": "Checks whether a definition is a structure.  (-  lux;Anns lux;Bool)", 
            "title": "struct?"
        }, 
        {
            "location": "/lux_compiler/#tag-lists-module", 
            "text": "All the tag-lists defined in a module, with their associated types.  (-  lux;Text (lux;Lux (lux;List [(lux;List lux;Ident) lux;Type])))", 
            "title": "(tag-lists module)"
        }, 
        {
            "location": "/lux_compiler/#tags-of-type-name", 
            "text": "All the tags associated with a type definition.  (-  lux;Ident (lux;Lux (lux;List lux;Ident)))", 
            "title": "(tags-of type-name)"
        }, 
        {
            "location": "/lux_compiler/#type-args-anns", 
            "text": "Looks up the arguments of a parameterized type.  (-  lux;Anns (lux;List lux;Text))", 
            "title": "(type-args anns)"
        }, 
        {
            "location": "/lux_compiler/#type-rec", 
            "text": "Checks whether a definition is a recursive type.  (-  lux;Anns lux;Bool)", 
            "title": "type-rec?"
        }, 
        {
            "location": "/lux_compiler/#type", 
            "text": "Checks whether a definition is a type.  (-  lux;Anns lux;Bool)", 
            "title": "type?"
        }, 
        {
            "location": "/lux_compiler/#un-alias-def-name", 
            "text": "Given an aliased definition's name, returns the original definition being referenced.  (-  lux;Ident (lux;Lux lux;Ident))", 
            "title": "(un-alias def-name)"
        }, 
        {
            "location": "/lux_concurrency_actor/", 
            "text": "lux/concurrency/actor\n\n\n\n\nThe actor model of concurrency.\n\n\n\n\nTypes\n\n\nActor\n\n\nAn actor, defined as all the necessities it requires.\n\n\n(type: (Actor s m)\n  {#mailbox (lux/concurrency/stm;Var m)\n   #kill-signal (lux/concurrency/promise;Promise lux;Unit)\n   #obituary (lux/concurrency/promise;Promise [(lux;Maybe lux;Text) s (lux;List m)])})\n\n\n\n\nBehavior\n\n\nAn actor's behavior when messages are received.\n\n\n(type: (Behavior s m)\n  {#step (-\n (Actor s m) m s (lux/concurrency/promise;Promise (lux/data/error;Error s)))\n   #end (-\n (lux;Maybe lux;Text) s (lux/concurrency/promise;Promise lux;Unit))})\n\n\n\n\nMacros\n\n\nactor:\n\n\n## Allows defining an actor, with a pice of state and a set of methods that can be called on it.\n## A method can access the actor's state through the *state* variable.\n## A method can also access the actor itself through the *self* variable.\n## A method may succeed or fail (in case of failure, the actor dies). This is handled through the Either type.\n## A method's output must be a promise containing a 2-tuple with the updated state and a return value.\n## All methods are run implicitly within the Promise monad.\n(actor: #export Adder\n  Int\n\n  (method: (count! [to-add Int])\n    [Int Int]\n    (if (i.\n= 0 to-add)\n      (let [new-state (i.+ to-add *state*)]\n        (wrap (#lux;Right[new-state [*state* new-state]])))\n      (wrap (#lux;Left\nCan't add negative numbers!\n)))))\n\n\n\n\nValues\n\n\n(alive? actor)\n\n\n(All [a b] (-\n (Actor a b) lux;Bool))\n\n\n(keep-alive init behavior)\n\n\nGiven initial-state and a behavior, spawns an actor that will reboot if it dies of errors.\n\nHowever, if it is killed, it won't re-spawn.\n\n\n\n\n(All [a b] (-\n a (Behavior a b) (lux/codata/io;IO (Actor a b))))\n\n\npoison\n\n\nImmediately kills the given actor (if it's not already dead).\n\n\n\n\n(All [a b] (-\n (Actor a b) (lux/codata/io;IO lux;Bool)))\n\n\n(send message actor)\n\n\nCommunicate with an actor through message passing.\n\n\n\n\n(All [a b] (-\n b (Actor a b) (lux/concurrency/promise;Promise lux;Bool)))\n\n\n(spawn init behavior)\n\n\nGiven a behavior and initial state, spawns an actor and returns it.\n\n\n\n\n(All [a b] (-\n a (Behavior a b) (lux/codata/io;IO (Actor a b))))", 
            "title": "Lux concurrency actor"
        }, 
        {
            "location": "/lux_concurrency_actor/#luxconcurrencyactor", 
            "text": "The actor model of concurrency.", 
            "title": "lux/concurrency/actor"
        }, 
        {
            "location": "/lux_concurrency_actor/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_concurrency_actor/#actor", 
            "text": "An actor, defined as all the necessities it requires.  (type: (Actor s m)\n  {#mailbox (lux/concurrency/stm;Var m)\n   #kill-signal (lux/concurrency/promise;Promise lux;Unit)\n   #obituary (lux/concurrency/promise;Promise [(lux;Maybe lux;Text) s (lux;List m)])})", 
            "title": "Actor"
        }, 
        {
            "location": "/lux_concurrency_actor/#behavior", 
            "text": "An actor's behavior when messages are received.  (type: (Behavior s m)\n  {#step (-  (Actor s m) m s (lux/concurrency/promise;Promise (lux/data/error;Error s)))\n   #end (-  (lux;Maybe lux;Text) s (lux/concurrency/promise;Promise lux;Unit))})", 
            "title": "Behavior"
        }, 
        {
            "location": "/lux_concurrency_actor/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_concurrency_actor/#actor_1", 
            "text": "## Allows defining an actor, with a pice of state and a set of methods that can be called on it.\n## A method can access the actor's state through the *state* variable.\n## A method can also access the actor itself through the *self* variable.\n## A method may succeed or fail (in case of failure, the actor dies). This is handled through the Either type.\n## A method's output must be a promise containing a 2-tuple with the updated state and a return value.\n## All methods are run implicitly within the Promise monad.\n(actor: #export Adder\n  Int\n\n  (method: (count! [to-add Int])\n    [Int Int]\n    (if (i. = 0 to-add)\n      (let [new-state (i.+ to-add *state*)]\n        (wrap (#lux;Right[new-state [*state* new-state]])))\n      (wrap (#lux;Left Can't add negative numbers! )))))", 
            "title": "actor:"
        }, 
        {
            "location": "/lux_concurrency_actor/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_concurrency_actor/#alive-actor", 
            "text": "(All [a b] (-  (Actor a b) lux;Bool))", 
            "title": "(alive? actor)"
        }, 
        {
            "location": "/lux_concurrency_actor/#keep-alive-init-behavior", 
            "text": "Given initial-state and a behavior, spawns an actor that will reboot if it dies of errors.\n\nHowever, if it is killed, it won't re-spawn.  (All [a b] (-  a (Behavior a b) (lux/codata/io;IO (Actor a b))))", 
            "title": "(keep-alive init behavior)"
        }, 
        {
            "location": "/lux_concurrency_actor/#poison", 
            "text": "Immediately kills the given actor (if it's not already dead).  (All [a b] (-  (Actor a b) (lux/codata/io;IO lux;Bool)))", 
            "title": "poison"
        }, 
        {
            "location": "/lux_concurrency_actor/#send-message-actor", 
            "text": "Communicate with an actor through message passing.  (All [a b] (-  b (Actor a b) (lux/concurrency/promise;Promise lux;Bool)))", 
            "title": "(send message actor)"
        }, 
        {
            "location": "/lux_concurrency_actor/#spawn-init-behavior", 
            "text": "Given a behavior and initial state, spawns an actor and returns it.  (All [a b] (-  a (Behavior a b) (lux/codata/io;IO (Actor a b))))", 
            "title": "(spawn init behavior)"
        }, 
        {
            "location": "/lux_concurrency_atom/", 
            "text": "lux/concurrency/atom\n\n\nTypes\n\n\nAtom\n\n\nAtomic references that are safe to mutate concurrently.\n\n\n(type: (Atom a)\n  ((All [b] (host java.util.concurrent.atomic.AtomicReference c)) a))\n\n\n\n\nValues\n\n\n(atom value)\n\n\n(All [a] (-\n a (Atom a)))\n\n\n(compare-and-swap current new atom)\n\n\nOnly mutates an atom if you can present it's current value.\n\nThat guarantees that atom wasn't updated since you last read from it.\n\n\n\n\n(All [a] (-\n a a (Atom a) (lux/codata/io;IO lux;Bool)))\n\n\n(get atom)\n\n\n(All [a] (-\n (Atom a) (lux/codata/io;IO a)))\n\n\n(set value atom)\n\n\n(All [a] (-\n a (Atom a) (lux/codata/io;IO lux;Unit)))\n\n\n(update f atom)\n\n\nUpdates an atom by applying a function to its current value.\n\nIf it fails to update it (because some other process wrote to it first), it will retry until it succeeds.\n\nThe retries will be done with the new values of the atom, as they show up.\n\n\n\n\n(All [a] (-\n (-\n a a) (Atom a) (lux/codata/io;IO lux;Unit)))", 
            "title": "Lux concurrency atom"
        }, 
        {
            "location": "/lux_concurrency_atom/#luxconcurrencyatom", 
            "text": "", 
            "title": "lux/concurrency/atom"
        }, 
        {
            "location": "/lux_concurrency_atom/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_concurrency_atom/#atom", 
            "text": "Atomic references that are safe to mutate concurrently.  (type: (Atom a)\n  ((All [b] (host java.util.concurrent.atomic.AtomicReference c)) a))", 
            "title": "Atom"
        }, 
        {
            "location": "/lux_concurrency_atom/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_concurrency_atom/#atom-value", 
            "text": "(All [a] (-  a (Atom a)))", 
            "title": "(atom value)"
        }, 
        {
            "location": "/lux_concurrency_atom/#compare-and-swap-current-new-atom", 
            "text": "Only mutates an atom if you can present it's current value.\n\nThat guarantees that atom wasn't updated since you last read from it.  (All [a] (-  a a (Atom a) (lux/codata/io;IO lux;Bool)))", 
            "title": "(compare-and-swap current new atom)"
        }, 
        {
            "location": "/lux_concurrency_atom/#get-atom", 
            "text": "(All [a] (-  (Atom a) (lux/codata/io;IO a)))", 
            "title": "(get atom)"
        }, 
        {
            "location": "/lux_concurrency_atom/#set-value-atom", 
            "text": "(All [a] (-  a (Atom a) (lux/codata/io;IO lux;Unit)))", 
            "title": "(set value atom)"
        }, 
        {
            "location": "/lux_concurrency_atom/#update-f-atom", 
            "text": "Updates an atom by applying a function to its current value.\n\nIf it fails to update it (because some other process wrote to it first), it will retry until it succeeds.\n\nThe retries will be done with the new values of the atom, as they show up.  (All [a] (-  (-  a a) (Atom a) (lux/codata/io;IO lux;Unit)))", 
            "title": "(update f atom)"
        }, 
        {
            "location": "/lux_concurrency_frp/", 
            "text": "lux/concurrency/frp\n\n\nTypes\n\n\nChan\n\n\nAn asynchronous channel of values which may be closed.\n\n\nReading from a channel does not remove the read piece of data, as it can still be accessed if you have an earlier node of the channel.\n\n\n(type: (Chan a)\n  (lux/concurrency/promise;Promise (lux;Maybe [a (Chan a)])))\n\n\n\n\nMacros\n\n\nchan\n\n\n## Makes an uninitialized Chan (in this case, of Unit).\n(chan Unit)\n\n## The type is optional.\n(chan)\n\n\n\n\nStructs\n\n\nApplicative\nChan\n\n\n(lux/control/applicative;Applicative Chan)\n\n\nFunctor\nChan\n\n\n(lux/control/functor;Functor Chan)\n\n\nMonad\nChan\n\n\n(lux/control/monad;Monad Chan)\n\n\nValues\n\n\n(as-chan p)\n\n\n(All [a] (-\n (lux/concurrency/promise;Promise a) (Chan a)))\n\n\n(close chan)\n\n\n(All [a] (-\n (Chan a) (lux/codata/io;IO lux;Bool)))\n\n\n(consume xs)\n\n\nReads the entirety of a channel's contents and returns them as a list.\n\n\n\n\n(All [a] (-\n (Chan a) (lux/concurrency/promise;Promise (lux;List a))))\n\n\n(filter p xs)\n\n\n(All [a] (-\n (-\n a lux;Bool) (Chan a) (Chan a)))\n\n\n(fold f init xs)\n\n\nAsynchronous fold over channels.\n\n\n\n\n(All [a b] (-\n (-\n b a (lux/concurrency/promise;Promise a)) a (Chan b) (lux/concurrency/promise;Promise a)))\n\n\n(merge xss)\n\n\nFuse all the elements in a list of channels by piping them onto a new output channel.\n\n\n\n\n(All [a] (-\n (lux;List (Chan a)) (Chan a)))\n\n\n(no-dups eq xs)\n\n\nMultiple consecutive equal values in the input channel will just be single value in the output channel.\n\n\n\n\n(All [a] (-\n (lux/control/eq;Eq a) (Chan a) (Chan a)))\n\n\n(pipe input output)\n\n\nCopy/pipe the contents of a channel on to another.\n\n\n\n\n(All [a] (-\n (Chan a) (Chan a) (lux/concurrency/promise;Promise lux;Unit)))\n\n\n(write value chan)\n\n\nWrite to a channel, so long as it's still open.\n\n\n\n\n(All [a] (-\n a (Chan a) (lux/codata/io;IO (lux;Maybe (Chan a)))))", 
            "title": "Lux concurrency frp"
        }, 
        {
            "location": "/lux_concurrency_frp/#luxconcurrencyfrp", 
            "text": "", 
            "title": "lux/concurrency/frp"
        }, 
        {
            "location": "/lux_concurrency_frp/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_concurrency_frp/#chan", 
            "text": "An asynchronous channel of values which may be closed.  Reading from a channel does not remove the read piece of data, as it can still be accessed if you have an earlier node of the channel.  (type: (Chan a)\n  (lux/concurrency/promise;Promise (lux;Maybe [a (Chan a)])))", 
            "title": "Chan"
        }, 
        {
            "location": "/lux_concurrency_frp/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_concurrency_frp/#chan_1", 
            "text": "## Makes an uninitialized Chan (in this case, of Unit).\n(chan Unit)\n\n## The type is optional.\n(chan)", 
            "title": "chan"
        }, 
        {
            "location": "/lux_concurrency_frp/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_concurrency_frp/#applicativechan", 
            "text": "(lux/control/applicative;Applicative Chan)", 
            "title": "Applicative&lt;Chan&gt;"
        }, 
        {
            "location": "/lux_concurrency_frp/#functorchan", 
            "text": "(lux/control/functor;Functor Chan)", 
            "title": "Functor&lt;Chan&gt;"
        }, 
        {
            "location": "/lux_concurrency_frp/#monadchan", 
            "text": "(lux/control/monad;Monad Chan)", 
            "title": "Monad&lt;Chan&gt;"
        }, 
        {
            "location": "/lux_concurrency_frp/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_concurrency_frp/#as-chan-p", 
            "text": "(All [a] (-  (lux/concurrency/promise;Promise a) (Chan a)))", 
            "title": "(as-chan p)"
        }, 
        {
            "location": "/lux_concurrency_frp/#close-chan", 
            "text": "(All [a] (-  (Chan a) (lux/codata/io;IO lux;Bool)))", 
            "title": "(close chan)"
        }, 
        {
            "location": "/lux_concurrency_frp/#consume-xs", 
            "text": "Reads the entirety of a channel's contents and returns them as a list.  (All [a] (-  (Chan a) (lux/concurrency/promise;Promise (lux;List a))))", 
            "title": "(consume xs)"
        }, 
        {
            "location": "/lux_concurrency_frp/#filter-p-xs", 
            "text": "(All [a] (-  (-  a lux;Bool) (Chan a) (Chan a)))", 
            "title": "(filter p xs)"
        }, 
        {
            "location": "/lux_concurrency_frp/#fold-f-init-xs", 
            "text": "Asynchronous fold over channels.  (All [a b] (-  (-  b a (lux/concurrency/promise;Promise a)) a (Chan b) (lux/concurrency/promise;Promise a)))", 
            "title": "(fold f init xs)"
        }, 
        {
            "location": "/lux_concurrency_frp/#merge-xss", 
            "text": "Fuse all the elements in a list of channels by piping them onto a new output channel.  (All [a] (-  (lux;List (Chan a)) (Chan a)))", 
            "title": "(merge xss)"
        }, 
        {
            "location": "/lux_concurrency_frp/#no-dups-eq-xs", 
            "text": "Multiple consecutive equal values in the input channel will just be single value in the output channel.  (All [a] (-  (lux/control/eq;Eq a) (Chan a) (Chan a)))", 
            "title": "(no-dups eq xs)"
        }, 
        {
            "location": "/lux_concurrency_frp/#pipe-input-output", 
            "text": "Copy/pipe the contents of a channel on to another.  (All [a] (-  (Chan a) (Chan a) (lux/concurrency/promise;Promise lux;Unit)))", 
            "title": "(pipe input output)"
        }, 
        {
            "location": "/lux_concurrency_frp/#write-value-chan", 
            "text": "Write to a channel, so long as it's still open.  (All [a] (-  a (Chan a) (lux/codata/io;IO (lux;Maybe (Chan a)))))", 
            "title": "(write value chan)"
        }, 
        {
            "location": "/lux_concurrency_promise/", 
            "text": "lux/concurrency/promise\n\n\nTypes\n\n\nPromise\n\n\nRepresents values produced by asynchronous computations (unlike IO, which is synchronous).\n\n\n(type: (Promise a)\n  (lux/concurrency/atom;Atom (Promise-State a)))\n\n\n\n\nMacros\n\n\npromise\n\n\n## Makes an uninitialized Promise (in this example, of Unit).\n(promise Unit)\n\n## The type is optional.\n(promise)\n\n\n\n\nStructs\n\n\nApplicative\nPromise\n\n\n(lux/control/applicative;Applicative Promise)\n\n\nFunctor\nPromise\n\n\n(lux/control/functor;Functor Promise)\n\n\nMonad\nPromise\n\n\n(lux/control/monad;Monad Promise)\n\n\nValues\n\n\n(alt left right)\n\n\nHeterogeneous alternative combinator.\n\n\n\n\n(All [a b] (-\n (Promise a) (Promise b) (Promise (| a b))))\n\n\nconcurrency-level\n\n\nlux;Nat\n\n\n(delay time value)\n\n\nDelivers a value after a certain period has passed.\n\n\n\n\n(All [a] (-\n lux;Nat a (Promise a)))\n\n\n(either left right)\n\n\nHomogeneous alternative combinator.\n\n\n\n\n(All [a] (-\n (Promise a) (Promise a) (Promise a)))\n\n\n(future computation)\n\n\nRuns an I/O computation on its own process and returns an Promise that will eventually host its result.\n\n\n\n\n(All [a] (-\n (lux/codata/io;IO a) (Promise a)))\n\n\n(poll promise)\n\n\nChecks whether an Promise's value has already been resolved.\n\n\n\n\n(All [a] (-\n (Promise a) (lux;Maybe a)))\n\n\n(resolve value promise)\n\n\nSets an Promise's value if it hasn't been done yet.\n\n\n\n\n(All [a] (-\n a (Promise a) (lux/codata/io;IO lux;Bool)))\n\n\n(seq left right)\n\n\nSequencing combinator.\n\n\n\n\n(All [a b] (-\n (Promise a) (Promise b) (Promise [a b])))\n\n\n(time-out time promise)\n\n\nWait for a Promise to be resolved within the specified amount of milliseconds.\n\n\n\n\n(All [a] (-\n lux;Nat (Promise a) (Promise (lux;Maybe a))))\n\n\n(wait time)\n\n\nReturns a Promise that will be resolved after the specified amount of milliseconds.\n\n\n\n\n(-\n lux;Nat (Promise lux;Unit))", 
            "title": "Lux concurrency promise"
        }, 
        {
            "location": "/lux_concurrency_promise/#luxconcurrencypromise", 
            "text": "", 
            "title": "lux/concurrency/promise"
        }, 
        {
            "location": "/lux_concurrency_promise/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_concurrency_promise/#promise", 
            "text": "Represents values produced by asynchronous computations (unlike IO, which is synchronous).  (type: (Promise a)\n  (lux/concurrency/atom;Atom (Promise-State a)))", 
            "title": "Promise"
        }, 
        {
            "location": "/lux_concurrency_promise/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_concurrency_promise/#promise_1", 
            "text": "## Makes an uninitialized Promise (in this example, of Unit).\n(promise Unit)\n\n## The type is optional.\n(promise)", 
            "title": "promise"
        }, 
        {
            "location": "/lux_concurrency_promise/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_concurrency_promise/#applicativepromise", 
            "text": "(lux/control/applicative;Applicative Promise)", 
            "title": "Applicative&lt;Promise&gt;"
        }, 
        {
            "location": "/lux_concurrency_promise/#functorpromise", 
            "text": "(lux/control/functor;Functor Promise)", 
            "title": "Functor&lt;Promise&gt;"
        }, 
        {
            "location": "/lux_concurrency_promise/#monadpromise", 
            "text": "(lux/control/monad;Monad Promise)", 
            "title": "Monad&lt;Promise&gt;"
        }, 
        {
            "location": "/lux_concurrency_promise/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_concurrency_promise/#alt-left-right", 
            "text": "Heterogeneous alternative combinator.  (All [a b] (-  (Promise a) (Promise b) (Promise (| a b))))", 
            "title": "(alt left right)"
        }, 
        {
            "location": "/lux_concurrency_promise/#concurrency-level", 
            "text": "lux;Nat", 
            "title": "concurrency-level"
        }, 
        {
            "location": "/lux_concurrency_promise/#delay-time-value", 
            "text": "Delivers a value after a certain period has passed.  (All [a] (-  lux;Nat a (Promise a)))", 
            "title": "(delay time value)"
        }, 
        {
            "location": "/lux_concurrency_promise/#either-left-right", 
            "text": "Homogeneous alternative combinator.  (All [a] (-  (Promise a) (Promise a) (Promise a)))", 
            "title": "(either left right)"
        }, 
        {
            "location": "/lux_concurrency_promise/#future-computation", 
            "text": "Runs an I/O computation on its own process and returns an Promise that will eventually host its result.  (All [a] (-  (lux/codata/io;IO a) (Promise a)))", 
            "title": "(future computation)"
        }, 
        {
            "location": "/lux_concurrency_promise/#poll-promise", 
            "text": "Checks whether an Promise's value has already been resolved.  (All [a] (-  (Promise a) (lux;Maybe a)))", 
            "title": "(poll promise)"
        }, 
        {
            "location": "/lux_concurrency_promise/#resolve-value-promise", 
            "text": "Sets an Promise's value if it hasn't been done yet.  (All [a] (-  a (Promise a) (lux/codata/io;IO lux;Bool)))", 
            "title": "(resolve value promise)"
        }, 
        {
            "location": "/lux_concurrency_promise/#seq-left-right", 
            "text": "Sequencing combinator.  (All [a b] (-  (Promise a) (Promise b) (Promise [a b])))", 
            "title": "(seq left right)"
        }, 
        {
            "location": "/lux_concurrency_promise/#time-out-time-promise", 
            "text": "Wait for a Promise to be resolved within the specified amount of milliseconds.  (All [a] (-  lux;Nat (Promise a) (Promise (lux;Maybe a))))", 
            "title": "(time-out time promise)"
        }, 
        {
            "location": "/lux_concurrency_promise/#wait-time", 
            "text": "Returns a Promise that will be resolved after the specified amount of milliseconds.  (-  lux;Nat (Promise lux;Unit))", 
            "title": "(wait time)"
        }, 
        {
            "location": "/lux_concurrency_stm/", 
            "text": "lux/concurrency/stm\n\n\nTypes\n\n\nSTM\n\n\nA computation which updates a transaction and produces a value.\n\n\n(type: (STM a)\n  (-\n Tx [Tx a]))\n\n\n\n\nVar\n\n\nA mutable cell containing a value, and observers that will be alerted of any change to it.\n\n\n(type: (Var a)\n  (lux/concurrency/atom;Atom (Var-State a)))\n\n\n\n\nStructs\n\n\nApplicative\nSTM\n\n\n(lux/control/applicative;Applicative STM)\n\n\nFunctor\nSTM\n\n\n(lux/control/functor;Functor STM)\n\n\nMonad\nSTM\n\n\n(lux/control/monad;Monad STM)\n\n\nValues\n\n\n(commit stm-proc)\n\n\nCommits a transaction and returns its result (asynchronously).\n\nNote that a transaction may be re-run an indeterminate number of times if other transactions involving the same variables successfully commit first.\n\nFor this reason, it's important to note that transactions must be free from side-effects, such as I/O.\n\n\n\n\n(All [a] (-\n (STM a) (lux/concurrency/promise;Promise a)))\n\n\n(follow label target)\n\n\nCreates a channel (identified by a label) that will receive all changes to the value of the given var.\n\n\n\n\n(All [a] (-\n lux;Text (Var a) (lux/codata/io;IO (lux/concurrency/frp;Chan a))))\n\n\n(read var)\n\n\n(All [a] (-\n (Var a) (STM a)))\n\n\n(read! var)\n\n\nReads var immediately, without going through a transaction.\n\n\n\n\n(All [a] (-\n (Var a) (lux/codata/io;IO a)))\n\n\n(unfollow label target)\n\n\nStop tracking the changes to a Var.\n\nCaveat emptor: It won't close any Chan that used to track the changes.\n\n\n\n\n(All [a] (-\n lux;Text (Var a) (lux/codata/io;IO lux;Unit)))\n\n\n(update f var)\n\n\nWill update a Var's value, and return a tuple with the old and the new values.\n\n\n\n\n(All [a] (-\n (-\n a a) (Var a) (STM [a a])))\n\n\n(update! f var)\n\n\nWill update a Var's value, and return a tuple with the old and the new values.\n\n\n\n\n(All [a] (-\n (-\n a a) (Var a) (lux/codata/io;IO [a a])))\n\n\n(var value)\n\n\nCreates a new STM var, with a default value.\n\n\n\n\n(All [a] (-\n a (Var a)))\n\n\n(write value var)\n\n\n(All [a] (-\n a (Var a) (STM lux;Unit)))\n\n\n(write! new-value var)\n\n\nWrites value to var immediately, without going through a transaction.\n\n\n\n\n(All [a] (-\n a (Var a) (lux/codata/io;IO lux;Unit)))", 
            "title": "Lux concurrency stm"
        }, 
        {
            "location": "/lux_concurrency_stm/#luxconcurrencystm", 
            "text": "", 
            "title": "lux/concurrency/stm"
        }, 
        {
            "location": "/lux_concurrency_stm/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_concurrency_stm/#stm", 
            "text": "A computation which updates a transaction and produces a value.  (type: (STM a)\n  (-  Tx [Tx a]))", 
            "title": "STM"
        }, 
        {
            "location": "/lux_concurrency_stm/#var", 
            "text": "A mutable cell containing a value, and observers that will be alerted of any change to it.  (type: (Var a)\n  (lux/concurrency/atom;Atom (Var-State a)))", 
            "title": "Var"
        }, 
        {
            "location": "/lux_concurrency_stm/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_concurrency_stm/#applicativestm", 
            "text": "(lux/control/applicative;Applicative STM)", 
            "title": "Applicative&lt;STM&gt;"
        }, 
        {
            "location": "/lux_concurrency_stm/#functorstm", 
            "text": "(lux/control/functor;Functor STM)", 
            "title": "Functor&lt;STM&gt;"
        }, 
        {
            "location": "/lux_concurrency_stm/#monadstm", 
            "text": "(lux/control/monad;Monad STM)", 
            "title": "Monad&lt;STM&gt;"
        }, 
        {
            "location": "/lux_concurrency_stm/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_concurrency_stm/#commit-stm-proc", 
            "text": "Commits a transaction and returns its result (asynchronously).\n\nNote that a transaction may be re-run an indeterminate number of times if other transactions involving the same variables successfully commit first.\n\nFor this reason, it's important to note that transactions must be free from side-effects, such as I/O.  (All [a] (-  (STM a) (lux/concurrency/promise;Promise a)))", 
            "title": "(commit stm-proc)"
        }, 
        {
            "location": "/lux_concurrency_stm/#follow-label-target", 
            "text": "Creates a channel (identified by a label) that will receive all changes to the value of the given var.  (All [a] (-  lux;Text (Var a) (lux/codata/io;IO (lux/concurrency/frp;Chan a))))", 
            "title": "(follow label target)"
        }, 
        {
            "location": "/lux_concurrency_stm/#read-var", 
            "text": "(All [a] (-  (Var a) (STM a)))", 
            "title": "(read var)"
        }, 
        {
            "location": "/lux_concurrency_stm/#read-var_1", 
            "text": "Reads var immediately, without going through a transaction.  (All [a] (-  (Var a) (lux/codata/io;IO a)))", 
            "title": "(read! var)"
        }, 
        {
            "location": "/lux_concurrency_stm/#unfollow-label-target", 
            "text": "Stop tracking the changes to a Var.\n\nCaveat emptor: It won't close any Chan that used to track the changes.  (All [a] (-  lux;Text (Var a) (lux/codata/io;IO lux;Unit)))", 
            "title": "(unfollow label target)"
        }, 
        {
            "location": "/lux_concurrency_stm/#update-f-var", 
            "text": "Will update a Var's value, and return a tuple with the old and the new values.  (All [a] (-  (-  a a) (Var a) (STM [a a])))", 
            "title": "(update f var)"
        }, 
        {
            "location": "/lux_concurrency_stm/#update-f-var_1", 
            "text": "Will update a Var's value, and return a tuple with the old and the new values.  (All [a] (-  (-  a a) (Var a) (lux/codata/io;IO [a a])))", 
            "title": "(update! f var)"
        }, 
        {
            "location": "/lux_concurrency_stm/#var-value", 
            "text": "Creates a new STM var, with a default value.  (All [a] (-  a (Var a)))", 
            "title": "(var value)"
        }, 
        {
            "location": "/lux_concurrency_stm/#write-value-var", 
            "text": "(All [a] (-  a (Var a) (STM lux;Unit)))", 
            "title": "(write value var)"
        }, 
        {
            "location": "/lux_concurrency_stm/#write-new-value-var", 
            "text": "Writes value to var immediately, without going through a transaction.  (All [a] (-  a (Var a) (lux/codata/io;IO lux;Unit)))", 
            "title": "(write! new-value var)"
        }, 
        {
            "location": "/lux_control_applicative/", 
            "text": "lux/control/applicative\n\n\nTypes\n\n\nApplicative\n\n\nApplicative functors.\n\n\n(sig: (Applicative f)\n  (: (lux/control/functor;Functor f)\n     functor)\n   (: (All [b] (-\n b (f b)))\n     wrap)\n   (: (All [b c] (-\n (f (-\n b c)) (f b) (f c)))\n     apply))\n\n\n\n\nStructs\n\n\n(compA Applicative\nF\n Applicative\nG\n)\n\n\nApplicative functor composition.\n\n\n\n\n(All [a b] (-\n (Applicative a) (Applicative b) (Applicative (All [c] (a (b c))))))", 
            "title": "Lux control applicative"
        }, 
        {
            "location": "/lux_control_applicative/#luxcontrolapplicative", 
            "text": "", 
            "title": "lux/control/applicative"
        }, 
        {
            "location": "/lux_control_applicative/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_control_applicative/#applicative", 
            "text": "Applicative functors.  (sig: (Applicative f)\n  (: (lux/control/functor;Functor f)\n     functor)\n   (: (All [b] (-  b (f b)))\n     wrap)\n   (: (All [b c] (-  (f (-  b c)) (f b) (f c)))\n     apply))", 
            "title": "Applicative"
        }, 
        {
            "location": "/lux_control_applicative/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_control_applicative/#compa-applicativef-applicativeg", 
            "text": "Applicative functor composition.  (All [a b] (-  (Applicative a) (Applicative b) (Applicative (All [c] (a (b c))))))", 
            "title": "(compA Applicative&lt;F&gt; Applicative&lt;G&gt;)"
        }, 
        {
            "location": "/lux_control_bounded/", 
            "text": "lux/control/bounded\n\n\nTypes\n\n\nBounded\n\n\nA representation of top and bottom boundaries for an ordered type.\n\n\n(sig: (Bounded a)\n  (: a\n     top)\n   (: a\n     bottom))", 
            "title": "Lux control bounded"
        }, 
        {
            "location": "/lux_control_bounded/#luxcontrolbounded", 
            "text": "", 
            "title": "lux/control/bounded"
        }, 
        {
            "location": "/lux_control_bounded/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_control_bounded/#bounded", 
            "text": "A representation of top and bottom boundaries for an ordered type.  (sig: (Bounded a)\n  (: a\n     top)\n   (: a\n     bottom))", 
            "title": "Bounded"
        }, 
        {
            "location": "/lux_control_codec/", 
            "text": "lux/control/codec\n\n\nTypes\n\n\nCodec\n\n\nA way to move back-and-forth between a type and an alternative representation for it.\n\n\n(sig: (Codec m a)\n  (: (-\n a m)\n     encode)\n   (: (-\n m (lux/data/error;Error a))\n     decode))\n\n\n\n\nStructs\n\n\n(compC Codec\nc,b\n Codec\nb,a\n)\n\n\nCodec composition.\n\n\n\n\n(All [a b c] (-\n (Codec c b) (Codec b a) (Codec c a)))", 
            "title": "Lux control codec"
        }, 
        {
            "location": "/lux_control_codec/#luxcontrolcodec", 
            "text": "", 
            "title": "lux/control/codec"
        }, 
        {
            "location": "/lux_control_codec/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_control_codec/#codec", 
            "text": "A way to move back-and-forth between a type and an alternative representation for it.  (sig: (Codec m a)\n  (: (-  a m)\n     encode)\n   (: (-  m (lux/data/error;Error a))\n     decode))", 
            "title": "Codec"
        }, 
        {
            "location": "/lux_control_codec/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_control_codec/#compc-codeccb-codecba", 
            "text": "Codec composition.  (All [a b c] (-  (Codec c b) (Codec b a) (Codec c a)))", 
            "title": "(compC Codec&lt;c,b&gt; Codec&lt;b,a&gt;)"
        }, 
        {
            "location": "/lux_control_comonad/", 
            "text": "lux/control/comonad\n\n\nTypes\n\n\nCoMonad\n\n\nCoMonads are the opposite/complement to monads.\n\n\nCoMonadic structures are often infinite in size and built upon lazily-evaluated functions.\n\n\n(sig: (CoMonad w)\n  (: (lux/control/functor;Functor w)\n     functor)\n   (: (All [b] (-\n (w b) b))\n     unwrap)\n   (: (All [b] (-\n (w b) (w (w b))))\n     split))\n\n\n\n\nMacros\n\n\nbe\n\n\n## A co-monadic parallel to the \ndo\n macro.\n(let [square (lambda [n] (i.* n n))]\n  (be CoMonad\nStream\n\n    [inputs (iterate i.inc 2)]\n    (square (head inputs))))", 
            "title": "Lux control comonad"
        }, 
        {
            "location": "/lux_control_comonad/#luxcontrolcomonad", 
            "text": "", 
            "title": "lux/control/comonad"
        }, 
        {
            "location": "/lux_control_comonad/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_control_comonad/#comonad", 
            "text": "CoMonads are the opposite/complement to monads.  CoMonadic structures are often infinite in size and built upon lazily-evaluated functions.  (sig: (CoMonad w)\n  (: (lux/control/functor;Functor w)\n     functor)\n   (: (All [b] (-  (w b) b))\n     unwrap)\n   (: (All [b] (-  (w b) (w (w b))))\n     split))", 
            "title": "CoMonad"
        }, 
        {
            "location": "/lux_control_comonad/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_control_comonad/#be", 
            "text": "## A co-monadic parallel to the  do  macro.\n(let [square (lambda [n] (i.* n n))]\n  (be CoMonad Stream \n    [inputs (iterate i.inc 2)]\n    (square (head inputs))))", 
            "title": "be"
        }, 
        {
            "location": "/lux_control_effect/", 
            "text": "lux/control/effect\n\n\n\n\nAlgebraic effects.\n\n\n\n\nTypes\n\n\nEff\n\n\nA Free Monad implementation for algebraic effects.\n\n\n(type: (Eff F a)\n  (#Pure a)\n  (#Effect (F (Eff F a))))\n\n\n\n\nHandler\n\n\nA way to interpret effects into arbitrary monads.\n\n\n(sig: (Handler E M)\n  (: (lux/control/monad;Monad M)\n     monad)\n   (: (All [c] (-\n (E c) (M c)))\n     handle))\n\n\n\n\nMacros\n\n\ndoE\n\n\n## An alternative to the 'do' macro for monads.\n(with-handler Handler\nEffABC,IO\n\n  (doE Functor\nEffABC\n\n    [a (lift fieldA)\n     b (lift fieldB)\n     c (lift fieldC)]\n    (wrap ($_ n.+ a b c))))\n\n\n\n\neffect:\n\n\n## Define effects by specifying which operations and constants a handler must provide.\n(effect: #export EffA\n  (opA [Nat Text] Bool)\n  (fieldA Nat))\n\n## In this case, 'opA' will be a function (-\n Nat Text Bool).\n## 'fieldA' will be a value provided by a handler.\n\n\n\n\nhandler:\n\n\n## Define effect handlers by implementing the operations and values of an effect.\n(handler: _\n  (=\n EffA [IO Monad\nIO\n])\n  (def: (opA length sample)\n    (:: Monad\nIO\n wrap (n.\n length\n                            (size sample))))\n\n  (def: fieldA (:: Monad\nIO\n wrap +10)))\n\n## Since a name for the handler was not specified, 'handler:' will generate the name as Handler\nEffA,IO\n.\n\n\n\n\nlift\n\n\n## A way to (automatically) lift effectful fields and operations from simple effects into the larger space of composite effects.\n(with-handler Handler\nEffABC,IO\n\n  (doE Functor\nEffABC\n\n    [a (lift fieldA)\n     b (lift fieldB)\n     c (lift fieldC)]\n    (wrap ($_ n.+ a b c))))\n\n\n\n\n|E\n\n\n## A way to combine smaller effect into a larger effect.\n(type: EffABC (|E EffA EffB EffC))\n\n\n\n\n|F\n\n\n## A way to combine smaller effect functors into a larger functor.\n(def: Functor\nEffABC\n\n  (Functor EffABC)\n  (|F Functor\nEffA\n Functor\nEffB\n Functor\nEffC\n))\n\n\n\n\n|H\n\n\n## A way to combine smaller effect handlers into a larger handler.\n(def: Handler\nEffABC,IO\n\n  (Handler EffABC lux/codata/io;IO)\n  (|H lux/codata/io;Monad\nIO\n\n      Handler\nEffA,IO\n Handler\nEffB,IO\n Handler\nEffC,IO\n))\n\n\n\n\nStructs\n\n\n(Applicative\nEff\n dsl)\n\n\n(All [a] (-\n (lux/control/functor;Functor a) (lux/control/applicative;Applicative (Eff a))))\n\n\n(Functor\nEff\n dsl)\n\n\n(All [a] (-\n (lux/control/functor;Functor a) (lux/control/functor;Functor (Eff a))))\n\n\n(Monad\nEff\n dsl)\n\n\n(All [a] (-\n (lux/control/functor;Functor a) (lux/control/monad;Monad (Eff a))))\n\n\nValues\n\n\n(with-handler handler body)\n\n\nHandles an effectful computation with the given handler to produce a monadic value.\n\n\n\n\n(All [a b c] (-\n (Handler a b) (Eff a c) (b c)))", 
            "title": "Lux control effect"
        }, 
        {
            "location": "/lux_control_effect/#luxcontroleffect", 
            "text": "Algebraic effects.", 
            "title": "lux/control/effect"
        }, 
        {
            "location": "/lux_control_effect/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_control_effect/#eff", 
            "text": "A Free Monad implementation for algebraic effects.  (type: (Eff F a)\n  (#Pure a)\n  (#Effect (F (Eff F a))))", 
            "title": "Eff"
        }, 
        {
            "location": "/lux_control_effect/#handler", 
            "text": "A way to interpret effects into arbitrary monads.  (sig: (Handler E M)\n  (: (lux/control/monad;Monad M)\n     monad)\n   (: (All [c] (-  (E c) (M c)))\n     handle))", 
            "title": "Handler"
        }, 
        {
            "location": "/lux_control_effect/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_control_effect/#doe", 
            "text": "## An alternative to the 'do' macro for monads.\n(with-handler Handler EffABC,IO \n  (doE Functor EffABC \n    [a (lift fieldA)\n     b (lift fieldB)\n     c (lift fieldC)]\n    (wrap ($_ n.+ a b c))))", 
            "title": "doE"
        }, 
        {
            "location": "/lux_control_effect/#effect", 
            "text": "## Define effects by specifying which operations and constants a handler must provide.\n(effect: #export EffA\n  (opA [Nat Text] Bool)\n  (fieldA Nat))\n\n## In this case, 'opA' will be a function (-  Nat Text Bool).\n## 'fieldA' will be a value provided by a handler.", 
            "title": "effect:"
        }, 
        {
            "location": "/lux_control_effect/#handler_1", 
            "text": "## Define effect handlers by implementing the operations and values of an effect.\n(handler: _\n  (=  EffA [IO Monad IO ])\n  (def: (opA length sample)\n    (:: Monad IO  wrap (n.  length\n                            (size sample))))\n\n  (def: fieldA (:: Monad IO  wrap +10)))\n\n## Since a name for the handler was not specified, 'handler:' will generate the name as Handler EffA,IO .", 
            "title": "handler:"
        }, 
        {
            "location": "/lux_control_effect/#lift", 
            "text": "## A way to (automatically) lift effectful fields and operations from simple effects into the larger space of composite effects.\n(with-handler Handler EffABC,IO \n  (doE Functor EffABC \n    [a (lift fieldA)\n     b (lift fieldB)\n     c (lift fieldC)]\n    (wrap ($_ n.+ a b c))))", 
            "title": "lift"
        }, 
        {
            "location": "/lux_control_effect/#e", 
            "text": "## A way to combine smaller effect into a larger effect.\n(type: EffABC (|E EffA EffB EffC))", 
            "title": "|E"
        }, 
        {
            "location": "/lux_control_effect/#f", 
            "text": "## A way to combine smaller effect functors into a larger functor.\n(def: Functor EffABC \n  (Functor EffABC)\n  (|F Functor EffA  Functor EffB  Functor EffC ))", 
            "title": "|F"
        }, 
        {
            "location": "/lux_control_effect/#h", 
            "text": "## A way to combine smaller effect handlers into a larger handler.\n(def: Handler EffABC,IO \n  (Handler EffABC lux/codata/io;IO)\n  (|H lux/codata/io;Monad IO \n      Handler EffA,IO  Handler EffB,IO  Handler EffC,IO ))", 
            "title": "|H"
        }, 
        {
            "location": "/lux_control_effect/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_control_effect/#applicativeeff-dsl", 
            "text": "(All [a] (-  (lux/control/functor;Functor a) (lux/control/applicative;Applicative (Eff a))))", 
            "title": "(Applicative&lt;Eff&gt; dsl)"
        }, 
        {
            "location": "/lux_control_effect/#functoreff-dsl", 
            "text": "(All [a] (-  (lux/control/functor;Functor a) (lux/control/functor;Functor (Eff a))))", 
            "title": "(Functor&lt;Eff&gt; dsl)"
        }, 
        {
            "location": "/lux_control_effect/#monadeff-dsl", 
            "text": "(All [a] (-  (lux/control/functor;Functor a) (lux/control/monad;Monad (Eff a))))", 
            "title": "(Monad&lt;Eff&gt; dsl)"
        }, 
        {
            "location": "/lux_control_effect/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_control_effect/#with-handler-handler-body", 
            "text": "Handles an effectful computation with the given handler to produce a monadic value.  (All [a b c] (-  (Handler a b) (Eff a c) (b c)))", 
            "title": "(with-handler handler body)"
        }, 
        {
            "location": "/lux_control_enum/", 
            "text": "lux/control/enum\n\n\nTypes\n\n\nEnum\n\n\nEnumerable types, with a notion of moving forward and backwards through a type's instances.\n\n\n(sig: (Enum e)\n  (: (lux/control/ord;Ord e)\n     ord)\n   (: (-\n e e)\n     succ)\n   (: (-\n e e)\n     pred))\n\n\n\n\nValues\n\n\n(range (^open) from to)\n\n\nAn inclusive [from, to] range of values.\n\n\n\n\n(All [a] (-\n (Enum a) a a (lux;List a)))", 
            "title": "Lux control enum"
        }, 
        {
            "location": "/lux_control_enum/#luxcontrolenum", 
            "text": "", 
            "title": "lux/control/enum"
        }, 
        {
            "location": "/lux_control_enum/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_control_enum/#enum", 
            "text": "Enumerable types, with a notion of moving forward and backwards through a type's instances.  (sig: (Enum e)\n  (: (lux/control/ord;Ord e)\n     ord)\n   (: (-  e e)\n     succ)\n   (: (-  e e)\n     pred))", 
            "title": "Enum"
        }, 
        {
            "location": "/lux_control_enum/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_control_enum/#range-open-from-to", 
            "text": "An inclusive [from, to] range of values.  (All [a] (-  (Enum a) a a (lux;List a)))", 
            "title": "(range (^open) from to)"
        }, 
        {
            "location": "/lux_control_eq/", 
            "text": "lux/control/eq\n\n\nTypes\n\n\nEq\n\n\nEquality for a type's instances.\n\n\n(sig: (Eq a)\n  (: (-\n a a lux;Bool)\n     =))\n\n\n\n\nValues\n\n\n(conj left right)\n\n\n(All [a b] (-\n (Eq a) (Eq b) (Eq [a b])))\n\n\n(disj left right)\n\n\n(All [a b] (-\n (Eq a) (Eq b) (Eq (| a b))))", 
            "title": "Lux control eq"
        }, 
        {
            "location": "/lux_control_eq/#luxcontroleq", 
            "text": "", 
            "title": "lux/control/eq"
        }, 
        {
            "location": "/lux_control_eq/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_control_eq/#eq", 
            "text": "Equality for a type's instances.  (sig: (Eq a)\n  (: (-  a a lux;Bool)\n     =))", 
            "title": "Eq"
        }, 
        {
            "location": "/lux_control_eq/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_control_eq/#conj-left-right", 
            "text": "(All [a b] (-  (Eq a) (Eq b) (Eq [a b])))", 
            "title": "(conj left right)"
        }, 
        {
            "location": "/lux_control_eq/#disj-left-right", 
            "text": "(All [a b] (-  (Eq a) (Eq b) (Eq (| a b))))", 
            "title": "(disj left right)"
        }, 
        {
            "location": "/lux_control_fold/", 
            "text": "lux/control/fold\n\n\nTypes\n\n\nFold\n\n\nIterate over a structure's values to build a summary value.\n\n\n(sig: (Fold F)\n  (: (All [b c] (-\n (-\n c b b) b (F c) b))\n     fold))", 
            "title": "Lux control fold"
        }, 
        {
            "location": "/lux_control_fold/#luxcontrolfold", 
            "text": "", 
            "title": "lux/control/fold"
        }, 
        {
            "location": "/lux_control_fold/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_control_fold/#fold", 
            "text": "Iterate over a structure's values to build a summary value.  (sig: (Fold F)\n  (: (All [b c] (-  (-  c b b) b (F c) b))\n     fold))", 
            "title": "Fold"
        }, 
        {
            "location": "/lux_control_functor/", 
            "text": "lux/control/functor\n\n\nTypes\n\n\nFunctor\n\n\n(sig: (Functor f)\n  (: (All [b c] (-\n (-\n b c) (f b) (f c)))\n     map))\n\n\n\n\nStructs\n\n\n(compF Functor\nF\n Functor\nG\n)\n\n\nFunctor composition.\n\n\n\n\n(All [a b] (-\n (Functor a) (Functor b) (Functor (All [c] (a (b c))))))", 
            "title": "Lux control functor"
        }, 
        {
            "location": "/lux_control_functor/#luxcontrolfunctor", 
            "text": "", 
            "title": "lux/control/functor"
        }, 
        {
            "location": "/lux_control_functor/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_control_functor/#functor", 
            "text": "(sig: (Functor f)\n  (: (All [b c] (-  (-  b c) (f b) (f c)))\n     map))", 
            "title": "Functor"
        }, 
        {
            "location": "/lux_control_functor/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_control_functor/#compf-functorf-functorg", 
            "text": "Functor composition.  (All [a b] (-  (Functor a) (Functor b) (Functor (All [c] (a (b c))))))", 
            "title": "(compF Functor&lt;F&gt; Functor&lt;G&gt;)"
        }, 
        {
            "location": "/lux_control_hash/", 
            "text": "lux/control/hash\n\n\nTypes\n\n\nHash\n\n\nA way to produce hash-codes for a type's instances.\n\n\nA necessity when working with some data-structures, such as dictionaries or sets.\n\n\n(sig: (Hash a)\n  (: (lux/control/eq;Eq a)\n     eq)\n   (: (-\n a lux;Nat)\n     hash))", 
            "title": "Lux control hash"
        }, 
        {
            "location": "/lux_control_hash/#luxcontrolhash", 
            "text": "", 
            "title": "lux/control/hash"
        }, 
        {
            "location": "/lux_control_hash/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_control_hash/#hash", 
            "text": "A way to produce hash-codes for a type's instances.  A necessity when working with some data-structures, such as dictionaries or sets.  (sig: (Hash a)\n  (: (lux/control/eq;Eq a)\n     eq)\n   (: (-  a lux;Nat)\n     hash))", 
            "title": "Hash"
        }, 
        {
            "location": "/lux_control_monad/", 
            "text": "lux/control/monad\n\n\nTypes\n\n\nMonad\n\n\n(sig: (Monad m)\n  (: (lux/control/applicative;Applicative m)\n     applicative)\n   (: (All [b] (-\n (m (m b)) (m b)))\n     join))\n\n\n\n\nMacros\n\n\ndo\n\n\n## Macro for easy concatenation of monadic operations.\n(do Monad\nMaybe\n\n  [y (f1 x)\n   z (f2 z)]\n  (wrap (f3 z)))\n\n\n\n\nValues\n\n\n(foldM monad f init xs)\n\n\nFold a list with a monad-producing function.\n\n\n\n\n(All [a b c] (-\n (Monad a) (-\n c b (a b)) b (lux;List c) (a b)))\n\n\n(liftM Monad\nM\n f)\n\n\nLift a normal function into the space of monads.\n\n\n\n\n(All [a b c] (-\n (Monad a) (-\n b c) (a b) (a c)))\n\n\n(mapM monad f xs)\n\n\nApply a monad-producing function to all values in a list.\n\n\n\n\n(All [a b c] (-\n (Monad a) (-\n b (a c)) (lux;List b) (a (lux;List c))))\n\n\n(seqM monad xs)\n\n\nRun all the monadic values in the list and produce a list of the base values.\n\n\n\n\n(All [a b] (-\n (Monad a) (lux;List (a b)) (a (lux;List b))))", 
            "title": "Lux control monad"
        }, 
        {
            "location": "/lux_control_monad/#luxcontrolmonad", 
            "text": "", 
            "title": "lux/control/monad"
        }, 
        {
            "location": "/lux_control_monad/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_control_monad/#monad", 
            "text": "(sig: (Monad m)\n  (: (lux/control/applicative;Applicative m)\n     applicative)\n   (: (All [b] (-  (m (m b)) (m b)))\n     join))", 
            "title": "Monad"
        }, 
        {
            "location": "/lux_control_monad/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_control_monad/#do", 
            "text": "## Macro for easy concatenation of monadic operations.\n(do Monad Maybe \n  [y (f1 x)\n   z (f2 z)]\n  (wrap (f3 z)))", 
            "title": "do"
        }, 
        {
            "location": "/lux_control_monad/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_control_monad/#foldm-monad-f-init-xs", 
            "text": "Fold a list with a monad-producing function.  (All [a b c] (-  (Monad a) (-  c b (a b)) b (lux;List c) (a b)))", 
            "title": "(foldM monad f init xs)"
        }, 
        {
            "location": "/lux_control_monad/#liftm-monadm-f", 
            "text": "Lift a normal function into the space of monads.  (All [a b c] (-  (Monad a) (-  b c) (a b) (a c)))", 
            "title": "(liftM Monad&lt;M&gt; f)"
        }, 
        {
            "location": "/lux_control_monad/#mapm-monad-f-xs", 
            "text": "Apply a monad-producing function to all values in a list.  (All [a b c] (-  (Monad a) (-  b (a c)) (lux;List b) (a (lux;List c))))", 
            "title": "(mapM monad f xs)"
        }, 
        {
            "location": "/lux_control_monad/#seqm-monad-xs", 
            "text": "Run all the monadic values in the list and produce a list of the base values.  (All [a b] (-  (Monad a) (lux;List (a b)) (a (lux;List b))))", 
            "title": "(seqM monad xs)"
        }, 
        {
            "location": "/lux_control_monoid/", 
            "text": "lux/control/monoid\n\n\nTypes\n\n\nMonoid\n\n\nA way to combine (append) values.\n\n\nIncludes an identity (unit) value which doesn't alter any other value when combined with.\n\n\n(sig: (Monoid a)\n  (: a\n     unit)\n   (: (-\n a a a)\n     append))", 
            "title": "Lux control monoid"
        }, 
        {
            "location": "/lux_control_monoid/#luxcontrolmonoid", 
            "text": "", 
            "title": "lux/control/monoid"
        }, 
        {
            "location": "/lux_control_monoid/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_control_monoid/#monoid", 
            "text": "A way to combine (append) values.  Includes an identity (unit) value which doesn't alter any other value when combined with.  (sig: (Monoid a)\n  (: a\n     unit)\n   (: (-  a a a)\n     append))", 
            "title": "Monoid"
        }, 
        {
            "location": "/lux_control_number/", 
            "text": "lux/control/number\n\n\nTypes\n\n\nNumber\n\n\nEverything that should be expected of a number type.\n\n\n(sig: (Number n)\n  (: (lux/control/ord;Ord n)\n     ord)\n   (: (-\n n n n)\n     +)\n   (: (-\n n n n)\n     -)\n   (: (-\n n n n)\n     *)\n   (: (-\n n n n)\n     /)\n   (: (-\n n n n)\n     %)\n   (: (-\n n n)\n     negate)\n   (: (-\n n n)\n     signum)\n   (: (-\n n n)\n     abs))", 
            "title": "Lux control number"
        }, 
        {
            "location": "/lux_control_number/#luxcontrolnumber", 
            "text": "", 
            "title": "lux/control/number"
        }, 
        {
            "location": "/lux_control_number/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_control_number/#number", 
            "text": "Everything that should be expected of a number type.  (sig: (Number n)\n  (: (lux/control/ord;Ord n)\n     ord)\n   (: (-  n n n)\n     +)\n   (: (-  n n n)\n     -)\n   (: (-  n n n)\n     *)\n   (: (-  n n n)\n     /)\n   (: (-  n n n)\n     %)\n   (: (-  n n)\n     negate)\n   (: (-  n n)\n     signum)\n   (: (-  n n)\n     abs))", 
            "title": "Number"
        }, 
        {
            "location": "/lux_control_ord/", 
            "text": "lux/control/ord\n\n\nTypes\n\n\nOrd\n\n\nA signature for types that possess some sense of ordering among their elements.\n\n\n(sig: (Ord a)\n  (: (lux/control/eq;Eq a)\n     eq)\n   (: (-\n a a lux;Bool)\n     \n)\n   (: (-\n a a lux;Bool)\n     \n=)\n   (: (-\n a a lux;Bool)\n     \n)\n   (: (-\n a a lux;Bool)\n     \n=))\n\n\n\n\nValues\n\n\n(max ord x y)\n\n\n(All [a] (-\n (Ord a) a a a))\n\n\n(min ord x y)\n\n\n(All [a] (-\n (Ord a) a a a))\n\n\n(ord eq \n)\n\n\n(All [a] (-\n (lux/control/eq;Eq a) (-\n a a lux;Bool) (Ord a)))", 
            "title": "Lux control ord"
        }, 
        {
            "location": "/lux_control_ord/#luxcontrolord", 
            "text": "", 
            "title": "lux/control/ord"
        }, 
        {
            "location": "/lux_control_ord/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_control_ord/#ord", 
            "text": "A signature for types that possess some sense of ordering among their elements.  (sig: (Ord a)\n  (: (lux/control/eq;Eq a)\n     eq)\n   (: (-  a a lux;Bool)\n      )\n   (: (-  a a lux;Bool)\n      =)\n   (: (-  a a lux;Bool)\n      )\n   (: (-  a a lux;Bool)\n      =))", 
            "title": "Ord"
        }, 
        {
            "location": "/lux_control_ord/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_control_ord/#max-ord-x-y", 
            "text": "(All [a] (-  (Ord a) a a a))", 
            "title": "(max ord x y)"
        }, 
        {
            "location": "/lux_control_ord/#min-ord-x-y", 
            "text": "(All [a] (-  (Ord a) a a a))", 
            "title": "(min ord x y)"
        }, 
        {
            "location": "/lux_control_ord/#ord-eq", 
            "text": "(All [a] (-  (lux/control/eq;Eq a) (-  a a lux;Bool) (Ord a)))", 
            "title": "(ord eq &lt;)"
        }, 
        {
            "location": "/lux_data_bit/", 
            "text": "lux/data/bit\n\n\nValues\n\n\n(\n param subject)\n\n\nBitwise and.\n\n\n\n\n(-\n lux;Nat lux;Nat lux;Nat)\n\n\n(\n param subject)\n\n\nBitwise shift-left.\n\n\n\n\n(-\n lux;Nat lux;Nat lux;Nat)\n\n\n(\n param subject)\n\n\nBitwise shift-right.\n\n\n\n\n(-\n lux;Nat lux;Int lux;Int)\n\n\n(\n param subject)\n\n\nBitwise unsigned-shift-right.\n\n\n\n\n(-\n lux;Nat lux;Nat lux;Nat)\n\n\n(^ param subject)\n\n\nBitwise xor.\n\n\n\n\n(-\n lux;Nat lux;Nat lux;Nat)\n\n\n(clear idx input)\n\n\nClear bit at given index.\n\n\n\n\n(-\n lux;Nat lux;Nat lux;Nat)\n\n\n(count subject)\n\n\nCount the number of 1s in a bit-map.\n\n\n\n\n(-\n lux;Nat lux;Nat)\n\n\n(flip idx input)\n\n\nFlip bit at given index.\n\n\n\n\n(-\n lux;Nat lux;Nat lux;Nat)\n\n\n(rotate-left distance input)\n\n\n(-\n lux;Nat lux;Nat lux;Nat)\n\n\n(rotate-right distance input)\n\n\n(-\n lux;Nat lux;Nat lux;Nat)\n\n\n(set idx input)\n\n\nSet bit at given index.\n\n\n\n\n(-\n lux;Nat lux;Nat lux;Nat)\n\n\n(set? idx input)\n\n\n(-\n lux;Nat lux;Nat lux;Bool)\n\n\n(| param subject)\n\n\nBitwise or.\n\n\n\n\n(-\n lux;Nat lux;Nat lux;Nat)\n\n\n~\n\n\nBitwise negation.\n\n\n\n\n(-\n lux;Nat lux;Nat)", 
            "title": "Lux data bit"
        }, 
        {
            "location": "/lux_data_bit/#luxdatabit", 
            "text": "", 
            "title": "lux/data/bit"
        }, 
        {
            "location": "/lux_data_bit/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_bit/#param-subject", 
            "text": "Bitwise and.  (-  lux;Nat lux;Nat lux;Nat)", 
            "title": "(&amp; param subject)"
        }, 
        {
            "location": "/lux_data_bit/#param-subject_1", 
            "text": "Bitwise shift-left.  (-  lux;Nat lux;Nat lux;Nat)", 
            "title": "(&lt;&lt; param subject)"
        }, 
        {
            "location": "/lux_data_bit/#param-subject_2", 
            "text": "Bitwise shift-right.  (-  lux;Nat lux;Int lux;Int)", 
            "title": "(&gt;&gt; param subject)"
        }, 
        {
            "location": "/lux_data_bit/#param-subject_3", 
            "text": "Bitwise unsigned-shift-right.  (-  lux;Nat lux;Nat lux;Nat)", 
            "title": "(&gt;&gt;&gt; param subject)"
        }, 
        {
            "location": "/lux_data_bit/#param-subject_4", 
            "text": "Bitwise xor.  (-  lux;Nat lux;Nat lux;Nat)", 
            "title": "(^ param subject)"
        }, 
        {
            "location": "/lux_data_bit/#clear-idx-input", 
            "text": "Clear bit at given index.  (-  lux;Nat lux;Nat lux;Nat)", 
            "title": "(clear idx input)"
        }, 
        {
            "location": "/lux_data_bit/#count-subject", 
            "text": "Count the number of 1s in a bit-map.  (-  lux;Nat lux;Nat)", 
            "title": "(count subject)"
        }, 
        {
            "location": "/lux_data_bit/#flip-idx-input", 
            "text": "Flip bit at given index.  (-  lux;Nat lux;Nat lux;Nat)", 
            "title": "(flip idx input)"
        }, 
        {
            "location": "/lux_data_bit/#rotate-left-distance-input", 
            "text": "(-  lux;Nat lux;Nat lux;Nat)", 
            "title": "(rotate-left distance input)"
        }, 
        {
            "location": "/lux_data_bit/#rotate-right-distance-input", 
            "text": "(-  lux;Nat lux;Nat lux;Nat)", 
            "title": "(rotate-right distance input)"
        }, 
        {
            "location": "/lux_data_bit/#set-idx-input", 
            "text": "Set bit at given index.  (-  lux;Nat lux;Nat lux;Nat)", 
            "title": "(set idx input)"
        }, 
        {
            "location": "/lux_data_bit/#set-idx-input_1", 
            "text": "(-  lux;Nat lux;Nat lux;Bool)", 
            "title": "(set? idx input)"
        }, 
        {
            "location": "/lux_data_bit/#param-subject_5", 
            "text": "Bitwise or.  (-  lux;Nat lux;Nat lux;Nat)", 
            "title": "(| param subject)"
        }, 
        {
            "location": "/lux_data_bit/#_1", 
            "text": "Bitwise negation.  (-  lux;Nat lux;Nat)", 
            "title": "~"
        }, 
        {
            "location": "/lux_data_bool/", 
            "text": "lux/data/bool\n\n\nStructs\n\n\nAnd@Monoid\nBool\n\n\n(lux/control/monoid;Monoid lux;Bool)\n\n\nCodec\nText,Bool\n\n\n(lux/control/codec;Codec lux;Text lux;Bool)\n\n\nEq\nBool\n\n\n(lux/control/eq;Eq lux;Bool)\n\n\nOr@Monoid\nBool\n\n\n(lux/control/monoid;Monoid lux;Bool)\n\n\nValues\n\n\ncomplement\n\n\nGenerates the complement of a predicate.\nThat is a predicate that returns the oposite of the original predicate.\n\n\n\n\n(All [a] (-\n (-\n a lux;Bool) a lux;Bool))", 
            "title": "Lux data bool"
        }, 
        {
            "location": "/lux_data_bool/#luxdatabool", 
            "text": "", 
            "title": "lux/data/bool"
        }, 
        {
            "location": "/lux_data_bool/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_data_bool/#andmonoidbool", 
            "text": "(lux/control/monoid;Monoid lux;Bool)", 
            "title": "And@Monoid&lt;Bool&gt;"
        }, 
        {
            "location": "/lux_data_bool/#codectextbool", 
            "text": "(lux/control/codec;Codec lux;Text lux;Bool)", 
            "title": "Codec&lt;Text,Bool&gt;"
        }, 
        {
            "location": "/lux_data_bool/#eqbool", 
            "text": "(lux/control/eq;Eq lux;Bool)", 
            "title": "Eq&lt;Bool&gt;"
        }, 
        {
            "location": "/lux_data_bool/#ormonoidbool", 
            "text": "(lux/control/monoid;Monoid lux;Bool)", 
            "title": "Or@Monoid&lt;Bool&gt;"
        }, 
        {
            "location": "/lux_data_bool/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_bool/#complement", 
            "text": "Generates the complement of a predicate.\nThat is a predicate that returns the oposite of the original predicate.  (All [a] (-  (-  a lux;Bool) a lux;Bool))", 
            "title": "complement"
        }, 
        {
            "location": "/lux_data_char/", 
            "text": "lux/data/char\n\n\nStructs\n\n\nCodec\nText,Char\n\n\n(lux/control/codec;Codec lux;Text lux;Char)\n\n\nEq\nChar\n\n\n(lux/control/eq;Eq lux;Char)\n\n\nHash\nChar\n\n\n(lux/control/hash;Hash lux;Char)\n\n\nOrd\nChar\n\n\n(lux/control/ord;Ord lux;Char)\n\n\nValues\n\n\n(as-text x)\n\n\n(-\n lux;Char lux;Text)\n\n\n(char x)\n\n\n(-\n lux;Nat lux;Char)\n\n\n(code x)\n\n\n(-\n lux;Char lux;Nat)\n\n\n(space? x)\n\n\nChecks whether the character is white-space.\n\n\n\n\n(-\n lux;Char lux;Bool)", 
            "title": "Lux data char"
        }, 
        {
            "location": "/lux_data_char/#luxdatachar", 
            "text": "", 
            "title": "lux/data/char"
        }, 
        {
            "location": "/lux_data_char/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_data_char/#codectextchar", 
            "text": "(lux/control/codec;Codec lux;Text lux;Char)", 
            "title": "Codec&lt;Text,Char&gt;"
        }, 
        {
            "location": "/lux_data_char/#eqchar", 
            "text": "(lux/control/eq;Eq lux;Char)", 
            "title": "Eq&lt;Char&gt;"
        }, 
        {
            "location": "/lux_data_char/#hashchar", 
            "text": "(lux/control/hash;Hash lux;Char)", 
            "title": "Hash&lt;Char&gt;"
        }, 
        {
            "location": "/lux_data_char/#ordchar", 
            "text": "(lux/control/ord;Ord lux;Char)", 
            "title": "Ord&lt;Char&gt;"
        }, 
        {
            "location": "/lux_data_char/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_char/#as-text-x", 
            "text": "(-  lux;Char lux;Text)", 
            "title": "(as-text x)"
        }, 
        {
            "location": "/lux_data_char/#char-x", 
            "text": "(-  lux;Nat lux;Char)", 
            "title": "(char x)"
        }, 
        {
            "location": "/lux_data_char/#code-x", 
            "text": "(-  lux;Char lux;Nat)", 
            "title": "(code x)"
        }, 
        {
            "location": "/lux_data_char/#space-x", 
            "text": "Checks whether the character is white-space.  (-  lux;Char lux;Bool)", 
            "title": "(space? x)"
        }, 
        {
            "location": "/lux_data_error/", 
            "text": "lux/data/error\n\n\nTypes\n\n\nError\n\n\n(type: (Error a)\n  (#Error lux;Text)\n  (#Success a))\n\n\n\n\nStructs\n\n\nApplicative\nError\n\n\n(lux/control/applicative;Applicative Error)\n\n\n(ErrorT Monad\nM\n)\n\n\n(All [a] (-\n (lux/control/monad;Monad a) (lux/control/monad;Monad (All [b] (a (Error b))))))\n\n\nFunctor\nError\n\n\n(lux/control/functor;Functor Error)\n\n\nMonad\nError\n\n\n(lux/control/monad;Monad Error)\n\n\nValues\n\n\n(fail message)\n\n\n(All [a] (-\n lux;Text (Error a)))\n\n\n(lift-error Monad\nM\n)\n\n\n(All [a b] (-\n (lux/control/monad;Monad a) (a b) (a (Error b))))", 
            "title": "Lux data error"
        }, 
        {
            "location": "/lux_data_error/#luxdataerror", 
            "text": "", 
            "title": "lux/data/error"
        }, 
        {
            "location": "/lux_data_error/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_data_error/#error", 
            "text": "(type: (Error a)\n  (#Error lux;Text)\n  (#Success a))", 
            "title": "Error"
        }, 
        {
            "location": "/lux_data_error/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_data_error/#applicativeerror", 
            "text": "(lux/control/applicative;Applicative Error)", 
            "title": "Applicative&lt;Error&gt;"
        }, 
        {
            "location": "/lux_data_error/#errort-monadm", 
            "text": "(All [a] (-  (lux/control/monad;Monad a) (lux/control/monad;Monad (All [b] (a (Error b))))))", 
            "title": "(ErrorT Monad&lt;M&gt;)"
        }, 
        {
            "location": "/lux_data_error/#functorerror", 
            "text": "(lux/control/functor;Functor Error)", 
            "title": "Functor&lt;Error&gt;"
        }, 
        {
            "location": "/lux_data_error/#monaderror", 
            "text": "(lux/control/monad;Monad Error)", 
            "title": "Monad&lt;Error&gt;"
        }, 
        {
            "location": "/lux_data_error/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_error/#fail-message", 
            "text": "(All [a] (-  lux;Text (Error a)))", 
            "title": "(fail message)"
        }, 
        {
            "location": "/lux_data_error/#lift-error-monadm", 
            "text": "(All [a b] (-  (lux/control/monad;Monad a) (a b) (a (Error b))))", 
            "title": "(lift-error Monad&lt;M&gt;)"
        }, 
        {
            "location": "/lux_data_error_exception/", 
            "text": "lux/data/error/exception\n\n\n\n\nException-handling functionality built on top of the Error type.\n\n\n\n\nTypes\n\n\nException\n\n\nAn exception provides a way to decorate error messages.\n\n\n(type: Exception\n  (-\n lux;Text lux;Text))\n\n\n\n\nMacros\n\n\nexception:\n\n\n## Define a new exception type.\n## It moslty just serves as a way to tag error messages for later catching.\n(exception: #export Some-Exception)\n\n\n\n\nValues\n\n\n(catch exception then try)\n\n\nIf a particular exception is detected on a possibly-erroneous value, handle it.\n\nIf no exception was detected, or a different one from the one being checked, then pass along the original value.\n\n\n\n\n(All [a] (-\n Exception (-\n lux;Text a) (lux/data/error;Error a) (lux/data/error;Error a)))\n\n\n(otherwise to-do try)\n\n\nIf no handler could be found to catch the exception, then run a function as a last-resort measure.\n\n\n\n\n(All [a] (-\n (-\n lux;Text a) (lux/data/error;Error a) a))\n\n\n(return value)\n\n\nA way to lift normal values into the error-handling context.\n\n\n\n\n(All [a] (-\n a (lux/data/error;Error a)))\n\n\n(throw exception message)\n\n\nDecorate an error message with an Exception and lift it into the error-handling context.\n\n\n\n\n(All [a] (-\n Exception lux;Text (lux/data/error;Error a)))", 
            "title": "Lux data error exception"
        }, 
        {
            "location": "/lux_data_error_exception/#luxdataerrorexception", 
            "text": "Exception-handling functionality built on top of the Error type.", 
            "title": "lux/data/error/exception"
        }, 
        {
            "location": "/lux_data_error_exception/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_data_error_exception/#exception", 
            "text": "An exception provides a way to decorate error messages.  (type: Exception\n  (-  lux;Text lux;Text))", 
            "title": "Exception"
        }, 
        {
            "location": "/lux_data_error_exception/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_data_error_exception/#exception_1", 
            "text": "## Define a new exception type.\n## It moslty just serves as a way to tag error messages for later catching.\n(exception: #export Some-Exception)", 
            "title": "exception:"
        }, 
        {
            "location": "/lux_data_error_exception/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_error_exception/#catch-exception-then-try", 
            "text": "If a particular exception is detected on a possibly-erroneous value, handle it.\n\nIf no exception was detected, or a different one from the one being checked, then pass along the original value.  (All [a] (-  Exception (-  lux;Text a) (lux/data/error;Error a) (lux/data/error;Error a)))", 
            "title": "(catch exception then try)"
        }, 
        {
            "location": "/lux_data_error_exception/#otherwise-to-do-try", 
            "text": "If no handler could be found to catch the exception, then run a function as a last-resort measure.  (All [a] (-  (-  lux;Text a) (lux/data/error;Error a) a))", 
            "title": "(otherwise to-do try)"
        }, 
        {
            "location": "/lux_data_error_exception/#return-value", 
            "text": "A way to lift normal values into the error-handling context.  (All [a] (-  a (lux/data/error;Error a)))", 
            "title": "(return value)"
        }, 
        {
            "location": "/lux_data_error_exception/#throw-exception-message", 
            "text": "Decorate an error message with an Exception and lift it into the error-handling context.  (All [a] (-  Exception lux;Text (lux/data/error;Error a)))", 
            "title": "(throw exception message)"
        }, 
        {
            "location": "/lux_data_format_json/", 
            "text": "lux/data/format/json\n\n\n\n\nFunctionality for reading, generating and processing values in the JSON format.\n\n\nFor more information, please see: http://www.json.org/\n\n\n\n\nTypes\n\n\nArray\n\n\n(type: Array\n  (lux/data/struct/vector;Vector JSON))\n\n\n\n\nBoolean\n\n\n(type: Boolean\n  lux;Bool)\n\n\n\n\nGen\n\n\nJSON generators.\n\n\n(type: (Gen a)\n  (-\n a JSON))\n\n\n\n\nJSON\n\n\n(type: #rec JSON\n  (#Null Null)\n  (#Boolean Boolean)\n  (#Number Number)\n  (#String String)\n  (#Array (lux/data/struct/vector;Vector JSON))\n  (#Object (lux/data/struct/dict;Dict String JSON)))\n\n\n\n\nNull\n\n\n(type: Null\n  lux;Unit)\n\n\n\n\nNumber\n\n\n(type: Number\n  lux;Real)\n\n\n\n\nObject\n\n\n(type: Object\n  (lux/data/struct/dict;Dict String JSON))\n\n\n\n\nParser\n\n\nJSON parsers.\n\n\n(type: (Parser a)\n  (-\n JSON (lux/data/error;Error a)))\n\n\n\n\nString\n\n\n(type: String\n  lux;Text)\n\n\n\n\nMacros\n\n\nCodec\nJSON,?\n\n\n## A macro for automatically producing JSON codecs.\n(type: Variant\n  (#Case0 Bool)\n  (#Case1 Int)\n  (#Case2 Real))\n\n(type: Record\n  {#unit Unit\n   #bool Bool\n   #int Int\n   #real Real\n   #char Char\n   #text Text\n   #maybe (Maybe Int)\n   #list (List Int)\n   #variant Variant\n   #tuple [Int Real Char]})\n\n(derived: (Codec\nJSON,?\n Record))\n\n\n\n\njson\n\n\n## A way to produce JSON literals.\n(json true)\n\n(json 123)\n\n(json 456.78)\n\n(json \nSome text\n)\n\n(json #null)\n\n(json [\nthis\n \nis\n \nan\n \narray\n])\n\n(json {\nthis\n \nis\n\n       \nan\n \nobject\n})\n\n\n\n\nshape\n\n\n## Builds a parser that ensures the (inclusive) shape of an array or object.\n(shape [bool! int! real!])\n\n(shape {\nisAlive\n bool!\n        \nage\n int!\n        \nincome\n real!})\n\n\n\n\nshape!\n\n\n## Builds a parser that ensures the (exclusive) shape of an array or object.\n(shape! [bool! int! real!])\n\n(shape! {\nisAlive\n bool!\n         \nage\n int!\n         \nincome\n real!})\n\n\n\n\nStructs\n\n\nApplicative\nParser\n\n\n(lux/control/applicative;Applicative Parser)\n\n\nCodec\nText,JSON\n\n\n(lux/control/codec;Codec lux;Text JSON)\n\n\nEq\nJSON\n\n\n(lux/control/eq;Eq JSON)\n\n\nFunctor\nParser\n\n\n(lux/control/functor;Functor Parser)\n\n\nMonad\nParser\n\n\n(lux/control/monad;Monad Parser)\n\n\nValues\n\n\n(alt pa pb json)\n\n\nHeterogeneous alternative combinator.\n\n\n\n\n(All [a b] (-\n (Parser a) (Parser b) (Parser (| a b))))\n\n\nany\n\n\nJust returns the JSON input without applying any logic.\n\n\n\n\n(Parser JSON)\n\n\n(array parser)\n\n\nParses a JSON array, assuming that every element can be parsed the same way.\n\n\n\n\n(All [a] (-\n (Parser a) (Parser (lux;List a))))\n\n\n(array-size! size json)\n\n\nEnsures a JSON array has the specified size.\n\n\n\n\n(-\n lux;Nat (Parser lux;Unit))\n\n\n(at idx parser)\n\n\nParses an element inside a JSON array.\n\n\n\n\n(All [a] (-\n lux;Nat (Parser a) (Parser a)))\n\n\n(bool json)\n\n\nReads a JSON value as bool.\n\n\n\n\n(Parser lux;Bool)\n\n\n(bool! test json)\n\n\nEnsures a JSON value is a boolean.\n\n\n\n\n(-\n lux;Bool (Parser lux;Unit))\n\n\n(bool? test json)\n\n\nAsks whether a JSON value is a boolean.\n\n\n\n\n(-\n lux;Bool (Parser lux;Bool))\n\n\n(char json)\n\n\nReads a JSON value as a single-character string.\n\n\n\n\n(Parser lux;Char)\n\n\n(char! test json)\n\n\nEnsures a JSON value is a single-character string with the specified character.\n\n\n\n\n(-\n lux;Char (Parser lux;Unit))\n\n\n(char? test json)\n\n\nAsks whether a JSON value is a single-character string with the specified character.\n\n\n\n\n(-\n lux;Char (Parser lux;Bool))\n\n\n(either pl pr json)\n\n\nHomogeneous alternative combinator.\n\n\n\n\n(All [a] (-\n (Parser a) (Parser a) (Parser a)))\n\n\n(ensure test parser json)\n\n\nOnly parses a JSON if it passes a test (which is also a parser).\n\n\n\n\n(All [a] (-\n (Parser lux;Unit) (Parser a) (Parser a)))\n\n\n(field field-name parser)\n\n\nParses a field inside a JSON object.\n\n\n\n\n(All [a] (-\n lux;Text (Parser a) (Parser a)))\n\n\n(fields json)\n\n\nGet all the fields in a JSON object.\n\n\n\n\n(-\n JSON (lux/data/error;Error (lux;List String)))\n\n\n(gen-array value)\n\n\nA JSON generator for arrays.\n\n\n\n\n(Gen Array)\n\n\n(gen-boolean value)\n\n\nA JSON generator for booleans.\n\n\n\n\n(Gen Boolean)\n\n\n(gen-nullable gen)\n\n\nBuilds a JSON generator for potentially inexistent values.\n\n\n\n\n(All [a] (-\n (Gen a) (Gen (lux;Maybe a))))\n\n\n(gen-number value)\n\n\nA JSON generator for numbers.\n\n\n\n\n(Gen Number)\n\n\n(gen-object value)\n\n\nA JSON generator for objects.\n\n\n\n\n(Gen Object)\n\n\n(gen-string value)\n\n\nA JSON generator for strings.\n\n\n\n\n(Gen String)\n\n\n(get key json)\n\n\nA JSON object field getter.\n\n\n\n\n(-\n String JSON (lux/data/error;Error JSON))\n\n\n(get-array key json)\n\n\nA JSON object field getter for arrays.\n\n\n\n\n(-\n lux;Text JSON (lux/data/error;Error Array))\n\n\n(get-boolean key json)\n\n\nA JSON object field getter for booleans.\n\n\n\n\n(-\n lux;Text JSON (lux/data/error;Error Boolean))\n\n\n(get-number key json)\n\n\nA JSON object field getter for numbers.\n\n\n\n\n(-\n lux;Text JSON (lux/data/error;Error Number))\n\n\n(get-object key json)\n\n\nA JSON object field getter for objects.\n\n\n\n\n(-\n lux;Text JSON (lux/data/error;Error Object))\n\n\n(get-string key json)\n\n\nA JSON object field getter for strings.\n\n\n\n\n(-\n lux;Text JSON (lux/data/error;Error String))\n\n\n(int json)\n\n\nReads a JSON value as int.\n\n\n\n\n(Parser lux;Int)\n\n\n(int! test json)\n\n\nEnsures a JSON value is a number.\n\n\n\n\n(-\n lux;Int (Parser lux;Unit))\n\n\n(int? test json)\n\n\nAsks whether a JSON value is a number.\n\n\n\n\n(-\n lux;Int (Parser lux;Bool))\n\n\nnull\n\n\nThe null JSON value.\n\n\n\n\nJSON\n\n\n(nullable parser)\n\n\nA parser that can handle the presence of null values.\n\n\n\n\n(All [a] (-\n (Parser a) (Parser (lux;Maybe a))))\n\n\n(object parser)\n\n\nParses a JSON object, assuming that every field's value can be parsed the same way.\n\n\n\n\n(All [a] (-\n (Parser a) (Parser (lux/data/struct/dict;Dict String a))))\n\n\n(object-fields! wanted-fields json)\n\n\nEnsures that every field in the list of wanted-fields is present in a JSON object.\n\n\n\n\n(-\n (lux;List String) (Parser lux;Unit))\n\n\n(opt p json)\n\n\nOptionality combinator.\n\n\n\n\n(All [a] (-\n (Parser a) (Parser (lux;Maybe a))))\n\n\n(real json)\n\n\nReads a JSON value as real.\n\n\n\n\n(Parser lux;Real)\n\n\n(real! test json)\n\n\nEnsures a JSON value is a number.\n\n\n\n\n(-\n lux;Real (Parser lux;Unit))\n\n\n(real? test json)\n\n\nAsks whether a JSON value is a number.\n\n\n\n\n(-\n lux;Real (Parser lux;Bool))\n\n\n(run parser json)\n\n\n(All [a] (-\n (Parser a) JSON (lux/data/error;Error a)))\n\n\n(seq pa pb)\n\n\nSequencing combinator.\n\n\n\n\n(All [a b] (-\n (Parser a) (Parser b) (Parser [a b])))\n\n\n(set key value json)\n\n\nA JSON object field setter.\n\n\n\n\n(-\n String JSON JSON (lux/data/error;Error JSON))\n\n\n(text json)\n\n\nReads a JSON value as text.\n\n\n\n\n(Parser lux;Text)\n\n\n(text! test json)\n\n\nEnsures a JSON value is a string.\n\n\n\n\n(-\n lux;Text (Parser lux;Unit))\n\n\n(text? test json)\n\n\nAsks whether a JSON value is a string.\n\n\n\n\n(-\n lux;Text (Parser lux;Bool))\n\n\n(unit json)\n\n\nReads a JSON value as unit.\n\n\n\n\n(Parser lux;Unit)", 
            "title": "Lux data format json"
        }, 
        {
            "location": "/lux_data_format_json/#luxdataformatjson", 
            "text": "Functionality for reading, generating and processing values in the JSON format.  For more information, please see: http://www.json.org/", 
            "title": "lux/data/format/json"
        }, 
        {
            "location": "/lux_data_format_json/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_data_format_json/#array", 
            "text": "(type: Array\n  (lux/data/struct/vector;Vector JSON))", 
            "title": "Array"
        }, 
        {
            "location": "/lux_data_format_json/#boolean", 
            "text": "(type: Boolean\n  lux;Bool)", 
            "title": "Boolean"
        }, 
        {
            "location": "/lux_data_format_json/#gen", 
            "text": "JSON generators.  (type: (Gen a)\n  (-  a JSON))", 
            "title": "Gen"
        }, 
        {
            "location": "/lux_data_format_json/#json", 
            "text": "(type: #rec JSON\n  (#Null Null)\n  (#Boolean Boolean)\n  (#Number Number)\n  (#String String)\n  (#Array (lux/data/struct/vector;Vector JSON))\n  (#Object (lux/data/struct/dict;Dict String JSON)))", 
            "title": "JSON"
        }, 
        {
            "location": "/lux_data_format_json/#null", 
            "text": "(type: Null\n  lux;Unit)", 
            "title": "Null"
        }, 
        {
            "location": "/lux_data_format_json/#number", 
            "text": "(type: Number\n  lux;Real)", 
            "title": "Number"
        }, 
        {
            "location": "/lux_data_format_json/#object", 
            "text": "(type: Object\n  (lux/data/struct/dict;Dict String JSON))", 
            "title": "Object"
        }, 
        {
            "location": "/lux_data_format_json/#parser", 
            "text": "JSON parsers.  (type: (Parser a)\n  (-  JSON (lux/data/error;Error a)))", 
            "title": "Parser"
        }, 
        {
            "location": "/lux_data_format_json/#string", 
            "text": "(type: String\n  lux;Text)", 
            "title": "String"
        }, 
        {
            "location": "/lux_data_format_json/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_data_format_json/#codecjson", 
            "text": "## A macro for automatically producing JSON codecs.\n(type: Variant\n  (#Case0 Bool)\n  (#Case1 Int)\n  (#Case2 Real))\n\n(type: Record\n  {#unit Unit\n   #bool Bool\n   #int Int\n   #real Real\n   #char Char\n   #text Text\n   #maybe (Maybe Int)\n   #list (List Int)\n   #variant Variant\n   #tuple [Int Real Char]})\n\n(derived: (Codec JSON,?  Record))", 
            "title": "Codec&lt;JSON,?&gt;"
        }, 
        {
            "location": "/lux_data_format_json/#json_1", 
            "text": "## A way to produce JSON literals.\n(json true)\n\n(json 123)\n\n(json 456.78)\n\n(json  Some text )\n\n(json #null)\n\n(json [ this   is   an   array ])\n\n(json { this   is \n        an   object })", 
            "title": "json"
        }, 
        {
            "location": "/lux_data_format_json/#shape", 
            "text": "## Builds a parser that ensures the (inclusive) shape of an array or object.\n(shape [bool! int! real!])\n\n(shape { isAlive  bool!\n         age  int!\n         income  real!})", 
            "title": "shape"
        }, 
        {
            "location": "/lux_data_format_json/#shape_1", 
            "text": "## Builds a parser that ensures the (exclusive) shape of an array or object.\n(shape! [bool! int! real!])\n\n(shape! { isAlive  bool!\n          age  int!\n          income  real!})", 
            "title": "shape!"
        }, 
        {
            "location": "/lux_data_format_json/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_data_format_json/#applicativeparser", 
            "text": "(lux/control/applicative;Applicative Parser)", 
            "title": "Applicative&lt;Parser&gt;"
        }, 
        {
            "location": "/lux_data_format_json/#codectextjson", 
            "text": "(lux/control/codec;Codec lux;Text JSON)", 
            "title": "Codec&lt;Text,JSON&gt;"
        }, 
        {
            "location": "/lux_data_format_json/#eqjson", 
            "text": "(lux/control/eq;Eq JSON)", 
            "title": "Eq&lt;JSON&gt;"
        }, 
        {
            "location": "/lux_data_format_json/#functorparser", 
            "text": "(lux/control/functor;Functor Parser)", 
            "title": "Functor&lt;Parser&gt;"
        }, 
        {
            "location": "/lux_data_format_json/#monadparser", 
            "text": "(lux/control/monad;Monad Parser)", 
            "title": "Monad&lt;Parser&gt;"
        }, 
        {
            "location": "/lux_data_format_json/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_format_json/#alt-pa-pb-json", 
            "text": "Heterogeneous alternative combinator.  (All [a b] (-  (Parser a) (Parser b) (Parser (| a b))))", 
            "title": "(alt pa pb json)"
        }, 
        {
            "location": "/lux_data_format_json/#any", 
            "text": "Just returns the JSON input without applying any logic.  (Parser JSON)", 
            "title": "any"
        }, 
        {
            "location": "/lux_data_format_json/#array-parser", 
            "text": "Parses a JSON array, assuming that every element can be parsed the same way.  (All [a] (-  (Parser a) (Parser (lux;List a))))", 
            "title": "(array parser)"
        }, 
        {
            "location": "/lux_data_format_json/#array-size-size-json", 
            "text": "Ensures a JSON array has the specified size.  (-  lux;Nat (Parser lux;Unit))", 
            "title": "(array-size! size json)"
        }, 
        {
            "location": "/lux_data_format_json/#at-idx-parser", 
            "text": "Parses an element inside a JSON array.  (All [a] (-  lux;Nat (Parser a) (Parser a)))", 
            "title": "(at idx parser)"
        }, 
        {
            "location": "/lux_data_format_json/#bool-json", 
            "text": "Reads a JSON value as bool.  (Parser lux;Bool)", 
            "title": "(bool json)"
        }, 
        {
            "location": "/lux_data_format_json/#bool-test-json", 
            "text": "Ensures a JSON value is a boolean.  (-  lux;Bool (Parser lux;Unit))", 
            "title": "(bool! test json)"
        }, 
        {
            "location": "/lux_data_format_json/#bool-test-json_1", 
            "text": "Asks whether a JSON value is a boolean.  (-  lux;Bool (Parser lux;Bool))", 
            "title": "(bool? test json)"
        }, 
        {
            "location": "/lux_data_format_json/#char-json", 
            "text": "Reads a JSON value as a single-character string.  (Parser lux;Char)", 
            "title": "(char json)"
        }, 
        {
            "location": "/lux_data_format_json/#char-test-json", 
            "text": "Ensures a JSON value is a single-character string with the specified character.  (-  lux;Char (Parser lux;Unit))", 
            "title": "(char! test json)"
        }, 
        {
            "location": "/lux_data_format_json/#char-test-json_1", 
            "text": "Asks whether a JSON value is a single-character string with the specified character.  (-  lux;Char (Parser lux;Bool))", 
            "title": "(char? test json)"
        }, 
        {
            "location": "/lux_data_format_json/#either-pl-pr-json", 
            "text": "Homogeneous alternative combinator.  (All [a] (-  (Parser a) (Parser a) (Parser a)))", 
            "title": "(either pl pr json)"
        }, 
        {
            "location": "/lux_data_format_json/#ensure-test-parser-json", 
            "text": "Only parses a JSON if it passes a test (which is also a parser).  (All [a] (-  (Parser lux;Unit) (Parser a) (Parser a)))", 
            "title": "(ensure test parser json)"
        }, 
        {
            "location": "/lux_data_format_json/#field-field-name-parser", 
            "text": "Parses a field inside a JSON object.  (All [a] (-  lux;Text (Parser a) (Parser a)))", 
            "title": "(field field-name parser)"
        }, 
        {
            "location": "/lux_data_format_json/#fields-json", 
            "text": "Get all the fields in a JSON object.  (-  JSON (lux/data/error;Error (lux;List String)))", 
            "title": "(fields json)"
        }, 
        {
            "location": "/lux_data_format_json/#gen-array-value", 
            "text": "A JSON generator for arrays.  (Gen Array)", 
            "title": "(gen-array value)"
        }, 
        {
            "location": "/lux_data_format_json/#gen-boolean-value", 
            "text": "A JSON generator for booleans.  (Gen Boolean)", 
            "title": "(gen-boolean value)"
        }, 
        {
            "location": "/lux_data_format_json/#gen-nullable-gen", 
            "text": "Builds a JSON generator for potentially inexistent values.  (All [a] (-  (Gen a) (Gen (lux;Maybe a))))", 
            "title": "(gen-nullable gen)"
        }, 
        {
            "location": "/lux_data_format_json/#gen-number-value", 
            "text": "A JSON generator for numbers.  (Gen Number)", 
            "title": "(gen-number value)"
        }, 
        {
            "location": "/lux_data_format_json/#gen-object-value", 
            "text": "A JSON generator for objects.  (Gen Object)", 
            "title": "(gen-object value)"
        }, 
        {
            "location": "/lux_data_format_json/#gen-string-value", 
            "text": "A JSON generator for strings.  (Gen String)", 
            "title": "(gen-string value)"
        }, 
        {
            "location": "/lux_data_format_json/#get-key-json", 
            "text": "A JSON object field getter.  (-  String JSON (lux/data/error;Error JSON))", 
            "title": "(get key json)"
        }, 
        {
            "location": "/lux_data_format_json/#get-array-key-json", 
            "text": "A JSON object field getter for arrays.  (-  lux;Text JSON (lux/data/error;Error Array))", 
            "title": "(get-array key json)"
        }, 
        {
            "location": "/lux_data_format_json/#get-boolean-key-json", 
            "text": "A JSON object field getter for booleans.  (-  lux;Text JSON (lux/data/error;Error Boolean))", 
            "title": "(get-boolean key json)"
        }, 
        {
            "location": "/lux_data_format_json/#get-number-key-json", 
            "text": "A JSON object field getter for numbers.  (-  lux;Text JSON (lux/data/error;Error Number))", 
            "title": "(get-number key json)"
        }, 
        {
            "location": "/lux_data_format_json/#get-object-key-json", 
            "text": "A JSON object field getter for objects.  (-  lux;Text JSON (lux/data/error;Error Object))", 
            "title": "(get-object key json)"
        }, 
        {
            "location": "/lux_data_format_json/#get-string-key-json", 
            "text": "A JSON object field getter for strings.  (-  lux;Text JSON (lux/data/error;Error String))", 
            "title": "(get-string key json)"
        }, 
        {
            "location": "/lux_data_format_json/#int-json", 
            "text": "Reads a JSON value as int.  (Parser lux;Int)", 
            "title": "(int json)"
        }, 
        {
            "location": "/lux_data_format_json/#int-test-json", 
            "text": "Ensures a JSON value is a number.  (-  lux;Int (Parser lux;Unit))", 
            "title": "(int! test json)"
        }, 
        {
            "location": "/lux_data_format_json/#int-test-json_1", 
            "text": "Asks whether a JSON value is a number.  (-  lux;Int (Parser lux;Bool))", 
            "title": "(int? test json)"
        }, 
        {
            "location": "/lux_data_format_json/#null_1", 
            "text": "The null JSON value.  JSON", 
            "title": "null"
        }, 
        {
            "location": "/lux_data_format_json/#nullable-parser", 
            "text": "A parser that can handle the presence of null values.  (All [a] (-  (Parser a) (Parser (lux;Maybe a))))", 
            "title": "(nullable parser)"
        }, 
        {
            "location": "/lux_data_format_json/#object-parser", 
            "text": "Parses a JSON object, assuming that every field's value can be parsed the same way.  (All [a] (-  (Parser a) (Parser (lux/data/struct/dict;Dict String a))))", 
            "title": "(object parser)"
        }, 
        {
            "location": "/lux_data_format_json/#object-fields-wanted-fields-json", 
            "text": "Ensures that every field in the list of wanted-fields is present in a JSON object.  (-  (lux;List String) (Parser lux;Unit))", 
            "title": "(object-fields! wanted-fields json)"
        }, 
        {
            "location": "/lux_data_format_json/#opt-p-json", 
            "text": "Optionality combinator.  (All [a] (-  (Parser a) (Parser (lux;Maybe a))))", 
            "title": "(opt p json)"
        }, 
        {
            "location": "/lux_data_format_json/#real-json", 
            "text": "Reads a JSON value as real.  (Parser lux;Real)", 
            "title": "(real json)"
        }, 
        {
            "location": "/lux_data_format_json/#real-test-json", 
            "text": "Ensures a JSON value is a number.  (-  lux;Real (Parser lux;Unit))", 
            "title": "(real! test json)"
        }, 
        {
            "location": "/lux_data_format_json/#real-test-json_1", 
            "text": "Asks whether a JSON value is a number.  (-  lux;Real (Parser lux;Bool))", 
            "title": "(real? test json)"
        }, 
        {
            "location": "/lux_data_format_json/#run-parser-json", 
            "text": "(All [a] (-  (Parser a) JSON (lux/data/error;Error a)))", 
            "title": "(run parser json)"
        }, 
        {
            "location": "/lux_data_format_json/#seq-pa-pb", 
            "text": "Sequencing combinator.  (All [a b] (-  (Parser a) (Parser b) (Parser [a b])))", 
            "title": "(seq pa pb)"
        }, 
        {
            "location": "/lux_data_format_json/#set-key-value-json", 
            "text": "A JSON object field setter.  (-  String JSON JSON (lux/data/error;Error JSON))", 
            "title": "(set key value json)"
        }, 
        {
            "location": "/lux_data_format_json/#text-json", 
            "text": "Reads a JSON value as text.  (Parser lux;Text)", 
            "title": "(text json)"
        }, 
        {
            "location": "/lux_data_format_json/#text-test-json", 
            "text": "Ensures a JSON value is a string.  (-  lux;Text (Parser lux;Unit))", 
            "title": "(text! test json)"
        }, 
        {
            "location": "/lux_data_format_json/#text-test-json_1", 
            "text": "Asks whether a JSON value is a string.  (-  lux;Text (Parser lux;Bool))", 
            "title": "(text? test json)"
        }, 
        {
            "location": "/lux_data_format_json/#unit-json", 
            "text": "Reads a JSON value as unit.  (Parser lux;Unit)", 
            "title": "(unit json)"
        }, 
        {
            "location": "/lux_data_ident/", 
            "text": "lux/data/ident\n\n\nStructs\n\n\nCodec\nText,Ident\n\n\n(lux/control/codec;Codec lux;Text lux;Ident)\n\n\nEq\nIdent\n\n\n(lux/control/eq;Eq lux;Ident)\n\n\nHash\nIdent\n\n\n(lux/control/hash;Hash lux;Ident)\n\n\nValues\n\n\n(module [module name])\n\n\n(-\n lux;Ident lux;Text)\n\n\n(name [module name])\n\n\n(-\n lux;Ident lux;Text)", 
            "title": "Lux data ident"
        }, 
        {
            "location": "/lux_data_ident/#luxdataident", 
            "text": "", 
            "title": "lux/data/ident"
        }, 
        {
            "location": "/lux_data_ident/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_data_ident/#codectextident", 
            "text": "(lux/control/codec;Codec lux;Text lux;Ident)", 
            "title": "Codec&lt;Text,Ident&gt;"
        }, 
        {
            "location": "/lux_data_ident/#eqident", 
            "text": "(lux/control/eq;Eq lux;Ident)", 
            "title": "Eq&lt;Ident&gt;"
        }, 
        {
            "location": "/lux_data_ident/#hashident", 
            "text": "(lux/control/hash;Hash lux;Ident)", 
            "title": "Hash&lt;Ident&gt;"
        }, 
        {
            "location": "/lux_data_ident/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_ident/#module-module-name", 
            "text": "(-  lux;Ident lux;Text)", 
            "title": "(module [module name])"
        }, 
        {
            "location": "/lux_data_ident/#name-module-name", 
            "text": "(-  lux;Ident lux;Text)", 
            "title": "(name [module name])"
        }, 
        {
            "location": "/lux_data_identity/", 
            "text": "lux/data/identity\n\n\nTypes\n\n\nIdentity\n\n\n(type: (Identity a)\n  a)\n\n\n\n\nStructs\n\n\nApplicative\nIdentity\n\n\n(lux/control/applicative;Applicative Identity)\n\n\nCoMonad\nIdentity\n\n\n(lux/control/comonad;CoMonad Identity)\n\n\nFunctor\nIdentity\n\n\n(lux/control/functor;Functor Identity)\n\n\nMonad\nIdentity\n\n\n(lux/control/monad;Monad Identity)", 
            "title": "Lux data identity"
        }, 
        {
            "location": "/lux_data_identity/#luxdataidentity", 
            "text": "", 
            "title": "lux/data/identity"
        }, 
        {
            "location": "/lux_data_identity/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_data_identity/#identity", 
            "text": "(type: (Identity a)\n  a)", 
            "title": "Identity"
        }, 
        {
            "location": "/lux_data_identity/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_data_identity/#applicativeidentity", 
            "text": "(lux/control/applicative;Applicative Identity)", 
            "title": "Applicative&lt;Identity&gt;"
        }, 
        {
            "location": "/lux_data_identity/#comonadidentity", 
            "text": "(lux/control/comonad;CoMonad Identity)", 
            "title": "CoMonad&lt;Identity&gt;"
        }, 
        {
            "location": "/lux_data_identity/#functoridentity", 
            "text": "(lux/control/functor;Functor Identity)", 
            "title": "Functor&lt;Identity&gt;"
        }, 
        {
            "location": "/lux_data_identity/#monadidentity", 
            "text": "(lux/control/monad;Monad Identity)", 
            "title": "Monad&lt;Identity&gt;"
        }, 
        {
            "location": "/lux_data_log/", 
            "text": "lux/data/log\n\n\nTypes\n\n\nLog\n\n\nRepresents a value with an associated 'log' value to record arbitrary information.\n\n\n(type: (Log l a)\n  {#log l\n   #value a})\n\n\n\n\nStructs\n\n\n(Applicative\nLog\n mon)\n\n\n(All [a] (-\n (lux/control/monoid;Monoid a) (lux/control/applicative;Applicative (Log a))))\n\n\nFunctor\nLog\n\n\n(All [a] (lux/control/functor;Functor (Log a)))\n\n\n(LogT Monoid\nl\n Monad\nM\n)\n\n\n(All [a b] (-\n (lux/control/monoid;Monoid a) (lux/control/monad;Monad b) (lux/control/monad;Monad (All [c] (b (Log a c))))))\n\n\n(Monad\nLog\n mon)\n\n\n(All [a] (-\n (lux/control/monoid;Monoid a) (lux/control/monad;Monad (Log a))))\n\n\nValues\n\n\n(lift-log Monoid\nl\n Monad\nM\n)\n\n\n(All [a b c] (-\n (lux/control/monoid;Monoid a) (lux/control/monad;Monad b) (b c) (b (Log a c))))\n\n\n(log l)\n\n\nSet the log to a particular value.\n\n\n\n\n(All [a] (-\n a (Log a lux;Unit)))", 
            "title": "Lux data log"
        }, 
        {
            "location": "/lux_data_log/#luxdatalog", 
            "text": "", 
            "title": "lux/data/log"
        }, 
        {
            "location": "/lux_data_log/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_data_log/#log", 
            "text": "Represents a value with an associated 'log' value to record arbitrary information.  (type: (Log l a)\n  {#log l\n   #value a})", 
            "title": "Log"
        }, 
        {
            "location": "/lux_data_log/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_data_log/#applicativelog-mon", 
            "text": "(All [a] (-  (lux/control/monoid;Monoid a) (lux/control/applicative;Applicative (Log a))))", 
            "title": "(Applicative&lt;Log&gt; mon)"
        }, 
        {
            "location": "/lux_data_log/#functorlog", 
            "text": "(All [a] (lux/control/functor;Functor (Log a)))", 
            "title": "Functor&lt;Log&gt;"
        }, 
        {
            "location": "/lux_data_log/#logt-monoidl-monadm", 
            "text": "(All [a b] (-  (lux/control/monoid;Monoid a) (lux/control/monad;Monad b) (lux/control/monad;Monad (All [c] (b (Log a c))))))", 
            "title": "(LogT Monoid&lt;l&gt; Monad&lt;M&gt;)"
        }, 
        {
            "location": "/lux_data_log/#monadlog-mon", 
            "text": "(All [a] (-  (lux/control/monoid;Monoid a) (lux/control/monad;Monad (Log a))))", 
            "title": "(Monad&lt;Log&gt; mon)"
        }, 
        {
            "location": "/lux_data_log/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_log/#lift-log-monoidl-monadm", 
            "text": "(All [a b c] (-  (lux/control/monoid;Monoid a) (lux/control/monad;Monad b) (b c) (b (Log a c))))", 
            "title": "(lift-log Monoid&lt;l&gt; Monad&lt;M&gt;)"
        }, 
        {
            "location": "/lux_data_log/#log-l", 
            "text": "Set the log to a particular value.  (All [a] (-  a (Log a lux;Unit)))", 
            "title": "(log l)"
        }, 
        {
            "location": "/lux_data_maybe/", 
            "text": "lux/data/maybe\n\n\nStructs\n\n\nApplicative\nMaybe\n\n\n(lux/control/applicative;Applicative lux;Maybe)\n\n\n(Eq\nMaybe\n Eq\na\n)\n\n\n(All [a] (-\n (lux/control/eq;Eq a) (lux/control/eq;Eq (lux;Maybe a))))\n\n\nFunctor\nMaybe\n\n\n(lux/control/functor;Functor lux;Maybe)\n\n\n(MaybeT Monad\nM\n)\n\n\n(All [a] (-\n (lux/control/monad;Monad a) (lux/control/monad;Monad (All [b] (a (lux;Maybe b))))))\n\n\nMonad\nMaybe\n\n\n(lux/control/monad;Monad lux;Maybe)\n\n\nMonoid\nMaybe\n\n\n(All [a] (lux/control/monoid;Monoid (lux;Maybe a)))\n\n\nValues\n\n\n(lift-maybe Monad\nM\n)\n\n\n(All [a b] (-\n (lux/control/monad;Monad a) (a b) (a (lux;Maybe b))))", 
            "title": "Lux data maybe"
        }, 
        {
            "location": "/lux_data_maybe/#luxdatamaybe", 
            "text": "", 
            "title": "lux/data/maybe"
        }, 
        {
            "location": "/lux_data_maybe/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_data_maybe/#applicativemaybe", 
            "text": "(lux/control/applicative;Applicative lux;Maybe)", 
            "title": "Applicative&lt;Maybe&gt;"
        }, 
        {
            "location": "/lux_data_maybe/#eqmaybe-eqa", 
            "text": "(All [a] (-  (lux/control/eq;Eq a) (lux/control/eq;Eq (lux;Maybe a))))", 
            "title": "(Eq&lt;Maybe&gt; Eq&lt;a&gt;)"
        }, 
        {
            "location": "/lux_data_maybe/#functormaybe", 
            "text": "(lux/control/functor;Functor lux;Maybe)", 
            "title": "Functor&lt;Maybe&gt;"
        }, 
        {
            "location": "/lux_data_maybe/#maybet-monadm", 
            "text": "(All [a] (-  (lux/control/monad;Monad a) (lux/control/monad;Monad (All [b] (a (lux;Maybe b))))))", 
            "title": "(MaybeT Monad&lt;M&gt;)"
        }, 
        {
            "location": "/lux_data_maybe/#monadmaybe", 
            "text": "(lux/control/monad;Monad lux;Maybe)", 
            "title": "Monad&lt;Maybe&gt;"
        }, 
        {
            "location": "/lux_data_maybe/#monoidmaybe", 
            "text": "(All [a] (lux/control/monoid;Monoid (lux;Maybe a)))", 
            "title": "Monoid&lt;Maybe&gt;"
        }, 
        {
            "location": "/lux_data_maybe/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_maybe/#lift-maybe-monadm", 
            "text": "(All [a b] (-  (lux/control/monad;Monad a) (a b) (a (lux;Maybe b))))", 
            "title": "(lift-maybe Monad&lt;M&gt;)"
        }, 
        {
            "location": "/lux_data_number/", 
            "text": "lux/data/number\n\n\n\n\nImplementations of common structures for Lux's primitive number types.\n\n\n\n\nMacros\n\n\nbin\n\n\n## Given syntax for a binary number, generates a Nat.\n(bin \n11001001\n)\n\n\n\n\nhex\n\n\n## Given syntax for a hexadecimal number, generates a Nat.\n(hex \ndeadBEEF\n)\n\n\n\n\noct\n\n\n## Given syntax for an octal number, generates a Nat.\n(oct \n615243\n)\n\n\n\n\nStructs\n\n\nAdd@Monoid\nFrac\n\n\n(lux/control/monoid;Monoid lux;Frac)\n\n\nAdd@Monoid\nInt\n\n\n(lux/control/monoid;Monoid lux;Int)\n\n\nAdd@Monoid\nNat\n\n\n(lux/control/monoid;Monoid lux;Nat)\n\n\nAdd@Monoid\nReal\n\n\n(lux/control/monoid;Monoid lux;Real)\n\n\nBinary@Codec\nText,Nat\n\n\n(lux/control/codec;Codec lux;Text lux;Nat)\n\n\nBounded\nFrac\n\n\n(lux/control/bounded;Bounded lux;Frac)\n\n\nBounded\nInt\n\n\n(lux/control/bounded;Bounded lux;Int)\n\n\nBounded\nNat\n\n\n(lux/control/bounded;Bounded lux;Nat)\n\n\nBounded\nReal\n\n\n(lux/control/bounded;Bounded lux;Real)\n\n\nCodec\nText,Frac\n\n\n(lux/control/codec;Codec lux;Text lux;Frac)\n\n\nCodec\nText,Int\n\n\n(lux/control/codec;Codec lux;Text lux;Int)\n\n\nCodec\nText,Nat\n\n\n(lux/control/codec;Codec lux;Text lux;Nat)\n\n\nCodec\nText,Real\n\n\n(lux/control/codec;Codec lux;Text lux;Real)\n\n\nEnum\nInt\n\n\n(lux/control/enum;Enum lux;Int)\n\n\nEnum\nNat\n\n\n(lux/control/enum;Enum lux;Nat)\n\n\nEq\nFrac\n\n\n(lux/control/eq;Eq lux;Frac)\n\n\nEq\nInt\n\n\n(lux/control/eq;Eq lux;Int)\n\n\nEq\nNat\n\n\n(lux/control/eq;Eq lux;Nat)\n\n\nEq\nReal\n\n\n(lux/control/eq;Eq lux;Real)\n\n\nHash\nInt\n\n\n(lux/control/hash;Hash lux;Int)\n\n\nHash\nNat\n\n\n(lux/control/hash;Hash lux;Nat)\n\n\nHash\nReal\n\n\n(lux/control/hash;Hash lux;Real)\n\n\nHex@Codec\nText,Nat\n\n\n(lux/control/codec;Codec lux;Text lux;Nat)\n\n\nMax@Monoid\nFrac\n\n\n(lux/control/monoid;Monoid lux;Frac)\n\n\nMax@Monoid\nInt\n\n\n(lux/control/monoid;Monoid lux;Int)\n\n\nMax@Monoid\nNat\n\n\n(lux/control/monoid;Monoid lux;Nat)\n\n\nMax@Monoid\nReal\n\n\n(lux/control/monoid;Monoid lux;Real)\n\n\nMin@Monoid\nFrac\n\n\n(lux/control/monoid;Monoid lux;Frac)\n\n\nMin@Monoid\nInt\n\n\n(lux/control/monoid;Monoid lux;Int)\n\n\nMin@Monoid\nNat\n\n\n(lux/control/monoid;Monoid lux;Nat)\n\n\nMin@Monoid\nReal\n\n\n(lux/control/monoid;Monoid lux;Real)\n\n\nMul@Monoid\nFrac\n\n\n(lux/control/monoid;Monoid lux;Frac)\n\n\nMul@Monoid\nInt\n\n\n(lux/control/monoid;Monoid lux;Int)\n\n\nMul@Monoid\nNat\n\n\n(lux/control/monoid;Monoid lux;Nat)\n\n\nMul@Monoid\nReal\n\n\n(lux/control/monoid;Monoid lux;Real)\n\n\nNumber\nFrac\n\n\n(lux/control/number;Number lux;Frac)\n\n\nNumber\nInt\n\n\n(lux/control/number;Number lux;Int)\n\n\nNumber\nNat\n\n\n(lux/control/number;Number lux;Nat)\n\n\nNumber\nReal\n\n\n(lux/control/number;Number lux;Real)\n\n\nOctal@Codec\nText,Nat\n\n\n(lux/control/codec;Codec lux;Text lux;Nat)\n\n\nOrd\nFrac\n\n\n(lux/control/ord;Ord lux;Frac)\n\n\nOrd\nInt\n\n\n(lux/control/ord;Ord lux;Int)\n\n\nOrd\nNat\n\n\n(lux/control/ord;Ord lux;Nat)\n\n\nOrd\nReal\n\n\n(lux/control/ord;Ord lux;Real)\n\n\nValues\n\n\n+inf\n\n\nPositive infinity.\n\n\n\n\nlux;Real\n\n\n-inf\n\n\nNegative infinity.\n\n\n\n\nlux;Real\n\n\nnan\n\n\nNot-a-number.\n\n\n\n\nlux;Real\n\n\n(nan? number)\n\n\nTests whether a real is actually not-a-number.\n\n\n\n\n(-\n lux;Real lux;Bool)", 
            "title": "Lux data number"
        }, 
        {
            "location": "/lux_data_number/#luxdatanumber", 
            "text": "Implementations of common structures for Lux's primitive number types.", 
            "title": "lux/data/number"
        }, 
        {
            "location": "/lux_data_number/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_data_number/#bin", 
            "text": "## Given syntax for a binary number, generates a Nat.\n(bin  11001001 )", 
            "title": "bin"
        }, 
        {
            "location": "/lux_data_number/#hex", 
            "text": "## Given syntax for a hexadecimal number, generates a Nat.\n(hex  deadBEEF )", 
            "title": "hex"
        }, 
        {
            "location": "/lux_data_number/#oct", 
            "text": "## Given syntax for an octal number, generates a Nat.\n(oct  615243 )", 
            "title": "oct"
        }, 
        {
            "location": "/lux_data_number/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_data_number/#addmonoidfrac", 
            "text": "(lux/control/monoid;Monoid lux;Frac)", 
            "title": "Add@Monoid&lt;Frac&gt;"
        }, 
        {
            "location": "/lux_data_number/#addmonoidint", 
            "text": "(lux/control/monoid;Monoid lux;Int)", 
            "title": "Add@Monoid&lt;Int&gt;"
        }, 
        {
            "location": "/lux_data_number/#addmonoidnat", 
            "text": "(lux/control/monoid;Monoid lux;Nat)", 
            "title": "Add@Monoid&lt;Nat&gt;"
        }, 
        {
            "location": "/lux_data_number/#addmonoidreal", 
            "text": "(lux/control/monoid;Monoid lux;Real)", 
            "title": "Add@Monoid&lt;Real&gt;"
        }, 
        {
            "location": "/lux_data_number/#binarycodectextnat", 
            "text": "(lux/control/codec;Codec lux;Text lux;Nat)", 
            "title": "Binary@Codec&lt;Text,Nat&gt;"
        }, 
        {
            "location": "/lux_data_number/#boundedfrac", 
            "text": "(lux/control/bounded;Bounded lux;Frac)", 
            "title": "Bounded&lt;Frac&gt;"
        }, 
        {
            "location": "/lux_data_number/#boundedint", 
            "text": "(lux/control/bounded;Bounded lux;Int)", 
            "title": "Bounded&lt;Int&gt;"
        }, 
        {
            "location": "/lux_data_number/#boundednat", 
            "text": "(lux/control/bounded;Bounded lux;Nat)", 
            "title": "Bounded&lt;Nat&gt;"
        }, 
        {
            "location": "/lux_data_number/#boundedreal", 
            "text": "(lux/control/bounded;Bounded lux;Real)", 
            "title": "Bounded&lt;Real&gt;"
        }, 
        {
            "location": "/lux_data_number/#codectextfrac", 
            "text": "(lux/control/codec;Codec lux;Text lux;Frac)", 
            "title": "Codec&lt;Text,Frac&gt;"
        }, 
        {
            "location": "/lux_data_number/#codectextint", 
            "text": "(lux/control/codec;Codec lux;Text lux;Int)", 
            "title": "Codec&lt;Text,Int&gt;"
        }, 
        {
            "location": "/lux_data_number/#codectextnat", 
            "text": "(lux/control/codec;Codec lux;Text lux;Nat)", 
            "title": "Codec&lt;Text,Nat&gt;"
        }, 
        {
            "location": "/lux_data_number/#codectextreal", 
            "text": "(lux/control/codec;Codec lux;Text lux;Real)", 
            "title": "Codec&lt;Text,Real&gt;"
        }, 
        {
            "location": "/lux_data_number/#enumint", 
            "text": "(lux/control/enum;Enum lux;Int)", 
            "title": "Enum&lt;Int&gt;"
        }, 
        {
            "location": "/lux_data_number/#enumnat", 
            "text": "(lux/control/enum;Enum lux;Nat)", 
            "title": "Enum&lt;Nat&gt;"
        }, 
        {
            "location": "/lux_data_number/#eqfrac", 
            "text": "(lux/control/eq;Eq lux;Frac)", 
            "title": "Eq&lt;Frac&gt;"
        }, 
        {
            "location": "/lux_data_number/#eqint", 
            "text": "(lux/control/eq;Eq lux;Int)", 
            "title": "Eq&lt;Int&gt;"
        }, 
        {
            "location": "/lux_data_number/#eqnat", 
            "text": "(lux/control/eq;Eq lux;Nat)", 
            "title": "Eq&lt;Nat&gt;"
        }, 
        {
            "location": "/lux_data_number/#eqreal", 
            "text": "(lux/control/eq;Eq lux;Real)", 
            "title": "Eq&lt;Real&gt;"
        }, 
        {
            "location": "/lux_data_number/#hashint", 
            "text": "(lux/control/hash;Hash lux;Int)", 
            "title": "Hash&lt;Int&gt;"
        }, 
        {
            "location": "/lux_data_number/#hashnat", 
            "text": "(lux/control/hash;Hash lux;Nat)", 
            "title": "Hash&lt;Nat&gt;"
        }, 
        {
            "location": "/lux_data_number/#hashreal", 
            "text": "(lux/control/hash;Hash lux;Real)", 
            "title": "Hash&lt;Real&gt;"
        }, 
        {
            "location": "/lux_data_number/#hexcodectextnat", 
            "text": "(lux/control/codec;Codec lux;Text lux;Nat)", 
            "title": "Hex@Codec&lt;Text,Nat&gt;"
        }, 
        {
            "location": "/lux_data_number/#maxmonoidfrac", 
            "text": "(lux/control/monoid;Monoid lux;Frac)", 
            "title": "Max@Monoid&lt;Frac&gt;"
        }, 
        {
            "location": "/lux_data_number/#maxmonoidint", 
            "text": "(lux/control/monoid;Monoid lux;Int)", 
            "title": "Max@Monoid&lt;Int&gt;"
        }, 
        {
            "location": "/lux_data_number/#maxmonoidnat", 
            "text": "(lux/control/monoid;Monoid lux;Nat)", 
            "title": "Max@Monoid&lt;Nat&gt;"
        }, 
        {
            "location": "/lux_data_number/#maxmonoidreal", 
            "text": "(lux/control/monoid;Monoid lux;Real)", 
            "title": "Max@Monoid&lt;Real&gt;"
        }, 
        {
            "location": "/lux_data_number/#minmonoidfrac", 
            "text": "(lux/control/monoid;Monoid lux;Frac)", 
            "title": "Min@Monoid&lt;Frac&gt;"
        }, 
        {
            "location": "/lux_data_number/#minmonoidint", 
            "text": "(lux/control/monoid;Monoid lux;Int)", 
            "title": "Min@Monoid&lt;Int&gt;"
        }, 
        {
            "location": "/lux_data_number/#minmonoidnat", 
            "text": "(lux/control/monoid;Monoid lux;Nat)", 
            "title": "Min@Monoid&lt;Nat&gt;"
        }, 
        {
            "location": "/lux_data_number/#minmonoidreal", 
            "text": "(lux/control/monoid;Monoid lux;Real)", 
            "title": "Min@Monoid&lt;Real&gt;"
        }, 
        {
            "location": "/lux_data_number/#mulmonoidfrac", 
            "text": "(lux/control/monoid;Monoid lux;Frac)", 
            "title": "Mul@Monoid&lt;Frac&gt;"
        }, 
        {
            "location": "/lux_data_number/#mulmonoidint", 
            "text": "(lux/control/monoid;Monoid lux;Int)", 
            "title": "Mul@Monoid&lt;Int&gt;"
        }, 
        {
            "location": "/lux_data_number/#mulmonoidnat", 
            "text": "(lux/control/monoid;Monoid lux;Nat)", 
            "title": "Mul@Monoid&lt;Nat&gt;"
        }, 
        {
            "location": "/lux_data_number/#mulmonoidreal", 
            "text": "(lux/control/monoid;Monoid lux;Real)", 
            "title": "Mul@Monoid&lt;Real&gt;"
        }, 
        {
            "location": "/lux_data_number/#numberfrac", 
            "text": "(lux/control/number;Number lux;Frac)", 
            "title": "Number&lt;Frac&gt;"
        }, 
        {
            "location": "/lux_data_number/#numberint", 
            "text": "(lux/control/number;Number lux;Int)", 
            "title": "Number&lt;Int&gt;"
        }, 
        {
            "location": "/lux_data_number/#numbernat", 
            "text": "(lux/control/number;Number lux;Nat)", 
            "title": "Number&lt;Nat&gt;"
        }, 
        {
            "location": "/lux_data_number/#numberreal", 
            "text": "(lux/control/number;Number lux;Real)", 
            "title": "Number&lt;Real&gt;"
        }, 
        {
            "location": "/lux_data_number/#octalcodectextnat", 
            "text": "(lux/control/codec;Codec lux;Text lux;Nat)", 
            "title": "Octal@Codec&lt;Text,Nat&gt;"
        }, 
        {
            "location": "/lux_data_number/#ordfrac", 
            "text": "(lux/control/ord;Ord lux;Frac)", 
            "title": "Ord&lt;Frac&gt;"
        }, 
        {
            "location": "/lux_data_number/#ordint", 
            "text": "(lux/control/ord;Ord lux;Int)", 
            "title": "Ord&lt;Int&gt;"
        }, 
        {
            "location": "/lux_data_number/#ordnat", 
            "text": "(lux/control/ord;Ord lux;Nat)", 
            "title": "Ord&lt;Nat&gt;"
        }, 
        {
            "location": "/lux_data_number/#ordreal", 
            "text": "(lux/control/ord;Ord lux;Real)", 
            "title": "Ord&lt;Real&gt;"
        }, 
        {
            "location": "/lux_data_number/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_number/#inf", 
            "text": "Positive infinity.  lux;Real", 
            "title": "+inf"
        }, 
        {
            "location": "/lux_data_number/#-inf", 
            "text": "Negative infinity.  lux;Real", 
            "title": "-inf"
        }, 
        {
            "location": "/lux_data_number/#nan", 
            "text": "Not-a-number.  lux;Real", 
            "title": "nan"
        }, 
        {
            "location": "/lux_data_number/#nan-number", 
            "text": "Tests whether a real is actually not-a-number.  (-  lux;Real lux;Bool)", 
            "title": "(nan? number)"
        }, 
        {
            "location": "/lux_data_product/", 
            "text": "lux/data/product\n\n\n\n\nFunctionality for working with tuples (particularly 2-tuples).\n\n\n\n\nValues\n\n\n(curry f)\n\n\n(All [a b c] (-\n (-\n [a b] c) a b c))\n\n\n(left xy)\n\n\n(All [a b] (-\n [a b] a))\n\n\n(right xy)\n\n\n(All [a b] (-\n [a b] b))\n\n\n(swap xy)\n\n\n(All [a b] (-\n [a b] [b a]))\n\n\n(uncurry f)\n\n\n(All [a b c] (-\n (-\n a b c) [a b] c))", 
            "title": "Lux data product"
        }, 
        {
            "location": "/lux_data_product/#luxdataproduct", 
            "text": "Functionality for working with tuples (particularly 2-tuples).", 
            "title": "lux/data/product"
        }, 
        {
            "location": "/lux_data_product/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_product/#curry-f", 
            "text": "(All [a b c] (-  (-  [a b] c) a b c))", 
            "title": "(curry f)"
        }, 
        {
            "location": "/lux_data_product/#left-xy", 
            "text": "(All [a b] (-  [a b] a))", 
            "title": "(left xy)"
        }, 
        {
            "location": "/lux_data_product/#right-xy", 
            "text": "(All [a b] (-  [a b] b))", 
            "title": "(right xy)"
        }, 
        {
            "location": "/lux_data_product/#swap-xy", 
            "text": "(All [a b] (-  [a b] [b a]))", 
            "title": "(swap xy)"
        }, 
        {
            "location": "/lux_data_product/#uncurry-f", 
            "text": "(All [a b c] (-  (-  a b c) [a b] c))", 
            "title": "(uncurry f)"
        }, 
        {
            "location": "/lux_data_struct_array/", 
            "text": "lux/data/struct/array\n\n\nTypes\n\n\nArray\n\n\nMutable arrays.\n\n\n(type: (Array a)\n  (host #Array a))\n\n\n\n\nStructs\n\n\n(Eq\nArray\n Eq\na\n)\n\n\n(All [a] (-\n (lux/control/eq;Eq a) (lux/control/eq;Eq (Array a))))\n\n\nFold\nArray\n\n\n(lux/control/fold;Fold Array)\n\n\nFunctor\nArray\n\n\n(lux/control/functor;Functor Array)\n\n\nMonoid\nArray\n\n\n(All [a] (lux/control/monoid;Monoid (Array a)))\n\n\nValues\n\n\n(clone xs)\n\n\n(All [a] (-\n (Array a) (Array a)))\n\n\n(copy length src-start src-array dest-start dest-array)\n\n\n(All [a] (-\n lux;Nat lux;Nat (Array a) lux;Nat (Array a) (Array a)))\n\n\n(filter p xs)\n\n\n(All [a] (-\n (-\n a lux;Bool) (Array a) (Array a)))\n\n\n(find p xs)\n\n\n(All [a] (-\n (-\n a lux;Bool) (Array a) (lux;Maybe a)))\n\n\n(find+ p xs)\n\n\nJust like 'find', but with access to the index of each value.\n\n\n\n\n(All [a] (-\n (-\n lux;Nat a lux;Bool) (Array a) (lux;Maybe [lux;Nat a])))\n\n\n(from-list xs)\n\n\n(All [a] (-\n (lux;List a) (Array a)))\n\n\n(get i xs)\n\n\n(All [a] (-\n lux;Nat (Array a) (lux;Maybe a)))\n\n\n(new size)\n\n\n(All [a] (-\n lux;Nat (Array a)))\n\n\n(occupied array)\n\n\nFinds out how many cells in an array are occupied.\n\n\n\n\n(All [a] (-\n (Array a) lux;Nat))\n\n\n(put i x xs)\n\n\n(All [a] (-\n lux;Nat a (Array a) (Array a)))\n\n\n(remove i xs)\n\n\n(All [a] (-\n lux;Nat (Array a) (Array a)))\n\n\n(size xs)\n\n\n(All [a] (-\n (Array a) lux;Nat))\n\n\n(to-list array)\n\n\n(All [a] (-\n (Array a) (lux;List a)))\n\n\n(vacant array)\n\n\nFinds out how many cells in an array are vacant.\n\n\n\n\n(All [a] (-\n (Array a) lux;Nat))", 
            "title": "Lux data struct array"
        }, 
        {
            "location": "/lux_data_struct_array/#luxdatastructarray", 
            "text": "", 
            "title": "lux/data/struct/array"
        }, 
        {
            "location": "/lux_data_struct_array/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_data_struct_array/#array", 
            "text": "Mutable arrays.  (type: (Array a)\n  (host #Array a))", 
            "title": "Array"
        }, 
        {
            "location": "/lux_data_struct_array/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_data_struct_array/#eqarray-eqa", 
            "text": "(All [a] (-  (lux/control/eq;Eq a) (lux/control/eq;Eq (Array a))))", 
            "title": "(Eq&lt;Array&gt; Eq&lt;a&gt;)"
        }, 
        {
            "location": "/lux_data_struct_array/#foldarray", 
            "text": "(lux/control/fold;Fold Array)", 
            "title": "Fold&lt;Array&gt;"
        }, 
        {
            "location": "/lux_data_struct_array/#functorarray", 
            "text": "(lux/control/functor;Functor Array)", 
            "title": "Functor&lt;Array&gt;"
        }, 
        {
            "location": "/lux_data_struct_array/#monoidarray", 
            "text": "(All [a] (lux/control/monoid;Monoid (Array a)))", 
            "title": "Monoid&lt;Array&gt;"
        }, 
        {
            "location": "/lux_data_struct_array/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_struct_array/#clone-xs", 
            "text": "(All [a] (-  (Array a) (Array a)))", 
            "title": "(clone xs)"
        }, 
        {
            "location": "/lux_data_struct_array/#copy-length-src-start-src-array-dest-start-dest-array", 
            "text": "(All [a] (-  lux;Nat lux;Nat (Array a) lux;Nat (Array a) (Array a)))", 
            "title": "(copy length src-start src-array dest-start dest-array)"
        }, 
        {
            "location": "/lux_data_struct_array/#filter-p-xs", 
            "text": "(All [a] (-  (-  a lux;Bool) (Array a) (Array a)))", 
            "title": "(filter p xs)"
        }, 
        {
            "location": "/lux_data_struct_array/#find-p-xs", 
            "text": "(All [a] (-  (-  a lux;Bool) (Array a) (lux;Maybe a)))", 
            "title": "(find p xs)"
        }, 
        {
            "location": "/lux_data_struct_array/#find-p-xs_1", 
            "text": "Just like 'find', but with access to the index of each value.  (All [a] (-  (-  lux;Nat a lux;Bool) (Array a) (lux;Maybe [lux;Nat a])))", 
            "title": "(find+ p xs)"
        }, 
        {
            "location": "/lux_data_struct_array/#from-list-xs", 
            "text": "(All [a] (-  (lux;List a) (Array a)))", 
            "title": "(from-list xs)"
        }, 
        {
            "location": "/lux_data_struct_array/#get-i-xs", 
            "text": "(All [a] (-  lux;Nat (Array a) (lux;Maybe a)))", 
            "title": "(get i xs)"
        }, 
        {
            "location": "/lux_data_struct_array/#new-size", 
            "text": "(All [a] (-  lux;Nat (Array a)))", 
            "title": "(new size)"
        }, 
        {
            "location": "/lux_data_struct_array/#occupied-array", 
            "text": "Finds out how many cells in an array are occupied.  (All [a] (-  (Array a) lux;Nat))", 
            "title": "(occupied array)"
        }, 
        {
            "location": "/lux_data_struct_array/#put-i-x-xs", 
            "text": "(All [a] (-  lux;Nat a (Array a) (Array a)))", 
            "title": "(put i x xs)"
        }, 
        {
            "location": "/lux_data_struct_array/#remove-i-xs", 
            "text": "(All [a] (-  lux;Nat (Array a) (Array a)))", 
            "title": "(remove i xs)"
        }, 
        {
            "location": "/lux_data_struct_array/#size-xs", 
            "text": "(All [a] (-  (Array a) lux;Nat))", 
            "title": "(size xs)"
        }, 
        {
            "location": "/lux_data_struct_array/#to-list-array", 
            "text": "(All [a] (-  (Array a) (lux;List a)))", 
            "title": "(to-list array)"
        }, 
        {
            "location": "/lux_data_struct_array/#vacant-array", 
            "text": "Finds out how many cells in an array are vacant.  (All [a] (-  (Array a) lux;Nat))", 
            "title": "(vacant array)"
        }, 
        {
            "location": "/lux_data_struct_dict/", 
            "text": "lux/data/struct/dict\n\n\nTypes\n\n\nDict\n\n\nA dictionary implemented as a Hash-Array Mapped Trie (HAMT).\n\n\n(type: (Dict k v)\n  {#hash (lux/control/hash;Hash k)\n   #root (Node k v)})\n\n\n\n\nStructs\n\n\n(Eq\nDict\n Eq\nv\n)\n\n\n(All [a b] (-\n (lux/control/eq;Eq b) (lux/control/eq;Eq (Dict a b))))\n\n\nValues\n\n\n(contains? key table)\n\n\n(All [a b] (-\n a (Dict a b) lux;Bool))\n\n\nempty?\n\n\n(All [a b] (-\n (Dict a b) lux;Bool))\n\n\n(entries dict)\n\n\n(All [a b] (-\n (Dict a b) (lux;List [a b])))\n\n\n(from-list Hash\nK\n kvs)\n\n\n(All [a b] (-\n (lux/control/hash;Hash a) (lux;List [a b]) (Dict a b)))\n\n\n(get key dict)\n\n\n(All [a b] (-\n a (Dict a b) (lux;Maybe b)))\n\n\n(keys dict)\n\n\n(All [a b] (-\n (Dict a b) (lux;List a)))\n\n\n(merge dict2 dict1)\n\n\nMerges 2 dictionaries.\n\nIf any collisions with keys occur, the values of dict2 will overwrite those of dict1.\n\n\n\n\n(All [a b] (-\n (Dict a b) (Dict a b) (Dict a b)))\n\n\n(merge-with f dict2 dict1)\n\n\nMerges 2 dictionaries.\n\nIf any collisions with keys occur, a new value will be computed by applying 'f' to the values of dict2 and dict1.\n\n\n\n\n(All [a b] (-\n (-\n b b b) (Dict a b) (Dict a b) (Dict a b)))\n\n\n(new Hash\nK\n)\n\n\n(All [a b] (-\n (lux/control/hash;Hash a) (Dict a b)))\n\n\n(put key val dict)\n\n\n(All [a b] (-\n a b (Dict a b) (Dict a b)))\n\n\n(put~ key val table)\n\n\nOnly puts the KV-pair if the key is not already present.\n\n\n\n\n(All [a b] (-\n a b (Dict a b) (Dict a b)))\n\n\n(re-bind from-key to-key dict)\n\n\n(All [a b] (-\n a a (Dict a b) (Dict a b)))\n\n\n(remove key dict)\n\n\n(All [a b] (-\n a (Dict a b) (Dict a b)))\n\n\n(select keys dict)\n\n\nCreates a sub-set of the given dict, with only the specified keys.\n\n\n\n\n(All [a b] (-\n (lux;List a) (Dict a b) (Dict a b)))\n\n\nsize\n\n\n(All [a b] (-\n (Dict a b) lux;Nat))\n\n\n(update key f table)\n\n\nTransforms the value located at key (if available), using the given function.\n\n\n\n\n(All [a b] (-\n a (-\n b b) (Dict a b) (Dict a b)))\n\n\n(values dict)\n\n\n(All [a b] (-\n (Dict a b) (lux;List b)))", 
            "title": "Lux data struct dict"
        }, 
        {
            "location": "/lux_data_struct_dict/#luxdatastructdict", 
            "text": "", 
            "title": "lux/data/struct/dict"
        }, 
        {
            "location": "/lux_data_struct_dict/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_data_struct_dict/#dict", 
            "text": "A dictionary implemented as a Hash-Array Mapped Trie (HAMT).  (type: (Dict k v)\n  {#hash (lux/control/hash;Hash k)\n   #root (Node k v)})", 
            "title": "Dict"
        }, 
        {
            "location": "/lux_data_struct_dict/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_data_struct_dict/#eqdict-eqv", 
            "text": "(All [a b] (-  (lux/control/eq;Eq b) (lux/control/eq;Eq (Dict a b))))", 
            "title": "(Eq&lt;Dict&gt; Eq&lt;v&gt;)"
        }, 
        {
            "location": "/lux_data_struct_dict/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_struct_dict/#contains-key-table", 
            "text": "(All [a b] (-  a (Dict a b) lux;Bool))", 
            "title": "(contains? key table)"
        }, 
        {
            "location": "/lux_data_struct_dict/#empty", 
            "text": "(All [a b] (-  (Dict a b) lux;Bool))", 
            "title": "empty?"
        }, 
        {
            "location": "/lux_data_struct_dict/#entries-dict", 
            "text": "(All [a b] (-  (Dict a b) (lux;List [a b])))", 
            "title": "(entries dict)"
        }, 
        {
            "location": "/lux_data_struct_dict/#from-list-hashk-kvs", 
            "text": "(All [a b] (-  (lux/control/hash;Hash a) (lux;List [a b]) (Dict a b)))", 
            "title": "(from-list Hash&lt;K&gt; kvs)"
        }, 
        {
            "location": "/lux_data_struct_dict/#get-key-dict", 
            "text": "(All [a b] (-  a (Dict a b) (lux;Maybe b)))", 
            "title": "(get key dict)"
        }, 
        {
            "location": "/lux_data_struct_dict/#keys-dict", 
            "text": "(All [a b] (-  (Dict a b) (lux;List a)))", 
            "title": "(keys dict)"
        }, 
        {
            "location": "/lux_data_struct_dict/#merge-dict2-dict1", 
            "text": "Merges 2 dictionaries.\n\nIf any collisions with keys occur, the values of dict2 will overwrite those of dict1.  (All [a b] (-  (Dict a b) (Dict a b) (Dict a b)))", 
            "title": "(merge dict2 dict1)"
        }, 
        {
            "location": "/lux_data_struct_dict/#merge-with-f-dict2-dict1", 
            "text": "Merges 2 dictionaries.\n\nIf any collisions with keys occur, a new value will be computed by applying 'f' to the values of dict2 and dict1.  (All [a b] (-  (-  b b b) (Dict a b) (Dict a b) (Dict a b)))", 
            "title": "(merge-with f dict2 dict1)"
        }, 
        {
            "location": "/lux_data_struct_dict/#new-hashk", 
            "text": "(All [a b] (-  (lux/control/hash;Hash a) (Dict a b)))", 
            "title": "(new Hash&lt;K&gt;)"
        }, 
        {
            "location": "/lux_data_struct_dict/#put-key-val-dict", 
            "text": "(All [a b] (-  a b (Dict a b) (Dict a b)))", 
            "title": "(put key val dict)"
        }, 
        {
            "location": "/lux_data_struct_dict/#put-key-val-table", 
            "text": "Only puts the KV-pair if the key is not already present.  (All [a b] (-  a b (Dict a b) (Dict a b)))", 
            "title": "(put~ key val table)"
        }, 
        {
            "location": "/lux_data_struct_dict/#re-bind-from-key-to-key-dict", 
            "text": "(All [a b] (-  a a (Dict a b) (Dict a b)))", 
            "title": "(re-bind from-key to-key dict)"
        }, 
        {
            "location": "/lux_data_struct_dict/#remove-key-dict", 
            "text": "(All [a b] (-  a (Dict a b) (Dict a b)))", 
            "title": "(remove key dict)"
        }, 
        {
            "location": "/lux_data_struct_dict/#select-keys-dict", 
            "text": "Creates a sub-set of the given dict, with only the specified keys.  (All [a b] (-  (lux;List a) (Dict a b) (Dict a b)))", 
            "title": "(select keys dict)"
        }, 
        {
            "location": "/lux_data_struct_dict/#size", 
            "text": "(All [a b] (-  (Dict a b) lux;Nat))", 
            "title": "size"
        }, 
        {
            "location": "/lux_data_struct_dict/#update-key-f-table", 
            "text": "Transforms the value located at key (if available), using the given function.  (All [a b] (-  a (-  b b) (Dict a b) (Dict a b)))", 
            "title": "(update key f table)"
        }, 
        {
            "location": "/lux_data_struct_dict/#values-dict", 
            "text": "(All [a b] (-  (Dict a b) (lux;List b)))", 
            "title": "(values dict)"
        }, 
        {
            "location": "/lux_data_struct_list/", 
            "text": "lux/data/struct/list\n\n\nMacros\n\n\nzip\n\n\n## Create list zippers with the specified number of input lists.\n(def: #export zip2 (zip 2))\n\n(def: #export zip3 (zip 3))\n\n((zip 3) xs ys zs)\n\n\n\n\nzip-with\n\n\n## Create list zippers with the specified number of input lists.\n(def: #export zip2-with (zip-with 2))\n\n(def: #export zip3-with (zip-with 3))\n\n((zip-with 2) i.+ xs ys)\n\n\n\n\nStructs\n\n\nApplicative\nList\n\n\n(lux/control/applicative;Applicative lux;List)\n\n\n(Eq\nList\n Eq\na\n)\n\n\n(All [a] (-\n (lux/control/eq;Eq a) (lux/control/eq;Eq (lux;List a))))\n\n\nFold\nList\n\n\n(lux/control/fold;Fold lux;List)\n\n\nFunctor\nList\n\n\n(lux/control/functor;Functor lux;List)\n\n\n(ListT Monad\nM\n)\n\n\n(All [a] (-\n (lux/control/monad;Monad a) (lux/control/monad;Monad (All [b] (a (lux;List b))))))\n\n\nMonad\nList\n\n\n(lux/control/monad;Monad lux;List)\n\n\nMonoid\nList\n\n\n(All [a] (lux/control/monoid;Monoid (lux;List a)))\n\n\nValues\n\n\n(any? p xs)\n\n\n(All [a] (-\n (-\n a lux;Bool) (lux;List a) lux;Bool))\n\n\n(as-pairs xs)\n\n\nCut the list into pairs of 2.\n\nCaveat emptor: If the list has an uneven number of elements, the last one will be skipped.\n\n\n\n\n(All [a] (-\n (lux;List a) (lux;List [a a])))\n\n\n(at i xs)\n\n\nFetches the element at the specified index.\n\n\n\n\n(All [a] (-\n lux;Nat (lux;List a) (lux;Maybe a)))\n\n\n(concat xss)\n\n\n(All [a] (-\n (lux;List (lux;List a)) (lux;List a)))\n\n\n(drop n xs)\n\n\n(All [a] (-\n lux;Nat (lux;List a) (lux;List a)))\n\n\n(drop-while p xs)\n\n\n(All [a] (-\n (-\n a lux;Bool) (lux;List a) (lux;List a)))\n\n\n(empty? xs)\n\n\n(All [a] (-\n (lux;List a) lux;Bool))\n\n\n(enumerate xs)\n\n\nPairs every element in the list with it's index, starting at 0.\n\n\n\n\n(All [a] (-\n (lux;List a) (lux;List [lux;Nat a])))\n\n\n(every? p xs)\n\n\n(All [a] (-\n (-\n a lux;Bool) (lux;List a) lux;Bool))\n\n\n(filter p xs)\n\n\n(All [a] (-\n (-\n a lux;Bool) (lux;List a) (lux;List a)))\n\n\n(find p xs)\n\n\nReturns the first value in the list for which the predicate is true.\n\n\n\n\n(All [a] (-\n (-\n a lux;Bool) (lux;List a) (lux;Maybe a)))\n\n\n(head xs)\n\n\nReturns the first element of a list.\n\n\n\n\n(All [a] (-\n (lux;List a) (lux;Maybe a)))\n\n\n(i.range from to)\n\n\nGenerates an inclusive interval of values [from, to].\n\n\n\n\n(-\n lux;Int lux;Int (lux;List lux;Int))\n\n\n(indices size)\n\n\nProduces all the valid indices for a given size.\n\n\n\n\n(All [a] (-\n lux;Nat (lux;List lux;Nat)))\n\n\n(inits xs)\n\n\nFor a list of size N, returns the first N-1 elements.\n\nEmpty lists will result in a #;None value being returned instead.\n\n\n\n\n(All [a] (-\n (lux;List a) (lux;Maybe (lux;List a))))\n\n\n(interpose sep xs)\n\n\nPuts a value between every two elements in the list.\n\n\n\n\n(All [a] (-\n a (lux;List a) (lux;List a)))\n\n\n(iterate f x)\n\n\nGenerates a list element by element until the function returns #;None.\n\n\n\n\n(All [a] (-\n (-\n a (lux;Maybe a)) a (lux;List a)))\n\n\n(last xs)\n\n\n(All [a] (-\n (lux;List a) (lux;Maybe a)))\n\n\n(lift-list Monad\nM\n)\n\n\n(All [a b] (-\n (lux/control/monad;Monad a) (a b) (a (lux;List b))))\n\n\n(member? eq xs x)\n\n\n(All [a] (-\n (lux/control/eq;Eq a) (lux;List a) a lux;Bool))\n\n\n(n.range from to)\n\n\nGenerates an inclusive interval of values [from, to].\n\n\n\n\n(-\n lux;Nat lux;Nat (lux;List lux;Nat))\n\n\n(partition p xs)\n\n\nDivide the list into all elements that satisfy a predicate, and all elements that don't.\n\n\n\n\n(All [a] (-\n (-\n a lux;Bool) (lux;List a) [(lux;List a) (lux;List a)]))\n\n\n(repeat n x)\n\n\nA list of the value x, repeated n times.\n\n\n\n\n(All [a] (-\n lux;Nat a (lux;List a)))\n\n\n(reverse xs)\n\n\n(All [a] (-\n (lux;List a) (lux;List a)))\n\n\n(size list)\n\n\n(All [a] (-\n (lux;List a) lux;Nat))\n\n\n(sort \n xs)\n\n\n(All [a] (-\n (-\n a a lux;Bool) (lux;List a) (lux;List a)))\n\n\n(split n xs)\n\n\n(All [a] (-\n lux;Nat (lux;List a) [(lux;List a) (lux;List a)]))\n\n\n(split-all n xs)\n\n\nSegment the list in chunks of size n.\n\n\n\n\n(All [a] (-\n lux;Nat (lux;List a) (lux;List (lux;List a))))\n\n\n(split-with p xs)\n\n\nSegment the list by using a predicate to tell when to cut.\n\n\n\n\n(All [a] (-\n (-\n a lux;Bool) (lux;List a) [(lux;List a) (lux;List a)]))\n\n\n(tail xs)\n\n\nFor a list of size N, returns the N-1 elements after the first one.\n\n\n\n\n(All [a] (-\n (lux;List a) (lux;Maybe (lux;List a))))\n\n\n(take n xs)\n\n\n(All [a] (-\n lux;Nat (lux;List a) (lux;List a)))\n\n\n(take-while p xs)\n\n\n(All [a] (-\n (-\n a lux;Bool) (lux;List a) (lux;List a)))\n\n\nzip2\n\n\n(All [a b] (-\n (lux;List a) (lux;List b) (lux;List [a b])))\n\n\nzip2-with\n\n\n(All [a b c] (-\n (-\n a b c) (lux;List a) (lux;List b) (lux;List c)))\n\n\nzip3\n\n\n(All [a b c] (-\n (lux;List a) (lux;List b) (lux;List c) (lux;List [a b c])))\n\n\nzip3-with\n\n\n(All [a b c d] (-\n (-\n a b c d) (lux;List a) (lux;List b) (lux;List c) (lux;List d)))", 
            "title": "Lux data struct list"
        }, 
        {
            "location": "/lux_data_struct_list/#luxdatastructlist", 
            "text": "", 
            "title": "lux/data/struct/list"
        }, 
        {
            "location": "/lux_data_struct_list/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_data_struct_list/#zip", 
            "text": "## Create list zippers with the specified number of input lists.\n(def: #export zip2 (zip 2))\n\n(def: #export zip3 (zip 3))\n\n((zip 3) xs ys zs)", 
            "title": "zip"
        }, 
        {
            "location": "/lux_data_struct_list/#zip-with", 
            "text": "## Create list zippers with the specified number of input lists.\n(def: #export zip2-with (zip-with 2))\n\n(def: #export zip3-with (zip-with 3))\n\n((zip-with 2) i.+ xs ys)", 
            "title": "zip-with"
        }, 
        {
            "location": "/lux_data_struct_list/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_data_struct_list/#applicativelist", 
            "text": "(lux/control/applicative;Applicative lux;List)", 
            "title": "Applicative&lt;List&gt;"
        }, 
        {
            "location": "/lux_data_struct_list/#eqlist-eqa", 
            "text": "(All [a] (-  (lux/control/eq;Eq a) (lux/control/eq;Eq (lux;List a))))", 
            "title": "(Eq&lt;List&gt; Eq&lt;a&gt;)"
        }, 
        {
            "location": "/lux_data_struct_list/#foldlist", 
            "text": "(lux/control/fold;Fold lux;List)", 
            "title": "Fold&lt;List&gt;"
        }, 
        {
            "location": "/lux_data_struct_list/#functorlist", 
            "text": "(lux/control/functor;Functor lux;List)", 
            "title": "Functor&lt;List&gt;"
        }, 
        {
            "location": "/lux_data_struct_list/#listt-monadm", 
            "text": "(All [a] (-  (lux/control/monad;Monad a) (lux/control/monad;Monad (All [b] (a (lux;List b))))))", 
            "title": "(ListT Monad&lt;M&gt;)"
        }, 
        {
            "location": "/lux_data_struct_list/#monadlist", 
            "text": "(lux/control/monad;Monad lux;List)", 
            "title": "Monad&lt;List&gt;"
        }, 
        {
            "location": "/lux_data_struct_list/#monoidlist", 
            "text": "(All [a] (lux/control/monoid;Monoid (lux;List a)))", 
            "title": "Monoid&lt;List&gt;"
        }, 
        {
            "location": "/lux_data_struct_list/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_struct_list/#any-p-xs", 
            "text": "(All [a] (-  (-  a lux;Bool) (lux;List a) lux;Bool))", 
            "title": "(any? p xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#as-pairs-xs", 
            "text": "Cut the list into pairs of 2.\n\nCaveat emptor: If the list has an uneven number of elements, the last one will be skipped.  (All [a] (-  (lux;List a) (lux;List [a a])))", 
            "title": "(as-pairs xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#at-i-xs", 
            "text": "Fetches the element at the specified index.  (All [a] (-  lux;Nat (lux;List a) (lux;Maybe a)))", 
            "title": "(at i xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#concat-xss", 
            "text": "(All [a] (-  (lux;List (lux;List a)) (lux;List a)))", 
            "title": "(concat xss)"
        }, 
        {
            "location": "/lux_data_struct_list/#drop-n-xs", 
            "text": "(All [a] (-  lux;Nat (lux;List a) (lux;List a)))", 
            "title": "(drop n xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#drop-while-p-xs", 
            "text": "(All [a] (-  (-  a lux;Bool) (lux;List a) (lux;List a)))", 
            "title": "(drop-while p xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#empty-xs", 
            "text": "(All [a] (-  (lux;List a) lux;Bool))", 
            "title": "(empty? xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#enumerate-xs", 
            "text": "Pairs every element in the list with it's index, starting at 0.  (All [a] (-  (lux;List a) (lux;List [lux;Nat a])))", 
            "title": "(enumerate xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#every-p-xs", 
            "text": "(All [a] (-  (-  a lux;Bool) (lux;List a) lux;Bool))", 
            "title": "(every? p xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#filter-p-xs", 
            "text": "(All [a] (-  (-  a lux;Bool) (lux;List a) (lux;List a)))", 
            "title": "(filter p xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#find-p-xs", 
            "text": "Returns the first value in the list for which the predicate is true.  (All [a] (-  (-  a lux;Bool) (lux;List a) (lux;Maybe a)))", 
            "title": "(find p xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#head-xs", 
            "text": "Returns the first element of a list.  (All [a] (-  (lux;List a) (lux;Maybe a)))", 
            "title": "(head xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#irange-from-to", 
            "text": "Generates an inclusive interval of values [from, to].  (-  lux;Int lux;Int (lux;List lux;Int))", 
            "title": "(i.range from to)"
        }, 
        {
            "location": "/lux_data_struct_list/#indices-size", 
            "text": "Produces all the valid indices for a given size.  (All [a] (-  lux;Nat (lux;List lux;Nat)))", 
            "title": "(indices size)"
        }, 
        {
            "location": "/lux_data_struct_list/#inits-xs", 
            "text": "For a list of size N, returns the first N-1 elements.\n\nEmpty lists will result in a #;None value being returned instead.  (All [a] (-  (lux;List a) (lux;Maybe (lux;List a))))", 
            "title": "(inits xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#interpose-sep-xs", 
            "text": "Puts a value between every two elements in the list.  (All [a] (-  a (lux;List a) (lux;List a)))", 
            "title": "(interpose sep xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#iterate-f-x", 
            "text": "Generates a list element by element until the function returns #;None.  (All [a] (-  (-  a (lux;Maybe a)) a (lux;List a)))", 
            "title": "(iterate f x)"
        }, 
        {
            "location": "/lux_data_struct_list/#last-xs", 
            "text": "(All [a] (-  (lux;List a) (lux;Maybe a)))", 
            "title": "(last xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#lift-list-monadm", 
            "text": "(All [a b] (-  (lux/control/monad;Monad a) (a b) (a (lux;List b))))", 
            "title": "(lift-list Monad&lt;M&gt;)"
        }, 
        {
            "location": "/lux_data_struct_list/#member-eq-xs-x", 
            "text": "(All [a] (-  (lux/control/eq;Eq a) (lux;List a) a lux;Bool))", 
            "title": "(member? eq xs x)"
        }, 
        {
            "location": "/lux_data_struct_list/#nrange-from-to", 
            "text": "Generates an inclusive interval of values [from, to].  (-  lux;Nat lux;Nat (lux;List lux;Nat))", 
            "title": "(n.range from to)"
        }, 
        {
            "location": "/lux_data_struct_list/#partition-p-xs", 
            "text": "Divide the list into all elements that satisfy a predicate, and all elements that don't.  (All [a] (-  (-  a lux;Bool) (lux;List a) [(lux;List a) (lux;List a)]))", 
            "title": "(partition p xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#repeat-n-x", 
            "text": "A list of the value x, repeated n times.  (All [a] (-  lux;Nat a (lux;List a)))", 
            "title": "(repeat n x)"
        }, 
        {
            "location": "/lux_data_struct_list/#reverse-xs", 
            "text": "(All [a] (-  (lux;List a) (lux;List a)))", 
            "title": "(reverse xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#size-list", 
            "text": "(All [a] (-  (lux;List a) lux;Nat))", 
            "title": "(size list)"
        }, 
        {
            "location": "/lux_data_struct_list/#sort-xs", 
            "text": "(All [a] (-  (-  a a lux;Bool) (lux;List a) (lux;List a)))", 
            "title": "(sort &lt; xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#split-n-xs", 
            "text": "(All [a] (-  lux;Nat (lux;List a) [(lux;List a) (lux;List a)]))", 
            "title": "(split n xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#split-all-n-xs", 
            "text": "Segment the list in chunks of size n.  (All [a] (-  lux;Nat (lux;List a) (lux;List (lux;List a))))", 
            "title": "(split-all n xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#split-with-p-xs", 
            "text": "Segment the list by using a predicate to tell when to cut.  (All [a] (-  (-  a lux;Bool) (lux;List a) [(lux;List a) (lux;List a)]))", 
            "title": "(split-with p xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#tail-xs", 
            "text": "For a list of size N, returns the N-1 elements after the first one.  (All [a] (-  (lux;List a) (lux;Maybe (lux;List a))))", 
            "title": "(tail xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#take-n-xs", 
            "text": "(All [a] (-  lux;Nat (lux;List a) (lux;List a)))", 
            "title": "(take n xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#take-while-p-xs", 
            "text": "(All [a] (-  (-  a lux;Bool) (lux;List a) (lux;List a)))", 
            "title": "(take-while p xs)"
        }, 
        {
            "location": "/lux_data_struct_list/#zip2", 
            "text": "(All [a b] (-  (lux;List a) (lux;List b) (lux;List [a b])))", 
            "title": "zip2"
        }, 
        {
            "location": "/lux_data_struct_list/#zip2-with", 
            "text": "(All [a b c] (-  (-  a b c) (lux;List a) (lux;List b) (lux;List c)))", 
            "title": "zip2-with"
        }, 
        {
            "location": "/lux_data_struct_list/#zip3", 
            "text": "(All [a b c] (-  (lux;List a) (lux;List b) (lux;List c) (lux;List [a b c])))", 
            "title": "zip3"
        }, 
        {
            "location": "/lux_data_struct_list/#zip3-with", 
            "text": "(All [a b c d] (-  (-  a b c d) (lux;List a) (lux;List b) (lux;List c) (lux;List d)))", 
            "title": "zip3-with"
        }, 
        {
            "location": "/lux_data_struct_queue/", 
            "text": "lux/data/struct/queue\n\n\nTypes\n\n\nQueue\n\n\n(type: (Queue a)\n  {#front (lux;List a)\n   #rear (lux;List a)})\n\n\n\n\nStructs\n\n\n(Eq\nQueue\n Eq\na\n)\n\n\n(All [a] (-\n (lux/control/eq;Eq a) (lux/control/eq;Eq (Queue a))))\n\n\nValues\n\n\nempty\n\n\nQueue\n\n\nempty?\n\n\n(All [a] (-\n (Queue a) lux;Bool))\n\n\n(from-list entries)\n\n\n(All [a] (-\n (lux;List a) (Queue a)))\n\n\n(member? a/Eq queue member)\n\n\n(All [a] (-\n (lux/control/eq;Eq a) (Queue a) a lux;Bool))\n\n\npeek\n\n\n(All [a] (-\n (Queue a) (lux;Maybe a)))\n\n\n(pop queue)\n\n\n(All [a] (-\n (Queue a) (Queue a)))\n\n\n(push val queue)\n\n\n(All [a] (-\n a (Queue a) (Queue a)))\n\n\n(size queue)\n\n\n(All [a] (-\n (Queue a) lux;Nat))\n\n\n(to-list queue)\n\n\n(All [a] (-\n (Queue a) (lux;List a)))", 
            "title": "Lux data struct queue"
        }, 
        {
            "location": "/lux_data_struct_queue/#luxdatastructqueue", 
            "text": "", 
            "title": "lux/data/struct/queue"
        }, 
        {
            "location": "/lux_data_struct_queue/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_data_struct_queue/#queue", 
            "text": "(type: (Queue a)\n  {#front (lux;List a)\n   #rear (lux;List a)})", 
            "title": "Queue"
        }, 
        {
            "location": "/lux_data_struct_queue/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_data_struct_queue/#eqqueue-eqa", 
            "text": "(All [a] (-  (lux/control/eq;Eq a) (lux/control/eq;Eq (Queue a))))", 
            "title": "(Eq&lt;Queue&gt; Eq&lt;a&gt;)"
        }, 
        {
            "location": "/lux_data_struct_queue/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_struct_queue/#empty", 
            "text": "Queue", 
            "title": "empty"
        }, 
        {
            "location": "/lux_data_struct_queue/#empty_1", 
            "text": "(All [a] (-  (Queue a) lux;Bool))", 
            "title": "empty?"
        }, 
        {
            "location": "/lux_data_struct_queue/#from-list-entries", 
            "text": "(All [a] (-  (lux;List a) (Queue a)))", 
            "title": "(from-list entries)"
        }, 
        {
            "location": "/lux_data_struct_queue/#member-aeq-queue-member", 
            "text": "(All [a] (-  (lux/control/eq;Eq a) (Queue a) a lux;Bool))", 
            "title": "(member? a/Eq queue member)"
        }, 
        {
            "location": "/lux_data_struct_queue/#peek", 
            "text": "(All [a] (-  (Queue a) (lux;Maybe a)))", 
            "title": "peek"
        }, 
        {
            "location": "/lux_data_struct_queue/#pop-queue", 
            "text": "(All [a] (-  (Queue a) (Queue a)))", 
            "title": "(pop queue)"
        }, 
        {
            "location": "/lux_data_struct_queue/#push-val-queue", 
            "text": "(All [a] (-  a (Queue a) (Queue a)))", 
            "title": "(push val queue)"
        }, 
        {
            "location": "/lux_data_struct_queue/#size-queue", 
            "text": "(All [a] (-  (Queue a) lux;Nat))", 
            "title": "(size queue)"
        }, 
        {
            "location": "/lux_data_struct_queue/#to-list-queue", 
            "text": "(All [a] (-  (Queue a) (lux;List a)))", 
            "title": "(to-list queue)"
        }, 
        {
            "location": "/lux_data_struct_set/", 
            "text": "lux/data/struct/set\n\n\nTypes\n\n\nSet\n\n\n(type: (Set a)\n  (lux/data/struct/dict;Dict a a))\n\n\n\n\nStructs\n\n\nEq\nSet\n\n\n(All [a] (lux/control/eq;Eq (Set a)))\n\n\nHash\nSet\n\n\n(All [a] (lux/control/hash;Hash (Set a)))\n\n\nValues\n\n\n(add elem set)\n\n\n(All [a] (-\n a (Set a) (Set a)))\n\n\n(difference subs base)\n\n\n(All [a] (-\n (Set a) (Set a) (Set a)))\n\n\n(empty? set)\n\n\n(All [a] (-\n (Set a) lux;Bool))\n\n\n(from-list Hash\na\n xs)\n\n\n(All [a] (-\n (lux/control/hash;Hash a) (lux;List a) (Set a)))\n\n\n(intersection filter base)\n\n\n(All [a] (-\n (Set a) (Set a) (Set a)))\n\n\n(member? set elem)\n\n\n(All [a] (-\n (Set a) a lux;Bool))\n\n\n(new Hash\na\n)\n\n\n(All [a] (-\n (lux/control/hash;Hash a) (Set a)))\n\n\n(remove elem set)\n\n\n(All [a] (-\n a (Set a) (Set a)))\n\n\n(size set)\n\n\n(All [a] (-\n (Set a) lux;Nat))\n\n\n(sub? super sub)\n\n\n(All [a] (-\n (Set a) (Set a) lux;Bool))\n\n\n(super? sub super)\n\n\n(All [a] (-\n (Set a) (Set a) lux;Bool))\n\n\nto-list\n\n\n(All [a] (-\n (Set a) (lux;List a)))\n\n\n(union xs yx)\n\n\n(All [a] (-\n (Set a) (Set a) (Set a)))", 
            "title": "Lux data struct set"
        }, 
        {
            "location": "/lux_data_struct_set/#luxdatastructset", 
            "text": "", 
            "title": "lux/data/struct/set"
        }, 
        {
            "location": "/lux_data_struct_set/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_data_struct_set/#set", 
            "text": "(type: (Set a)\n  (lux/data/struct/dict;Dict a a))", 
            "title": "Set"
        }, 
        {
            "location": "/lux_data_struct_set/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_data_struct_set/#eqset", 
            "text": "(All [a] (lux/control/eq;Eq (Set a)))", 
            "title": "Eq&lt;Set&gt;"
        }, 
        {
            "location": "/lux_data_struct_set/#hashset", 
            "text": "(All [a] (lux/control/hash;Hash (Set a)))", 
            "title": "Hash&lt;Set&gt;"
        }, 
        {
            "location": "/lux_data_struct_set/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_struct_set/#add-elem-set", 
            "text": "(All [a] (-  a (Set a) (Set a)))", 
            "title": "(add elem set)"
        }, 
        {
            "location": "/lux_data_struct_set/#difference-subs-base", 
            "text": "(All [a] (-  (Set a) (Set a) (Set a)))", 
            "title": "(difference subs base)"
        }, 
        {
            "location": "/lux_data_struct_set/#empty-set", 
            "text": "(All [a] (-  (Set a) lux;Bool))", 
            "title": "(empty? set)"
        }, 
        {
            "location": "/lux_data_struct_set/#from-list-hasha-xs", 
            "text": "(All [a] (-  (lux/control/hash;Hash a) (lux;List a) (Set a)))", 
            "title": "(from-list Hash&lt;a&gt; xs)"
        }, 
        {
            "location": "/lux_data_struct_set/#intersection-filter-base", 
            "text": "(All [a] (-  (Set a) (Set a) (Set a)))", 
            "title": "(intersection filter base)"
        }, 
        {
            "location": "/lux_data_struct_set/#member-set-elem", 
            "text": "(All [a] (-  (Set a) a lux;Bool))", 
            "title": "(member? set elem)"
        }, 
        {
            "location": "/lux_data_struct_set/#new-hasha", 
            "text": "(All [a] (-  (lux/control/hash;Hash a) (Set a)))", 
            "title": "(new Hash&lt;a&gt;)"
        }, 
        {
            "location": "/lux_data_struct_set/#remove-elem-set", 
            "text": "(All [a] (-  a (Set a) (Set a)))", 
            "title": "(remove elem set)"
        }, 
        {
            "location": "/lux_data_struct_set/#size-set", 
            "text": "(All [a] (-  (Set a) lux;Nat))", 
            "title": "(size set)"
        }, 
        {
            "location": "/lux_data_struct_set/#sub-super-sub", 
            "text": "(All [a] (-  (Set a) (Set a) lux;Bool))", 
            "title": "(sub? super sub)"
        }, 
        {
            "location": "/lux_data_struct_set/#super-sub-super", 
            "text": "(All [a] (-  (Set a) (Set a) lux;Bool))", 
            "title": "(super? sub super)"
        }, 
        {
            "location": "/lux_data_struct_set/#to-list", 
            "text": "(All [a] (-  (Set a) (lux;List a)))", 
            "title": "to-list"
        }, 
        {
            "location": "/lux_data_struct_set/#union-xs-yx", 
            "text": "(All [a] (-  (Set a) (Set a) (Set a)))", 
            "title": "(union xs yx)"
        }, 
        {
            "location": "/lux_data_struct_stack/", 
            "text": "lux/data/struct/stack\n\n\nTypes\n\n\nStack\n\n\n(type: (Stack a)\n  (lux;List a))\n\n\n\n\nValues\n\n\nempty\n\n\nStack\n\n\n(empty? stack)\n\n\n(All [a] (-\n (Stack a) lux;Bool))\n\n\n(peek stack)\n\n\n(All [a] (-\n (Stack a) (lux;Maybe a)))\n\n\n(pop stack)\n\n\n(All [a] (-\n (Stack a) (Stack a)))\n\n\n(push value stack)\n\n\n(All [a] (-\n a (Stack a) (Stack a)))\n\n\n(size stack)\n\n\n(All [a] (-\n (Stack a) lux;Nat))", 
            "title": "Lux data struct stack"
        }, 
        {
            "location": "/lux_data_struct_stack/#luxdatastructstack", 
            "text": "", 
            "title": "lux/data/struct/stack"
        }, 
        {
            "location": "/lux_data_struct_stack/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_data_struct_stack/#stack", 
            "text": "(type: (Stack a)\n  (lux;List a))", 
            "title": "Stack"
        }, 
        {
            "location": "/lux_data_struct_stack/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_struct_stack/#empty", 
            "text": "Stack", 
            "title": "empty"
        }, 
        {
            "location": "/lux_data_struct_stack/#empty-stack", 
            "text": "(All [a] (-  (Stack a) lux;Bool))", 
            "title": "(empty? stack)"
        }, 
        {
            "location": "/lux_data_struct_stack/#peek-stack", 
            "text": "(All [a] (-  (Stack a) (lux;Maybe a)))", 
            "title": "(peek stack)"
        }, 
        {
            "location": "/lux_data_struct_stack/#pop-stack", 
            "text": "(All [a] (-  (Stack a) (Stack a)))", 
            "title": "(pop stack)"
        }, 
        {
            "location": "/lux_data_struct_stack/#push-value-stack", 
            "text": "(All [a] (-  a (Stack a) (Stack a)))", 
            "title": "(push value stack)"
        }, 
        {
            "location": "/lux_data_struct_stack/#size-stack", 
            "text": "(All [a] (-  (Stack a) lux;Nat))", 
            "title": "(size stack)"
        }, 
        {
            "location": "/lux_data_struct_tree/", 
            "text": "lux/data/struct/tree\n\n\nTypes\n\n\nTree\n\n\n(type: (Tree a)\n  {#value a\n   #children (lux;List (Tree a))})\n\n\n\n\nMacros\n\n\ntree\n\n\n## Tree literals.\n(tree Int 10)\n\n(tree Int {10 [20\n               {30 []}\n               40]})\n\n\n\n\nStructs\n\n\n(Eq\nTree\n Eq\na\n)\n\n\n(All [a] (-\n (lux/control/eq;Eq a) (lux/control/eq;Eq (Tree a))))\n\n\nValues\n\n\n(branch value children)\n\n\n(All [a] (-\n a (lux;List (Tree a)) (Tree a)))\n\n\n(flatten tree)\n\n\n(All [a] (-\n (Tree a) (lux;List a)))\n\n\n(leaf value)\n\n\n(All [a] (-\n a (Tree a)))", 
            "title": "Lux data struct tree"
        }, 
        {
            "location": "/lux_data_struct_tree/#luxdatastructtree", 
            "text": "", 
            "title": "lux/data/struct/tree"
        }, 
        {
            "location": "/lux_data_struct_tree/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_data_struct_tree/#tree", 
            "text": "(type: (Tree a)\n  {#value a\n   #children (lux;List (Tree a))})", 
            "title": "Tree"
        }, 
        {
            "location": "/lux_data_struct_tree/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_data_struct_tree/#tree_1", 
            "text": "## Tree literals.\n(tree Int 10)\n\n(tree Int {10 [20\n               {30 []}\n               40]})", 
            "title": "tree"
        }, 
        {
            "location": "/lux_data_struct_tree/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_data_struct_tree/#eqtree-eqa", 
            "text": "(All [a] (-  (lux/control/eq;Eq a) (lux/control/eq;Eq (Tree a))))", 
            "title": "(Eq&lt;Tree&gt; Eq&lt;a&gt;)"
        }, 
        {
            "location": "/lux_data_struct_tree/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_struct_tree/#branch-value-children", 
            "text": "(All [a] (-  a (lux;List (Tree a)) (Tree a)))", 
            "title": "(branch value children)"
        }, 
        {
            "location": "/lux_data_struct_tree/#flatten-tree", 
            "text": "(All [a] (-  (Tree a) (lux;List a)))", 
            "title": "(flatten tree)"
        }, 
        {
            "location": "/lux_data_struct_tree/#leaf-value", 
            "text": "(All [a] (-  a (Tree a)))", 
            "title": "(leaf value)"
        }, 
        {
            "location": "/lux_data_struct_vector/", 
            "text": "lux/data/struct/vector\n\n\nTypes\n\n\nVector\n\n\n(type: (Vector a)\n  {#level Level\n   #size lux;Nat\n   #root (Hierarchy a)\n   #tail (Base a)})\n\n\n\n\nMacros\n\n\nvector\n\n\n## Vector literals.\n(vector 10 20 30 40)\n\n\n\n\nStructs\n\n\nApplicative\nVector\n\n\n(lux/control/applicative;Applicative Vector)\n\n\n(Eq\nNode\n Eq\na\n)\n\n\n(All [a] (-\n (lux/control/eq;Eq a) (lux/control/eq;Eq (Node a))))\n\n\n(Eq\nVector\n Eq\na\n)\n\n\n(All [a] (-\n (lux/control/eq;Eq a) (lux/control/eq;Eq (Vector a))))\n\n\nFold\nVector\n\n\n(lux/control/fold;Fold Vector)\n\n\nFunctor\nVector\n\n\n(lux/control/functor;Functor Vector)\n\n\nMonad\nVector\n\n\n(lux/control/monad;Monad Vector)\n\n\nMonoid\nVector\n\n\n(All [a] (lux/control/monoid;Monoid (Vector a)))\n\n\nValues\n\n\n(add val vec)\n\n\n(All [a] (-\n a (Vector a) (Vector a)))\n\n\n(at idx vec)\n\n\n(All [a] (-\n lux;Nat (Vector a) (lux;Maybe a)))\n\n\nempty\n\n\nVector\n\n\nempty?\n\n\n(All [a] (-\n (Vector a) lux;Bool))\n\n\n(from-list list)\n\n\n(All [a] (-\n (lux;List a) (Vector a)))\n\n\n(member? a/Eq vec val)\n\n\n(All [a] (-\n (lux/control/eq;Eq a) (Vector a) a lux;Bool))\n\n\n(pop vec)\n\n\n(All [a] (-\n (Vector a) (Vector a)))\n\n\n(put idx val vec)\n\n\n(All [a] (-\n lux;Nat a (Vector a) (Vector a)))\n\n\n(size vector)\n\n\n(All [a] (-\n (Vector a) lux;Nat))\n\n\n(to-list vec)\n\n\n(All [a] (-\n (Vector a) (lux;List a)))\n\n\n(update idx f vec)\n\n\n(All [a] (-\n lux;Nat (-\n a a) (Vector a) (Vector a)))", 
            "title": "Lux data struct vector"
        }, 
        {
            "location": "/lux_data_struct_vector/#luxdatastructvector", 
            "text": "", 
            "title": "lux/data/struct/vector"
        }, 
        {
            "location": "/lux_data_struct_vector/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_data_struct_vector/#vector", 
            "text": "(type: (Vector a)\n  {#level Level\n   #size lux;Nat\n   #root (Hierarchy a)\n   #tail (Base a)})", 
            "title": "Vector"
        }, 
        {
            "location": "/lux_data_struct_vector/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_data_struct_vector/#vector_1", 
            "text": "## Vector literals.\n(vector 10 20 30 40)", 
            "title": "vector"
        }, 
        {
            "location": "/lux_data_struct_vector/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_data_struct_vector/#applicativevector", 
            "text": "(lux/control/applicative;Applicative Vector)", 
            "title": "Applicative&lt;Vector&gt;"
        }, 
        {
            "location": "/lux_data_struct_vector/#eqnode-eqa", 
            "text": "(All [a] (-  (lux/control/eq;Eq a) (lux/control/eq;Eq (Node a))))", 
            "title": "(Eq&lt;Node&gt; Eq&lt;a&gt;)"
        }, 
        {
            "location": "/lux_data_struct_vector/#eqvector-eqa", 
            "text": "(All [a] (-  (lux/control/eq;Eq a) (lux/control/eq;Eq (Vector a))))", 
            "title": "(Eq&lt;Vector&gt; Eq&lt;a&gt;)"
        }, 
        {
            "location": "/lux_data_struct_vector/#foldvector", 
            "text": "(lux/control/fold;Fold Vector)", 
            "title": "Fold&lt;Vector&gt;"
        }, 
        {
            "location": "/lux_data_struct_vector/#functorvector", 
            "text": "(lux/control/functor;Functor Vector)", 
            "title": "Functor&lt;Vector&gt;"
        }, 
        {
            "location": "/lux_data_struct_vector/#monadvector", 
            "text": "(lux/control/monad;Monad Vector)", 
            "title": "Monad&lt;Vector&gt;"
        }, 
        {
            "location": "/lux_data_struct_vector/#monoidvector", 
            "text": "(All [a] (lux/control/monoid;Monoid (Vector a)))", 
            "title": "Monoid&lt;Vector&gt;"
        }, 
        {
            "location": "/lux_data_struct_vector/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_struct_vector/#add-val-vec", 
            "text": "(All [a] (-  a (Vector a) (Vector a)))", 
            "title": "(add val vec)"
        }, 
        {
            "location": "/lux_data_struct_vector/#at-idx-vec", 
            "text": "(All [a] (-  lux;Nat (Vector a) (lux;Maybe a)))", 
            "title": "(at idx vec)"
        }, 
        {
            "location": "/lux_data_struct_vector/#empty", 
            "text": "Vector", 
            "title": "empty"
        }, 
        {
            "location": "/lux_data_struct_vector/#empty_1", 
            "text": "(All [a] (-  (Vector a) lux;Bool))", 
            "title": "empty?"
        }, 
        {
            "location": "/lux_data_struct_vector/#from-list-list", 
            "text": "(All [a] (-  (lux;List a) (Vector a)))", 
            "title": "(from-list list)"
        }, 
        {
            "location": "/lux_data_struct_vector/#member-aeq-vec-val", 
            "text": "(All [a] (-  (lux/control/eq;Eq a) (Vector a) a lux;Bool))", 
            "title": "(member? a/Eq vec val)"
        }, 
        {
            "location": "/lux_data_struct_vector/#pop-vec", 
            "text": "(All [a] (-  (Vector a) (Vector a)))", 
            "title": "(pop vec)"
        }, 
        {
            "location": "/lux_data_struct_vector/#put-idx-val-vec", 
            "text": "(All [a] (-  lux;Nat a (Vector a) (Vector a)))", 
            "title": "(put idx val vec)"
        }, 
        {
            "location": "/lux_data_struct_vector/#size-vector", 
            "text": "(All [a] (-  (Vector a) lux;Nat))", 
            "title": "(size vector)"
        }, 
        {
            "location": "/lux_data_struct_vector/#to-list-vec", 
            "text": "(All [a] (-  (Vector a) (lux;List a)))", 
            "title": "(to-list vec)"
        }, 
        {
            "location": "/lux_data_struct_vector/#update-idx-f-vec", 
            "text": "(All [a] (-  lux;Nat (-  a a) (Vector a) (Vector a)))", 
            "title": "(update idx f vec)"
        }, 
        {
            "location": "/lux_data_struct_zipper/", 
            "text": "lux/data/struct/zipper\n\n\nTypes\n\n\nZipper\n\n\nTree zippers, for easy navigation and editing over trees.\n\n\n(type: (Zipper a)\n  {#parent (lux;Maybe (Zipper a))\n   #lefts (lux/data/struct/stack;Stack (lux/data/struct/tree;Tree a))\n   #rights (lux/data/struct/stack;Stack (lux/data/struct/tree;Tree a))\n   #node (lux/data/struct/tree;Tree a)})\n\n\n\n\nValues\n\n\n(append-child value zipper)\n\n\n(All [a] (-\n a (Zipper a) (Zipper a)))\n\n\n(branch? zipper)\n\n\n(All [a] (-\n (Zipper a) lux;Bool))\n\n\n(children zipper)\n\n\n(All [a] (-\n (Zipper a) (lux;List (lux/data/struct/tree;Tree a))))\n\n\n(down zipper)\n\n\n(All [a] (-\n (Zipper a) (Zipper a)))\n\n\n(end? zipper)\n\n\n(All [a] (-\n (Zipper a) lux;Bool))\n\n\n(from-tree tree)\n\n\n(All [a] (-\n (lux/data/struct/tree;Tree a) (Zipper a)))\n\n\n(insert-left value zipper)\n\n\n(All [a] (-\n a (Zipper a) (lux;Maybe (Zipper a))))\n\n\n(insert-right value zipper)\n\n\n(All [a] (-\n a (Zipper a) (lux;Maybe (Zipper a))))\n\n\n(leaf? zipper)\n\n\n(All [a] (-\n (Zipper a) lux;Bool))\n\n\n(left zipper)\n\n\n(All [a] (-\n (Zipper a) (Zipper a)))\n\n\n(leftmost zipper)\n\n\n(All [a] (-\n (Zipper a) (Zipper a)))\n\n\n(next zipper)\n\n\n(All [a] (-\n (Zipper a) (Zipper a)))\n\n\n(parent zipper)\n\n\n(All [a] (-\n (Zipper a) (lux;Maybe (Zipper a))))\n\n\n(prepend-child value zipper)\n\n\n(All [a] (-\n a (Zipper a) (Zipper a)))\n\n\n(prev zipper)\n\n\n(All [a] (-\n (Zipper a) (Zipper a)))\n\n\n(remove zipper)\n\n\n(All [a] (-\n (Zipper a) (lux;Maybe (Zipper a))))\n\n\n(right zipper)\n\n\n(All [a] (-\n (Zipper a) (Zipper a)))\n\n\n(rightmost zipper)\n\n\n(All [a] (-\n (Zipper a) (Zipper a)))\n\n\n(root zipper)\n\n\n(All [a] (-\n (Zipper a) (Zipper a)))\n\n\n(root? zipper)\n\n\n(All [a] (-\n (Zipper a) lux;Bool))\n\n\n(set value zipper)\n\n\n(All [a] (-\n a (Zipper a) (Zipper a)))\n\n\n(to-tree zipper)\n\n\n(All [a] (-\n (Zipper a) (lux/data/struct/tree;Tree a)))\n\n\n(up zipper)\n\n\n(All [a] (-\n (Zipper a) (Zipper a)))\n\n\n(update f zipper)\n\n\n(All [a] (-\n (-\n a a) (Zipper a) (Zipper a)))\n\n\n(value zipper)\n\n\n(All [a] (-\n (Zipper a) a))", 
            "title": "Lux data struct zipper"
        }, 
        {
            "location": "/lux_data_struct_zipper/#luxdatastructzipper", 
            "text": "", 
            "title": "lux/data/struct/zipper"
        }, 
        {
            "location": "/lux_data_struct_zipper/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_data_struct_zipper/#zipper", 
            "text": "Tree zippers, for easy navigation and editing over trees.  (type: (Zipper a)\n  {#parent (lux;Maybe (Zipper a))\n   #lefts (lux/data/struct/stack;Stack (lux/data/struct/tree;Tree a))\n   #rights (lux/data/struct/stack;Stack (lux/data/struct/tree;Tree a))\n   #node (lux/data/struct/tree;Tree a)})", 
            "title": "Zipper"
        }, 
        {
            "location": "/lux_data_struct_zipper/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_struct_zipper/#append-child-value-zipper", 
            "text": "(All [a] (-  a (Zipper a) (Zipper a)))", 
            "title": "(append-child value zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#branch-zipper", 
            "text": "(All [a] (-  (Zipper a) lux;Bool))", 
            "title": "(branch? zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#children-zipper", 
            "text": "(All [a] (-  (Zipper a) (lux;List (lux/data/struct/tree;Tree a))))", 
            "title": "(children zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#down-zipper", 
            "text": "(All [a] (-  (Zipper a) (Zipper a)))", 
            "title": "(down zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#end-zipper", 
            "text": "(All [a] (-  (Zipper a) lux;Bool))", 
            "title": "(end? zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#from-tree-tree", 
            "text": "(All [a] (-  (lux/data/struct/tree;Tree a) (Zipper a)))", 
            "title": "(from-tree tree)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#insert-left-value-zipper", 
            "text": "(All [a] (-  a (Zipper a) (lux;Maybe (Zipper a))))", 
            "title": "(insert-left value zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#insert-right-value-zipper", 
            "text": "(All [a] (-  a (Zipper a) (lux;Maybe (Zipper a))))", 
            "title": "(insert-right value zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#leaf-zipper", 
            "text": "(All [a] (-  (Zipper a) lux;Bool))", 
            "title": "(leaf? zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#left-zipper", 
            "text": "(All [a] (-  (Zipper a) (Zipper a)))", 
            "title": "(left zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#leftmost-zipper", 
            "text": "(All [a] (-  (Zipper a) (Zipper a)))", 
            "title": "(leftmost zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#next-zipper", 
            "text": "(All [a] (-  (Zipper a) (Zipper a)))", 
            "title": "(next zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#parent-zipper", 
            "text": "(All [a] (-  (Zipper a) (lux;Maybe (Zipper a))))", 
            "title": "(parent zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#prepend-child-value-zipper", 
            "text": "(All [a] (-  a (Zipper a) (Zipper a)))", 
            "title": "(prepend-child value zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#prev-zipper", 
            "text": "(All [a] (-  (Zipper a) (Zipper a)))", 
            "title": "(prev zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#remove-zipper", 
            "text": "(All [a] (-  (Zipper a) (lux;Maybe (Zipper a))))", 
            "title": "(remove zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#right-zipper", 
            "text": "(All [a] (-  (Zipper a) (Zipper a)))", 
            "title": "(right zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#rightmost-zipper", 
            "text": "(All [a] (-  (Zipper a) (Zipper a)))", 
            "title": "(rightmost zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#root-zipper", 
            "text": "(All [a] (-  (Zipper a) (Zipper a)))", 
            "title": "(root zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#root-zipper_1", 
            "text": "(All [a] (-  (Zipper a) lux;Bool))", 
            "title": "(root? zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#set-value-zipper", 
            "text": "(All [a] (-  a (Zipper a) (Zipper a)))", 
            "title": "(set value zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#to-tree-zipper", 
            "text": "(All [a] (-  (Zipper a) (lux/data/struct/tree;Tree a)))", 
            "title": "(to-tree zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#up-zipper", 
            "text": "(All [a] (-  (Zipper a) (Zipper a)))", 
            "title": "(up zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#update-f-zipper", 
            "text": "(All [a] (-  (-  a a) (Zipper a) (Zipper a)))", 
            "title": "(update f zipper)"
        }, 
        {
            "location": "/lux_data_struct_zipper/#value-zipper", 
            "text": "(All [a] (-  (Zipper a) a))", 
            "title": "(value zipper)"
        }, 
        {
            "location": "/lux_data_sum/", 
            "text": "lux/data/sum\n\n\n\n\nFunctionality for working with variants (particularly 2-variants).\n\n\n\n\nValues\n\n\n(either f g s)\n\n\n(All [a b c] (-\n (-\n a c) (-\n b c) (| a b) c))\n\n\n(left value)\n\n\n(All [a b] (-\n a (| a b)))\n\n\n(lefts es)\n\n\n(All [a b] (-\n (lux;List (| a b)) (lux;List a)))\n\n\n(partition xs)\n\n\n(All [a b] (-\n (lux;List (| a b)) [(lux;List a) (lux;List b)]))\n\n\n(right value)\n\n\n(All [a b] (-\n b (| a b)))\n\n\n(rights es)\n\n\n(All [a b] (-\n (lux;List (| a b)) (lux;List b)))", 
            "title": "Lux data sum"
        }, 
        {
            "location": "/lux_data_sum/#luxdatasum", 
            "text": "Functionality for working with variants (particularly 2-variants).", 
            "title": "lux/data/sum"
        }, 
        {
            "location": "/lux_data_sum/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_sum/#either-f-g-s", 
            "text": "(All [a b c] (-  (-  a c) (-  b c) (| a b) c))", 
            "title": "(either f g s)"
        }, 
        {
            "location": "/lux_data_sum/#left-value", 
            "text": "(All [a b] (-  a (| a b)))", 
            "title": "(left value)"
        }, 
        {
            "location": "/lux_data_sum/#lefts-es", 
            "text": "(All [a b] (-  (lux;List (| a b)) (lux;List a)))", 
            "title": "(lefts es)"
        }, 
        {
            "location": "/lux_data_sum/#partition-xs", 
            "text": "(All [a b] (-  (lux;List (| a b)) [(lux;List a) (lux;List b)]))", 
            "title": "(partition xs)"
        }, 
        {
            "location": "/lux_data_sum/#right-value", 
            "text": "(All [a b] (-  b (| a b)))", 
            "title": "(right value)"
        }, 
        {
            "location": "/lux_data_sum/#rights-es", 
            "text": "(All [a b] (-  (lux;List (| a b)) (lux;List b)))", 
            "title": "(rights es)"
        }, 
        {
            "location": "/lux_data_text/", 
            "text": "lux/data/text\n\n\nStructs\n\n\nCodec\nText,Text\n\n\n(lux/control/codec;Codec lux;Text lux;Text)\n\n\nEq\nText\n\n\n(lux/control/eq;Eq lux;Text)\n\n\nHash\nText\n\n\n(lux/control/hash;Hash lux;Text)\n\n\nMonoid\nText\n\n\n(lux/control/monoid;Monoid lux;Text)\n\n\nOrd\nText\n\n\n(lux/control/ord;Ord lux;Text)\n\n\nValues\n\n\n(at idx x)\n\n\n(-\n lux;Nat lux;Text (lux;Maybe lux;Char))\n\n\nconcat\n\n\n(-\n (lux;List lux;Text) lux;Text)\n\n\n(contains? sub text)\n\n\n(-\n lux;Text lux;Text lux;Bool)\n\n\n(empty? text)\n\n\n(-\n lux;Text lux;Bool)\n\n\n(enclose [left right] content)\n\n\nSurrounds the given content text with left and right side additions.\n\n\n\n\n(-\n [lux;Text lux;Text] lux;Text lux;Text)\n\n\n(enclose' boundary content)\n\n\nSurrounds the given content text with the same boundary text.\n\n\n\n\n(-\n lux;Text lux;Text lux;Text)\n\n\n(ends-with? postfix x)\n\n\n(-\n lux;Text lux;Text lux;Bool)\n\n\n(index-of pattern x)\n\n\n(-\n lux;Text lux;Text (lux;Maybe lux;Nat))\n\n\n(index-of' pattern from x)\n\n\n(-\n lux;Text lux;Nat lux;Text (lux;Maybe lux;Nat))\n\n\n(join-with sep texts)\n\n\n(-\n lux;Text (lux;List lux;Text) lux;Text)\n\n\n(last-index-of pattern x)\n\n\n(-\n lux;Text lux;Text (lux;Maybe lux;Nat))\n\n\n(last-index-of' pattern from x)\n\n\n(-\n lux;Text lux;Nat lux;Text (lux;Maybe lux;Nat))\n\n\n(lower-case x)\n\n\n(-\n lux;Text lux;Text)\n\n\n(replace pattern value template)\n\n\n(-\n lux;Text lux;Text lux;Text lux;Text)\n\n\n(replace-once pattern value template)\n\n\n(-\n lux;Text lux;Text lux;Text lux;Text)\n\n\n(size x)\n\n\n(-\n lux;Text lux;Nat)\n\n\n(split at x)\n\n\n(-\n lux;Nat lux;Text (lux;Maybe [lux;Text lux;Text]))\n\n\n(split-all-with token sample)\n\n\n(-\n lux;Text lux;Text (lux;List lux;Text))\n\n\nsplit-lines\n\n\n(-\n lux;Text (lux;List lux;Text))\n\n\n(split-with token sample)\n\n\n(-\n lux;Text lux;Text (lux;Maybe [lux;Text lux;Text]))\n\n\n(starts-with? prefix x)\n\n\n(-\n lux;Text lux;Text lux;Bool)\n\n\n(sub from to x)\n\n\n(-\n lux;Nat lux;Nat lux;Text (lux;Maybe lux;Text))\n\n\n(sub' from x)\n\n\n(-\n lux;Nat lux;Text (lux;Maybe lux;Text))\n\n\n(trim x)\n\n\n(-\n lux;Text lux;Text)\n\n\n(upper-case x)\n\n\n(-\n lux;Text lux;Text)", 
            "title": "Lux data text"
        }, 
        {
            "location": "/lux_data_text/#luxdatatext", 
            "text": "", 
            "title": "lux/data/text"
        }, 
        {
            "location": "/lux_data_text/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_data_text/#codectexttext", 
            "text": "(lux/control/codec;Codec lux;Text lux;Text)", 
            "title": "Codec&lt;Text,Text&gt;"
        }, 
        {
            "location": "/lux_data_text/#eqtext", 
            "text": "(lux/control/eq;Eq lux;Text)", 
            "title": "Eq&lt;Text&gt;"
        }, 
        {
            "location": "/lux_data_text/#hashtext", 
            "text": "(lux/control/hash;Hash lux;Text)", 
            "title": "Hash&lt;Text&gt;"
        }, 
        {
            "location": "/lux_data_text/#monoidtext", 
            "text": "(lux/control/monoid;Monoid lux;Text)", 
            "title": "Monoid&lt;Text&gt;"
        }, 
        {
            "location": "/lux_data_text/#ordtext", 
            "text": "(lux/control/ord;Ord lux;Text)", 
            "title": "Ord&lt;Text&gt;"
        }, 
        {
            "location": "/lux_data_text/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_text/#at-idx-x", 
            "text": "(-  lux;Nat lux;Text (lux;Maybe lux;Char))", 
            "title": "(at idx x)"
        }, 
        {
            "location": "/lux_data_text/#concat", 
            "text": "(-  (lux;List lux;Text) lux;Text)", 
            "title": "concat"
        }, 
        {
            "location": "/lux_data_text/#contains-sub-text", 
            "text": "(-  lux;Text lux;Text lux;Bool)", 
            "title": "(contains? sub text)"
        }, 
        {
            "location": "/lux_data_text/#empty-text", 
            "text": "(-  lux;Text lux;Bool)", 
            "title": "(empty? text)"
        }, 
        {
            "location": "/lux_data_text/#enclose-left-right-content", 
            "text": "Surrounds the given content text with left and right side additions.  (-  [lux;Text lux;Text] lux;Text lux;Text)", 
            "title": "(enclose [left right] content)"
        }, 
        {
            "location": "/lux_data_text/#enclose-boundary-content", 
            "text": "Surrounds the given content text with the same boundary text.  (-  lux;Text lux;Text lux;Text)", 
            "title": "(enclose' boundary content)"
        }, 
        {
            "location": "/lux_data_text/#ends-with-postfix-x", 
            "text": "(-  lux;Text lux;Text lux;Bool)", 
            "title": "(ends-with? postfix x)"
        }, 
        {
            "location": "/lux_data_text/#index-of-pattern-x", 
            "text": "(-  lux;Text lux;Text (lux;Maybe lux;Nat))", 
            "title": "(index-of pattern x)"
        }, 
        {
            "location": "/lux_data_text/#index-of-pattern-from-x", 
            "text": "(-  lux;Text lux;Nat lux;Text (lux;Maybe lux;Nat))", 
            "title": "(index-of' pattern from x)"
        }, 
        {
            "location": "/lux_data_text/#join-with-sep-texts", 
            "text": "(-  lux;Text (lux;List lux;Text) lux;Text)", 
            "title": "(join-with sep texts)"
        }, 
        {
            "location": "/lux_data_text/#last-index-of-pattern-x", 
            "text": "(-  lux;Text lux;Text (lux;Maybe lux;Nat))", 
            "title": "(last-index-of pattern x)"
        }, 
        {
            "location": "/lux_data_text/#last-index-of-pattern-from-x", 
            "text": "(-  lux;Text lux;Nat lux;Text (lux;Maybe lux;Nat))", 
            "title": "(last-index-of' pattern from x)"
        }, 
        {
            "location": "/lux_data_text/#lower-case-x", 
            "text": "(-  lux;Text lux;Text)", 
            "title": "(lower-case x)"
        }, 
        {
            "location": "/lux_data_text/#replace-pattern-value-template", 
            "text": "(-  lux;Text lux;Text lux;Text lux;Text)", 
            "title": "(replace pattern value template)"
        }, 
        {
            "location": "/lux_data_text/#replace-once-pattern-value-template", 
            "text": "(-  lux;Text lux;Text lux;Text lux;Text)", 
            "title": "(replace-once pattern value template)"
        }, 
        {
            "location": "/lux_data_text/#size-x", 
            "text": "(-  lux;Text lux;Nat)", 
            "title": "(size x)"
        }, 
        {
            "location": "/lux_data_text/#split-at-x", 
            "text": "(-  lux;Nat lux;Text (lux;Maybe [lux;Text lux;Text]))", 
            "title": "(split at x)"
        }, 
        {
            "location": "/lux_data_text/#split-all-with-token-sample", 
            "text": "(-  lux;Text lux;Text (lux;List lux;Text))", 
            "title": "(split-all-with token sample)"
        }, 
        {
            "location": "/lux_data_text/#split-lines", 
            "text": "(-  lux;Text (lux;List lux;Text))", 
            "title": "split-lines"
        }, 
        {
            "location": "/lux_data_text/#split-with-token-sample", 
            "text": "(-  lux;Text lux;Text (lux;Maybe [lux;Text lux;Text]))", 
            "title": "(split-with token sample)"
        }, 
        {
            "location": "/lux_data_text/#starts-with-prefix-x", 
            "text": "(-  lux;Text lux;Text lux;Bool)", 
            "title": "(starts-with? prefix x)"
        }, 
        {
            "location": "/lux_data_text/#sub-from-to-x", 
            "text": "(-  lux;Nat lux;Nat lux;Text (lux;Maybe lux;Text))", 
            "title": "(sub from to x)"
        }, 
        {
            "location": "/lux_data_text/#sub-from-x", 
            "text": "(-  lux;Nat lux;Text (lux;Maybe lux;Text))", 
            "title": "(sub' from x)"
        }, 
        {
            "location": "/lux_data_text/#trim-x", 
            "text": "(-  lux;Text lux;Text)", 
            "title": "(trim x)"
        }, 
        {
            "location": "/lux_data_text/#upper-case-x", 
            "text": "(-  lux;Text lux;Text)", 
            "title": "(upper-case x)"
        }, 
        {
            "location": "/lux_data_text_format/", 
            "text": "lux/data/text/format\n\n\nTypes\n\n\nFormatter\n\n\nA way to produce readable text from values.\n\n\n(type: (Formatter a)\n  (-\n a lux;Text))\n\n\n\n\nMacros\n\n\nformat\n\n\n## Text interpolation as a macro.\n(format \nStatic part \n (%t static) \n doesn't match URI: \n uri)\n\n\n\n\nValues\n\n\n%ast\n\n\n(Formatter lux;AST)\n\n\n%b\n\n\n(Formatter lux;Bool)\n\n\n%bin\n\n\n(Formatter lux;Nat)\n\n\n%c\n\n\n(Formatter lux;Char)\n\n\n%f\n\n\n(Formatter lux;Frac)\n\n\n%hex\n\n\n(Formatter lux;Nat)\n\n\n%i\n\n\n(Formatter lux;Int)\n\n\n%ident\n\n\n(Formatter lux;Ident)\n\n\n(%list formatter)\n\n\n(All [a] (-\n (Formatter a) (Formatter (lux;List a))))\n\n\n%n\n\n\n(Formatter lux;Nat)\n\n\n%oct\n\n\n(Formatter lux;Nat)\n\n\n%r\n\n\n(Formatter lux;Real)\n\n\n%t\n\n\n(Formatter lux;Text)\n\n\n%type\n\n\n(Formatter lux;Type)", 
            "title": "Lux data text format"
        }, 
        {
            "location": "/lux_data_text_format/#luxdatatextformat", 
            "text": "", 
            "title": "lux/data/text/format"
        }, 
        {
            "location": "/lux_data_text_format/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_data_text_format/#formatter", 
            "text": "A way to produce readable text from values.  (type: (Formatter a)\n  (-  a lux;Text))", 
            "title": "Formatter"
        }, 
        {
            "location": "/lux_data_text_format/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_data_text_format/#format", 
            "text": "## Text interpolation as a macro.\n(format  Static part   (%t static)   doesn't match URI:   uri)", 
            "title": "format"
        }, 
        {
            "location": "/lux_data_text_format/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_data_text_format/#ast", 
            "text": "(Formatter lux;AST)", 
            "title": "%ast"
        }, 
        {
            "location": "/lux_data_text_format/#b", 
            "text": "(Formatter lux;Bool)", 
            "title": "%b"
        }, 
        {
            "location": "/lux_data_text_format/#bin", 
            "text": "(Formatter lux;Nat)", 
            "title": "%bin"
        }, 
        {
            "location": "/lux_data_text_format/#c", 
            "text": "(Formatter lux;Char)", 
            "title": "%c"
        }, 
        {
            "location": "/lux_data_text_format/#f", 
            "text": "(Formatter lux;Frac)", 
            "title": "%f"
        }, 
        {
            "location": "/lux_data_text_format/#hex", 
            "text": "(Formatter lux;Nat)", 
            "title": "%hex"
        }, 
        {
            "location": "/lux_data_text_format/#i", 
            "text": "(Formatter lux;Int)", 
            "title": "%i"
        }, 
        {
            "location": "/lux_data_text_format/#ident", 
            "text": "(Formatter lux;Ident)", 
            "title": "%ident"
        }, 
        {
            "location": "/lux_data_text_format/#list-formatter", 
            "text": "(All [a] (-  (Formatter a) (Formatter (lux;List a))))", 
            "title": "(%list formatter)"
        }, 
        {
            "location": "/lux_data_text_format/#n", 
            "text": "(Formatter lux;Nat)", 
            "title": "%n"
        }, 
        {
            "location": "/lux_data_text_format/#oct", 
            "text": "(Formatter lux;Nat)", 
            "title": "%oct"
        }, 
        {
            "location": "/lux_data_text_format/#r", 
            "text": "(Formatter lux;Real)", 
            "title": "%r"
        }, 
        {
            "location": "/lux_data_text_format/#t", 
            "text": "(Formatter lux;Text)", 
            "title": "%t"
        }, 
        {
            "location": "/lux_data_text_format/#type", 
            "text": "(Formatter lux;Type)", 
            "title": "%type"
        }, 
        {
            "location": "/lux_host/", 
            "text": "lux/host\n\n\nTypes\n\n\nBoolean-Array\n\n\n(type: Boolean-Array\n  (host [Z))\n\n\n\n\nByte-Array\n\n\n(type: Byte-Array\n  (host [B))\n\n\n\n\nChar-Array\n\n\n(type: Char-Array\n  (host [C))\n\n\n\n\nDouble-Array\n\n\n(type: Double-Array\n  (host [D))\n\n\n\n\nFloat-Array\n\n\n(type: Float-Array\n  (host [F))\n\n\n\n\nInt-Array\n\n\n(type: Int-Array\n  (host [I))\n\n\n\n\nLong-Array\n\n\n(type: Long-Array\n  (host [J))\n\n\n\n\nShort-Array\n\n\n(type: Short-Array\n  (host [S))\n\n\n\n\nMacros\n\n\n!!!\n\n\n## Takes a (Maybe ObjectType) and returns a ObjectType.\n## A #;None would get translated into a (null).\n(!!! (??? (: java.lang.Thread (null))))\n\n## =\n\n(null)\n\n(!!! (??? \nYOLO\n))\n\n## =\n\n## YOLO\n\n\n\n\n???\n\n\n## Takes a (potentially null) ObjectType reference and creates a (Maybe ObjectType) for it.\n(??? (: java.lang.String (null)))\n\n## =\n\n#lux;None\n\n(??? \nYOLO\n)\n\n## =\n\n(#lux;Some\nYOLO\n)\n\n\n\n\narray\n\n\n## Create an array of the given type, with the given size.\n(array Object +10)\n\n\n\n\narray-length\n\n\n## Gives the length of an array.\n(array-length my-array)\n\n\n\n\narray-load\n\n\n## Loads an element from an array.\n(array-load 10 my-array)\n\n\n\n\narray-store\n\n\n## Stores an element into an array.\n(array-store 10 my-object my-array)\n\n\n\n\nclass-for\n\n\n## Loads the class as a java.lang.Class object.\n(class-for java.lang.String)\n\n\n\n\nclass:\n\n\n## Allows defining JVM classes in Lux code.\n## For example:\n(class: #final (JvmPromise A) []\n\n  (#private resolved boolean)\n  (#private datum A)\n  (#private waitingList (java.util.List lux.Function))\n\n  (#public [] new [] []\n           (exec (:= .resolved false)\n             (:= .waitingList (ArrayList.new []))\n             []))\n  (#public [] resolve [{value A}] boolean\n           (let [container (.new! [])]\n             (synchronized _jvm_this\n               (if .resolved\n                 false\n                 (exec (:= .datum value)\n                   (:= .resolved true)\n                   (let [sleepers .waitingList\n                         sleepers-count (java.util.List.size [] sleepers)]\n                     (map (lambda [idx]\n                            (let [sleeper (java.util.List.get [(l2i idx)] sleepers)]\n                              (Executor.execute [(@runnable (lux.Function.apply [(:! Object value)] sleeper))]\n                                                executor)))\n                          (i.range 0 (i.dec (i2l sleepers-count)))))\n                   (:= .waitingList (null))\n                   true)))))\n  (#public [] poll [] A\n           .datum)\n  (#public [] wasResolved [] boolean\n           (synchronized _jvm_this\n             .resolved))\n  (#public [] waitOn [{callback lux.Function}] void\n           (synchronized _jvm_this\n             (exec (if .resolved\n                     (lux.Function.apply [(:! Object .datum)] callback)\n                     (:! Object (java.util.List.add [callback] .waitingList)))\n               [])))\n  (#public #static [A] make [{value A}] (lux.concurrency.promise.JvmPromise A)\n           (let [container (.new! [])]\n             (exec (.resolve! (:! (host lux.concurrency.promise.JvmPromise [Unit]) container) [(:! Unit value)])\n               container))))\n\n## The vector corresponds to parent interfaces.\n## An optional super-class can be specified before the vector. If not specified, java.lang.Object will be assumed.\n## Fields and methods defined in the class can be used with special syntax.\n## For example:\n## .resolved, for accessing the \nresolved\n field.\n## (:= .resolved true) for modifying it.\n## (.new! []) for calling the class's constructor.\n## (.resolve! container [value]) for calling the \nresolve\n method.\n\n\n\n\ndo-to\n\n\n## Call a variety of methods on an object; then return the object.\n(do-to vreq\n  (HttpServerRequest.setExpectMultipart [true])\n  (ReadStream.handler [(object [(Handler Buffer)]\n                         []\n                         ((Handler A) (handle [buffer A]) void\n                          (lux/codata/io;run(do Monad\nIO\n\n                                    [_ (write (Buffer.getBytes [] buffer) body)]\n                                    (wrap [])))))])\n\n  (ReadStream.endHandler [[(object [(Handler Void)]\n                             []\n                             ((Handler A) (handle [_ A]) void\n                              (exec (do Monad\nPromise\n\n                                      [#let [_ (lux/codata/io;run(close body))]\n                                       response (handler (request$ vreq body))]\n                                      (respond! response vreq))\n                                [])))]]))\n\n\n\n\ninstance?\n\n\n## Checks whether an object is an instance of a particular class.\n## Caveat emptor: Can't check for polymorphism, so avoid using parameterized classes.\n(instance? String \nYOLO\n)\n\n\n\n\ninterface:\n\n\n## Allows defining JVM interfaces.\n(interface: TestInterface\n  ([] foo [boolean String] void #throws [Exception]))\n\n\n\n\njvm-import\n\n\n## Allows importing JVM classes, and using them as types.\n## Their methods, fields and enum options can also be imported.\n## Also, classes which get imported into a module can also be referred-to with their short names in other macros that require JVM classes.\n## Examples:\n(jvm-import java.lang.Object\n  (new [])\n  (equals [Object] boolean)\n  (wait [int] #io #try void))\n\n## Special options can also be given for the return values.\n## #? means that the values will be returned inside a Maybe type. That way, null becomes #;None.\n## #try means that the computation might throw an exception, and the return value will be wrapped by the Error type.\n## #io means the computation has side effects, and will be wrapped by the IO type.\n## These options must show up in the following order [#io #try #?] (although, each option can be used independently).\n(jvm-import java.lang.String\n  (new [(Array byte)])\n  (#static valueOf [char] String)\n  (#static valueOf #as int-valueOf [int] String))\n\n(jvm-import #long (java.util.List e)\n  (size [] int)\n  (get [int] e))\n\n(jvm-import (java.util.ArrayList a)\n  ([T] toArray [(Array T)] (Array T)))\n\n## #long makes it so the class-type that is generated is of the fully-qualified name.\n## In this case, it avoids a clash between the java.util.List type, and Lux's own List type.\n(jvm-import java.lang.Character$UnicodeScript\n  (#enum ARABIC CYRILLIC LATIN))\n\n## All enum options to be imported must be specified.\n(jvm-import #long (lux.concurrency.promise.JvmPromise A)\n  (resolve [A] boolean)\n  (poll [] A)\n  (wasResolved [] boolean)\n  (waitOn [lux.Function] void)\n  (#static [A] make [A] (JvmPromise A)))\n\n## It should also be noted, the only types that may show up in method arguments or return values may be Java classes, arrays, primitives, void or type-parameters.\n## Lux types, such as Maybe can't be named (otherwise, they'd be confused for Java classes).\n## Also, the names of the imported members will look like ClassName.MemberName.\n## E.g.:\n(Object.new [])\n\n(Object.equals [other-object] my-object)\n\n(java.util.List.size [] my-list)\n\nCharacter$UnicodeScript.LATIN\n\n\n\n\nnull\n\n\n## Null object reference.\n(null)\n\n\n\n\nobject\n\n\n## Allows defining anonymous classes.\n## The 1st vector corresponds to parent interfaces.\n## The 2nd vector corresponds to arguments to the super class constructor.\n## An optional super-class can be specified before the 1st vector. If not specified, java.lang.Object will be assumed.\n(object [java.lang.Runnable]\n  []\n  (java.lang.Runnable (run) void\n                      (exec (do-something some-input)\n                        [])))\n\n\n\n\nsynchronized\n\n\n## Evaluates body, while holding a lock on a given object.\n(synchronized object-to-be-locked\n  (exec (do-something ...)\n    (do-something-else ...)\n    (finish-the-computation ...)))\n\n\n\n\ntry\n\n\n## Covers the expression in a try-catch block.\n## If it succeeds, you get (#;Right result).\n## If it fails, you get (#;Left error+stack-traces-as-text).\n(try (risky-computation input))\n\n\n\n\nwith-open\n\n\n## Creates a local-binding with the desired resources, and runs the body (assumed to be in the IO type).\n## Afterwards, closes all resources (assumed to be subclasses of java.io.Closeable), and returns the value resulting from running the body.\n(with-open [my-res1 (res1-constructor ...)\n            my-res2 (res1-constructor ...)]\n  (do Monad\nIO\n\n    [foo (do-something my-res1)\n     bar (do-something-else my-res2)]\n    (do-one-last-thing foo bar)))\n\n\n\n\nValues\n\n\n(b2l value)\n\n\n## Type converter.\n## From:\njava.lang.Byte\n\n## To:\njava.lang.Long\n\n\n\n\n(-\n (host java.lang.Byte) (host java.lang.Long))\n\n\n(c2b value)\n\n\n## Type converter.\n## From:\njava.lang.Character\n\n## To:\njava.lang.Byte\n\n\n\n\n(-\n (host java.lang.Character) (host java.lang.Byte))\n\n\n(c2i value)\n\n\n## Type converter.\n## From:\njava.lang.Character\n\n## To:\njava.lang.Integer\n\n\n\n\n(-\n (host java.lang.Character) (host java.lang.Integer))\n\n\n(c2l value)\n\n\n## Type converter.\n## From:\njava.lang.Character\n\n## To:\njava.lang.Long\n\n\n\n\n(-\n (host java.lang.Character) (host java.lang.Long))\n\n\n(c2s value)\n\n\n## Type converter.\n## From:\njava.lang.Character\n\n## To:\njava.lang.Short\n\n\n\n\n(-\n (host java.lang.Character) (host java.lang.Short))\n\n\n(d2f value)\n\n\n## Type converter.\n## From:\njava.lang.Double\n\n## To:\njava.lang.Float\n\n\n\n\n(-\n (host java.lang.Double) (host java.lang.Float))\n\n\n(d2i value)\n\n\n## Type converter.\n## From:\njava.lang.Double\n\n## To:\njava.lang.Integer\n\n\n\n\n(-\n (host java.lang.Double) (host java.lang.Integer))\n\n\n(d2l value)\n\n\n## Type converter.\n## From:\njava.lang.Double\n\n## To:\njava.lang.Long\n\n\n\n\n(-\n (host java.lang.Double) (host java.lang.Long))\n\n\n(f2d value)\n\n\n## Type converter.\n## From:\njava.lang.Float\n\n## To:\njava.lang.Double\n\n\n\n\n(-\n (host java.lang.Float) (host java.lang.Double))\n\n\n(f2i value)\n\n\n## Type converter.\n## From:\njava.lang.Float\n\n## To:\njava.lang.Integer\n\n\n\n\n(-\n (host java.lang.Float) (host java.lang.Integer))\n\n\n(f2l value)\n\n\n## Type converter.\n## From:\njava.lang.Float\n\n## To:\njava.lang.Long\n\n\n\n\n(-\n (host java.lang.Float) (host java.lang.Long))\n\n\n(i2b value)\n\n\n## Type converter.\n## From:\njava.lang.Integer\n\n## To:\njava.lang.Byte\n\n\n\n\n(-\n (host java.lang.Integer) (host java.lang.Byte))\n\n\n(i2c value)\n\n\n## Type converter.\n## From:\njava.lang.Integer\n\n## To:\njava.lang.Character\n\n\n\n\n(-\n (host java.lang.Integer) (host java.lang.Character))\n\n\n(i2d value)\n\n\n## Type converter.\n## From:\njava.lang.Integer\n\n## To:\njava.lang.Double\n\n\n\n\n(-\n (host java.lang.Integer) (host java.lang.Double))\n\n\n(i2f value)\n\n\n## Type converter.\n## From:\njava.lang.Integer\n\n## To:\njava.lang.Float\n\n\n\n\n(-\n (host java.lang.Integer) (host java.lang.Float))\n\n\n(i2l value)\n\n\n## Type converter.\n## From:\njava.lang.Integer\n\n## To:\njava.lang.Long\n\n\n\n\n(-\n (host java.lang.Integer) (host java.lang.Long))\n\n\n(i2s value)\n\n\n## Type converter.\n## From:\njava.lang.Integer\n\n## To:\njava.lang.Short\n\n\n\n\n(-\n (host java.lang.Integer) (host java.lang.Short))\n\n\n(l2b value)\n\n\n## Type converter.\n## From:\njava.lang.Long\n\n## To:\njava.lang.Byte\n\n\n\n\n(-\n (host java.lang.Long) (host java.lang.Byte))\n\n\n(l2d value)\n\n\n## Type converter.\n## From:\njava.lang.Long\n\n## To:\njava.lang.Double\n\n\n\n\n(-\n (host java.lang.Long) (host java.lang.Double))\n\n\n(l2f value)\n\n\n## Type converter.\n## From:\njava.lang.Long\n\n## To:\njava.lang.Float\n\n\n\n\n(-\n (host java.lang.Long) (host java.lang.Float))\n\n\n(l2i value)\n\n\n## Type converter.\n## From:\njava.lang.Long\n\n## To:\njava.lang.Integer\n\n\n\n\n(-\n (host java.lang.Long) (host java.lang.Integer))\n\n\n(l2s value)\n\n\n## Type converter.\n## From:\njava.lang.Long\n\n## To:\njava.lang.Short\n\n\n\n\n(-\n (host java.lang.Long) (host java.lang.Short))\n\n\n(null? obj)\n\n\n## Test for null object reference.\n(null? (null))\n\n## =\n\ntrue\n\n(null? \nYOLO\n)\n\n## =\n\nfalse\n\n\n\n\n(-\n (host java.lang.Object) lux;Bool)\n\n\n(resolve-class class)\n\n\n## Given a potentially unqualified class name, qualifies it if necessary.\n(resolve-class \nString\n)\n\n=\n\n\n## java.lang.String\n\n\n\n\n(-\n lux;Text (lux;Lux lux;Text))\n\n\n(s2l value)\n\n\n## Type converter.\n## From:\njava.lang.Short\n\n## To:\njava.lang.Long\n\n\n\n\n(-\n (host java.lang.Short) (host java.lang.Long))", 
            "title": "Lux host"
        }, 
        {
            "location": "/lux_host/#luxhost", 
            "text": "", 
            "title": "lux/host"
        }, 
        {
            "location": "/lux_host/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_host/#boolean-array", 
            "text": "(type: Boolean-Array\n  (host [Z))", 
            "title": "Boolean-Array"
        }, 
        {
            "location": "/lux_host/#byte-array", 
            "text": "(type: Byte-Array\n  (host [B))", 
            "title": "Byte-Array"
        }, 
        {
            "location": "/lux_host/#char-array", 
            "text": "(type: Char-Array\n  (host [C))", 
            "title": "Char-Array"
        }, 
        {
            "location": "/lux_host/#double-array", 
            "text": "(type: Double-Array\n  (host [D))", 
            "title": "Double-Array"
        }, 
        {
            "location": "/lux_host/#float-array", 
            "text": "(type: Float-Array\n  (host [F))", 
            "title": "Float-Array"
        }, 
        {
            "location": "/lux_host/#int-array", 
            "text": "(type: Int-Array\n  (host [I))", 
            "title": "Int-Array"
        }, 
        {
            "location": "/lux_host/#long-array", 
            "text": "(type: Long-Array\n  (host [J))", 
            "title": "Long-Array"
        }, 
        {
            "location": "/lux_host/#short-array", 
            "text": "(type: Short-Array\n  (host [S))", 
            "title": "Short-Array"
        }, 
        {
            "location": "/lux_host/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_host/#_1", 
            "text": "## Takes a (Maybe ObjectType) and returns a ObjectType.\n## A #;None would get translated into a (null).\n(!!! (??? (: java.lang.Thread (null))))\n\n## = \n(null)\n\n(!!! (???  YOLO ))\n\n## = \n## YOLO", 
            "title": "!!!"
        }, 
        {
            "location": "/lux_host/#_2", 
            "text": "## Takes a (potentially null) ObjectType reference and creates a (Maybe ObjectType) for it.\n(??? (: java.lang.String (null)))\n\n## = \n#lux;None\n\n(???  YOLO )\n\n## = \n(#lux;Some YOLO )", 
            "title": "???"
        }, 
        {
            "location": "/lux_host/#array", 
            "text": "## Create an array of the given type, with the given size.\n(array Object +10)", 
            "title": "array"
        }, 
        {
            "location": "/lux_host/#array-length", 
            "text": "## Gives the length of an array.\n(array-length my-array)", 
            "title": "array-length"
        }, 
        {
            "location": "/lux_host/#array-load", 
            "text": "## Loads an element from an array.\n(array-load 10 my-array)", 
            "title": "array-load"
        }, 
        {
            "location": "/lux_host/#array-store", 
            "text": "## Stores an element into an array.\n(array-store 10 my-object my-array)", 
            "title": "array-store"
        }, 
        {
            "location": "/lux_host/#class-for", 
            "text": "## Loads the class as a java.lang.Class object.\n(class-for java.lang.String)", 
            "title": "class-for"
        }, 
        {
            "location": "/lux_host/#class", 
            "text": "## Allows defining JVM classes in Lux code.\n## For example:\n(class: #final (JvmPromise A) []\n\n  (#private resolved boolean)\n  (#private datum A)\n  (#private waitingList (java.util.List lux.Function))\n\n  (#public [] new [] []\n           (exec (:= .resolved false)\n             (:= .waitingList (ArrayList.new []))\n             []))\n  (#public [] resolve [{value A}] boolean\n           (let [container (.new! [])]\n             (synchronized _jvm_this\n               (if .resolved\n                 false\n                 (exec (:= .datum value)\n                   (:= .resolved true)\n                   (let [sleepers .waitingList\n                         sleepers-count (java.util.List.size [] sleepers)]\n                     (map (lambda [idx]\n                            (let [sleeper (java.util.List.get [(l2i idx)] sleepers)]\n                              (Executor.execute [(@runnable (lux.Function.apply [(:! Object value)] sleeper))]\n                                                executor)))\n                          (i.range 0 (i.dec (i2l sleepers-count)))))\n                   (:= .waitingList (null))\n                   true)))))\n  (#public [] poll [] A\n           .datum)\n  (#public [] wasResolved [] boolean\n           (synchronized _jvm_this\n             .resolved))\n  (#public [] waitOn [{callback lux.Function}] void\n           (synchronized _jvm_this\n             (exec (if .resolved\n                     (lux.Function.apply [(:! Object .datum)] callback)\n                     (:! Object (java.util.List.add [callback] .waitingList)))\n               [])))\n  (#public #static [A] make [{value A}] (lux.concurrency.promise.JvmPromise A)\n           (let [container (.new! [])]\n             (exec (.resolve! (:! (host lux.concurrency.promise.JvmPromise [Unit]) container) [(:! Unit value)])\n               container))))\n\n## The vector corresponds to parent interfaces.\n## An optional super-class can be specified before the vector. If not specified, java.lang.Object will be assumed.\n## Fields and methods defined in the class can be used with special syntax.\n## For example:\n## .resolved, for accessing the  resolved  field.\n## (:= .resolved true) for modifying it.\n## (.new! []) for calling the class's constructor.\n## (.resolve! container [value]) for calling the  resolve  method.", 
            "title": "class:"
        }, 
        {
            "location": "/lux_host/#do-to", 
            "text": "## Call a variety of methods on an object; then return the object.\n(do-to vreq\n  (HttpServerRequest.setExpectMultipart [true])\n  (ReadStream.handler [(object [(Handler Buffer)]\n                         []\n                         ((Handler A) (handle [buffer A]) void\n                          (lux/codata/io;run(do Monad IO \n                                    [_ (write (Buffer.getBytes [] buffer) body)]\n                                    (wrap [])))))])\n\n  (ReadStream.endHandler [[(object [(Handler Void)]\n                             []\n                             ((Handler A) (handle [_ A]) void\n                              (exec (do Monad Promise \n                                      [#let [_ (lux/codata/io;run(close body))]\n                                       response (handler (request$ vreq body))]\n                                      (respond! response vreq))\n                                [])))]]))", 
            "title": "do-to"
        }, 
        {
            "location": "/lux_host/#instance", 
            "text": "## Checks whether an object is an instance of a particular class.\n## Caveat emptor: Can't check for polymorphism, so avoid using parameterized classes.\n(instance? String  YOLO )", 
            "title": "instance?"
        }, 
        {
            "location": "/lux_host/#interface", 
            "text": "## Allows defining JVM interfaces.\n(interface: TestInterface\n  ([] foo [boolean String] void #throws [Exception]))", 
            "title": "interface:"
        }, 
        {
            "location": "/lux_host/#jvm-import", 
            "text": "## Allows importing JVM classes, and using them as types.\n## Their methods, fields and enum options can also be imported.\n## Also, classes which get imported into a module can also be referred-to with their short names in other macros that require JVM classes.\n## Examples:\n(jvm-import java.lang.Object\n  (new [])\n  (equals [Object] boolean)\n  (wait [int] #io #try void))\n\n## Special options can also be given for the return values.\n## #? means that the values will be returned inside a Maybe type. That way, null becomes #;None.\n## #try means that the computation might throw an exception, and the return value will be wrapped by the Error type.\n## #io means the computation has side effects, and will be wrapped by the IO type.\n## These options must show up in the following order [#io #try #?] (although, each option can be used independently).\n(jvm-import java.lang.String\n  (new [(Array byte)])\n  (#static valueOf [char] String)\n  (#static valueOf #as int-valueOf [int] String))\n\n(jvm-import #long (java.util.List e)\n  (size [] int)\n  (get [int] e))\n\n(jvm-import (java.util.ArrayList a)\n  ([T] toArray [(Array T)] (Array T)))\n\n## #long makes it so the class-type that is generated is of the fully-qualified name.\n## In this case, it avoids a clash between the java.util.List type, and Lux's own List type.\n(jvm-import java.lang.Character$UnicodeScript\n  (#enum ARABIC CYRILLIC LATIN))\n\n## All enum options to be imported must be specified.\n(jvm-import #long (lux.concurrency.promise.JvmPromise A)\n  (resolve [A] boolean)\n  (poll [] A)\n  (wasResolved [] boolean)\n  (waitOn [lux.Function] void)\n  (#static [A] make [A] (JvmPromise A)))\n\n## It should also be noted, the only types that may show up in method arguments or return values may be Java classes, arrays, primitives, void or type-parameters.\n## Lux types, such as Maybe can't be named (otherwise, they'd be confused for Java classes).\n## Also, the names of the imported members will look like ClassName.MemberName.\n## E.g.:\n(Object.new [])\n\n(Object.equals [other-object] my-object)\n\n(java.util.List.size [] my-list)\n\nCharacter$UnicodeScript.LATIN", 
            "title": "jvm-import"
        }, 
        {
            "location": "/lux_host/#null", 
            "text": "## Null object reference.\n(null)", 
            "title": "null"
        }, 
        {
            "location": "/lux_host/#object", 
            "text": "## Allows defining anonymous classes.\n## The 1st vector corresponds to parent interfaces.\n## The 2nd vector corresponds to arguments to the super class constructor.\n## An optional super-class can be specified before the 1st vector. If not specified, java.lang.Object will be assumed.\n(object [java.lang.Runnable]\n  []\n  (java.lang.Runnable (run) void\n                      (exec (do-something some-input)\n                        [])))", 
            "title": "object"
        }, 
        {
            "location": "/lux_host/#synchronized", 
            "text": "## Evaluates body, while holding a lock on a given object.\n(synchronized object-to-be-locked\n  (exec (do-something ...)\n    (do-something-else ...)\n    (finish-the-computation ...)))", 
            "title": "synchronized"
        }, 
        {
            "location": "/lux_host/#try", 
            "text": "## Covers the expression in a try-catch block.\n## If it succeeds, you get (#;Right result).\n## If it fails, you get (#;Left error+stack-traces-as-text).\n(try (risky-computation input))", 
            "title": "try"
        }, 
        {
            "location": "/lux_host/#with-open", 
            "text": "## Creates a local-binding with the desired resources, and runs the body (assumed to be in the IO type).\n## Afterwards, closes all resources (assumed to be subclasses of java.io.Closeable), and returns the value resulting from running the body.\n(with-open [my-res1 (res1-constructor ...)\n            my-res2 (res1-constructor ...)]\n  (do Monad IO \n    [foo (do-something my-res1)\n     bar (do-something-else my-res2)]\n    (do-one-last-thing foo bar)))", 
            "title": "with-open"
        }, 
        {
            "location": "/lux_host/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_host/#b2l-value", 
            "text": "## Type converter.\n## From:\njava.lang.Byte\n\n## To:\njava.lang.Long  (-  (host java.lang.Byte) (host java.lang.Long))", 
            "title": "(b2l value)"
        }, 
        {
            "location": "/lux_host/#c2b-value", 
            "text": "## Type converter.\n## From:\njava.lang.Character\n\n## To:\njava.lang.Byte  (-  (host java.lang.Character) (host java.lang.Byte))", 
            "title": "(c2b value)"
        }, 
        {
            "location": "/lux_host/#c2i-value", 
            "text": "## Type converter.\n## From:\njava.lang.Character\n\n## To:\njava.lang.Integer  (-  (host java.lang.Character) (host java.lang.Integer))", 
            "title": "(c2i value)"
        }, 
        {
            "location": "/lux_host/#c2l-value", 
            "text": "## Type converter.\n## From:\njava.lang.Character\n\n## To:\njava.lang.Long  (-  (host java.lang.Character) (host java.lang.Long))", 
            "title": "(c2l value)"
        }, 
        {
            "location": "/lux_host/#c2s-value", 
            "text": "## Type converter.\n## From:\njava.lang.Character\n\n## To:\njava.lang.Short  (-  (host java.lang.Character) (host java.lang.Short))", 
            "title": "(c2s value)"
        }, 
        {
            "location": "/lux_host/#d2f-value", 
            "text": "## Type converter.\n## From:\njava.lang.Double\n\n## To:\njava.lang.Float  (-  (host java.lang.Double) (host java.lang.Float))", 
            "title": "(d2f value)"
        }, 
        {
            "location": "/lux_host/#d2i-value", 
            "text": "## Type converter.\n## From:\njava.lang.Double\n\n## To:\njava.lang.Integer  (-  (host java.lang.Double) (host java.lang.Integer))", 
            "title": "(d2i value)"
        }, 
        {
            "location": "/lux_host/#d2l-value", 
            "text": "## Type converter.\n## From:\njava.lang.Double\n\n## To:\njava.lang.Long  (-  (host java.lang.Double) (host java.lang.Long))", 
            "title": "(d2l value)"
        }, 
        {
            "location": "/lux_host/#f2d-value", 
            "text": "## Type converter.\n## From:\njava.lang.Float\n\n## To:\njava.lang.Double  (-  (host java.lang.Float) (host java.lang.Double))", 
            "title": "(f2d value)"
        }, 
        {
            "location": "/lux_host/#f2i-value", 
            "text": "## Type converter.\n## From:\njava.lang.Float\n\n## To:\njava.lang.Integer  (-  (host java.lang.Float) (host java.lang.Integer))", 
            "title": "(f2i value)"
        }, 
        {
            "location": "/lux_host/#f2l-value", 
            "text": "## Type converter.\n## From:\njava.lang.Float\n\n## To:\njava.lang.Long  (-  (host java.lang.Float) (host java.lang.Long))", 
            "title": "(f2l value)"
        }, 
        {
            "location": "/lux_host/#i2b-value", 
            "text": "## Type converter.\n## From:\njava.lang.Integer\n\n## To:\njava.lang.Byte  (-  (host java.lang.Integer) (host java.lang.Byte))", 
            "title": "(i2b value)"
        }, 
        {
            "location": "/lux_host/#i2c-value", 
            "text": "## Type converter.\n## From:\njava.lang.Integer\n\n## To:\njava.lang.Character  (-  (host java.lang.Integer) (host java.lang.Character))", 
            "title": "(i2c value)"
        }, 
        {
            "location": "/lux_host/#i2d-value", 
            "text": "## Type converter.\n## From:\njava.lang.Integer\n\n## To:\njava.lang.Double  (-  (host java.lang.Integer) (host java.lang.Double))", 
            "title": "(i2d value)"
        }, 
        {
            "location": "/lux_host/#i2f-value", 
            "text": "## Type converter.\n## From:\njava.lang.Integer\n\n## To:\njava.lang.Float  (-  (host java.lang.Integer) (host java.lang.Float))", 
            "title": "(i2f value)"
        }, 
        {
            "location": "/lux_host/#i2l-value", 
            "text": "## Type converter.\n## From:\njava.lang.Integer\n\n## To:\njava.lang.Long  (-  (host java.lang.Integer) (host java.lang.Long))", 
            "title": "(i2l value)"
        }, 
        {
            "location": "/lux_host/#i2s-value", 
            "text": "## Type converter.\n## From:\njava.lang.Integer\n\n## To:\njava.lang.Short  (-  (host java.lang.Integer) (host java.lang.Short))", 
            "title": "(i2s value)"
        }, 
        {
            "location": "/lux_host/#l2b-value", 
            "text": "## Type converter.\n## From:\njava.lang.Long\n\n## To:\njava.lang.Byte  (-  (host java.lang.Long) (host java.lang.Byte))", 
            "title": "(l2b value)"
        }, 
        {
            "location": "/lux_host/#l2d-value", 
            "text": "## Type converter.\n## From:\njava.lang.Long\n\n## To:\njava.lang.Double  (-  (host java.lang.Long) (host java.lang.Double))", 
            "title": "(l2d value)"
        }, 
        {
            "location": "/lux_host/#l2f-value", 
            "text": "## Type converter.\n## From:\njava.lang.Long\n\n## To:\njava.lang.Float  (-  (host java.lang.Long) (host java.lang.Float))", 
            "title": "(l2f value)"
        }, 
        {
            "location": "/lux_host/#l2i-value", 
            "text": "## Type converter.\n## From:\njava.lang.Long\n\n## To:\njava.lang.Integer  (-  (host java.lang.Long) (host java.lang.Integer))", 
            "title": "(l2i value)"
        }, 
        {
            "location": "/lux_host/#l2s-value", 
            "text": "## Type converter.\n## From:\njava.lang.Long\n\n## To:\njava.lang.Short  (-  (host java.lang.Long) (host java.lang.Short))", 
            "title": "(l2s value)"
        }, 
        {
            "location": "/lux_host/#null-obj", 
            "text": "## Test for null object reference.\n(null? (null))\n\n## = \ntrue\n\n(null?  YOLO )\n\n## = \nfalse  (-  (host java.lang.Object) lux;Bool)", 
            "title": "(null? obj)"
        }, 
        {
            "location": "/lux_host/#resolve-class-class", 
            "text": "## Given a potentially unqualified class name, qualifies it if necessary.\n(resolve-class  String )\n\n= \n\n## java.lang.String  (-  lux;Text (lux;Lux lux;Text))", 
            "title": "(resolve-class class)"
        }, 
        {
            "location": "/lux_host/#s2l-value", 
            "text": "## Type converter.\n## From:\njava.lang.Short\n\n## To:\njava.lang.Long  (-  (host java.lang.Short) (host java.lang.Long))", 
            "title": "(s2l value)"
        }, 
        {
            "location": "/lux_lexer/", 
            "text": "lux/lexer\n\n\nTypes\n\n\nLexer\n\n\n(type: (Lexer a)\n  (-\n lux;Text (lux/data/error;Error [lux;Text a])))\n\n\n\n\nStructs\n\n\nApplicative\nLexer\n\n\n(lux/control/applicative;Applicative Lexer)\n\n\nFunctor\nLexer\n\n\n(lux/control/functor;Functor Lexer)\n\n\nMonad\nLexer\n\n\n(lux/control/monad;Monad Lexer)\n\n\nValues\n\n\n(\n_ left right)\n\n\n(All [a b] (-\n (Lexer a) (Lexer b) (Lexer a)))\n\n\n(_\n left right)\n\n\n(All [a b] (-\n (Lexer a) (Lexer b) (Lexer b)))\n\n\nalpha\n\n\nOnly lex alphabetic characters.\n\n\n\n\n(Lexer lux;Char)\n\n\nalpha-num\n\n\nOnly lex alphanumeric characters.\n\n\n\n\n(Lexer lux;Char)\n\n\n(alt left right)\n\n\nHeterogeneous alternative combinator.\n\n\n\n\n(All [a b] (-\n (Lexer a) (Lexer b) (Lexer (| a b))))\n\n\nany\n\n\nJust returns the next character without applying any logic.\n\n\n\n\n(Lexer lux;Char)\n\n\n(assert message test)\n\n\nFails with the given message if the test is false.\n\n\n\n\n(-\n lux;Text lux;Bool (Lexer lux;Unit))\n\n\n(at-least n p)\n\n\nLex at least N times.\n\n\n\n\n(All [a] (-\n lux;Nat (Lexer a) (Lexer (lux;List a))))\n\n\n(at-most n p)\n\n\nLex at most N times.\n\n\n\n\n(All [a] (-\n lux;Nat (Lexer a) (Lexer (lux;List a))))\n\n\n(between from to p)\n\n\nLex between N and M times.\n\n\n\n\n(All [a] (-\n lux;Nat lux;Nat (Lexer a) (Lexer (lux;List a))))\n\n\n(char test)\n\n\nLex a character if it matches the given sample.\n\n\n\n\n(-\n lux;Char (Lexer lux;Char))\n\n\n(char-range bottom top)\n\n\nOnly lex characters within a range.\n\n\n\n\n(-\n lux;Char lux;Char (Lexer lux;Char))\n\n\n(codec codec lexer)\n\n\nLex a token by means of a codec.\n\n\n\n\n(All [a] (-\n (lux/control/codec;Codec lux;Text a) (Lexer lux;Text) (Lexer a)))\n\n\n(default value lexer)\n\n\nIf the given lexer fails, this lexer will succeed with the provided value.\n\n\n\n\n(All [a] (-\n a (Lexer a) (Lexer a)))\n\n\ndigit\n\n\nOnly lex decimal characters.\n\n\n\n\n(Lexer lux;Char)\n\n\n(either left right)\n\n\nHomogeneous alternative combinator.\n\n\n\n\n(All [a] (-\n (Lexer a) (Lexer a) (Lexer a)))\n\n\n(enclosed [start end] lexer)\n\n\n(All [a] (-\n [lux;Text lux;Text] (Lexer a) (Lexer a)))\n\n\nend\n\n\nEnsure the lexer's input is empty.\n\n\n\n\n(Lexer lux;Unit)\n\n\nend?\n\n\nAsk if the lexer's input is empty.\n\n\n\n\n(Lexer lux;Bool)\n\n\n(exactly n p)\n\n\nLex exactly N times.\n\n\n\n\n(All [a] (-\n lux;Nat (Lexer a) (Lexer (lux;List a))))\n\n\n(fail message)\n\n\n(All [a] (-\n lux;Text (Lexer a)))\n\n\nget-input\n\n\nGet all of the remaining input (without consuming it).\n\n\n\n\n(Lexer lux;Text)\n\n\nhex-digit\n\n\nOnly lex hexadecimal digits.\n\n\n\n\n(Lexer lux;Char)\n\n\nlower\n\n\nOnly lex lowercase characters.\n\n\n\n\n(Lexer lux;Char)\n\n\n(many p)\n\n\n1-or-more combinator.\n\n\n\n\n(All [a] (-\n (Lexer a) (Lexer (lux;List a))))\n\n\n(many' p)\n\n\nLex many characters as a single continuous text.\n\n\n\n\n(-\n (Lexer lux;Char) (Lexer lux;Text))\n\n\n(none-of options)\n\n\nOnly lex characters that aren't part of a piece of text.\n\n\n\n\n(-\n lux;Text (Lexer lux;Char))\n\n\n(not p)\n\n\nProduce a character if the lexer fails.\n\n\n\n\n(All [a] (-\n (Lexer a) (Lexer lux;Char)))\n\n\n(not! p)\n\n\nEnsure a lexer fails.\n\n\n\n\n(All [a] (-\n (Lexer a) (Lexer lux;Unit)))\n\n\noct-digit\n\n\nOnly lex octal characters.\n\n\n\n\n(Lexer lux;Char)\n\n\n(one-of options)\n\n\nOnly lex characters that are part of a piece of text.\n\n\n\n\n(-\n lux;Text (Lexer lux;Char))\n\n\n(opt p)\n\n\nOptionality combinator.\n\n\n\n\n(All [a] (-\n (Lexer a) (Lexer (lux;Maybe a))))\n\n\npeek\n\n\nLex the next character (without consuming it from the input).\n\n\n\n\n(Lexer lux;Char)\n\n\n(run lexer input)\n\n\n(All [a] (-\n (Lexer a) lux;Text (lux/data/error;Error a)))\n\n\n(run' lexer input)\n\n\n(All [a] (-\n (Lexer a) lux;Text (lux/data/error;Error [lux;Text a])))\n\n\n(satisfies p)\n\n\nOnly lex characters that satisfy a predicate.\n\n\n\n\n(-\n (-\n lux;Char lux;Bool) (Lexer lux;Char))\n\n\n(sep-by sep lexer)\n\n\nApply a lexer multiple times, checking that a separator lexer succeeds between each time.\n\n\n\n\n(All [a b] (-\n (Lexer b) (Lexer a) (Lexer (lux;List a))))\n\n\n(seq left right)\n\n\nSequencing combinator.\n\n\n\n\n(All [a b] (-\n (Lexer a) (Lexer b) (Lexer [a b])))\n\n\n(some p)\n\n\n0-or-more combinator.\n\n\n\n\n(All [a] (-\n (Lexer a) (Lexer (lux;List a))))\n\n\n(some' p)\n\n\nLex some characters as a single continuous text.\n\n\n\n\n(-\n (Lexer lux;Char) (Lexer lux;Text))\n\n\nspace\n\n\nOnly lex white-space.\n\n\n\n\n(Lexer lux;Char)\n\n\n(text test)\n\n\nLex a text if it matches the given sample.\n\n\n\n\n(-\n lux;Text (Lexer lux;Text))\n\n\nupper\n\n\nOnly lex uppercase characters.\n\n\n\n\n(Lexer lux;Char)", 
            "title": "Lux lexer"
        }, 
        {
            "location": "/lux_lexer/#luxlexer", 
            "text": "", 
            "title": "lux/lexer"
        }, 
        {
            "location": "/lux_lexer/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_lexer/#lexer", 
            "text": "(type: (Lexer a)\n  (-  lux;Text (lux/data/error;Error [lux;Text a])))", 
            "title": "Lexer"
        }, 
        {
            "location": "/lux_lexer/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_lexer/#applicativelexer", 
            "text": "(lux/control/applicative;Applicative Lexer)", 
            "title": "Applicative&lt;Lexer&gt;"
        }, 
        {
            "location": "/lux_lexer/#functorlexer", 
            "text": "(lux/control/functor;Functor Lexer)", 
            "title": "Functor&lt;Lexer&gt;"
        }, 
        {
            "location": "/lux_lexer/#monadlexer", 
            "text": "(lux/control/monad;Monad Lexer)", 
            "title": "Monad&lt;Lexer&gt;"
        }, 
        {
            "location": "/lux_lexer/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_lexer/#_-left-right", 
            "text": "(All [a b] (-  (Lexer a) (Lexer b) (Lexer a)))", 
            "title": "(&amp;_ left right)"
        }, 
        {
            "location": "/lux_lexer/#_-left-right_1", 
            "text": "(All [a b] (-  (Lexer a) (Lexer b) (Lexer b)))", 
            "title": "(_&amp; left right)"
        }, 
        {
            "location": "/lux_lexer/#alpha", 
            "text": "Only lex alphabetic characters.  (Lexer lux;Char)", 
            "title": "alpha"
        }, 
        {
            "location": "/lux_lexer/#alpha-num", 
            "text": "Only lex alphanumeric characters.  (Lexer lux;Char)", 
            "title": "alpha-num"
        }, 
        {
            "location": "/lux_lexer/#alt-left-right", 
            "text": "Heterogeneous alternative combinator.  (All [a b] (-  (Lexer a) (Lexer b) (Lexer (| a b))))", 
            "title": "(alt left right)"
        }, 
        {
            "location": "/lux_lexer/#any", 
            "text": "Just returns the next character without applying any logic.  (Lexer lux;Char)", 
            "title": "any"
        }, 
        {
            "location": "/lux_lexer/#assert-message-test", 
            "text": "Fails with the given message if the test is false.  (-  lux;Text lux;Bool (Lexer lux;Unit))", 
            "title": "(assert message test)"
        }, 
        {
            "location": "/lux_lexer/#at-least-n-p", 
            "text": "Lex at least N times.  (All [a] (-  lux;Nat (Lexer a) (Lexer (lux;List a))))", 
            "title": "(at-least n p)"
        }, 
        {
            "location": "/lux_lexer/#at-most-n-p", 
            "text": "Lex at most N times.  (All [a] (-  lux;Nat (Lexer a) (Lexer (lux;List a))))", 
            "title": "(at-most n p)"
        }, 
        {
            "location": "/lux_lexer/#between-from-to-p", 
            "text": "Lex between N and M times.  (All [a] (-  lux;Nat lux;Nat (Lexer a) (Lexer (lux;List a))))", 
            "title": "(between from to p)"
        }, 
        {
            "location": "/lux_lexer/#char-test", 
            "text": "Lex a character if it matches the given sample.  (-  lux;Char (Lexer lux;Char))", 
            "title": "(char test)"
        }, 
        {
            "location": "/lux_lexer/#char-range-bottom-top", 
            "text": "Only lex characters within a range.  (-  lux;Char lux;Char (Lexer lux;Char))", 
            "title": "(char-range bottom top)"
        }, 
        {
            "location": "/lux_lexer/#codec-codec-lexer", 
            "text": "Lex a token by means of a codec.  (All [a] (-  (lux/control/codec;Codec lux;Text a) (Lexer lux;Text) (Lexer a)))", 
            "title": "(codec codec lexer)"
        }, 
        {
            "location": "/lux_lexer/#default-value-lexer", 
            "text": "If the given lexer fails, this lexer will succeed with the provided value.  (All [a] (-  a (Lexer a) (Lexer a)))", 
            "title": "(default value lexer)"
        }, 
        {
            "location": "/lux_lexer/#digit", 
            "text": "Only lex decimal characters.  (Lexer lux;Char)", 
            "title": "digit"
        }, 
        {
            "location": "/lux_lexer/#either-left-right", 
            "text": "Homogeneous alternative combinator.  (All [a] (-  (Lexer a) (Lexer a) (Lexer a)))", 
            "title": "(either left right)"
        }, 
        {
            "location": "/lux_lexer/#enclosed-start-end-lexer", 
            "text": "(All [a] (-  [lux;Text lux;Text] (Lexer a) (Lexer a)))", 
            "title": "(enclosed [start end] lexer)"
        }, 
        {
            "location": "/lux_lexer/#end", 
            "text": "Ensure the lexer's input is empty.  (Lexer lux;Unit)", 
            "title": "end"
        }, 
        {
            "location": "/lux_lexer/#end_1", 
            "text": "Ask if the lexer's input is empty.  (Lexer lux;Bool)", 
            "title": "end?"
        }, 
        {
            "location": "/lux_lexer/#exactly-n-p", 
            "text": "Lex exactly N times.  (All [a] (-  lux;Nat (Lexer a) (Lexer (lux;List a))))", 
            "title": "(exactly n p)"
        }, 
        {
            "location": "/lux_lexer/#fail-message", 
            "text": "(All [a] (-  lux;Text (Lexer a)))", 
            "title": "(fail message)"
        }, 
        {
            "location": "/lux_lexer/#get-input", 
            "text": "Get all of the remaining input (without consuming it).  (Lexer lux;Text)", 
            "title": "get-input"
        }, 
        {
            "location": "/lux_lexer/#hex-digit", 
            "text": "Only lex hexadecimal digits.  (Lexer lux;Char)", 
            "title": "hex-digit"
        }, 
        {
            "location": "/lux_lexer/#lower", 
            "text": "Only lex lowercase characters.  (Lexer lux;Char)", 
            "title": "lower"
        }, 
        {
            "location": "/lux_lexer/#many-p", 
            "text": "1-or-more combinator.  (All [a] (-  (Lexer a) (Lexer (lux;List a))))", 
            "title": "(many p)"
        }, 
        {
            "location": "/lux_lexer/#many-p_1", 
            "text": "Lex many characters as a single continuous text.  (-  (Lexer lux;Char) (Lexer lux;Text))", 
            "title": "(many' p)"
        }, 
        {
            "location": "/lux_lexer/#none-of-options", 
            "text": "Only lex characters that aren't part of a piece of text.  (-  lux;Text (Lexer lux;Char))", 
            "title": "(none-of options)"
        }, 
        {
            "location": "/lux_lexer/#not-p", 
            "text": "Produce a character if the lexer fails.  (All [a] (-  (Lexer a) (Lexer lux;Char)))", 
            "title": "(not p)"
        }, 
        {
            "location": "/lux_lexer/#not-p_1", 
            "text": "Ensure a lexer fails.  (All [a] (-  (Lexer a) (Lexer lux;Unit)))", 
            "title": "(not! p)"
        }, 
        {
            "location": "/lux_lexer/#oct-digit", 
            "text": "Only lex octal characters.  (Lexer lux;Char)", 
            "title": "oct-digit"
        }, 
        {
            "location": "/lux_lexer/#one-of-options", 
            "text": "Only lex characters that are part of a piece of text.  (-  lux;Text (Lexer lux;Char))", 
            "title": "(one-of options)"
        }, 
        {
            "location": "/lux_lexer/#opt-p", 
            "text": "Optionality combinator.  (All [a] (-  (Lexer a) (Lexer (lux;Maybe a))))", 
            "title": "(opt p)"
        }, 
        {
            "location": "/lux_lexer/#peek", 
            "text": "Lex the next character (without consuming it from the input).  (Lexer lux;Char)", 
            "title": "peek"
        }, 
        {
            "location": "/lux_lexer/#run-lexer-input", 
            "text": "(All [a] (-  (Lexer a) lux;Text (lux/data/error;Error a)))", 
            "title": "(run lexer input)"
        }, 
        {
            "location": "/lux_lexer/#run-lexer-input_1", 
            "text": "(All [a] (-  (Lexer a) lux;Text (lux/data/error;Error [lux;Text a])))", 
            "title": "(run' lexer input)"
        }, 
        {
            "location": "/lux_lexer/#satisfies-p", 
            "text": "Only lex characters that satisfy a predicate.  (-  (-  lux;Char lux;Bool) (Lexer lux;Char))", 
            "title": "(satisfies p)"
        }, 
        {
            "location": "/lux_lexer/#sep-by-sep-lexer", 
            "text": "Apply a lexer multiple times, checking that a separator lexer succeeds between each time.  (All [a b] (-  (Lexer b) (Lexer a) (Lexer (lux;List a))))", 
            "title": "(sep-by sep lexer)"
        }, 
        {
            "location": "/lux_lexer/#seq-left-right", 
            "text": "Sequencing combinator.  (All [a b] (-  (Lexer a) (Lexer b) (Lexer [a b])))", 
            "title": "(seq left right)"
        }, 
        {
            "location": "/lux_lexer/#some-p", 
            "text": "0-or-more combinator.  (All [a] (-  (Lexer a) (Lexer (lux;List a))))", 
            "title": "(some p)"
        }, 
        {
            "location": "/lux_lexer/#some-p_1", 
            "text": "Lex some characters as a single continuous text.  (-  (Lexer lux;Char) (Lexer lux;Text))", 
            "title": "(some' p)"
        }, 
        {
            "location": "/lux_lexer/#space", 
            "text": "Only lex white-space.  (Lexer lux;Char)", 
            "title": "space"
        }, 
        {
            "location": "/lux_lexer/#text-test", 
            "text": "Lex a text if it matches the given sample.  (-  lux;Text (Lexer lux;Text))", 
            "title": "(text test)"
        }, 
        {
            "location": "/lux_lexer/#upper", 
            "text": "Only lex uppercase characters.  (Lexer lux;Char)", 
            "title": "upper"
        }, 
        {
            "location": "/lux_macro/", 
            "text": "lux/macro\n\n\nMacros\n\n\nexpand\n\n\n## Performs a macro-expansion and logs the resulting ASTs.\n## You can either use the resulting ASTs, or omit them.\n## By omitting them, this macro produces nothing (just like the lux;comment macro).\n              (\n\n\n\n\n\n\n\n\n\n\nexpand                       (def: (foo bar baz)\n                         (-\n Int Int Int)\n                         (i.+ bar baz)))\n\n\n\n\nexpand-all\n\n\n## Performs a macro-expansion and logs the resulting ASTs.\n## You can either use the resulting ASTs, or omit them.\n## By omitting them, this macro produces nothing (just like the lux;comment macro).\n              (\n\n\n\n\n\n\n\n\n\n\n\nexpand-all                       (def: (foo bar baz)\n                         (-\n Int Int Int)\n                         (i.+ bar baz)))\n\n\n\n\nexpand-once\n\n\n## Performs a macro-expansion and logs the resulting ASTs.\n## You can either use the resulting ASTs, or omit them.\n## By omitting them, this macro produces nothing (just like the lux;comment macro).\n              (\n\n\n\n\n\n\n\n\n\n\n\n\nexpand-once                       (def: (foo bar baz)\n                         (-\n Int Int Int)\n                         (i.+ bar baz)))", 
            "title": "Lux macro"
        }, 
        {
            "location": "/lux_macro/#luxmacro", 
            "text": "", 
            "title": "lux/macro"
        }, 
        {
            "location": "/lux_macro/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_macro/#expand", 
            "text": "## Performs a macro-expansion and logs the resulting ASTs.\n## You can either use the resulting ASTs, or omit them.\n## By omitting them, this macro produces nothing (just like the lux;comment macro).\n              (\n\n\n\n\n\n\n\n\n\n\nexpand                       (def: (foo bar baz)\n                         (-  Int Int Int)\n                         (i.+ bar baz)))", 
            "title": "expand"
        }, 
        {
            "location": "/lux_macro/#expand-all", 
            "text": "## Performs a macro-expansion and logs the resulting ASTs.\n## You can either use the resulting ASTs, or omit them.\n## By omitting them, this macro produces nothing (just like the lux;comment macro).\n              (\n\n\n\n\n\n\n\n\n\n\n\nexpand-all                       (def: (foo bar baz)\n                         (-  Int Int Int)\n                         (i.+ bar baz)))", 
            "title": "expand-all"
        }, 
        {
            "location": "/lux_macro/#expand-once", 
            "text": "## Performs a macro-expansion and logs the resulting ASTs.\n## You can either use the resulting ASTs, or omit them.\n## By omitting them, this macro produces nothing (just like the lux;comment macro).\n              (\n\n\n\n\n\n\n\n\n\n\n\n\nexpand-once                       (def: (foo bar baz)\n                         (-  Int Int Int)\n                         (i.+ bar baz)))", 
            "title": "expand-once"
        }, 
        {
            "location": "/lux_macro_ast/", 
            "text": "lux/macro/ast\n\n\nStructs\n\n\nEq\nAST\n\n\n(lux/control/eq;Eq lux;AST)\n\n\nValues\n\n\n(bool x)\n\n\n(-\n lux;Bool lux;AST)\n\n\n(char x)\n\n\n(-\n lux;Char lux;AST)\n\n\n(form x)\n\n\n(-\n (lux;List lux;AST) lux;AST)\n\n\n(frac x)\n\n\n(-\n lux;Frac lux;AST)\n\n\n(int x)\n\n\n(-\n lux;Int lux;AST)\n\n\n(local-symbol name)\n\n\nProduces a local symbol (a symbol with no module prefix).\n\n\n\n\n(-\n lux;Text lux;AST)\n\n\n(local-tag name)\n\n\nProduces a local tag (a tag with no module prefix).\n\n\n\n\n(-\n lux;Text lux;AST)\n\n\n(nat x)\n\n\n(-\n lux;Nat lux;AST)\n\n\n(real x)\n\n\n(-\n lux;Real lux;AST)\n\n\n(record x)\n\n\n(-\n (lux;List [lux;AST lux;AST]) lux;AST)\n\n\n(replace original substitute ast)\n\n\nReplaces all ASTs that look like 'original' with the 'substitute' in the given AST.\n\n\n\n\n(-\n lux;AST lux;AST lux;AST lux;AST)\n\n\n(symbol x)\n\n\n(-\n lux;Ident lux;AST)\n\n\n(tag x)\n\n\n(-\n lux;Ident lux;AST)\n\n\n(text x)\n\n\n(-\n lux;Text lux;AST)\n\n\n(to-text ast)\n\n\n(-\n lux;AST lux;Text)\n\n\n(tuple x)\n\n\n(-\n (lux;List lux;AST) lux;AST)", 
            "title": "Lux macro ast"
        }, 
        {
            "location": "/lux_macro_ast/#luxmacroast", 
            "text": "", 
            "title": "lux/macro/ast"
        }, 
        {
            "location": "/lux_macro_ast/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_macro_ast/#eqast", 
            "text": "(lux/control/eq;Eq lux;AST)", 
            "title": "Eq&lt;AST&gt;"
        }, 
        {
            "location": "/lux_macro_ast/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_macro_ast/#bool-x", 
            "text": "(-  lux;Bool lux;AST)", 
            "title": "(bool x)"
        }, 
        {
            "location": "/lux_macro_ast/#char-x", 
            "text": "(-  lux;Char lux;AST)", 
            "title": "(char x)"
        }, 
        {
            "location": "/lux_macro_ast/#form-x", 
            "text": "(-  (lux;List lux;AST) lux;AST)", 
            "title": "(form x)"
        }, 
        {
            "location": "/lux_macro_ast/#frac-x", 
            "text": "(-  lux;Frac lux;AST)", 
            "title": "(frac x)"
        }, 
        {
            "location": "/lux_macro_ast/#int-x", 
            "text": "(-  lux;Int lux;AST)", 
            "title": "(int x)"
        }, 
        {
            "location": "/lux_macro_ast/#local-symbol-name", 
            "text": "Produces a local symbol (a symbol with no module prefix).  (-  lux;Text lux;AST)", 
            "title": "(local-symbol name)"
        }, 
        {
            "location": "/lux_macro_ast/#local-tag-name", 
            "text": "Produces a local tag (a tag with no module prefix).  (-  lux;Text lux;AST)", 
            "title": "(local-tag name)"
        }, 
        {
            "location": "/lux_macro_ast/#nat-x", 
            "text": "(-  lux;Nat lux;AST)", 
            "title": "(nat x)"
        }, 
        {
            "location": "/lux_macro_ast/#real-x", 
            "text": "(-  lux;Real lux;AST)", 
            "title": "(real x)"
        }, 
        {
            "location": "/lux_macro_ast/#record-x", 
            "text": "(-  (lux;List [lux;AST lux;AST]) lux;AST)", 
            "title": "(record x)"
        }, 
        {
            "location": "/lux_macro_ast/#replace-original-substitute-ast", 
            "text": "Replaces all ASTs that look like 'original' with the 'substitute' in the given AST.  (-  lux;AST lux;AST lux;AST lux;AST)", 
            "title": "(replace original substitute ast)"
        }, 
        {
            "location": "/lux_macro_ast/#symbol-x", 
            "text": "(-  lux;Ident lux;AST)", 
            "title": "(symbol x)"
        }, 
        {
            "location": "/lux_macro_ast/#tag-x", 
            "text": "(-  lux;Ident lux;AST)", 
            "title": "(tag x)"
        }, 
        {
            "location": "/lux_macro_ast/#text-x", 
            "text": "(-  lux;Text lux;AST)", 
            "title": "(text x)"
        }, 
        {
            "location": "/lux_macro_ast/#to-text-ast", 
            "text": "(-  lux;AST lux;Text)", 
            "title": "(to-text ast)"
        }, 
        {
            "location": "/lux_macro_ast/#tuple-x", 
            "text": "(-  (lux;List lux;AST) lux;AST)", 
            "title": "(tuple x)"
        }, 
        {
            "location": "/lux_macro_poly/", 
            "text": "lux/macro/poly\n\n\nTypes\n\n\nEnv\n\n\n(type: Env\n  (lux/data/struct/dict;Dict lux;Nat [lux;Type lux;AST]))\n\n\n\n\nMatcher\n\n\n(type: (Matcher a)\n  (-\n lux;Type (lux;Lux a)))\n\n\n\n\nMacros\n\n\nderived:\n\n\npoly:\n\n\nValues\n\n\napply\n\n\n(Matcher [lux;Type (lux;List lux;Type)])\n\n\nbool\n\n\n(Matcher lux;Unit)\n\n\n(bound env)\n\n\n(-\n Env (Matcher lux;AST))\n\n\nchar\n\n\n(Matcher lux;Unit)\n\n\n(extend-env [funcT funcA] type-vars env)\n\n\n(-\n [lux;Type lux;AST] (lux;List [lux;Type lux;AST]) Env Env)\n\n\nfrac\n\n\n(Matcher lux;Unit)\n\n\nfunc\n\n\n(Matcher [lux;Type lux;Type])\n\n\nfunc+\n\n\n(Matcher [(lux;List lux;Type) lux;Type])\n\n\nfunction\n\n\n(Matcher [(lux;List lux;AST) (lux;List lux;Type) lux;Type])\n\n\n(gen-type env converter type-fun tvars type)\n\n\n(-\n Env (-\n lux;AST lux;AST) lux;AST (lux;List lux;AST) lux;Type lux;AST)\n\n\nint\n\n\n(Matcher lux;Unit)\n\n\nlist\n\n\n(Matcher lux;Type)\n\n\nmaybe\n\n\n(Matcher lux;Type)\n\n\nnat\n\n\n(Matcher lux;Unit)\n\n\npolymorphic\n\n\n(Matcher [(lux;List lux;AST) lux;Type])\n\n\nprimitive\n\n\n(Matcher lux;Type)\n\n\nprod\n\n\n(Matcher [lux;Type lux;Type])\n\n\nprod+\n\n\n(Matcher (lux;List lux;Type))\n\n\nreal\n\n\n(Matcher lux;Unit)\n\n\nrecord\n\n\n(Matcher [(lux;List lux;AST) (lux;List [lux;Ident lux;Type])])\n\n\n(recur env)\n\n\n(-\n Env (Matcher lux;AST))\n\n\nsum\n\n\n(Matcher [lux;Type lux;Type])\n\n\nsum+\n\n\n(Matcher (lux;List lux;Type))\n\n\ntagged\n\n\n(Matcher [(lux;List lux;Ident) lux;Type])\n\n\ntext\n\n\n(Matcher lux;Unit)\n\n\ntuple\n\n\n(Matcher [(lux;List lux;AST) (lux;List lux;Type)])\n\n\n(type-var-indices num-vars)\n\n\n(-\n lux;Nat (lux;List lux;Type))\n\n\nunit\n\n\n(Matcher lux;Unit)\n\n\n(var env var-id)\n\n\n(-\n Env lux;Nat (Matcher lux;Unit))\n\n\nvariant\n\n\n(Matcher [(lux;List lux;AST) (lux;List [lux;Ident lux;Type])])\n\n\nvoid\n\n\n(Matcher lux;Unit)", 
            "title": "Lux macro poly"
        }, 
        {
            "location": "/lux_macro_poly/#luxmacropoly", 
            "text": "", 
            "title": "lux/macro/poly"
        }, 
        {
            "location": "/lux_macro_poly/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_macro_poly/#env", 
            "text": "(type: Env\n  (lux/data/struct/dict;Dict lux;Nat [lux;Type lux;AST]))", 
            "title": "Env"
        }, 
        {
            "location": "/lux_macro_poly/#matcher", 
            "text": "(type: (Matcher a)\n  (-  lux;Type (lux;Lux a)))", 
            "title": "Matcher"
        }, 
        {
            "location": "/lux_macro_poly/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_macro_poly/#derived", 
            "text": "", 
            "title": "derived:"
        }, 
        {
            "location": "/lux_macro_poly/#poly", 
            "text": "", 
            "title": "poly:"
        }, 
        {
            "location": "/lux_macro_poly/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_macro_poly/#apply", 
            "text": "(Matcher [lux;Type (lux;List lux;Type)])", 
            "title": "apply"
        }, 
        {
            "location": "/lux_macro_poly/#bool", 
            "text": "(Matcher lux;Unit)", 
            "title": "bool"
        }, 
        {
            "location": "/lux_macro_poly/#bound-env", 
            "text": "(-  Env (Matcher lux;AST))", 
            "title": "(bound env)"
        }, 
        {
            "location": "/lux_macro_poly/#char", 
            "text": "(Matcher lux;Unit)", 
            "title": "char"
        }, 
        {
            "location": "/lux_macro_poly/#extend-env-funct-funca-type-vars-env", 
            "text": "(-  [lux;Type lux;AST] (lux;List [lux;Type lux;AST]) Env Env)", 
            "title": "(extend-env [funcT funcA] type-vars env)"
        }, 
        {
            "location": "/lux_macro_poly/#frac", 
            "text": "(Matcher lux;Unit)", 
            "title": "frac"
        }, 
        {
            "location": "/lux_macro_poly/#func", 
            "text": "(Matcher [lux;Type lux;Type])", 
            "title": "func"
        }, 
        {
            "location": "/lux_macro_poly/#func_1", 
            "text": "(Matcher [(lux;List lux;Type) lux;Type])", 
            "title": "func+"
        }, 
        {
            "location": "/lux_macro_poly/#function", 
            "text": "(Matcher [(lux;List lux;AST) (lux;List lux;Type) lux;Type])", 
            "title": "function"
        }, 
        {
            "location": "/lux_macro_poly/#gen-type-env-converter-type-fun-tvars-type", 
            "text": "(-  Env (-  lux;AST lux;AST) lux;AST (lux;List lux;AST) lux;Type lux;AST)", 
            "title": "(gen-type env converter type-fun tvars type)"
        }, 
        {
            "location": "/lux_macro_poly/#int", 
            "text": "(Matcher lux;Unit)", 
            "title": "int"
        }, 
        {
            "location": "/lux_macro_poly/#list", 
            "text": "(Matcher lux;Type)", 
            "title": "list"
        }, 
        {
            "location": "/lux_macro_poly/#maybe", 
            "text": "(Matcher lux;Type)", 
            "title": "maybe"
        }, 
        {
            "location": "/lux_macro_poly/#nat", 
            "text": "(Matcher lux;Unit)", 
            "title": "nat"
        }, 
        {
            "location": "/lux_macro_poly/#polymorphic", 
            "text": "(Matcher [(lux;List lux;AST) lux;Type])", 
            "title": "polymorphic"
        }, 
        {
            "location": "/lux_macro_poly/#primitive", 
            "text": "(Matcher lux;Type)", 
            "title": "primitive"
        }, 
        {
            "location": "/lux_macro_poly/#prod", 
            "text": "(Matcher [lux;Type lux;Type])", 
            "title": "prod"
        }, 
        {
            "location": "/lux_macro_poly/#prod_1", 
            "text": "(Matcher (lux;List lux;Type))", 
            "title": "prod+"
        }, 
        {
            "location": "/lux_macro_poly/#real", 
            "text": "(Matcher lux;Unit)", 
            "title": "real"
        }, 
        {
            "location": "/lux_macro_poly/#record", 
            "text": "(Matcher [(lux;List lux;AST) (lux;List [lux;Ident lux;Type])])", 
            "title": "record"
        }, 
        {
            "location": "/lux_macro_poly/#recur-env", 
            "text": "(-  Env (Matcher lux;AST))", 
            "title": "(recur env)"
        }, 
        {
            "location": "/lux_macro_poly/#sum", 
            "text": "(Matcher [lux;Type lux;Type])", 
            "title": "sum"
        }, 
        {
            "location": "/lux_macro_poly/#sum_1", 
            "text": "(Matcher (lux;List lux;Type))", 
            "title": "sum+"
        }, 
        {
            "location": "/lux_macro_poly/#tagged", 
            "text": "(Matcher [(lux;List lux;Ident) lux;Type])", 
            "title": "tagged"
        }, 
        {
            "location": "/lux_macro_poly/#text", 
            "text": "(Matcher lux;Unit)", 
            "title": "text"
        }, 
        {
            "location": "/lux_macro_poly/#tuple", 
            "text": "(Matcher [(lux;List lux;AST) (lux;List lux;Type)])", 
            "title": "tuple"
        }, 
        {
            "location": "/lux_macro_poly/#type-var-indices-num-vars", 
            "text": "(-  lux;Nat (lux;List lux;Type))", 
            "title": "(type-var-indices num-vars)"
        }, 
        {
            "location": "/lux_macro_poly/#unit", 
            "text": "(Matcher lux;Unit)", 
            "title": "unit"
        }, 
        {
            "location": "/lux_macro_poly/#var-env-var-id", 
            "text": "(-  Env lux;Nat (Matcher lux;Unit))", 
            "title": "(var env var-id)"
        }, 
        {
            "location": "/lux_macro_poly/#variant", 
            "text": "(Matcher [(lux;List lux;AST) (lux;List [lux;Ident lux;Type])])", 
            "title": "variant"
        }, 
        {
            "location": "/lux_macro_poly/#void", 
            "text": "(Matcher lux;Unit)", 
            "title": "void"
        }, 
        {
            "location": "/lux_macro_poly_eq/", 
            "text": "lux/macro/poly/eq\n\n\nMacros\n\n\nEq\n?", 
            "title": "Lux macro poly eq"
        }, 
        {
            "location": "/lux_macro_poly_eq/#luxmacropolyeq", 
            "text": "", 
            "title": "lux/macro/poly/eq"
        }, 
        {
            "location": "/lux_macro_poly_eq/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_macro_poly_eq/#eq", 
            "text": "", 
            "title": "Eq&lt;?&gt;"
        }, 
        {
            "location": "/lux_macro_poly_functor/", 
            "text": "lux/macro/poly/functor\n\n\nMacros\n\n\nFunctor\n?", 
            "title": "Lux macro poly functor"
        }, 
        {
            "location": "/lux_macro_poly_functor/#luxmacropolyfunctor", 
            "text": "", 
            "title": "lux/macro/poly/functor"
        }, 
        {
            "location": "/lux_macro_poly_functor/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_macro_poly_functor/#functor", 
            "text": "", 
            "title": "Functor&lt;?&gt;"
        }, 
        {
            "location": "/lux_macro_poly_text-encoder/", 
            "text": "lux/macro/poly/text-encoder\n\n\nMacros\n\n\nCodec\nText,?\n::encode", 
            "title": "Lux macro poly text encoder"
        }, 
        {
            "location": "/lux_macro_poly_text-encoder/#luxmacropolytext-encoder", 
            "text": "", 
            "title": "lux/macro/poly/text-encoder"
        }, 
        {
            "location": "/lux_macro_poly_text-encoder/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_macro_poly_text-encoder/#codectextencode", 
            "text": "", 
            "title": "Codec&lt;Text,?&gt;::encode"
        }, 
        {
            "location": "/lux_macro_syntax/", 
            "text": "lux/macro/syntax\n\n\nTypes\n\n\nSyntax\n\n\nA Lux AST syntax parser.\n\n\n(type: (Syntax a)\n  (-\n (lux;List lux;AST) (lux/data/error;Error [(lux;List lux;AST) a])))\n\n\n\n\nMacros\n\n\nsyntax:\n\n\n## A more advanced way to define macros than macro:.\n## The inputs to the macro can be parsed in complex ways through the use of syntax parsers.\n## The macro body is also (implicitly) run in the Monad\nLux\n, to save some typing.\n## Also, the compiler state can be accessed through the *compiler* binding.\n(syntax: #export (object [#let [imports (class-imports *compiler*)]]\n                   [#let [class-vars (list)]]\n                   [super (opt (super-class-decl^ imports class-vars))]\n                   [interfaces (tuple (some (super-class-decl^ imports class-vars)))]\n                   [constructor-args (constructor-args^ imports class-vars)]\n                   [methods (some (overriden-method-def^ imports))])\n  (let [def-code ($_ Text/append \nanon-class:\n\n                     (spaced (list (super-class-decl$ (lux;defaultobject-super-class super))\n                                   (with-brackets (spaced (map super-class-decl$ interfaces)))\n                                   (with-brackets (spaced (map constructor-arg$ constructor-args)))\n                                   (with-brackets (spaced (map (method-def$ id) methods))))))]\n    (wrap (list (` (lux;_lux_proc[\njvm\n (~ (lux/macro/ast;textdef-code))] []))))))\n\n\n\n\nStructs\n\n\nApplicative\nSyntax\n\n\n(lux/control/applicative;Applicative Syntax)\n\n\nFunctor\nSyntax\n\n\n(lux/control/functor;Functor Syntax)\n\n\nMonad\nSyntax\n\n\n(lux/control/monad;Monad Syntax)\n\n\nValues\n\n\n(alt p1 p2)\n\n\nHeterogeneous alternative combinator.\n\n\n\n\n(All [a b] (-\n (Syntax a) (Syntax b) (Syntax (| a b))))\n\n\nany\n\n\nJust returns the next input without applying any logic.\n\n\n\n\n(Syntax lux;AST)\n\n\n(assert message test)\n\n\nFails with the given message if the test is false.\n\n\n\n\n(-\n lux;Text lux;Bool (Syntax lux;Unit))\n\n\n(at-least n p)\n\n\nParse at least N times.\n\n\n\n\n(All [a] (-\n lux;Nat (Syntax a) (Syntax (lux;List a))))\n\n\n(at-most n p)\n\n\nParse at most N times.\n\n\n\n\n(All [a] (-\n lux;Nat (Syntax a) (Syntax (lux;List a))))\n\n\n(between from to p)\n\n\nParse between N and M times.\n\n\n\n\n(All [a] (-\n lux;Nat lux;Nat (Syntax a) (Syntax (lux;List a))))\n\n\nbool\n\n\nParses the next bool input AST.\n\n\n\n\n(Syntax lux;Bool)\n\n\n(bool! v)\n\n\nEnsures the given bool is the next input AST.\n\n\n\n\n(-\n lux;Bool (Syntax lux;Unit))\n\n\n(bool? v)\n\n\nAsks if the given bool is the next input AST.\n\n\n\n\n(-\n lux;Bool (Syntax lux;Bool))\n\n\nchar\n\n\nParses the next char input AST.\n\n\n\n\n(Syntax lux;Char)\n\n\n(char! v)\n\n\nEnsures the given char is the next input AST.\n\n\n\n\n(-\n lux;Char (Syntax lux;Unit))\n\n\n(char? v)\n\n\nAsks if the given char is the next input AST.\n\n\n\n\n(-\n lux;Char (Syntax lux;Bool))\n\n\n(default value parser)\n\n\nIf the given parser fails, returns the default value.\n\n\n\n\n(All [a] (-\n a (Syntax a) (Syntax a)))\n\n\n(either pl pr)\n\n\nHomogeneous alternative combinator.\n\n\n\n\n(All [a] (-\n (Syntax a) (Syntax a) (Syntax a)))\n\n\nend\n\n\nEnsures there are no more inputs.\n\n\n\n\n(Syntax lux;Unit)\n\n\nend?\n\n\nChecks whether there are no more inputs.\n\n\n\n\n(Syntax lux;Bool)\n\n\n(exactly n p)\n\n\nParse exactly N times.\n\n\n\n\n(All [a] (-\n lux;Nat (Syntax a) (Syntax (lux;List a))))\n\n\n(fail message)\n\n\n(All [a] (-\n lux;Text (Syntax a)))\n\n\n(form p)\n\n\nParse inside the contents of a form as if they were the input ASTs.\n\n\n\n\n(All [a] (-\n (Syntax a) (Syntax a)))\n\n\nfrac\n\n\nParses the next frac input AST.\n\n\n\n\n(Syntax lux;Frac)\n\n\n(frac! v)\n\n\nEnsures the given frac is the next input AST.\n\n\n\n\n(-\n lux;Frac (Syntax lux;Unit))\n\n\n(frac? v)\n\n\nAsks if the given frac is the next input AST.\n\n\n\n\n(-\n lux;Frac (Syntax lux;Bool))\n\n\nint\n\n\nParses the next int input AST.\n\n\n\n\n(Syntax lux;Int)\n\n\n(int! v)\n\n\nEnsures the given int is the next input AST.\n\n\n\n\n(-\n lux;Int (Syntax lux;Unit))\n\n\n(int? v)\n\n\nAsks if the given int is the next input AST.\n\n\n\n\n(-\n lux;Int (Syntax lux;Bool))\n\n\n(local local-inputs syntax)\n\n\nRun a syntax parser with the given list of inputs, instead of the real ones.\n\n\n\n\n(All [a] (-\n (lux;List lux;AST) (Syntax a) (Syntax a)))\n\n\nlocal-symbol\n\n\nParse a local symbol (a symbol that has no module prefix).\n\n\n\n\n(Syntax lux;Text)\n\n\nlocal-tag\n\n\nParse a local tag (a tag that has no module prefix).\n\n\n\n\n(Syntax lux;Text)\n\n\n(many p)\n\n\n1-or-more combinator.\n\n\n\n\n(All [a] (-\n (Syntax a) (Syntax (lux;List a))))\n\n\nnat\n\n\nParses the next nat input AST.\n\n\n\n\n(Syntax lux;Nat)\n\n\n(nat! v)\n\n\nEnsures the given nat is the next input AST.\n\n\n\n\n(-\n lux;Nat (Syntax lux;Unit))\n\n\n(nat? v)\n\n\nAsks if the given nat is the next input AST.\n\n\n\n\n(-\n lux;Nat (Syntax lux;Bool))\n\n\nneg-int\n\n\n(Syntax lux;Int)\n\n\n(not p)\n\n\n(All [a] (-\n (Syntax a) (Syntax lux;Unit)))\n\n\n(on compiler action)\n\n\nRun a Lux operation as if it was a Syntax parser.\n\n\n\n\n(All [a] (-\n lux;Compiler (lux;Lux a) (Syntax a)))\n\n\n(opt p)\n\n\nOptionality combinator.\n\n\n\n\n(All [a] (-\n (Syntax a) (Syntax (lux;Maybe a))))\n\n\npos-int\n\n\n(Syntax lux;Int)\n\n\nreal\n\n\nParses the next real input AST.\n\n\n\n\n(Syntax lux;Real)\n\n\n(real! v)\n\n\nEnsures the given real is the next input AST.\n\n\n\n\n(-\n lux;Real (Syntax lux;Unit))\n\n\n(real? v)\n\n\nAsks if the given real is the next input AST.\n\n\n\n\n(-\n lux;Real (Syntax lux;Bool))\n\n\n(record p)\n\n\nParse inside the contents of a record as if they were the input ASTs.\n\n\n\n\n(All [a] (-\n (Syntax a) (Syntax a)))\n\n\n(run tokens p)\n\n\n(All [a] (-\n (lux;List lux;AST) (Syntax a) (lux/data/error;Error [(lux;List lux;AST) a])))\n\n\n(sep-by sep p)\n\n\nParsers instances of 'p' that are separated by instances of 'sep'.\n\n\n\n\n(All [a b] (-\n (Syntax b) (Syntax a) (Syntax (lux;List a))))\n\n\n(seq p1 p2)\n\n\nSequencing combinator.\n\n\n\n\n(All [a b] (-\n (Syntax a) (Syntax b) (Syntax [a b])))\n\n\n(some p)\n\n\n0-or-more combinator.\n\n\n\n\n(All [a] (-\n (Syntax a) (Syntax (lux;List a))))\n\n\nsymbol\n\n\nParses the next symbol input AST.\n\n\n\n\n(Syntax lux;Ident)\n\n\n(symbol! v)\n\n\nEnsures the given symbol is the next input AST.\n\n\n\n\n(-\n lux;Ident (Syntax lux;Unit))\n\n\n(symbol? v)\n\n\nAsks if the given symbol is the next input AST.\n\n\n\n\n(-\n lux;Ident (Syntax lux;Bool))\n\n\ntag\n\n\nParses the next tag input AST.\n\n\n\n\n(Syntax lux;Ident)\n\n\n(tag! v)\n\n\nEnsures the given tag is the next input AST.\n\n\n\n\n(-\n lux;Ident (Syntax lux;Unit))\n\n\n(tag? v)\n\n\nAsks if the given tag is the next input AST.\n\n\n\n\n(-\n lux;Ident (Syntax lux;Bool))\n\n\ntext\n\n\nParses the next text input AST.\n\n\n\n\n(Syntax lux;Text)\n\n\n(text! v)\n\n\nEnsures the given text is the next input AST.\n\n\n\n\n(-\n lux;Text (Syntax lux;Unit))\n\n\n(text? v)\n\n\nAsks if the given text is the next input AST.\n\n\n\n\n(-\n lux;Text (Syntax lux;Bool))\n\n\n(tuple p)\n\n\nParse inside the contents of a tuple as if they were the input ASTs.\n\n\n\n\n(All [a] (-\n (Syntax a) (Syntax a)))", 
            "title": "Lux macro syntax"
        }, 
        {
            "location": "/lux_macro_syntax/#luxmacrosyntax", 
            "text": "", 
            "title": "lux/macro/syntax"
        }, 
        {
            "location": "/lux_macro_syntax/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_macro_syntax/#syntax", 
            "text": "A Lux AST syntax parser.  (type: (Syntax a)\n  (-  (lux;List lux;AST) (lux/data/error;Error [(lux;List lux;AST) a])))", 
            "title": "Syntax"
        }, 
        {
            "location": "/lux_macro_syntax/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_macro_syntax/#syntax_1", 
            "text": "## A more advanced way to define macros than macro:.\n## The inputs to the macro can be parsed in complex ways through the use of syntax parsers.\n## The macro body is also (implicitly) run in the Monad Lux , to save some typing.\n## Also, the compiler state can be accessed through the *compiler* binding.\n(syntax: #export (object [#let [imports (class-imports *compiler*)]]\n                   [#let [class-vars (list)]]\n                   [super (opt (super-class-decl^ imports class-vars))]\n                   [interfaces (tuple (some (super-class-decl^ imports class-vars)))]\n                   [constructor-args (constructor-args^ imports class-vars)]\n                   [methods (some (overriden-method-def^ imports))])\n  (let [def-code ($_ Text/append  anon-class: \n                     (spaced (list (super-class-decl$ (lux;defaultobject-super-class super))\n                                   (with-brackets (spaced (map super-class-decl$ interfaces)))\n                                   (with-brackets (spaced (map constructor-arg$ constructor-args)))\n                                   (with-brackets (spaced (map (method-def$ id) methods))))))]\n    (wrap (list (` (lux;_lux_proc[ jvm  (~ (lux/macro/ast;textdef-code))] []))))))", 
            "title": "syntax:"
        }, 
        {
            "location": "/lux_macro_syntax/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_macro_syntax/#applicativesyntax", 
            "text": "(lux/control/applicative;Applicative Syntax)", 
            "title": "Applicative&lt;Syntax&gt;"
        }, 
        {
            "location": "/lux_macro_syntax/#functorsyntax", 
            "text": "(lux/control/functor;Functor Syntax)", 
            "title": "Functor&lt;Syntax&gt;"
        }, 
        {
            "location": "/lux_macro_syntax/#monadsyntax", 
            "text": "(lux/control/monad;Monad Syntax)", 
            "title": "Monad&lt;Syntax&gt;"
        }, 
        {
            "location": "/lux_macro_syntax/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_macro_syntax/#alt-p1-p2", 
            "text": "Heterogeneous alternative combinator.  (All [a b] (-  (Syntax a) (Syntax b) (Syntax (| a b))))", 
            "title": "(alt p1 p2)"
        }, 
        {
            "location": "/lux_macro_syntax/#any", 
            "text": "Just returns the next input without applying any logic.  (Syntax lux;AST)", 
            "title": "any"
        }, 
        {
            "location": "/lux_macro_syntax/#assert-message-test", 
            "text": "Fails with the given message if the test is false.  (-  lux;Text lux;Bool (Syntax lux;Unit))", 
            "title": "(assert message test)"
        }, 
        {
            "location": "/lux_macro_syntax/#at-least-n-p", 
            "text": "Parse at least N times.  (All [a] (-  lux;Nat (Syntax a) (Syntax (lux;List a))))", 
            "title": "(at-least n p)"
        }, 
        {
            "location": "/lux_macro_syntax/#at-most-n-p", 
            "text": "Parse at most N times.  (All [a] (-  lux;Nat (Syntax a) (Syntax (lux;List a))))", 
            "title": "(at-most n p)"
        }, 
        {
            "location": "/lux_macro_syntax/#between-from-to-p", 
            "text": "Parse between N and M times.  (All [a] (-  lux;Nat lux;Nat (Syntax a) (Syntax (lux;List a))))", 
            "title": "(between from to p)"
        }, 
        {
            "location": "/lux_macro_syntax/#bool", 
            "text": "Parses the next bool input AST.  (Syntax lux;Bool)", 
            "title": "bool"
        }, 
        {
            "location": "/lux_macro_syntax/#bool-v", 
            "text": "Ensures the given bool is the next input AST.  (-  lux;Bool (Syntax lux;Unit))", 
            "title": "(bool! v)"
        }, 
        {
            "location": "/lux_macro_syntax/#bool-v_1", 
            "text": "Asks if the given bool is the next input AST.  (-  lux;Bool (Syntax lux;Bool))", 
            "title": "(bool? v)"
        }, 
        {
            "location": "/lux_macro_syntax/#char", 
            "text": "Parses the next char input AST.  (Syntax lux;Char)", 
            "title": "char"
        }, 
        {
            "location": "/lux_macro_syntax/#char-v", 
            "text": "Ensures the given char is the next input AST.  (-  lux;Char (Syntax lux;Unit))", 
            "title": "(char! v)"
        }, 
        {
            "location": "/lux_macro_syntax/#char-v_1", 
            "text": "Asks if the given char is the next input AST.  (-  lux;Char (Syntax lux;Bool))", 
            "title": "(char? v)"
        }, 
        {
            "location": "/lux_macro_syntax/#default-value-parser", 
            "text": "If the given parser fails, returns the default value.  (All [a] (-  a (Syntax a) (Syntax a)))", 
            "title": "(default value parser)"
        }, 
        {
            "location": "/lux_macro_syntax/#either-pl-pr", 
            "text": "Homogeneous alternative combinator.  (All [a] (-  (Syntax a) (Syntax a) (Syntax a)))", 
            "title": "(either pl pr)"
        }, 
        {
            "location": "/lux_macro_syntax/#end", 
            "text": "Ensures there are no more inputs.  (Syntax lux;Unit)", 
            "title": "end"
        }, 
        {
            "location": "/lux_macro_syntax/#end_1", 
            "text": "Checks whether there are no more inputs.  (Syntax lux;Bool)", 
            "title": "end?"
        }, 
        {
            "location": "/lux_macro_syntax/#exactly-n-p", 
            "text": "Parse exactly N times.  (All [a] (-  lux;Nat (Syntax a) (Syntax (lux;List a))))", 
            "title": "(exactly n p)"
        }, 
        {
            "location": "/lux_macro_syntax/#fail-message", 
            "text": "(All [a] (-  lux;Text (Syntax a)))", 
            "title": "(fail message)"
        }, 
        {
            "location": "/lux_macro_syntax/#form-p", 
            "text": "Parse inside the contents of a form as if they were the input ASTs.  (All [a] (-  (Syntax a) (Syntax a)))", 
            "title": "(form p)"
        }, 
        {
            "location": "/lux_macro_syntax/#frac", 
            "text": "Parses the next frac input AST.  (Syntax lux;Frac)", 
            "title": "frac"
        }, 
        {
            "location": "/lux_macro_syntax/#frac-v", 
            "text": "Ensures the given frac is the next input AST.  (-  lux;Frac (Syntax lux;Unit))", 
            "title": "(frac! v)"
        }, 
        {
            "location": "/lux_macro_syntax/#frac-v_1", 
            "text": "Asks if the given frac is the next input AST.  (-  lux;Frac (Syntax lux;Bool))", 
            "title": "(frac? v)"
        }, 
        {
            "location": "/lux_macro_syntax/#int", 
            "text": "Parses the next int input AST.  (Syntax lux;Int)", 
            "title": "int"
        }, 
        {
            "location": "/lux_macro_syntax/#int-v", 
            "text": "Ensures the given int is the next input AST.  (-  lux;Int (Syntax lux;Unit))", 
            "title": "(int! v)"
        }, 
        {
            "location": "/lux_macro_syntax/#int-v_1", 
            "text": "Asks if the given int is the next input AST.  (-  lux;Int (Syntax lux;Bool))", 
            "title": "(int? v)"
        }, 
        {
            "location": "/lux_macro_syntax/#local-local-inputs-syntax", 
            "text": "Run a syntax parser with the given list of inputs, instead of the real ones.  (All [a] (-  (lux;List lux;AST) (Syntax a) (Syntax a)))", 
            "title": "(local local-inputs syntax)"
        }, 
        {
            "location": "/lux_macro_syntax/#local-symbol", 
            "text": "Parse a local symbol (a symbol that has no module prefix).  (Syntax lux;Text)", 
            "title": "local-symbol"
        }, 
        {
            "location": "/lux_macro_syntax/#local-tag", 
            "text": "Parse a local tag (a tag that has no module prefix).  (Syntax lux;Text)", 
            "title": "local-tag"
        }, 
        {
            "location": "/lux_macro_syntax/#many-p", 
            "text": "1-or-more combinator.  (All [a] (-  (Syntax a) (Syntax (lux;List a))))", 
            "title": "(many p)"
        }, 
        {
            "location": "/lux_macro_syntax/#nat", 
            "text": "Parses the next nat input AST.  (Syntax lux;Nat)", 
            "title": "nat"
        }, 
        {
            "location": "/lux_macro_syntax/#nat-v", 
            "text": "Ensures the given nat is the next input AST.  (-  lux;Nat (Syntax lux;Unit))", 
            "title": "(nat! v)"
        }, 
        {
            "location": "/lux_macro_syntax/#nat-v_1", 
            "text": "Asks if the given nat is the next input AST.  (-  lux;Nat (Syntax lux;Bool))", 
            "title": "(nat? v)"
        }, 
        {
            "location": "/lux_macro_syntax/#neg-int", 
            "text": "(Syntax lux;Int)", 
            "title": "neg-int"
        }, 
        {
            "location": "/lux_macro_syntax/#not-p", 
            "text": "(All [a] (-  (Syntax a) (Syntax lux;Unit)))", 
            "title": "(not p)"
        }, 
        {
            "location": "/lux_macro_syntax/#on-compiler-action", 
            "text": "Run a Lux operation as if it was a Syntax parser.  (All [a] (-  lux;Compiler (lux;Lux a) (Syntax a)))", 
            "title": "(on compiler action)"
        }, 
        {
            "location": "/lux_macro_syntax/#opt-p", 
            "text": "Optionality combinator.  (All [a] (-  (Syntax a) (Syntax (lux;Maybe a))))", 
            "title": "(opt p)"
        }, 
        {
            "location": "/lux_macro_syntax/#pos-int", 
            "text": "(Syntax lux;Int)", 
            "title": "pos-int"
        }, 
        {
            "location": "/lux_macro_syntax/#real", 
            "text": "Parses the next real input AST.  (Syntax lux;Real)", 
            "title": "real"
        }, 
        {
            "location": "/lux_macro_syntax/#real-v", 
            "text": "Ensures the given real is the next input AST.  (-  lux;Real (Syntax lux;Unit))", 
            "title": "(real! v)"
        }, 
        {
            "location": "/lux_macro_syntax/#real-v_1", 
            "text": "Asks if the given real is the next input AST.  (-  lux;Real (Syntax lux;Bool))", 
            "title": "(real? v)"
        }, 
        {
            "location": "/lux_macro_syntax/#record-p", 
            "text": "Parse inside the contents of a record as if they were the input ASTs.  (All [a] (-  (Syntax a) (Syntax a)))", 
            "title": "(record p)"
        }, 
        {
            "location": "/lux_macro_syntax/#run-tokens-p", 
            "text": "(All [a] (-  (lux;List lux;AST) (Syntax a) (lux/data/error;Error [(lux;List lux;AST) a])))", 
            "title": "(run tokens p)"
        }, 
        {
            "location": "/lux_macro_syntax/#sep-by-sep-p", 
            "text": "Parsers instances of 'p' that are separated by instances of 'sep'.  (All [a b] (-  (Syntax b) (Syntax a) (Syntax (lux;List a))))", 
            "title": "(sep-by sep p)"
        }, 
        {
            "location": "/lux_macro_syntax/#seq-p1-p2", 
            "text": "Sequencing combinator.  (All [a b] (-  (Syntax a) (Syntax b) (Syntax [a b])))", 
            "title": "(seq p1 p2)"
        }, 
        {
            "location": "/lux_macro_syntax/#some-p", 
            "text": "0-or-more combinator.  (All [a] (-  (Syntax a) (Syntax (lux;List a))))", 
            "title": "(some p)"
        }, 
        {
            "location": "/lux_macro_syntax/#symbol", 
            "text": "Parses the next symbol input AST.  (Syntax lux;Ident)", 
            "title": "symbol"
        }, 
        {
            "location": "/lux_macro_syntax/#symbol-v", 
            "text": "Ensures the given symbol is the next input AST.  (-  lux;Ident (Syntax lux;Unit))", 
            "title": "(symbol! v)"
        }, 
        {
            "location": "/lux_macro_syntax/#symbol-v_1", 
            "text": "Asks if the given symbol is the next input AST.  (-  lux;Ident (Syntax lux;Bool))", 
            "title": "(symbol? v)"
        }, 
        {
            "location": "/lux_macro_syntax/#tag", 
            "text": "Parses the next tag input AST.  (Syntax lux;Ident)", 
            "title": "tag"
        }, 
        {
            "location": "/lux_macro_syntax/#tag-v", 
            "text": "Ensures the given tag is the next input AST.  (-  lux;Ident (Syntax lux;Unit))", 
            "title": "(tag! v)"
        }, 
        {
            "location": "/lux_macro_syntax/#tag-v_1", 
            "text": "Asks if the given tag is the next input AST.  (-  lux;Ident (Syntax lux;Bool))", 
            "title": "(tag? v)"
        }, 
        {
            "location": "/lux_macro_syntax/#text", 
            "text": "Parses the next text input AST.  (Syntax lux;Text)", 
            "title": "text"
        }, 
        {
            "location": "/lux_macro_syntax/#text-v", 
            "text": "Ensures the given text is the next input AST.  (-  lux;Text (Syntax lux;Unit))", 
            "title": "(text! v)"
        }, 
        {
            "location": "/lux_macro_syntax/#text-v_1", 
            "text": "Asks if the given text is the next input AST.  (-  lux;Text (Syntax lux;Bool))", 
            "title": "(text? v)"
        }, 
        {
            "location": "/lux_macro_syntax/#tuple-p", 
            "text": "Parse inside the contents of a tuple as if they were the input ASTs.  (All [a] (-  (Syntax a) (Syntax a)))", 
            "title": "(tuple p)"
        }, 
        {
            "location": "/lux_macro_syntax_common/", 
            "text": "lux/macro/syntax/common\n\n\n\n\nCommons syntax parsers and generators.\n\n\nThe goal is to be able to reuse common syntax in macro definitions across libraries.\n\n\n\n\nTypes\n\n\nDecl\n\n\n(type: Decl\n  {#decl-name lux;Text\n   #decl-args (lux;List lux;Text)})\n\n\n\n\nDef-Syntax\n\n\n(type: Def-Syntax\n  {#def-name lux;Text\n   #def-type (lux;Maybe lux;AST)\n   #def-value lux;AST\n   #def-anns (lux;List [lux;Ident lux;AST])\n   #def-args (lux;List lux;Text)})\n\n\n\n\nExport-Level\n\n\n(type: Export-Level\n  (#Exported lux;Unit)\n  (#Hidden lux;Unit))\n\n\n\n\nValues\n\n\ndecl\n\n\n## A parser for declaration syntax.\n## Such as:\nquux\n\n(foo bar baz)\n\n\n\n\n(lux/macro/syntax;Syntax Decl)\n\n\n(def compiler)\n\n\nA parser that first macro-expands and then analyses the input AST, to ensure it's a definition.\n\n\n\n\n(-\n lux;Compiler (lux/macro/syntax;Syntax Def-Syntax))\n\n\ndef-anns\n\n\nParser for the common annotations syntax used by def: statements.\n\n\n\n\n(lux/macro/syntax;Syntax (lux;List [lux;Ident lux;AST]))\n\n\nexport-level\n\n\n## A parser for export levels.\n## Such as:\n#export\n\n#hidden\n\n\n\n\n(lux/macro/syntax;Syntax (lux;Maybe Export-Level))\n\n\n(gen-export-level ?el)\n\n\n(-\n (lux;Maybe Export-Level) (lux;List lux;AST))\n\n\ntype-params\n\n\nParser for the common type var/param used by many macros.\n\n\n\n\n(lux/macro/syntax;Syntax (lux;List lux;Text))\n\n\ntyped-arg\n\n\nParser for the common typed-argument syntax used by many macros.\n\n\n\n\n(lux/macro/syntax;Syntax [lux;Text lux;AST])\n\n\n(typed-def compiler)\n\n\nA parser for definitions that ensures the input syntax is typed.\n\n\n\n\n(-\n lux;Compiler (lux/macro/syntax;Syntax Def-Syntax))", 
            "title": "Lux macro syntax common"
        }, 
        {
            "location": "/lux_macro_syntax_common/#luxmacrosyntaxcommon", 
            "text": "Commons syntax parsers and generators.  The goal is to be able to reuse common syntax in macro definitions across libraries.", 
            "title": "lux/macro/syntax/common"
        }, 
        {
            "location": "/lux_macro_syntax_common/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_macro_syntax_common/#decl", 
            "text": "(type: Decl\n  {#decl-name lux;Text\n   #decl-args (lux;List lux;Text)})", 
            "title": "Decl"
        }, 
        {
            "location": "/lux_macro_syntax_common/#def-syntax", 
            "text": "(type: Def-Syntax\n  {#def-name lux;Text\n   #def-type (lux;Maybe lux;AST)\n   #def-value lux;AST\n   #def-anns (lux;List [lux;Ident lux;AST])\n   #def-args (lux;List lux;Text)})", 
            "title": "Def-Syntax"
        }, 
        {
            "location": "/lux_macro_syntax_common/#export-level", 
            "text": "(type: Export-Level\n  (#Exported lux;Unit)\n  (#Hidden lux;Unit))", 
            "title": "Export-Level"
        }, 
        {
            "location": "/lux_macro_syntax_common/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_macro_syntax_common/#decl_1", 
            "text": "## A parser for declaration syntax.\n## Such as:\nquux\n\n(foo bar baz)  (lux/macro/syntax;Syntax Decl)", 
            "title": "decl"
        }, 
        {
            "location": "/lux_macro_syntax_common/#def-compiler", 
            "text": "A parser that first macro-expands and then analyses the input AST, to ensure it's a definition.  (-  lux;Compiler (lux/macro/syntax;Syntax Def-Syntax))", 
            "title": "(def compiler)"
        }, 
        {
            "location": "/lux_macro_syntax_common/#def-anns", 
            "text": "Parser for the common annotations syntax used by def: statements.  (lux/macro/syntax;Syntax (lux;List [lux;Ident lux;AST]))", 
            "title": "def-anns"
        }, 
        {
            "location": "/lux_macro_syntax_common/#export-level_1", 
            "text": "## A parser for export levels.\n## Such as:\n#export\n\n#hidden  (lux/macro/syntax;Syntax (lux;Maybe Export-Level))", 
            "title": "export-level"
        }, 
        {
            "location": "/lux_macro_syntax_common/#gen-export-level-el", 
            "text": "(-  (lux;Maybe Export-Level) (lux;List lux;AST))", 
            "title": "(gen-export-level ?el)"
        }, 
        {
            "location": "/lux_macro_syntax_common/#type-params", 
            "text": "Parser for the common type var/param used by many macros.  (lux/macro/syntax;Syntax (lux;List lux;Text))", 
            "title": "type-params"
        }, 
        {
            "location": "/lux_macro_syntax_common/#typed-arg", 
            "text": "Parser for the common typed-argument syntax used by many macros.  (lux/macro/syntax;Syntax [lux;Text lux;AST])", 
            "title": "typed-arg"
        }, 
        {
            "location": "/lux_macro_syntax_common/#typed-def-compiler", 
            "text": "A parser for definitions that ensures the input syntax is typed.  (-  lux;Compiler (lux/macro/syntax;Syntax Def-Syntax))", 
            "title": "(typed-def compiler)"
        }, 
        {
            "location": "/lux_math/", 
            "text": "lux/math\n\n\n\n\nCommon mathematical constants and functions.\n\n\n\n\nMacros\n\n\ninfix\n\n\n## Infix math syntax.\n(infix [x i.* 10])\n\n(infix [[x i.+ y] i.* [x i.- y]])\n\n(infix [[x n.\n y] and [y n.\n z]])\n\n(infix [#and x n.\n y n.\n z])\n\n(infix [(n.* +3 +9) gcd +450])\n\n## The rules for infix syntax are simple.\n## If you want your binary function to work well with it.\n## Then take the argument to the right (y) as your first argument,\n## and take the argument to the left (x) as your second argument.\n\n\n\n\nValues\n\n\n(acos n)\n\n\n(-\n lux;Real lux;Real)\n\n\n(asin n)\n\n\n(-\n lux;Real lux;Real)\n\n\n(atan n)\n\n\n(-\n lux;Real lux;Real)\n\n\n(atan2 param subject)\n\n\n(-\n lux;Real lux;Real lux;Real)\n\n\n(cbrt n)\n\n\n(-\n lux;Real lux;Real)\n\n\n(ceil n)\n\n\n(-\n lux;Real lux;Real)\n\n\n(cos n)\n\n\n(-\n lux;Real lux;Real)\n\n\n(cosh n)\n\n\n(-\n lux;Real lux;Real)\n\n\n(degrees n)\n\n\n(-\n lux;Real lux;Real)\n\n\ne\n\n\nlux;Real\n\n\n(exp n)\n\n\n(-\n lux;Real lux;Real)\n\n\n(floor n)\n\n\n(-\n lux;Real lux;Real)\n\n\n(gcd a b)\n\n\nGreatest Common Divisor.\n\n\n\n\n(-\n lux;Nat lux;Nat lux;Nat)\n\n\n(lcm x y)\n\n\nLeast Common Multiple.\n\n\n\n\n(-\n lux;Nat lux;Nat lux;Nat)\n\n\n(log n)\n\n\n(-\n lux;Real lux;Real)\n\n\npi\n\n\nlux;Real\n\n\n(pow param subject)\n\n\n(-\n lux;Real lux;Real lux;Real)\n\n\n(radians n)\n\n\n(-\n lux;Real lux;Real)\n\n\n(round n)\n\n\n(-\n lux;Real lux;Real)\n\n\n(sin n)\n\n\n(-\n lux;Real lux;Real)\n\n\n(sinh n)\n\n\n(-\n lux;Real lux;Real)\n\n\n(sqrt n)\n\n\n(-\n lux;Real lux;Real)\n\n\n(tan n)\n\n\n(-\n lux;Real lux;Real)\n\n\n(tanh n)\n\n\n(-\n lux;Real lux;Real)\n\n\ntau\n\n\nThe same as 2*PI.\n\n\n\n\nlux;Real", 
            "title": "Lux math"
        }, 
        {
            "location": "/lux_math/#luxmath", 
            "text": "Common mathematical constants and functions.", 
            "title": "lux/math"
        }, 
        {
            "location": "/lux_math/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_math/#infix", 
            "text": "## Infix math syntax.\n(infix [x i.* 10])\n\n(infix [[x i.+ y] i.* [x i.- y]])\n\n(infix [[x n.  y] and [y n.  z]])\n\n(infix [#and x n.  y n.  z])\n\n(infix [(n.* +3 +9) gcd +450])\n\n## The rules for infix syntax are simple.\n## If you want your binary function to work well with it.\n## Then take the argument to the right (y) as your first argument,\n## and take the argument to the left (x) as your second argument.", 
            "title": "infix"
        }, 
        {
            "location": "/lux_math/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_math/#acos-n", 
            "text": "(-  lux;Real lux;Real)", 
            "title": "(acos n)"
        }, 
        {
            "location": "/lux_math/#asin-n", 
            "text": "(-  lux;Real lux;Real)", 
            "title": "(asin n)"
        }, 
        {
            "location": "/lux_math/#atan-n", 
            "text": "(-  lux;Real lux;Real)", 
            "title": "(atan n)"
        }, 
        {
            "location": "/lux_math/#atan2-param-subject", 
            "text": "(-  lux;Real lux;Real lux;Real)", 
            "title": "(atan2 param subject)"
        }, 
        {
            "location": "/lux_math/#cbrt-n", 
            "text": "(-  lux;Real lux;Real)", 
            "title": "(cbrt n)"
        }, 
        {
            "location": "/lux_math/#ceil-n", 
            "text": "(-  lux;Real lux;Real)", 
            "title": "(ceil n)"
        }, 
        {
            "location": "/lux_math/#cos-n", 
            "text": "(-  lux;Real lux;Real)", 
            "title": "(cos n)"
        }, 
        {
            "location": "/lux_math/#cosh-n", 
            "text": "(-  lux;Real lux;Real)", 
            "title": "(cosh n)"
        }, 
        {
            "location": "/lux_math/#degrees-n", 
            "text": "(-  lux;Real lux;Real)", 
            "title": "(degrees n)"
        }, 
        {
            "location": "/lux_math/#e", 
            "text": "lux;Real", 
            "title": "e"
        }, 
        {
            "location": "/lux_math/#exp-n", 
            "text": "(-  lux;Real lux;Real)", 
            "title": "(exp n)"
        }, 
        {
            "location": "/lux_math/#floor-n", 
            "text": "(-  lux;Real lux;Real)", 
            "title": "(floor n)"
        }, 
        {
            "location": "/lux_math/#gcd-a-b", 
            "text": "Greatest Common Divisor.  (-  lux;Nat lux;Nat lux;Nat)", 
            "title": "(gcd a b)"
        }, 
        {
            "location": "/lux_math/#lcm-x-y", 
            "text": "Least Common Multiple.  (-  lux;Nat lux;Nat lux;Nat)", 
            "title": "(lcm x y)"
        }, 
        {
            "location": "/lux_math/#log-n", 
            "text": "(-  lux;Real lux;Real)", 
            "title": "(log n)"
        }, 
        {
            "location": "/lux_math/#pi", 
            "text": "lux;Real", 
            "title": "pi"
        }, 
        {
            "location": "/lux_math/#pow-param-subject", 
            "text": "(-  lux;Real lux;Real lux;Real)", 
            "title": "(pow param subject)"
        }, 
        {
            "location": "/lux_math/#radians-n", 
            "text": "(-  lux;Real lux;Real)", 
            "title": "(radians n)"
        }, 
        {
            "location": "/lux_math/#round-n", 
            "text": "(-  lux;Real lux;Real)", 
            "title": "(round n)"
        }, 
        {
            "location": "/lux_math/#sin-n", 
            "text": "(-  lux;Real lux;Real)", 
            "title": "(sin n)"
        }, 
        {
            "location": "/lux_math/#sinh-n", 
            "text": "(-  lux;Real lux;Real)", 
            "title": "(sinh n)"
        }, 
        {
            "location": "/lux_math/#sqrt-n", 
            "text": "(-  lux;Real lux;Real)", 
            "title": "(sqrt n)"
        }, 
        {
            "location": "/lux_math/#tan-n", 
            "text": "(-  lux;Real lux;Real)", 
            "title": "(tan n)"
        }, 
        {
            "location": "/lux_math/#tanh-n", 
            "text": "(-  lux;Real lux;Real)", 
            "title": "(tanh n)"
        }, 
        {
            "location": "/lux_math/#tau", 
            "text": "The same as 2*PI.  lux;Real", 
            "title": "tau"
        }, 
        {
            "location": "/lux_math_complex/", 
            "text": "lux/math/complex\n\n\n\n\nComplex arithmetic.\n\n\n\n\nTypes\n\n\nComplex\n\n\n(type: Complex\n  {#real lux;Real\n   #imaginary lux;Real})\n\n\n\n\nMacros\n\n\ncomplex\n\n\n## Complex literals.\n(complex real imaginary)\n\n## The imaginary part can be omitted if it's 0.\n(complex real)\n\n\n\n\nStructs\n\n\nCodec\nText,Complex\n\n\n(lux/control/codec;Codec lux;Text Complex)\n\n\nEq\nComplex\n\n\n(lux/control/eq;Eq Complex)\n\n\nValues\n\n\n(acos input)\n\n\n(-\n Complex Complex)\n\n\n(argument (^slots [#real #imaginary]))\n\n\n(-\n Complex lux;Real)\n\n\n(asin input)\n\n\n(-\n Complex Complex)\n\n\n(atan input)\n\n\n(-\n Complex Complex)\n\n\n(c.* param input)\n\n\n(-\n Complex Complex Complex)\n\n\n(c.*' param input)\n\n\n(-\n lux;Real Complex Complex)\n\n\n(c.+ param input)\n\n\n(-\n Complex Complex Complex)\n\n\n(c.- param input)\n\n\n(-\n Complex Complex Complex)\n\n\n(c./ param input)\n\n\n(-\n Complex Complex Complex)\n\n\n(c./' param subject)\n\n\n(-\n lux;Real Complex Complex)\n\n\n(c.= param input)\n\n\n(-\n Complex Complex lux;Bool)\n\n\n(c.abs subject)\n\n\n(-\n Complex lux;Real)\n\n\nc.negate\n\n\n(-\n Complex Complex)\n\n\nc.signum\n\n\n(-\n Complex Complex)\n\n\nconjugate\n\n\n(-\n Complex Complex)\n\n\n(cos subject)\n\n\n(-\n Complex Complex)\n\n\n(cosh subject)\n\n\n(-\n Complex Complex)\n\n\n(exp subject)\n\n\n(-\n Complex Complex)\n\n\ni\n\n\nComplex\n\n\n(log subject)\n\n\n(-\n Complex Complex)\n\n\n(nan? complex)\n\n\n(-\n Complex lux;Bool)\n\n\n(nth-roots nth input)\n\n\n(-\n lux;Nat Complex (lux;List Complex))\n\n\none\n\n\nComplex\n\n\n(pow param input)\n\n\n(-\n Complex Complex Complex)\n\n\n(pow' param input)\n\n\n(-\n lux;Real Complex Complex)\n\n\n(reciprocal (^slots [#real #imaginary]))\n\n\n(-\n Complex Complex)\n\n\n(sin subject)\n\n\n(-\n Complex Complex)\n\n\n(sinh subject)\n\n\n(-\n Complex Complex)\n\n\n(sqrt (^@ input (^slots [#real #imaginary])))\n\n\n(-\n Complex Complex)\n\n\n(sqrt-1z input)\n\n\n(-\n Complex Complex)\n\n\n(tan subject)\n\n\n(-\n Complex Complex)\n\n\n(tanh subject)\n\n\n(-\n Complex Complex)\n\n\nzero\n\n\nComplex", 
            "title": "Lux math complex"
        }, 
        {
            "location": "/lux_math_complex/#luxmathcomplex", 
            "text": "Complex arithmetic.", 
            "title": "lux/math/complex"
        }, 
        {
            "location": "/lux_math_complex/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_math_complex/#complex", 
            "text": "(type: Complex\n  {#real lux;Real\n   #imaginary lux;Real})", 
            "title": "Complex"
        }, 
        {
            "location": "/lux_math_complex/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_math_complex/#complex_1", 
            "text": "## Complex literals.\n(complex real imaginary)\n\n## The imaginary part can be omitted if it's 0.\n(complex real)", 
            "title": "complex"
        }, 
        {
            "location": "/lux_math_complex/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_math_complex/#codectextcomplex", 
            "text": "(lux/control/codec;Codec lux;Text Complex)", 
            "title": "Codec&lt;Text,Complex&gt;"
        }, 
        {
            "location": "/lux_math_complex/#eqcomplex", 
            "text": "(lux/control/eq;Eq Complex)", 
            "title": "Eq&lt;Complex&gt;"
        }, 
        {
            "location": "/lux_math_complex/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_math_complex/#acos-input", 
            "text": "(-  Complex Complex)", 
            "title": "(acos input)"
        }, 
        {
            "location": "/lux_math_complex/#argument-slots-real-imaginary", 
            "text": "(-  Complex lux;Real)", 
            "title": "(argument (^slots [#real #imaginary]))"
        }, 
        {
            "location": "/lux_math_complex/#asin-input", 
            "text": "(-  Complex Complex)", 
            "title": "(asin input)"
        }, 
        {
            "location": "/lux_math_complex/#atan-input", 
            "text": "(-  Complex Complex)", 
            "title": "(atan input)"
        }, 
        {
            "location": "/lux_math_complex/#c-param-input", 
            "text": "(-  Complex Complex Complex)", 
            "title": "(c.* param input)"
        }, 
        {
            "location": "/lux_math_complex/#c-param-input_1", 
            "text": "(-  lux;Real Complex Complex)", 
            "title": "(c.*' param input)"
        }, 
        {
            "location": "/lux_math_complex/#c-param-input_2", 
            "text": "(-  Complex Complex Complex)", 
            "title": "(c.+ param input)"
        }, 
        {
            "location": "/lux_math_complex/#c-param-input_3", 
            "text": "(-  Complex Complex Complex)", 
            "title": "(c.- param input)"
        }, 
        {
            "location": "/lux_math_complex/#c-param-input_4", 
            "text": "(-  Complex Complex Complex)", 
            "title": "(c./ param input)"
        }, 
        {
            "location": "/lux_math_complex/#c-param-subject", 
            "text": "(-  lux;Real Complex Complex)", 
            "title": "(c./' param subject)"
        }, 
        {
            "location": "/lux_math_complex/#c-param-input_5", 
            "text": "(-  Complex Complex lux;Bool)", 
            "title": "(c.= param input)"
        }, 
        {
            "location": "/lux_math_complex/#cabs-subject", 
            "text": "(-  Complex lux;Real)", 
            "title": "(c.abs subject)"
        }, 
        {
            "location": "/lux_math_complex/#cnegate", 
            "text": "(-  Complex Complex)", 
            "title": "c.negate"
        }, 
        {
            "location": "/lux_math_complex/#csignum", 
            "text": "(-  Complex Complex)", 
            "title": "c.signum"
        }, 
        {
            "location": "/lux_math_complex/#conjugate", 
            "text": "(-  Complex Complex)", 
            "title": "conjugate"
        }, 
        {
            "location": "/lux_math_complex/#cos-subject", 
            "text": "(-  Complex Complex)", 
            "title": "(cos subject)"
        }, 
        {
            "location": "/lux_math_complex/#cosh-subject", 
            "text": "(-  Complex Complex)", 
            "title": "(cosh subject)"
        }, 
        {
            "location": "/lux_math_complex/#exp-subject", 
            "text": "(-  Complex Complex)", 
            "title": "(exp subject)"
        }, 
        {
            "location": "/lux_math_complex/#i", 
            "text": "Complex", 
            "title": "i"
        }, 
        {
            "location": "/lux_math_complex/#log-subject", 
            "text": "(-  Complex Complex)", 
            "title": "(log subject)"
        }, 
        {
            "location": "/lux_math_complex/#nan-complex", 
            "text": "(-  Complex lux;Bool)", 
            "title": "(nan? complex)"
        }, 
        {
            "location": "/lux_math_complex/#nth-roots-nth-input", 
            "text": "(-  lux;Nat Complex (lux;List Complex))", 
            "title": "(nth-roots nth input)"
        }, 
        {
            "location": "/lux_math_complex/#one", 
            "text": "Complex", 
            "title": "one"
        }, 
        {
            "location": "/lux_math_complex/#pow-param-input", 
            "text": "(-  Complex Complex Complex)", 
            "title": "(pow param input)"
        }, 
        {
            "location": "/lux_math_complex/#pow-param-input_1", 
            "text": "(-  lux;Real Complex Complex)", 
            "title": "(pow' param input)"
        }, 
        {
            "location": "/lux_math_complex/#reciprocal-slots-real-imaginary", 
            "text": "(-  Complex Complex)", 
            "title": "(reciprocal (^slots [#real #imaginary]))"
        }, 
        {
            "location": "/lux_math_complex/#sin-subject", 
            "text": "(-  Complex Complex)", 
            "title": "(sin subject)"
        }, 
        {
            "location": "/lux_math_complex/#sinh-subject", 
            "text": "(-  Complex Complex)", 
            "title": "(sinh subject)"
        }, 
        {
            "location": "/lux_math_complex/#sqrt-input-slots-real-imaginary", 
            "text": "(-  Complex Complex)", 
            "title": "(sqrt (^@ input (^slots [#real #imaginary])))"
        }, 
        {
            "location": "/lux_math_complex/#sqrt-1z-input", 
            "text": "(-  Complex Complex)", 
            "title": "(sqrt-1z input)"
        }, 
        {
            "location": "/lux_math_complex/#tan-subject", 
            "text": "(-  Complex Complex)", 
            "title": "(tan subject)"
        }, 
        {
            "location": "/lux_math_complex/#tanh-subject", 
            "text": "(-  Complex Complex)", 
            "title": "(tanh subject)"
        }, 
        {
            "location": "/lux_math_complex/#zero", 
            "text": "Complex", 
            "title": "zero"
        }, 
        {
            "location": "/lux_math_ratio/", 
            "text": "lux/math/ratio\n\n\n\n\nRational arithmetic.\n\n\n\n\nTypes\n\n\nRatio\n\n\n(type: Ratio\n  {#numerator lux;Nat\n   #denominator lux;Nat})\n\n\n\n\nMacros\n\n\nratio\n\n\n## Rational literals.\n(ratio numerator denominator)\n\n## The denominator can be omitted if it's 1.\n(ratio numerator)\n\n\n\n\nStructs\n\n\nCodec\nText,Ratio\n\n\n(lux/control/codec;Codec lux;Text Ratio)\n\n\nEq\nRatio\n\n\n(lux/control/eq;Eq Ratio)\n\n\nNumber\nRatio\n\n\n(lux/control/number;Number Ratio)\n\n\nOrd\nRatio\n\n\n(lux/control/ord;Ord Ratio)\n\n\nValues\n\n\n(q.% param input)\n\n\n(-\n Ratio Ratio Ratio)\n\n\n(q.* param input)\n\n\n(-\n Ratio Ratio Ratio)\n\n\n(q.+ param input)\n\n\n(-\n Ratio Ratio Ratio)\n\n\n(q.- param input)\n\n\n(-\n Ratio Ratio Ratio)\n\n\n(q./ param input)\n\n\n(-\n Ratio Ratio Ratio)\n\n\n(q.\n param input)\n\n\n(-\n Ratio Ratio lux;Bool)\n\n\n(q.\n= param input)\n\n\n(-\n Ratio Ratio lux;Bool)\n\n\n(q.= param input)\n\n\n(-\n Ratio Ratio lux;Bool)\n\n\n(q.\n param input)\n\n\n(-\n Ratio Ratio lux;Bool)\n\n\n(q.\n= param input)\n\n\n(-\n Ratio Ratio lux;Bool)\n\n\n(q.max left right)\n\n\n(-\n Ratio Ratio Ratio)\n\n\n(q.min left right)\n\n\n(-\n Ratio Ratio Ratio)", 
            "title": "Lux math ratio"
        }, 
        {
            "location": "/lux_math_ratio/#luxmathratio", 
            "text": "Rational arithmetic.", 
            "title": "lux/math/ratio"
        }, 
        {
            "location": "/lux_math_ratio/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_math_ratio/#ratio", 
            "text": "(type: Ratio\n  {#numerator lux;Nat\n   #denominator lux;Nat})", 
            "title": "Ratio"
        }, 
        {
            "location": "/lux_math_ratio/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_math_ratio/#ratio_1", 
            "text": "## Rational literals.\n(ratio numerator denominator)\n\n## The denominator can be omitted if it's 1.\n(ratio numerator)", 
            "title": "ratio"
        }, 
        {
            "location": "/lux_math_ratio/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_math_ratio/#codectextratio", 
            "text": "(lux/control/codec;Codec lux;Text Ratio)", 
            "title": "Codec&lt;Text,Ratio&gt;"
        }, 
        {
            "location": "/lux_math_ratio/#eqratio", 
            "text": "(lux/control/eq;Eq Ratio)", 
            "title": "Eq&lt;Ratio&gt;"
        }, 
        {
            "location": "/lux_math_ratio/#numberratio", 
            "text": "(lux/control/number;Number Ratio)", 
            "title": "Number&lt;Ratio&gt;"
        }, 
        {
            "location": "/lux_math_ratio/#ordratio", 
            "text": "(lux/control/ord;Ord Ratio)", 
            "title": "Ord&lt;Ratio&gt;"
        }, 
        {
            "location": "/lux_math_ratio/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_math_ratio/#q-param-input", 
            "text": "(-  Ratio Ratio Ratio)", 
            "title": "(q.% param input)"
        }, 
        {
            "location": "/lux_math_ratio/#q-param-input_1", 
            "text": "(-  Ratio Ratio Ratio)", 
            "title": "(q.* param input)"
        }, 
        {
            "location": "/lux_math_ratio/#q-param-input_2", 
            "text": "(-  Ratio Ratio Ratio)", 
            "title": "(q.+ param input)"
        }, 
        {
            "location": "/lux_math_ratio/#q-param-input_3", 
            "text": "(-  Ratio Ratio Ratio)", 
            "title": "(q.- param input)"
        }, 
        {
            "location": "/lux_math_ratio/#q-param-input_4", 
            "text": "(-  Ratio Ratio Ratio)", 
            "title": "(q./ param input)"
        }, 
        {
            "location": "/lux_math_ratio/#q-param-input_5", 
            "text": "(-  Ratio Ratio lux;Bool)", 
            "title": "(q.&lt; param input)"
        }, 
        {
            "location": "/lux_math_ratio/#q-param-input_6", 
            "text": "(-  Ratio Ratio lux;Bool)", 
            "title": "(q.&lt;= param input)"
        }, 
        {
            "location": "/lux_math_ratio/#q-param-input_7", 
            "text": "(-  Ratio Ratio lux;Bool)", 
            "title": "(q.= param input)"
        }, 
        {
            "location": "/lux_math_ratio/#q-param-input_8", 
            "text": "(-  Ratio Ratio lux;Bool)", 
            "title": "(q.&gt; param input)"
        }, 
        {
            "location": "/lux_math_ratio/#q-param-input_9", 
            "text": "(-  Ratio Ratio lux;Bool)", 
            "title": "(q.&gt;= param input)"
        }, 
        {
            "location": "/lux_math_ratio/#qmax-left-right", 
            "text": "(-  Ratio Ratio Ratio)", 
            "title": "(q.max left right)"
        }, 
        {
            "location": "/lux_math_ratio/#qmin-left-right", 
            "text": "(-  Ratio Ratio Ratio)", 
            "title": "(q.min left right)"
        }, 
        {
            "location": "/lux_math_simple/", 
            "text": "lux/math/simple\n\n\n\n\nPolymorphic arithmetic operators that work with all primitive numeric types, without requiring any prefixes.\n\n\n\n\nMacros\n\n\n%\n\n\n*\n\n\n+\n\n\n-\n\n\n/\n\n\n\n\n=\n\n\n=\n\n\n\n\n=\n\n\ndec\n\n\neven?\n\n\ninc\n\n\nmax\n\n\nmin\n\n\nodd?", 
            "title": "Lux math simple"
        }, 
        {
            "location": "/lux_math_simple/#luxmathsimple", 
            "text": "Polymorphic arithmetic operators that work with all primitive numeric types, without requiring any prefixes.", 
            "title": "lux/math/simple"
        }, 
        {
            "location": "/lux_math_simple/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_math_simple/#_1", 
            "text": "", 
            "title": "%"
        }, 
        {
            "location": "/lux_math_simple/#_2", 
            "text": "", 
            "title": "*"
        }, 
        {
            "location": "/lux_math_simple/#_3", 
            "text": "", 
            "title": "+"
        }, 
        {
            "location": "/lux_math_simple/#-", 
            "text": "", 
            "title": "-"
        }, 
        {
            "location": "/lux_math_simple/#_4", 
            "text": "", 
            "title": "/"
        }, 
        {
            "location": "/lux_math_simple/#_5", 
            "text": "", 
            "title": "&lt;"
        }, 
        {
            "location": "/lux_math_simple/#_6", 
            "text": "", 
            "title": "&lt;="
        }, 
        {
            "location": "/lux_math_simple/#_7", 
            "text": "", 
            "title": "="
        }, 
        {
            "location": "/lux_math_simple/#_8", 
            "text": "", 
            "title": "&gt;"
        }, 
        {
            "location": "/lux_math_simple/#_9", 
            "text": "", 
            "title": "&gt;="
        }, 
        {
            "location": "/lux_math_simple/#dec", 
            "text": "", 
            "title": "dec"
        }, 
        {
            "location": "/lux_math_simple/#even", 
            "text": "", 
            "title": "even?"
        }, 
        {
            "location": "/lux_math_simple/#inc", 
            "text": "", 
            "title": "inc"
        }, 
        {
            "location": "/lux_math_simple/#max", 
            "text": "", 
            "title": "max"
        }, 
        {
            "location": "/lux_math_simple/#min", 
            "text": "", 
            "title": "min"
        }, 
        {
            "location": "/lux_math_simple/#odd", 
            "text": "", 
            "title": "odd?"
        }, 
        {
            "location": "/lux_pipe/", 
            "text": "lux/pipe\n\n\n\n\nComposable extensions to the piping macro |\n that enhance it with various abilities.\n\n\n\n\nMacros\n\n\n!\n\n\n## Loops for pipes.\n## Both the testing and calculating steps are pipes and must be given inside tuples.\n(|\n 1\n    (!\n [(i.\n 10)]\n        [i.inc]))\n\n\n\n\n%\n\n\n## Monadic pipes.\n## Each steps in the monadic computation is a pipe and must be given inside a tuple.\n(|\n 5\n    (%\n Id/Monad\n        [(i.* 3)]\n        [(i.+ 4)]\n        [i.inc]))\n\n\n\n\n\n\n## Parallel branching for pipes.\n## Allows to run multiple pipelines for a value and gives you a tuple of the outputs.\n(|\n 5\n    (\n [(i.* 10)]\n        [i.dec (i./ 2)]\n        [Int/encode]))\n\n## Will become: [50 2 \n5\n]\n\n\n\n\n?\n\n\n## Branching for pipes.\n## Both the tests and the bodies are piped-code, and must be given inside a tuple.\n## If a last else-pipe isn't given, the piped-argument will be used instead.\n(|\n 5\n    (?\n [i.even?] [(i.* 2)]\n        [i.odd?] [(i.* 3)]\n        [(_\n -1)]))\n\n\n\n\n@\n\n\n## Gives a name to the piped-argument, within the given expression.\n## If given no name, defaults to '@'.\n(|\n 5\n    (@\n X [(i.+ X X)]))\n\n(|\n 5\n    (@\n [(i.+ @ @)]))\n\n\n\n\n_\n\n\n## Ignores the piped argument, and begins a new pipe.\n(|\n 20\n    (i.* 3)\n    (i.+ 4)\n    (_\n 0 i.inc))\n\n\n\n\ncase\n\n\n## Pattern-matching for pipes.\n## The bodies of each branch are NOT pipes; just regular values.\n(|\n 5\n    (case\n 0 \nzero\n\n           1 \none\n\n           2 \ntwo\n\n           3 \nthree\n\n           4 \nfour\n\n           5 \nfive\n\n           6 \nsix\n\n           7 \nseven\n\n           8 \neight\n\n           9 \nnine\n\n           _ \n???\n))\n\n\n\n\n~\n\n\n## Non-updating pipes.\n## Will generate piped computations, but their results won't be used in the larger scope.\n(|\n 5\n    (~\n [int-to-nat %n log!])\n    (i.* 10))", 
            "title": "Lux pipe"
        }, 
        {
            "location": "/lux_pipe/#luxpipe", 
            "text": "Composable extensions to the piping macro |  that enhance it with various abilities.", 
            "title": "lux/pipe"
        }, 
        {
            "location": "/lux_pipe/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_pipe/#_1", 
            "text": "## Loops for pipes.\n## Both the testing and calculating steps are pipes and must be given inside tuples.\n(|  1\n    (!  [(i.  10)]\n        [i.inc]))", 
            "title": "!&gt;"
        }, 
        {
            "location": "/lux_pipe/#_2", 
            "text": "## Monadic pipes.\n## Each steps in the monadic computation is a pipe and must be given inside a tuple.\n(|  5\n    (%  Id/Monad\n        [(i.* 3)]\n        [(i.+ 4)]\n        [i.inc]))", 
            "title": "%&gt;"
        }, 
        {
            "location": "/lux_pipe/#_3", 
            "text": "## Parallel branching for pipes.\n## Allows to run multiple pipelines for a value and gives you a tuple of the outputs.\n(|  5\n    (  [(i.* 10)]\n        [i.dec (i./ 2)]\n        [Int/encode]))\n\n## Will become: [50 2  5 ]", 
            "title": "&amp;&gt;"
        }, 
        {
            "location": "/lux_pipe/#_4", 
            "text": "## Branching for pipes.\n## Both the tests and the bodies are piped-code, and must be given inside a tuple.\n## If a last else-pipe isn't given, the piped-argument will be used instead.\n(|  5\n    (?  [i.even?] [(i.* 2)]\n        [i.odd?] [(i.* 3)]\n        [(_  -1)]))", 
            "title": "?&gt;"
        }, 
        {
            "location": "/lux_pipe/#_5", 
            "text": "## Gives a name to the piped-argument, within the given expression.\n## If given no name, defaults to '@'.\n(|  5\n    (@  X [(i.+ X X)]))\n\n(|  5\n    (@  [(i.+ @ @)]))", 
            "title": "@&gt;"
        }, 
        {
            "location": "/lux_pipe/#_", 
            "text": "## Ignores the piped argument, and begins a new pipe.\n(|  20\n    (i.* 3)\n    (i.+ 4)\n    (_  0 i.inc))", 
            "title": "_&gt;"
        }, 
        {
            "location": "/lux_pipe/#case", 
            "text": "## Pattern-matching for pipes.\n## The bodies of each branch are NOT pipes; just regular values.\n(|  5\n    (case  0  zero \n           1  one \n           2  two \n           3  three \n           4  four \n           5  five \n           6  six \n           7  seven \n           8  eight \n           9  nine \n           _  ??? ))", 
            "title": "case&gt;"
        }, 
        {
            "location": "/lux_pipe/#_6", 
            "text": "## Non-updating pipes.\n## Will generate piped computations, but their results won't be used in the larger scope.\n(|  5\n    (~  [int-to-nat %n log!])\n    (i.* 10))", 
            "title": "~&gt;"
        }, 
        {
            "location": "/lux_random/", 
            "text": "lux/random\n\n\n\n\nPseudo-random number generation (PRNG) algorithms.\n\n\n\n\nTypes\n\n\nPRNG\n\n\nAn abstract way to represent any PRNG.\n\n\n(type: #rec PRNG\n  (-\n lux;Unit [PRNG lux;Nat]))\n\n\n\n\nRandom\n\n\nA producer of random values based on a PRNG.\n\n\n(type: (Random a)\n  (-\n PRNG [PRNG a]))\n\n\n\n\nStructs\n\n\nApplicative\nRandom\n\n\n(lux/control/applicative;Applicative Random)\n\n\nFunctor\nRandom\n\n\n(lux/control/functor;Functor Random)\n\n\nMonad\nRandom\n\n\n(lux/control/monad;Monad Random)\n\n\nValues\n\n\n(alt left right)\n\n\nHeterogeneous alternative combinator.\n\n\n\n\n(All [a b] (-\n (Random a) (Random b) (Random (| a b))))\n\n\n(array size value-gen)\n\n\n(All [a] (-\n lux;Nat (Random a) (Random (lux/data/struct/array;Array a))))\n\n\nbool\n\n\n(Random lux;Bool)\n\n\nchar\n\n\n(Random lux;Char)\n\n\ncomplex\n\n\n(Random lux/math/complex;Complex)\n\n\n(dict Hash\na\n size key-gen value-gen)\n\n\n(All [a b] (-\n (lux/control/hash;Hash a) lux;Nat (Random a) (Random b) (Random (lux/data/struct/dict;Dict a b))))\n\n\n(either left right)\n\n\nHomogeneous alternative combinator.\n\n\n\n\n(All [a] (-\n (Random a) (Random a) (Random a)))\n\n\n(filter pred gen)\n\n\nRetries the generator until the output satisfies a predicate.\n\n\n\n\n(All [a] (-\n (-\n a lux;Bool) (Random a) (Random a)))\n\n\nfrac\n\n\n(Random lux;Frac)\n\n\nint\n\n\n(Random lux;Int)\n\n\n(list size value-gen)\n\n\n(All [a] (-\n lux;Nat (Random a) (Random (lux;List a))))\n\n\n(maybe value-gen)\n\n\n(All [a] (-\n (Random a) (Random (lux;Maybe a))))\n\n\nnat\n\n\n(Random lux;Nat)\n\n\n(pcg-32 [inc seed])\n\n\nAn implementation of the PCG32 algorithm.\n\nFor more information, please see: http://www.pcg-random.org/\n\n\n\n\n(-\n [lux;Nat lux;Nat] PRNG)\n\n\n(queue size value-gen)\n\n\n(All [a] (-\n lux;Nat (Random a) (Random (lux/data/struct/queue;Queue a))))\n\n\nratio\n\n\n(Random lux/math/ratio;Ratio)\n\n\nreal\n\n\n(Random lux;Real)\n\n\n(rec gen)\n\n\nA combinator for producing recursive random generators.\n\n\n\n\n(All [a] (-\n (-\n (Random a) (Random a)) (Random a)))\n\n\n(run prng calc)\n\n\n(All [a] (-\n PRNG (Random a) [PRNG a]))\n\n\n(seq left right)\n\n\nSequencing combinator.\n\n\n\n\n(All [a b] (-\n (Random a) (Random b) (Random [a b])))\n\n\n(set Hash\na\n size value-gen)\n\n\n(All [a] (-\n (lux/control/hash;Hash a) lux;Nat (Random a) (Random (lux/data/struct/set;Set a))))\n\n\n(shuffle seed vector)\n\n\nShuffle a vector randomly based on a seed value.\n\n\n\n\n(All [a] (-\n lux;Nat (lux/data/struct/vector;Vector a) (lux/data/struct/vector;Vector a)))\n\n\n(stack size value-gen)\n\n\n(All [a] (-\n lux;Nat (Random a) (Random (lux/data/struct/stack;Stack a))))\n\n\n(text size)\n\n\n(-\n lux;Nat (Random lux;Text))\n\n\n(text' char-gen size)\n\n\n(-\n (Random lux;Char) lux;Nat (Random lux;Text))\n\n\n(vector size value-gen)\n\n\n(All [a] (-\n lux;Nat (Random a) (Random (lux/data/struct/vector;Vector a))))\n\n\n(xoroshiro-128+ [s0 s1])\n\n\nAn implementation of the Xoroshiro128+ algorithm.\n\nFor more information, please see: http://xoroshiro.di.unimi.it/\n\n\n\n\n(-\n [lux;Nat lux;Nat] PRNG)", 
            "title": "Lux random"
        }, 
        {
            "location": "/lux_random/#luxrandom", 
            "text": "Pseudo-random number generation (PRNG) algorithms.", 
            "title": "lux/random"
        }, 
        {
            "location": "/lux_random/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_random/#prng", 
            "text": "An abstract way to represent any PRNG.  (type: #rec PRNG\n  (-  lux;Unit [PRNG lux;Nat]))", 
            "title": "PRNG"
        }, 
        {
            "location": "/lux_random/#random", 
            "text": "A producer of random values based on a PRNG.  (type: (Random a)\n  (-  PRNG [PRNG a]))", 
            "title": "Random"
        }, 
        {
            "location": "/lux_random/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_random/#applicativerandom", 
            "text": "(lux/control/applicative;Applicative Random)", 
            "title": "Applicative&lt;Random&gt;"
        }, 
        {
            "location": "/lux_random/#functorrandom", 
            "text": "(lux/control/functor;Functor Random)", 
            "title": "Functor&lt;Random&gt;"
        }, 
        {
            "location": "/lux_random/#monadrandom", 
            "text": "(lux/control/monad;Monad Random)", 
            "title": "Monad&lt;Random&gt;"
        }, 
        {
            "location": "/lux_random/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_random/#alt-left-right", 
            "text": "Heterogeneous alternative combinator.  (All [a b] (-  (Random a) (Random b) (Random (| a b))))", 
            "title": "(alt left right)"
        }, 
        {
            "location": "/lux_random/#array-size-value-gen", 
            "text": "(All [a] (-  lux;Nat (Random a) (Random (lux/data/struct/array;Array a))))", 
            "title": "(array size value-gen)"
        }, 
        {
            "location": "/lux_random/#bool", 
            "text": "(Random lux;Bool)", 
            "title": "bool"
        }, 
        {
            "location": "/lux_random/#char", 
            "text": "(Random lux;Char)", 
            "title": "char"
        }, 
        {
            "location": "/lux_random/#complex", 
            "text": "(Random lux/math/complex;Complex)", 
            "title": "complex"
        }, 
        {
            "location": "/lux_random/#dict-hasha-size-key-gen-value-gen", 
            "text": "(All [a b] (-  (lux/control/hash;Hash a) lux;Nat (Random a) (Random b) (Random (lux/data/struct/dict;Dict a b))))", 
            "title": "(dict Hash&lt;a&gt; size key-gen value-gen)"
        }, 
        {
            "location": "/lux_random/#either-left-right", 
            "text": "Homogeneous alternative combinator.  (All [a] (-  (Random a) (Random a) (Random a)))", 
            "title": "(either left right)"
        }, 
        {
            "location": "/lux_random/#filter-pred-gen", 
            "text": "Retries the generator until the output satisfies a predicate.  (All [a] (-  (-  a lux;Bool) (Random a) (Random a)))", 
            "title": "(filter pred gen)"
        }, 
        {
            "location": "/lux_random/#frac", 
            "text": "(Random lux;Frac)", 
            "title": "frac"
        }, 
        {
            "location": "/lux_random/#int", 
            "text": "(Random lux;Int)", 
            "title": "int"
        }, 
        {
            "location": "/lux_random/#list-size-value-gen", 
            "text": "(All [a] (-  lux;Nat (Random a) (Random (lux;List a))))", 
            "title": "(list size value-gen)"
        }, 
        {
            "location": "/lux_random/#maybe-value-gen", 
            "text": "(All [a] (-  (Random a) (Random (lux;Maybe a))))", 
            "title": "(maybe value-gen)"
        }, 
        {
            "location": "/lux_random/#nat", 
            "text": "(Random lux;Nat)", 
            "title": "nat"
        }, 
        {
            "location": "/lux_random/#pcg-32-inc-seed", 
            "text": "An implementation of the PCG32 algorithm.\n\nFor more information, please see: http://www.pcg-random.org/  (-  [lux;Nat lux;Nat] PRNG)", 
            "title": "(pcg-32 [inc seed])"
        }, 
        {
            "location": "/lux_random/#queue-size-value-gen", 
            "text": "(All [a] (-  lux;Nat (Random a) (Random (lux/data/struct/queue;Queue a))))", 
            "title": "(queue size value-gen)"
        }, 
        {
            "location": "/lux_random/#ratio", 
            "text": "(Random lux/math/ratio;Ratio)", 
            "title": "ratio"
        }, 
        {
            "location": "/lux_random/#real", 
            "text": "(Random lux;Real)", 
            "title": "real"
        }, 
        {
            "location": "/lux_random/#rec-gen", 
            "text": "A combinator for producing recursive random generators.  (All [a] (-  (-  (Random a) (Random a)) (Random a)))", 
            "title": "(rec gen)"
        }, 
        {
            "location": "/lux_random/#run-prng-calc", 
            "text": "(All [a] (-  PRNG (Random a) [PRNG a]))", 
            "title": "(run prng calc)"
        }, 
        {
            "location": "/lux_random/#seq-left-right", 
            "text": "Sequencing combinator.  (All [a b] (-  (Random a) (Random b) (Random [a b])))", 
            "title": "(seq left right)"
        }, 
        {
            "location": "/lux_random/#set-hasha-size-value-gen", 
            "text": "(All [a] (-  (lux/control/hash;Hash a) lux;Nat (Random a) (Random (lux/data/struct/set;Set a))))", 
            "title": "(set Hash&lt;a&gt; size value-gen)"
        }, 
        {
            "location": "/lux_random/#shuffle-seed-vector", 
            "text": "Shuffle a vector randomly based on a seed value.  (All [a] (-  lux;Nat (lux/data/struct/vector;Vector a) (lux/data/struct/vector;Vector a)))", 
            "title": "(shuffle seed vector)"
        }, 
        {
            "location": "/lux_random/#stack-size-value-gen", 
            "text": "(All [a] (-  lux;Nat (Random a) (Random (lux/data/struct/stack;Stack a))))", 
            "title": "(stack size value-gen)"
        }, 
        {
            "location": "/lux_random/#text-size", 
            "text": "(-  lux;Nat (Random lux;Text))", 
            "title": "(text size)"
        }, 
        {
            "location": "/lux_random/#text-char-gen-size", 
            "text": "(-  (Random lux;Char) lux;Nat (Random lux;Text))", 
            "title": "(text' char-gen size)"
        }, 
        {
            "location": "/lux_random/#vector-size-value-gen", 
            "text": "(All [a] (-  lux;Nat (Random a) (Random (lux/data/struct/vector;Vector a))))", 
            "title": "(vector size value-gen)"
        }, 
        {
            "location": "/lux_random/#xoroshiro-128-s0-s1", 
            "text": "An implementation of the Xoroshiro128+ algorithm.\n\nFor more information, please see: http://xoroshiro.di.unimi.it/  (-  [lux;Nat lux;Nat] PRNG)", 
            "title": "(xoroshiro-128+ [s0 s1])"
        }, 
        {
            "location": "/lux_regex/", 
            "text": "lux/regex\n\n\nMacros\n\n\nregex\n\n\n## Create lexers using regular-expression syntax.\n## For example:\n## Literals\n(regex \na\n)\n\n## Wildcards\n(regex \n.\n)\n\n## Escaping\n(regex \n\\\\.\n)\n\n## Character classes\n(regex \n\\\\d\n)\n\n(regex \n\\\\p{Lower}\n)\n\n(regex \n[abc]\n)\n\n(regex \n[a-z]\n)\n\n(regex \n[a-zA-Z]\n)\n\n(regex \n[a-z\n[def]]\n)\n\n## Negation\n(regex \n[^abc]\n)\n\n(regex \n[^a-z]\n)\n\n(regex \n[^a-zA-Z]\n)\n\n(regex \n[a-z\n[^bc]]\n)\n\n(regex \n[a-z\n[^m-p]]\n)\n\n## Combinations\n(regex \naa\n)\n\n(regex \na?\n)\n\n(regex \na*\n)\n\n(regex \na+\n)\n\n## Specific amounts\n(regex \na{2}\n)\n\n## At least\n(regex \na{1,}\n)\n\n## At most\n(regex \na{,1}\n)\n\n## Between\n(regex \na{1,2}\n)\n\n## Groups\n(regex \na(.)c\n)\n\n(regex \na(b+)c\n)\n\n(regex \n(\\\\d{3})-(\\\\d{3})-(\\\\d{4})\n)\n\n(regex \n(\\\\d{3})-(?:\\\\d{3})-(\\\\d{4})\n)\n\n(regex \n(?\ncode\n\\\\d{3})-\\\\k\ncode\n-(\\\\d{4})\n)\n\n(regex \n(?\ncode\n\\\\d{3})-\\\\k\ncode\n-(\\\\d{4})-\\\\0\n)\n\n(regex \n(\\\\d{3})-((\\\\d{3})-(\\\\d{4}))\n)\n\n## Alternation\n(regex \na|b\n)\n\n(regex \na(.)(.)|b(.)(.)\n)", 
            "title": "Lux regex"
        }, 
        {
            "location": "/lux_regex/#luxregex", 
            "text": "", 
            "title": "lux/regex"
        }, 
        {
            "location": "/lux_regex/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_regex/#regex", 
            "text": "## Create lexers using regular-expression syntax.\n## For example:\n## Literals\n(regex  a )\n\n## Wildcards\n(regex  . )\n\n## Escaping\n(regex  \\\\. )\n\n## Character classes\n(regex  \\\\d )\n\n(regex  \\\\p{Lower} )\n\n(regex  [abc] )\n\n(regex  [a-z] )\n\n(regex  [a-zA-Z] )\n\n(regex  [a-z [def]] )\n\n## Negation\n(regex  [^abc] )\n\n(regex  [^a-z] )\n\n(regex  [^a-zA-Z] )\n\n(regex  [a-z [^bc]] )\n\n(regex  [a-z [^m-p]] )\n\n## Combinations\n(regex  aa )\n\n(regex  a? )\n\n(regex  a* )\n\n(regex  a+ )\n\n## Specific amounts\n(regex  a{2} )\n\n## At least\n(regex  a{1,} )\n\n## At most\n(regex  a{,1} )\n\n## Between\n(regex  a{1,2} )\n\n## Groups\n(regex  a(.)c )\n\n(regex  a(b+)c )\n\n(regex  (\\\\d{3})-(\\\\d{3})-(\\\\d{4}) )\n\n(regex  (\\\\d{3})-(?:\\\\d{3})-(\\\\d{4}) )\n\n(regex  (? code \\\\d{3})-\\\\k code -(\\\\d{4}) )\n\n(regex  (? code \\\\d{3})-\\\\k code -(\\\\d{4})-\\\\0 )\n\n(regex  (\\\\d{3})-((\\\\d{3})-(\\\\d{4})) )\n\n## Alternation\n(regex  a|b )\n\n(regex  a(.)(.)|b(.)(.) )", 
            "title": "regex"
        }, 
        {
            "location": "/lux_test/", 
            "text": "lux/test\n\n\n\n\nTools for unit \n property-based/generative testing.\n\n\n\n\nTypes\n\n\nSeed\n\n\nThe seed value used for random testing (if that feature is used).\n\n\n(type: Seed\n  lux;Nat)\n\n\n\n\nTest\n\n\nTests are asynchronous process which may fail.\n\n\n(type: Test\n  (lux/concurrency/promise;Promise (lux/data/error;Error lux;Unit)))\n\n\n\n\nMacros\n\n\nrun\n\n\n## Runs all the tests defined on the current module, and in all imported modules.\n(run)\n\n\n\n\ntest:\n\n\n## Macro for definint tests.\n(test: \nSimple macros and constructs\n\n  ($_ seq\n      (assert \nCan write easy loops for iterative programming.\n\n              (i.= 1000\n                   (loop [counter 0\n                          value 1]\n                     (if (i.\n 3 counter)\n                       (recur (i.inc counter) (i.* 10 value))\n                       value))))\n\n      (assert \nCan create lists easily through macros.\n\n              (and (case (list 1 2 3)\n                     (#lux;Cons1 (#lux;Cons2 (#lux;Cons3 #lux;Nil)))\n                     true\n\n                     _\n                     false)\n\n                   (case (list\n 1 2 3 (list 4 5 6))\n                     (#lux;Cons1 (#lux;Cons2 (#lux;Cons3 (#lux;Cons4 (#lux;Cons5 (#lux;Cons6 #lux;Nil))))))\n                     true\n\n                     _\n                     false)))\n\n      (assert \nCan have defaults for Maybe values.\n\n              (and (is \nyolo\n (default \nyolo\n\n                                #lux;None))\n\n                   (is \nlol\n (default \nyolo\n\n                               (#lux;Some\nlol\n)))))))\n\n## Also works with random generation of values for property-based testing.\n(test: \nAddition \n Substraction\n\n  [x (:: @ map \nprep\n rand-gen)\n   y (:: @ map \nprep\n rand-gen)]\n  (assert \n\n          (and (|\n x (- y) (+ y) (= x))\n               (|\n x (+ y) (- y) (= x)))))\n\n## By default, random tests will be tried 100 times, you can specify the amount you want:\n(test: \nAddition \n Substraction\n\n  #times +1234\n  [x (:: @ map \nprep\n rand-gen)\n   y (:: @ map \nprep\n rand-gen)]\n  (assert \n\n          (and (|\n x (- y) (+ y) (= x))\n               (|\n x (+ y) (- y) (= x)))))\n\n## If a test fails, you'll be shown a seed that you can then use to reproduce a failing scenario.\n(test: \nAddition \n Substraction\n\n  #seed +987654321\n  [x (:: @ map \nprep\n rand-gen)\n   y (:: @ map \nprep\n rand-gen)]\n  (assert \n\n          (and (|\n x (- y) (+ y) (= x))\n               (|\n x (+ y) (- y) (= x)))))\n\n\n\n\nValues\n\n\n(alt left right)\n\n\nAlternative combinator.\n\n\n\n\n(-\n Test Test Test)\n\n\n(assert message condition)\n\n\nCheck that a condition is true, and fail with the given message otherwise.\n\n\n\n\n(-\n lux;Text lux;Bool Test)\n\n\n(fail message)\n\n\n(All [a] (-\n lux;Text Test))\n\n\n(seq left right)\n\n\nSequencing combinator.\n\n\n\n\n(-\n Test Test Test)", 
            "title": "Lux test"
        }, 
        {
            "location": "/lux_test/#luxtest", 
            "text": "Tools for unit   property-based/generative testing.", 
            "title": "lux/test"
        }, 
        {
            "location": "/lux_test/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_test/#seed", 
            "text": "The seed value used for random testing (if that feature is used).  (type: Seed\n  lux;Nat)", 
            "title": "Seed"
        }, 
        {
            "location": "/lux_test/#test", 
            "text": "Tests are asynchronous process which may fail.  (type: Test\n  (lux/concurrency/promise;Promise (lux/data/error;Error lux;Unit)))", 
            "title": "Test"
        }, 
        {
            "location": "/lux_test/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_test/#run", 
            "text": "## Runs all the tests defined on the current module, and in all imported modules.\n(run)", 
            "title": "run"
        }, 
        {
            "location": "/lux_test/#test_1", 
            "text": "## Macro for definint tests.\n(test:  Simple macros and constructs \n  ($_ seq\n      (assert  Can write easy loops for iterative programming. \n              (i.= 1000\n                   (loop [counter 0\n                          value 1]\n                     (if (i.  3 counter)\n                       (recur (i.inc counter) (i.* 10 value))\n                       value))))\n\n      (assert  Can create lists easily through macros. \n              (and (case (list 1 2 3)\n                     (#lux;Cons1 (#lux;Cons2 (#lux;Cons3 #lux;Nil)))\n                     true\n\n                     _\n                     false)\n\n                   (case (list  1 2 3 (list 4 5 6))\n                     (#lux;Cons1 (#lux;Cons2 (#lux;Cons3 (#lux;Cons4 (#lux;Cons5 (#lux;Cons6 #lux;Nil))))))\n                     true\n\n                     _\n                     false)))\n\n      (assert  Can have defaults for Maybe values. \n              (and (is  yolo  (default  yolo \n                                #lux;None))\n\n                   (is  lol  (default  yolo \n                               (#lux;Some lol )))))))\n\n## Also works with random generation of values for property-based testing.\n(test:  Addition   Substraction \n  [x (:: @ map  prep  rand-gen)\n   y (:: @ map  prep  rand-gen)]\n  (assert  \n          (and (|  x (- y) (+ y) (= x))\n               (|  x (+ y) (- y) (= x)))))\n\n## By default, random tests will be tried 100 times, you can specify the amount you want:\n(test:  Addition   Substraction \n  #times +1234\n  [x (:: @ map  prep  rand-gen)\n   y (:: @ map  prep  rand-gen)]\n  (assert  \n          (and (|  x (- y) (+ y) (= x))\n               (|  x (+ y) (- y) (= x)))))\n\n## If a test fails, you'll be shown a seed that you can then use to reproduce a failing scenario.\n(test:  Addition   Substraction \n  #seed +987654321\n  [x (:: @ map  prep  rand-gen)\n   y (:: @ map  prep  rand-gen)]\n  (assert  \n          (and (|  x (- y) (+ y) (= x))\n               (|  x (+ y) (- y) (= x)))))", 
            "title": "test:"
        }, 
        {
            "location": "/lux_test/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_test/#alt-left-right", 
            "text": "Alternative combinator.  (-  Test Test Test)", 
            "title": "(alt left right)"
        }, 
        {
            "location": "/lux_test/#assert-message-condition", 
            "text": "Check that a condition is true, and fail with the given message otherwise.  (-  lux;Text lux;Bool Test)", 
            "title": "(assert message condition)"
        }, 
        {
            "location": "/lux_test/#fail-message", 
            "text": "(All [a] (-  lux;Text Test))", 
            "title": "(fail message)"
        }, 
        {
            "location": "/lux_test/#seq-left-right", 
            "text": "Sequencing combinator.  (-  Test Test Test)", 
            "title": "(seq left right)"
        }, 
        {
            "location": "/lux_type/", 
            "text": "lux/type\n\n\n\n\nBasic functionality for working with types.\n\n\n\n\nStructs\n\n\nEq\nType\n\n\n(lux/control/eq;Eq lux;Type)\n\n\nValues\n\n\n(application quant params)\n\n\n(-\n lux;Type (lux;List lux;Type) lux;Type)\n\n\n(apply-type type-func param)\n\n\n(-\n lux;Type lux;Type (lux;Maybe lux;Type))\n\n\n(exq size body)\n\n\n(-\n lux;Nat lux;Type lux;Type)\n\n\n(flatten-application type)\n\n\n(-\n lux;Type [lux;Type (lux;List lux;Type)])\n\n\n(flatten-exq type)\n\n\n(-\n lux;Type [lux;Nat lux;Type])\n\n\n(flatten-function type)\n\n\n(-\n lux;Type [(lux;List lux;Type) lux;Type])\n\n\n(flatten-tuple type)\n\n\n(-\n lux;Type (lux;List lux;Type))\n\n\n(flatten-univq type)\n\n\n(-\n lux;Type [lux;Nat lux;Type])\n\n\n(flatten-variant type)\n\n\n(-\n lux;Type (lux;List lux;Type))\n\n\n(function inputs output)\n\n\n(-\n (lux;List lux;Type) lux;Type lux;Type)\n\n\n(to-ast type)\n\n\n(-\n lux;Type lux;AST)\n\n\n(to-text type)\n\n\n(-\n lux;Type lux;Text)\n\n\n(tuple types)\n\n\n(-\n (lux;List lux;Type) lux;Type)\n\n\n(un-alias type)\n\n\n(-\n lux;Type lux;Type)\n\n\n(un-name type)\n\n\n(-\n lux;Type lux;Type)\n\n\n(univq size body)\n\n\n(-\n lux;Nat lux;Type lux;Type)\n\n\n(variant types)\n\n\n(-\n (lux;List lux;Type) lux;Type)", 
            "title": "Lux type"
        }, 
        {
            "location": "/lux_type/#luxtype", 
            "text": "Basic functionality for working with types.", 
            "title": "lux/type"
        }, 
        {
            "location": "/lux_type/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_type/#eqtype", 
            "text": "(lux/control/eq;Eq lux;Type)", 
            "title": "Eq&lt;Type&gt;"
        }, 
        {
            "location": "/lux_type/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_type/#application-quant-params", 
            "text": "(-  lux;Type (lux;List lux;Type) lux;Type)", 
            "title": "(application quant params)"
        }, 
        {
            "location": "/lux_type/#apply-type-type-func-param", 
            "text": "(-  lux;Type lux;Type (lux;Maybe lux;Type))", 
            "title": "(apply-type type-func param)"
        }, 
        {
            "location": "/lux_type/#exq-size-body", 
            "text": "(-  lux;Nat lux;Type lux;Type)", 
            "title": "(exq size body)"
        }, 
        {
            "location": "/lux_type/#flatten-application-type", 
            "text": "(-  lux;Type [lux;Type (lux;List lux;Type)])", 
            "title": "(flatten-application type)"
        }, 
        {
            "location": "/lux_type/#flatten-exq-type", 
            "text": "(-  lux;Type [lux;Nat lux;Type])", 
            "title": "(flatten-exq type)"
        }, 
        {
            "location": "/lux_type/#flatten-function-type", 
            "text": "(-  lux;Type [(lux;List lux;Type) lux;Type])", 
            "title": "(flatten-function type)"
        }, 
        {
            "location": "/lux_type/#flatten-tuple-type", 
            "text": "(-  lux;Type (lux;List lux;Type))", 
            "title": "(flatten-tuple type)"
        }, 
        {
            "location": "/lux_type/#flatten-univq-type", 
            "text": "(-  lux;Type [lux;Nat lux;Type])", 
            "title": "(flatten-univq type)"
        }, 
        {
            "location": "/lux_type/#flatten-variant-type", 
            "text": "(-  lux;Type (lux;List lux;Type))", 
            "title": "(flatten-variant type)"
        }, 
        {
            "location": "/lux_type/#function-inputs-output", 
            "text": "(-  (lux;List lux;Type) lux;Type lux;Type)", 
            "title": "(function inputs output)"
        }, 
        {
            "location": "/lux_type/#to-ast-type", 
            "text": "(-  lux;Type lux;AST)", 
            "title": "(to-ast type)"
        }, 
        {
            "location": "/lux_type/#to-text-type", 
            "text": "(-  lux;Type lux;Text)", 
            "title": "(to-text type)"
        }, 
        {
            "location": "/lux_type/#tuple-types", 
            "text": "(-  (lux;List lux;Type) lux;Type)", 
            "title": "(tuple types)"
        }, 
        {
            "location": "/lux_type/#un-alias-type", 
            "text": "(-  lux;Type lux;Type)", 
            "title": "(un-alias type)"
        }, 
        {
            "location": "/lux_type/#un-name-type", 
            "text": "(-  lux;Type lux;Type)", 
            "title": "(un-name type)"
        }, 
        {
            "location": "/lux_type/#univq-size-body", 
            "text": "(-  lux;Nat lux;Type lux;Type)", 
            "title": "(univq size body)"
        }, 
        {
            "location": "/lux_type/#variant-types", 
            "text": "(-  (lux;List lux;Type) lux;Type)", 
            "title": "(variant types)"
        }, 
        {
            "location": "/lux_type_auto/", 
            "text": "lux/type/auto\n\n\nMacros\n\n\n:::\n\n\n## Automatic structure selection (for type-class style polymorphism).\n## This feature layers type-class style polymorphism on top of Lux's signatures and structures.\n## When calling a polymorphic function, or using a polymorphic constant,\n## this macro will check the types of the arguments, and the expected type for the whole expression\n## and it will search in the local scope, the module's scope and the imports' scope\n## in order to find suitable structures to satisfy those requirements.\n## If a single alternative is found, that one will be used automatically.\n## If no alternative is found, or if more than one alternative is found (ambiguity)\n## a compile-time error will be raised, to alert the user.\n## Examples:\n## Nat equality\n(:: lux/data/number;Eq\nNat\n= x y)\n\n(::: = x y)\n\n## Can optionally add the prefix of the module where the signature was defined.\n(::: lux/control/eq;=x y)\n\n## (List Nat) equality\n(::: =\n     (lux/data/struct/list;n.range+1 +10)\n     (lux/data/struct/list;n.range+1 +10))\n\n## Functor map\n(::: map n.inc (lux/data/struct/list;n.range+0 +9))\n\n## Caveat emptor: You need to make sure to import the module of any structure you want to use.\n## Otherwise, this macro won't find it.", 
            "title": "Lux type auto"
        }, 
        {
            "location": "/lux_type_auto/#luxtypeauto", 
            "text": "", 
            "title": "lux/type/auto"
        }, 
        {
            "location": "/lux_type_auto/#macros", 
            "text": "", 
            "title": "Macros"
        }, 
        {
            "location": "/lux_type_auto/#_1", 
            "text": "## Automatic structure selection (for type-class style polymorphism).\n## This feature layers type-class style polymorphism on top of Lux's signatures and structures.\n## When calling a polymorphic function, or using a polymorphic constant,\n## this macro will check the types of the arguments, and the expected type for the whole expression\n## and it will search in the local scope, the module's scope and the imports' scope\n## in order to find suitable structures to satisfy those requirements.\n## If a single alternative is found, that one will be used automatically.\n## If no alternative is found, or if more than one alternative is found (ambiguity)\n## a compile-time error will be raised, to alert the user.\n## Examples:\n## Nat equality\n(:: lux/data/number;Eq Nat = x y)\n\n(::: = x y)\n\n## Can optionally add the prefix of the module where the signature was defined.\n(::: lux/control/eq;=x y)\n\n## (List Nat) equality\n(::: =\n     (lux/data/struct/list;n.range+1 +10)\n     (lux/data/struct/list;n.range+1 +10))\n\n## Functor map\n(::: map n.inc (lux/data/struct/list;n.range+0 +9))\n\n## Caveat emptor: You need to make sure to import the module of any structure you want to use.\n## Otherwise, this macro won't find it.", 
            "title": ":::"
        }, 
        {
            "location": "/lux_type_check/", 
            "text": "lux/type/check\n\n\n\n\nType-checking functionality.\n\n\nVery useful for writing advanced macros.\n\n\n\n\nTypes\n\n\nCheck\n\n\n(type: (Check a)\n  (-\n Context (lux/data/error;Error [Context a])))\n\n\n\n\nContext\n\n\n(type: Context\n  {#var-counter Id\n   #ex-counter Id\n   #bindings (lux/data/struct/dict;Dict Id (lux;Maybe lux;Type))\n   #fixpoints Fixpoints})\n\n\n\n\nFixpoints\n\n\n(type: Fixpoints\n  (lux;List [[lux;Type lux;Type] lux;Bool]))\n\n\n\n\nId\n\n\n(type: Id\n  lux;Nat)\n\n\n\n\nStructs\n\n\nApplicative\nCheck\n\n\n(lux/control/applicative;Applicative Check)\n\n\nFunctor\nCheck\n\n\n(lux/control/functor;Functor Check)\n\n\nMonad\nCheck\n\n\n(lux/control/monad;Monad Check)\n\n\nValues\n\n\n(check expected actual)\n\n\nType-check to ensure that the 'expected' type subsumes the 'actual' type.\n\n\n\n\n(-\n lux;Type lux;Type (Check lux;Unit))\n\n\n(checks? expected actual)\n\n\nA simple type-checking function that just returns a yes/no answer.\n\n\n\n\n(-\n lux;Type lux;Type lux;Bool)\n\n\n(clear-var id)\n\n\n(-\n Id (Check lux;Unit))\n\n\ncreate-var\n\n\n(Check [Id lux;Type])\n\n\n(delete-var id)\n\n\n(-\n Id (Check lux;Unit))\n\n\nexistential\n\n\nA producer of existential types.\n\n\n\n\n(Check [Id lux;Type])\n\n\n(fail message)\n\n\n(All [a] (-\n lux;Text (Check a)))\n\n\nfresh-context\n\n\nContext\n\n\nget-context\n\n\n(Check Context)\n\n\n(read-var id)\n\n\n(-\n Id (Check lux;Type))\n\n\n(run context proc)\n\n\n(All [a] (-\n Context (Check a) (lux/data/error;Error a)))\n\n\n(with-var k)\n\n\n(All [a] (-\n (-\n [Id lux;Type] (Check a)) (Check a)))\n\n\n(write-var id type)\n\n\n(-\n Id lux;Type (Check lux;Unit))", 
            "title": "Lux type check"
        }, 
        {
            "location": "/lux_type_check/#luxtypecheck", 
            "text": "Type-checking functionality.  Very useful for writing advanced macros.", 
            "title": "lux/type/check"
        }, 
        {
            "location": "/lux_type_check/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/lux_type_check/#check", 
            "text": "(type: (Check a)\n  (-  Context (lux/data/error;Error [Context a])))", 
            "title": "Check"
        }, 
        {
            "location": "/lux_type_check/#context", 
            "text": "(type: Context\n  {#var-counter Id\n   #ex-counter Id\n   #bindings (lux/data/struct/dict;Dict Id (lux;Maybe lux;Type))\n   #fixpoints Fixpoints})", 
            "title": "Context"
        }, 
        {
            "location": "/lux_type_check/#fixpoints", 
            "text": "(type: Fixpoints\n  (lux;List [[lux;Type lux;Type] lux;Bool]))", 
            "title": "Fixpoints"
        }, 
        {
            "location": "/lux_type_check/#id", 
            "text": "(type: Id\n  lux;Nat)", 
            "title": "Id"
        }, 
        {
            "location": "/lux_type_check/#structs", 
            "text": "", 
            "title": "Structs"
        }, 
        {
            "location": "/lux_type_check/#applicativecheck", 
            "text": "(lux/control/applicative;Applicative Check)", 
            "title": "Applicative&lt;Check&gt;"
        }, 
        {
            "location": "/lux_type_check/#functorcheck", 
            "text": "(lux/control/functor;Functor Check)", 
            "title": "Functor&lt;Check&gt;"
        }, 
        {
            "location": "/lux_type_check/#monadcheck", 
            "text": "(lux/control/monad;Monad Check)", 
            "title": "Monad&lt;Check&gt;"
        }, 
        {
            "location": "/lux_type_check/#values", 
            "text": "", 
            "title": "Values"
        }, 
        {
            "location": "/lux_type_check/#check-expected-actual", 
            "text": "Type-check to ensure that the 'expected' type subsumes the 'actual' type.  (-  lux;Type lux;Type (Check lux;Unit))", 
            "title": "(check expected actual)"
        }, 
        {
            "location": "/lux_type_check/#checks-expected-actual", 
            "text": "A simple type-checking function that just returns a yes/no answer.  (-  lux;Type lux;Type lux;Bool)", 
            "title": "(checks? expected actual)"
        }, 
        {
            "location": "/lux_type_check/#clear-var-id", 
            "text": "(-  Id (Check lux;Unit))", 
            "title": "(clear-var id)"
        }, 
        {
            "location": "/lux_type_check/#create-var", 
            "text": "(Check [Id lux;Type])", 
            "title": "create-var"
        }, 
        {
            "location": "/lux_type_check/#delete-var-id", 
            "text": "(-  Id (Check lux;Unit))", 
            "title": "(delete-var id)"
        }, 
        {
            "location": "/lux_type_check/#existential", 
            "text": "A producer of existential types.  (Check [Id lux;Type])", 
            "title": "existential"
        }, 
        {
            "location": "/lux_type_check/#fail-message", 
            "text": "(All [a] (-  lux;Text (Check a)))", 
            "title": "(fail message)"
        }, 
        {
            "location": "/lux_type_check/#fresh-context", 
            "text": "Context", 
            "title": "fresh-context"
        }, 
        {
            "location": "/lux_type_check/#get-context", 
            "text": "(Check Context)", 
            "title": "get-context"
        }, 
        {
            "location": "/lux_type_check/#read-var-id", 
            "text": "(-  Id (Check lux;Type))", 
            "title": "(read-var id)"
        }, 
        {
            "location": "/lux_type_check/#run-context-proc", 
            "text": "(All [a] (-  Context (Check a) (lux/data/error;Error a)))", 
            "title": "(run context proc)"
        }, 
        {
            "location": "/lux_type_check/#with-var-k", 
            "text": "(All [a] (-  (-  [Id lux;Type] (Check a)) (Check a)))", 
            "title": "(with-var k)"
        }, 
        {
            "location": "/lux_type_check/#write-var-id-type", 
            "text": "(-  Id lux;Type (Check lux;Unit))", 
            "title": "(write-var id type)"
        }
    ]
}